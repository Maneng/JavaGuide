Index: .idea/.gitignore
===================================================================
diff --git a/.idea/.gitignore b/.idea/.gitignore
deleted file mode 100644
--- a/.idea/.gitignore	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ /dev/null	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
@@ -1,5 +0,0 @@
-# 默认忽略的文件
-/shelf/
-/workspace.xml
-# 基于编辑器的 HTTP 客户端请求
-/httpRequests/
Index: docs/learn/mybatis/README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: true\nfooter: true\nbacktotop: true\ntitle: Mybatis\n---\n\n![](https://mybatis.org/images/mybatis-logo.png)\n\n# 什么是 MyBatis？[官方文档](https://mybatis.net.cn/)\n\nMyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。\n\n# 重构Mybatis博客\n\n最早使用Mybatis是在2016年,那时候学习只会用,根本不知道什么原理,不懂的原理的地方只能死记。搭建一个小的demo放到github,工作需要的时候就直接复制黏贴,虽然也能满足工作需要但是总感觉到不带劲。在找到工作后大概2017年时候就对Mybatis的源码进行了阅读，其实相对于Dubbo,Spring,之类的源码Mybatis的源码还是非常简单的,现在也经常推荐给刚开始学习看源码的同学。\n早在2019年小编就开始写Mybatis的博客了,那时候博客主要还是自己学习为主,现在回头看看,感觉有些粗糙。这里准备回炉重造一波。将原博客进行优化。对Mybaits的核心功能，核心处理类重新重构下博客。\n\n\n[![](https://img.shields.io/badge/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-mybatis--opensource--example-green)](https://github.com/lxchinesszz/mybatis-opensource-example)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/mybatis/README.md b/docs/learn/mybatis/README.md
--- a/docs/learn/mybatis/README.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/mybatis/README.md	(date 1655373430366)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/project/jmvn/jmvn-plugin.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: true\nfooter: true\nbacktotop: true\ntitle: 插件开发\n---\n\n::: tip jmvn instll 数据安装\n`jmvn` 一个好用的功能就是支持数据安装，这个功能是我比较喜欢的。因为在项目\n中开发过程中，经常会出现,表结构进行变更，可能是增加些表注释，增加个字段。这个时候就要同步来\n修改数据模型。是比较繁琐的。当你尝试过 `jmvn install` 功能后，这个问题就能彻底解决了。\n只需要运行 `jmvn install` 命令，数据模型就会同步更改。\n:::\n\n\n\n\n## 配置如下\n\n在你的项目 `.jmvn.json` 中添加如下。`jmvn` 会读取 `dbConfig` 中数据库的配置。\n写入到 `models` 中指定的目录 `path`。\n\n```json \n{\n  \"namespace\": [\n  ],\n  \"config\": {},\n  \"dbConfig\": {\n    \"host\": \"10.*.*.8\",\n    \"user\": \"root\",\n    \"password\": \"123456\",\n    \"database\": \"test\"\n  },\n  \"models\": [\n    {\n      \"suffix\": \"DO\",\n      \"tableName\": [\n        \"user\",\n        \"user_detail\"\n      ],\n      \"path\": \"example-dal/src/main/java/com/example/dal/entity\"\n    }\n  ]\n}\n```\n\n你可以在models中使用suffix添加Java文件的后缀名。\neg: user表，最终写成java文件为 UserDO\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/project/jmvn/jmvn-plugin.md b/docs/learn/project/jmvn/jmvn-plugin.md
--- a/docs/learn/project/jmvn/jmvn-plugin.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/project/jmvn/jmvn-plugin.md	(date 1655373430123)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/mybatis/PagePlugin.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: true\nfooter: true\npassword: 111\nbacktotop: true\ntitle: 第10篇:Mybatis分页插件设计\ncategory: Mybatis\n---\n<PageBanner/>\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/mybatis/PagePlugin.md b/docs/learn/mybatis/PagePlugin.md
--- a/docs/learn/mybatis/PagePlugin.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/mybatis/PagePlugin.md	(date 1655373430495)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/java/线程隔离.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 多线程之线程隔离\ncategory: Java进阶\n---\n\n\n![](https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png)\n\n**作者**: 西魏陶渊明\n**博客**: [https://blog.springlearn.cn/](https://blog.springlearn.cn/)\n\n::: tip 西魏陶渊明\n莫笑少年江湖梦，谁不少年梦江湖\n:::\n\n\n\n> [!TIP]\n> Java多线程之隔离技术ThreadLocal源码详解\n\n# Java多线程之隔离技术ThreadLocal源码详解\n\n**本篇文章是对ThreadLocal和InheritableThreadLocal,TransmittableThreadLocal的原理和源码进行深入分析,并举例讲解,其中前两个是JDK自带的。原理相对比较简单,其解决了单线程环境和在单线程中又创建线程(父子线程)中线程隔离的问题, TransmittableThreadLocal主要是解决,线程池中线程复用的场景。全文涉及到源码比较多阅读起来需要动脑筋思考,文章前半部分比较简单,后半部分比较困难,注意看代码注释。有不懂的可以留言。**\n\n![](http://p3.pstatp.com/large/pgc-image/1529412918151862e9151ba)\n\n以上是百度百科检索到的描述,相信通过上面的描述大家已经有了一个大概的了解,也相信大多数开发人员对这个类也是比较了解的,小编首先从原理开始讲解,开始吧!\n\n\n\n## 1. ThreadLocal 的原理是什么呢 ?\n\n其实就相当于一个Map集合,只不过这个Map 的Key是固定的,都是当前线程。\n**它能解决什么问题呢? 它存在的价值是什么呢?**\n\n- 它的存在就是为了线程隔离,让每个线程都能拥有属于自己的变量空间,线程之间互相不影响,为什么这么说呢? 看下代码就明白\n\n![](http://p1.pstatp.com/large/pgc-image/15294130178426b9ba68b45)\n\n通过上面的代码,可以发现其实ThreadLocal的set()方法就相当于\n![](http://p3.pstatp.com/large/pgc-image/15294130624201011b98c5d)\n\n之所以能起到线程隔离的作用,是因为Key就是当前的线程,所以每个线程的值都是隔离的，就像上图那样。\n\n其实并不是这样简单,之所以这样讲是为了,大家理解,其实这里的核心点在getMap中,从Thread中拿到一个Map，然后把value放到这个线程的map中\n\n因为每个线程都有一个自己的Map，也就是threadLocals。从而起到了线程隔离的作用\n\n![](http://p3.pstatp.com/large/pgc-image/1529413112969790858fd09)\n![](http://p3.pstatp.com/large/pgc-image/15294131130928909328961)\n\n## 2. 根据JDK原理,自己实现一个类似的\n\n![](http://p1.pstatp.com/large/pgc-image/1529413164762e67c5cae45)\n\n测试用例\n\n![](http://p1.pstatp.com/large/pgc-image/152941318828671381eeadc)\n\nResult:\n\n![](http://p3.pstatp.com/large/pgc-image/1529413210711e5595823b7)\n\n## 3. 单线程隔离\n什么是单线程隔离，这个是小编自己想的名字,其实是为了和父子线程区分开来，上面我们演示的都是属于在单一线程的情况下的使用。\n\n## 4.父子线程隔离\n什么是父子线程,需要解释下是，当我们创建一个线程,在线程内有去运行另一个线程的时候，作为子线程，如何去拿到父线程的私有属性呢?\n\n![](http://p3.pstatp.com/large/pgc-image/15294132718636bd88455c1)\n![](http://p3.pstatp.com/large/pgc-image/1529413271771989993f0f7)\n\n**我们怎么能拿到父线程的属性呢?**\n\n- 我们看前面标记的①,在get()时候有一个getMap(),在②有一个createMap方法\n  ![](http://p3.pstatp.com/large/pgc-image/1529413312687008ee8dca7)\n\n既然我们想拿到父线程的私有变量,那我们想在线程内创建线程时候,子线程能不能拿到父线程的的私有变量呢?\n\n**答案:当然是可以的,**\n\n**我们看Thread的源码的时候，可以找到这样两个属性**\n\n![](http://p1.pstatp.com/large/pgc-image/152941335122800b1bf88f6)\n那么它是如何实现继承的呢？我们可以在Thread的构造初始化init方法中，找到答案\n![](http://p3.pstatp.com/large/pgc-image/152941349280560c1a07a41)\n\n**看到这里我们分析，为什么ThreadLocal不能把父线程的私有变量传递给子线程?**\n\n1. 因为getMap和createMap都是对threadLocals进行操作，而threadLocals变量是不能被继承的。\n\n那么我们怎么去实现能传递呢?\n\n其实JDK是为我们实现了一套的,这个类就是InheritableThreadLocal,我们看他为什么能实现呢? 在看代码前，我们先自己思考下，是不是InheritableThreadLocal操作的是可继承的字段inheritableThreadLocals呢？答案也是肯定的\n\n![](http://p3.pstatp.com/large/pgc-image/15294135331813f5f2b77fd)\n\n在父线程内创建子线程的时候,子线程会在拿到父线程中的可继承的私有变量空间属性,也就是inheritableThreadLocals字段。\n\n**测试用例**\n\n![](http://p1.pstatp.com/large/pgc-image/152941358189410391e60ee)\n![](http://p3.pstatp.com/large/pgc-image/1529413587585a39d62e8a9)\n\n## 5. 线程池线程复用隔离\n\n在解决上面的问题后，我们来研究一个更有难度的问题,就是线程池线程复用的情况，怎么实现?\n\n为什么会遇到这个问题呢? 是因为在线程池中核心线程用完，并不会直接被回收,而是返回到线程池中，既然是重新利用，\n\n那么久不会重新创建线程，不会创建线程，父子之间就不会传递(如果这点没有明白,请继续看上面父子线程)。\n\n那么这时父子线程关系的ThreadLocal值传递已经没有意义。\n\n那么根据这个原理 ，我们继续来深入研究一波。\n\n![](http://p3.pstatp.com/large/pgc-image/152941368203290892a2f3c)\n![](http://p1.pstatp.com/large/pgc-image/1529413681980c41819c3c7)\n\n**解决方案是什么呢？**\n\n```\n在submit的时候把父线程copy给子线程\n\n在execute的时候结束后吧线程的ThreadLocal清理，就能解决这个问题\n```\n\n上面是网上搜到的答案，小编在证实上面答案的时候走了很多坑，根本没有找到清理的代码。最后小编发现,根本就没有清理的代码，而是重新赋值的形式来实现清理。\n\n到底是怎么来实现的呢？我们看TransmittableThreadLocal核心代码\n\n![](http://p1.pstatp.com/large/pgc-image/15294137835549160937407)\n\n1. 拿到创建线程时候的备份所有线程空间 【深复制】因为浅复制会结果会被修改\n\n2. 在执行时候将之前的备份恢复，将最新的值返回到backup变量中\n\n3. 执行完成后，再将backup最新的值重新写入到TransmittableThreadLocal中\n\n代码看起来很简洁，但是理解起来并不容易，每一步都有很多细节？我们一个一个来看\n\n1. copy方法。\n\nTransmittableThreadLocal内维护了一个holder保存所有TransmittableThreadLocal实例当set时候addValue方法\n\n![](http://p3.pstatp.com/large/pgc-image/15294137826850f0a707402)\n\n如果还没添加就添加，null在这里只是占位,没有其他用，因为this就包含了所有值\n![](http://p9.pstatp.com/large/pgc-image/15294137828914b65c93dde)\n\ncopy方法就是将holder里面维护的TransmittableThreadLocal实例和值通过深复制的形式返回，为什么是深复制,因为引用复制可能会在其他地方值被修改。\n\n2. backupAndSetToCopied方法从copide中恢复数据，然后新值返回出去，放到backup变量中\n\n3. 当线程已经执行完，在调用restoreBackup方法恢复backup变量中的值。\n\n这点理解其他优点困难，尽管小编已经很努力的讲清楚，但是可以通过下面一个例子可以将以上几种方法的用处讲清。\n\n#### 请注意文中的注释!\n\n\n![](http://p1.pstatp.com/large/pgc-image/152941378383811d7b64d7d)\n\n### 问题\n\n子线程修改变量空间值，是否会影响父线程值？\n\n答案：当然影响。因为子线程获取父线程的inheritableThreadLocals时候，方法ThreadLocal.createInheritedMap(parent.inheritableThreadLocals)其实是浅复制，也就是引用复制，其主要用途是从key.childValue，就是运行ThreadLocal的继承者，重写childValue方法，从而能改变父线程的本地空间ThreadLocal\n\n![](http://p3.pstatp.com/large/pgc-image/1529413784125d263a0718c)\n![](http://p9.pstatp.com/large/pgc-image/15294137837064b50ac393d)\n\n交给子类去实现了\n\n总结:\n\n- ThreadLocal 基础实现 (原理: 保存着线程中)\n\n- inheritableThreadLocals 实现了父子直接的传递 （原理: 可继承的变量空间,在Thread初始化init方法时候给子赋值）\n\n- TransmittableThreadLocal 实现线程复用 (原理: 在每次线程执行时候重新给ThreadLocal赋值)\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/java/线程隔离.md b/docs/learn/java/线程隔离.md
--- a/docs/learn/java/线程隔离.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/java/线程隔离.md	(date 1655373430222)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/project/jvm/README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: auto\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\nsidebarDepth: 3\ntitle: JVM调优\npassword: 123\nicon: zuanshi\n---\n\n## 一、JVM内存介绍\n\n## 1.1 堆空间\n\n## 1.2 非堆空间\n\n## 二、工具介绍\n\n## 1.1 Java原生工具\n\n### 1.1.1 jmap\n\n### 1.1.2 jstack\n\n## 1.2 二方可视化分析\n\n## 三、场景分析\n\n## 3.1 堆空间导致OOM\n\n## 3.2 非堆空间导致OOM\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/project/jvm/README.md b/docs/learn/project/jvm/README.md
--- a/docs/learn/project/jvm/README.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/project/jvm/README.md	(date 1655373430773)
@@ -1,8 +1,8 @@
 ---
 breadcrumb: false
 navbar: true
-sidebar: auto
-pageInfo: false
+sidebar: true
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
@@ -15,27 +15,216 @@
 title: JVM调优
 password: 123
 icon: zuanshi
+image: https://img.springlearn.cn/blog/learn_1654183539000.png
 ---
 
 ## 一、JVM内存介绍
 
+我们在学习JVM的内存管理的时候,我们的思维要跳出Java的局限。我们要这么理解。我们写的Java代码，是运行在JVM上的。
+如果让你来实现JVM那么。你会怎么处理呢?
+
+- 公共部分(堆heap)
+    - `Class字节码`是公共的,是共享的,所有线程都要认识字节码。
+    - `new的对象`是公共的,也是共享的,所有线程要都能认识这些实例对象,能读取到实例的数据。
+- 私有部分 (栈stock)
+    - Java中每个线程的执行中的代码，及代码中的局部变量等信息是私有的。每个线程之间都要维护一份。
+    - JVM虚拟栈和本地方法栈。
+    - 代码是怎么执行的,当然是一行一行执行。那么这一行一行的代码是放在哪里的呢? 是放在栈里面的。Java代码是在JVM来执行的。
+      所以这个栈，我们称为`JVM虚拟栈`。
+    - JVM中有些方法是调用其他语言实现的, 会使用`本地方法栈`。
+    - 那么谁来读取栈里面的数据,来出栈执行呢? 这叫做`PC寄存区`。
+
 ## 1.1 堆空间
 
+[JVM参数配置说明](/learn/project/jvm/JVM参数配置说明/)
+
+![](https://img.springlearn.cn/blog/learn_1654183539000.png)
+
+### 1.1.1 堆上信息
+
+![](https://img.springlearn.cn/blog/learn_1654188805000.png)
+
+`new` 出来的对象都在堆上。当堆的内存不足，会触发gc。[GC策略](/)。
+
+### 1.1.2 堆的相关配置
+
+| 配置参数                         | 说明                        | 示例                                                                                                                                                                             |
+|:-----------------------------|:--------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
+| `-Xmx`                       | 设置最大堆大小。                  | `-Xmx3550m`，设置JVM最大可用内存为3550 MB。                                                                                                                                               |
+| `-Xms`                       | 设置JVM初始内存。                | `-Xms3550m`，设置JVM初始内存为3550 MB。此值建议与`-Xmx`相同，避免每次垃圾回收完成后JVM重新分配内存。                                                                                                              |
+| `-Xmn2g`                     | 设置年轻代大小。                  | `-Xmn2g`，设置年轻代大小为2 GB。整个JVM内存大小=年轻代大小+年老代大小+持久代大小。持久代一般固定大小为64 MB，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。                                                            |
+| `-XX:NewRatio=n`             | 设置年轻代和年老代的比值。             | `-XX:NewRatio=4`，设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。如果设置为4，那么年轻代与年老代所占比值为1:4，年轻代占整个堆栈的1/5。                                                                                |
+| `-XX:SurvivorRatio=n`        | 年轻代中Eden区与两个Survivor区的比值。 | `-XX:SurvivorRatio=4`，设置年轻代中Eden区与Survivor区的大小比值。如果设置为4，那么两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6。                                                                    |
+| `-XX:MaxPermSize=n`          | 设置持久代大小。(JDK8以移除)         | `-XX:MaxPermSize=16m`，设置持久代大小为16 MB。                                                                                                                                           |
+ | `-XX:MaxTenuringThreshold=n` | 设置垃圾最大年龄。                 | `-XX:MaxTenuringThreshold=0`，设置垃圾最大年龄。如果设置为0，那么年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，提高了效率。如果将此值设置为较大值，那么年轻代对象会在Survivor区进行多次复制，增加了对象在年轻代的存活时间，增加在年轻代即被回收的概率。                  |
+
+### 1.1.3 常见问题
+
+- 大对象，无法释放，导致内存移除。
+**堆上的问题是比较容易排查的,可以通过工具把堆的信息给dump下来,然后就能直接定位到大对象,并通过调用链路定位到具体的代码,后面会介绍工具**
+
+
 ## 1.2 非堆空间
 
+![](https://img.springlearn.cn/blog/learn_1654188048000.png)
+
+### 1.2.1 非堆上的信息
+
+![](https://img.springlearn.cn/blog/learn_1654188805000.png)
+
+- `Thread` 配置线程的栈大小，决定了你调用链的深度。
+- `Metaspace` 可加载类的信息大小
+
+### 1.2.2 相关配置
+
+| 配置参数                         | 说明                        | 示例                                                                                                                                                                             |
+|:-----------------------------|:--------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
+| `-Xss`                       | 设置线程的栈大小。                 | `-Xss128k`，设置每个线程的栈大小为128 KB。**说明** JDK 5.0版本以后每个线程栈大小为1 MB，JDK 5.0以前版本每个线程栈大小为256 KB。请依据应用的线程所需内存大小进行调整。在相同物理内存下，减小该值可以生成更多的线程。但是操作系统对一个进程内的线程个数有一定的限制，无法无限生成，一般在3000个~5000个。 |
+| `-XX:MaxMetaspace=n`         | 设置元空间大小。        | `-XX:MaxMetaspace=16m`，设置元空间大小为16 MB。                                                                                                                                          |
+
+
 ## 二、工具介绍
 
-## 1.1 Java原生工具
+## 2.1 原生命令
+
+## 2.2 二方可视化分析
+
+### 2.2.1 idea 插件VisualGC
+
+![](https://img.springlearn.cn/blog/learn_1654189397000.png)
+
+![](https://img.springlearn.cn/blog/learn_1654189362000.png)
+
+### 2.2.2 JProfile
+
+[JProfile](https://www.ej-technologies.com/products/jprofiler/overview.html)
+
+![](https://img.springlearn.cn/blog/learn_1654189623000.png)
+
+### 2.2.3 Arthas 
+
+[Arthas](https://arthas.aliyun.com/zh-cn/)
+
+**Arthas功能是比较强大的,非常适合用于排查些疑难问题**
+
+![](https://img.springlearn.cn/blog/learn_1654189757000.png)
+
+## 2.3 GC日志学习
+
+- 开启GC日志参数 `-XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:+PrintGCDateStamps`
+
+### 2.3.1 年轻代GC
+
+- 首先是年轻代GC
 
-### 1.1.1 jmap
+```
+2022-06-03T00:13:48.801-0800: 
+0.369: 
+[GC (Allocation Failure) 
+[PSYoungGen: 7168K->1513K(8704K)] 7168K->4097K(49664K), 0.0183816 secs] 
+[Times: user=0.02 sys=0.01, real=0.02 secs] 
+```
 
-### 1.1.2 jstack
+- `2022-06-03T00:13:48.801-0800` -XX:+PrintGCDateStamps 打印日期
+- `0.369` -XX:+PrintGCDateStamps JVM启动到当前日期的总时长的时间戳形式
+- `[GC (Allocation Failure)` GC 原因(Allocation Failure) 分配失败
+  - ==Allocation Failure== 分配失败
+  - ==Metadata GC Threshold== 元空间不足
+  - ==Last ditch collection== 元空间GC后,仍然不足,即触发
+- `PSYoungGen` 年轻代GC
+- `Times` 耗时统计
+  - `user` 表示GC线程执行所使用的CPU总时间
+  - `sys` 进程在内核态消耗的CPU时间
+  - `real` 程序从开始到结束所用的时钟时间,这个时间接近 sys + user
 
-## 1.2 二方可视化分析
+**由于多核的原因,一般的GC事件中, real time是小于sys + user time的,因为一般是多个线程并发的去做GC,所以real time是要小于systuser time的**
+
+
+### 2.3.2 老年代GC
+
+老年代执行的是 Full GC，Full GC执行的时候，不止回收老年代，还会回收新生代和元数据空间
+
+```
+2022-06-03T00:22:27.829-0800:
+0.798: 
+[Full GC (Allocation Failure) 
+[PSYoungGen: 0K->0K(8704K)] 
+[ParOldGen: 36024K->36006K(40960K)] 36024K->36006K(49664K), 
+[Metaspace: 3078K->3078K(1056768K)], 0.2006976 secs] 
+[Times: user=1.11 sys=0.01, real=0.21 secs] 
+``` 
+
+- `2022-06-03T00:13:48.801-0800` -XX:+PrintGCDateStamps 打印日期
+- `0.369` -XX:+PrintGCDateStamps JVM启动到当前日期的总时长的时间戳形式
+- `[Full GC (Allocation Failure)` GC 原因(Allocation Failure) 分配失败 
+  - ==Allocation Failure== 分配失败
+  - ==Metadata GC Threshold== 元空间不足
+  - ==Last ditch collection== 元空间GC后,仍然不足,即触发
+- `PSYoungGen` 年轻代GC
+- `ParOldGen` 老年代GC
+- `Metaspace` 元空间或者叫方法区GC
+- `Times` 耗时统计
+  - `user` 表示GC线程执行所使用的CPU总时间
+  - `sys` 进程在内核态消耗的CPU时间
+  - `real` 程序从开始到结束所用的时钟时间,这个时间接近 sys + user
+
+
 
 ## 三、场景分析
 
 ## 3.1 堆空间导致OOM
 
-## 3.2 非堆空间导致OOM
+### 3.1.1 模拟堆栈
+
+### 3.1.2 现象
+
+1. 频繁进行fu gc
+2. 应用吞吐量下降
+3. 应用rt上升
+4. 方法调用报错**OutOfMemoryError : Java heap space**
+
+### 3.1.3 解决方案
+
+1. `jps` 找到应用 `pid`
+2. 把堆信息dump下来 `jmap -dump:format=b,file=heap.hprof  ${pid}`
+3. 打开JProfile 打开文件,直接看到大对象是哪个。
+
+![](https://img.springlearn.cn/blog/learn_1654191631000.png)
+
+## 3.2 CPU飙升
+
+### 3.2.1 解决方案
+
+1. 找到那些线程在阻塞 `jstack $PID`
+2. 如下片段发现线程都是 `BLOCKED` 状态, 调用点都在 `CPU.java:18`
+
+``` 
+"Thread-497" #508 prio=5 os_prio=31 tid=0x00007f88f58a0000 nid=0x41903 waiting for monitor entry [0x0000000326ea5000]
+   java.lang.Thread.State: BLOCKED (on object monitor)
+	at java.io.PrintStream.println(PrintStream.java:735)
+	- waiting to lock <0x00000007bce02720> (a java.io.PrintStream)
+	at learn.jvm.CPU.lambda$main$0(CPU.java:18)
+	at learn.jvm.CPU$$Lambda$1/189568618.run(Unknown Source)
+	at java.lang.Thread.run(Thread.java:748)
+
+"Thread-496" #507 prio=5 os_prio=31 tid=0x00007f88f589f800 nid=0x41a03 waiting for monitor entry [0x0000000326da2000]
+   java.lang.Thread.State: BLOCKED (on object monitor)
+	at java.io.PrintStream.println(PrintStream.java:735)
+	- waiting to lock <0x00000007bce02720> (a java.io.PrintStream)
+	at learn.jvm.CPU.lambda$main$0(CPU.java:18)
+	at learn.jvm.CPU$$Lambda$1/189568618.run(Unknown Source)
+	at java.lang.Thread.run(Thread.java:748)
+
+"Thread-495" #506 prio=5 os_prio=31 tid=0x00007f8905034000 nid=0x41c03 waiting for monitor entry [0x0000000326c9f000]
+   java.lang.Thread.State: BLOCKED (on object monitor)
+	at java.io.PrintStream.println(PrintStream.java:735)
+	- waiting to lock <0x00000007bce02720> (a java.io.PrintStream)
+	at learn.jvm.CPU.lambda$main$0(CPU.java:18)
+	at learn.jvm.CPU$$Lambda$1/189568618.run(Unknown Source)
+	at java.lang.Thread.run(Thread.java:748)
+```
+
+
+
+## 3.3 非堆空间导致OOM
 
Index: docs/learn/mybatis/MetaObject.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: true\nfooter: true\nbacktotop: true\ntitle: 第12篇:Mybatis中反射工具\ncategory: Mybatis\n---\n\n::: tip\n我们知道在java中基于反射的速度相对来说是很慢的, 但是如果对反射信息加了缓存性能可以提升1半以上, 如果在对反射设置了忽略安全检查, 性能更是会再提升1半。那么这个时候\n反射带来的性能问题基本可以忽略了。在Mybatis中关于反射的工具就可以很大程度来解决这个问题。本篇讲解下Mybatis中的工具类, 以后在项目中也可以直接使用。\n:::\n\n## 一、反射缓存类 Reflector\n\n所有的反射对象都会被生成一个 `Reflector`, Reflector 会把反射的方法、构造、字段、类型等信息都缓存起来。这样的设计主要是为了解决性能问题。\n\n```java \npublic class Reflector {\n\n  private final Class<?> type;\n  private final String[] readablePropertyNames;\n  private final String[] writablePropertyNames;\n  private final Map<String, Invoker> setMethods = new HashMap<>();\n  private final Map<String, Invoker> getMethods = new HashMap<>();\n  private final Map<String, Class<?>> setTypes = new HashMap<>();\n  private final Map<String, Class<?>> getTypes = new HashMap<>();\n  private Constructor<?> defaultConstructor;\n\n  private Map<String, String> caseInsensitivePropertyMap = new HashMap<>();\n  \n}  \n```\n\nReflectorFactory 反射工厂用来缓存反射对象 Reflector\n\n```java \n\npublic class DefaultReflectorFactory implements ReflectorFactory {\n  private boolean classCacheEnabled = true;\n  private final ConcurrentMap<Class<?>, Reflector> reflectorMap = new ConcurrentHashMap<>();\n  \n  @Override\n  public Reflector findForClass(Class<?> type) {\n    if (classCacheEnabled) {\n      // synchronized (type) removed see issue #461\n      return MapUtil.computeIfAbsent(reflectorMap, type, Reflector::new);\n    } else {\n      return new Reflector(type);\n    }\n  }\n  \n}  \n```\n\n## 二、通过反射操作对象 MetaObject\n\nMetaObject 从名字来看就是对对象进行操作,他的操作都是通过反射来进行的。\n\n## 2.1 简单对象操作\n\n```java \n    @AllArgsConstructor\n    @ToString\n    public static class Person {\n\n        @Getter(AccessLevel.PRIVATE)\n        @Setter(AccessLevel.PRIVATE)\n        private String name;\n\n        @Getter(AccessLevel.PRIVATE)\n        @Setter(AccessLevel.PRIVATE)\n        private int age;\n\n        @Getter(AccessLevel.PRIVATE)\n        @Setter(AccessLevel.PRIVATE)\n        private Long userId;\n    }\n\n    /**\n     * 通过反射给对象赋值\n     */\n    @Test\n    public void metaObjectTest() {\n        Person jay = new Person(\"周杰伦\", 40, 1L);\n        MetaObject jayMetaObject = MetaObject.forObject(jay, new DefaultObjectFactory(), new DefaultObjectWrapperFactory(), new DefaultReflectorFactory());\n        if (jayMetaObject.hasGetter(\"name\")) {\n            Class<?> name = jayMetaObject.getGetterType(\"name\");\n            // class java.lang.String\n            System.out.println(name);\n            jayMetaObject.setValue(\"name\", \"昆凌\");\n            // 昆凌\n            System.out.println(jayMetaObject.getValue(\"name\"));\n        }\n        // 昆凌\n        System.out.println(jay.getName());\n    }\n```\n\n## 2.2 嵌套对象操作\n\n\n```java \n    @AllArgsConstructor\n    @ToString\n    public static class Person {\n\n        @Getter(AccessLevel.PRIVATE)\n        @Setter(AccessLevel.PRIVATE)\n        private String name;\n\n        @Getter(AccessLevel.PRIVATE)\n        @Setter(AccessLevel.PRIVATE)\n        private int age;\n\n        @Getter(AccessLevel.PRIVATE)\n        @Setter(AccessLevel.PRIVATE)\n        private Long userId;\n    }\n    \n    @AllArgsConstructor\n    @ToString\n    public static class School {\n\n        @Getter(AccessLevel.PRIVATE)\n        @Setter(AccessLevel.PRIVATE)\n        private String name;\n\n        @Getter(AccessLevel.PRIVATE)\n        @Setter(AccessLevel.PRIVATE)\n        private Person person;\n    }\n    \n    @Test\n    public void fillChildObjectTest() {\n        School school = new School(\"西天大学\", new Person(\"周杰伦\", 40, 1L));\n        MetaObject schoolMetaObject = MetaObject.forObject(school, new DefaultObjectFactory(), new DefaultObjectWrapperFactory(), new DefaultReflectorFactory());\n        // 周杰伦\n        System.out.println(schoolMetaObject.getValue(\"person.name\"));\n        schoolMetaObject.setValue(\"person.name\", \"昆凌\");\n        // 昆凌\n        System.out.println(school.getPerson().getName());\n    }\n```\n\n## 三、获取反射信息 MetaClass\n\nMetaClass 主要是对 Reflector信息的一个包装并提供些更高级的操作。如跟嵌套类赋值\n\n```java \n    @Test\n    public void metaClassTest() throws Exception {\n        MetaClass metaClass = MetaClass.forClass(School.class, new DefaultReflectorFactory());\n        // class com.test.tool.MetaObjectTest$Person\n        System.out.println(metaClass.getGetterType(\"person\"));\n\n        School school = new School();\n        Invoker setNameInvoker = metaClass.getSetInvoker(\"name\");\n        // 通过反射给空对象赋值\n        setNameInvoker.invoke(school, new Object[]{\"Jay\"});\n\n        // 通过反射获取空对象\n        Invoker getNameInvoker = metaClass.getGetInvoker(\"name\");\n        // Jay\n        System.out.println(getNameInvoker.invoke(school, new Object[]{}));\n    }\n```\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/mybatis/MetaObject.md b/docs/learn/mybatis/MetaObject.md
--- a/docs/learn/mybatis/MetaObject.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/mybatis/MetaObject.md	(date 1655373430410)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/other/zookeeper.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: false\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: Zookeeper实践\narticle: true\n---\n\n\n## 一、Zookeeper介绍\n\n## 1.1 配置管理\n\n在我们的应用中除了代码外，还有一些就是各种配置。比如数据库连接等。一般我们都是使用配置文件的方式，在代码中引入这些配置文件。但是当我们只有一种配置，只有一台服务器，并且不经常修改的时候，使用配置文件是一个很好的做法，但是如果我们配置非常多，有很多服务器都需要这个配置，而且还可能是动态的话使用配置文件就不是个好主意了。这个时候往往需要寻找一种集中管理配置的方法，我们在这个集中的地方修改了配置，所有对这个配置感兴趣的都可以获得变更。比如我们可以把配置放在数据库里，然后所有需要配置的服务都去这个数据库读取配置。\n\n## 1.2 名字服务\n\n名字服务这个就很好理解了。比如为了通过网络访问一个系统，我们得知道对方的IP地址，但是IP地址对人非常不友好，这个时候我们就需要使用域名来访问。但是计算机是不能是别域名的。怎么办呢？如果我们每台机器里都备有一份域名到IP地址的映射，这个倒是能解决一部分问题，但是如果域名对应的IP发生变化了又该怎么办呢？于是我们有了DNS这个东西。我们只需要访问一个大家熟知的(known)的点，它就会告诉你这个域名对应的IP是什么。在我们的应用中也会存在很多这类问题，特别是在我们的服务特别多的时候，如果我们在本地保存服务的地址的时候将非常不方便，但是如果我们只需要访问一个大家都熟知的访问点，这里提供统一的入口，那么维护起来将方便得多了。\n分布式锁\n\n## 1.3 集群管理\n\n在分布式的集群中，经常会由于各种原因，比如硬件故障，软件故障，网络问题，有些节点会进进出出。有新的节点加入进来，也有老的节点退出集群。这个时候，集群中其他机器需要感知到这种变化，然后根据这种变化做出对应的决策。比如我们是一个分布式存储系统，有一个中央控制节点负责存储的分配，当有新的存储进来的时候我们要根据现在集群目前的状态来分配存储节点。这个时候我们就需要动态感知到集群目前的状态。还有，比如一个分布式的SOA架构中，服务是一个集群提供的，当消费者访问某个服务时，就需要采用某种机制发现现在有哪些节点可以提供该服务(这也称之为服务发现，比如Alibaba开源的SOA框架Dubbo就采用了Zookeeper作为服务发现的底层机制)。还有开源的Kafka队列就采用了Zookeeper作为Cosnumer的上下线管理。\n\n## 二、本地安装运行\n\n## 2.1 Mac环境部署\n\n```\n// 查询\nbrew search zookeeper\n// 安装\nbrew install zookeeper\n// 运行\nbrew services start zookeeper\n// 运行成功了\n==> Successfully started `zookeeper` (label: homebrew.mxcl.zookeeper)\n```\n\n## 2.2 Windows环境部署\n\n1. [下载安装包](http://mirror.bit.edu.cn/apache/zookeeper/zookeeper-3.4.12/)\n2. 运行 `启动zkServer.sh  | zkServer.cmd`\n\n\n## 三、项目实践\n\n## 3.1 引入依赖\n\n```xml \n        <!-- 对zookeeper的底层api的一些封装 -->\n        <dependency>\n            <groupId>org.apache.curator</groupId>\n            <artifactId>curator-framework</artifactId>\n            <version>2.12.0</version>\n        </dependency>\n\n\n        <!-- 提供一些客户端的操作，例如重试策略等 -->\n        <dependency>\n            <groupId>org.apache.curator</groupId>\n            <artifactId>curator-client</artifactId>\n            <version>2.13.0</version>\n        </dependency>\n\n\n        <!-- 封装了一些高级特性，如：Cache事件监听、选举、分布式锁、分布式计数器、分布式Barrier等 -->\n        <dependency>\n            <groupId>org.apache.curator</groupId>\n            <artifactId>curator-recipes</artifactId>\n            <version>2.12.0</version>\n        </dependency>\n```\n\n## 3.2 Curator API\n\n:::info\nCurator是Netflix公司开源的一套zookeeper客户端框架，解决了很多Zookeeper客户端非常底层的细节开发工作，包括连接重连、反复注册Watcher和NodeExistsException异常等等。Patrixck Hunt（Zookeeper）以一句“Guava is to Java that Curator to Zookeeper”给Curator予高度评价。\n:::\n\n==Curator包含了几个包：==\n\n- curator-framework：对zookeeper的底层api的一些封装\n- curator-client：提供一些客户端的操作，例如重试策略等\n- curator-recipes：封装了一些高级特性，如：Cache事件监听、选举、分布式锁、分布式计数器、分布式Barrier等\n\n### 3.2.1 创建会话\n\n\n1.使用静态工程方法创建客户端\n\n```\nRetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);\nCuratorFramework client =\nCuratorFrameworkFactory.newClient(\n                        connectionInfo,\n                        5000,\n                        3000,\n                        retryPolicy);\n```\n\n**newClient静态工厂方法包含四个主要参数：**\n\n参数名 | 说明\n---|---\nconnectionString | 服务器列表，格式host1:port1,host2:port2,...\nretryPolicy | 重试策略,内建有四种重试策略,也可以自行实现RetryPolicy接口\nsessionTimeoutMs | 会话超时时间，单位毫秒，默认60000ms\nconnectionTimeoutMs | 连接创建超时时间，单位毫秒，默认60000ms\n\n---\n\n2.使用Fluent风格的Api创建会话\n核心参数变为流式设置，一个列子如下\n\n```\nRetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);\n        CuratorFramework client =\n        CuratorFrameworkFactory.builder()\n                .connectString(connectionInfo)\n                .sessionTimeoutMs(5000)\n                .connectionTimeoutMs(5000)\n                .retryPolicy(retryPolicy)\n                .build();。\n```\n---\n\n3.创建包含隔离命名空间的会话\n为了实现不同的Zookeeper业务之间的隔离，需要为每个业务分配一个独立的命名空间（NameSpace），即指定一个Zookeeper的根路径（官方术语：为Zookeeper添加“Chroot”特性）。例如（下面的例子）当客户端指定了独立命名空间为“/base”，那么该客户端对Zookeeper上的数据节点的操作都是基于该目录进行的。通过设置Chroot可以将客户端应用与Zookeeper服务端的一课子树相对应，在多个应用共用一个Zookeeper集群的场景下，这对于实现不同应用之间的相互隔离十分有意义。\n\n```\nRetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);\n        CuratorFramework client =\n        CuratorFrameworkFactory.builder()\n                .connectString(connectionInfo)\n                .sessionTimeoutMs(5000)\n                .connectionTimeoutMs(5000)\n                .retryPolicy(retryPolicy)\n                .namespace(\"base\")\n                .build();\n\n```\n\n4. 启动客户端\n当创建会话成功，得到client的实例然后可以直接调用其start( )方法：\n\n`client.start();`\n\n\n### 3.2.2 添加监听器\n\n```java \n/**\n   * 只能监听某一个节点的变化\n   *\n   * @throws Exception\n   */\n  @Test\n  public void nodeCacheListenerTest() throws Exception {\n    ExponentialBackoffRetry exponentialBackoffRetry = new ExponentialBackoffRetry(1000, 3);\n    CuratorFramework client = CuratorFrameworkFactory.newClient(connect_info,\n      exponentialBackoffRetry);\n    client.start();\n    client.usingNamespace(\"dubboz\");\n\n    final NodeCache cache = new NodeCache(client, ROOT_PATH);\n\n    NodeCacheListener listener = new NodeCacheListener() {\n      public void nodeChanged() throws Exception {\n        ChildData data = cache.getCurrentData();\n        if (null != data) {\n          System.out.println(\"节点数据：\" + new String(cache.getCurrentData().getData()));\n        } else {\n          System.out.println(\"节点被删除!\");\n        }\n      }\n    };\n    cache.getListenable().addListener(listener);\n    cache.start();\n\n    client.create().creatingParentsIfNeeded().forPath(ROOT_PATH);\n    client.setData().forPath(ROOT_PATH, \"01\".getBytes());\n    Thread.sleep(100);\n    client.setData().forPath(ROOT_PATH, \"02\".getBytes());\n    Thread.sleep(100);\n    client.delete().deletingChildrenIfNeeded().forPath(ROOT_PATH);\n    Thread.sleep(1000 * 2);\n    cache.close();\n    client.close();\n    System.out.println(\"OK!\");\n  }\n```\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/other/zookeeper.md b/docs/learn/other/zookeeper.md
--- a/docs/learn/other/zookeeper.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/other/zookeeper.md	(date 1655373430147)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: false
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/tools/reactor/README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\nsidebarDepth: 3\ntitle: Reactive 反应式编程\n---\n\n::: tip 反应式编程\nreactive 是一种新的编程思想, 如同名字一样, 反应式编程。而Reactor 是一个工具包，类似于\nSpring一样。这点我们可以直接在Spring的官网上可以看到。本篇基于小编自己的学习进行总结。\n:::\n\n![](https://img.springlearn.cn/blog/learn_1651411884000.png)\n\n## 一、提出问题\n\n目前来说反应式编程在Java行业其实不是很流行, 其原因1在于传统的编程模型已经根深蒂固。虽然阻塞但是其实对于业务开发\n并不是一个很大的痛点。其2新的编程思想具有学习成本，但是又不是特别的痛，所以没有引起关注。下面我们来带着问题来学习吧。\n\n## 1.1 什么是反应式编程?\n\n哎，可能因为都是从外国翻译过来的缘故，总喜欢翻译写高大上，且晦涩难懂的文字进行描述，搞得大多数程序猿一头雾水。但是没办法，\n谁让你不主动去学习原文，而要吃一些大牛的二手翻译资料呢。所以我们就要最这些二手资料进行重读，并且深入思考，来总结出自己的理解。\n小编理解，所谓反应式编程，简单来说就是基于事件编程，由事件去驱动。比如我们servlet api，传统的方式servlet 线程是阻塞线程，\n如果方法没有执行完成，那么servlet线程会一直在阻塞等待。从而会导致不能接受更多的外部请求。而如果要使用反应式编程\n\n## 1.2 反应式编程中背压指得是什么?\n\n我也不知道为什么称背压，如果单从这个词汇来说，想死都想不通。什么鬼玩意呀。现在我们忽略这个sb的词汇。直接来说他的含义。\n要想搞明白这个，先知道事件驱动是如何设计的。首先有一个事件发送者，和一个事件处理者。传统的方式是事件处理者被动的来接受\n事件发送者，发起的事件，并进行处理，而在reactor中，事件的处理者不仅可以被动的接受，同时也支持主动的拉去事件。于是这种\n能力被称为背压。在高大上的解释就是，这能实现组件之间的弹性。\n\n## 1.3 反应式编程好处是什么?\n\n我们直接看官网的说明，然后进行白话翻译。\n\n> Reactive systems better utilize modern processors. Also, the inclusion of back-pressure in reactive programming\n> ensures better resilience between decoupled components.\n\n直白点就是可以充分的利用其cpu多核多线程的处理能力, 另外背压的能力,使组件知道当前的负载,动态的确定自己还能接受的任务数量,称之为弹性。\n\n## 二、Reactor 核心类\n\n这种编程思想其实还是值得学习的，因为基于事件来驱动，确实可以充分的利用其cpu多核多线程的处理能力。充分压榨cpu的能力。\n其实我们在很多地方都能看到类似的设计思想。eg: RxJava, Netty。\n下面我们就学习下如何使用吧。\n\n## 2.1 Publisher 发布者\n\n发布者只有一个接口,提供订阅能力。\n\n```java \npublic interface Publisher<T> {\n    // 绑定一个订阅者\n    public void subscribe(Subscriber<? super T> s);\n}\n```\n\n## 2.2 Subscriber 订阅者\n\n订阅者主要处理发布者发布的信息\n\n```java \npublic interface Subscriber<T> {\n    // 确定订阅关系\n    public void onSubscribe(Subscription s);\n    // 处理数据\n    public void onNext(T t);\n    // 错误处理\n    public void onError(Throwable t);\n    // 当事件处理完时触发\n    public void onComplete();\n}\n```\n\n## 2.3 Subscription 订阅关系\n\n订阅关系，可以取消订阅，通知可以实现拉去能力。\n\n```java \npublic interface Subscription {\n    // 获取指定数量的数据\n    public void request(long n);\n    // 取消订阅关系\n    public void cancel();\n}\n```\n\n## 2.4 Sink 数据池\n\nSink#next会将数据放入池中，由Sink缓存或直接发送给订阅者。\n\nMono和Flux分别提供了create和generate的方法,用来绑定事件发射器 Sink。开发者可以利用Sink来\n生产事件数据，然后发送给订阅者。\n\n## 三、事件模式\n\nPush推模式，PUSH_PULL混合模式\n\n```java \nenum CreateMode {\n\tPUSH_ONLY, PUSH_PULL\n}\n```\n\n## 3.1 Pull 模式\n\ngenerate 方法适用于拉去模式，当订阅者调用Subscription#request,则从Sink#next生产一条数据。\n如下两个代码示例。\n\n```java \n    @Test\n    @DisplayName(\"Flux Pull模式 Integer.MAX_VALUE\")\n    public void testFluxPull() {\n        Flux.generate((Consumer<SynchronousSink<Integer>>) sink -> {\n                    int k = (int) (Math.random() * 10);\n                    sink.next(k);\n                })\n                // 默认获取 request(Integer.MAX_VALUE)\n                .subscribe(integer -> System.out.println(\"Pull:\" + integer));\n    }\n\n    @Test\n    @DisplayName(\"Flux Pull模式 request调用一次,则调用Sink生产一次\")\n    public void testFluxPullTwo() {\n        Flux.generate((Consumer<SynchronousSink<Integer>>) sink -> {\n                    int k = (int) (Math.random() * 10);\n                    sink.next(k);\n                })\n                .subscribe(new Subscriber<Integer>() {\n                    Subscription subscription;\n\n                    private int count;\n\n                    @Override\n                    public void onSubscribe(Subscription s) {\n                        this.subscription = s;\n                        // 订阅时候,生产1条数据\n                        this.subscription.request(1);\n                    }\n\n                    @Override\n                    public void onNext(Integer integer) {\n                        count++;\n                        System.out.println(\"处理:\" + integer);\n                        // 在处理1次，当第二次处理时候,就不拉数据了\n                        if (count < 2) {\n                            this.subscription.request(1);\n                        }\n                    }\n\n                    @Override\n                    public void onError(Throwable t) {\n                        System.out.println(\"onError\");\n                    }\n\n                    @Override\n                    public void onComplete() {\n                        System.out.println(\"onComplete\");\n                    }\n                });\n    }\n```\n\n``` \n处理:3\n处理:1\n```\n\n## 3.2 Push 模式\n\n发布者主动推动数据,跟Pull的区别是。他不会随着,订阅者调用Subscription#request,而从Sink#next生产一条数据。\n只有订阅时候Subscription#request,Sink只会执行一次\n\n```java \n    @Test\n    @DisplayName(\"Flux Push模式\")\n    public void testFluxPush() {\n        Flux.create((Consumer<FluxSink<Integer>>) sink -> {\n            int k = (int) (Math.random() * 10);\n            sink.next(k);\n        }).subscribe(new Subscriber<Integer>() {\n\n            Subscription subscription;\n\n            @Override\n            public void onSubscribe(Subscription s) {\n                this.subscription = s;\n                this.subscription.request(1);\n            }\n\n            @SneakyThrows\n            @Override\n            public void onNext(Integer integer) {\n                System.out.println(\"处理:\" + integer);\n            }\n\n            @Override\n            public void onError(Throwable t) {\n                System.out.println(\"处理失败\");\n            }\n\n            @Override\n            public void onComplete() {\n                System.out.println(\"处理完成\");\n            }\n        });\n    }\n```\n\n```\n处理:9\n```\n\n\n## 四、事件驱动的好处\n\n反应式编程的好处, 主要是编程思想的不同, 抓住关键点非阻塞+事件驱动。\n\n```\nStopWatch '耗时统计': running time = 2070915374 ns\n---------------------------------------------\nns         %     Task name\n---------------------------------------------\n063036666   003%  基于事件驱动的编程思想\n2007878708  097%  传统阻塞式的编程思想\n```\n\n如下举一个例子,假如这是Servlet API。Servlet 线程负责调用getMonoUserName()。但是其实没有执行\n处理逻辑,而真正的执行逻辑交给业务线程处理。而此时Servlet线程可以释放出来,继续接受外部请求。\n\n\n```java \n    @Test\n    @DisplayName(\"Mono 事件驱动的好处\")\n    public void testMono() {\n        StopWatch stopWatch = new StopWatch();\n        stopWatch.start(\"基于事件驱动的编程思想\");\n        Mono<String> userNameMono = getMonoUserName();\n        stopWatch.stop();\n        stopWatch.start(\"传统阻塞式的编程思想\");\n        System.out.println(getUserName());\n        stopWatch.stop();\n        System.out.println(userNameMono.block());\n        System.out.println(stopWatch.prettyPrint());\n    }\n\n\n    @SneakyThrows\n    public String getUserName() {\n        Thread.sleep(2000L);\n        return \"JayChou\";\n    }\n\n    /**\n     * 基于事件驱动的编程思想\n     *\n     * @return Mono<String>\n     */\n    public Mono<String> getMonoUserName() {\n        return Mono.create(monoSink -> {\n            try {\n                Thread.sleep(2000L);\n            } catch (InterruptedException e) {\n                monoSink.error(new RuntimeException(e));\n                return;\n            }\n            monoSink.success(\"JayChou\");\n        });\n    }\n\n```\n\n\n## 五、总结 & 思考\n\n传统的编程思想是: 基于数据处理来写处理逻辑,逻辑中可能直接就阻塞了。\n反应式编程思想是: 我们只写数据处理逻辑,里面虽然也有阻塞,但是并不直接执行。类似线程中,Future#get\n\n![](https://img.springlearn.cn/blog/learn_1651427177000.png)\n\n其主要的不同就是编程思想不同，非阻塞的编程思想。但是我们也发现, 这样的思想其实带来好处其实并不是很大。\n我们也可以直接使用多线程来直接搞定，而不用增加学习成本来学习新的框架。\n\n**为什么反应式编程在后端开发者里面推广不起来**\n\n作为后台服务, 开发者其实对吞吐量并不是很关心,比如页面请求了后端，就算我后端服务慢，前台请求就会卡住。卡住就卡住等待呗，不管用什么框架都会卡住。（秒杀高并发服务除外，并不是所有的服务都要求高并发。特殊情况特殊处理, 异步也解决不了高并发的吞吐和rt问题）\n\n但是如果作为安卓开发呢？\n用户发起了一个请求, 请求慢就让用户主线程就卡住，手机不能滑动。这样用户体验是非常的差的。所以安卓开发会比较关注，解决方案就是纯异步，主线程只接受请求，然后任务安排给后台异步线程，这样就算请求慢，但是用户不会感觉手机是卡顿的。等到异步任务执行完，在跳转出来就行了。\n\n所以RxJava 是鼻祖，Reactor是追随者。也是因为上面的特性，所以后台开发者没有安卓开发者感兴趣，不需要压榨机器的性能。\n\nReactor要想推广起来，必须要与异步Servlet或是Spring WebFlux结合（开发者无感使用），才可能推广使用起来。\n但是不管怎么样这种编程思想是可以借鉴。\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/tools/reactor/README.md b/docs/learn/tools/reactor/README.md
--- a/docs/learn/tools/reactor/README.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/tools/reactor/README.md	(date 1655373430254)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
@@ -302,6 +302,6 @@
 
 所以RxJava 是鼻祖，Reactor是追随者。也是因为上面的特性，所以后台开发者没有安卓开发者感兴趣，不需要压榨机器的性能。
 
-Reactor要想推广起来，必须要与异步Servlet或是Spring WebFlux结合（开发者无感使用），才可能推广使用起来。
+`Reactor要想推广起来，必须要与异步Servlet或是Spring WebFlux结合`（开发者无感使用），或是`云原生应用彻底推广起来,强制开发者必须使用。`才可能推广使用起来。
 但是不管怎么样这种编程思想是可以借鉴。
 
Index: docs/learn/maven/plugin/artifact-check-maven-plugin.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: auto\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 编译卡点插件\npassword: 111\nicon: zuanshi\ncategory: Maven\n---\n\n<Pwd/>\n\n小编问一个问题,你们依赖的项目在发布线上环境时候,依赖中是否还会有快照版本呢?\n如果有，那你就危险了,因为是快照版本,随时都可以进行覆盖,如果覆盖了之前的版本。很有可能你的项目有很大的风险。\n举一个例子,项目A组使用了项目B组提供的一个依赖。开发时候因为都是使用快照包。但是上线B向A提供了一个RELEASE包。\n但是A项目组上线时候,忘记使用RELEASE包了。代码运行也完全没问题。\n但是突然有一天项目B组将之前的快照包给覆盖了,并且删除了里面的一些代码。这个时候项目A的项目,可能就启动不起来了。\n因为他依赖的快照包被覆盖了。\n\n\n那么如何解决上面的问题呢? 本篇我们就利用我们之前学的知识来开发一个,版本检查的工具。在每次项目编译的时候去进行检查。\n\n通过不同环境，执行不同的参数来对依赖版本进行校验。\n\n\n## 一、开发思路\n\n思路比较简单,在maven 打包时候,通过添加参数的方式,对打包的依赖进行正则分析。当发现有被匹配到的版本。就收集起来。\n最后进行阻断,不允许打包通过。\n\n## 二、开始开发\n\n## 2.1 声明一个Mojo插件\n\n本文我们都基于Maven3进行插件开发。使用注解方式进行声明。\n\n```java \n@Mojo(name = \"versionCheck\", defaultPhase = LifecyclePhase.PACKAGE, threadSafe = true, requiresDependencyCollection = ResolutionScope.TEST)\n@Execute(phase = LifecyclePhase.PACKAGE)\npublic class ArtifactVersionCheckMojo extends AbstractMojo {\n\n    @Override\n    public void execute() throws MojoExecutionException, MojoFailureException {\n    \n    }\n}\n\n```\n\n## 2.2 添加拦截规则\n\n拦击规则我们让用户自己进行配置。\n\n```java \n    @Parameter(property = \"versionCheckRegular\")\n    private String[] assertDependencyRegular;\n```\n\n用户可以通过set方式注入\n\n```xml \n              <plugin>\n                <groupId>com.github.lxchinesszz</groupId>\n                <artifactId>learn-maven-plugin</artifactId>\n                <version>1.0.1-SNAPSHOT</version>\n                <executions>\n                    <execution>\n                        <phase>package</phase>\n                        <goals>\n                            <goal>versionCheck</goal>\n                        </goals>\n                    </execution>\n                </executions>\n                <configuration>\n                    // 使用标签就行配置\n                    <assertDependencyRegular>\n                        <param>.*SNAPSHOT</param>\n                    </assertDependencyRegular>\n                </configuration>\n            </plugin>\n```\n\n同时也可以使用-D在命令行进行操作。\n\n`mvn package -DversionCheckRegular=.*SNAPSHOT`\n\n## 2.3 依赖分析\n\n这里为了避免你的maven版本过低建议你指定版本。\n\n```xml\n        <dependency>\n            <groupId>org.apache.maven</groupId>\n            <artifactId>maven-core</artifactId>\n            <version>3.8.5</version>\n        </dependency>\n```\n\n我们使用分析工具. DependencyGraphBuilder\n\n```java \n    ProjectBuildingRequest buildingRequest = new DefaultProjectBuildingRequest(session.getProjectBuildingRequest());\n    buildingRequest.setProject(project);\n    DependencyNode rootNode = dependencyGraphBuilder.buildDependencyGraph(buildingRequest, new ScopeArtifactFilter(\"test\"));\n```\n\n\n## 三、使用演示\n\n## 3.1 安装插件\n\n```xml \n    <build>\n        <plugins>\n            <plugin>\n                <groupId>com.github.lxchinesszz</groupId>\n                <artifactId>learn-maven-plugin</artifactId>\n                <version>1.0.1-SNAPSHOT</version>\n                <executions>\n                    <execution>\n                        <phase>package</phase>\n                        <goals>\n                            <goal>versionCheck</goal>\n                        </goals>\n                    </execution>\n                </executions>\n                <configuration>\n                    <assertDependencyRegular>\n                        <param>.*SNAPSHOT</param>\n                    </assertDependencyRegular>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n```\n\n## 3.2 执行打包命令\n\n- 因为我们绑定的是package所以我们直接执行插件\n\n`mvn com.github.lxchinesszz:learn-maven-plugin:1.0.1-SNAPSHOT:versionCheck`\n\n- 或者我们直接执行打包命令,同样会触发插件执行\n\n`mvn package -DversionCheckRegular=.*SNAPSHOT`\n\n\n![](https://img.springlearn.cn/blog/learn_1651591415000.png)\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/maven/plugin/artifact-check-maven-plugin.md b/docs/learn/maven/plugin/artifact-check-maven-plugin.md
--- a/docs/learn/maven/plugin/artifact-check-maven-plugin.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/maven/plugin/artifact-check-maven-plugin.md	(date 1655373430576)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: auto
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/误入歧途.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: false\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: true\nfooter: true\nbacktotop: true\nlayout: NewLayout\ntitle: 切莫走火入魔\nnoPageCopyright: true\nblankHome: true\n---\n\n[//]: # (![123]&#40;https://img.springlearn.cn/learn_4232870cfeea3d2ee58f45a24f3c0a56.png&#41;)\n\n![](https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png)\n## 为什么要坚持写博客?\n\n1. `避免眼高手低`，看起来全会，做起来全不对的情况。\n2. 编程重要的是思想，`思路决定出路`，在思想的指引下。写的代码都只是工具，工具类的API没有必要都要记住。\n   只要做到看到认识,再次遇到知道如何处理即可。`笔记的好处是下次再次遇到，只需要看看笔记就知道如何使用了`。\n3. `记录内容`、`总结知识`、`分享成长`。\n\n## 常见的技术误区\n\n1. 技术是永远学不完的, 避免陷入到`技术旋涡中`，为了学技术而学技术。\n2. 再厉害的技术，一定是了解决某些场景的问题而存在的。`重点是学习思想，参考其实现`。\n3. 一通百通，一下看不懂的知识。要进行`拆解`，拆解成知识点。`逐个击破`，最终`为我所用`。\n4. it上高大上的名词都是唬人的，不要被名字给吓退了。\n\n\n## 问题回答\n\n#### \uD83D\uDCE2 1. 这个网站内容都是你写的吗? \n\n`绝大多数都是自己的学习笔记`。另在纯技术文章上，其实纯原创都是比较少的。为什么这么说呢？ 因为IT技术类的东西\n核心在于对源代码的学习, 只有开发源代码的人或者第一个吃螃蟹的人,可以说是纯原创。\n而后来者基本都是在学习了源代码的同时也吸收了大部分网络前辈们的文章观点，进行辨别的学习和思考后，\n总结的新的个人观点。这部分文章虽然业务原创，但是并不是那么的纯。`但是尽管不是那么的纯，也可能比纯的更加具有学习价值，因为他在前辈的总结的观点下，又增加了新的观点。`\n\n本网站凡是收录的优秀文章,都会附带原文链接。`编码不易,必须尊重原创作者`。\n\n#### \uD83D\uDCE2 2. 这个网站都是技术类文章吗?\n\n`不是`，凡是优秀的文章，具有学习意义的。都可能存在。即是对自己知识面的补充，增加见识。也希望分享出来，让更多人看到这些优秀的文章。\n\n#### \uD83D\uDCE2 3. 为什么有些链接都是404呢?\n\n这个网站是小编利用业务时间进行自我学习，修炼和总结的乐园，因为时间没有那么充足，可能有些只写的标题。并没有补充文章内容。\n而这些没有补充内容的文章，都会`暂时`以404这种明确的`http` 暗号告诉你这篇文章，`已经被安排到学习日程上了`。接下来就会被安排上了。\n\n#### \uD83D\uDCE2 4. 为什么有些文章是加密的呢?\n\n如果你有这个问题, 难道客官`你是想白嫖吗`? 加密方案是基于浏览器缓存实现的，所以只用关注一次，即所有文章都可以免费白嫖了。\n验证码是你我唯一的暗号，凭借这个暗号还有更多用处哦。\n\n\n#### \uD83D\uDCE2 5. 个人博客是如何实现的?\n\n首先这是基于 `vuepress` 实现的，服务部署也是免费的，如果你也想拥有可以。\n- `静态博客` [Vuepress](https://java.springlearn.cn/learn/blog/vuepress/)\n- `免费部署` [Vercel](http://localhost:8080/learn/blog/vercel/)\n\n\n## 联系方式\n\n微信: `lxchinesszz`\n\n## 意见反馈\n\n若本号内容有做得不到位的地方（比如：涉及版权或其他问题），请及时联系我进行整改。\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/误入歧途.md b/docs/learn/误入歧途.md
--- a/docs/learn/误入歧途.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/误入歧途.md	(date 1655373430295)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: false
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/outsite/沟通软实力.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/outsite/沟通软实力.md b/docs/learn/outsite/沟通软实力.md
new file mode 100644
--- /dev/null	(date 1655373430170)
+++ b/docs/learn/outsite/沟通软实力.md	(date 1655373430170)
@@ -0,0 +1,208 @@
+---
+breadcrumb: false
+navbar: true
+sidebar: true
+pageInfo: true
+contributor: true
+editLink: true
+updateTime: true
+prev: true
+next: true
+comment: false
+footer: true
+backtotop: true
+title: 软实力之沟通篇
+category: 软实力
+---
+
+> 无论作为程序员还是技术leader，沟通，在我们的工作中起了很大的作用。每个人都会说话，但是会沟通之道的却不是太多，不信你往下看。为了增加代入感，全文都以第一人称“我”来叙述。因为有些案例出自朋友身上。
+
+我把他们分为三大类别：
+
+## 一、向上沟通
+
+## 1.1 雷区一：所有问题都自己扛！
+
+在我还是个刚刚转岗的 PM 小菜鸟时，我负责管理一个项目，代号叫“KK”，这个项目是为公司的战略项目提供底层支撑的。在跟进这个项目的前几个月里，我跟技术负责人阿仑配合得还算默契。但是，我发现他有个特点，就是所有问题，都自己扛。
+
+距离里程碑发布只剩一周了，但在测试时，我们还在不断地发现新的 Bug。以目前的进度和剩余 Bug 的潜在影响来看，按原计划上线，质量风险很高。这天，开站会时，我请团队中的每个人，在白板上画出自己的发布信心指数。总体来看，情况非常不乐观。
+
+我跟阿仑一起做好当天的安排之后，特意提醒他：“现在的情况不是很好，我们最好跟方雷提前报备一下。”我说的方雷，是这个项目的发起人，也是阿仑的上级。阿仑没有应声，转而找旁边的开发，开始讨论别的问题了。我心里很着急，但也只好作罢。实际上，我的担忧并不是空穴来风。方雷曾经在很多个场合强调过，KK 是今年的重点，稳定性更是重中之重。最近几次线上出问题，我们团队没少挨骂。这次的上线风险这么高，要不要及时告诉方雷呢？
+我在方雷的办公室门前，绕了两个弯，各种纠结顾虑，再一想到方雷那严厉的神情，就打起了退堂鼓。最终，我什么都没说，就离开了。新版本最后还是如期上线了，但我却并没有因此感到轻松。且不说遗留 Bug 的潜在风险，由于时间紧张，我们连线上监控都没做到位，也没时间充分考虑应急预案和演练。
+
+正当团队全力补漏的时候，线上还是出事了：底层依赖的第三方服务报错，导致很多线上用户请求失败。大晚上接到客户侧的紧急电话，我们才知道出了事。第二天，方雷在邮件里，劈头盖脸就责骂了我们一顿：“之前我一再强调监控，结果已经预见到的问题，你们都没有做应对，这是非常严重的人为事故！”
+
+看到这里，你觉得我冤不冤呢？其实，我明明知道这样上线会有很大问题，也明白现阶段最好的应对方式是什么，甚至还在心中打了无数的底稿，可以说服方雷调整上线计划。可是，当我站在方雷的办公室门口时，却死活迈不出自己心里的那道坎，这个“坎”究竟是什么呢？首先是层级差在无形之中给我带来的心理压力，包括方雷平日里强硬的作风，都让我有点怵，不自觉就想躲开。
+
+其次，都快上线了，项目还有这么多问题，作为项目经理，我也是有很大责任的。另外，因为阿仑不想去汇报，如果我汇报了，我会觉得像打小报告，不仗义。实际上，做好一次紧急问题的汇报沟通，并不是什么难事。但是，迈过自己内心的那道坎，主动大胆的发起沟通，是做好向上沟通的第一步。事实上，我们首先必须要明确，这类严重影响稳定性的问题，已经不属于可以自己扛的级别了，必须要让上级知晓的。
+
+
+明确了这一点，处理方式可以有很多种。比如，跟阿仑深入探讨下项目的处境，尝试说服他一起去找方雷。即便他不去，我也可以跟他说明自己的判断和接下来的行动，因为客观暴露风险，合理应对，这本身就是项目经理的职责所在。当然，我也可以尝试用邮件的形式，发一封项目风险告警，客观描述现在的风险和影响，提醒方雷特别关注，等等。
+
+
+这里的关键是，不管通过什么途径，我们必须时刻从大局出发，让这些项目关键信息，及时有效地流动，保障及时有效的决策。当真正重要、紧急的事情发生时，直接打电话或走过去敲门，确保第一时间沟通，才是更合适的做法。记住，你不需要所有问题，都自己扛。
+
+
+## 1.2 雷区二：只知道吐槽，不知道争取
+
+在 KK 项目组，连续加班是常有的事，半夜 2 点爬起来升级，也是家常便饭。即便我们的工作强度已经这么高了，线上仍然问题不断，项目组从上到下都压力很大。在如此“恶劣”的生存环境中，团队成员彼此之间就好比“难兄难弟”，私底下经常一起吃饭。当然，少不了的，就是一起“吐槽”。
+
+某个周末，又是一次通宵上线，我们忙到凌晨 4 点多钟，结果更新之后，出现了个突发情况，按照流程果断回退了。第二天，在定位解决问题后，又重新来过。在连续了两个通宵之后，项目得以成功上线，但团队却撑不住了。在看不到尽头的艰苦境况中，吐槽似乎成了最有效的排解压力的方式。比如，我们可能经常听到这样的吐槽：“出了问题挨骂”“没出问题是应该的”……
+刚开始，我也会跟着吐槽几句，因为我也一样，拼死拼活却得不到认可。可是，除了私下吐吐苦水，又能做什么呢？你看，这就是我踩过的第二个“坑”。当团队和管理层之间关系紧张时，很多项目经理会特别容易掉进一个误区，那就是，尽自己的努力帮团队解决问题，脏活累活都自己来。这样的“老好人”，在团队中会有很好的人缘，但是，跟着大家一起吐槽，似乎并不能带给团队真正的帮助。特别是当你同时受到高层压力的驱使，被迫去快速拿结果时，就很容易演变成“夹心饼”，吃苦受累，最后反而落得两头埋怨。
+
+那么，破局的点在哪里呢？答案就是，把“夹心饼”变成“连接器”，成为高层干系人与团队之间紧密联系的纽带。事实上，经过层层汇报，高层干系人能够得到的一线团队的信息，相当有限。很多自上而下的决策，如果不能根据一线反馈，及时调整的话，就很容易走形，偏离本意。作为项目经理，当需要高层重视和支持的事件发生时，该出手时就得出手，引发高层关注，把团队最一手的相关动态信息及时传递给他，争取高层必要的支持，而不是跟着团队一起吐槽。
+
+所以，这一次，我立刻想到了方雷！我应该让他听到团队的声音，让他意识到，长期这样下去的严重影响。而且，他才是解开这个困境的最合适的人。事实表明，方雷的介入，大大提升了团队士气。
+
+
+## 1.3 雷区三：抓不住重点，给不出方案
+
+某次会议散会之后，我叫住了他。我说：“我们团队最近加班很严重，已经连轴工作好几天了，这样下去，恐怕会……”我的话还没说完，方雷就毫不客气地打断了我，说：“现在这些年轻人，加几天班，就叫苦叫累的，想当年，我加班可多了去了……（此处省略一万字）”
+
+你看，在得到方雷的支持之前，我又踩了一个“坑”，也就是我想说的第 3 个误区：抓不住重点，给不出方案。“团队现在加班很严重”“团队任务不及时更新”“某某工作不主动、总是迟到”……如果你只是这样反映问题，只是说这里不好、那里不好，却没有告诉他，为什么要关注这个问题的话，你的意见不仅不会得到重视，甚至还会产生反效果。
+
+高层干系人的时间往往很宝贵，所以，在沟通之前，做好充分的准备，是必不可少的。你要反映的问题，与高层干系人的核心关注点是否相匹配，这是能否引起其关注并进一步行动的关键所在。在向高层干系人提问题的同时，一定要给他一个明确的“点”，让他知道，为什么要关注这个问题。实际上，抓住了对方真正的核心关注点，你才能在后续的沟通中，更加有针对性地进行高效管理。
+
+虽然我很了解方雷的脾气，但还是被刚刚这架势吓住了。还好，我提前就有所准备了。于是，我打开电脑，把准备好的数据摆在方雷面前，说：“你知道，我们的线上质量是容不得半点闪失的。这是我们团队前两个月的连续加班记录。“有人曾经做过统计，连续加班三周，人的身体、心理、情绪都会降到谷底。现在团队已经连续加班和通宵两个月了。再加上每次上线的心理压力，这样下去，恐怕会很容易犯错。昨天这次上线，团队吸取了教训，最终还是很平稳的，也算是这么长时间以来一次小小的胜利了！我在想，我们是不是应该简单庆祝下，帮大家先从心理上减减压，鼓舞下士气，也好有一个新的开始？”
+
+我一口气说完了事先准备好的“台词”，方雷先是有些吃惊，但他很快认可了我的判断。他说：“确实，我们得想办法鼓励下大家，而且一定要及时！”我灵机一动，接着说：“嗯！我看今天就是一个很好的时机。我们正打算下午开复盘会，我这就去准备些零食饮料，可以的话，请你到场跟大家讲两句话吧！”在复盘会上，方雷显然事先认真准备过。他从这个项目对大部门的重要性，讲到对大家的辛苦付出的感谢，再到绩效及奖励措施上的承诺。看得出来，他不太习惯公开说这么多鼓励的话，气氛稍有些诡异。
+
+## 二、跨部门沟通
+
+
+其实，人类社会的很多冲突，都始于“边界”二字。比如，部门与部门之间存在边界，所以就有了“部门墙”。别看只是跨了个部门，各项沟通的复杂度就会直线上升。
+
+为啥呢？不是“自己人”了啊。那么，我们该如何应对跨部门沟通的问题呢？我跟你分享两种方法。
+
+一.约法三章，先说清楚
+
+我们先来看看第一种：约法三章。既然不是自己人，那就要分清楚哪些事情该我干，哪些该你干。那么，该如何约法三章呢？
+
+## 2.1 第一步：建立君子协定
+
+在合作前，你要跟对方建立合约，明确合作目标、合作事项、双方各自的需求和责任、时间进度要求、风险及责任人。建立合约时，要由双方负责人进行邮件确认，公开做出正式的承诺。
+
+需要注意的是，在刚开始合作时，建立稳定的预期是关键，双方责任及进度要求，必须要得到公开确认。否则，这些问题如果不明不白的话，就会给后续工作带来极大的隐患。
+
+## 2.2 第二步：建立机制
+
+万万不要以为，签完合约就万事大吉了。曾经，我们就遇到这样的情况：眼看着要到联调的 Deadline 了，对方的任务还没完成。我问了对方之后，才知道，说好的功能接口不能准时交付了。他们给出了很多原因，比如，工作比想象得复杂，还有人员休产假、离职等等。
+
+在项目进行中，各种情况都有可能发生，只有及时获知、甚至是提前预知风险，才能让项目始终保持可控。合作建立之后，需要建立常规的沟通机制来持续推动。比如，项目信息开放共享，每周在固定的时间开碰头会，双方相关人员交流工作进展及风险情况。更进一步的话，你还可以借助标准的任务管理和文档管理工具，对项目任务和文档做到统一的流程化管理，在过程中确保及时地跟进检查。
+
+常规机制及工具搭建好之后，在运行过程中，你还需要经常自检，确认下流程上是否有疏忽的地方。比如，是否存在“三不管”地带？每个依赖任务的职责是否明确，责任是否具体到个人？如果你发现了模糊地带的存在，要及时明确需要共同协作的内容是什么，该由哪个部门、哪个人负责，做到权责分明和分工合理，避免后期出现相互推诿、扯皮的情况。
+
+## 2.3 第三步：解决问题
+
+通过周期检查，我们可以及时发现问题。但是，如果事先约定好了，并做了周期检查，对方负责的事情还是出问题了，该怎么办呢？有同学会说：“找他们领导！”在跨部门沟通中，打出领导牌，的确会起到一定的作用。但是，这张牌属于“王炸”，不到特别时刻，不要随便拿出来用。在找领导之前，建议你先自己摸清楚状况，尽快启动风险应对机制，确定问题处理方案，比如改变方案、调整时间、增加资源、减少范围等。
+
+另外，你要把问题和相应的决议结果抄送给双方的负责人，让双方清楚问题对整体项目的影响及调整方案。同时，你还要明确的是，今后要采取哪些预防措施，以避免问题的再次发生。那么，什么时候该找领导呢？我曾经就遇到过一种情况：两边的领导已经达成了正式的约定，但是，不是每个牵涉进去的协作方都会立马配合。
+
+原因有很多，比如，这个部门的 KPI 早就定义好了，目前上面的领导虽然认可了合作方案，但是没改 KPI，原来的目标依然有效。对于这部分新增的工作，他们要额外投人去做。因此，他们非常担心，虽然增加了工作量，但产出却不受领导的重视。类似这种会影响合作落地的根本机制问题，你就需要引入双方的领导，来一起研究解决方案。比如，在双方的绩效考核指标中，加入跨部门利益的指标，来强化这种目标和利益的捆绑，让双方真正把劲往一处使。
+
+
+**打开边界，一起想办法**
+
+“约法三章”，可以说是最为常见的一种跨部门沟通的应对方式。接下来，我们再来看看第二种方法：打开边界，一起想办法。尽管不是自己人，咱还是要把对方当成自己人看待，好，就一起好；出了问题，大家就一起扛。为什么说跨部门沟通还需要打开边界呢？我给你分享一个我经历过的项目，你就明白了。
+
+X 项目是一个非常典型的跨部门、跨职能的大型项目集，项目组人员接近两百个，涉及到的跨职能小组就有 12 个。由于技术复杂性，各模块之间的依赖和耦合很强，再加上各业务模块都有自己的目标和优先级，跨部门沟通的成本很高。在这样的背景下，每个业务模块都反馈说：“跨部门协调这个事，太难了。”一个很小的改进，可能就需要交互、前端、中间层、后端、各模块的测试都参与其中。即使只是组织一个会议，要想把人叫齐，都颇费周折。这种跨部门的协作，已经融入到每一天的工作中了。这时，“约法三章”的沟通方式，显然已经不适合我们了。那怎么办呢？
+
+**首先，要建立统一、清晰的节奏感**
+
+你需要结合不同业务模块的功能、相互之间的依赖关系，来为各个业务模块设计统一的交付节奏，也就是根据项目中的关键依赖，把交付时间错开排布。比如，在 X 项目中，我们在每个月固定设置了四个发布窗口，分别是 5 号、10 号、15 号和 20 号。接着，根据这 12 个模块的先后依赖关系，我们把它们安排在不同的窗口进行发布。在此之前，这些模块的发布时间都是自行定义的，现在，每月有了统一的规划和交付节奏，协同复杂度降低了很多，因为彼此之间有了稳定的交付预期和协同基准。
+
+需要注意的是，节奏的设定没有固定模式可循，你需要在自己的情境中，尝试总结规律，并把它们固化下来。有一个指示性的指标，就是重新设定节奏之后，如果跨部门协调的问题明显变少了，那么，当前这个节奏就是更合适的。
+
+其次，想要打开边界，你还需要主动往前一步
+
+对于这个项目集里的 12 个子业务模块来说，每个模块既可能是底层服务的用户，同时又是上层服务的依赖方，彼此互为上下游。在这样的情况下，如果没有彼此的通力合作，那就谁也做不好。曾经，我见过两个部门的负责人来来回回地在邮件里争吵，据理力争地互怼。后来，因为实在无法直接沟通了，他们就跟我说：“给我们加个项目经理吧。”
+
+
+在了解了需求之后，我发现，每个模块的日子都不好过，要么是被需求的反复弄得焦头烂额，一肚子怨气，说：“明明之前都约定好了，需求还是说变就变。我辛辛苦苦做出来了，说不用就不用，全白搭了。”要么是被频繁的依赖问题折磨得陷入“水深火热”的境地，纷纷吐槽：“底层服务又出问题，害我挨用户一顿臭骂。整天出问题，真是拿我们当小白鼠。”
+
+不管是哪一方，每个人都盯着别人的问题，同时捂住自己的问题。像这样的情况，就算是再放 10 个项目经理，估计都很难从整体上改善局面。那么，该怎么办呢？在和项目集的高层领导一起深入地剖析了现状之后，我们都认为，“头痛医头，脚痛医脚”的方式，并不是我们想要寻求的解决方案。
+我们把真正的担当解释为“上敬老，下爱小”。什么意思呢？上敬老，是说对于用户方，你要去主动深挖用户方的需求及业务背景，走在用户前面；下爱小，是指对于依赖方，你要全面监控、必要容错、并帮助它不断改进。通过这次的深入讨论，我们认识到，只有各个模块都往前走一步，才能够引发系统的改善。与其去责怪对方，不如跟他一起找到合作共赢的方式，最终让所有人获益。每次主动往前一步，最终必将体现到工作的长期效果上，从而形成持久化差异。
+
+
+## 三、向下沟通
+
+在做项目管理的前几年时间里，我经常会听到一种声音：“项目经理无权无势，不就是个打杂的吗？”老实说，刚开始从小白起步时，我也经常有这样的困惑。没有权力，却要承担很大的责任，还得让别人愿意听我的，互相配合着把事情做好，难度真的非常高。但正因为这样，我们项目管理部的项目经理们，在这些磨练中，个个都发展出了一身武艺。这其中最厉害的一项本事，叫作“非职权领导力”。在大量的实践中，我逐步总结梳理出了非职权领导力的六力模型。“六力”分别是执行力、信息力、感知力、透明力、影响力和整合力，这六力是层层递进的关系，代表了非职权领导力发展之路上的六个层次。
+
+## 3.1 执行力
+
+执行力是非职权领导力的根基，俗称“靠谱”，这是项目经理的立身之本。我们判断一个人是否靠谱，往往是在说这个人是否具有两个特征：主动担责和有始有终。
+
+- 主动担责
+
+管好自己的一亩三分地，并非就是执行力好。比如，我见过很多策划，在写好策划案之后就甩手不管了。但是，我曾遇到过这样一位策划，他不仅把自己的本职工作做得很出色，还会帮忙给所有策划制作一张总进度表，即时同步信息，汇报进展。如果中间过程出现了问题，比如开发跟测试发生了冲突，他也会主动想办法协调解决，推进项目落地。
+
+
+一段时间后，他被 Leader 点名表扬，很快从几个同级中脱颖而出，得到了晋升。我问他：“你为啥做这么多事？”他笑笑说：“也没啥，我就是很想看到整个产品都做得很好，不能忍受有些环节出了问题没人管，没人上，那就我上呗。”所以，你看，执行力的第一层，并没有什么神奇的，你首先需要跳出自己的小圈圈，主动承担更大的责任，而不是眼睁睁地看着项目出现问题，放手不管。
+
+- 有始有终
+
+言必信，行必果。交给你的任何事情，都有始有终。当很多人都只是在完成任务时，如果你懂得闭环的重要性，势必会事半功倍！当时，我在团队中发起了一项“零 Bug”的改进活动，后来因为一些原因没有坚持做下去。她在了解了情况之后，很严厉地跟我说：“作为一个项目经理，你发起的任何一件事都要有‘Close’的动作。你既然跟团队讲过要做这件事，现在不做了，就算自认为原因再合理，都需要给大家一个交待，而不是不声不响地就停止了。”
+
+实际上，一个有始有终的闭环，意味着你要对自己的每一个行为负责，清楚地了解为什么做，目标是什么，做完之后效果是怎样的，还有什么问题，以后要做哪些改进。如果中途有变化，也要及时跟相关方明确说明调整或取消的原因是什么。一屋不扫，何以扫天下？执行力可以说是你能够影响他人，继而具备非职权领导力的根本。
+
+
+## 3.2 信息力
+
+在大数据时代，谁掌握着数据和信息，谁就拥有更强大的力量和权力。由于自身的职责和信息渠道的便利，项目管理人员会很容易成为团队中拥有最大信息量的人。大到全局的战略、项目的初衷和发展方向、决策的起因和前后变迁，小到每个团队每天在干什么，都尽在项目管理人员的掌控之中。因此，项目经理就好比是项目信息的交换中心。
+
+我曾遇到过一个项目经理，他就拥有这种神通广大的信息力。不只是项目组里，甚至是公司里上上下下发生的事情，他都能第一时间获悉。所以，遇到拿不定主意的事情时，我经常向他打听消息。有一次，我忍不住问他：“你到底是怎么做到的？”他说：“没什么神秘的，我这个就是好奇心强，而且比较热心。我对别人很感兴趣，就会经常跟大家多聊几句，不管聊的东西有没有用，我都记得清清楚楚。而且，我还特别喜欢帮助别人。比如，我觉得某个机会适合某某，我就会推荐他去试试看。久而久之，大家就会主动给我提供信息，让我帮忙出谋划策，所以我就成了最有信息力的人啦！”
+
+当然，信息力可不只是掌握简单的八卦，而是要让流动的信息汇聚起来。作为初学者，你可以通过信息互通机制和平台来帮助自己做到这一点。比如，周会、站会、周报、邮件列表、通讯群，甚至是各类数据平台，都可以成为信息力的承载。除此之外，能够让非正式信息自动流向你，就属于内功的范畴了。在与人交往与合作时，好奇、关心、真诚、友善……这些特质都会帮助你构建起信任基础。连接多了，覆盖面广了，自然会形成规模效应和网络效应，这时就会产生信息力的红利了。
+
+## 3.3 感知力
+
+感知力建立在信息力的基础之上，不同的是，感知力是对“冰山下”隐性信息的敏锐度。这种对系统敏锐的感知判断，俗称“闻味道”。感知力是日积月累的功力，但也并不是什么深奥的功夫，你也可以做得到，重点就是平常在开会时，你要多练习、多观察。
+
+举个例子，某业务负责人请我给他的管理层做一次共创会，请大家根据总体规划，各个角色共同定义下半年各自的工作重点。拿到这个需求之后，我先跟几个管理者开了一次沟通会。会后，我找到这位负责人，跟他同步了我对管理团队的观察，并且提出了我的共创方案：“在这次共创之前，我们必须先有个复盘环节，否则，以咱们团队现在的这种合作状态，根本没法很好地共创。咱们得提前准备，我需要你的大力配合。”
+他很快就认可了我的方案，并且惊讶地问我：“你是怎么做到在这么的短时间内捕捉到这么多复杂的背景信息的？”你可能也很好奇，事实上，这就是感知力在现实场景中的运用。要想培养感知力，你需要经历三个层次。
+第一层：现象层。这一层观察的焦点，是在“冰山上”的行为。比如，你观察到开发和产品在会上吵起来了，这时，你注意到的是行为，还不是真正的感知。
+
+第二层：意图层。这一层观察的焦点，是在“冰山下”行为背后的真正意图。具体要怎么做呢？最简单的是，多问几个为什么。比如，他们为什么会吵起来，各自想要达成什么目标。仔细思考之后，你会发现，原来技术已经对于产品的频繁变更忍无可忍了，技术 Leader 有很大的压力，想要为受苦受难的开发们出头；而产品的意图也很直接，他们的想法是：“业务 KPI 在那儿摆着，咱能不能别那么磨叽？快速推进不行吗？”观察到这一层，你就很接近冲突的根源了。
+
+
+第三层：感受层。你要试着从这些现象和意图中，去感受每个人的状态和需要。你会发现，开发的核心感受显然是愤怒；产品直接承担着业务指标带来的高压，老大的想法又一直在变，技术的不配合让他们受到双面夹击，早已是苦不堪言，核心感受是苦涩。
+
+
+体会到这些之后，你会发现，如果不事先处理好这些强烈的感受，这些人是根本没有办法在一起很好地进行共创的。于是，在共创开始前，我安排了一个之前提到过的复盘环节，就是让每个成员画出自己从项目启动以来的状态、经历，并把其中的“高光时刻”和“至暗时刻”分享给大家。当天，这位负责人第一个发言，跟大家分享了开创新业务以来自己的坎坷经历。他的开放和坦诚让大家一下子轻松了许多。接着，轮到产品，她提到了刚上线就被苹果推荐的成就和喜悦，同时又分享了最近“两头受夹板气”的惨痛经历。开发同学则拿出自己的画，说自己自始至终都是“压力山大”，从来都没轻松过……就这样，大家开始一点点地敞开了心扉。
+
+
+那些平时看不到的真实一面，被集体看见和理解之后，团队内部淤积的压力也终于得到了释放。于是，大家开始聚焦在共创下一步真正有效的解决方案。总之，要想培养感知力，就要在日常的观察之中下功夫。从关注行为，到关注行为背后的意图，再到关注意图背后个体的核心感受和深层需要，最后着眼于团队中的气场和互动品质。
+
+## 3.4 透明力
+
+信息力和感知力是对环境的观察、观察、再观察。你需要注意的是，这些观察的结果只有透明出来，才能发挥效用。你要想办法把你看到的问题可视化，让决策者和团队都能看到这些问题。这就是我经常说到的透明的力量。
+
+我在一个团队中经常听到这样的声音：“搞什么需求评审、交互评审？要做什么先说好，然后就别再来烦我了。让我安静地写会儿代码，不行吗？”于是，这些评审会能不开就不开。结果，在 Deadline 之前，需求稿、设计稿和技术方案的问题不断爆发，要熬上好几个通宵，才能保证版本的正常发布.但是到了下一个版本，情况依然如此，循环往复。
+
+
+经过仔细了解，我发现，如果在早期投入精力的话，这些导致发布延期的大多数问题都是可以有效避免的，发布的风险也会大大降低。实际上，定位问题并不难，但是要想解决这个问题就很难了。因为这个团队三四年来一直都是这样，他们早就已经习惯这种模式了。想要引发改变，不是仅凭一人之力就可以做得到的。要打破这个恶性循环，就一定得让大家真正地看见问题，并且从心底里达成共识。
+
+
+我教你两个透明化呈现的方法：一个是“分析−思考−看见”，一个是“目睹−感受−看见”。前者走脑，是指借助数据、事实、逻辑分析等，调动头脑的智慧，创造共识；后者走心，是指运用图片、视频、故事等形象化的元素，调动情绪的力量，创造共鸣。如果你能结合起来用，效果会更好。
+
+在一次版本总结回顾时，我给大家讲了一个“熊猫大侠”的故事。这位“熊猫大侠”是一个苦兮兮的程序员，他有着熊猫一样的黑眼圈，他的黑眼圈是怎么来的呢？我以这个问题为切入点，以故事的形式带领大家回顾了整个版本进行过程中的一幕幕场景，从上个版本结束时的“累觉不爱”，需求评审会上的睡意朦胧，讲到提测前对设计方案的争执不下，最后到上线前的“兵荒马乱”。“熊猫大侠”的故事，使团队成员深度地看到了项目的现状，并产生了共鸣。接着，我晒出了各种过程数据，包括需求变更率、需求和设计问题发生的阶段及成本、各阶段等待时间、研发负荷度等，邀请团队一起来想办法解开 Deadline 的“魔咒”。
+
+看见这些事实和数据之后，大家才真正地意识到早期那些看似无聊的评审工作的重要性。除此之外，团队还进一步定义了各角色的协作规则，以达到更合理的节奏。最后，在团队的共同努力下，我们进一步建立了基于过程数据的效能改进机制，各角色的协同状况得到了持续的改善。所以，你看，想要改善什么，就把什么透明化！在走脑的同时又要走心，让团队的所有人都看见问题，调动起集体的关注力和改变的动力。这样的话，这种透明的力量就会自然地推动变化的发生。
+
+
+## 3.5 影响力
+
+项目经理无权无势，行走江湖，靠的是大家肯买你的账。能让他人买账的这种影响力，对个体来说，就是说服力；对群体来说，就是感染力。人们通常认为，要想提升影响力，一定要能讲，会讲。但很有意思的是，影响力的真正秘诀却在于“听”，而不是“讲”。
+我曾经跟一位产品总监合作，他本人聪明又强势，属于公认的特别难搞的类型。有一次，他主动跟我说：“别人跟我讲话，我向来只听两句就忍不住想打断，但是你说的话，我几乎全都听完了。”他之所以会这样说，并不是因为我的表达能力比别人强、我的逻辑更清晰、我的话更有道理，而是因为在他讲话的时候，我做到了真正的听。跟其他人相比，我更懂他的逻辑，我明白他是出于什么样的考虑，才会那么说、那么做的。我给他提的每一条建议都是建立在我对他的理解之上的，所以才能被他听进去。
+
+不听，是一切沟通问题的根源。要想增强你的影响力，你需要先培养“听”的能力。那么，该怎么培养这种能力呢？我给你分享一个小技巧。你可以找一位项目中的成员，请他聊一聊，在最近的工作中，他有没有什么高兴或者烦恼的事。在听他说话的时候，你一定不要打断他，也不需要特意去想自己该怎么回应。你只要简单地把注意力放在对方身上，清空你的思绪，打开你的所有感官，留心去体会对方的状态和需求就可以了。试着保持至少五分钟的专注，并在结束后记录自己的体会。
+
+同时，我鼓励你跟对方分享一下，在刚刚的对话中，你留意到了什么。另外，你也可以跟他沟通下，有没有什么事情是你可以帮他一起做的。实际上，在真正有说服力的对话中，恰恰并不存在什么“一定要去说服”的想法，这又是一个有意思的悖论。实际上，只有当你真诚地抱着想要了解和倾听对方的愿望，放下对自己的想法的执着时，你才能留意到对方真正的需要。这样自然的交流分享，反而更容易产生碰撞，引发共振。如果你能够在你的每次工作对话中有意识地坚持运用这个小练习，半年之后，你的影响力就能够得到很大的提升。
+
+## 3.6 整合力
+
+在一个业务团队中，除了总负责人之外，项目经理往往是唯一站在全局层面的人。毕竟，其他人都各有各的职责分工。在这样的定位之下，项目经理一定要成为一个“多面手”。因此，优秀的全局整合能力非常关键。简单来说，整合力就是把互相分离的部分连接在一起，使它们发挥出整体作用的力量。一群优秀的人结合在一起，也并不一定能成为一个优秀的团队，不一定能真的做成一个业务。作为项目经理，整合力就意味着你要去主动发现项目组中的各类风险和问题，综合运用各种能力，跨部门、跨角色地整合资源，以实现全链条的共同目标。
+
+关于整合力，我定义了两个“凡是”：凡是能促进业务良性运作的，凡是能促进团队健康发展的，都是整合管理的范畴。举个例子，我身边有个项目曾经遭遇到了发展上的瓶颈，军心溃散，士气低落，这时，我就变身成了教练，借助教练技术，给业务负责人及核心团队“照镜子”，帮助他们看到限制他们的模式到底是什么，促发团队进行深度思考和交流，共同梳理出当前局面之下最好的思路和打法，从而帮助团队更好地走出困境。所以，你看，所谓的整合力，就是不受限于你自己的角色、从头到尾把事做成的能力。这种整合力来源于你对项目环境的观察和感知，最后要落地到全局层面的行动中去。
+
+在“六力模型”中，执行力是从现在的“行”开始，想要影响别人，就要先做好自己，走出自己的小圈圈，去承担更大的职责，并且把你在日常执行中遇到的每一个问题，都视为一个开启新循环的机会。信息力和感知力是指你要不断拓展自己对环境的准确认知和把握，观察、观察、再观察，从复杂的系统中找到一个恰当的发力点，通过把它有效地透明出来，让集体共同看见，从而获取新的共识，也就是新知。最后，你还需要通过影响力和整合力去践行这个新知，反向影响和改造环境，最终推进新知的有效落地。
Index: docs/learn/spring/Spring声明式事务的实现方案.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/spring/Spring声明式事务的实现方案.md b/docs/learn/spring/Spring声明式事务的实现方案.md
new file mode 100644
--- /dev/null	(date 1655373430313)
+++ b/docs/learn/spring/Spring声明式事务的实现方案.md	(date 1655373430313)
@@ -0,0 +1,520 @@
+---
+breadcrumb: false
+navbar: true
+sidebar: true
+pageInfo: true
+contributor: true
+editLink: true
+updateTime: true
+prev: true
+next: true
+comment: true
+footer: true
+backtotop: true
+title: Spring声明式事务的实现方案?
+category: SpringBoot
+---
+
+::: tip
+本篇文章是对Mybatis知识点的一个扩展,主要一起来研究下Spring是如何来管理事务的。顺便再多聊一点其他的知识点,在学习的过程中主要带着以下问题来进行有目的的学习
+然后最终来回答下面这些问题。
+:::
+
+1. Mybatis是如何整合进Spring中的
+   - Spring如何知道哪些接口是Mapper接口的?
+   - Mapper接口是如何变成Spring Bean的？
+2. Spring在哪里声明的SqlSession的实现逻辑？
+3. Spring中声明式事务的实现方式是怎样的？
+4. Spring中如何处理嵌套事务的？
+5. Spring中事务的传播方式是如何实现的？
+
+https://cloud.tencent.com/developer/article/1497631
+
+## 一、如何整合进Spring中的
+
+默认大家对Spring都比较了解了,这里只说结果。都知道接口是不能被实例化的,那么接口是如何成为Bean的呢?
+
+## 1.1 如何知道哪些是Mybatis的接口呢?
+
+- `@MapperScan` Spring中在配置类上加上这个注解。根据源码能看到还导入了`MapperScannerRegistrar`
+
+```java 
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.TYPE)
+@Documented
+@Import(MapperScannerRegistrar.class)
+@Repeatable(MapperScans.class)
+public @interface MapperScan {}
+
+public class MapperScannerRegistrar implements ImportBeanDefinitionRegistrar, ResourceLoaderAware {}
+```
+
+`MapperScannerRegistrar` 会在配置类解析时候拿到`MapperScan`注解信息,并解析里面的参数。生成一个 `MapperScannerConfigurer` 信息。
+从源码中能看到Mybatis的很多配置信息,都会被注入到`MapperScannerConfigurer`中。
+
+![img.png](https://img.springlearn.cn/learn_4b3a9611962ebf20587584574ecb05ec.png)
+
+```java 
+public class MapperScannerConfigurer
+    implements BeanDefinitionRegistryPostProcessor, InitializingBean, ApplicationContextAware, BeanNameAware {}
+```
+
+实现自BeanDefinitionRegistryPostProcessor会前置,拿到MapperScan中的basePackage,最终通过`ClassPathMapperScanner`扫描并添加到
+`BeanDefinitionRegistry`中。
+
+![](https://img.springlearn.cn/blog/learn_1655086500000.png)
+
+到这里这种方式就能知道哪些是Mybatis中的Mapper接口了。
+
+还有第二种方式当发现Spring容器中没有`MapperScannerConfigurer`。会自动注入一个
+
+![](https://img.springlearn.cn/blog/learn_1655086934000.png)
+
+会直接指定哪些类被Mapper修饰,就将他生成Bean。
+![](https://img.springlearn.cn/blog/learn_1655087073000.png)
+
+好了，到这里就知道如何来确定那些接口是要生成Mybatis接口的了。下面看下个问题。
+
+## 1.2 Mapper接口是如何变成Spring Bean的？
+
+接口是不能被实例化的，但是在Spring中如何想让接口实例化就可以使用 [FactoryBean](/learn/spring/FactoryBean接口实例化/) + 动态代理的方式，实现接口类的实例化。
+
+- 首先利用 ClassPathBeanDefinitionScanner 找到符合规则的类生成 BeanDefinition。
+- 给 BeanDefinition 指定BeanClass,执行 FactoryBean 是 `MapperFactoryBean`
+
+![](https://img.springlearn.cn/blog/learn_1655087975000.png)
+
+
+## 二、Spring在哪里声明的SqlSession的实现逻辑？
+
+通过Mybatis的学习知道SqlSession一共有2个包装类。SqlSessionManager和SqlSessionTemplate。那么SqlSession是在哪里指定用哪个的呢?
+答案就在 `MapperFactoryBean`
+
+```java 
+public class MapperFactoryBean<T> extends SqlSessionDaoSupport implements FactoryBean<T> {
+  private SqlSessionTemplate sqlSessionTemplate;
+   
+     public void setSqlSessionFactory(SqlSessionFactory sqlSessionFactory) {
+       if (this.sqlSessionTemplate == null || sqlSessionFactory != this.sqlSessionTemplate.getSqlSessionFactory()) {
+         this.sqlSessionTemplate = createSqlSessionTemplate(sqlSessionFactory);
+       }
+     }
+   
+     @SuppressWarnings("WeakerAccess")
+     protected SqlSessionTemplate createSqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
+       return new SqlSessionTemplate(sqlSessionFactory);
+     }
+}
+```
+
+## 三、Spring中声明式事务的实现方式是怎样的
+
+看了Mybatis中事务这一章节,知道如果使用了SqlSessionTemplate,那么事务的权限就外包给了Spring。那么Spring中事务怎么处理的呢?
+终于进入正题了。Spring中提供两种事务的能力。
+
+- 声明式事务
+- 编程式事务
+
+## 3.1 声明式事务
+
+使用 `Transactional` 修饰方法，其主要实现是使用切面实现。
+
+- `TransactionAspectSupport#invokeWithinTransaction`。拦截方法。获取事务管理器。
+
+这里我们先来思考下,通过前面的学习知道事务的最底层实现是jdbc驱动来实现的。
+
+![](https://img.springlearn.cn/learn_d3cd2ff5e89f6dbfffff18289043304e.png)
+
+那么切面中要想实现，就必须保证切面中的线程执行的数据库操作，一定是同一个`SqlSession`这样才能在方法正常执行时候做commit，异常时候做rollback操作。
+
+![](https://img.springlearn.cn/blog/learn_1655099097000.png)
+
+那我们看下他是如何保证切面中的数据库操作一定是同一个SqlSession的吧。这部分逻辑就在 `SqlSessionTemplate` 中。
+
+![](https://img.springlearn.cn/blog/learn_1655099774000.png)
+
+- 获取当前线程是否已经有SqlSession了，如果有就直接使用，这样就保证在切面中的事务用的是同一个事务了。
+
+## 3.2 编程式事务
+
+- `TransactionTemplate#execute`
+
+编程是事务需要实现者自己来管理事务的，Spring提供的扩展接口类是 `CallbackPreferringPlatformTransactionManager`。如果发现容器中默认的事务管理类是这个
+就直接调动全局的这个事务管理方法。如果不是就自己来处理。这种设计的好处是,事务管理器既可以做关系型数据库的事务管理,也可以满足一些特定场景的事务控制(eg: 给Kafka的逻辑做一个事务管理)。
+
+![](https://img.springlearn.cn/blog/learn_1655100730000.png)
+
+
+## 四、Spring中如何处理嵌套事务的？
+
+什么是嵌套事务,举一个伪代码的例子。下面 `saveUser` 代码中有2个Mapper。但是有几个SqlSession呢?
+
+```java 
+UserMapper userMapper;
+
+RegistroyMapper registoryMapper;
+
+@Transactional(rollbackFor = {Throwable.class, RuntimeException.class, ExecutionException.class})
+public void save(User user){
+   userMapper.save(user);
+}
+
+@Transactional(rollbackFor = {Throwable.class, RuntimeException.class, ExecutionException.class})
+public void saveUser(String userName,Strign password){
+   User user = registoryMapper.regis(userName,password);
+   save(user);
+}
+```
+
+通过上面的学习我们了解到如果是Spring来管理的事务是一个线程对应一个SqlSession。所以说上面伪代码中的两个Mapper
+其实是用的同一个SqlSession,这样才能保证是在同一个事务中。核心代码逻辑就在这里 `SqlSessionUtils#getSqlSession`。
+从Spring中的事务管理器中获取 `SqlSession`。是否使用同一个事务，外包给Spring容器去托管。这就给Spring提供了很多可以发挥的空间。
+比如说传播机制等。
+
+```java 
+public static SqlSession getSqlSession(SqlSessionFactory sessionFactory, ExecutorType executorType,
+      PersistenceExceptionTranslator exceptionTranslator) {
+
+    notNull(sessionFactory, NO_SQL_SESSION_FACTORY_SPECIFIED);
+    notNull(executorType, NO_EXECUTOR_TYPE_SPECIFIED);
+
+    SqlSessionHolder holder = (SqlSessionHolder) TransactionSynchronizationManager.getResource(sessionFactory);
+
+    SqlSession session = sessionHolder(executorType, holder);
+    if (session != null) {
+      return session;
+    }
+
+    LOGGER.debug(() -> "Creating a new SqlSession");
+    session = sessionFactory.openSession(executorType);
+
+    registerSessionHolder(sessionFactory, executorType, exceptionTranslator, session);
+
+    return session;
+  }
+```
+
+## 五、Spring中事务的传播方式是如何实现的？
+
+| 传播方式                                  | 说明                                                         | 常用 |
+|---------------------------------------| ------------------------------------------------------------ | ---- |
+| TransactionDefinition.PROPAGATION_REQUIRED      | 如果存在一个事务，则支持当前事务。如果没有事务则开启         | ✅    |
+| TransactionDefinition.PROPAGATION_SUPPORTS      | 如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行 |      |
+| TransactionDefinition.PROPAGATION_MANDATORY     | 如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常 |      |
+| TransactionDefinition.PROPAGATION_NEVER         | 总是非事务地执行，如果存在一个活动事务，则抛出异常           |      |
+| TransactionDefinition.PROPAGATION_NOT_SUPPORTED | 总是非事务地执行，并挂起任何存在的事务                       |      |
+| TransactionDefinition.PROPAGATION_REQUIRES_NEW  | 总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起。 |      |
+| TransactionDefinition.PROPAGATION_NESTED        | 如果一个活动的事务存在，则运行在一个嵌套的事务中. 如果没有活动事务则按TransactionDefinition.PROPAGATION_REQUIRED 属性执行 |      |
+
+
+**思考传播机制如何实现**
+
+首先我们先思考下传播机制是如何实现的,因为我们知道 `要保证是同一个事务,那么一定是同一个SqlSession,这样才能保证是同一个事务`。
+而如果要新开事务,就要先将当前线程绑定的SqlSession等事务信息,给挂起，那么是如何进行挂起的呢? SqlSession又是如何跟线程绑定的呢?
+
+## 5.1 SqlSession是如何跟线程绑定的呢?
+
+通过TransactionSynchronizationManager中的ThreadLocal跟线程绑定`(new NamedThreadLocal<>("Transactional resources"))`。注意: 如果主线程下创建子线程是不能绑定上的。
+
+```java 
+private static void registerSessionHolder(SqlSessionFactory sessionFactory, ExecutorType executorType,
+      PersistenceExceptionTranslator exceptionTranslator, SqlSession session) {
+        SqlSessionHolder holder = new SqlSessionHolder(session, executorType, exceptionTranslator);
+        TransactionSynchronizationManager.bindResource(sessionFactory, holder);
+        TransactionSynchronizationManager
+            .registerSynchronization(new SqlSessionSynchronization(holder, sessionFactory));
+        holder.setSynchronizedWithTransaction(true);
+        holder.requested();
+  }
+```
+
+## 5.2 事务是如何嵌套的?
+
+答案就在 `TransactionAspectSupport#TransactionInfo` 中。一个事务注解对应一个TransactionInfo,如果出现嵌套
+就会生成一个事务链。如下图一样。
+
+![](https://img.springlearn.cn/blog/learn_1655110242000.png)
+
+当里层的事务处理完成后会执行清理动作,同时在将第一个的事务在进行恢复跟线程绑定。
+
+```java 
+        private void restoreThreadLocalStatus() {
+			// Use stack to restore old transaction TransactionInfo.
+			// Will be null if none was set.
+			transactionInfoHolder.set(this.oldTransactionInfo);
+		}
+```
+
+## 5.3 事务是如何挂起的?
+
+前面知道每一个 `@Transaction` 注解会对应一个 `TransactionAspectSupport#TransactionInfo`。而事务挂起后,会先跟线程进行解绑。
+然后挂起的事务 `SuspendedResourcesHolder` 会被添加在 `TransactionStatus` 中。
+
+**挂起的数据保存在哪里**
+
+```java 
+protected final class TransactionInfo {
+        // 事务管理器
+		@Nullable
+		private final PlatformTransactionManager transactionManager;
+        // 事务信息
+		@Nullable
+		private final TransactionAttribute transactionAttribute;
+        // 切面点
+		private final String joinpointIdentification;
+		// DefaultTransactionStatus
+		@Nullable
+		private TransactionStatus transactionStatus; 
+		@Nullable
+		private TransactionInfo oldTransactionInfo;
+}
+
+public class DefaultTransactionStatus extends AbstractTransactionStatus {
+	@Nullable
+	private final Object transaction;
+	private final boolean newTransaction;
+	private final boolean newSynchronization;
+	private final boolean readOnly;
+	private final boolean debug;
+	@Nullable
+	private final Object suspendedResources;
+}			
+```
+
+
+**如何进行挂起的**
+
+TransactionSynchronization 事务同步器，为了解决事务的传播方式
+
+- suspend 暂定事务,将事务从当前线程上解绑
+- resume  恢复事务,将事务从新恢复到当前线程上
+- beforeCommit 触发提交事务，执行commit
+- beforeCompletion 事务提交后
+- afterCommit 提交后
+- afterCompletion 完成后调用
+
+SqlSessionSynchronization 也是跟当前线程绑定的
+- 位置 `TransactionSynchronizationManager#ThreadLocal<Set<TransactionSynchronization>> synchronizations`
+
+```java  
+ // 挂起时候,将SqlSessionHolder与当前线程进行解绑
+ @Override
+ public void suspend() {
+   if (this.holderActive) {
+     LOGGER.debug(() -> "Transaction synchronization suspending SqlSession [" + this.holder.getSqlSession() + "]");
+     TransactionSynchronizationManager.unbindResource(this.sessionFactory);
+   }
+ }
+
+ /**
+  * 恢复时候重新跟当前线程绑定
+  */
+ @Override
+ public void resume() {
+   if (this.holderActive) {
+     LOGGER.debug(() -> "Transaction synchronization resuming SqlSession [" + this.holder.getSqlSession() + "]");
+     TransactionSynchronizationManager.bindResource(this.sessionFactory, this.holder);
+   }
+ }
+```
+
+
+## 5.4 传播方式具体实现
+
+下面这段代码就是事务注解的切面处理类，Spring事务的所有逻辑和扩展支持都在这里。
+
+- `TransactionAspectSupport#invokeWithinTransaction`
+
+**首先我们先看整体的逻辑**
+
+1. 获取当切面上的 `@Transaction` 注解信息
+2. 根据注解信息找到指定的事务管理器,如果没有执行就使用默认的
+3. 生成事务信息 `TransactionInfo` 传播机制,事务挂起都在这个类上
+4. 失败执行回滚&成功提交&如果是嵌套事务,从`TransactionInfo` 中将挂起的事务重新跟线程进行绑定
+
+```java {17,30,26,32}
+protected Object invokeWithinTransaction(Method method, @Nullable Class<?> targetClass,
+			final InvocationCallback invocation) throws Throwable {
+
+		// If the transaction attribute is null, the method is non-transactional.
+		TransactionAttributeSource tas = getTransactionAttributeSource();
+		// 获取被事务注解标记的事务信息
+		final TransactionAttribute txAttr = (tas != null ? tas.getTransactionAttribute(method, targetClass) : null);
+		// 根据事务注解上指定的事务管理器名称,去系统中获取，如果没有就拿系统中默认的事务管理器
+		final PlatformTransactionManager tm = determineTransactionManager(txAttr);
+		// 切面拦截点: com.alibaba.purchase.domain.replenish.impl.ReplenishDomainWriteServiceImpl.mockSave
+		final String joinpointIdentification = methodIdentification(method, targetClass, txAttr);
+        // 这里只看关系型数据的的事务逻辑。CallbackPreferringPlatformTransactionManager是具有回调性质的事务管理器,多用于处理自定的事务
+		if (txAttr == null || !(tm instanceof CallbackPreferringPlatformTransactionManager)) {
+			// Standard transaction demarcation with getTransaction and commit/rollback calls.
+			// 获取事务的信息,包含传播方式
+			TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);
+			Object retVal = null;
+			try {
+				// This is an around advice: Invoke the next interceptor in the chain.
+				// This will normally result in a target object being invoked.
+				retVal = invocation.proceedWithInvocation();
+			}
+			catch (Throwable ex) {
+				// target invocation exception
+				completeTransactionAfterThrowing(txInfo, ex);
+				throw ex;
+			}
+			finally {
+				cleanupTransactionInfo(txInfo);
+			}
+			commitTransactionAfterReturning(txInfo);
+			return retVal;
+		}
+}	
+```
+
+**这里只看传播机制吧。AbstractPlatformTransactionManager#handleExistingTransaction**
+
+- TransactionDefinition.PROPAGATION_NEVER 如果存在事务就报错
+- TransactionDefinition.PROPAGATION_NOT_SUPPORTED 如果有事务,就挂起(当前事务跟线程解绑)。不使用事务进行执行。
+- TransactionDefinition.PROPAGATION_REQUIRES_NEW 当前事务挂起,新开个事务。
+
+```java 
+     /**
+	 * Create a TransactionStatus for an existing transaction.
+	 */
+	private TransactionStatus handleExistingTransaction(
+			TransactionDefinition definition, Object transaction, boolean debugEnabled)
+			throws TransactionException {
+        // TransactionDefinition.PROPAGATION_NEVER（总是非事务地执行，如果存在一个活动事务，则抛出异常）就直接阻断报错
+		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) {
+			throw new IllegalTransactionStateException(
+					"Existing transaction found for transaction marked with propagation 'never'");
+		}
+        // TransactionDefinition.PROPAGATION_NOT_SUPPORTED 总是非事务地执行，并挂起任何存在的事务
+		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {
+			if (debugEnabled) {
+				logger.debug("Suspending current transaction");
+			}
+			Object suspendedResources = suspend(transaction);
+			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);
+			// 数据暂存在TransactionSynchronizationManager#synchronizations同步器中
+			return prepareTransactionStatus(
+					definition, null, false, newSynchronization, debugEnabled, suspendedResources);
+		}
+        // 总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起。
+		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) {
+			if (debugEnabled) {
+				logger.debug("Suspending current transaction, creating new transaction with name [" +
+						definition.getName() + "]");
+			}
+			SuspendedResourcesHolder suspendedResources = suspend(transaction);
+			try {
+				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);
+				DefaultTransactionStatus status = newTransactionStatus(
+						definition, transaction, true, newSynchronization, debugEnabled, suspendedResources);
+				doBegin(transaction, definition);
+				prepareSynchronization(status, definition);
+				return status;
+			}
+			catch (RuntimeException | Error beginEx) {
+				resumeAfterBeginException(transaction, suspendedResources, beginEx);
+				throw beginEx;
+			}
+		}
+        // 如果有事务存在，则运行在一个嵌套的事务中. 如果没有活动事务则按TransactionDefinition.PROPAGATION_REQUIRED 属性执行
+		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {
+			if (!isNestedTransactionAllowed()) {
+				throw new NestedTransactionNotSupportedException(
+						"Transaction manager does not allow nested transactions by default - " +
+						"specify 'nestedTransactionAllowed' property with value 'true'");
+			}
+			if (debugEnabled) {
+				logger.debug("Creating nested transaction with name [" + definition.getName() + "]");
+			}
+			if (useSavepointForNestedTransaction()) {
+				// Create savepoint within existing Spring-managed transaction,
+				// through the SavepointManager API implemented by TransactionStatus.
+				// Usually uses JDBC 3.0 savepoints. Never activates Spring synchronization.
+				DefaultTransactionStatus status =
+						prepareTransactionStatus(definition, transaction, false, false, debugEnabled, null);
+				// 使用当前事务,并增加当前事务的一次引用。		
+				status.createAndHoldSavepoint();
+				return status;
+			}
+			else {
+				// Nested transaction through nested begin and commit/rollback calls.
+				// Usually only for JTA: Spring synchronization might get activated here
+				// in case of a pre-existing JTA transaction.
+				// 没有新建一个事务
+				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);
+				DefaultTransactionStatus status = newTransactionStatus(
+						definition, transaction, true, newSynchronization, debugEnabled, null);
+				doBegin(transaction, definition);
+				prepareSynchronization(status, definition);
+				return status;
+			}
+		}
+
+		// Assumably PROPAGATION_SUPPORTS or PROPAGATION_REQUIRED.
+		if (debugEnabled) {
+			logger.debug("Participating in existing transaction");
+		}
+		if (isValidateExistingTransaction()) {
+			if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) {
+				Integer currentIsolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel();
+				if (currentIsolationLevel == null || currentIsolationLevel != definition.getIsolationLevel()) {
+					Constants isoConstants = DefaultTransactionDefinition.constants;
+					throw new IllegalTransactionStateException("Participating transaction with definition [" +
+							definition + "] specifies isolation level which is incompatible with existing transaction: " +
+							(currentIsolationLevel != null ?
+									isoConstants.toCode(currentIsolationLevel, DefaultTransactionDefinition.PREFIX_ISOLATION) :
+									"(unknown)"));
+				}
+			}
+			if (!definition.isReadOnly()) {
+				if (TransactionSynchronizationManager.isCurrentTransactionReadOnly()) {
+					throw new IllegalTransactionStateException("Participating transaction with definition [" +
+							definition + "] is not marked as read-only but existing transaction is");
+				}
+			}
+		}
+		// 
+		boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);
+		return prepareTransactionStatus(definition, transaction, false, newSynchronization, debugEnabled, null);
+	}
+```
+
+## 5.5 嵌套事务如何知道是否要提交
+
+当两个Mapper中使用的是同一个SqlSession,那么会不会第二个事务在执行后,就直接commit了呢,此时第一个事务有一次commit。导致异常呢?
+
+解决方案在这里 `DefaultTransactionStatus`
+
+第二个事务状态中
+- newTransaction = false
+- newSynchronization = false
+![](https://img.springlearn.cn/blog/learn_1655202764000.png)
+
+而下面代码中会做校验,只需要同步时候才会提交事务。
+
+```java 
+protected final void triggerBeforeCommit(DefaultTransactionStatus status) {
+		if (status.isNewSynchronization()) {
+			if (status.isDebug()) {
+				logger.trace("Triggering beforeCommit synchronization");
+			}
+			TransactionSynchronizationUtils.triggerBeforeCommit(status.isReadOnly());
+		}
+}
+```
+
+第一个事务状态中
+- newTransaction = true
+- newSynchronization = true
+才会真正的去执行。
+![](https://img.springlearn.cn/blog/learn_1655203089000.png)
+
+
+
+## 5.6 这样设计是否线程安全
+
+线程安全只有在多线程环境下才会出现。那么这里一定会有多线程问题。而事务是跟线程进行绑定的,所以这里虽然有多线程但是不会有线程安全问题。
+
+但是这里我们看源码线程绑定时候使用的ThreadLocal,所以你在线程中创建子线程或者是线程中使用线程池,这里的事务都不会共享的。
Index: docs/learn/project/jvm/JVM.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/project/jvm/JVM.md b/docs/learn/project/jvm/JVM.md
new file mode 100644
--- /dev/null	(date 1655373430303)
+++ b/docs/learn/project/jvm/JVM.md	(date 1655373430303)
@@ -0,0 +1,52 @@
+---
+breadcrumb: false
+navbar: true
+sidebar: true
+pageInfo: true
+contributor: true
+editLink: true
+updateTime: true
+prev: true
+next: true
+comment: false
+footer: true
+backtotop: true
+title: JVM内存模型
+---
+
+![](https://img.springlearn.cn/blog/learn_1654432506000.png)
+
+我们在学习JVM的内存管理的时候,我们的思维要跳出Java的局限。我们要这么理解。我们写的Java代码，是运行在JVM上的。
+如果让你来实现JVM那么。你会怎么处理呢?
+
+
+1. 什么是公共部分,什么是私有部分?
+
+- 公共部分(堆heap)
+    - Class字节码是公共的,是共享的,所有线程都要认识字节码。
+    - new的对象是公共的,也是共享的,所有线程要都能认识这些实例对象,能读取到实例的数据。
+- 私有部分 (栈stock)
+    - Java中每个线程的执行中的代码，及代码中的局部变量等信息是私有的。每个线程之间都要维护一份。
+    - JVM虚拟栈和本地方法栈。
+    - 代码是怎么执行的,当然是一行一行执行。那么这一行一行的代码是放在哪里的呢? 是放在栈里面的。Java代码是在JVM来执行的。
+      所以这个栈，我们称为JVM虚拟栈。
+    - JVM中有些方法是调用其他语言实现的, 会使用本地方法栈。
+    - 那么谁来读取栈里面的数据,来出栈执行呢? 这叫做PC寄存区。
+
+
+2. 这些区域的内存是如何划分的呢?
+
+
+
+3. 传说中的GC的内存回收策略?    
+
+
+
+https://arthas.gitee.io/jad.html jad命令
+
+打开arthas 找到类 `[arthas@87476]$ sc  sun.reflect.GeneratedMethodAccessor*` 扫描动态生成的类。
+
+反编译看下反射类中的代码
+
+
+元空间使用 https://xiaogenban1993.github.io/20.04/%E7%BB%BC%E8%BF%B0_%E5%86%85%E5%AD%98.html
Index: docs/learn/project/jvm/JVM参数配置说明.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/project/jvm/JVM参数配置说明.md b/docs/learn/project/jvm/JVM参数配置说明.md
new file mode 100644
--- /dev/null	(date 1655373430770)
+++ b/docs/learn/project/jvm/JVM参数配置说明.md	(date 1655373430770)
@@ -0,0 +1,67 @@
+---
+breadcrumb: false
+navbar: true
+sidebar: false
+pageInfo: true
+contributor: true
+editLink: true
+updateTime: true
+prev: true
+next: true
+comment: false
+footer: true
+backtotop: true
+title: JVM参数配置说明
+---
+
+[参考地址](https://help.aliyun.com/document_detail/193455.html)
+
+## 一、内存容量调优参数
+
+![](https://img.springlearn.cn/blog/learn_1654141304000.png)
+
+
+| 配置参数                     | 说明                                   | 示例                                                         |
+| :--------------------------- | :------------------------------------- | :----------------------------------------------------------- |
+| `-Xmx`                       | 设置最大堆大小。                       | `-Xmx3550m`，设置JVM最大可用内存为3550 MB。                  |
+| `-Xms`                       | 设置JVM初始内存。                      | `-Xms3550m`，设置JVM初始内存为3550 MB。此值建议与`-Xmx`相同，避免每次垃圾回收完成后JVM重新分配内存。 |
+| `-Xmn2g`                     | 设置年轻代大小。                       | `-Xmn2g`，设置年轻代大小为2 GB。整个JVM内存大小=年轻代大小+年老代大小+持久代大小。持久代一般固定大小为64 MB，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。 |
+| `-Xss`                       | 设置线程的栈大小。                     | `-Xss128k`，设置每个线程的栈大小为128 KB。**说明** JDK 5.0版本以后每个线程栈大小为1 MB，JDK 5.0以前版本每个线程栈大小为256 KB。请依据应用的线程所需内存大小进行调整。在相同物理内存下，减小该值可以生成更多的线程。但是操作系统对一个进程内的线程个数有一定的限制，无法无限生成，一般在3000个~5000个。 |
+| `-XX:NewRatio=n`             | 设置年轻代和年老代的比值。             | `-XX:NewRatio=4`，设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。如果设置为4，那么年轻代与年老代所占比值为1:4，年轻代占整个堆栈的1/5。 |
+| `-XX:SurvivorRatio=n`        | 年轻代中Eden区与两个Survivor区的比值。 | `-XX:SurvivorRatio=4`，设置年轻代中Eden区与Survivor区的大小比值。如果设置为4，那么两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6。 |
+| `-XX:MaxPermSize=n`          | 设置持久代大小。                       | `-XX:MaxPermSize=16m`，设置持久代大小为16 MB。               |
+| `-XX:MaxTenuringThreshold=n` | 设置垃圾最大年龄。                     | `-XX:MaxTenuringThreshold=0`，设置垃圾最大年龄。如果设置为0，那么年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，提高了效率。如果将此值设置为较大值，那么年轻代对象会在Survivor区进行多次复制，增加了对象在年轻代的存活时间，增加在年轻代即被回收的概率。 |
+
+## 二、GC回收调优
+
+## 2.1 吞吐量优先的GC典型配置参数
+
+| 配置参数                     | 说明                                                         | 示例                                                         |
+| :--------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
+| `-XX:+UseParallelGC`         | 选择垃圾收集器为并行收集器。                                 | `-Xmx3800m -Xms3800m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20`，`-XX:+UseParallelGC`此配置仅对年轻代有效，即在示例配置下，年轻代使用并发收集，而年老代仍旧使用串行收集。 |
+| `-XX:ParallelGCThreads`      | 配置并行收集器的线程数，即同时多少个线程一起进行垃圾回收。**说明** 此值建议配置与处理器数目相等。 | `-Xmx3800m -Xms3800m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20`，`-XX:ParallelGCThreads=20`表示配置并行收集器的线程数为20个。 |
+| `-XX:+UseParallelOldGC`      | 配置年老代垃圾收集方式为并行收集。**说明** JDK 6.0支持对年老代并行收集。 | `-Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20 -XX:+UseParallelOldGC`，`-XX:+UseParallelOldGC`表示对年老代进行并行收集。 |
+| `-XX:MaxGCPauseMillis`       | 设置每次年轻代垃圾回收的最长时间，如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值。 | `-Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:MaxGCPauseMillis=100`，`-XX:MaxGCPauseMillis=100`设置每次年轻代垃圾回收的最长时间为100 ms。 |
+| `-XX:+UseAdaptiveSizePolicy` | 设置此选项后，并行收集器自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低响应时该间或者收集频率，该值建议使用并行收集器时，并且一直打开。 | `-Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:MaxGCPauseMillis=100 -XX:+UseAdaptiveSizePolicy` |
+
+
+## 2.2 响应时间优先的GC典型配置参数
+
+| 配置参数                             | 说明                                                         | 示例                                                         |
+| :----------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
+| `-XX:+UseConcMarkSweepGC`            | 设置年老代为并发收集。**说明** 配置了`-XX:+UseConcMarkSweepGC`，建议年轻代大小使用`-Xmn`设置。 | `-Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:ParallelGCThreads=20 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC` |
+| `-XX:+UseParNewGC`                   | 设置年轻代为并行收集。可与CMS收集同时使用。JDK 5.0以上版本，JVM根据系统配置自行设置，无需再设置此值。 | `-Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:ParallelGCThreads=20 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC` |
+| `-XX:CMSFullGCsBeforeCompaction`     | 由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩、整理。 | `-Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseConcMarkSweepGC -XX:CMSFullGCsBeforeCompaction=5 -XX:+UseCMSCompactAtFullCollection`，`-XX:CMSFullGCsBeforeCompaction=5`，表示运行GC5次后对内存空间进行压缩、整理。 |
+| `-XX:+UseCMSCompactAtFullCollection` | 打开对年老代的压缩。**说明** 该值可能会影响性能，但是可以消除碎片。 | `-Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseConcMarkSweepGC -XX:CMSFullGCsBeforeCompaction=5 -XX:+UseCMSCompactAtFullCollection` |
+
+
+## 三、GC辅助参数
+
+| 配置参数                 | 说明                                                         |
+| :----------------------- | :----------------------------------------------------------- |
+| `-XX:+PrintGC`           | 用于输出GC日志。                                             |
+| `-XX:+PrintGCDetails`    | 用于输出GC日志。                                             |
+| `-XX:+PrintGCTimeStamps` | 用于输出GC时间戳（JVM启动到当前日期的总时长的时间戳形式）。示例如下：`0.855: [GC (Allocation Failure) [PSYoungGen: 33280K->5118K(38400K)] 33280K->5663K(125952K), 0.0067629 secs] [Times: user=0.01 sys=0.01, real=0.00 secs]` |
+| `-XX:+PrintGCDateStamps` | 用于输出GC时间戳（日期形式）。示例如下：`2022-01-27T16:22:20.885+0800: 0.299: [GC pause (G1 Evacuation Pause) (young), 0.0036685 secs]` |
+| `-XX:+PrintHeapAtGC`     | 在进行GC前后打印出堆的信息。                                 |
+| `-Xloggc:../logs/gc.log` | 日志文件的输出路径。                                         |
Index: docs/learn/design/六脉神剑.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: true\ntime: 2022-05-24\nfooter: true\nbacktotop: true\ntitle: 六大原则 & 23种设计模式\nsticky: true\ncategory: 设计&规范\nstar: true\noriginal: true\nimage: https://img.springlearn.cn/blog/learn_1653399918000.png\n---\n\n![](https://img.springlearn.cn/blog/learn_1653399918000.png)\n\n## 一、设计模式\n\n设计模式一般分为三类：创建型模式、结构型模式、行为型模式。\n\n- 创建型模式：对象实例化的模式，创建型模式用于解耦对象的实例化过程。\n- 结构型模式：把类或对象结合在一起形成一个更大的结构。\n- 行为型模式：类和对象如何交互，及划分责任和算法\n\n![](https://img.springlearn.cn/27c9d5187cd283f8d160ec1ed2b5ac89.jpg)\n\n\n\n## 1.1 创建型模式\n创建型模式简单来说就是用来创建对象的。一共有五种：单例模式、建造者模式、工厂方法模式、抽象工厂模式、原型模式。\n\n1. 单例模式 ：确保某一个类只有一个实例，并且提供一个全局访问点。\n2. 建造者模式 ： 用来创建复杂的复合对象。\n3. 工厂方法模式 ：让子类来决定要创建哪个对象。\n4. 抽象工厂模式 ：创建多个产品族中的产品对象。\n5. 原型模式 ：通过复制原型来创建新对象。\n\n## 1.2 结构型模式\n\n结构型模式主要是用于处理类或者对象的组合。一共有七种：适配器模式、装饰模式、代理模式、外观模式、桥接模式、组合模式、享元模式。\n\n1. 代理模式 ：控制客户端对对象的访问。\n2. 组合模式 ：将整体与局部（树形结构）进行递归组合，让客户端能够以一种的方式对其进行处理。\n3. 适配器模式 ：将原来不兼容的两个类融合在一起。\n4. 装饰者模式 ：为对象添加新功能。\n5. 享元模式 ：使用对象池来减少重复对象的创建。\n6. 外观模式 ：对外提供一个统一的接口用来访问子系统。\n7. 桥接模式 ：将两个能够独立变化的部分分离开来。\n\n## 1.3 行为型模式\n行为型模式主要是描述类或者对象是怎样交互和怎样分配职责的。一共有十一种：策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。\n\n1. 策略模式 ：封装不同的算法，算法之间能互相替换。\n2. 状态模式 ：根据不同的状态做出不同的行为。\n3. 责任链模式 ：将事件沿着链去处理。\n4. 观察者模式 ：状态发生改变时通知观察者，一对多的关系。\n5. 模板方法模式 ：定义一套流程模板，根据需要实现模板中的操作。\n6. 迭代器模式 ：提供一种方法顺序访问一个聚合对象中的各个元素。\n7. 备忘录模式 ：保存对象的状态，在需要时进行恢复。\n8. 访问者模式 ：稳定数据结构中，定义新的操作行为。\n9. 中介者模式 ：将网状结构转变为星型结构，所有行为都通过中介。\n10. 解释器模式 ：定义语法，并对其进行解释。\n11. 命令模式 ：将请求封装成命令，并记录下来，能够撤销与重做。\n\n\n**总结**\n虽然设计模式是个好东西，能够给我们带来各种好处，比如降低对象之间的耦合，增加程序的可复用性、可扩展性、可维护性等等。\n但是我们也不应该滥用设计模式，设计模式在一定程序上会增加系统的复杂性。我们在写码时应该评估好各方面，避免过度设计。\n\n\n## 二、六大原则\n\n## 2.1 开闭原则\n\n**定义**\n\n一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。\n\n**问题场景**\n\n在软件的生命周期内，因为变化、升级和维护等原因需要`对软件原有代码进行修改时`，可能会`给旧代码中引入错误`，也可能会使我们`不得不对整个功能进行重构`，并且需要原有代码经过重新测试。\n\n**解决方案**\n\n当软件需要变化时，`尽量通过扩展软件实体的行为来实现变化`，而`不是通过修改已有的代码`来实现变化。\n\n**表达**\n\n用抽象构建框架，用实现扩展细节因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节，我们用从抽象派生的实现类来进行扩展，当软件需要发生变化时，我们只需要根据需求重新派生一个实现类来扩展就可以了。当然前提是我们的抽象要合理，要对需求的变更有前瞻性和预见性才行。\n\n**分析**\n\n就是对扩展开放,对修改关闭, 里式替换原则理论支持了这个一说法,及子类要能替换父类,这样子类就可以在父类的基础上,扩展\n\n## 2.2 单一职责原则\n\n**定义**\n\n`一个类只负责一项职责。`\n\n**问题场景**\n\n类T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。\n\n**解决方案**\n\n遵循单一职责原则。分别建立两个类T1、T2，使T1完成职责P1功能，T2完成职责P2功能。这样，当修改类T1时，不会使职责P2发生故障风险；同理，当修改T2时，也不会使职责P1发生故障风险。\n\n**表达**\n\n不要让责任扩散\n\n**分析**\n\n一个类,指责要单一,避免如果有多种职责,修改一个职责的时候,误触到其他职责的问题\n\n## 2.3 里氏替换原则\n\n**定义**\n\n所有引用基类的地方必须能透明地使用其子类的对象。\n\n**问题场景**\n\n有一功能P由类A完成，现在要扩展P,其中P由类A的子类B完成，则子类在完成的同时，可能会导致原来功能故障\n\n**解决方案**\n\n当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。\n\n**表达**\n\n使用继承的时候，不要随便修改父类中已经实现的方法\n\n**分析**\n\n子类要能替换父类\n\n## 2.4 依赖倒置原则\n\n**定义**\n\n高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。\n\n**问题场景**\n\n类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。\n\n**解决方案**\n\n将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率。\n\n**表达**\n\n如果A依赖B，现在要改为依赖C，如果直接修改A有风险，可以让A去依赖一个接口，BC都实现这个接口，也就是策略模式\n\n**分析**\n\n白话就是说,要根据接口或者抽象去设计,不要依赖于细节,eg.项目中要换数据库,不用重新写底层的数据库代码. 就是使用了hibernate一样,替换方言就好了,因为hibernate是根据接口设计的,不同数据库有不同的实现,可以直接使用. eg2: 我生病了要去买药,如果A药铺,没有我就用B药铺买. 因为他们都是药铺,都有一样的功能,可以友好的替换\n\n## 2.5 接口隔离原则\n\n**定义**\n\n客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。\n\n**问题场景**\n\n类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则**类B和类D必须去实现他们不需要的方法**。\n\n**解决方案**\n\n将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则\n\n**表达**\n\n防止去实现不需要的接口方法，可以按接口拆分，避免臃肿。\n\n**分析**\n\n白话,接口要最小化,功能更细分. 目的是:不需要的功能,就不要去实现\n\n比如有些接口可能里面什么方法都没有，其存在的意义，就是为了其实现类拥有特殊的功能.所以我们也要怕我们的接口里面没有方法，就怀疑了它存在的价值\n\n```\npublic class RandomAccess{\n}\n```\n\n当实现RandomAccess的类比如ArrayList就具有随机访问的能力，而没有实现该接口的，就只能去迭代访问。\n\n我们可以简单的看下Collections下的binarySearch方法的源码\n\n```java \n    public static <T>\n    int binarySearch(List<? extends Comparable<? super T>> list, T key) {\n        if (list instanceof RandomAccess || list.size()<BINARYSEARCH_THRESHOLD)\n            return Collections.indexedBinarySearch(list, key);\n        else\n            return Collections.iteratorBinarySearch(list, key);\n    }\n```\n\n\n## 2.6 迪米特法则\n\n\n**定义**\n\n一个对象应该对其他对象保持最少的了解。\n\n**问题场景**\n\n类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。\n\n**解决方案**\n\n尽量降低类与类之间的耦合。\n\n**表达**\n\n尽量降低类与类之间的耦合。\n\n**分析**\n\n降低类与类之间直接交互,能隐藏的属性就可以隐藏. eg. 修电脑,去IT部门,之前一直找小张,现在小张走了,还需要重新认识小李. 迪米特法则,就是直接找IT主管,让主管派人修. 主管就是接口，调用接口的方法，底层具体是小张还是小李，我们不用去管\n\n这里其实也强调了接口的重要性!\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/design/六脉神剑.md b/docs/learn/design/六脉神剑.md
--- a/docs/learn/design/六脉神剑.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/design/六脉神剑.md	(date 1655372859809)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
@@ -14,6 +14,7 @@
 backtotop: true
 title: 六大原则 & 23种设计模式
 sticky: true
+word: true
 category: 设计&规范
 star: true
 original: true
Index: docs/learn/tools/reflections/Java泛型.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\nsidebarDepth: 3\ntitle: Java泛型体系知识学习\n---\n\n<Djt/>\n\n![](https://img.springlearn.cn/blog/learn_1652114729000.png)\n\n## 一、Java泛型体系\n\nType 是 Java 语言中所有类型的公共父接口，其从 JDK5 开始引入，引入的目的主要是为了支持泛型。\nJava的泛型体系还是比较复杂的, 不过没关系，本篇文章会从实战的角度来，学习泛型。\n\n## 1.1 ParameterizedType 参数化泛型\n\nParameterizedType 是, `参数化泛型`只要记住凡是带泛型的是明确的类型,只要不是数组GenericArrayType那么一定是ParameterizedType。\n如下:\n- List<?> list 中的 list\n- Map<String,String> map中的map\n- Map<String,String> map中的map\n\n### 1.1.1 API 说明\n\nParameterizedType 一共有3个方法如下。\n\n```java \npublic interface ParameterizedType extends Type {\n    // 获取泛型信息，输一个数组。因为可能泛型有多个\n    Type[] getActualTypeArguments();\n    // 原始数据类型\n    Type getRawType();\n    // \n    Type getOwnerType();\n}\n```\n\n- getRawType 获取原始数据类型\n- getActualTypeArguments 获取泛型信息,因为泛型可以是多个,所以返回是数组\n\n### 1.1.2 代码示例\n\n```java \npublic class Test {\n    class Girl implements Person {}\n    class Boy implements Person {}\n    interface Person {}\n    class School<A extends Boy & Person> {}\n    School<Boy> boySchool;\n    School<Boy>[] schools;\n    @Test\n    public void test() {\n        // class java.lang.Class\n        System.out.println(ReflectionUtils.findField(Test.class, \"boy\").getGenericType().getClass());\n        // class sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl\n        System.out.println(ReflectionUtils.findField(Test.class, \"boySchool\").getGenericType().getClass());\n        // class sun.reflect.generics.reflectiveObjects.GenericArrayTypeImpl\n        System.out.println(ReflectionUtils.findField(Test.class, \"schools\").getGenericType().getClass());\n    }\n}\n```\n\n\n- `boy` 是具体类型,且不是泛型,所以是Class类型\n- `School<Boy> boySchool` 是具体类型,但是有泛型`<Boy>`,所以是ParameterizedType\n  - `ParameterizedType#getActualTypeArguments` 下标0就是泛型`Boy`\n- `School<Boy>[] schools` 是具体类型,有泛型`<Boy>`,但是是数组类型所以是GenericArrayType\n\n## 1.2 GenericArrayType  泛型数组\n\n`GenericArrayType`和`ParameterizedType`是比较类似的,唯一的区别是GenericArrayType一定是数组,如果不是数组就是ParameterizedType\n\n### 1.2.1 API 说明\n\nGenericArrayType 只提供了一个方法就是获取泛型的方法\n\n```java \npublic interface GenericArrayType extends Type {\n    // 获取数组泛型\n    Type getGenericComponentType();\n}\n```\n\n### 1.2.2 代码示例\n\n```java \npublic class Test {\n    class Girl implements Person {}\n    class Boy implements Person {}\n    interface Person {}\n    class School<A extends Boy & Person> {}\n    School<Boy> boySchool;\n    School<Boy>[] schools;\n    @Test\n    public void test2(){\n        GenericArrayType schoolsArrayType = (GenericArrayType) ReflectionUtils.findField(Test.class, \"schools\").getGenericType();\n        Type genericComponentType = schoolsArrayType.getGenericComponentType();\n        // learn.common.print.Test$School<learn.common.print.Test$Boy>\n        System.out.println(genericComponentType.getTypeName());\n        // class sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl\n        System.out.println(genericComponentType.getClass());\n    }\n}  \n```\n\n- `School<Boy> boySchool` 是具体类型,且有泛型,但是`不是`数组所以是`ParameterizedType`\n- `School<Boy>[] schools` 是具体类型,且有泛型,但是`是`数组所以就是`GenericArrayType`\n  - `GenericArrayType#getGenericComponentType` = `School<Boy>` = `ParameterizedType`\n\n\n\n\n## 1.3 TypeVariable 泛型变量\n\n`TypeVariable`变量泛型是比较好判断的,只要是变量泛型。一定就是TypeVariable。\n\n### 1.3.1 API 说明\n\n```java \npublic interface TypeVariable<D extends GenericDeclaration> extends Type, AnnotatedElement {\n    // 获取泛型信息\n    Type[] getBounds();\n\n    D getGenericDeclaration();\n\n    String getName();\n\n    AnnotatedType[] getAnnotatedBounds();\n}\n```\n\n### 1.3.2 代码示例\n\n```java \n    class TypeVariableObj<A extends Number> {\n        A a;\n        TypeVariableObj<A> as;\n    }\n    @Test\n    public void test3() {\n        Type a = ReflectionUtils.findField(TypeVariableObj.class, \"a\").getGenericType();\n        // class sun.reflect.generics.reflectiveObjects.TypeVariableImpl\n        System.out.println(a.getClass());\n\n        Type as = ReflectionUtils.findField(TypeVariableObj.class, \"as\").getGenericType();\n        // class sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl\n        System.out.println(as.getClass());\n        Type[] actualTypeArguments = ((ParameterizedType) as).getActualTypeArguments();\n        // A 因为只有1个泛型,所以直接去下标0\n        TypeVariable actualTypeArgument = (TypeVariable) actualTypeArguments[0];\n        System.out.println(actualTypeArgument.getTypeName());\n    }\n```\n\n- `A a = TypeVariable`\n- `TypeVariableObj<A> as = ParameterizedType`\n  - `ParameterizedType#getActualTypeArguments()[0] = <A>`\n\n  \n\n## 1.4 WildcardType 泛型表达式\n\n`WildcardType`也比较好判断只要是通配符,可以简单理解,直接带有 `?` 的泛型限定那么就是 `WildcardType`\n\n### 1.4.1 API 说明\n\nWildcardType通配符, 如 `?`, `? extends Number`, `? super Integer`\n\n```java \npublic interface WildcardType extends Type {\n    // 泛型上限\n    Type[] getUpperBounds();\n    // 泛型下限\n    Type[] getLowerBounds();\n}\n```\n\n- `Type[] getUpperBounds();` //获得泛型表达式上界（上限） 获取泛型变量的上边界（extends） \n- `Type[] getLowerBounds();` //获得泛型表达式下界（下限） 获取泛型变量的下边界（super）\n\n### 1.4.2 代码示例\n\n```java \npublic class WildcardTypeTest {\n    Map<? extends String, ? super Number> map;\n    @Test\n    public void wildcardTypeTest() {\n        Field map = ReflectionUtils.findField(WildcardTypeTest.class, \"map\");\n        Type[] actualTypeArguments = ((ParameterizedType) map.getGenericType()).getActualTypeArguments();\n        // ? extends java.lang.String\n        System.out.println(((WildcardType) actualTypeArguments[0]).getTypeName());\n        // class java.lang.String\n        System.out.println(((WildcardType) actualTypeArguments[0]).getUpperBounds()[0]);\n    }\n}\n```\n\n- `Map<? extends String, ? super Number> map` 中 map是 `ParameterizedType`\n  - `ParameterizedType#getActualTypeArguments[0]` = `WildcardType#getUpperBounds[0]` = `String`\n  - `ParameterizedType#getActualTypeArguments[1]` = `WildcardType#getLowerBounds[0]` = `Number`\n\n\n## 二、泛型获取\n\n通过上面的学习,我们可以使用原始API来获取各种泛型的信息,而Spring中有一个比较好用的工具。屏蔽了底层的\n具体实现。比较方便。\n\n## 2.1 获取接口泛型\n\n```java \n    class A {}\n    class B {}\n    interface School<T, K> {}\n    interface X extends School<A, B> {}\n    @Test\n    public void test() {\n        // 获取实现的接口是泛型的信息\n        ResolvableType resolvableType = ResolvableType.forClass(X.class);\n        Class<?> resolve1 = resolvableType.getInterfaces()[0].getGeneric(0).resolve();\n        // class learn.common.print.ColorConsoleTest$A\n        System.out.println(resolve1);\n        Class<?> resolve2 = resolvableType.getInterfaces()[0].getGeneric(1).resolve();\n        // class learn.common.print.ColorConsoleTest$B\n        System.out.println(resolve2);\n    }\n```\n\n## 2.2 获取父类泛型\n\n```java \n    class A {}\n    class B {}\n    class School<T, K> {}\n    class X extends School<A, B> {}\n    @Test\n    public void test() {\n        // 获取实现的接口是泛型的信息\n        ResolvableType resolvableType = ResolvableType.forClass(X.class);\n        Class<?> resolve1 = resolvableType.getSuperType().getGeneric(0).resolve();\n        // class learn.common.print.ColorConsoleTest$A\n        System.out.println(resolve1);\n        Class<?> resolve2 = resolvableType.getSuperType().getGeneric(1).resolve();\n        // class learn.common.print.ColorConsoleTest$B\n        System.out.println(resolve2);\n    }\n```\n\n## 2.3 获取字段泛型\n\n```java \n    class A {}\n    class B {}\n    class School<T, K> {}\n    class X {\n        private School<A, B> school;\n    }\n\n    @Test\n    public void test() {\n        // Spring的提供工具类,用于字段的泛型信息,Person<String>\n        ResolvableType resolvableType = ResolvableType.forField(Objects.requireNonNull(ReflectionUtils.findField(X.class, \"school\")));\n        System.out.println(resolvableType);\n        Class<?> resolve1 = resolvableType.getGeneric(0).resolve();\n        // class learn.common.print.ColorConsoleTest$A\n        System.out.println(resolve1);\n        Class<?> resolve2 = resolvableType.getGeneric(1).resolve();\n        // class learn.common.print.ColorConsoleTest$B\n        System.out.println(resolve2);\n    }\n```\n\n## 2.4 获取方法泛型\n\n```java \n    class A {}\n    class B {}\n    class School<T, K> {}\n    class X {\n        public School<A, B> getSchool() {\n            return null;\n        }\n    }\n\n    @Test\n    public void test() {\n        // Spring的提供工具类,用于字段的泛型信息,Person<String>\n        ResolvableType resolvableType = ResolvableType.forMethodReturnType(Objects.requireNonNull(ReflectionUtils.findMethod(X.class, \"getSchool\")));\n        System.out.println(resolvableType);\n        Class<?> resolve1 = resolvableType.getGeneric(0).resolve();\n        // class learn.common.print.ColorConsoleTest$A\n        System.out.println(resolve1);\n        Class<?> resolve2 = resolvableType.getGeneric(1).resolve();\n        // class learn.common.print.ColorConsoleTest$B\n        System.out.println(resolve2);\n    }\n```\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/tools/reflections/Java泛型.md b/docs/learn/tools/reflections/Java泛型.md
--- a/docs/learn/tools/reflections/Java泛型.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/tools/reflections/Java泛型.md	(date 1655373430394)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/project/alfred/README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: false\nbacktotop: true\ntitle: Mac 效率工具必备神器Alfred插件开发\n---\n\n::: tip 如果你还不了解 [Alfred](https://www.alfredapp.com/)\n本文默认你已经知道 Alfred的情况下,进行插件的开发。我们可以编写\n自动化工作流，在工作中帮助我们提高工作效率。\n:::\n\n\n![](https://img.springlearn.cn/blog/learn_1651658394000.png)\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/project/alfred/README.md b/docs/learn/project/alfred/README.md
--- a/docs/learn/project/alfred/README.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/project/alfred/README.md	(date 1655373430766)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/design/中文文档写作规范.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: auto\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 中文文档写作规范\n---\n\n\n::: tip 中文技术文档的写作规范。\n本篇文章参考与阮一峰大佬的网络日志, 总结比较细致。非常具有借鉴意义, 欢迎大家进行学习。\n- 文章参考地址: [阮一峰的网络日志](https://github.com/ruanyf/document-style-guide)\n:::\n\n# 目录\n\n1. [标题](#一、标题)\n1. [文本](#二、文本)\n1. [段落](#三、段落)\n1. [数值](#四、数值)\n1. [标点符号](#五、标点符号)\n1. [文档体系](#六、文档体系)\n1. [参考链接](#七、参考链接)\n\n## 一、标题\n\n### 层级\n\n标题分为四级。\n\n- 一级标题：文章的标题\n- 二级标题：文章主要部分的大标题\n- 三级标题：二级标题下面一级的小标题\n- 四级标题：三级标题下面某一方面的小标题\n\n下面是示例。\n\n```markdown\n# 一级标题\n\n## 二级标题\n\n### 三级标题\n\n#### 四级标题\n```\n\n### 原则\n\n（1）一级标题下，不能直接出现三级标题。\n\n示例：下面的文章结构，缺少二级标题。\n\n```markdown\n# 一级标题\n\n### 三级标题\n```\n\n（2）标题要避免孤立编号（即同级标题只有一个）。\n\n示例：下面的文章结构，`二级标题 A`只包含一个三级标题，完全可以省略`三级标题 A`。\n\n```markdown\n## 二级标题 A\n\n### 三级标题 A\n\n## 二级标题 B\n```\n\n（3）下级标题不重复上一级标题的名字。\n\n示例：下面的文章结构，二级标题与下属的三级标题同名，建议避免。\n\n```markdown\n## 概述\n\n### 概述\n```\n\n（4）谨慎使用四级标题，尽量避免出现，保持层级的简单，防止出现过于复杂的章节。\n\n如果三级标题下有并列性的内容，建议只使用项目列表（Item list）。\n\n示例：下面的结构二要好于结构一。后者适用的场景，主要是较长篇幅的内容。\n\n```markdown\n结构一\n\n### 三级标题\n\n#### 四级标题 A\n\n#### 四级标题 B\n\n#### 四级标题 C\n\n结构二\n\n### 三级标题\n\n**（1）A**\n\n**（2）B**\n\n**（3）C**\n```\n\n\n\n\n## 二、文本\n\n### 字间距\n\n（1）全角中文字符与半角英文字符之间，应有一个半角空格。\n\n```\n错误：本文介绍如何快速启动Windows系统。\n\n正确：本文介绍如何快速启动 Windows 系统。\n```\n\n（2）全角中文字符与半角阿拉伯数字之间，有没有半角空格都可，但必须保证风格统一，不能两种风格混杂。\n\n```\n正确：2011年5月15日，我订购了5台笔记本电脑与10台平板电脑。\n\n正确：2011 年 5 月 15 日，我订购了 5 台笔记本电脑与 10 台平板电脑。\n```\n\n半角的百分号，视同阿拉伯数字。\n\n```\n正确：今年我国经济增长率是6.5%。\n\n正确：今年我国经济增长率是 6.5%。\n```\n\n（3）英文单位若不翻译，单位前的阿拉伯数字与单位间不留空格。\n\n```\n错误：一部容量为 16 GB 的智能手机\n\n正确：一部容量为 16GB 的智能手机\n```\n\n（4）半角英文字符和半角阿拉伯数字，与全角标点符号之间不留空格。\n\n```\n错误：他的电脑是 MacBook Air 。\n\n正确：他的电脑是 MacBook Air。\n```\n\n### 句子\n\n（1）避免使用长句。\n\n不包含任何标点符号的单个句子，或者以逗号分隔的句子构件，长度尽量保持在 20 个字以内；20～29 个字的句子，可以接受；30～39 个字的句子，语义必须明确，才能接受；多于 40 个字的句子，任何情况下都不能接受。\n\n```\n错误：本产品适用于从由一台服务器进行动作控制的单一节点结构到由多台服务器进行动作控制的并行处理程序结构等多种体系结构。\n\n正确：本产品适用于多种体系结构。无论是由一台服务器（单一节点结构），还是由多台服务器（并行处理结构）进行动作控制，均可以使用本产品。\n```\n\n逗号分割的长句，总长度不应该超过 100 字或者正文的 3 行。\n\n（2）尽量使用简单句和并列句，避免使用复合句。\n\n```\n并列句：他昨天生病了，没有参加会议。\n\n复合句：那个昨天生病的人没有参加会议。\n```\n\n（3）同样一个意思，尽量使用肯定句表达，不使用否定句表达。\n\n```\n错误：请确认没有接通装置的电源。\n\n正确：请确认装置的电源已关闭。\n```\n\n（4）避免使用双重否定句。\n\n```\n错误：没有删除权限的用户，不能删除此文件。\n\n正确：用户必须拥有删除权限，才能删除此文件。\n```\n\n### 写作风格\n\n（1）尽量不使用被动语态，改为使用主动语态。\n\n```\n错误：假如此软件尚未被安装，\n\n正确：假如尚未安装这个软件，\n```\n\n（2）不使用非正式的语言风格。\n\n```\n错误：Lady Gaga 的演唱会真是酷毙了，从没看过这么给力的表演！！！\n\n正确：无法参加本次活动，我深感遗憾。\n```\n\n（3）不使用冷僻、生造或者文言文的词语，而要使用现代汉语的常用表达方式。\n\n```\n错误：这是唯二的快速启动的方法。\n\n正确：这是仅有的两种快速启动的方法。\n```\n\n（4）用对“的”、“地”、“得”。\n\n```\n她露出了开心的笑容。\n（形容词＋的＋名词）\n\n她开心地笑了。\n（副词＋地＋动词）\n\n她笑得很开心。\n（动词＋得＋副词）\n```\n\n（5）使用代词时（比如“其”、“该”、“此”、“这”等词），必须明确指代的内容，保证只有一个含义。\n\n```\n错误：从管理系统可以监视中继系统和受其直接控制的分配系统。\n\n正确：从管理系统可以监视两个系统：中继系统和受中继系统直接控制的分配系统。\n```\n\n（6）名词前不要使用过多的形容词。\n\n```\n错误：此设备的使用必须在接受过本公司举办的正式的设备培训的技师的指导下进行。\n\n正确：此设备必须在技师的指导下使用，且指导技师必须接受过由本公司举办的正式设备培训。\n```\n\n### 英文处理\n\n（1）英文原文如果使用了复数形式，翻译成中文时，应该将其还原为单数形式。\n\n```\n英文：⋯information stored in random access memory (RAMs)⋯\n\n中文：……存储在随机存取存储器（RAM）里的信息……\n```\n\n（2）外文缩写可以使用半角圆点(`.`)表示缩写。\n\n```\nU.S.A.\nApple, Inc.\n```\n\n（3）表示中文时，英文省略号（`⋯`）应改为中文省略号（`……`）。\n\n```\n英文：5 minutes later⋯\n\n中文：5 分钟过去了……\n```\n\n（4）英文书名或电影名改用中文表达时，双引号应改为书名号。\n\n```\n英文：He published an article entitled \"The Future of the Aviation\".\n\n中文：他发表了一篇名为《航空业的未来》的文章。\n```\n\n（5）第一次出现英文词汇时，在括号中给出中文标注。此后再次出现时，直接使用英文缩写即可。\n\n```\nIOC（International Olympic Committee，国际奥林匹克委员会）。这样定义后，便可以直接使用“IOC”了。\n```\n\n（6）专有名词中每个词第一个字母均应大写，非专有名词则不需要大写。\n\n```\n“American Association of Physicists in Medicine”（美国医学物理学家协会）是专有名词，需要大写。\n\n“online transaction processing”（在线事务处理）不是专有名词，不应大写。\n```\n\n\n\n\n## 三、段落\n\n### 原则\n\n- 一个段落只能有一个主题，或一个中心句子。\n- 段落的中心句子放在段首，对全段内容进行概述。后面陈述的句子为核心句服务。\n- 一个段落的长度不能超过七行，最佳段落长度小于等于四行。\n- 段落的句子语气要使用陈述和肯定语气，避免使用感叹语气。\n- 段落之间使用一个空行隔开。\n- 段落开头不要留出空白字符。\n\n### 引用\n\n引用第三方内容时，应注明出处。\n\n```\nOne man’s constant is another man’s variable. — Alan Perlis\n```\n\n如果是全篇转载，请在全文开头显著位置注明作者和出处，并链接至原文。\n\n```\n本文转载自 WikiQuote\n```\n\n使用外部图片时，必须在图片下方或文末标明来源。\n\n```\n本文部分图片来自 Wikipedia\n```\n\n\n\n## 四、数值\n\n### 半角数字\n\n阿拉伯数字一律使用半角形式，不得使用全角形式。\n\n```\n错误： 这件商品的价格是１０００元。\n\n正确： 这件商品的价格是 1000 元。\n```\n\n### 千分号\n\n数值为千位以上，应添加千分号（半角逗号）。\n\n```\nXXX 公司的实收资本为 ￥1,258,000 人民币。\n```\n\n对于 4 位以下的数值，千分号是选用的，比如`1000`和`1,000`都可以接受。对于 4 位以上的数值，千分号是必须的。\n\n### 货币\n\n货币应为阿拉伯数字，并在数字前写出货币符号，或在数字后写出货币中文名称。\n\n```\n$1,000\n1,000 美元\n```\n\n英文的货币名称，建议参考国际标准 [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217)。\n\n### 数值范围\n\n表示数值范围时，用`～`或`——`连接。参见《标点符号》一节的“连接号”部分。\n\n带有单位或百分号时，两个数字建议都要加上单位或百分号。\n\n```\n132kg～234kg\n\n67%～89%\n```\n\n### 变化程度的表示法\n\n数字的增加要使用“增加了”、“增加到”。“了”表示增量，“到”表示定量。\n\n```\n增加到过去的两倍\n（过去为一，现在为二）\n\n增加了两倍\n（过去为一，现在为三）\n```\n\n数字的减少要使用“降低了”、“降低到”。“了”表示增量，“到”表示定量。\n\n```\n降低到百分之八十\n（定额是一百，现在是八十）\n\n降低了百分之八十\n（原来是一百，现在是二十）\n```\n\n不能用“降低 N 倍”或“减少 N 倍”的表示法，要用“降低百分之几”或“减少百分之几”。因为减少（或降低）一倍表示数值原来为一百，现在等于零。\n\n\n\n## 五、标点符号\n\n### 原则\n\n（1）中文语句的标点符号，均应该采取全角符号，这样可以与全角文字保持视觉的一致。\n\n（2）如果整句为英文，则该句使用英文/半角标点。\n\n（3）句号、问号、叹号、逗号、顿号、分号和冒号不得出现在一行之首。\n\n### 句号\n\n（1）中文语句的结尾处应该用全角句号（`。`）。\n\n（2）句子末尾用括号加注时，句号应在括号之外。\n\n```\n错误：关于文件的输出，请参照第 1.3 节（见第 26 页。）\n\n正确：关于文件的输出，请参照第 1.3 节（见第 26 页）。\n```\n\n### 逗号\n\n（1）逗号（`，`）表示句子内部的一般性停顿。\n\n（2）注意避免“一逗到底”，即整个段落除了结尾，全部停顿都使用逗号。\n\n### 顿号\n\n（1）句子内部的并列词，应该用全角顿号(`、`) 分隔，而不用逗号，即使并列词是英语也是如此。\n\n```\n错误：我最欣赏的科技公司有 Google, Facebook, 腾讯, 阿里和百度等。\n\n正确：我最欣赏的科技公司有 Google、Facebook、腾讯、阿里和百度等。\n```\n\n（2）英文句子中，并列词语之间使用半角逗号（`,`）分隔。\n\n```\n例句：Microsoft Office includes Word, Excel, PowerPoint, Outlook and other components.\n```\n\n### 分号\n\n（1）分号（`；`）表示复句内部并列分句之间的停顿。\n\n### 引号\n\n（1）引用时，应该使用全角双引号（`“ ”`），注意前后双引号不同。\n\n```\n例句：许多人都认为客户服务的核心是“友好”和“专业”。\n```\n\n（2）引号里面还要用引号时，外面一层用双引号，里面一层用单引号（`‘ ’`），注意前后单引号不同。\n\n```\n例句：鲍勃解释道：“我要放音乐，可萨利说，‘不行！’。”\n```\n\n### 括号\n\n（1）补充说明时，使用全角圆括号（`（）`），括号前后不加空格。\n\n```\n例句：请确认所有的连接（电缆和接插件）均安装牢固。\n```\n\n（2）几种括号的中英文名称。\n\n|       |             英文            |   中文 |\n|-------|:---------------------------:|-------:|\n| `{ }` | braces 或 curly brackets    | 大括号 |\n| `[ ]` | square brackets 或 brackets | 方括号 |\n| `< >` | angled brackets             | 尖括号 |\n| `( )` | parentheses                 | 圆括号 |\n\n### 冒号\n\n（1）全角冒号（`：`）常用在需要解释的词语后边，引出解释和说明。\n\n```\n例句：请确认以下几项内容：时间、地点、活动名称，以及来宾数量。\n```\n\n（2）表示时间时，应使用半角冒号（`:`）。\n\n```\n例句：早上 8:00\n```\n\n### 省略号\n\n（1）省略号（`……`）表示语句未完、或者语气的不连续。\n\n（2）省略号占两个汉字空间、包含六个省略点，不要使用`。。。`或`...`等非标准形式。\n\n（3）省略号不应与“等”这个词一起使用。\n\n```\n错误：我们为会餐准备了香蕉、苹果、梨…等各色水果。\n\n正确：我们为会餐准备了各色水果，有香蕉、苹果、梨……\n\n正确：我们为会餐准备了香蕉、苹果、梨等各色水果。\n```\n\n### 感叹号\n\n（1）应该使用平静的语气叙述，尽量避免使用感叹号（`！`）。\n\n（2）不得多个感叹号连用，比如`！！`和`!!!`。\n\n### 破折号\n\n（1）破折号`————`一般用于进一步解释。\n\n（2）破折号应占两个汉字的位置。如果破折号本身只占一个汉字的位置，那么前后应该留出一个半角空格。\n\n```\n例句：直觉————尽管它并不总是可靠的————告诉我，这事可能出了些问题。\n\n例句：直觉 —— 尽管它并不总是可靠的 —— 告诉我，这事可能出了些问题。\n```\n\n### 连接号\n\n（1）连接号用于连接两个类似的词。\n\n（2）以下场合应该使用直线连接号（`-`），占一个半角字符的位置。\n\n- 两个名词的复合\n- 图表编号\n\n```\n例句：氧化-还原反应\n\n例句：图 1-1\n```\n\n（3）数值范围（例如日期、时间或数字）应该使用波浪连接号（`～`），占一个全角字符的位置。\n\n```\n例句：2009 年～2011 年\n```\n\n注意，波浪连接号前后两个值都应该加上单位。\n\n（4）波浪连接号也可以用汉字“至”代替。\n\n```\n例句：周围温度：-20°C 至 -10°C\n```\n\n\n## 六、文档体系\n\n### 结构\n\n软件手册是一部完整的书，建议采用下面的结构。\n\n- **简介**（Introduction）： [必备] [文件] 提供对产品和文档本身的总体的、扼要的说明\n- **快速上手**（Getting Started）：[可选] [文件] 如何最快速地使用产品\n- **入门篇**（Basics）： [必备] [目录] 又称”使用篇“，提供初级的使用教程\n  - **环境准备**（Prerequisite）：[必备] [文件] 软件使用需要满足的前置条件\n  - **安装**（Installation）：[可选] [文件] 软件的安装方法\n  - **设置**（Configuration）：[必备] [文件] 软件的设置\n- **进阶篇**（Advanced)：[可选] [目录] 又称”开发篇“，提供中高级的开发教程\n- **API**（Reference）：[可选] [目录|文件] 软件 API 的逐一介绍\n- **FAQ**：[可选] [文件] 常见问题解答\n- **附录**（Appendix）：[可选] [目录] 不属于教程本身、但对阅读教程有帮助的内容\n  - **Glossary**：[可选] [文件] 名词解释\n  - **Recipes**：[可选] [文件] 最佳实践\n  - **Troubleshooting**：[可选] [文件] 故障处理\n  - **ChangeLog**：[可选] [文件] 版本说明\n  - **Feedback**：[可选] [文件] 反馈方式\n\n下面是两个真实范例，可参考。\n\n- [Redux 手册](http://redux.js.org/index.html)\n- [Atom 手册](http://flight-manual.atom.io/)\n\n### 文件名\n\n文档的文件名不得含有空格。\n\n文件名必须使用半角字符，不得使用全角字符。这也意味着，中文不能用于文件名。\n\n```\n错误： 名词解释.md\n\n正确： glossary.md\n```\n\n文件名建议只使用小写字母，不使用大写字母。\n\n```\n错误：TroubleShooting.md\n\n正确：troubleshooting.md \n```\n\n为了醒目，某些说明文件的文件名，可以使用大写字母，比如`README`、`LICENSE`。\n\n文件名包含多个单词时，单词之间建议使用半角的连词线（`-`）分隔。\n\n```\n不佳：advanced_usage.md\n\n正确：advanced-usage.md\n```\n\n\n## 七、参考链接\n\n- [产品手册中文写作规范](http://wenku.baidu.com/view/23cc1a6527d3240c8447efbf.html), by 华为\n- [写作规范和格式规范](http://guide.daocloud.io/dcs/%E5%86%99%E4%BD%9C%E8%A7%84%E8%8C%83%E5%92%8C%E6%A0%BC%E5%BC%8F%E8%A7%84%E8%8C%83-9153803.html), by DaoCloud\n- [技术写作技巧在日汉翻译中的应用](http://www.hitachi-tc.co.jp/company/thesis/thesis.pdf), by 刘方\n- [简体中文规范指南](https://www.lengoo.de/documents/styleguides/lengoo_styleguide_ZH.pdf), by lengoo\n- [文档风格指南](https://open.leancloud.cn/copywriting-style-guide.html), by LeanCloud\n- [豌豆荚文案风格指南](https://docs.google.com/document/d/1R8lMCPf6zCD5KEA8ekZ5knK77iw9J-vJ6vEopPemqZM/edit), by 豌豆荚\n- [中文文案排版指北](https://github.com/sparanoid/chinese-copywriting-guidelines), by sparanoid\n- [中文排版需求](http://w3c.github.io/clreq/), by W3C\n- [为什么文件名要小写？](http://www.ruanyifeng.com/blog/2017/02/filename-should-be-lowercase.html), by 阮一峰\n- [Google Developer Documentation Style Guide](https://developers.google.com/style/), by Google\n- [出版物上数字用法的规定（国家标准GBT15835－2011）](http://www.moe.gov.cn/ewebeditor/uploadfile/2015/01/13/20150113091154536.pdf)\n- [中华人民共和国国家标准出版物数字用法](https://baike.baidu.com/item/%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E5%9B%BD%E5%AE%B6%E6%A0%87%E5%87%86%E5%87%BA%E7%89%88%E7%89%A9%E6%95%B0%E5%AD%97%E7%94%A8%E6%B3%95)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/design/中文文档写作规范.md b/docs/learn/design/中文文档写作规范.md
--- a/docs/learn/design/中文文档写作规范.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/design/中文文档写作规范.md	(date 1655373430128)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: auto
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/design/年终总结汇报大纲.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: auto\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 年终总结汇报大纲\n---\n\n\n工作总结框架如下：\n\n## 一、工作开展情况\n\n1.一年来取得的成绩。\n\n2.在单位主要做了哪些工作。\n\n3.目前正在开展的主要工作。\n\n4.下一步要做的工作。\n\n## 二、工作中的创新点、亮点以及经验技巧。\n\n1.哪些环节提高了工作效率。\n\n2.精简和优化了哪些工作流程。\n\n3.为单位节约了哪些成本。\n\n## 三、存在不足和问题分析\n\n1.工作中遇到了哪些困难。\n\n2.出现困难的原因。\n\n3.是如何解决这些困难的。\n\n## 四、来年的打算\n\n1.工作思路计划\n\n2.需要单位给予的哪些支持。#职场加油站# #冬日
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/design/年终总结汇报大纲.md b/docs/learn/design/年终总结汇报大纲.md
--- a/docs/learn/design/年终总结汇报大纲.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/design/年终总结汇报大纲.md	(date 1655373430527)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: auto
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
@@ -47,4 +47,4 @@
 
 1.工作思路计划
 
-2.需要单位给予的哪些支持。#职场加油站# #冬日
\ No newline at end of file
+2.需要单位给予的哪些支持。#职场加油站# #冬日
Index: docs/learn/project/alfred/create-alfred.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: false\nbacktotop: true\ntitle: Alfred添加工作流\n---\n\n## 1. 创建一个新的Workflow\n\n![](https://img.springlearn.cn/blog/learn_1651661121000.png)\n\n## 2. 使用编辑器打开文件夹创建项目\n\n![](https://img.springlearn.cn/blog/learn_1651661168000.png)\n\n\n## 3. 安装Alfred-workflow工作\n\n``` \nnpm install \"alfred-workflow-nodejs\"\n```\n\n## 4. 使用bash启动脚本\n\n![](https://img.springlearn.cn/blog/learn_1651661238000.png)\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/project/alfred/create-alfred.md b/docs/learn/project/alfred/create-alfred.md
--- a/docs/learn/project/alfred/create-alfred.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/project/alfred/create-alfred.md	(date 1655373430759)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/.vuepress/theme/components/Blog/ArticleInfo.vue
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><template>\n  <div v-if=\"author || time\" class=\"article-info\">\n    <!-- Author -->\n    <span v-if=\"author\" :aria-label=\"authorText\" data-balloon-pos=\"right\">\n      <AuthorIcon />\n      <span property=\"author\" v-text=\"author\" />\n    </span>\n\n    <!-- Writing Date -->\n    <span\n      v-if=\"time\"\n      class=\"time\"\n      :aria-label=\"timeText\"\n      data-balloon-pos=\"right\"\n    >\n      <CalendarIcon />\n      <span property=\"datePublished\" v-text=\"time\" />\n    </span>\n\n    <CategoryInfo\n      v-if=\"article.frontmatter.category\"\n      :category=\"article.frontmatter.category\" data-balloon-pos=\"right\"\n    />\n\n    <TagInfo v-if=\"tags.length !== 0\" :tags=\"tags\" />\n\n    <!-- Reading time -->\n    <span\n      v-if=\"readingTime\"\n      class=\"read-time-info\"\n      :aria-label=\"readingTimeText\"\n      data-balloon-pos=\"right\"\n    >\n      <TimerIcon />\n      <span v-text=\"readingTime\" />\n      <meta property=\"timeRequired\" :content=\"readingTimeContent\" />\n    </span>\n  </div>\n</template>\n\n<script src=\"./ArticleInfo\" />\n\n<style lang=\"stylus\">\n$articleInfoTextSize ?= 14px\n\n.article-info\n  color var(--dark-grey)\n  font-size $articleInfoTextSize\n  font-family Arial, Helvetica, sans-serif\n\n  & > span\n    display inline-block\n    margin-right 0.5em\n    line-height 1.8\n\n    @media (max-width $MQMobileNarrow)\n      margin-right 0.3em\n      font-size 0.86rem\n\n    &::after\n      --balloon-font-size 8px\n      padding 0.3em 0.6em !important\n\n    svg\n      position relative\n      bottom -0.125em\n\n    .tags-wrapper\n      display inline-block\n\n  .icon\n    width 1em\n    height 1em\n</style>\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/.vuepress/theme/components/Blog/ArticleInfo.vue b/docs/.vuepress/theme/components/Blog/ArticleInfo.vue
--- a/docs/.vuepress/theme/components/Blog/ArticleInfo.vue	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/.vuepress/theme/components/Blog/ArticleInfo.vue	(date 1655372259670)
@@ -35,6 +35,7 @@
       <span v-text="readingTime" />
       <meta property="timeRequired" :content="readingTimeContent" />
     </span>
+
   </div>
 </template>
 
Index: docs/learn/design/README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: auto\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 没有规矩不成方圆\n---\n\n![](https://img.springlearn.cn/blog/learn_1598165820000.png)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/design/README.md b/docs/learn/design/README.md
--- a/docs/learn/design/README.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/design/README.md	(date 1655373430094)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: auto
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/design/Java代码规范全部奉上.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: auto\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: Java代码规范全部奉上\n---\n\n![](https://img.springlearn.cn/blog/learn_1598165820000.png)\n\n>写代码就像写文章, 好的代码就像好的文章,结构严谨,构思清晰。写代码就像写文章, 一不留神就成流水账，为避免这种情况作为软件开发工程师，重要的是设计而不是实现。\n\n\n**在一个团队中,由于不同经验的开发导致编程风格可能会出现非常混乱的情况,从而导致开发成本上升。难以维护。所以代码规范就显得异常重要了。**\n\n本篇文章就是给出编程命名的建议,仅供参考,但是其目的是为了统一规范,提高编程能力,降低开发成本,减少代码维护成本。\n\n契约精神: 做到有法可依，有章可循。\n\n## 一、类命名\n\n### 1. 抽象类\n\n适用的设计模式为模板模式。抽象是自下往上的设计。由具体实现推断出抽象方法。建议以Abstract开头。\n\n| 建议 | 示例 |\n| ----------------------- | --------------- |\n| Abstract 或者 Base 开头 | BaseUserService、AbstractUserService |\n\n\n### 2. 枚举类\n\n- 枚举是由JVM来保证的单例。可以用来做单例类。\n- 枚举类常用作值判断,不建议每次进行循环判断得到实例。建议由内部维护一个map类型,当做cache。此方法建议放在static静态代码块中实现\n\n| 建议 | 示例 |\n| ------------- | ---------- |\n| Enum 作为后缀 | GenderEnum |\n\n\n```\npublic enum ProtocolEnum {\n\n    /**\n     * ECHO协议\n     */\n    ECHO(1, null),\n\n    /**\n     * mojito协议\n     */\n    MOJITO(2, MojitoProtocol.class);\n\n    private byte type;\n\n    private Class<? extends Protocol> protocol;\n\n    private static Map<Byte, ProtocolEnum> cache = new HashMap<>();\n\n    static {\n        for (ProtocolEnum protocolEnum : values()) {\n            cache.put(protocolEnum.type, protocolEnum);\n        }\n    }\n\n    public static ProtocolEnum byType(byte type) {\n        return cache.get(type);\n    }\n}    \n```\n### 3. 工具类\n\n工具类常为无状态对象,无状态对象都是线程安全对象,建议使用 `final` 修饰。\n\n\n\n工具类中避免出现业务属性, 如果出现业务属性,抽象出领域层\n\n| 建议 | 示例 |\n| ------------- | ---------- |\n| Utils作为后缀 | StringUtils |\n\n\n### 4. 异常类\n\n建议保持异常链。\n\n| 建议 | 示例 |\n| ------------- | ---------- |\n| Exception结尾 | RuntimeException |\n\n\n### 5. 接口实现类\n\n众所周知\n\n| 建议 | 示例 |\n| ------------- | ---------- |\n| 接口名+ Impl | UserServiceImpl |\n\n\n### 6. 设计模式相关类\n\n\n| 建议 | 示例 |\n| ------------- | ---------- |\n| Builder，Factory等 | 当使用到设计模式时，需要使用对应的设计模式作为后缀，如ThreadFactory |\n\n![](https://img.springlearn.cn/27c9d5187cd283f8d160ec1ed2b5ac89.jpg)\n\n### 7. 处理特定功能的\n\n其主要的目的是代码可重复使用。\n\n| 建议 | 示例 |\n| ------------- | ---------- |\n| Handler，Predicate, Validator | 表示处理器，校验器，断言，这些类工厂还有配套的方法名如handle，predicate，validate |\n\n\n### 8. 测试类\n\n\n| 建议 | 示例 |\n| ------------- | ---------- |\n| Test结尾 | UserServiceTest， 表示用来测试UserService类的 |\n\n\n### 9. 领域模型载体\n\n| 建议 | 示例 |\n| ------------- | ---------- |\n| DTO/*Request | 数据传输对象                  |\n| BO           | 业务对象                      |\n| VO           | 数据展示对象,用于承载页面数据 |\n| DO           | 数据持久化对象                |\n\n\n\n## 二、方法命名\n\n参考于网络。\n\n### 1. 布尔判断方法\n\n注：Prefix-前缀，Suffix-后缀，Alone-单独使用\n\n| **位置** | **单词** | **意义**                                                     | **例**        |\n| -------- | -------- | ------------------------------------------------------------ | ------------- |\n| Prefix   | is       | 对象是否符合期待的状态                                       | isValid       |\n| Prefix   | can      | 对象**能否执行**所期待的动作                                 | canRemove     |\n| Prefix   | should   | 调用方执行某个命令或方法是**好还是不好**,**应不应该**，或者说**推荐还是不推荐** | shouldMigrate |\n| Prefix   | has      | 对象**是否持有**所期待的数据和属性                           | hasObservers  |\n| Prefix   | needs    | 调用方**是否需要**执行某个命令或方法                         | needsMigrate  |\n\n\n\n### 2. 检查的方法\n\n注：Prefix-前缀，Suffix-后缀，Alone-单独使用\n\n| **单词** | **意义**                                             | **例**         |\n| -------- | ---------------------------------------------------- | -------------- |\n| ensure   | 检查是否为期待的状态，不是则抛出异常或返回error code | ensureCapacity |\n| validate | 检查是否为正确的状态，不是则抛出异常或返回error code | validateInputs |\n\n\n\n### 3. 按需求才执行的方法\n\n注：Prefix-前缀，Suffix-后缀，Alone-单独使用\n\n| **位置** | **单词**  | **意义**                                  | **例**                 |\n| -------- | --------- | ----------------------------------------- | ---------------------- |\n| Suffix   | IfNeeded  | 需要的时候执行，不需要的时候什么都不做    | drawIfNeeded           |\n| Prefix   | might     | 同上                                      | mightCreate            |\n| Prefix   | try       | 尝试执行，失败时抛出异常或是返回errorcode | tryCreate              |\n| Suffix   | OrDefault | 尝试执行，失败时返回默认值                | getOrDefault           |\n| Suffix   | OrElse    | 尝试执行、失败时返回实际参数中指定的值    | getOrElse              |\n| Prefix   | force     | 强制尝试执行。error抛出异常或是返回值     | forceCreate, forceStop |\n\n\n\n### 4. 异步相关方法\n\n注：Prefix-前缀，Suffix-后缀，Alone-单独使用\n\n| **位置**        | **单词**     | **意义**                                     | **例**                |\n| --------------- | ------------ | -------------------------------------------- | --------------------- |\n| Prefix          | blocking     | 线程阻塞方法                                 | blockingGetUser       |\n| Suffix          | InBackground | 执行在后台的线程                             | doInBackground        |\n| Suffix          | Async        | 异步方法                                     | sendAsync             |\n| Suffix          | Sync         | 对应已有异步方法的同步方法                   | sendSync              |\n| Prefix or Alone | schedule     | Job和Task放入队列                            | schedule, scheduleJob |\n| Prefix or Alone | post         | 同上                                         | postJob               |\n| Prefix or Alone | execute      | 执行异步方法（注：我一般拿这个做同步方法名） | execute, executeTask  |\n| Prefix or Alone | start        | 同上                                         | start, startJob       |\n| Prefix or Alone | cancel       | 停止异步方法                                 | cancel, cancelJob     |\n| Prefix or Alone | stop         | 同上                                         | stop, stopJob         |\n\n\n\n### 5. 回调方法\n\n注：Prefix-前缀，Suffix-后缀，Alone-单独使用\n\n| **位置** | **单词** | **意义**                   | **例**       |\n| -------- | -------- | -------------------------- | ------------ |\n| Prefix   | on       | 事件发生时执行             | onCompleted  |\n| Prefix   | before   | 事件发生前执行             | beforeUpdate |\n| Prefix   | pre      | 同上                       | preUpdate    |\n| Prefix   | will     | 同上                       | willUpdate   |\n| Prefix   | after    | 事件发生后执行             | afterUpdate  |\n| Prefix   | post     | 同上                       | postUpdate   |\n| Prefix   | did      | 同上                       | didUpdate    |\n| Prefix   | should   | 确认事件是否可以发生时执行 | shouldUpdate |\n\n### 6. 操作对象生命周期的方法\n\n注：Prefix-前缀，Suffix-后缀，Alone-单独使用\n\n| **单词**   | **意义**                       | **例**          |\n| ---------- | ------------------------------ | --------------- |\n| initialize | 初始化。也可作为延迟初始化使用 | initialize      |\n| pause      | 暂停                           | onPause ，pause |\n| stop       | 停止                           | onStop，stop    |\n| abandon    | 销毁的替代                     | abandon         |\n| destroy    | 同上                           | destroy         |\n| dispose    | 同上                           | dispose         |\n\n\n\n### 7. 与集合操作相关的方法\n\n注：Prefix-前缀，Suffix-后缀，Alone-单独使用\n\n| **单词** | **意义**                     | **例**     |\n| -------- | ---------------------------- | ---------- |\n| contains | 是否持有与指定对象相同的对象 | contains   |\n| add      | 添加                         | addJob     |\n| append   | 添加                         | appendJob  |\n| insert   | 插入到下标n                  | insertJob  |\n| put      | 添加与key对应的元素          | putJob     |\n| remove   | 移除元素                     | removeJob  |\n| enqueue  | 添加到队列的最末位           | enqueueJob |\n| dequeue  | 从队列中头部取出并移除       | dequeueJob |\n| push     | 添加到栈头                   | pushJob    |\n| pop      | 从栈头取出并移除             | popJob     |\n| peek     | 从栈头取出但不移除           | peekJob    |\n| find     | 寻找符合条件的某物           | findById   |\n\n\n\n### 8. 数据增删改查相关的方法\n\n注：Prefix-前缀，Suffix-后缀，Alone-单独使用\n\n| **单词** | **意义**                               | **例**        |\n| -------- | -------------------------------------- | ------------- |\n| create   | 新创建                                 | createAccount |\n| new      | 新创建                                 | newAccount    |\n| from     | 从既有的某物新建，或是从其他的数据新建 | fromConfig    |\n| to       | 转换                                   | toString      |\n| update   | 更新既有某物                           | updateAccount |\n| load     | 读取                                   | loadAccount   |\n| fetch    | 远程读取                               | fetchAccount  |\n| delete   | 删除                                   | deleteAccount |\n| remove   | 删除                                   | removeAccount |\n| save     | 保存                                   | saveAccount   |\n| store    | 保存                                   | storeAccount  |\n| commit   | 保存                                   | commitChange  |\n| apply    | 保存或应用                             | applyChange   |\n| clear    | 清除数据或是恢复到初始状态             | clearAll      |\n| reset    | 清除数据或是恢复到初始状态             | resetAll      |\n\n### 9. 成对出现的动词\n\n注：Prefix-前缀，Suffix-后缀，Alone-单独使用\n\n| **单词**       | **意义**          |\n| -------------- | ----------------- |\n| get获取        | set 设置          |\n| add 增加       | remove 删除       |\n| create 创建    | destory 移除      |\n| start 启动     | stop 停止         |\n| open 打开      | close 关闭        |\n| read 读取      | write 写入        |\n| load 载入      | save 保存         |\n| create 创建    | destroy 销毁      |\n| begin 开始     | end 结束          |\n| backup 备份    | restore 恢复      |\n| import 导入    | export 导出       |\n| split 分割     | merge 合并        |\n| inject 注入    | extract 提取      |\n| attach 附着    | detach 脱离       |\n| bind 绑定      | separate 分离     |\n| view 查看      | browse 浏览       |\n| edit 编辑      | modify 修改       |\n| select 选取    | mark 标记         |\n| copy 复制      | paste 粘贴        |\n| undo 撤销      | redo 重做         |\n| insert 插入    | delete 移除       |\n| add 加入       | append 添加       |\n| clean 清理     | clear 清除        |\n| index 索引     | sort 排序         |\n| find 查找      | search 搜索       |\n| increase 增加  | decrease 减少     |\n| play 播放      | pause 暂停        |\n| launch 启动    | run 运行          |\n| compile 编译   | execute 执行      |\n| debug 调试     | trace 跟踪        |\n| observe 观察   | listen 监听       |\n| build 构建     | publish 发布      |\n| input 输入     | output 输出       |\n| encode 编码    | decode 解码       |\n| encrypt 加密   | decrypt 解密      |\n| compress 压缩  | decompress 解压缩 |\n| pack 打包      | unpack 解包       |\n| parse 解析     | emit 生成         |\n| connect 连接   | disconnect 断开   |\n| send 发送      | receive 接收      |\n| download 下载  | upload 上传       |\n| refresh 刷新   | synchronize 同步  |\n| update 更新    | revert 复原       |\n| lock 锁定      | unlock 解锁       |\n| check out 签出 | check in 签入     |\n| submit 提交    | commit 交付       |\n| push 推        | pull 拉           |\n| expand 展开    | collapse 折叠     |\n| begin 起始     | end 结束          |\n| start 开始     | finish 完成       |\n| enter 进入     | exit 退出         |\n| abort 放弃     | quit 离开         |\n| obsolete 废弃  | depreciate 废旧   |\n| collect 收集   | aggregate 聚集    |\n\n### 10. 获取必须的参数\n\n| getRequiredProperty | 获取必须的参数,否则报错,该方法一般都要抛出异常          |\n| ------------------- | ------------------------------------------------------- |\n| getProperty         | 非必须参数,可以返回null，不报错，调用方自行判断处理逻辑 |\n\n### 11. 获取数据并对数据进行某种处理\n\n注：Prefix-前缀，Suffix-后缀，Alone-单独使用\n\n| 位置   | 单词         | 意义                                                     | 例子                |\n| ------ | ------------ | -------------------------------------------------------- | ------------------- |\n| Prefix | resolve      | 解决某些问题,比如对文本占位符进行填充,并获取到填充后的值 | resolvePlaceholders |\n| Suffix | Placeholders | 占位符相关命名                                           | resolvePlaceholders |\n\n## 三、方法编程建议\n\n### 1. 方法复杂度\n\n凡是逻辑判断语句均为复杂度。当一个方法中出现了大于等于10个复杂度。建议根据\n\n方法实现进行业务抽离。两个建议点(1. 方法单一职责 2. 方法可重复利用 3. 是否能用策略模式或者命令模式)\n\n\n### 2.方法长度及宽度\n\n长度: 方法的长度建议控制在80-120行以内。满足一屏可以放下。\n宽度: 当方法超过3个及以上入参,建议使用对象封装(对象容易后期扩展,且不会出现眼花缭乱现象)\n\n\n### 3.关注方法优化编辑器提示\n\n减少出现黄色警告⚠️, 最好不要出现警告。编辑器的警告都是优化点,需要在编程时候考虑进去。\n\neg: 性能优化、命名不规范、重复代码\n\n![img](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/a/21643544635/2678603850/7fbfc8ab-22ca-4f92-be04-31c4d1b704e3.png)\n\n### 4.方法重复代码\n\n贫血模型的标志性问题\n\n重复代码编辑器会提出警告,此种现象,强烈建议不要出现\n\n\n\n\n\n### 5. 方法注释\n\n注释是必须要做的(先写注释在做实现)，重在设计。\n\n代码是公司财产, 要对自己对公司对后人负责,先写注释再做实现。\n\n\n\n\n\n## 四、项目依赖模型\n\n\n\n### 1. 领域设计的认识\n\n领域划分,用另外一个词形容也非常的合适,就是业务模块化。所有能力都进行能力化抽象,形成模块,形成领域。 当遇到新的业务逻辑,底层的数据结构和数据关系肯定也是一样的。那么就可以像堆积木一样,根据这些模块快速的组装成新的业务逻辑。快速的实现业务的迭代和升级。\n\n关于这个问题,需要结合自己的业务系统来进行抽象和设计。\n\n\n\n设计核心: 用面向对象的设计思想对业务进行解耦来做到领域划分。\n\n### 2. 层次划分\n\n#### 基础层(外部调用,db操作)\n\n注意: 基础层只做适配不做业务\n\n- db操作以dao结尾\n- 外部调用以Client(Http协议)/Instruction(Rpc协议)\n    - 改层仅仅做数据适配,不做业务处理。\n\n#### 领域层(偏向领域的业务逻辑)\n\n以Manager\n\n#### 业务层(对领域层的业务编排)\n\n以Service结尾\n\n#### 外观层(可以提供能力,可以提供视图)。\n\n以Resource、Facade结尾\n\n\n\n有一个完善的领域层,可以方便快速便捷的对业务进行扩展。与其对立的就是贫血模型。没有领域层只有业务层,业务逻辑都堆积在业务层。典型的面向过程设计。\n\n\n\n![img](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/a/21643544635/2678603850/8be6e99c-f5e9-4a8a-bce4-85f5aa3717e7.png)\n\n### 3. 层次依赖模型\n\nmaven多模块应用和单模块应用通用。\n\n一定要控制项目的依赖情况。\n\n①service只能出现领域层的依赖, 领域层只能存在dao层和第三方服务层。\n\n②各个层代码不能平行调用(出现平行调用逻辑,要抽象出领域层来封装)。\n\n\n\n![img](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/a/21643544635/2678603850/c08a058d-8c81-45c4-bdc4-82d666a304f7.png)\n\n具体代码体现就是\n\n- 以Service命名的类,里面只能存在Manager\n- 以Manager命名的类,里面只能存在Dao和Client(Http协议)/Instruction(Rpc协议)封装的第三方调用\n- 以Dao命名的类是对数据库的操作\n- 以Client(Http协议)/Instruction(Rpc协议)命名的类,作为适配层与第三方API进行交互封装\n\n\n\n## 五、设计模式六大原则\n\n\n\n代码编程时候要向以下这6大原则,进行向其靠拢。\n\n\n\n### 1. 开闭原则\n\n一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。\n\n\n\n**代码设计建议**\n\n用抽象构建框架，用实现扩展细节因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。\n\n\n\n### 2. 单一职责\n\n不要存在多于一个导致类变更的原因通俗的说，即一个类只负责一项职责。\n\n\n\n**代码设计建议**\n\n在具体方法编写或者类编写时候,类编写时候业务要单一,方法编写时候实现要单一\n\n反例:\n\nUserService 类中提供了获取商品信息的接口\n\nsetUserName(String name)方法的时候,对name的值进行了二次处理。\n\n\n\n### 3. **里氏替换原则**\n\n所有引用基类的地方必须能透明地使用其子类的对象。\n\n\n\n**代码设计建议**\n\n面向接口编程, 子类能透明替换父类。\n\n\n\n### 4. **依赖倒置原则**\n\n高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。\n\n\n\n**代码设计建议**\n\n要根据接口或者抽象去设计,不要依赖于细节,eg.项目中要换数据库,不用重新写底层的数据库代码. 就是使用了hibernate一样,替换方言就好了,因为hibernate是根据接口设计的,不同数据库有不同的实现,可以直接使用. eg2: 我生病了要去买药,如果A药铺,没有我就用B药铺买. 因为他们都是药铺,都有一样的功能,可以友好的替换\n\n\n\n### **5. 接口隔离原则**\n\n客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。\n\n\n\n**代码设计建议**\n\n保持最小的责任。\n\neg: 接口ConfigurableApplicationContext实现了Lifecycle和Closeable接口。他们其中每个里面定义的接口都很少,为什么不定义到一起呢?\n\n首先第一责任清晰单一,第二做到接口隔离。\n\n\n\n当某一个方法只用到生命周期的方法,那么方法就可以写成。\n\npublic void stop(Lifecycle lifecycle); 调用时候用->public void stop(new ConfigurableApplicationContext());\n\npublic void close(Closeable closeable); 调用时候用->public void close(new ConfigurableApplicationContext());\n\n\n\nstop里面的实现就只能调用Lifecycle里面的方法,而不能调用ConfigurableApplicationContext里面的方法。从而来达到接口隔离原则\n\n\n\n### 6. **迪米特法则**\n\n一个对象应该对其他对象保持最少的了解。\n\n\n\n**代码设计建议**\n\n减少类与类之间的关系,接口隔离也可以做到。\n\n\n\n## 六、版本迭代\n\nmaster分支版本后缀 ${大版本号}.${0进位}.${迭代版本号}.RELEASE\n\ntest分支版本号 ${大版本号}.${0进位}.${迭代版本号}.SNAPSHOP\n\n\n\n迭代版本可追踪，避免出现jar包覆盖无法追踪\n\n\n\n迭代版本升级,必须升级迭代版本号。避免出现jar包覆盖无法追踪\n\n\n\n### 1. 大版本定义\n\nAPP1.0  APP2.0 APP3.0\n\n\n\n### 2. 迭代版本号\n\nAPP1.0.1  APP1.0版本的第一个迭代\n\nAPP1.1.0  APP1.0版本的第十个迭代\n\nAPP2.0.2  APP2.0版本的第二个迭代\n\nAPP2.1.0  APP2.0版本的第十个迭代\n\n\n\n\n\n## 七、代码格式化\n\n统一格式化模板,解决多人共同开发场景,代码格式化导致的git提交冲突问题\n\n\n\n\n\n\n最后求关注,求订阅,谢谢你的阅读!\n\n\n![](https://img.springlearn.cn/blog/learn_1589360371000.png)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/design/Java代码规范全部奉上.md b/docs/learn/design/Java代码规范全部奉上.md
--- a/docs/learn/design/Java代码规范全部奉上.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/design/Java代码规范全部奉上.md	(date 1655373430188)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: auto
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/design/领域驱动模型的思考与认知.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: auto\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 领域驱动模型的思考与认知\n---\n\n\n> 本项目是基于小编的开发经验与心得,分享小编关于领域模型的理解, 个人愚见仅供参考,希望能为渴望进步的你提供帮助。如果你感到有用对你有帮助,请不要吝啬你的关注,求关注,求转发。\n> 文章有三个议题，什么是领域模型,为什么需要领域模型设计,以及领域驱动的项目结构是什么样的?\n\n\n![](https://img.springlearn.cn/blog/learn_1594392162000.png)\n\n\n## 一、领域驱动模型是什么？\n\n如果你是第一次听到这个词,嗯,多么恐怖的一件事情呀! 什么是领域模型,一种新的技术吗? 领域模型到底有什么用呢?\n为什么那么多大佬都在讲领域模型。网络上充斥着着各种高端的解释,各种高大上的名字,各种复杂的系统设计图。\n\n![](https://img.springlearn.cn/blog/learn_1595078884000.png)\n\nfuck !\n身边总是有这样一群人的出现。总喜欢中文里加载者英文,英文中夹杂着中文,仿佛这样能使他们更加自信一样。把你讲懵了,他就自信了。 very fuck !\n\n身为技术人,尽量想把一种事情给将清楚,说明白。而不是用各种抽象的晦涩难懂但看上去高大上的名词给解释。千万不要怕,下面我们通过先做一点小小的铺垫。最后在总结领域模型的理解。\n\n### 1. 贫血模型\n\n在讲清楚领域模型之前我们先来看引入一个词汇 **“贫血模型”** ，读到这里不要怕。只是一个词汇而已。是对我们平时的项目代码结构的一个形容词。相信无论面前的你\n是一个大牛，还是一个刚入行的小菜鸟。你都一定写过这样的代码:\n\n- dao层: 负责持久化\n- model层: 数据模型\n- service层: 服务层\n- web层: 提供对UI层的访问\n\n\n嗯。这就是一个典型的贫血模型, 哇,真的好形象,这是谁想出来的词汇,真想给他说一句 fuck you!  但是，但是，你还有更好的词汇来形容这种项目结构吗?\n所谓贫血模型是指使用的领域对象中只有 `setter` 和 `getter` 方法（POJO），所有的业务逻辑都不包含在领域对象中而是放在业务逻辑层。\n\n往往我们入行的初期我们都是在这样的项目结构中进行编程的,那个时候我们的业务往往都是简单的,对于那个时候的我们来说,这样的代码结构真是太好用了。清晰易懂。甚至想说一声 i love code !!!\n\n这个时期,我们的关注点往往不是业务的复杂度,而是技术的使用,语法的使用。以及代码是否能编译通过。所以下面我们来总结一下贫血模型的优点。\n\n### 2. 贫血模型优点\n\n1. 被许多程序员所掌握，对于刚入行的同学来说，这种模型很自然很舒服，典型的MVC结构\n2. 它非常简单，对于并不复杂的业务，它工作得很好，开发起来非常迅速。它似乎也不需要对领域的充分了解，只要给出要实现功能的每一个步骤，就能实现它。\n3. 事务边界相当清楚，一般来说service的每个方法都可以看成一个事务。\n\n### 3. 贫血模型缺点\n随着发际线推移,随着历史的变迁,随着候鸟的迁徙。不知不觉我们的业务越来越复杂了。万恶的资本家,总想让我们一夜之间开发一个淘宝,一夜之间开发一个百度,一夜之间开发一个QQ。于是我们的service层,不断的\n不断的增加。代码量从100行,200行,300行,10000行刹不住车了。终于小张忍不住了,辞职走了。留下了孤独的你独自承受这忧伤。\n![](https://img.springlearn.cn/blog/learn_1594392402000.png)\n\n这样代码是什么意思？ 这样代码能不能删？这行代码怎么没有走？这样代码能不能拆出去? 这样改万一项目上线崩溃了怎么办? 想一想老婆,望一望孩子。哎,算了吧。于是乎service复杂度指数般的递增。这就是贫血模型的缺点。\n\n![](https://img.springlearn.cn/blog/learn_1594392441000.png)\n\n**缺点**\n\n1. 所有的业务都在service中处理，当业越来越复杂时，service会变得越来越庞大，最终难以理解和维护，轻则项目组解散，重则妻离子散。\n2. 将所有的业务放在无状态的service中实际上是一个过程化的设计,这与面向对象的编程风格,相向而行。(你转身离开分手说不出来,海鸟跟鱼相爱只是一场意外)\n3. 项目代码写的不少,重用的不多。(fuck and fuck = double kill)\n\n### 4. 充血模型\n前面说我说了贫血模型,这里顺便提一下充血模型,也不要怕,也只是一个吓人的词汇。前面我们理解了贫血模型，那么充血模型，很容易就能理解。\n前面我们说贫血模型实体类只有SET GET方法，逻辑基本在服务层实现。而**充血模型它的实体类里不但有状态，还有行为，即属性和方法都有。它的Service层很薄。**显然者不符合MVC的思想,因为充血模型中model中不仅有数据,还有状态。维护起来非常麻烦。\n\n\n\n### 5. 领域驱动总结\n针对贫血模型的service层非常复杂臃肿的缺点,领域模型的概念越来越流行起来,至少在一些很多的大公司中,非常盛行。领域模型的概念不仅可以重新去设计service,同时也在微服务设计中有重要的意义。\n所以说领域模型其实就是要解决service越来越臃肿的一种设计思想。主要就是对service中的复杂的业务逻辑进行拆分,根据领域来进行拆分。用面向对象的思想去重新设计service。\n有人给他起了一个高大上的词汇: 领域模型。\n\n所以最后小编想用一大白话来总结一下领域模型。\n\n**领域模型就是要用面向对象的思想去重新设计充斥着复杂业务逻辑的service层。**\n\n\n## 二、为什么要进行领域模型设计?\n\n相信看到这里的你,一定对领域模型有一个自己的认识。为什么要进行领域模型设计? 相信自己心里一定有一个自己的判断了。贫血模型的项目结构, service层无可避免的非常的臃肿，臃肿到一个方法可能深不见底。对于业务老油条，可能还凑合能看成，  \n假如你是一个新的同学,当你看到这样的代码一定是崩溃的，假如说注释也没有,那你内心更是崩溃的。假如说这是一个很庞大的系统,很复杂的业务流程,这就更不用说了。\n![](https://img.springlearn.cn/blog/learn_1594478376000.png)\n\n如果读到这里,你还是对领域驱动设计感到迷茫，那么就其实这个标题也可以这样讲: **我们如何对臃肿的service进行面向对象的设计。设计的过程就是对service层的代码进行领域设计。**  \n而我们之所以这样做的目的。\n\n1. 为了快乐的coding\n2. 为了业务系统的稳定\n3. 为了业务更快的迭代升级。\n\n当然这一切的前提是你对业务有一个全局的认识,有一个前瞻性的判断,否则也设计不出来,真正适合自身系统的领域驱动模型。\n\n\n## 三、领域驱动的项目结构是什么样的?\n\n**一千个人眼里有一千个哈姆雷特,没有最好的项目结构,只有最适合自己的业务系统。**本文只是小编对领域驱动的模块的思考和认识。\n仅供参考,希望对你有所启示和引导。\n\n\n### 1. 领域划分|模块化建造\n\n![](https://img.springlearn.cn/blog/learn_1594574191000.png)\n\n领域划分,小编感觉用另外一个词形容也非常的合适,就是业务模块化。所有能力都进行能力化抽象,形成模块,形成领域。 当遇到新的业务逻辑,底层的数据结构和数据关系肯定也是一样的。那么就可以像堆积木一样,根据这些模块快速的组装成新的业务逻辑。快速的实现业务的迭代和升级。\n关于这个问题,需要结合自己的业务系统来进行抽象和设计。而小编的能做的就是,提醒你**模块化设计,领域化设计的重要意义。**\n\n### 2. 项目结构\n\n基础层(外部调用,db操作) + 领域层(偏向领域的业务逻辑) + 业务层(对领域层的业务编排) + 外观层(可以提供能力,可以提供视图)。\n有一个完善的领域层,可以方便快速便捷的对业务进行扩展。\n\n![](https://img.springlearn.cn/blog/learn_1595074590000.png)\n\n领域层就是模块化设计的积木。丰富的模块化有助于业务扩展。\n\n一定要控制项目的依赖情况。service只能出现领域层的依赖, 领域层只能存在dao层和第三方服务层。各个层代码不能平行调用。\n\n![](https://img.springlearn.cn/blog/learn_1595069641000.png)\n\n\n### 3. 编程规范\n\n\n关于项目提出6个注意的点。如果把做项目比作是前线打仗,那么打仗最重要的是战斗成员目标要一致。在目标不一致的情况下一定要进行\n充分讨论(项目负责人要做的),说明情况互相妥协指定出统一的项目编程规范。去进行执行。一旦指定不能违背。否则项目质量不保。\n\n**项目固然重要,但是作为软件开发工程师,首先要对代码质量做保障。**\n\n![](https://img.springlearn.cn/blog/learn_1595078292000.png)\n\n\n\n### 4. 日志设计\n\n天下没有完美的项目,任何系统不存在bug是不可能的。想要发现bug并快速定位问题,日志系统的不能缺少的。\n\n日志系统是非常重要的系统, 对系统的监控, 在设计日志系统中,我们需要关注的点\n1. 日志结构(目的是按照结构解析到日志引擎中)\n   如果想做日志的搜索平台,一定要进行日志结构化设计,方便被搜索平台的解析。如ELK日志搜索系统。\n2. 日志打印降级能力\n   在遇到大促时候,可以减少不必要的日志打印,要对日志打印做降级的设计\n3. 异步输入日志\n4. 日志归档\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<configuration>\n    <!-- 系统日志打印 -->\n    <appender name=\"logfile\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n        <File>${logger.logback.logpath}mbp-game-service.log</File>\n        <encoder>\n            <Pattern>[%date] [%-5level] %c{40} %line --%mdc{client} [%X{TRACE_LOG_ID}] [%X{dstTraceId}] %msg%n</Pattern>\n            <charset>UTF-8</charset>\n        </encoder>\n        <rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\">\n            <fileNamePattern>${logger.logback.logpath}mbp-game-service.%d{yyyy-MM-dd}.%i.log</fileNamePattern>\n            <maxHistory>30</maxHistory>\n            <TimeBasedFileNamingAndTriggeringPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP\">\n                <maxFileSize>512MB</maxFileSize>\n            </TimeBasedFileNamingAndTriggeringPolicy>\n        </rollingPolicy>\n    </appender>\n\n    <!-- 异步输出 -->\n    <appender name=\"asyncAppender\" class=\"ch.qos.logback.classic.AsyncAppender\">\n        <!-- 不丢失日志.默认的,如果队列的80%已满,则会丢弃TRACT、DEBUG、INFO级别的日志 -->\n        <discardingThreshold>0</discardingThreshold>\n        <!-- 更改默认的队列的深度,该值会影响性能.默认值为256 -->\n        <queueSize>1024</queueSize>\n        <!-- 添加附加的appender,最多只能添加一个 -->\n        <appender-ref ref=\"logfile\"/>\n    </appender>\n\n\n    <!-- 外部jar包 日志级别设置 -->\n    <logger level=\"${logger.outside.logLevel}\" name=\"com.ibatis\"/>\n    <logger level=\"${logger.outside.logLevel}\" name=\"org.springframework\"/>\n    <logger level=\"${logger.outside.logLevel}\" name=\"java.sql\"/>\n    <logger level=\"${logger.outside.logLevel}\" name=\"org.apache\"/>\n    <logger level=\"${logger.outside.logLevel}\" name=\"com.alibaba.dubbo\"/>\n    <logger level=\"${logger.outside.logLevel}\" name=\"org.I0Itec\"/>\n    <logger level=\"${logger.outside.logLevel}\" name=\"org.dozer\"/>\n    <logger level=\"${logger.outside.logLevel}\" name=\"kafka.producer.SyncProducer\"/>\n    <logger level=\"${logger.kafka.outside.logLevel}\" name=\"org.apache.kafka\"/>\n    <logger level=\"${logger.kafka.outside.logLevel}\" name=\"org.springframework.kafka\"/>\n\n    <!-- 输出到文件，可定义更多的 Appender -->\n    <root level=\"${logger.logLevel}\">\n        <appender-ref ref=\"asyncAppender\"/>\n    </root>\n\n</configuration>\n```\n\n\n\n\n最后求关注,求订阅,谢谢你的阅读!\n\n\n![](https://img.springlearn.cn/blog/learn_1589360371000.png)\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/design/领域驱动模型的思考与认知.md b/docs/learn/design/领域驱动模型的思考与认知.md
--- a/docs/learn/design/领域驱动模型的思考与认知.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/design/领域驱动模型的思考与认知.md	(date 1655373430101)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: auto
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/guide/disable.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\ntitle: 组件禁用\nicon: config\ncategory: 使用指南\n\nnavbar: false\nsidebar: false\n\nbreadcrumb: false\npageInfo: false\ncontributor: false\neditLink: false\nupdateTime: false\nprev: false\nnext: false\ncomment: false\nfooter: false\n\nbacktotop: false\n---\n\n你可以通过设置页面的 Frontmatter，在页面禁用一些功能。\n\n<!-- more -->\n\n本页面应当禁用了:\n\n- 导航栏\n- 侧边栏\n- 路径导航\n- 页面信息\n- 贡献者\n- 编辑此页链接\n- 更新时间\n- 上一篇/下一篇 链接\n- 评论\n- 页脚\n- 返回顶部按钮\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/guide/disable.md b/docs/learn/guide/disable.md
--- a/docs/learn/guide/disable.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/guide/disable.md	(date 1655373430395)
@@ -7,7 +7,7 @@
 sidebar: false
 
 breadcrumb: false
-pageInfo: false
+pageInfo: true
 contributor: false
 editLink: false
 updateTime: false
Index: docs/learn/guide/test.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: auto\npageInfo: false\ncontributor: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 指南\n---\n\n不是使用自动生成侧边栏，而是使用。自定以侧边栏。\n\nhttps://vuepress-theme-hope.github.io/zh/guide/layout/sidebar/#%E4%BE%A7%E8%BE%B9%E6%A0%8F%E5%88%86%E7%BB%84\n## 一、本站知识阅览\n### 1. 多撒多\n### 2. fdsa \n## 二、学习路线参\n考\n范德萨\n## 三、Java\n德萨\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/guide/test.md b/docs/learn/guide/test.md
--- a/docs/learn/guide/test.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/guide/test.md	(date 1655373430753)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: auto
-pageInfo: false
+pageInfo: true
 contributor: true
 updateTime: true
 prev: true
Index: docs/learn/tools/pool2/README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\nsidebarDepth: 3\ntitle: 池化技术\npassword: 123\nicon: zuanshi\n---\n\n:::info 羽化而登仙，池化而提效\n本篇文章我们的研究专题是池化技术, 其实所谓池化可以简单理解为缓存。将那些创建比较耗时的对象,缓存起来,放到一个池子里。\n比如数据库连接池，线程池，字符串常量池。这个技术常用于框架类设计。本文教你基于Apache-commons-pool2快速实现一个常量池的设计。\n:::\n\n\n## 一、Pool2 四大件\n\n![](https://img.springlearn.cn/blog/learn_1651339646000.png)\n\n\n### 1.1 新建资源\n\n![](https://img.springlearn.cn/blog/learn_1651340254000.png)\n\n\n### 1.2 回收资源\n\n![](https://img.springlearn.cn/blog/learn_1651340687000.png)\n\n## 二、数据库连接池实战\n\n我们利用Common Pool2工具 可以使用很少的代码就实现了池化的能力。\n\n## 2.2 构建连接工厂\n\n可以看到核心方法非常少，开发者只用实现很少方法即可\n\n1. makeObject 创建资源\n2. activateObject 资源被激活时候调用\n3. passivateObject 资源在回收时候调用\n4. validateObject 当配置了资源检查时候会在创建和回收时候调用\n5. destroyObject 资源在销毁时候调用\n\n```java  \npublic class PooledConnectFactory implements PooledObjectFactory<Connection> {\n\n\n    /**\n     * 数据库连接\n     */\n    private final String url;\n\n    /**\n     * 用户名\n     */\n    private final String userName;\n\n    /**\n     * 数据密码\n     */\n    private final String password;\n\n    public PooledConnectFactory(String url, String userName, String password) {\n        this.url = url;\n        this.userName = userName;\n        this.password = password;\n    }\n\n    /**\n     * 对象被激活后，会进行调用\n     *\n     * @param pooledObject a {@code PooledObject} wrapping the instance to be activated\n     */\n    @Override\n    public void activateObject(PooledObject<Connection> pooledObject) throws Exception {\n    }\n\n    /**\n     * 销毁数据库连接\n     *\n     * @param pooledObject a {@code PooledObject} wrapping the instance to be destroyed\n     * @throws Exception 异常\n     */\n    @Override\n    public void destroyObject(PooledObject<Connection> pooledObject) throws Exception {\n        Connection connection = pooledObject.getObject();\n        connection.close();\n    }\n\n    /**\n     * 创建一个数据库连接\n     *\n     * @return 数据库连接的池对象包装\n     * @throws Exception 异常\n     */\n    @Override\n    public PooledObject<Connection> makeObject() throws Exception {\n        Connection connection = DriverManager.getConnection(this.url, this.userName, this.password);\n        return new DefaultPooledObject<>(connection);\n    }\n\n    /**\n     * 回收资源时候进行调用\n     * @param pooledObject a {@code PooledObject} wrapping the instance to be passivated\n     *\n     * @throws Exception\n     */\n    @Override\n    public void passivateObject(PooledObject<Connection> pooledObject) throws Exception {\n\n    }\n\n    @Override\n    @SneakyThrows\n    public boolean validateObject(PooledObject<Connection> pooledObject) {\n        Connection connection = pooledObject.getObject();\n        // 如果连接关闭说明已经失效就返回false告诉池子,已经失效,会自动移除\n        return !connection.isClosed();\n    }\n}\n```\n\n## 2.3 连接池演示\n\n```java \n    @Test\n    @DisplayName(\"验证回收对象\")\n    public void testReturn()throws Exception{\n        // 1. 构建一个数据连接池化工厂\n        String dbUrl = \"jdbc:mysql://127.0.0.1:3306/test\";\n        String user = \"root\";\n        String pass = \"123456\";\n        PooledConnectFactory pooledConnectFactory = new PooledConnectFactory(dbUrl, user, pass);\n\n        // 2. 给池子添加支持的配置信息\n        GenericObjectPoolConfig<Connection> config = new GenericObjectPoolConfig<Connection>();\n        // 2.1 最大池化对象数量\n        config.setMaxTotal(5);\n        // 2.2 最大空闲池化对象数量\n        config.setMaxIdle(2);\n        // 2.3 最小空闲池化对象数量\n        config.setMinIdle(2);\n        // 2.4 间隔多久检查一次池化对象状态,驱逐空闲对象,检查最小空闲数量小于就创建\n        config.setTimeBetweenEvictionRuns(Duration.ofSeconds(5));\n        // 2.5 阻塞就报错\n        config.setBlockWhenExhausted(true);\n        // 2.6 最大等待时长超过5秒就报错,如果不配置一直进行等待\n        config.setMaxWait(Duration.ofSeconds(5));\n        // 2.7 是否开启jmx监控,默认开启\n        config.setJmxEnabled(true);\n        // 2.8 一定要符合命名规则,否则无效\n        config.setJmxNameBase(\"org.apache.commons.pool2:type=MysqlConnObjectPool,name=ConnectJmxNameBase\");\n        // 生成数据库连接池\n        // 连接池配置最大5个连接setMaxTotal(5),但是获取6次,那么有一次获取不到就会阻塞setBlockWhenExhausted(true),\n        // 当等待了10秒setMaxWait(Duration.ofSeconds(10))还是获取不到。就直接报错\n        try (GenericObjectPool<Connection> connPool = new GenericObjectPool<>(pooledConnectFactory, config)) {\n            for (int i = 1; i <= 7; i++) {\n                Connection connection = connPool.borrowObject();\n                Statement statement = connection.createStatement();\n                ResultSet show_tables = statement.executeQuery(\"show tables\");\n                printRows(\"Connect-\" + i + \">\", show_tables);\n                connPool.returnObject(connection);\n            }\n        }\n    }\n```\n\n甚至还能配置支持jmx管理。非常的简单和方便。\n\n![](https://img.springlearn.cn/blog/learn_1651342753000.png)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/tools/pool2/README.md b/docs/learn/tools/pool2/README.md
--- a/docs/learn/tools/pool2/README.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/tools/pool2/README.md	(date 1655373430481)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/java/线程组.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 给线程归归类\ncategory: Java进阶\n---\n\n\n![](https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png)\n\n**作者**: 西魏陶渊明\n**博客**: [https://blog.springlearn.cn/](https://blog.springlearn.cn/)\n\n::: tip 西魏陶渊明\n莫笑少年江湖梦，谁不少年梦江湖\n:::\n\n# 线程组\n\n可以把线程归属到某一个线程组中，线程组中可以有线程对象，也可以有线程组，组中还可以有线程，这样的组织结构有点类似于树的形式，如图所示.\n\n线程组的作用是：可以批量管理线程或线程组对象，有效地对线程或线程组对象进行组织\n![](https://img.springlearn.cn/blog/learn_1599301362000.png)\n\n\n线程组提供对组内的线程的管理能力,如我们可以用一个线程组里面的线程去执行任务,任何一个任务失败,就把所有组内的线程都给中断。\n\n```java\npublic class MThreadGroup extends ThreadGroup {\n    public MThreadGroup(String s) {\n        super(s);\n    }\n\n    public MThreadGroup(ThreadGroup threadGroup, String s) {\n        super(threadGroup, s);\n    }\n\n    @Override\n    public void uncaughtException(Thread thread, Throwable throwable) {\n        //任何一个线程异常就讲所有组内的线程中断\n        thread.getThreadGroup().interrupt();\n    }\n}\n```\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/java/线程组.md b/docs/learn/java/线程组.md
--- a/docs/learn/java/线程组.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/java/线程组.md	(date 1655373430369)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/java/Condition.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 没有条件创造条件Condition\ncategory: Java进阶\n---\n\n\n![](https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png)\n\n**作者**: 西魏陶渊明\n**博客**: [https://blog.springlearn.cn/](https://blog.springlearn.cn/)\n\n::: tip 西魏陶渊明\n莫笑少年江湖梦，谁不少年梦江湖\n:::\n\n\nhttps://blog.csdn.net/a1439775520/article/details/98471610\n\n\nCondition 是为了调换 Object 中的 wait()\n和notify().\n\n|API|Object|Condition|\n|:---:|:---:|:---:|\n|等待|wait()|wait()|\n|通知|notify()|signal()|\n|通知所有|notifyAll()|signalAll()|\n\n**wait是会释放锁**\n\n## 相同点\n\n- 都必须被包裹在同步代码块中，即加锁\n- 当调用wait都会释放锁\n\n## 不同点\n\n- Object 依赖 synchronized 锁\n- Condition 依赖 Lock 锁\n\n## ObjectWait\n\n::: tip 运行结果\n- 当前线程进入线程一\n- 当前线程进入线程二\n- 当前线程释放main\n- 当前线程释放main\n- 当前线程退出线程一\n- 当前线程退出线程二\n:::\n  \n```java ObjectWait\n/**\n * @author liuxin\n * 2022/1/5 12:24 上午\n */\npublic class ObjectWait {\n\n    public synchronized void objWait() throws Exception {\n        System.out.println(\"当前线程进入\" + Thread.currentThread().getName());\n        wait();\n        System.out.println(\"当前线程退出\" + Thread.currentThread().getName());\n    }\n\n    public synchronized void objNotify() throws Exception {\n        System.out.println(\"当前线程释放\" + Thread.currentThread().getName());\n        notify();\n    }\n\n    public static void main(String[] args) throws Exception {\n        ObjectWait objectWait = new ObjectWait();\n        // 使用synchronized修饰方法，就是锁的是当前这个示例synchronized(this)\n        new Thread(() -> {\n            try {\n                // 当前进入等待，然后释放锁。wait会释放锁\n                objectWait.objWait();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        },\"线程一\").start();\n\n        // 使用synchronized修饰方法，就是锁的是当前这个示例synchronized(this)\n        new Thread(() -> {\n            try {\n                // 当前进入等待，然后释放锁。wait会释放锁\n                objectWait.objWait();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        },\"线程二\").start();\n        Thread.sleep(1000L);\n        // 释放锁后才会放行\n        objectWait.objNotify();\n        // 释放锁后才会放行\n        objectWait.objNotify();\n    }\n}\n\n```\n\n## LockWait\n\n::: tip 运行结果\n- 当前线程进入线程一\n- 当前线程进入线程二\n- 当前线程释放main\n- 当前线程释放main\n- 当前线程退出线程一\n- 当前线程退出线程二\n:::\n\n```java  LockWait\n/**\n * @author liuxin\n * 2022/1/5 24:24 上午\n */\npublic class LockWait {\n\n    private ReentrantLock lock = new ReentrantLock();\n\n    private Condition condition = lock.newCondition();\n\n    public void lockWait() throws Exception {\n        lock.lock();\n        System.out.println(\"当前线程进入\" + Thread.currentThread().getName());\n        condition.await();\n        System.out.println(\"当前线程退出\" + Thread.currentThread().getName());\n        lock.unlock();\n    }\n\n    public void lockNotify() {\n        lock.lock();\n        System.out.println(\"当前线程释放\" + Thread.currentThread().getName());\n        condition.signal();\n        lock.unlock();\n    }\n\n    public static void main(String[] args) throws Exception {\n        LockWait lockWait = new LockWait();\n        // lock.lock()  线程一: 获取锁,然后wait之后，进入释放锁,然后进入到等待队列\n        new Thread(() -> {\n            try {\n                // 当前进入等待，然后释放锁。\n                lockWait.lockWait();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }, \"线程一\").start();\n        // lock.lock()  当前线程二获取锁,然后wait之后，进入释放锁,然后进入到等待队列\n        new Thread(() -> {\n            try {\n                // 当前进入等待，然后释放锁。\n                lockWait.lockWait();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        },\"线程二\").start();\n\n        Thread.sleep(1000L);\n        // 调用第一次，会唤醒线程一，继续向下执行\n        lockWait.lockNotify();\n        // 调用第二次，会唤醒线程二，继续向下执行\n        lockWait.lockNotify();\n    }\n}\n\n```\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/java/Condition.md b/docs/learn/java/Condition.md
--- a/docs/learn/java/Condition.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/java/Condition.md	(date 1655373430090)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/java/ReentrantLock.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 重入锁 ReentrantLock\ncategory: Java进阶\n---\n\n\n![](https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png)\n\n**作者**: 西魏陶渊明\n**博客**: [https://blog.springlearn.cn/](https://blog.springlearn.cn/)\n\n::: tip 西魏陶渊明\n莫笑少年江湖梦，谁不少年梦江湖\n:::\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/java/ReentrantLock.md b/docs/learn/java/ReentrantLock.md
--- a/docs/learn/java/ReentrantLock.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/java/ReentrantLock.md	(date 1655373430390)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/java/JMX.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: Java管理扩展\ncategory: Java进阶\n---\n\n![](https://img.springlearn.cn/blog/learn_1590919227000.png)\n\n**作者**: 西魏陶渊明\n**博客**: [https://blog.springlearn.cn/](https://blog.springlearn.cn/)\n\n::: tip 西魏陶渊明\n莫笑少年江湖梦，谁不少年梦江湖\n:::\n\n **JMX（Java Management Extensions，即Java管理扩展）是一个为应用程序、设备、系统等植入管理功能的框架。JMX可以跨越一系列异构操作系统平台、系统体系结构和网络传输协议，灵活的开发无缝集成的系统、网络和服务管理应用。**\n\n\n\n 前面是对JMX的介绍，那么JMX在我们日常的开发过程中，有什么实际的意义呢? 相信很多做Java开发的同学都使用过JDK自带的 jconsole 或者 jvisualvm 监控过JVM的运行情况，但不知道有没有留意过它们会有一个MBean的功能/标签，通过MBean可以看到在JVM中运行的组件的一些属性和操作。下面小编就通过一个SpringBoot应用来一探究竟。并教会你如何自定义扩展。\n\n\n\n ## 一、实际意义\n\n ### 1. 启动一个SpringBoot应用\n\n 下面我们以SpringBoot应用为例子，启动一个SpringBoot项目。端口是 `8080`\n\n ![](https://img.springlearn.cn/blog/learn_1590921574000.png)\n\n\n\n ### 2. 命令行打开Jconsole\n\n ![](https://img.springlearn.cn/blog/learn_1590921682000.png)\n\n\n\n ### 3. 连接前面的应用\n\n ![image-20200531184151871](https://tva1.sinaimg.cn/large/007S8ZIlly1gfbtkkzi1bj30p00ku761.jpg)\n\n 选中MBean标签,然后可以看到一个SpringApplication的类。shutdown是服务下线。\n\n ![](https://img.springlearn.cn/blog/learn_1590921783000.png)\n\n 当我们点击了shutdown方法后,应用就会自动的关闭了。导致Jconsole连接丢失\n ![image-20200531184702204](https://tva1.sinaimg.cn/large/007S8ZIlly1gfbtpwfbbqj30oy0i2gof.jpg)\n\n getProperty方法是获取应用中的配置信息。如图我们获取redis的相关信息。可以看到返回值是Spring应用中我们定义的值\n 6379\n\n ![](https://img.springlearn.cn/blog/learn_1590921918000.png)\n\n\n\n ![image-20200531184553346](https://tva1.sinaimg.cn/large/007S8ZIlly1gfbtoo8x1yj30lc07imy6.jpg)\n\n\n\n 那么其实这个能力就是利用JMX提供的接口来实现的。下面我们通过分析SpringBoot中的源码来看他是如何实现的。\n\n\n\n ---\n\n ## 二、源码追踪看SpringBoot应用如何实现?\n\n 我们通过看Jconsole工具,可以看到工具里面的类名叫SpringApplication，目录是admin，于是我们就根据这个推测SpringBoot中的命名,果然我们找到两个实现类。\n\n ![](https://img.springlearn.cn/blog/learn_1590922192000.png)\n\n\n **1. SpringApplicationAdminMXBean**\n\n 这个类就是JMX中的MBean，我们可以简单理解这个里面的方法都是可以通过Jconsole来调用的。\n 通过将这个类注册给JMX管理器就能实现在Jconsole中的数据展示。\n\n 首先看**SpringApplicationAdminMXBean**\n\n ```java\n public interface SpringApplicationAdminMXBean {\n    //是否可读\n    boolean isReady();\n    //是否web应用\n    boolean isEmbeddedWebApplication();\n    //获取配置信息\n    String getProperty(String key);\n    //下线应用\n    void shutdown();\n }\n ```\n\n 实现类**SpringApplicationAdmin**,是SpringApplicationAdminMXBeanRegistrar的内部类\n\n ```java\n private class SpringApplicationAdmin implements SpringApplicationAdminMXBean {\n     // 是否可读，当应用还没起来时候这个值是false\n       @Override\n       public boolean isReady() {\n          return SpringApplicationAdminMXBeanRegistrar.this.ready;\n       }\n       // 是否是web应用\n       @Override\n       public boolean isEmbeddedWebApplication() {\n          return SpringApplicationAdminMXBeanRegistrar.this.embeddedWebApplication;\n       }\n     // 从Spring的配置信息中实时读取值\n       @Override\n       public String getProperty(String key) {\n          return SpringApplicationAdminMXBeanRegistrar.this.environment.getProperty(key);\n       }\n     // 关闭Spring应用\n       @Override\n       public void shutdown() {\n          logger.info(\"Application shutdown requested.\");\n          SpringApplicationAdminMXBeanRegistrar.this.applicationContext.close();\n       }\n\n    }\n ```\n\n\n\n **2. SpringApplicationAdminMXBeanRegistrar**\n\n 提供注册能力。这个类中我们可以知道如何注册JMX以及如何取消注册。下面我看这个类如何利用Spring提供的接口能力,来实现应用下线。及注册到JMX上的吧。\n\n ![](https://img.springlearn.cn/blog/learn_1590922871000.png)\n\n 自动化配置将SpringApplicationAdminMXBeanRegistrar声明成一个Spring中的Bean对象。并配置JMX中的命名及目录。\n ![](https://img.springlearn.cn/blog/learn_1590923451000.png)\n\n\n\n ### 1. ApplicationContextAware\n\n 获得读取上下文能力。在Spring容器中一个bean如何实现了该方法则就可以获取上下文对象。\n\n ```\n    @Override\n    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n       Assert.state(applicationContext instanceof ConfigurableApplicationContext,\n             \"ApplicationContext does not implement ConfigurableApplicationContext\");\n       this.applicationContext = (ConfigurableApplicationContext) applicationContext;\n    }\n ```\n\n ### 2. GenericApplicationListener\n\n 获取处理事件的能力,同样在Spring中只要实现该接口,就获取了事件监听的能力,不过具体监听什么事件要自己去判断。大家可以根据例子\n 来理解。\n\n ```\n   // 根据事件泛型判断是否需要处理，这里判断如果是ApplicationReadyEvent和WebServerInitializedEvent\n   // 事件就处理\n   @Override\n    public boolean supportsEventType(ResolvableType eventType) {\n       Class<?> type = eventType.getRawClass();\n       if (type == null) {\n          return false;\n       }\n       return ApplicationReadyEvent.class.isAssignableFrom(type)\n             || WebServerInitializedEvent.class.isAssignableFrom(type);\n    }\n\n    @Override\n    public boolean supportsSourceType(Class<?> sourceType) {\n       return true;\n    }\n\n    @Override\n    public void onApplicationEvent(ApplicationEvent event) {\n     // 如果Spring已经准备好了,就将this.ready = true;\n       if (event instanceof ApplicationReadyEvent) {\n          onApplicationReadyEvent((ApplicationReadyEvent) event);\n       }\n     // 如果是Web应用,this.embeddedWebApplication = true\n       if (event instanceof WebServerInitializedEvent) {\n          onWebServerInitializedEvent((WebServerInitializedEvent) event);\n       }\n    }\n    //优先级\n    @Override\n    public int getOrder() {\n       return Ordered.HIGHEST_PRECEDENCE;\n    }\n\n    void onApplicationReadyEvent(ApplicationReadyEvent event) {\n       if (this.applicationContext.equals(event.getApplicationContext())) {\n          this.ready = true;\n       }\n    }\n\n    void onWebServerInitializedEvent(WebServerInitializedEvent event) {\n       if (this.applicationContext.equals(event.getApplicationContext())) {\n          this.embeddedWebApplication = true;\n       }\n    }\n ```\n\n ### 3. EnvironmentAware\n\n 获取应用配置信息, 和上面一样实现了Aware结尾的接口,都能获取对象的Spring内容的对象实例，然后我们就可以根据该实例,来进行功能扩展。\n\n ```\n @Override\n    public void setEnvironment(Environment environment) {\n       this.environment = environment;\n    }\n ```\n\n ### 4. InitializingBean\n\n 这里就要着重看了，在初始化时候将MBean注册到JMX上。当然我们可以通过 @PostConstruct注解来声明初始化方法。\n\n ```\n @Override\n    public void afterPropertiesSet() throws Exception {\n       MBeanServer server = ManagementFactory.getPlatformMBeanServer();\n       server.registerMBean(new SpringApplicationAdmin(), this.objectName);\n       if (logger.isDebugEnabled()) {\n          logger.debug(\"Application Admin MBean registered with name '\" + this.objectName + \"'\");\n       }\n    }\n ```\n\n ### 5. DisposableBean\n\n 应用销毁时候,取消注册。同样我们也可以用@PreDestroy注解来实现\n\n ```\n @Override\n    public void destroy() throws Exception {\n       ManagementFactory.getPlatformMBeanServer().unregisterMBean(this.objectName);\n    }\n ```\n\n\n\n 通过对SpringBoot应用源码的追踪，我们大概已经明白JMX的实际意义了，并且能自定义一个能提供类似能力的MBean了吧，但是JMX能做的远远不止如此。\n\n\n\n ## 三、自定义MBean\n\n 注意接口名必须是MBean结尾，实现类必须去掉MBean\n\n 如CustomMBean接口对应的实现类必须是Custom。\n\n ### 1. 代码实现\n\n ```java\n @Component\n public class CustomMbeanRegistrar implements ApplicationContextAware, InitializingBean, DisposableBean {\n     private ConfigurableApplicationContext applicationContext;\n     private ObjectName objectName = new ObjectName(\"com.example.demo:type=CustomAdmin,name=CustomMXBean\");\n\n     public CustomMbeanRegistrar() throws MalformedObjectNameException {\n     }\n     @Override\n     public void destroy() throws Exception {\n         ManagementFactory.getPlatformMBeanServer().unregisterMBean(this.objectName);\n     }\n\n     @Override\n     public void afterPropertiesSet() throws Exception {\n         MBeanServer server = ManagementFactory.getPlatformMBeanServer();\n         server.registerMBean(new Custom(), this.objectName);\n     }\n\n     @Override\n     public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n         this.applicationContext = (ConfigurableApplicationContext) applicationContext;\n     }\n\n     public interface CustomMBean {\n         int getDatabaseConnectionPoolSize();\n         void customShutdown();\n     }\n\n     private class Custom implements CustomMBean {\n\n         /**\n          * 获取数据库连接池大小\n          *\n          * @return 模拟\n          */\n         @Override\n         public int getDatabaseConnectionPoolSize() {\n             return new Random().nextInt(100);\n         }\n\n         /**\n          * 自定义一个销毁方法\n          */\n         public void customShutdown() {\n             CustomMbeanRegistrar.this.applicationContext.close();\n         }\n     }\n }\n\n ```\n\n\n\n ### 2. 演示\n\n ![](https://img.springlearn.cn/blog/learn_1590924584000.png)\n\n\n ## 四、总结\n\n 通过前面的演示,大概我们对JMX在实际中的用处有一个大概的了解了吧。根据这个特性,我们就可以根据我们的需求来定制属于自己的能力。\n\n\n 最后求关注,求订阅,谢谢你的阅读!\n\n\n ![](https://img.springlearn.cn/blog/learn_1589360371000.png)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/java/JMX.md b/docs/learn/java/JMX.md
--- a/docs/learn/java/JMX.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/java/JMX.md	(date 1655373430490)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/java/CyclicBarrier.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 循环锁屏障 CyclicBarrier\ncategory: Java进阶\n---\n\n\n![](https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png)\n\n**作者**: 西魏陶渊明\n**博客**: [https://blog.springlearn.cn/](https://blog.springlearn.cn/)\n\n::: tip 西魏陶渊明\n莫笑少年江湖梦，谁不少年梦江湖\n:::\n\n举个例子,五个人开黑,少一个人就开不了。\n\n\n\n```java \npublic static void main(String[] args) throws Throwable {\n        CyclicBarrier cb = new CyclicBarrier(5, new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"人都到齐了,游戏开始进入峡谷\");\n            }\n        });\n        Runnable player = new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(Thread.currentThread().getName() + \"已经进来了\");\n                try {\n                    cb.await();\n                } catch (Throwable e) {\n                    e.printStackTrace();\n                }\n            }\n        };\n        new Thread(player, \"上路程咬金\").start();\n        new Thread(player, \"中路安琪拉\").start();\n        new Thread(player, \"下路小鲁班\").start();\n        new Thread(player, \"辅助李元芳\").start();\n        new Thread(player, \"打野孙悟空\").start();\n    }\n```\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/java/CyclicBarrier.md b/docs/learn/java/CyclicBarrier.md
--- a/docs/learn/java/CyclicBarrier.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/java/CyclicBarrier.md	(date 1655373430337)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/java/README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: Java编程\n---\n![](https://img.springlearn.cn/blog/learn_1648126927000.png)\n\n::: tip 西魏陶渊明\n莫笑少年江湖梦，谁不少年梦江湖\n:::\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/java/README.md b/docs/learn/java/README.md
--- a/docs/learn/java/README.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/java/README.md	(date 1655373430437)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/java/线程工厂.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 开个工厂造线程\ncategory: Java进阶\n---\n\n\n![](https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png)\n\n**作者**: 西魏陶渊明\n**博客**: [https://blog.springlearn.cn/](https://blog.springlearn.cn/)\n\n::: tip 西魏陶渊明\n莫笑少年江湖梦，谁不少年梦江湖\n:::\n\n# 线程工厂\n\n线程是Java里面很重要的一个概念，具体体现就是Thread这个类。我们平时最常用的创建线程就是在用Executors来创建线程池。在前面的章节\n也可以看到，创建线程池时候有一个入参就是线程工厂，ThreadFactory这个类。那么这个类具体有什么用呢? 其实就是为了统一在创建线程时设置一些参数，\n如是否守护线程。线程一些特性等，如优先级，名称。\n\n```java\n\t/**\n\t * @param threadFactory 线程工厂\n     */\n      public ThreadPoolExecutor(int corePoolSize,\n                                 int maximumPoolSize,\n                                 long keepAliveTime,\n                                 TimeUnit unit,\n                                 BlockingQueue<Runnable> workQueue,\n                                 ThreadFactory threadFactory) {\n           this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,\n                threadFactory, defaultHandler);\n       }\n```\n\n# 自定义\n\n所谓线程工厂其实就是创建线程使用的。正常情况下我们创建线程是下面这样的。\n\n```java\n  Thread ret = new Thread(runnable);\n```\n\n但是线程的构造其实并不是只有一个,它有一个线程组的概念,另外也可以给每个线程去设置一个名字。这样的目的是可以通过名字就能辨认是什么线程在执行。\n\n\n![](https://img.springlearn.cn/blog/learn_1599299678000.png)\n\n那么我们就看下这里面怎么实现的,其实非常简单。\n\n```java\npublic class NamedThreadFactory implements ThreadFactory {\n\n  protected static final AtomicInteger POOL_SEQ = new AtomicInteger(1);\n\n  protected final AtomicInteger mThreadNum = new AtomicInteger(1);\n\n  protected final String mPrefix;\n\n  protected final boolean mDaemon;\n\n  protected final ThreadGroup mGroup;\n\n  public NamedThreadFactory() {\n    this(\"pool-\" + POOL_SEQ.getAndIncrement(), false);\n  }\n\n  public NamedThreadFactory(String prefix) {\n    this(prefix, false);\n  }\n\n  public NamedThreadFactory(String prefix, boolean daemon) {\n    mPrefix = prefix + \"-thread-\";\n    mDaemon = daemon;\n    SecurityManager s = System.getSecurityManager();\n    mGroup = (s == null) ? Thread.currentThread().getThreadGroup() : s.getThreadGroup();\n  }\n\n  @Override\n  public Thread newThread(Runnable runnable) {\n    //就是给线程创建了一个名字和指定了一个线程组\n    String name = mPrefix + mThreadNum.getAndIncrement();\n    Thread ret = new Thread(mGroup, runnable, name, 0);\n    ret.setDaemon(mDaemon);\n    return ret;\n  }\n\n  public ThreadGroup getThreadGroup() {\n    return mGroup;\n  }\n}\n```\n\n如此而已,线程工厂就是这样。\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/java/线程工厂.md b/docs/learn/java/线程工厂.md
--- a/docs/learn/java/线程工厂.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/java/线程工厂.md	(date 1655373430322)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/java/synchronized.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: synchronized锁升级\ncategory: Java进阶\n---\n\n\n![](https://img.springlearn.cn/blog/learn_1596467333000.png)\n\n**作者**: 西魏陶渊明\n**博客**: [https://blog.springlearn.cn/](https://blog.springlearn.cn/)\n\n::: tip 西魏陶渊明\n莫笑少年江湖梦，谁不少年梦江湖\n:::\n\n## 一、重量级锁\n\n什么叫重量级锁？\n\n就是申请资源必须经过kernel(内核也叫操作系统)，调用。\n\n![](https://img.springlearn.cn/blog/learn_1596467437000.png)\n\n## 二、轻量级锁\n\n轻量级锁,是不经过操作系统。轻量级锁是相对于重量级锁来叫的,也可以叫乐观锁。\n\n在Java中乐观锁就是cas操作(compare and swap)根据英文翻译就是比较和交换。\n底层都是调用的Unsafe里面的方法,可以看到这些方法是native方法。\n\n![](https://img.springlearn.cn/blog/learn_1596467628000.png)\n\n通过看jvm源码,看到c++的代码有一个汇编语言支持cas\n\n![](https://img.springlearn.cn/blog/learn_1596467784000.png)\n\n但是，这条cmpchg1不具有原子性，点进lock_if_mp(%4)里\n\n 最终实现是lock cmpxchg 指令：表示在硬件在执行后面的指令会锁定一个北桥总线。（相当于锁定总线，但是比锁总线要轻量级）解决了下面的问题\n\n\n## 三、偏向锁\n\n顾名思义，它会偏向于第一个访问锁的线程，如果在运行过程中，同步锁只有一个线程访问，不存在多线程争用的情况，则线程是不需要触发同步的，这种情况下，就会给线程加一个偏向锁。\n说白了,没有竞争,还叫啥锁呀。就是加了一个标记。认为没有人给你竞争。\n\n\n## 四、锁升级步骤\n\n偏向锁 -> 轻量级锁 -> 重量级锁\n\n在jdk1.6之前synchronized直接就是一个重量级锁,一了百了。\njdk优化后出现了,锁升级的概念。\n\n\n那么其实synchronized的执行过程:\n\n1. 检测Mark Word里面是不是当前线程的ID，如果是，表示当前线程处于偏向锁\n2. 如果不是，则使用CAS将当前线程的ID替换Mard Word，如果成功则表示当前线程获得偏向锁，置偏向标志位1(前面一个线程刚好释放的情况下,这个才能成功,否则看3)\n3. 如果失败，则说明发生竞争，撤销偏向锁，进而升级为轻量级锁。\n4. 当前线程使用CAS将对象头的Mark Word替换为锁记录指针，如果成功，当前线程获得锁\n5. 如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。\n6. 如果自旋成功则依然处于轻量级状态。\n7. 如果自旋失败，则升级为重量级锁。\n\n翻译成白话问:\n\n\n1. 当没有人跟你竞争就是一个偏向锁,当cas失败了,说明有人跟你竞争了,这个时候锁就从偏向锁升级成了轻量级锁。\n\n2. 轻量级锁的状态下,仍然还有很多线程来竞争,那么此时cas就会比较严重从而浪费cpu执行。就升级为重量级锁。\n其次其他等待线程就进入了阻塞状态。\n\n\n最后求关注,求订阅,谢谢你的阅读!\n\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/java/synchronized.md b/docs/learn/java/synchronized.md
--- a/docs/learn/java/synchronized.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/java/synchronized.md	(date 1655373430356)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/mybatis/事务的实现方案.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/mybatis/事务的实现方案.md b/docs/learn/mybatis/事务的实现方案.md
new file mode 100644
--- /dev/null	(date 1655373430309)
+++ b/docs/learn/mybatis/事务的实现方案.md	(date 1655373430309)
@@ -0,0 +1,332 @@
+---
+breadcrumb: false
+navbar: true
+sidebar: true
+pageInfo: true
+contributor: true
+editLink: true
+updateTime: true
+prev: true
+next: true
+comment: true
+footer: true
+backtotop: true
+title: 第14篇:Mybatis事务处理
+category: SpringBoot
+---
+
+## 一、Jdk底层实现
+
+
+Java JDK中提供了标准接口`Connection`,不同的数据库驱动负责具体的实现。后面无论是`Spring`还是`Mybatis`对事务的处理，无论怎么的封装,最终究其到底都是由`Connection`来提供的能力。
+
+```java 
+public interface Connection  extends Wrapper, AutoCloseable {
+    Statement createStatement() throws SQLException;
+    void commit() throws SQLException;
+    void rollback() throws SQLException;
+}
+```
+
+例如 `com.mysql.cj.jdbc.ConnectionImpl`。具体负责跟mysql进行通信执行命令。
+
+
+## 二、Mybatis实现
+
+首先我们来看Mybatis是如何对`Connection`进行事务的封装。首先我们先来看一个图。
+
+![](https://img.springlearn.cn/learn_d3cd2ff5e89f6dbfffff18289043304e.png)
+
+
+## 2.1 调用流程
+
+根据上面的图我们看,都是一层一层的封装进行委派最终由`Connection`的具体数据库驱动来进行实现的。
+
+- SqlSession
+- Executor
+- Transaction
+
+```java 
+public interface SqlSession extends Closeable {
+  void commit();
+  void rollback();
+}
+public interface Executor {
+  void commit();
+  void rollback();
+}
+public interface Transaction {
+  void commit() throws SQLException;
+  void rollback() throws SQLException;
+}
+```
+
+
+## 2.2 实现原理
+
+Mybatis中我们的接口是使用代理进行跟数据库进行交互的。所以他的事务提交逻辑是嵌套在代理方法中的。
+通过前面的调用流程学习,[第04篇:Mybatis代理对象生成](/learn/mybatis/Mapper代理对象创建/)我们知道最终都是在`MapperMethod`对SqlSession的调用执行数据库操作的。
+而SqlSession是有两个包装类的。
+
+- SqlSession 通过底层的封装提供具体的调用指令
+- SqlSessionManager 对SqlSession进行代理,自动对事务进行处理
+- SqlSessionTemplate 事务的处理完全外包给Spring来处理
+
+下面我们分别来看下每个类具体都做了什么吧。
+
+### SqlSessionManager
+
+SqlSessionManager 是对SqlSession的一个包装,它会自己来管理SqlSession。他的具体实现是通过对SqlSession
+生成代理，代理拦截每个方法进行增强。
+
+```java 
+
+  private SqlSessionManager(SqlSessionFactory sqlSessionFactory) {
+    this.sqlSessionFactory = sqlSessionFactory;
+    this.sqlSessionProxy = (SqlSession) Proxy.newProxyInstance(
+        SqlSessionFactory.class.getClassLoader(),
+        new Class[]{SqlSession.class},
+        new SqlSessionInterceptor());
+  }
+```
+
+**SqlSessionInterceptor**
+
+
+```java 
+ private class SqlSessionInterceptor implements InvocationHandler {
+    public SqlSessionInterceptor() {
+        // Prevent Synthetic Access
+    }
+
+    @Override
+    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
+      final SqlSession sqlSession = SqlSessionManager.this.localSqlSession.get();
+      if (sqlSession != null) {
+        try {
+          return method.invoke(sqlSession, args);
+        } catch (Throwable t) {
+          throw ExceptionUtil.unwrapThrowable(t);
+        }
+      } else {
+        try (SqlSession autoSqlSession = openSession()) {
+          try {
+            final Object result = method.invoke(autoSqlSession, args);
+            autoSqlSession.commit();
+            return result;
+          } catch (Throwable t) {
+            autoSqlSession.rollback();
+            throw ExceptionUtil.unwrapThrowable(t);
+          }
+        }
+      }
+    }
+  }
+```
+
+
+1. 从ThreadLocal中获取SqlSession，如果有，说明是调用方要自己处理事务，那么就只进行执行数据库操作，不进行事务处理和连接的关闭。
+2. 如果没有,说明要自己来管理事务，那么就新生成SqlSession，帮我们调用SqlSession#commit来提交事务,失败进行回滚。
+
+根据其中原理我们知道有两种使用办法，
+
+- `首先第一种自己管理SqlSession的方式`
+
+```java 
+    InputStream inputStream = Resources.getResourceAsStream("mybatis-config.xml");
+    // 实例化sqlSessionManager
+    SqlSessionManager sqlSessionManager = SqlSessionManager.newInstance(inputStream);
+    // 第一步: 开启管理SqlSession，创建一个SqlSession并存入到ThreadLocal中
+    sqlSessionManager.startManagedSession();
+    // 使用
+    UserMapper mapper = sqlSessionManager.getMapper(UserMapper.class);
+    mapper.save(new User("孙悟空"));
+    // 第二步: 因为事务是我们自己开启的,所以要自己来操作提交事务，或者回滚
+    sqlSessionManager.commit();
+    // 第三步: 关闭连接
+    sqlSessionManager.close();
+```
+
+- `第二种,自动管理SqlSession`
+
+```java 
+    InputStream inputStream = Resources.getResourceAsStream("mybatis-config.xml");
+    // 实例化sqlSessionManager
+    SqlSessionManager sqlSessionManager = SqlSessionManager.newInstance(inputStream);
+    UserMapper mapper = sqlSessionManager.getMapper(UserMapper.class);
+    mapper.save(new User("孙悟空"));
+    // 只用关心关闭就好了，事务的信息,都帮我们完成了。
+    sqlSessionManager.close();
+```
+
+### SqlSessionTemplate
+
+线程安全、Spring 管理、与 Spring 事务管理一起使用的SqlSession ，以确保实际使用的 SqlSession 是与当前 Spring 事务关联的那个。此外，它还管理会话生命周期，包括根据 Spring 事务配置根据需要关闭、提交或回滚会话。
+模板需要一个 SqlSessionFactory 来创建 SqlSession，作为构造函数参数传递。也可以构造指示要使用的执行器类型，如果没有，将使用会话工厂中定义的默认执行器类型。
+此模板将 MyBatis PersistenceExceptions 转换为未经检查的 DataAccessExceptions，默认情况下使用MyBatisExceptionTranslator 。
+
+==SqlSessionTemplate== 和 ==SqlSessionManager==
+
+- `相同点:` 都是通过对SqlSession进行代理对方法进行增强的
+- `不同点:` 前者是将SqlSession外包给Spring进行管理的,后者是自己通过ThreadLocal进行管理的。
+
+下面我们来具体看下是如何拦截增强的。
+
+1. 第一个点获取SqlSession不同。
+   - 从Spring中的事务管理器中获取当前线程的事务信息
+2. 第二个点方法执行完成后都会自动关闭SqlSession或减少引用
+   - 为解决嵌套事务的情况,每次执行完后会减少一次引用。当引用都减少为0才会真正进行关闭。
+3. 第三个点是否提交事务，有判定规则。
+   - 只有Spring事务管理器中没有事务时候才会自己进行提交,否则都外包给Spring进行管理。
+
+下面我们具体来看下代码的实现吧。
+
+```java {4-5,19,30,8}
+ private class SqlSessionInterceptor implements InvocationHandler {
+    @Override
+    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
+      SqlSession sqlSession = getSqlSession(SqlSessionTemplate.this.sqlSessionFactory,
+          SqlSessionTemplate.this.executorType, SqlSessionTemplate.this.exceptionTranslator);
+      try {
+        Object result = method.invoke(sqlSession, args);
+        if (!isSqlSessionTransactional(sqlSession, SqlSessionTemplate.this.sqlSessionFactory)) {
+          // force commit even on non-dirty sessions because some databases require
+          // a commit/rollback before calling close()
+          sqlSession.commit(true);
+        }
+        return result;
+      } catch (Throwable t) {
+        Throwable unwrapped = unwrapThrowable(t);
+        if (SqlSessionTemplate.this.exceptionTranslator != null && unwrapped instanceof PersistenceException) {
+          // release the connection to avoid a deadlock if the translator is no loaded. See issue #22
+          closeSqlSession(sqlSession, SqlSessionTemplate.this.sqlSessionFactory);
+          sqlSession = null;
+          Throwable translated = SqlSessionTemplate.this.exceptionTranslator
+              .translateExceptionIfPossible((PersistenceException) unwrapped);
+          if (translated != null) {
+            unwrapped = translated;
+          }
+        }
+        throw unwrapped;
+      } finally {
+        if (sqlSession != null) {
+          closeSqlSession(sqlSession, SqlSessionTemplate.this.sqlSessionFactory);
+        }
+      }
+    }
+  }
+```
+
+**getSqlSession**
+
+- 从Spring提供的事务管理器(TransactionSynchronizationManager)中获取当前线程拥有的SqlSession
+- 如果没有就新建一个并注册到TransactionSynchronizationManager上。
+
+```java 
+ public static SqlSession getSqlSession(SqlSessionFactory sessionFactory, ExecutorType executorType,
+      PersistenceExceptionTranslator exceptionTranslator) {
+
+    notNull(sessionFactory, NO_SQL_SESSION_FACTORY_SPECIFIED);
+    notNull(executorType, NO_EXECUTOR_TYPE_SPECIFIED);
+    // 从Spring提供的事务管理器(TransactionSynchronizationManager)中获取当前线程拥有的SqlSession
+    // 逻辑很简单key=SqlSessionFactory value=SqlSessionHolder
+    SqlSessionHolder holder = (SqlSessionHolder) TransactionSynchronizationManager.getResource(sessionFactory);
+
+    SqlSession session = sessionHolder(executorType, holder);
+    if (session != null) {
+      return session;
+    }
+
+    LOGGER.debug(() -> "Creating a new SqlSession");
+    session = sessionFactory.openSession(executorType);
+    // 如果没有就新建一个并注册到TransactionSynchronizationManager上。
+    registerSessionHolder(sessionFactory, executorType, exceptionTranslator, session);
+
+    return session;
+  }
+```
+
+**registerSessionHolder**
+
+- 为了保险先判断下当前线程中是否已经存在同步器,如果存在还注册就提示:  "SqlSession [" + session + "] was not registered for synchronization because synchronization is not active");
+- 如果当前线程没有,判断事务管理器是否是SpringManagedTransactionFactory,如果是就注册一个。
+- SqlSessionHolder#requested() 注意这一行,创建后给引用次数加1.
+
+```java 
+private static void registerSessionHolder(SqlSessionFactory sessionFactory, ExecutorType executorType,
+      PersistenceExceptionTranslator exceptionTranslator, SqlSession session) {
+    SqlSessionHolder holder;
+    if (TransactionSynchronizationManager.isSynchronizationActive()) {
+      Environment environment = sessionFactory.getConfiguration().getEnvironment();
+
+      if (environment.getTransactionFactory() instanceof SpringManagedTransactionFactory) {
+        LOGGER.debug(() -> "Registering transaction synchronization for SqlSession [" + session + "]");
+
+        holder = new SqlSessionHolder(session, executorType, exceptionTranslator);
+        TransactionSynchronizationManager.bindResource(sessionFactory, holder);
+        TransactionSynchronizationManager
+            .registerSynchronization(new SqlSessionSynchronization(holder, sessionFactory));
+        holder.setSynchronizedWithTransaction(true);
+        holder.requested();
+      } else {
+        if (TransactionSynchronizationManager.getResource(environment.getDataSource()) == null) {
+          LOGGER.debug(() -> "SqlSession [" + session
+              + "] was not registered for synchronization because DataSource is not transactional");
+        } else {
+          throw new TransientDataAccessResourceException(
+              "SqlSessionFactory must be using a SpringManagedTransactionFactory in order to use Spring transaction synchronization");
+        }
+      }
+    } else {
+      LOGGER.debug(() -> "SqlSession [" + session
+          + "] was not registered for synchronization because synchronization is not active");
+    }
+```
+
+**closeSqlSession**
+
+- 如果是Spring的事务管理，就减少引用
+- 如果不是Spring的事务管理,就直接关闭
+
+```java 
+  public static void closeSqlSession(SqlSession session, SqlSessionFactory sessionFactory) {
+    notNull(session, NO_SQL_SESSION_SPECIFIED);
+    notNull(sessionFactory, NO_SQL_SESSION_FACTORY_SPECIFIED);
+
+    SqlSessionHolder holder = (SqlSessionHolder) TransactionSynchronizationManager.getResource(sessionFactory);
+    if ((holder != null) && (holder.getSqlSession() == session)) {
+      LOGGER.debug(() -> "Releasing transactional SqlSession [" + session + "]");
+      holder.released();
+    } else {
+      LOGGER.debug(() -> "Closing non transactional SqlSession [" + session + "]");
+      session.close();
+    }
+  }
+```
+
+
+**isSqlSessionTransactional**
+
+事务的判定逻辑:
+- 如果从事务管理器中获取,说明当前线程是有事务的
+- 当前线程中的事务SqlSession和这个方法中的SqlSession是同一个,说明是嵌套事务。
+
+如果是Spring来管理事务,这就不会自动来提交事务。外包给Spring的事务拦截器自己去处理。
+
+```java 
+  public static boolean isSqlSessionTransactional(SqlSession session, SqlSessionFactory sessionFactory) {
+    notNull(session, NO_SQL_SESSION_SPECIFIED);
+    notNull(sessionFactory, NO_SQL_SESSION_FACTORY_SPECIFIED);
+
+    SqlSessionHolder holder = (SqlSessionHolder) TransactionSynchronizationManager.getResource(sessionFactory);
+
+    return (holder != null) && (holder.getSqlSession() == session);
+  }
+```
+
+好了，到这里Mybatis中事务的处理逻辑我们就到了解了。
+
+SqlSession对底层进行封装提供具体的指令
+SqlSessionManager和SqlSessionTemplate都是对SqlSession进行增强来自动或者委派Spring进行事务的处理的。
+
+下面我们去看看Spring是如何来处理事务的吧。[Spring事务的处理方式](/learn/spring/Spring声明式事务的实现方案/)
Index: docs/learn/java/委派双亲之类加载器.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 委派双亲之类加载器\ncategory: Java进阶\n---\n\n\n\n![](https://img.springlearn.cn/blog/learn_1589811713000.png)\n\n**作者**: 西魏陶渊明\n**博客**: [https://blog.springlearn.cn/](https://blog.springlearn.cn/)\n\n::: tip 西魏陶渊明\n莫笑少年江湖梦，谁不少年梦江湖\n:::\n\n\n\n- BootStrap ClassLoader：称为启动类加载器，是Java类加载层次中最顶层的类加载器，负责加载JDK中的核心类库，如：rt.jar、resources.jar、charsets.jar等，可通过如下程序获得该类加载器从哪些地方加载了相关的jar或class文件：\n- Extension ClassLoader：称为扩展类加载器，负责加载Java的扩展类库，默认加载JAVA_HOME/jre/lib/ext/目下的所有jar。\n- App ClassLoader：称为系统类加载器，负责加载应用程序classpath目录下的所有jar和class文件。\n\n## 一、类加载器\n\n类的加载在JVM的外部实现。对于任意的一个类，都必须由加载它的类加载器和这个类本身共同确立其在Java虚拟机中的唯一性。JVM提供中类加载器。\n\n## 二、启动类加载器（Bootstrap ClassLoader）\n\n负责加载 JAVA_HOME\\lib 目录中的，或通过-Xbootclasspath 参数指定路径中的，且被 虚拟机认可（按文件名识别，如 rt.jar）的类。\n\n![](https://img.springlearn.cn/blog/learn_1589811324000.png)\n\n## 三、扩展类加载器(Extension ClassLoader)\n\n负责加载 JAVA_HOME\\lib\\ext 目录中的，或通过 java.ext.dirs 系统变量指定路径中的类 库。\n\n![](https://img.springlearn.cn/blog/learn_1589811366000.png)\n\n## 四、应用程序类加载器(Application ClassLoader)\n\n负责加载用户路径（classpath）上的类库。 JVM 通过双亲委派模型进行类的加载，当然我们也可以通过继承 java.lang.ClassLoader 实现自定义的类加载器。\n\n![](https://img.springlearn.cn/blog/learn_1589811400000.png)\n\n## 五、原理解释\n\nClassLoader使用的是双亲委托模型来搜索类的，每个ClassLoader实例都有一个父类加载器的引用（不是继承的关系，是一个包含的关系），虚拟机内置的类加载器（Bootstrap ClassLoader）本身没有父类加载器，但可以用作其它ClassLoader实例的的父类加载器。当一个ClassLoader实例需要加载某个类时，它会试图亲自搜索某个类之前，先把这个任务委托给它的父类加载器，这个过程是由上至下依次检查的，首先由最顶层的类加载器Bootstrap ClassLoader试图加载，如果没加载到，则把任务转交给Extension ClassLoader试图加载，如果也没加载到，则转交给App ClassLoader 进行加载，如果它也没有加载得到的话，则返回给委托的发起者，由它到指定的文件系统或网络等URL中加载该类。如果它们都没有加载到这个类时，则抛出ClassNotFoundException异常。否则将这个找到的类生成一个类的定义，并将它加载到内存当中，最后返回这个类在内存中的Class实例对象。\n\n## 六、为什么要使用双亲委托这种模型呢？\n\n因为这样可以避免重复加载，当父亲已经加载了该类的时候，就没有必要子ClassLoader再加载一次。考虑到安全因素，我们试想一下，如果不使用这种委托模式，那我们就可以随时使用自定义的String来动态替代java核心api中定义的类型，这样会存在非常大的安全隐患，而双亲委托的方式，就可以避免这种情况，因为String已经在启动时就被引导类加载器（Bootstrcp ClassLoader）加载，所以用户自定义的ClassLoader永远也无法加载一个自己写的String，除非你改变JDK中ClassLoader搜索类的默认算法。\n\n## 七、但是JVM在搜索类的时候，又是如何判定两个class是相同的呢？\n\nJVM在判定两个class是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。只有两者同时满足的情况下，JVM才认为这两个class是相同的。就算两个class是同一份class字节码，如果被两个不同的ClassLoader实例所加载，JVM也会认为它们是两个不同class。\n\n```\n /**\n         * rt目录:\n         * 加载rt.jar的类加载器\n         */\n        ClassLoader rtClassLoader = StringBuffer.class.getClassLoader();\n        System.out.println(rtClassLoader);\n\n        /**\n         * lib/ext扩展包\n         * sun.misc.Launcher$ExtClassLoader@67b6d4ae\n         */\n        ClassLoader extClassLoader = EventID.class.getClassLoader();\n        System.out.println(extClassLoader);\n\n        /**\n         * 当前应用加载器\n         * sun.misc.Launcher$AppClassLoader@33909752\n         */\n        ClassLoader classLoader = BaseSyntaxTest.class.getClassLoader();\n        System.out.println(classLoader);\n\n        /**\n         * sun.misc.Launcher$AppClassLoader@33909752\n         */\n        ClassLoader currentClassLoader = Thread.currentThread().getContextClassLoader();\n        System.out.println(currentClassLoader);\n```\n\n最后求关注,求订阅,谢谢你的阅读!\n\n\n![](https://img.springlearn.cn/blog/learn_1589360371000.png)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/java/委派双亲之类加载器.md b/docs/learn/java/委派双亲之类加载器.md
--- a/docs/learn/java/委派双亲之类加载器.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/java/委派双亲之类加载器.md	(date 1655373430341)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/java/Semaphore.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 信号量 Semaphore\ncategory: Java进阶\n---\n\n\n![](https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png)\n\n**作者**: 西魏陶渊明\n**博客**: [https://blog.springlearn.cn/](https://blog.springlearn.cn/)\n\n::: tip 西魏陶渊明\n莫笑少年江湖梦，谁不少年梦江湖\n:::\n\n## \uD83D\uDE80 知识快读\n\n`Semaphore` 翻译过来就是信号量, 其根本原理就是基于 `CAS` 共享锁的一种实现。举一个例子。\n假设停车场只有三个车位，一开始三个车位都是空的。这时如果同时来了五辆车，看门人允许其中三辆不受阻碍的进入，然后放下车拦，剩下的车则必须在入口等待，此后来的车也都不得不在入口处等待。这时，有一辆车离开停车场，看门人得知后，打开车拦，放入一辆，如果又离开两辆，则又可以放入两辆，如此往复。\n\n那么上面的这个例子可以这样理解，资源一共有3个, 即三个车位。如何来控制这5辆汽车，来合理的使用这3个资源呢?\n`Semaphore` 可以这样来定义。\n\n```java\n// 1. 定一个信号量,声明有3个资源。使用公平模式线程将会按到达的顺序（FIFO）执行(也就是等待时间最长的先执行),如果是非公平，则可以后请求的有可能排在队列的头部。\nSemaphore semp = new Semaphore(3);\n// 2. 获取1个许可 - 最大允许3个进入，一但超过就让其等待,除非已经释放\nsemp.acquire();  \n// 3. 释放1个许可 \nsemp.release(); \n// 4. 获取1许可,失败就返回,不等待\nsemp.tryAcquire();  \n// 5. 获取2许可,失败就返回,不等待\nsemp.tryAcquire(2);  \n// 6. 不允许被中断\nsemp.acquireUninterruptibly();\n```\n\n## 知识点1: Fair & NoFair\n\n`Semaphore` 的模式配置,只是构造来定义。\n\n- 默认构造不公平模式, 谁来申请资源,就先尝试获取资源。排队的要等到没有资源进来申请才能继续申请\n\n```java\n    public Semaphore(int permits) {\n        sync = new NonfairSync(permits);\n    }\n\n    public Semaphore(int permits, boolean fair) {\n        sync = fair ? new FairSync(permits) : new NonfairSync(permits);\n    }\n```\n\n![](https://img.springlearn.cn/blog/learn_1640531082000.png)\n\n## 知识点2: 申请资源\n\n- acquire() 获取1个资源,获取不到就等待,如果线程中断,会直接中断。\n- acquire(2) 获取2个资源,获取不到就等待,如果线程中断,会直接中断。\n- tryAcquire() 获取1个资源,获取不到就返回 `false`,如果线程中断,会直接中断。\n- acquireUninterruptibly() 获取1个资源,获取不到就等待,不会关心线程中断。\n\n## 知识点3: 释放资源\n\n- release() 释放一个资源\n- release(2) 释放两个资源\n\n## 知识点4: 其他API\n\n- availablePermits() 当前资源数量\n- drainPermits() 获取当前资源数量，并将剩余资源清零，直接赋值0\n- reducePermits(2) 将资源数量，扣减2个 \n- isFair() 是否公平\n- hasQueuedThreads() 是否还有线程等待\n- getQueueLength() 还有多少线程等待\n- getQueuedThreads() 获取所有的线程集合\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/java/Semaphore.md b/docs/learn/java/Semaphore.md
--- a/docs/learn/java/Semaphore.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/java/Semaphore.md	(date 1655373430176)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/java/线程安全.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 线程安全感\ncategory: Java进阶\n---\n\n\n\n![](https://img.springlearn.cn/blog/learn_1608963968000.png)\n\n\n**作者**: 西魏陶渊明\n**博客**: [https://blog.springlearn.cn/](https://blog.springlearn.cn/)\n\n::: tip 西魏陶渊明\n莫笑少年江湖梦，谁不少年梦江湖\n:::\n\n# 线程安全\n\n> 所谓发生线程安全其实是有一个前提条件,即当有多线程时候才会设计到线程安全,单线程是不存在线程安全的问题的。且只有在有状态对象中才会发生。\n\n## 1. 什么叫有状态对象?\n\n### 1.1 无状态对象\n\n```java\npublic class Home{\n    public String say(String message){\n        return message;\n    }\n}\n```\n\n### 1.2 有状态对象\n\n```java \npublic class Home{\n    //实例变量\n    public int age = 0;\n    public String say(String message){\n        return message + (age++);\n    }\n}\n```\n\n为什么说无状态对象不会发生线程安全,线程对公共变量（实例变量，类变量）进行操作才会发生线程安全问题，而方法中变量是保存在每个线程的私有栈中的,所以不存在线程安全问题\n\n## 2. 什么时候要保证线程安全？\n\n1. 当变量属于实例,该实例被多线程操作\n2. 当多线程会影响到执行结果时候,需要保证线程安全\n3. 当变量属于共享属性时候需要保证线程安全,而方法内变量属于每个\n   线程的空间,则不需要。\n   \n## 3. 如何保证线程安全？\n\n1. 原子性 lock操作,Syn...\n2. 可见性 volatile\n3. 顺序性 防止被重排序\n\n## 3.1 原子性\n\n原子是世界上的最小单位，具有不可分割性。比如 a=0；（a非long和double类型） 这个操作是不可分割的，那么我们说这个操作时原子操作。再比如：a++； 这个操作实际是a = a + 1；是可分割的，所以他不是一个原子操作。非原子操作都会存在线程安全问题，需要我们使用同步技术（sychronized）来让它变成一个原子操作。\n\n## 3.2 可见性\n\n可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个线程修改的结果。另一个线程马上就能看到。比如：用volatile修饰的变量，就会具有可见性。volatile修饰的变量不允许线程内部缓存和重排序，即直接修改内存。所以对其他线程是可见的。\n\n- volatile 本质是在告诉jvm当前变量在寄存器中的值是不确定的,需要从主存中读取,\n- synchronized 则是锁定当前变量,只有当前线程可以访问该变量,其他线程被阻塞住.\n\n## 3.3 那么什么时候用可见性？\n\n当多线程并不直接进行原子性操作的时候，可以用 volatile 修饰,这样可以保证每个线程读取的都是最新的\n\n## 3.4 什么时候用原子性?\n\n当涉及到多个线程对同一个数据进行操作的时候，为了保证在同一刻只有一个操作，就用 synchronized 修饰加锁\uD83D\uDD10\n\n## 4. Servlet线程安全问题思考\n\nServlet本身是无状态的，一个无状态的Servlet是绝对线程安全的，无状态对象设计也是解决线程安全问题的一种有效手段。\n\n所以，servlet是否线程安全是由它的实现来决定的，如果它内部的属性或方法会被多个线程改变，它就是线程不安全的，反之，就是线程安全的。\n\n在一个无状态的情况下，是不存在线程安全问题的，即使存在那也是跟它的实现类相关\n\n在Servlet中避免使用实例变量是保证Servlet线程安全的最佳选择。\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/java/线程安全.md b/docs/learn/java/线程安全.md
--- a/docs/learn/java/线程安全.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/java/线程安全.md	(date 1655373430570)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/java/四大引用.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: Java四大引用\ncategory: Java进阶\n---\n\n\n![](https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png)\n\n**作者**: 西魏陶渊明\n**博客**: [https://blog.springlearn.cn/](https://blog.springlearn.cn/)\n\n::: tip 西魏陶渊明\n莫笑少年江湖梦，谁不少年梦江湖\n:::\n\n# 一、概念\n## 1. 强引用\n\nnew 对象并指向引用变量的都是强引用,开发中大部分都是强引用。对于强引用,JVM宁愿报错`OutOfMemoryError`错误,是程序异常终止,\n也不会回收强引用来解决内存, 对这类情况,可以通过赋值强引用对象=null,从而被JVM回收。\n但是一般我们在方法中定义的强引用,会存在方法栈中,当方法运行完,退出,此时方法中的强引用也会因为引用数为0,从而被回收。\n\n## 2. 软引用\n\n在内存充足情况下,GC不会回收软引用对象,如果内存空间不足了,才会回收这些对象的内存。也正因为这个特性,所以软引用经常用作缓存对象使用。\n\n\n## 3. 弱引用\n\n任意GC都会清理掉软引用对象,弱引用是最容易记的,任何的GC动作都会将弱引用对象给回收掉。\n\n## 4. 虚引用\n\n和其他三个不一样,这个不对生命周期,有影响,而是当要回收时候,加入到Queue队列中\n\n# 二、在JDK中的体现\n\n| 类               | 引用说明                | 用途                   | 生存时间                | 被垃圾回收时间   |\n| ---------------- | ----------------------- | ---------------------- | ----------------------- | ---------------- |\n| Object           | 默认new出来的都是强引用 | 对象正常状态           | JVM停止或者无引用被回收 | 无任务对象使用   |\n| SoftReference    | 软引用                  | 常用作缓存             | 当内存不足时候终止      | 内存不足时候回收 |\n| WeakReference    | 弱引用                  | 常用作缓存             | 垃圾回收后终止          | 任何垃圾回收时   |\n| PhantomReference | 虚引用                  | 用于跟踪对象是否被回收 | 垃圾回收后终止          | 任何垃圾回收时   |\n\n\n\n最后求关注,求订阅,谢谢你的阅读!\n\n\n![](https://img.springlearn.cn/blog/learn_1589360371000.png)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/java/四大引用.md b/docs/learn/java/四大引用.md
--- a/docs/learn/java/四大引用.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/java/四大引用.md	(date 1655373430327)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/java/SPI.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: SPI服务发现机制\ncategory: Java进阶\n---\n\n![](https://img.springlearn.cn/blog/learn_1590160192000.png)\n\n**作者**: 西魏陶渊明\n**博客**: [https://blog.springlearn.cn/](https://blog.springlearn.cn/)\n\n::: tip 西魏陶渊明\n莫笑少年江湖梦，谁不少年梦江湖\n:::\n\n## 一、什么是SPI\n\nSPI ，全称为 Service Provider Interface，是一种服务发现机制。JDK中的SPI是通过在ClassPath路径下的META-INF/services文件夹查找扩展文件,自动加载文件里所定义的类。\n\n在小编的理解来,觉得它更是一种思想。即找到服务的接口, 美其名曰: 服务发现机制思想。很多开源框架都有借用这种思想，比如dubbo、jdbc。\n\n\n\n## 二、SPI在JDK中如何使用\n\nSPI在JDK中,我们可以使用 `ServiceLoader` 类进行使用。\n![](https://img.springlearn.cn/blog/learn_1590225886000.png)\n\n\n\n### 1. 前提准备\n\n```\npublic interface SpiService {\n    String say();\n}\n```\n\n两个实现类\n\n```\npublic class ASpiServiceImpl implements SpiService {\n    static {\n        System.out.println(\"static init a\");\n    }\n\n    {\n        System.out.println(\"init a\");\n    }\n\n    @Override\n    public String say() {\n        return \"A\";\n    }\n}\n```\n\n```\npublic class BSpiServiceImpl implements SpiService {\n    static {\n        System.out.println(\"static init b\");\n    }\n\n    {\n        System.out.println(\"init b\");\n    }\n    @Override\n    public String say() {\n        return \"B\";\n    }\n}\n```\n\n### 2. 进行配置\n\n在resources中创建META-INF/services目录\n\n![](https://img.springlearn.cn/blog/learn_1590225980000.png)\n\n```\n│  └── resources\n│      └── META-INF\n│          └── services\n│              └── com.github.easylog.spi.SpiService\n```\n\ncom.github.easylog.spi.SpiService文件内容\n\n```\ncom.github.easylog.spi.impl.ASpiServiceImpl\ncom.github.easylog.spi.impl.BSpiServiceImpl\n```\n\n### 3. 使用\n\n通过ServiceLoader类我们可以加载到所有配置的实现类,并对实现类进行处理。需要注意一点的是，看4使用注意。\n\n![](https://img.springlearn.cn/blog/learn_1590226089000.png)\n\n```\npublic class SpiTester {\n    public static void main(String[] args) {\n        ServiceLoader<SpiService> spiServices = ServiceLoader.load(SpiService.class);\n        Iterator<SpiService> iterator = spiServices.iterator();\n        while (iterator.hasNext()) {\n            SpiService next = iterator.next();\n            System.out.println(next.say());\n        }\n    }\n}\n```\n\n### 4. 使用注意\n\n可以看下小编前面声明的两个实现类,都定义了静态代码块和非静态代码块。正常情况当这个字节码被加载,就会执行静态代码块里面的内容，但是实际运行时候却没有执行, 其实是有原因的。\n\n![](https://img.springlearn.cn/blog/learn_1590223793000.png)\n\n可以看到第二个参数是false。即加载时候不进行初始化。\n\n\n\n## 三、Dubbo中服务发现思想\n\n服务发现这种思想的特点是: 代码不是硬编码的方式,而是可配置的。只要将要支持的实现类放到指定配置文件下面,就会自动被加载起来了。然后代码中只关心使用即可。我们可以利用这种思想来实现, 框架的扩展,比如前面说了。Dubbo会利用SPI的思想进行，加载用户自定义的过滤器。\n\n这种思想特别适合做服务扩展。现在大多数开源框架中都会使用到这种思想。\n\n### 1. 定义过滤器\n\n![](https://img.springlearn.cn/blog/learn_1590226192000.png)\n\n```\n@Activate(group = { Constants.PROVIDER })\npublic class ProviderHelloFilter implements Filter {\n  \n    @Override\n    public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {\n        System.out.pringln(\"hello ok!\");\n        return invoker.invoke(invocation);\n    }\n\n}\n```\n\n### 2. 添加配置文件\n\n`META-INF/dubbo/Interal/com.alibaba.dubbo.rpc.Filter`\n\n默认支持的过滤器\n\n![](https://img.springlearn.cn/blog/learn_1590224576000.png)\n\n利用SPI原理,我们自定义一个过滤器\n\n![](https://img.springlearn.cn/blog/learn_1590224824000.png)\n\n### 3. 使用\n\n其实API跟JDK中使用ServiceLoader的方式,非常类同。唯一不同的是Dubbo中是使用ExtensionLoader。因为dubbo中做了一些特殊的增强处理。比如在配置文件中支持自定义一个别名key。如上图hello就是key。通过getExtension(\"hello\")就能获取指定的实现类。\n\n![](https://img.springlearn.cn/blog/learn_1590226285000.png)\n\n```\npublic class SpiTester {\n    public static void main(String[] args) throws Exception{\n        ExtensionLoader<Filter> filterExtensionLoader = ExtensionLoader.getExtensionLoader(Filter.class);\n        Set<String> supportedExtensions = filterExtensionLoader.getSupportedExtensions();\n        System.out.println(supportedExtensions);\n        //[accesslog, activelimit, cache...]\n        Filter hello = filterExtensionLoader.getExtension(\"hello\");\n        //com.github.easylog.spi.ProviderHelloFilter@299a06ac\n        System.out.println(hello);\n    }\n    \n}\n```\n\n\n\n**那么这种思想你学会了吗? **\n\n![](https://i04piccdn.sogoucdn.com/96a6f7554ee28b9c)\n\n\n\n最后求关注,求订阅,谢谢你的阅读!\n\n\n![](https://img.springlearn.cn/blog/learn_1589360371000.png)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/java/SPI.md b/docs/learn/java/SPI.md
--- a/docs/learn/java/SPI.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/java/SPI.md	(date 1655373430230)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/java/拒绝策略.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 成熟的线程要懂得拒绝\ncategory: Java进阶\n---\n\n\n![](https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png)\n\n**作者**: 西魏陶渊明\n**博客**: [https://blog.springlearn.cn/](https://blog.springlearn.cn/)\n\n::: tip 西魏陶渊明\n莫笑少年江湖梦，谁不少年梦江湖\n:::\n\n\n# 拒绝策略\n\n**拒绝策略就是任务实在是已经执行不了，那么就需要你告诉程序，怎么样去拒绝在执行其他任务**\n\n在实际开发场景中，基本使用JDK自带的策略就可以完成日常开发，但是作为程序员必须要知道。下面说一下JDK自带有哪些线程策略\n\n```java\npublic interface RejectedExecutionHandler {\n    void rejectedExecution(Runnable r, ThreadPoolExecutor executor);\n}\n```\n\n\n\n# 四种拒绝策略\n\n> ThreadPoolExecutor类里面是内置了4中拒绝策略，我们一个一个来分析\n\n## 1. CallerRunsPolicy\n\n直接执行该任务，如果线程池已经关闭，就不运行\n\n```java\n    public static class CallerRunsPolicy implements RejectedExecutionHandler {\n        public CallerRunsPolicy() { }\n        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n            if (!e.isShutdown()) {\n                r.run();\n            }\n        }\n    }\n```\n\n## 2. AbortPolicy 【默认策略】\n\n直接报异常，简单粗暴\n\n```java\npublic static class AbortPolicy implements RejectedExecutionHandler {\n        public AbortPolicy() { }\n        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n            throw new RejectedExecutionException(\"Task \" + r.toString() +\n                                                 \" rejected from \" +\n                                                 e.toString());\n        }\n    }\n```\n\n## 3. DiscardPolicy\n\n直接丢弃，不记录任何信息\n\n```java\n public static class DiscardPolicy implements RejectedExecutionHandler {\n        public DiscardPolicy() { }\n        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n        }\n    }\n```\n\n## 4. DiscardOldestPolicy\n\n丢弃一个老任务，然后执行当前任务\n\n```java\npublic static class DiscardOldestPolicy implements RejectedExecutionHandler {\n        public DiscardOldestPolicy() { }\n        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n            if (!e.isShutdown()) {\n\t\t\t\t// Retrieves and removes the head of this queue 移出最头任务，也就是老任务\n                e.getQueue().poll();\n                e.execute(r);\n            }\n        }\n```\n\n# 分析\n\n拒绝策略其实很简单，知己知彼百战百胜，在多线程多任务编程场景下，我们可以根据业务特性定义拒绝策略。\n比如，在任务满的情况将，任务放到数据库中，或者打印到特殊的日志中，用来恢复任务。\n\n最后求关注,求订阅,谢谢你的阅读!\n\n\n![](https://img.springlearn.cn/blog/learn_1589360371000.png)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/java/拒绝策略.md b/docs/learn/java/拒绝策略.md
--- a/docs/learn/java/拒绝策略.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/java/拒绝策略.md	(date 1655373430603)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/spring/FactoryBean接口实例化.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/spring/FactoryBean接口实例化.md b/docs/learn/spring/FactoryBean接口实例化.md
new file mode 100644
--- /dev/null	(date 1655373430406)
+++ b/docs/learn/spring/FactoryBean接口实例化.md	(date 1655373430406)
@@ -0,0 +1,183 @@
+---
+breadcrumb: false
+navbar: true
+sidebar: true
+pageInfo: true
+contributor: true
+editLink: true
+updateTime: true
+prev: true
+next: true
+comment: true
+footer: true
+backtotop: true
+title: FactoryBean接口实例化
+category: Spring
+image:
+---
+
+![文章头](https://img.springlearn.cn/eaf9d1d2bf5c8df466b3376235db919a.jpg)
+
+
+> Java编程规范中声明,Java接口类是不能直接实例化的,但是我们在平时的开发中经常会遇到只声明接口就可以直接使用的。
+
+eg:
+
+1. Mybatis中只用使用`@MapperScan`声明要扫描的Mapper接口类就可以直接从Spring中获取使用,进行操作数据库
+2. Dubbo中只要用Dubbo提供的`@Service`注解,同样可以直接从Spring中获取使用进行远程调用。
+
+
+**那么以上这些功能在Spring中是如何实现的呢?**
+
+由此就引出本篇主要介绍的接口`FactoryBean`
+```java
+
+public interface FactoryBean<T> {
+    @Nullable
+    T getObject() throws Exception;
+
+    @Nullable
+    Class<?> getObjectType();
+
+    default boolean isSingleton() {
+        return true;
+    }
+}
+```
+在Spring中当发现一个Bean的类型是`FactoryBean`,此时实例化时候就会执行,该对象的`getObject()`方法从而来进行实例化。那么如何获取真实`FactoryBean`呢?只需要在实例化的Bean的name前面加`&`符号才是获取真正`FactoryBean`的实例对象。
+
+
+Java编程规范中声明,Java接口类是不能直接实例化的,Spring实现接口的实例化操作,本质上只是调用`FactoryBean`的`getObject()`方法,而真正的实例化操作,还是有开发者来实现的。以我们常见的使用框架为例。`MyBatis` and `Dubbo`
+
+- MyBatis中实现FactoryBean的类`MapperFactoryBean`
+- Dubbo中实现FactoryBean的类`ReferenceBean`
+
+在此我们以MyBatis为例,讲述MyBatis是如何实现FactoryBean来实现接口实例化操作的。
+对Spring的源码有研究的同学知道,在Spring中Bean的读取会生成BeanDefinition对象,实例化实际就是找到Bean对象的BeanDefinition对象,然后根据
+BeanDefinition信息来实例的。那么在这里我们首先要看下MyBatis是如何为接口生成BeanDefinition对象的吧。
+
+我们一起看下`ImportBeanDefinitionRegistrar`接口。ImportBeanDefinitionRegistrar接口就是允许开发者来根据开发者的规则来生成BeanDefinition的并注册到`BeanDefinitionRegistry`中。因为Spring默认是根据自己的规则去生成BeanDefinition的，但是这里也提供了一个切口,供开发者使用。
+```java
+
+public interface ImportBeanDefinitionRegistrar {
+    public void registerBeanDefinitions(
+            AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry);
+}
+```
+
+MyBatis中`MapperScannerRegistrar`实现了`ImportBeanDefinitionRegistrar`。扫描Mapper接口所在的包,为每个接口生成特定的BeanDefinition
+#### MapperScannerRegistrar
+```java
+ public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
+    //扫描Mapper接口所在的包
+    AnnotationAttributes annoAttrs = AnnotationAttributes.fromMap(importingClassMetadata.getAnnotationAttributes(MapperScan.class.getName()));
+    ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);
+    ....
+    //为每个接口生成特定的BeanDefinition 
+    scanner.doScan(StringUtils.toStringArray(basePackages));
+  }
+```
+
+### ClassPathMapperScanner
+
+在doScan方法为每个标记的Mapper接口生成一个BeanName。而实例化工厂都指定为`MapperFactoryBean`。只用调用其`getObject()`方法即可完成接口的实例化。
+```java
+public Set<BeanDefinitionHolder> doScan(String... basePackages) {
+    Set<BeanDefinitionHolder> beanDefinitions = super.doScan(basePackages);
+
+    if (beanDefinitions.isEmpty()) {
+      logger.warn("No MyBatis mapper was found in '" + Arrays.toString(basePackages) + "' package. Please check your configuration.");
+    } else {
+      //开始配置自己的规则
+      processBeanDefinitions(beanDefinitions);
+    }
+
+    return beanDefinitions;
+  }
+  private void processBeanDefinitions(Set<BeanDefinitionHolder> beanDefinitions) {
+    GenericBeanDefinition definition;
+    for (BeanDefinitionHolder holder : beanDefinitions) {
+      definition = (GenericBeanDefinition) holder.getBeanDefinition();
+      //设置每个Bean的工厂类，MapperFactoryBean
+      definition.setBeanClass(this.mapperFactoryBean.getClass());
+      ...
+    }
+  }
+}
+```
+
+我们举一个例子
+```
+@Mapper
+public interface TUserMapper {
+
+    int insert(TUser record);
+
+    List<TUser> selectAll();
+
+    TUser selectOne(@Param("id") Integer id);
+
+    TUser selectByName(@Param("name") String name);
+}
+```
+这里BeanDefinition的名字就是`TUserMapper`，而工厂方法就是`MapperFactoryBean`。如下伪代码,getBean("TUserMapper"),就是调用`MapperFactoryBean.getObject()`,而`getBean("&TUserMapper")`才是获取`MapperFactoryBean`的实例。
+
+
+```
+    @Test
+    public void factoryBeanTest(){
+        System.out.println(applicationContextTools.getApp().getBean("&TUserMapper"));
+        //org.mybatis.spring.mapper.MapperFactoryBean@3ab6678b
+    }
+```
+
+
+### 我们如何定制自己的解析的注解呢?
+
+编写一个类似于`MapperScan`的注解类,`MyMapperScan`。
+
+**注意:** 自定义的注解只能声明在配置类上才有效，配置类就是一定要被`@Configuration`修饰。
+
+```java
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.TYPE)
+@Documented
+@Import(MyMapperScannerRegistrar.class)
+public @interface MyMapperScan {
+    String value();
+}
+
+public class MyMapperScannerRegistrar implements ImportBeanDefinitionRegistrar {
+    @Override
+    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
+        AnnotationAttributes annoAttrs = AnnotationAttributes.fromMap(importingClassMetadata.getAnnotationAttributes(MyMapperScan.class.getName()));
+        String value = annoAttrs.getString("value");
+        System.out.println(value);
+        System.out.println("配置类:"+importingClassMetadata.getClassName());
+    }
+}
+```
+
+#### 验证
+
+```
+@Configuration
+@MyMapperScan(value = "ConfigBean")
+public class ConfigBean {
+}
+
+@SpringBootApplication //被@Configuration修饰就等同于配置类
+@MyMapperScan(value = "test")
+@MapperScan(value = "orm.example.dal.mapper")
+public class LxchinesszzMybatisStudyApplication {
+    public static void main(String[] args) {
+        new SpringApplicationBuilder().web(WebApplicationType.NONE).run(args);
+    }
+
+}
+
+ConfigBean
+配置类:orm.example.ConfigBean
+test
+配置类:orm.example.LxchinesszzMybatisStudyApplication
+```
Index: docs/learn/java/分布式锁.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 分布式锁\ncategory: Java进阶\n---\n\n\n![](https://img.springlearn.cn/blog/learn_1596467333000.png)\n\n**作者**: 西魏陶渊明\n**博客**: [https://blog.springlearn.cn/](https://blog.springlearn.cn/)\n\n::: tip 西魏陶渊明\n在单机环境下多线程操作共享数据时候回用到锁的概念,因为是单机可以直接使用jdk提供的锁机制就可以满足。\n但是在微服务场景下,因为是多服务共享数据,此时jdk提供的锁就不能再使用了。于是乎就有了分布式锁。\n本文介绍常见的几种可以使用的生产的分布式锁\n:::\n\n\n**本文面向有开发经验的同学,所以场景就不赘述,直接上干货**\n\n## 一、分布式锁具有的品格\n\n- 基本的加锁和释放锁\n- 具备锁失效机制,防止死锁\n- 非阻塞机制\n- 高性能和高可用\n\n## 二、思考一下如何自己实现?\n\n\n### 1. db\n\n根据上面提出的要求,发现只要能满足多服务之前通信就能实现。\n比如我们可以用mysql就能实现,比如A服务对一个表加锁和释放锁。B服务就会发现表加了锁。此时B就阻塞了。\n\n当然这明显不满足,非阻塞的机制。另外如果要用一个数据库来做锁的场景也太浪费性能了。\n\n### 2. redis\n\n利用redis命令来实现,如果返回ok说明获取锁。返回nil说明没有获取到锁。\n\n不阻塞,防止死锁,高性能,都满足\n\n```\nset key value [EX seconds] [PX milliseconds] [NX|XX]\nEX seconds：设置失效时长，单位秒\nPX milliseconds：设置失效时长，单位毫秒\nNX：key不存在时设置value，成功返回OK，失败返回(nil)\nXX：key存在时设置value，成功返回OK，失败返回(nil)\n//对资源加一个锁 key为资源名 value可以为任意 ex为秒 1为过期时间 nx为\n127.0.0.1:6379> set ziyuanming 1 ex 1 nx\nOK\n127.0.0.1:6379> set ziyuanming 1 ex 1 nx\n(nil)\n```\n\n### 3. zookeeper\n\n#### 获取锁\n1. 在Zookeeper当中创建一个持久节点ParentLock。当第一个客户端想要获得锁时，需要在ParentLock这个节点下面创建一个临时顺序节点 Lock1。\n2. Client1查找ParentLock下面所有的临时顺序节点并排序，判断自己所创建的节点Lock1是不是顺序最靠前的一个。如果是第一个节点，则成功获得锁。\n3. 如果再有一个客户端 Client2 前来获取锁，则在ParentLock下载再创建一个临时顺序节点Lock2。\n   此时Client2发现自己并不是最靠前的就像Lock1注册了一个Watcher,用于监听Lock1节点释放。此时Client2就进入等待状态\n4. Client3,4以此类推\n\n#### 释放锁\n\n1. Client1释放了锁,此时Zookeeper就讲Lock1移出,并触发了Lock1的Watcher。\n2. Client2一直在监听Lock1的状态,当Lock1节点被删除,Client2里面收到通知获得了锁。\n\n\n\n## 三、现成的解决方案\n\n### 1. db的方式就不考虑了\n\n实现简单,但是不划算,性能也不是最好的。\n\n### 2. redis\n\n```\n<dependency>\n    <groupId>org.redisson</groupId>\n    <artifactId>redisson</artifactId>\n    <version>3.11.0</version>\n</dependency>\n```\n\n```\n\npublic class RedLockTester {\n    public static void main(String[] args) {\n        //连接redis\n        Config config = new Config();\n        config.useSingleServer().setAddress(\"redis://127.0.0.1:6379\");\n        RedissonClient redisson = Redisson.create(config);\n        log.info(\"连接Redis\");\n\n        //1.定义锁\n        RLock lock = redisson.getLock(\"myTest001\");\n\n        try {\n            //尝试加锁的超时时间\n            Long timeout = 300L;\n            //锁过期时间\n            Long expire = 30L;\n            //2.获取锁\n            if (lock.tryLock(timeout, expire, TimeUnit.MILLISECONDS)) {\n                //2.1.获取锁成功的处理\n                log.info(\"加锁成功\");\n                //...do something\n                log.info(\"使用完毕\");\n            } else {\n                //2.2.获取锁失败的处理\n                log.info(\"加锁失败\");\n                log.info(\"其他处理\");\n            }\n        } catch (InterruptedException e) {\n            log.error(\"尝试获取分布式锁失败\", e);\n        } finally {\n            //3.释放锁\n            try {\n                lock.unlock();\n                log.info(\"锁释放成功\");\n            } catch (Exception e) {\n                //do nothing...\n            }\n        }\n\n        //关闭连接\n        redisson.shutdown();\n        log.info(\"关闭redis连接\");\n    }\n}\n```\n通过官方文档能找到实现第三方工具\n\n![](https://img.springlearn.cn/blog/learn_1596471713000.png)\n\n\n[参考文章](https://www.cnblogs.com/rgcLOVEyaya/p/RGC_LOVE_YAYA_1003days.html)\n\n\n### 3. zookeeper\n\n[Curator](https://curator.apache.org/)\n\n\n```\n<!-- 对zookeeper的底层api的一些封装 -->\n        <dependency>\n            <groupId>org.apache.curator</groupId>\n            <artifactId>curator-framework</artifactId>\n            <version>2.12.0</version>\n        </dependency>\n        <!-- 封装了一些高级特性，如：Cache事件监听、选举、分布式锁、分布式Barrier -->\n        <dependency>\n            <groupId>org.apache.curator</groupId>\n            <artifactId>curator-recipes</artifactId>\n            <version>2.12.0</version>\n        </dependency>\n```\n\n几乎对所有的JDK锁都实现了,基于Zookeeper的分布式锁。具体使用方法可以自行百度。\n\n- InterProcessMutex：分布式可重入排它锁\n- InterProcessSemaphoreMutex：分布式排它锁\n- InterProcessReadWriteLock：分布式读写锁\n- InterProcessMultiLock：将多个锁作为单个实体管理的容器\n- InterProcessSemaphoreV2 信号量\n- DistributedBarrier 分布式栅栏\n- DistributedDoubleBarrier 分布式栅栏\n\n\n最后求关注,求订阅,谢谢你的阅读!\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/java/分布式锁.md b/docs/learn/java/分布式锁.md
--- a/docs/learn/java/分布式锁.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/java/分布式锁.md	(date 1655373430348)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/java/原子操作.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 线程安全之原子操作\ncategory: Java进阶\n---\n\n![](https://img.springlearn.cn/blog/learn_1589361031000.png)\n\n\n**作者**: 西魏陶渊明\n**博客**: [https://blog.springlearn.cn/](https://blog.springlearn.cn/)\n\n::: tip 西魏陶渊明\n莫笑少年江湖梦，谁不少年梦江湖\n:::\n\n\n\n**原子特性: 原子是最小的粒子,不可再分**\n\n这并不是一个化学课,而是巧妙的借用了化学上的一个概念,即原子是最小的粒子,不可再分;原子操作也是不能再分的操作;\n为了能把这个讲明白,下文基本都是大白话,其实Java本来并不是很难,而是总有一些人喜欢把简单的概念给复杂化。小编不喜欢\n那种说辞,所以尽量简单易懂。如有问题,欢迎提出问题。共同交流进步,最后谢谢你的阅读。\n\n---\n\n# 举例说明原子操作重要性\n\n在很多场景中我们需要我们的操作是原子特性的,如果我们写的程序都是单线程的,其实我们没必要考虑原子操作。但是假如\n我们写多线程操作,或者是在Web服务中来更新对象属性,那么就必须要来考虑原子操作问题了。\n\n举一个\uD83C\uDF30例子A:\n\n```\nint a = 1;\n```\n\n可以看到程序对变量 `a` 操作,其实是有多个步骤进行的。在单线程环境下基本不会发生任何问题\n![](https://img.springlearn.cn/blog/learn_1589372995000.png)\n\n\n举一个\uD83C\uDF30例子B(单线程操作):\n\n\n```\npublic class Tester {\n\n    private static Integer a = 1;\n\n    private static AtomicInteger aa = new AtomicInteger(1);\n\n    private static void restore() {\n        a = 1;\n        aa = new AtomicInteger(1);\n    }\n\n    public static void main(String[] args) {\n        for (int i = 0; i < 10; i++) {\n            test(\"第\" + i + \"次\");\n            restore();\n        }\n    }\n\n    private static void test(String str) {\n        for (int i = 1; i <= 1000; i++) {\n            new Thread(() -> a = a + 1).start();\n            new Thread(() -> aa.addAndGet(1)).start();\n        }\n        System.out.print(str + \"常规操作a=\" + a);\n        System.out.println(\" <===> \"+str+\"原子操作操作aa=\" + aa);\n    }\n}\n```\n\n规律:\n\n```\n        /**\n         * i              i+1\n         * 1: a = 1 + 1 = 2\n         * 2: a = 2 + 1 = 3\n         * 3: a = 3 + 1 = 4\n         * 4: a = 4 + 1 = 5\n         * 5: a = 5 + 1 = 6\n         * 6: a = 6 + 1 = 7\n         * 7: a = 7 + 1 = 8\n         * 8: a = 8 + 1 = 9\n         * 9: a = 9 + 1 = 10\n         * 10:a = 10 + 1 = 11\n         */\n```\n\n如上面代码变量a是基本类型,变量aa是原子类型,正常情况对a或者aa进行1000次操作结果都应该是\n`1001`。正常情况我们可以理解是单线程操作。结果也是没有问题的。\n\n![](https://img.springlearn.cn/blog/learn_1589380382000.png)\n\n举一个\uD83C\uDF30例子C(多线程操作):\n\n```\npublic class Tester {\n\n    private static Integer a = 1;\n\n    private static AtomicInteger aa = new AtomicInteger(1);\n\n    private static void restore() {\n        a = 1;\n        aa = new AtomicInteger(1);\n    }\n\n    public static void main(String[] args) throws Exception {\n        for (int i = 0; i < 10; i++) {\n            test(\"第\" + i + \"次\");\n            restore();\n        }\n    }\n\n    private static void test(String str) throws Exception {\n        for (int i = 1; i <= 100; i++) {\n            new Thread(() -> a = a + 1).start();\n            new Thread(() -> a = a + 1).start();\n\n            new Thread(() -> aa.addAndGet(1)).start();\n            new Thread(() -> aa.addAndGet(1)).start();\n            Thread.sleep(1);\n        }\n        System.out.print(str + \"常规操作a=\" + a);\n        System.out.println(\" <===> \" + str + \"原子操作操作aa=\" + aa);\n    }\n    \n}\n\n```\n\n规律:\n\n```\n    /**\n     * i          2 * i + 1\n     * 1: a = 1 + 1 + 1 = 3\n     * 2: a = 3 + 1 + 1 = 5\n     * 3: a = 5 + 1 + 1 = 7\n     * 4: a = 7 + 1 + 1 = 9\n     * 5:                 11\n     * 6:                 13\n     * 7:                 15\n     * 8:                 17\n     * 9:                 19\n     * 10:                21\n     */\n```\n\n多线程环境下操作会不会有问题呢? 出现了问题。我们看到使用常规操作的a变量出现了数据不一致情况。\n\n\n![](https://img.springlearn.cn/blog/learn_1589375176000.png)\n\n实际上当循环的次数越多,出现错误的几率就越大,如下我们循环了1000次。\n\n\n![](https://img.springlearn.cn/blog/learn_1589375386000.png)\n\n# 问题分析\n\n我们思考为什么基本类型进行多线程操作时候会出现这种情况呢? 其实问题答案最开始已经说了。 我们通过这张图\n就可以找到原因。\n\n![](https://img.springlearn.cn/blog/learn_1589372995000.png)\n\n对变量的每次操作其实都有3个步骤\n1. 读取变量值\n2. 变量值操作\n3. 变量重新赋值。\n\n我们模拟一下错误的原因。\n\n当A线程读取a=1,并对1+1。但是还未对变量重新赋值a=2的时候，\nB线程也读取了A还未赋值的变量,此时变量还是1,那么B线程因为读取了还未更新的数据,所以也做1+1的操作。然后B对a\n重新赋值了此时a=2,是B赋值的。这个时候A因为已经执行完了前两个步骤,最后也重新赋值了a=2。\n\n这样数据就更新丢了。这就是因为数据更新不是原子性从而导致的问题。\n\n因为数据更新丢了,所以出现了。\n\n![](https://img.springlearn.cn/blog/learn_1589380830000.png)\n\n\n# 如何解决这种问题\n\n如何解决这种问题,其实很简单只要我们保证我们的操作是原子操作即可,简单来说就是将更新的三个步骤合并成一个步骤即可,在Java中JDK已经为我们提供了很多的\n原子操作每一个基本类型都对应一个原子操作。\n\n## 原子基础类\n\n![](https://img.springlearn.cn/blog/learn_1589378016000.png)\n\n\n**原子基础类API**\n\n![](https://img.springlearn.cn/blog/learn_1589378409000.png)\n\n## 原子数组类\n\n![](https://img.springlearn.cn/blog/learn_1589378718000.png)\n\n**原子更新数组API**\n\n![](https://img.springlearn.cn/blog/learn_1589378583000.png)\n\n\n## 原子引用类\n\n![](https://img.springlearn.cn/blog/learn_1589379304000.png)\n\n**注意:** \n\n想要原子的更新字段，需要两个步骤：\n\n　　1.每次使用的时候必须使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类和属性\n\n　　2.更新类的字段（属性）必须使用public volatile修饰符\n\n\n# 最后我们看一下原子操作的原理\n\n\n![](https://img.springlearn.cn/blog/learn_1589379629000.png)\n\n\n\n\n最后求关注,求订阅,谢谢你的阅读!\n\n\n![](https://img.springlearn.cn/blog/learn_1589360371000.png)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/java/原子操作.md b/docs/learn/java/原子操作.md
--- a/docs/learn/java/原子操作.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/java/原子操作.md	(date 1655373430351)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/project/alfred/alfred-worflow-js.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: false\nbacktotop: true\ntitle: Alfred-workflow-js\n---\n\n## 1. 基本运行\n\n\n```javascript\nvar AlfredNode = require('alfred-workflow-nodejs');\nvar actionHandler = AlfredNode.actionHandler;\nvar workflow = AlfredNode.workflow;\nvar Item = AlfredNode.Item;\n \n(function main() {\n    actionHandler.onAction(\"action1\", function(query) {\n        // your code to handle action 1 here\n    });\n    actionHandler.onAction(\"action2\", function(query) {\n        // your code to handle action 2 here\n    });\n    \n    actionHandler.onMenuItemSelected(\"action2\", function(query, selectedTitle, selectedData) {\n        // your code to handle manu item selected of action 2 here\n    });\n \n    AlfredNode.run();\n})();\n\n```\n\n## 2. 日志打印\n\n```\nconsole.warn(\"action1, 参数:\" + query)\n```\n\n## 3. 菜单\n\n使用脚本当使用tab键,会进行跳转的操作。\n\n```javascript\n\n    //输入tab键会把上一个选中的参数翻到这里\n    actionHandler.onMenuItemSelected(\"action1\", function (query, title, data) {\n        console.warn(\"data:\" + data)\n        console.warn(\"title:\" + title)\n        console.warn(\"query:\" + query)\n\n        var item1 = new Item({\n            title: \"Item 1 of \" + title,\n            arg: \"item 1 of \" + title + \" which has alias \",\n            subtitle: \"data\", // we can get data of selected item\n            valid: true\n        });\n\n        var item2 = new Item({\n            title: \"Item 2 of \" + title,\n            arg: \"item 2 of \" + title + \" which has alias \",\n            subtitle: data,\n            valid: true\n        });\n\n        workflow.addItem(item1);\n        workflow.addItem(item2);\n\n\n        var item3 = new Item({\n            title: \"Item 3 of \" + storage.get(\"key1\"),\n            arg: \"item 3 of \" + title + \" which has alias \",\n            subtitle: data,\n            valid: true\n        });\n        workflow.addItem(item3);\n\n        var item4 = new Item({\n            title: \"Item 4 of \" + storage.get(\"key2\").name,\n            arg: \"item 4 of \" + title + \" which has alias \",\n            subtitle: data,\n            valid: true\n        });\n        workflow.addItem(item4);\n\n        workflow.feedback();\n    });\n```\n\n## 4. 使用本地缓存进行CURD\n\n```javascript\n\nvar AlfredNode = require('alfred-workflow-nodejs');\nvar actionHandler = AlfredNode.actionHandler;\nvar workflow = AlfredNode.workflow;\nvar Item = AlfredNode.Item;\nworkflow.setName(\"example-alfred-workflow-using-nodejs\");\n//类似本地的缓存\nvar storage = AlfredNode.storage;\n\n\n\nvar storage = AlfredNode.storage;\nstorge.set(\"key\", \"value\");\nstorage.set(\"key\", {name: \"node\"}, 1000);\nstorage.get(\"key\");\nstorage.remove(\"key\");\nstorage.clear();\n```\n\n## 5. 获取Alfred-workflow中的配置\n\n![](https://img.springlearn.cn/blog/learn_1605443439000.png)\n\n```javascript\n\n //获取系统外部配置\n console.warn(\"系统环境变量:\" + utils.envVars.get(\"outSetting\"))\n```\n\n## 6. 异常图标\n\n可以是图片地址，也可以是系统icns地址\n\n(ACCOUNT, BURN, CLOCK, COLOR, EJECT, ERROR, FAVORITE, GROUP, HELP, HOME, INFO, NETWORK, NOTE, SETTINGS, SWIRL, SWITCH, SYNC, TRASH, USER, WARNING, WEB)\n\n```\n\nicon: AlfredNode.ICONS.INFO\n\nicon: AlfredNode.ICONS.ERROR\n```\n\n## 7. 传递给下一个的变量\n\n![](https://img.springlearn.cn/blog/learn_1605444141000.png)\n\n![](https://img.springlearn.cn/blog/learn_1605444173000.png)\n\n```\nAlfredNode.utils.generateVars({arg: 'xyz', variables: {key: value}};\n\n```\n\n## 8. 获取mac的钥匙串\n\n![](https://img.springlearn.cn/blog/learn_1605444750000.png)\n\n```\n var settings = AlfredNode.settings;\n        // 将账户密码添加到钥匙串\n        settings.setPassword(\"alfred-liuxin\", \"password\");\n        // 获取mac的钥匙串中的,密码\n        settings.getPassword(\"alfred-liuxin\", function(error, password){\n            console.warn(\"获取密码:\" + password);\n        });\n```\n\n\n## 9. 自动黏贴APP中\n\n![](https://img.springlearn.cn/blog/learn_1605446383000.png)\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/project/alfred/alfred-worflow-js.md b/docs/learn/project/alfred/alfred-worflow-js.md
--- a/docs/learn/project/alfred/alfred-worflow-js.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/project/alfred/alfred-worflow-js.md	(date 1655373430468)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/java/hooks函数.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: JVM钩子hooks函数\ncategory: Java进阶\n---\n\n\n![](https://img.springlearn.cn/blog/learn_1589383784000.png)\n\n**作者**: 西魏陶渊明\n**博客**: [https://blog.springlearn.cn/](https://blog.springlearn.cn/)\n\n::: tip 西魏陶渊明\n莫笑少年江湖梦，谁不少年梦江湖\n:::\n\n什么是钩子函数,在学习钩子函数之前,小编先提一个问题。\n\n**请问在Spring中,如果JVM异常终止,Spring是如何保证会释放掉占用的资源,比如说数据库连接等资源呢?**\n\n\n钩子函数非常简单,简单到小编只用摘抄一段Spring代码即可。走你,现在开始。\n\n\n# 问题\n\n`Spring` 容器中 `Bean` 在什么时候执行销毁方法? \n\n我们知道在Spring中定义销毁方法有两种方式\n\n1. 实现 `DisposableBean` 的 `destroy` 方法。\n2. 使用 `@PreDestroy` 注解修饰方法\n\n```\n@Component\npublic class DataCollectBean implements DisposableBean {\n\n    /**\n     * 第一种方法实现 DisposableBean#destroy方法\n     *\n     * @throws Exception 异常\n     */\n    @Override\n    public void destroy() throws Exception {\n        System.err.println(\"执行销毁方法\");\n    }\n\n    /**\n     * 第二种方法使用PreDestroy注解声明销毁方法\n     */\n    @PreDestroy\n    public void customerDestroy() {\n        System.err.println(\"执行自定义销毁方法\");\n    }\n\n\n}\n\n```\n\n\n## 那么在什么时候执行销毁方法?\n\n![](https://img.springlearn.cn/blog/learn_1589471346000.png)\n\n1. 主动执行销毁bean\n\n```\n    public static void main(String[] args) {\n        ConfigurableApplicationContext run = SpringApplication.run(DemoApplication.class, args);\n        DataCollectBean bean = run.getBean(DataCollectBean.class);\n        //1. 主动销毁bean\n        run.getBeanFactory().destroyBean(bean);\n    }\n```\n\n2. JVM关闭时候自动执行销毁方法。\n\n这里就要用到钩子函数了, `Spring` 的钩子函数在 `AbstractApplicationContext#shutdownHook属性`\n\n如果我们是SpringBoot项目我们看到在SpringApplication启动时候会注册一个钩子函数\n\n![](https://img.springlearn.cn/blog/learn_1589473259000.png)\n\n# 如何定义钩子函数?\n\n简直太简单了，没有任何学习成本。一行代码就能搞定。\n\n```\npublic class HooksTester {\n    public static void main(String[] args) {\n        Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"钩子函数执行\");\n            }\n        }));\n        //当主动关闭应用\n        while (true);\n    }\n}\n```\n\n![](https://img.springlearn.cn/blog/learn_1589471574000.png)\n# 触发钩子函数的场景\n\n只要不是机器断电，强制kill -9 强制杀进程，都会触发。\n\n![](https://img.springlearn.cn/blog/learn_1589473502000.png)\n    \n# 钩子函数能做什么？\n\n![](https://img.springlearn.cn/blog/learn_1589383970000.png)\n\n正如上图所示优雅停机,在项目将要关闭时候,主动释放程序占用的资源信息,释放db连接池的连接等其他占用的资源信息。\n如果我们是 `Spring` 项目其实我们不用自己定义钩子函数,我们只要使用Spring提供给我们的销毁方法即可。因为\nSpring定义的钩子函数中会去执行, `DisposableBean.destory()` 和被 `PreDestroy` 修饰的方法。\n\n我们看下源码\n\n![](https://img.springlearn.cn/blog/learn_1589472185000.png)\n\n```\nprotected void doClose() {\n\t\t// Check whether an actual close attempt is necessary...\n\t\tif (this.active.get() && this.closed.compareAndSet(false, true)) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Closing \" + this);\n\t\t\t}\n\n\t\t\tLiveBeansView.unregisterApplicationContext(this);\n\n\t\t\ttry {\n\t\t\t\t// Publish shutdown event.\n\t\t\t\tpublishEvent(new ContextClosedEvent(this));\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tlogger.warn(\"Exception thrown from ApplicationListener handling ContextClosedEvent\", ex);\n\t\t\t}\n\n\t\t\t// Stop all Lifecycle beans, to avoid delays during individual destruction.\n\t\t\tif (this.lifecycleProcessor != null) {\n\t\t\t\ttry {\n\t\t\t\t\tthis.lifecycleProcessor.onClose();\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tlogger.warn(\"Exception thrown from LifecycleProcessor on context close\", ex);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Destroy all cached singletons in the context's BeanFactory.\n\t\t\tdestroyBeans();\n\n\t\t\t// Close the state of this context itself.\n\t\t\tcloseBeanFactory();\n\n\t\t\t// Let subclasses do some final clean-up if they wish...\n\t\t\tonClose();\n\n\t\t\t// Reset local application listeners to pre-refresh state.\n\t\t\tif (this.earlyApplicationListeners != null) {\n\t\t\t\tthis.applicationListeners.clear();\n\t\t\t\tthis.applicationListeners.addAll(this.earlyApplicationListeners);\n\t\t\t}\n\n\t\t\t// Switch to inactive.\n\t\t\tthis.active.set(false);\n\t\t}\n\t}\n```\n\n可以看到：doClose()方法会执行bean的destroy()，也会执行SmartLifeCycle的stop()方法，我们就可以通过重写这些方法来实现对象的关闭，生命周期的管理，实现平滑shutdown\n\n\n![](https://i03piccdn.sogoucdn.com/7eac32473373b70a)\n\n最后求关注,求订阅,谢谢你的阅读!\n\n\n![](https://img.springlearn.cn/blog/learn_1589360371000.png)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/java/hooks函数.md b/docs/learn/java/hooks函数.md
--- a/docs/learn/java/hooks函数.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/java/hooks函数.md	(date 1655373430347)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/.vuepress/public/js/busuanzi.pure.mini.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/.vuepress/public/js/busuanzi.pure.mini.js b/docs/.vuepress/public/js/busuanzi.pure.mini.js
new file mode 100644
--- /dev/null	(date 1655369960996)
+++ b/docs/.vuepress/public/js/busuanzi.pure.mini.js	(date 1655369960996)
@@ -0,0 +1,57 @@
+var bszCaller, bszTag;
+!function () {
+    var c, d, e, a = !1, b = [];
+    ready = function (c) {
+        return a || "interactive" === document.readyState || "complete" === document.readyState ? c.call(document) : b.push(function () {
+            return c.call(this)
+        }), this
+    }, d = function () {
+        for (var a = 0, c = b.length; c > a; a++) b[a].apply(document);
+        b = []
+    }, e = function () {
+        a || (a = !0, d.call(window), document.removeEventListener ? document.removeEventListener("DOMContentLoaded", e, !1) : document.attachEvent && (document.detachEvent("onreadystatechange", e), window == window.top && (clearInterval(c), c = null)))
+    }, document.addEventListener ? document.addEventListener("DOMContentLoaded", e, !1) : document.attachEvent && (document.attachEvent("onreadystatechange", function () {
+        /loaded|complete/.test(document.readyState) && e()
+    }), window == window.top && (c = setInterval(function () {
+        try {
+            a || document.documentElement.doScroll("left")
+        } catch (b) {
+            return
+        }
+        e()
+    }, 5)))
+}(), bszCaller = {
+    fetch: function (a, b) {
+        var c = "BusuanziCallback_" + Math.floor(1099511627776 * Math.random());
+        window[c] = this.evalCall(b), a = a.replace("=BusuanziCallback", "=" + c), scriptTag = document.createElement("SCRIPT"), scriptTag.type = "text/javascript", scriptTag.defer = !0, scriptTag.src = a, scriptTag.referrerPolicy = "no-referrer-when-downgrade", document.getElementsByTagName("HEAD")[0].appendChild(scriptTag)
+    }, evalCall: function (a) {
+        return function (b) {
+            ready(function () {
+                try {
+                    a(b), scriptTag.parentElement.removeChild(scriptTag)
+                } catch (c) {
+                    bszTag.hides()
+                }
+            })
+        }
+    }
+}, bszCaller.fetch("//busuanzi.ibruce.info/busuanzi?jsonpCallback=BusuanziCallback", function (a) {
+    bszTag.texts(a), bszTag.shows()
+}), bszTag = {
+    bszs: ["site_pv", "page_pv", "site_uv"], texts: function (a) {
+        this.bszs.map(function (b) {
+            var c = document.getElementById("busuanzi_value_" + b);
+            c && (c.innerHTML = a[b])
+        })
+    }, hides: function () {
+        this.bszs.map(function (a) {
+            var b = document.getElementById("busuanzi_container_" + a);
+            b && (b.style.display = "none")
+        })
+    }, shows: function () {
+        this.bszs.map(function (a) {
+            var b = document.getElementById("busuanzi_container_" + a);
+            b && (b.style.display = "inline")
+        })
+    }
+};
Index: docs/learn/java/HashMap.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 再也不怕被HashMap欺负了\ncategory: Java进阶\n---\n\n\n![](https://img.springlearn.cn/blog/learn_1596467333000.png)\n\n**作者**: 西魏陶渊明\n**博客**: [https://blog.springlearn.cn/](https://blog.springlearn.cn/)\n\n::: tip 西魏陶渊明\n莫笑少年江湖梦，谁不少年梦江湖\n:::\n\n\n> HashMap是我们在日常开发中经常使用的一个结合类型,同时也是面试时候最好提问的集合类型,在这里进行整理\n> 一起学习,进步。\n\n\n## 一、数据结构\n\n先说两种数据结构, 不用怕, 如果要对付面试只要了解就行了。不用手写实现, 同时也因为已经有人帮我写好,所以开发中我们只要用就行。\n\n### 1. 二叉树\n\n[动画展示二叉树](https://www.cs.usfca.edu/~galles/visualization/BST.html)\n\n本来是一个相对平衡的二叉树(当前数据 > 根节点 ？ 从右边插入 : 从左边插入)。\n![](https://img.springlearn.cn/blog/learn_1596522740000.png)\n但是由于在使用的过程中的删除,慢慢的变成了一个瘸腿。此时树的高度越高,数据越多,导致查询叶子\n的耗时越长。\n![](https://img.springlearn.cn/blog/learn_1596522608000.png)\n\n于是乎人们在这个数据结构的基础上,研究出新的结构,就是下面的红黑树。\n\n### 2. 红黑树\n\n[动画展示红黑树](https://www.cs.usfca.edu/~galles/visualization/RedBlack.html)\n\n依次插入7 5 3 2 4 6 8 9 12 11 17 13 14 16\n\n很明显我们可以看出红黑树比二叉树相对比较平衡。\n![](https://img.springlearn.cn/blog/learn_1596523217000.png)\n\n在对比一下二叉树\n\n![](https://img.springlearn.cn/blog/learn_1596523318000.png)\n\n\n好了关于数据结构的知识就说这么多,可以通过图就能知道这两种数据结构情况了。因为数据结构不是我们本篇研究的点。\n所以就提这么多。\n\n\n## 二、源码分析\n\n\nHashMap 实现了 Map 接口,JDK1.7由 数组 + 链表实现， 1.8后由 数组 + 链表 + 红黑树实现\n\n![](https://img.springlearn.cn/blog/learn_1596527068000.png)\n\n### 1. put的源码分析\n\nHashMap中声明的常量信息,注意看。下面源码中会提到。\n\n|变量|含义|\n|---|---|\n|DEFAULT_INITIAL_CAPACITY| 默认的初始容量|\n|MAXIMUM_CAPACITY|最大的容量2^30|\n|DEFAULT_LOAD_FACTOR|容器个数 size > 负载因子 * 数组长度  就需要进行扩容|\n|TREEIFY_THRESHOLD| 如果数组中某一个链表 >= 8 需要转化为红黑树|\n|UNTREEIFY_THRESHOLD|如果数组中某一个链表转化为红黑树后的节点 < 6 的时候 继续转为 链表|\n\n\n```\n final V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n        Node<K,V>[] tab; Node<K,V> p; int n, i;\n        if ((tab = table) == null || (n = tab.length) == 0)\n            n = (tab = resize()).length;\n        if ((p = tab[i = (n - 1) & hash]) == null)\n            tab[i] = newNode(hash, key, value, null);\n        else {\n            Node<K,V> e; K k;\n            if (p.hash == hash &&\n                ((k = p.key) == key || (key != null && key.equals(k))))\n                e = p;\n            //判断是否是树    \n            else if (p instanceof TreeNode)\n                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n            //继续用链表    \n            else {\n                // 循环链表\n                for (int binCount = 0; ; ++binCount) {\n                    if ((e = p.next) == null) {\n                        // 新建节点存储\n                        p.next = newNode(hash, key, value, null);\n                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                            //大于树的阀值,就转换为树结构\n                            treeifyBin(tab, hash);\n                        break;\n                    }\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        break;\n                    p = e;\n                }\n            }\n            if (e != null) { // existing mapping for key\n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value;\n                afterNodeAccess(e);\n                return oldValue;\n            }\n        }\n        ++modCount;\n        if (++size > threshold)\n            resize();\n        afterNodeInsertion(evict);\n        return null;\n    }\n\n```\n\n从上面源码中我们可以看到在put时候会判断是链表结构还是红黑树。如果是树就用树put\n`((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);`。\n\n如果是链表就循环列表插入数据,如果发现列表长度大于树的阀值就讲链表转换为树\n\n\n### 2. put流程赘述\n\n1. 判断 table 是否为 null。为 null 则新建一个 table 数组\n2. 调用 hash 获取 该 key 的 hash 值\n![](https://img.springlearn.cn/blog/learn_1596528441000.png)\n3. 如果发现有数据,且还是树结构就调用树的put方法\n4. 如果发现有数据,是链表的结构就循环插入尾部,如果发现达到了要转换树的长度,就转成红黑树\n5. 发现key冲突直接新值替换旧值,并且break;\n![](https://img.springlearn.cn/blog/learn_1596528854000.png)\n\n## 三、面试知识扩展\n\n前面我们知道了HashMap在1.8之后的优化。这里我们最后再说一个面试题。\n问: 1.7时候hashmap在扩容时候回出现死链的问题。问题原因是什么?  已经出现的场景是什么?\n\n首先看下扩容方法 `resize`\n![](https://img.springlearn.cn/blog/learn_1596530770000.png)\n\n### 1. 优化1\n\njdk1.8在对链表进行扩容时候时候不是直接都去hash了。而是\n`(e.hash & oldCap) == 0` 下标不变\n`(e.hash & oldCap) != 0` 下标 = 原下标 + oldCap\n\n### 2. 出现的场景\n\n多线程操作扩容\n\n![](https://img.springlearn.cn/blog/learn_1596531864000.png)\n\n最后求关注,求订阅,谢谢你的阅读!\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/java/HashMap.md b/docs/learn/java/HashMap.md
--- a/docs/learn/java/HashMap.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/java/HashMap.md	(date 1655373430153)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/java/Java异常体系.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: Java异常体系\ncategory: Java进阶\n---\n\n\n![](https://img.springlearn.cn/blog/learn_1589293715000.png)\n\n**作者**: 西魏陶渊明\n**博客**: [https://blog.springlearn.cn/](https://blog.springlearn.cn/)\n\n::: tip 西魏陶渊明\n莫笑少年江湖梦，谁不少年梦江湖\n:::\n\n知己知彼方能百战不殆,在小编初学Java时候特别怕程序报异常,经常会因为异常不知所措,相信这个问题应该是所有\n初学者都会有的心理感受;如果你也有这种感受,那么只有一种解决方法:\n迎难而上,攻克Java异常体系,长痛不如短痛,只要清楚了Java的异常体系,就不会再有这种感受了。下面跟着小编来窥探Java的异常体系吧。\n\n\n# 一、Java异常体系其实很简单\n\n其实Java的异常体系是非常简单的,简单到只要你看过本文就能明白百分之八九十的样子。当你清楚了Java的异常体系\n那么在遇到项目执行异常的时候,基本看报错的异常就大概明白问题出在哪里,遇到的错误多了,就成长了,处理的问题就是\n你未来在技术路上所积累的财富。\n\n![](https://img.springlearn.cn/blog/learn_1589294764000.png)\n\n在Java的异常体系中 `Throwable` 我们可以理解为是一个根异常,即所有的异常都是它的子类\n\n![](https://img.springlearn.cn/blog/learn_1589295509000.png)\n\n# 二、Error\n\n前面我们说了Java的异常体系中 `Throwable` 可以理解是一个根异常,那么 `Error` 就是这个根节点的一个子节点。\n`Error` 类对象由 `Java` 虚拟机生成并抛出，大多数错误与代码编写者所执行的操作无关。程序无法处理的异常，一般伴随者jvm虚拟机停止，或者断电之类\n这种问题，是无法通过程序来解决的。\n\n**这种异常基本很少,如果遇到也不要慌,跟你的业务逻辑没有关系,顶多是Java代码写的有问题,只要不是业务问题其实大多都能先通过重启解决;\n但是假如项目还未上线,只是在开发过程中出现这种问题一定要弄清楚原因,是那一部分代码编写异常导致的,否则上线可能有重大隐患**\n\n**经验教学:**\n \n1. 如果是在项目系统过程中遇到这种问题,可能是因为Jar包冲突导致的。\n2. 如果是在项目运行过程中遇到这种问题,可能是因为对象创建过多没有释放,导致堆栈溢出。这个时候就要看GC是否频繁,然后对堆栈日志进行分析,看存在最多的对象是哪一个,然后分析代码解决。\n\n# 三、Exception\n\n`Exception` 异常时我们平时在开发中遇到最多，其实 `Exception` 也分为两种即: \n\n1. `checkException` 编译异常，这种异常，是哪些没有遵守java语言规则，容易看出和解决的\n2. `uncheckException` 运行异常，运行异常，具有不确定性，往往难以排查，包括处理逻辑问题。\n\n然而 `checkException` 和 `uncheckException` 其实只是一个概念,并没有对应的 `Java异常类`。我们基本可以忽略\n`checkException` 因为这种异常基本现在的编译器都会给我们做了，我们在写代码时候就会实时的给我提示错误了。我们\n只用关心 `uncheckException`即可。\n\n**uncheckException**\n\n![](https://img.springlearn.cn/blog/learn_1589297073000.png)\n\n`RuntimeException` + `Error` 和其子类都是属于 `uncheckException`\n\n前面我们已经对 `Error` 做了说明，现在就主要来看下 `RuntimeException`。 `RuntimeException` 从名字来看就是\n运行异常,所谓运行异常就是可能在程序运行过程中发生的异常,这种异常一般是可以通过代码逻辑进行处理的。\n我们举例一个例子,我们都知道0不能作为除数。但是假如在下面这个代码中\n\n```\npublic class Tester {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        System.out.print(\"请输入被除数a:\");\n        int a = sc.nextInt();\n        System.out.print(\"请输入除数b:\");\n        int b = sc.nextInt();\n        System.out.println(\"a/b=\" + a / b);\n    }\n}\n```\n\n当输入a=8,b=2,那么结果就是4。\n\n![](https://i02piccdn.sogoucdn.com/8206a4441e0386c3)\n\n\n**假如我们输入b=0呢?**\n\n学过数学都知道0不能做除数,程序也不运行你这么输入,但是却不能阻止你,只能通过报错的方式来告诉你。\n\n\n![](https://img.springlearn.cn/blog/learn_1589298143000.png)\n\n那么我们就要对这个异常进行处理,当发现有这个异常就在控制台来提醒用户。那么代码就会变成这样\n\n```\npublic class Tester {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        System.out.print(\"请输入被除数a:\");\n        int a = sc.nextInt();\n        System.out.print(\"请输入除数b:\");\n        int b = sc.nextInt();\n        try {\n            System.out.println(\"a/b=\" + a / b);\n        } catch (ArithmeticException ate) {\n            //对算术异常进行捕捉\n            System.err.println(\"0不能作为除数,请输入不为0的任意数\");\n        }\n    }\n}\n\n```\n当出现算术异常直接提示: \"0不能作为除数,请输入不为0的任意数\"\n![](https://img.springlearn.cn/blog/learn_1589298261000.png)\n\n那么像这种程序中无可避免会出现,且又能通过逻辑来处理的异常就是运行异常。运行异常一般都可以正常运行,只是在特定情况下会导致异常发生。\n像这面这个例子,我们只要看到 `ArithmeticException` 就知道是算术异常。所以只要我们对运行异常类有一个认识，其实就能解决大多数的程序问题了。\n下面我们来看下运行异常都要有哪些类把。\n\n![](https://i03piccdn.sogoucdn.com/f960e6a461d218d2)\n\n\n**只要对下面运行异常类进行熟悉了,基本就清楚掌握了Java的异常体系了**\n\n![](https://img.springlearn.cn/blog/learn_1589299119000.png)\n\n![](https://img.springlearn.cn/blog/learn_1589299523000.png)\n\n以上就是常见的运行异常类,当然Java中还有很多不常见的异常类。剩下的我们就可以在日常工作中去学习了。\n\n\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/java/Java异常体系.md b/docs/learn/java/Java异常体系.md
--- a/docs/learn/java/Java异常体系.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/java/Java异常体系.md	(date 1655373430173)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/java/CountDownLatch.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 倒计锁 CountDownLatch\ncategory: Java进阶\n---\n\n\n![](https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png)\n\n**作者**: 西魏陶渊明\n**博客**: [https://blog.springlearn.cn/](https://blog.springlearn.cn/)\n\n::: tip 西魏陶渊明\n莫笑少年江湖梦，谁不少年梦江湖\n:::\n\n上文我们知道了 `Semaphore` 信号量的用法，那么这一篇基本不用学了。因为原理基本上是一样的。\n但是用法不太一样。\n\n\n`Semaphore` 是获取到资源就执行，获取不到资源就等待。\n`CountDownLatch` 跟 `Semaphore` 正好相反。\n\nCountDownLatch#await() 可以理解为获取不到资源，就等待。这么说不太好理解，直接看源码吧。\n\n```java CountDownLatch内部实现类\nprivate static final class Sync extends AbstractQueuedSynchronizer {\n        private static final long serialVersionUID = 4982264981922014374L;\n\n        Sync(int count) {\n            setState(count);\n        }\n\n        int getCount() {\n            return getState();\n        }\n\n        protected int tryAcquireShared(int acquires) {\n            // 获取资源,await就是调用这个方法。当tryReleaseShared没有进行扣减之前。\n            // 这里一直都是-1。而-1就是获取不到资源进行等待\n            return (getState() == 0) ? 1 : -1;\n        }\n\n        protected boolean tryReleaseShared(int releases) {\n            // countDown就调用这个方法,进行扣减1\n            for (;;) {\n                int c = getState();\n                if (c == 0)\n                    return false;\n                int nextc = c-1;\n                if (compareAndSetState(c, nextc))\n                    return nextc == 0;\n            }\n        }\n    }\n\n```\n\n## 常用用法\n\n**注意:**\n==CountDownLatch不可重复使用，当计数器减少到0之后，就废了，无法继续使用了。==\n\nCountDownLatch是在java1.5被引入的，跟它一起被引入的并发工具类还有CyclicBarrier、Semaphore、ConcurrentHashMap和BlockingQueue，它们都存在于java.util.concurrent包下。CountDownLatch这个类能够使一个线程等待其他线程完成各自的工作后再执行。例如，应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行。\n\nCountDownLatch是通过一个计数器来实现的，计数器的初始值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就会减1。当计数器值到达0时，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务。\n\n![](http://incdn1.b0.upaiyun.com/2015/04/f65cc83b7b4664916fad5d1398a36005.png)\n\n\n\n## CountDownLatch 存在的意义\n\n让主线程阻塞，等待线程结束后在运行\n\n\n直译过来就是倒计数(CountDown)门闩(Latch)。倒计数不用说，门闩的意思顾名思义就是阻止前进。在这里就是指 CountDownLatch.await() 方法在倒计数为0之前会阻塞当前线程。\n\n**实现**\n\nCountDownLatch内部维护一个最大线程数，当每个线程执行结束，就调用\n`latch.countDown();` 将数量减 1 ,当数量为0的时候，就放弃阻塞主线程，也就是放弃 `countDownLatch.await() `阻塞的线程\n\n\n## 代码解释\n\n```java\n public void test()throws Exception{\n        int pagecount=3;\n        ExecutorService executors = Executors.newFixedThreadPool(pagecount);\n        CountDownLatch countDownLatch = new CountDownLatch(pagecount);\n        for (int i = 0; i < pagecount; i++) {\n            // 启动线程抓取\n            executors\n                    .execute(new Runnable() {\n                        @Override\n                        public void run() {\n                            System.out.println(Thread.currentThread().getName());\n                            countDownLatch.countDown();\n                        }\n                    });\n        }\n        countDownLatch.await();//主线程阻塞在这里，等到线程结束,\n        //然后关闭线程池\n        executors.shutdown();\n\n    }\n\n\n\n```\n\n\n\n## 最大缺点\n\n通过前面源码我们发现, `CountDownLatch` 只有减没有加，所以导致了一个最大的缺点就是\n只能使用一次,当扣减为0的时候,那么就不能在继续使用了。所以就要引入 `CyclicBarrier`了。\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/java/CountDownLatch.md b/docs/learn/java/CountDownLatch.md
--- a/docs/learn/java/CountDownLatch.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/java/CountDownLatch.md	(date 1655373430213)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/java/函数式编程.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: Lambda函数式编程\ncategory: Java进阶\n---\n\n![](https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png)\n\n**作者**: 西魏陶渊明\n**博客**: [https://blog.springlearn.cn/](https://blog.springlearn.cn/)\n\n::: tip 西魏陶渊明\n莫笑少年江湖梦，谁不少年梦江湖\n:::\n\n>Java8所有的新特性基本基于函数式编程的思想，函数式编程给Java带来了注入了新鲜的活力。\n>函数式编程其实并不是很难，小编在学习函数式编程时候刚开始一头雾水，最后仔细观察就发现了其中的小窍门，读了本篇文章如果还没有掌握，就算我输了\n\n\n# 函数式编程\n\n\n\n## 一、Lambda表达式\n\n**注意**: 以下方法都可以使用表达式来进行缩写\n\n我们来看Java中如何来定义一个方法\n\n### 1. 语法\n\n`()->{}`\n\n其中小括号里面可以放入参，大括号就是方法体，里面也允许有返回值。\n\n**当方法体中只有返回值而没有其他语句时候，大括号和 `return` 关键字都可以省略不写。**\n\n\n### 2. 方法引用\n\n*只要用.引用不报错的，都可以将.换成:*\n\n| 类型                      | 语法                           |\n| ------------------------- | ------------------------------ |\n| 1、引用静态方法           | ClassName::staticMethodName    |\n| 2、引用构造函数           | ClassName::new                 |\n| 3、引用特定类型的实例方法 | ClassName::instanceMethodName  |\n| 4、引用特定对象的实例方法 | objectName::instanceMethodName |\n\n\n## 二、Java8新增函数式接口\n\n### 1. Predicate接口\n\nPredicate 接口只有一个参数，返回boolean类型。该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）\n\n```\nPredicate<String> predicate = (s) -> s.length() > 0;\n```\n根据前面的语法我们知道小括号里面可以放入参，大括号里面放出参，当大括号里面只有返回值时候，大括号和 `return` 关键字也可以省略。如上。\n### 2. Function 接口\n\nFunction 接口有一个参数并且返回一个结果，并附带了一些可以和其他函数组合的默认方法（compose, andThen）：\n\n```\nFunction<Integer, Integer> function = (x) -> 2 * x;\n```\n同理，这个接口有一个入参和出参，如果返回体重不包含其他逻辑，只有一个返回值，大括号和 `return` 关键字也可以省略。如上。\n\n### 3. Supplier 接口\n\nSupplier 接口返回一个任意范型的值，和Function接口不同的是该接口没有任何参数\n\n```\npublic class Main{\n    public static void main(String[] args) {\n        //构造方法\n        Supplier<Main> supplier = () -> new Main();\n        Supplier<Main> mainSupplier = Main::new;\n        Supplier<Main> mainSupplier1 = Main::staticMethod;\n    }\n    private static Main staticMethod() {\n        return new Main();\n    }\n}\n```\n\n因为没有入参，所以小括号里面什么都不用写。当遇到这种情况，同样可以用上面其他两种来替换\n\n### 4. Consumer 接口\n\nConsumer 是一个只有入参，但是无出参的接口。\n\n```\npublic class Main {\n    public static void main(String[] args) {\n        List<String> dataList = Arrays.asList(\"1\", \"2\");\n\n        //特定类的静态方法\n        dataList.forEach(Main::staticMethod);\n        dataList.forEach((x) -> System.out.println(x));\n        dataList.forEach(System.out::println);\n\n    }\n    private static void staticMethod(String name) {\n        System.out.println(\"对象静态方法引用:\" + name);\n    }\n}\n```\n\n## 三、快速记忆\n\n虽然新增的函数式接口并不多，但是想要一次性死记住，还是有一点点的难度。小编的学习方式是\n理解这记忆。\n\n| 类型         | 简记           |\n| ------------ | -------------- |\n| 1、Predicate | 条件类型       |\n| 2、Supplier  | 无入参，有出参 |\n| 3、Function  | 有入参，有出参 |\n| 4、Consumer  | 有入参，无出参 |\n\n\n最后求关注,求订阅,谢谢你的阅读!\n\n\n![](https://img.springlearn.cn/blog/learn_1589360371000.png)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/java/函数式编程.md b/docs/learn/java/函数式编程.md
--- a/docs/learn/java/函数式编程.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/java/函数式编程.md	(date 1655373430763)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/java/ReadWriteLock.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 读写锁 ReadWriteLock\ncategory: Java进阶\n---\n\n\n![](https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png)\n\n**作者**: 西魏陶渊明\n**博客**: [https://blog.springlearn.cn/](https://blog.springlearn.cn/)\n\n::: tip 西魏陶渊明\n莫笑少年江湖梦，谁不少年梦江湖\n:::\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/java/ReadWriteLock.md b/docs/learn/java/ReadWriteLock.md
--- a/docs/learn/java/ReadWriteLock.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/java/ReadWriteLock.md	(date 1655373430358)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/java/线程池.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 线程池扫盲\ncategory: Java进阶\n---\n\n\n![](https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png)\n\n**作者**: 西魏陶渊明\n**博客**: [https://blog.springlearn.cn/](https://blog.springlearn.cn/)\n\n::: tip 西魏陶渊明\n莫笑少年江湖梦，谁不少年梦江湖\n:::\n\n> [!TIP]\n> 本篇文章通读时间大概3分钟,希望在三分钟内的讲解，对你有所帮助，\n> 一定要认真看并思考，好了。废话不多数，直接上干货,本节内容我们讲\n> 的是Java的线程池,在讲之前我们首先看一下有哪些线程池，这些线程池\n> 我们不过多讲解,因为我们的关注点是他们是如何实现的,和其运行的原理。\n\n\n# 一、常用线程池列表\n\n这部分内容,只是帮助你回顾一下线程池的知识，大家重点看方法内的实现\n\n1、构造一个固定线程数目的线程池，配置的corePoolSize与maximumPoolSize大小相同，同时使用了一个无界LinkedBlockingQueue存放阻塞任务，因此多余的任务将存在再阻塞队列，不会由RejectedExecutionHandler处理\n\n```java\n    public static ExecutorService newFixedThreadPool(int nThreads) {\n        return new ThreadPoolExecutor(nThreads, nThreads,\n                                      0L, TimeUnit.MILLISECONDS,\n                                      new LinkedBlockingQueue<Runnable>());\n    }\n```\n\n2、构造一个缓冲功能的线程池，配置corePoolSize=0，maximumPoolSize=Integer.MAX_VALUE，keepAliveTime=60s,以及一个无容量的阻塞队列 SynchronousQueue，因此任务提交之后，将会创建新的线程执行；线程空闲超过60s将会销毁\n```java\n    public static ExecutorService newCachedThreadPool() {\n        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                      60L, TimeUnit.SECONDS,\n                                      new SynchronousQueue<Runnable>());\n    }\n```\n\n3、构造一个只支持一个线程的线程池，配置corePoolSize=maximumPoolSize=1，无界阻塞队列LinkedBlockingQueue；保证任务由一个线程串行执行\n```java\n    public static ExecutorService newSingleThreadExecutor() {\n        return new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1,\n                                    0L, TimeUnit.MILLISECONDS,\n                                    new LinkedBlockingQueue<Runnable>()));\n    }\n```\n\n4、构造有定时功能的线程池，配置corePoolSize，无界延迟阻塞队列DelayedWorkQueue；有意思的是：maximumPoolSize=Integer.MAX_VALUE，由于DelayedWorkQueue是无界队列，所以这个值是没有意义的\n\n```java\n    /**\n     * Creates a thread pool that can schedule commands to run after a\n     * given delay, or to execute periodically.\n     * @param corePoolSize the number of threads to keep in the pool,\n     * even if they are idle\n     * @return a newly created scheduled thread pool\n     * @throws IllegalArgumentException if {@code corePoolSize < 0}\n     */\n    public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {\n        return new ScheduledThreadPoolExecutor(corePoolSize);\n    }\n\n```\n\n\n# 二、ThreadPoolExecutor\n\n相信大家从上面的众多线程池中都已经看到了这个类,因为上面的线程池底层的构造都是由这个类创建的,\n\n那么我们就开始研究这个类\n\n```java\n/**\n * @since 1.5\n * @author Doug Lea\n */\npublic class ThreadPoolExecutor extends AbstractExecutorService {\n\t...\n}\n```\n\n首先看一下构造方法，关于注释一定要好好看，每个参数都理解了，那么你就弄懂了\n\n```java\n\n/**\n     *\n     * @param corePoolSize 核心线程池大小\n     * @param maximumPoolSize 线程池最大容量\n     * @param keepAliveTime 线程池空闲时，线程存活时间\n     * @param unit 时间单位\n     * @param workQueue 工作队列\n\t * @param threadFactory 线程工厂\n     * @throws IllegalArgumentException if one of the following holds:<br>\n     *         {@code corePoolSize < 0}<br>\n     *         {@code keepAliveTime < 0}<br>\n     *         {@code maximumPoolSize <= 0}<br>\n     *         {@code maximumPoolSize < corePoolSize}\n     * @throws NullPointerException if {@code workQueue} is null\n     */\n      public ThreadPoolExecutor(int corePoolSize,\n                                 int maximumPoolSize,\n                                 long keepAliveTime,\n                                 TimeUnit unit,\n                                 BlockingQueue<Runnable> workQueue,\n                                 ThreadFactory threadFactory) {\n           this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,\n                threadFactory, defaultHandler);\n       }\n```\n\n\n# 三、构造参数详解\n\n| 参数            | 说明                                                         |\n| --------------- | ------------------------------------------------------------ |\n| corePoolSize    | 核心的线程数                                                 |\n| maximumPoolSize | 最大线程池就是说你定义的线程池运行创建的最大线程数量         |\n| keepAliveTime   | 空闲时间回收，当这个时间后还没有任务执行就将线程回收         |\n| unit            | 单位,控制上面时间的单位，可以为秒，或者分钟                  |\n| workQueue       | 核心线程都已经去执行任务但是，任务还有，那么久先放到这个队列里，就相当于集合 |\n| threadFactory   | 创建线程用户的线程工厂,里面只有一个方法就是newThread，你可以自定义线程名 |\n\n<font color=red>上面的文字可能你看的不太明白，小编这里画了一个图，大家仔细看看 </font>\n\n这张图是小编之前画的，但是头条压缩了，导致图不太清楚，大家看到字就行了\n\n![](https://img.springlearn.cn/blog/learn_1640316132000.png)\n\n## 1. 执行顺序\n\n1. 首先交给核心线程数来执行corePoolSize\n2. 如果核心都用完了，就放到workQueue队列里面\n3. 当队列和核心线程数都满了，就继续创建线程，直到等于maximumPoolSize为止\n4. 当任务已经塞不下了，就开始执行拒绝策略(下一篇讲)\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/java/线程池.md b/docs/learn/java/线程池.md
--- a/docs/learn/java/线程池.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/java/线程池.md	(date 1655373430151)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/mybatis/Mybatis一级二级缓存设计.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: true\nfooter: true\npassword: 111\nbacktotop: true\ntitle: 第06篇:Mybatis缓存设计\ncategory: Mybatis\n---\n\n\n[官方文档](https://mybatis.net.cn/sqlmap-xml.html#cache)\n\n:::tip\nMyBatis 内置了一个强大的事务性查询缓存机制，它可以非常方便地配置和定制。本篇文章，小编将会在最短的时间呢，通过观察源码来深刻了解Mybatis的\n一级二级缓存;然后在说如何定制。\n:::\n\n\n\n\n## 一、Mybatis Cache设计\n\n在Mybatis中所有的缓存,都是实现自Cache接口。无论是一级缓存还是二级缓存都是实现这个接口。其中一级缓存是本地缓存，二级缓存是一个允许开发者扩展的\n缓存(eg: ehcache/或者内置的很多缓存)。\n\n```java \npublic interface Cache {\n\n  String getId();\n\n  void putObject(Object key, Object value);\n\n  Object getObject(Object key);\n\n  Object removeObject(Object key);\n\n  void clear();\n\n  int getSize();\n\n  default ReadWriteLock getReadWriteLock() {\n    return null;\n  }\n\n}\n\n```\n\n## 二、一级缓存\n\n一级缓存是本地缓存,其实就是PerpetualCache这类,它的源码也很简单,其实就是一个Map而已。一般面试的经常说一级缓存称为\nSqlSession缓存,我们看其实最终实现是在BaseExecutor进行做的。就这么简单。\n\n```java\npublic abstract class BaseExecutor implements Executor {\n\n    // 一级缓存本地缓存\n    protected PerpetualCache localCache;\n    \n    protected BaseExecutor(Configuration configuration, Transaction transaction) {\n        this.transaction = transaction;\n        this.deferredLoads = new ConcurrentLinkedQueue<>();\n        this.localCache = new PerpetualCache(\"LocalCache\");\n    }\n    \n    // 执行查询后添加到一级缓存中\n    private <E> List<E> queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {\n        List<E> list;\n        localCache.putObject(key, EXECUTION_PLACEHOLDER);\n        try {\n          list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);\n        } finally {\n          localCache.removeObject(key);\n        }\n        localCache.putObject(key, list);\n        if (ms.getStatementType() == StatementType.CALLABLE) {\n          localOutputParameterCache.putObject(key, parameter);\n        }\n        return list;\n      }\n}  \n```\n\n## 三、二级缓存\n\n二级缓存是基于装饰器模式,它允许开发者自定义缓存的实现,只要实现了Cache接口就行。通过装饰器的设计。\nCachingExecutor从MappedStatement#getCache获取缓存的具体实现，从而进行缓存操作。\n\n下面代码是看Mybatis是如何进行装饰器的。注意看注释。如果开启缓存,则包装器对Executor进行包装。\n\n```java \npublic class Configuration {\n    public Executor newExecutor(Transaction transaction, ExecutorType executorType) {\n        executorType = executorType == null ? defaultExecutorType : executorType;\n        executorType = executorType == null ? ExecutorType.SIMPLE : executorType;\n        Executor executor;\n        if (ExecutorType.BATCH == executorType) {\n          executor = new BatchExecutor(this, transaction);\n        } else if (ExecutorType.REUSE == executorType) {\n          executor = new ReuseExecutor(this, transaction);\n        } else {\n          executor = new SimpleExecutor(this, transaction);\n        }\n        // 如果开启缓存,则包装器对Executor进行包装\n        if (cacheEnabled) {\n          executor = new CachingExecutor(executor);\n        }\n        executor = (Executor) interceptorChain.pluginAll(executor);\n        return executor;\n  }\n}\n```\n\nCachingExecutor在实际执行时候从MappedStatement#getCache获取缓存的具体实现，从而进行缓存操作。\n看到查询是先从二级缓存中获取，如果没有获取到就从一级缓存中获取，还没有就查询db。\n\n\n```java \npublic class CachingExecutor implements Executor {\n\n  @Override\n  public <E> List<E> query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)\n      throws SQLException {\n    // 从MappedStatement获取Cache\n    Cache cache = ms.getCache();\n    if (cache != null) {\n      flushCacheIfRequired(ms);\n      if (ms.isUseCache() && resultHandler == null) {\n        ensureNoOutParams(ms, boundSql);\n        @SuppressWarnings(\"unchecked\")\n        List<E> list = (List<E>) tcm.getObject(cache, key);\n        if (list == null) {\n          list = delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);\n          tcm.putObject(cache, key, list); // issue #578 and #116\n        }\n        return list;\n      }\n    }\n    return delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);\n  }\n}\n```\n\n注意这里可以看到如果指定了要进行缓存，但是没有指定缓存的type默认是 PERPETUAL(PerpetualCache\n)\n\n## 四、开启二级缓存\n\n## 4.1 内置二级缓存\n\n1. 首先开启配置\n2. 同时在Mapper文件中添加<cache/>标签 (XMLMapperBuilder#cacheElement)\n3. 或者是在Mapper类上添加@CacheNamespace注解(MapperAnnotationBuilder#parseCache)\n\n```xml \n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n    <!-- 指定Mybatis使用log4j -->\n    <settings>\n        <setting name=\"logImpl\" value=\"LOG4J\"/>\n        // 通过 cacheEnabled 进行配置,如果不配置默认是true\n        <setting name=\"cacheEnabled\" value=\"false\"/>\n    </settings>\n</configuration>\n\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"orm.example.dal.mapper.TUserMapper\">\n    // 添加cache标签\n    <cache/>\n</mapper>    \n```\n\n|属性|含义|\n|:--|:--|\n|eviction|缓存回收策略|\n|flushInterval|缓存刷新间隔，缓存多长时间刷新一次，默认不清空，设置一个毫秒值|\n|readOnly| 是否只读；true 只读|\n|size|缓存存放多少个元素|\n|type|指定自定义缓存的全类名(实现Cache 接口即可)|\n|blocking|若缓存中找不到对应的key，是否会一直blocking，直到有对应的数据进入缓存。|\n\n一共可以使用的二级缓存有以下这些。\n\n![](https://img.springlearn.cn/blog/learn_1648571791000.png)\n\n## 4.2 外置二级缓存\n\n只要实现了Cache接口那么Mybatis就会调用这个接口实现进行缓存。下面只说一个思路。如下通过指定EhcacheCache\n就可以将这个二级缓存的能力，交给Mybatis进行调用了。\n\n```xml \n<cache type=\"org.mybatis.caches.ehcache.EhcacheCache\" > \n      <property name=\"timeToIdleSeconds\" value=\"3600\"/>\n      <property name=\"timeToLiveSeconds\" value=\"3600\"/>\n      <!-- 同ehcache参数maxElementsInMemory -->\n    <property name=\"maxEntriesLocalHeap\" value=\"1000\"/>\n    <!-- 同ehcache参数maxElementsOnDisk -->\n      <property name=\"maxEntriesLocalDisk\" value=\"10000000\"/>\n      <property name=\"memoryStoreEvictionPolicy\" value=\"LRU\"/>\n</cache>\n```\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/mybatis/Mybatis一级二级缓存设计.md b/docs/learn/mybatis/Mybatis一级二级缓存设计.md
--- a/docs/learn/mybatis/Mybatis一级二级缓存设计.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/mybatis/Mybatis一级二级缓存设计.md	(date 1655373430610)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/java2/Java异常体系.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: Java异常体系\n---\n\n\n![](https://img.springlearn.cn/blog/learn_1589293715000.png)\n\n知己知彼方能百战不殆,在小编初学Java时候特别怕程序报异常,经常会因为异常不知所措,相信这个问题应该是所有\n初学者都会有的心理感受;如果你也有这种感受,那么只有一种解决方法:\n迎难而上,攻克Java异常体系,长痛不如短痛,只要清楚了Java的异常体系,就不会再有这种感受了。下面跟着小编来窥探Java的异常体系吧。\n\n\n# 一、Java异常体系其实很简单\n\n其实Java的异常体系是非常简单的,简单到只要你看过本文就能明白百分之八九十的样子。当你清楚了Java的异常体系\n那么在遇到项目执行异常的时候,基本看报错的异常就大概明白问题出在哪里,遇到的错误多了,就成长了,处理的问题就是\n你未来在技术路上所积累的财富。\n\n![](https://img.springlearn.cn/blog/learn_1589294764000.png)\n\n在Java的异常体系中 `Throwable` 我们可以理解为是一个根异常,即所有的异常都是它的子类\n\n![](https://img.springlearn.cn/blog/learn_1589295509000.png)\n\n# 二、Error\n\n前面我们说了Java的异常体系中 `Throwable` 可以理解是一个根异常,那么 `Error` 就是这个根节点的一个子节点。\n`Error` 类对象由 `Java` 虚拟机生成并抛出，大多数错误与代码编写者所执行的操作无关。程序无法处理的异常，一般伴随者jvm虚拟机停止，或者断电之类\n这种问题，是无法通过程序来解决的。\n\n**这种异常基本很少,如果遇到也不要慌,跟你的业务逻辑没有关系,顶多是Java代码写的有问题,只要不是业务问题其实大多都能先通过重启解决;\n但是假如项目还未上线,只是在开发过程中出现这种问题一定要弄清楚原因,是那一部分代码编写异常导致的,否则上线可能有重大隐患**\n\n**经验教学:**\n \n1. 如果是在项目系统过程中遇到这种问题,可能是因为Jar包冲突导致的。\n2. 如果是在项目运行过程中遇到这种问题,可能是因为对象创建过多没有释放,导致堆栈溢出。这个时候就要看GC是否频繁,然后对堆栈日志进行分析,看存在最多的对象是哪一个,然后分析代码解决。\n\n# 三、Exception\n\n`Exception` 异常时我们平时在开发中遇到最多，其实 `Exception` 也分为两种即: \n\n1. `checkException` 编译异常，这种异常，是哪些没有遵守java语言规则，容易看出和解决的\n2. `uncheckException` 运行异常，运行异常，具有不确定性，往往难以排查，包括处理逻辑问题。\n\n然而 `checkException` 和 `uncheckException` 其实只是一个概念,并没有对应的 `Java异常类`。我们基本可以忽略\n`checkException` 因为这种异常基本现在的编译器都会给我们做了，我们在写代码时候就会实时的给我提示错误了。我们\n只用关心 `uncheckException`即可。\n\n**uncheckException**\n\n![](https://img.springlearn.cn/blog/learn_1589297073000.png)\n\n`RuntimeException` + `Error` 和其子类都是属于 `uncheckException`\n\n前面我们已经对 `Error` 做了说明，现在就主要来看下 `RuntimeException`。 `RuntimeException` 从名字来看就是\n运行异常,所谓运行异常就是可能在程序运行过程中发生的异常,这种异常一般是可以通过代码逻辑进行处理的。\n我们举例一个例子,我们都知道0不能作为除数。但是假如在下面这个代码中\n\n```\npublic class Tester {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        System.out.print(\"请输入被除数a:\");\n        int a = sc.nextInt();\n        System.out.print(\"请输入除数b:\");\n        int b = sc.nextInt();\n        System.out.println(\"a/b=\" + a / b);\n    }\n}\n```\n\n当输入a=8,b=2,那么结果就是4。\n\n![](https://i02piccdn.sogoucdn.com/8206a4441e0386c3)\n\n\n**假如我们输入b=0呢?**\n\n学过数学都知道0不能做除数,程序也不运行你这么输入,但是却不能阻止你,只能通过报错的方式来告诉你。\n\n\n![](https://img.springlearn.cn/blog/learn_1589298143000.png)\n\n那么我们就要对这个异常进行处理,当发现有这个异常就在控制台来提醒用户。那么代码就会变成这样\n\n```\npublic class Tester {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        System.out.print(\"请输入被除数a:\");\n        int a = sc.nextInt();\n        System.out.print(\"请输入除数b:\");\n        int b = sc.nextInt();\n        try {\n            System.out.println(\"a/b=\" + a / b);\n        } catch (ArithmeticException ate) {\n            //对算术异常进行捕捉\n            System.err.println(\"0不能作为除数,请输入不为0的任意数\");\n        }\n    }\n}\n\n```\n当出现算术异常直接提示: \"0不能作为除数,请输入不为0的任意数\"\n![](https://img.springlearn.cn/blog/learn_1589298261000.png)\n\n那么像这种程序中无可避免会出现,且又能通过逻辑来处理的异常就是运行异常。运行异常一般都可以正常运行,只是在特定情况下会导致异常发生。\n像这面这个例子,我们只要看到 `ArithmeticException` 就知道是算术异常。所以只要我们对运行异常类有一个认识，其实就能解决大多数的程序问题了。\n下面我们来看下运行异常都要有哪些类把。\n\n![](https://i03piccdn.sogoucdn.com/f960e6a461d218d2)\n\n\n**只要对下面运行异常类进行熟悉了,基本就清楚掌握了Java的异常体系了**\n\n![](https://img.springlearn.cn/blog/learn_1589299119000.png)\n\n![](https://img.springlearn.cn/blog/learn_1589299523000.png)\n\n以上就是常见的运行异常类,当然Java中还有很多不常见的异常类。剩下的我们就可以在日常工作中去学习了。\n\n\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/java2/Java异常体系.md b/docs/learn/java2/Java异常体系.md
--- a/docs/learn/java2/Java异常体系.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/java2/Java异常体系.md	(date 1655373430519)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/java2/函数式编程.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 函数式编程\n---\n\n::: tip\n Java8所有的新特性基本基于函数式编程的思想，函数式编程给Java带来了注入了新鲜的活力。\n 函数式编程其实并不是很难，小编在学习函数式编程时候刚开始一头雾水，最后仔细观察就发现了其中的小窍门，读了本篇文章如果还没有掌握，就算我输了\n 加我微信: lxchinesszz 找我一对一教学\n:::\n\n# 函数式编程\n\n\n\n## 一、Lambda表达式\n\n**注意**: 以下方法都可以使用表达式来进行缩写\n\n我们来看Java中如何来定义一个方法\n\n### 1. 语法\n\n`()->{}`\n\n其中小括号里面可以放入参，大括号就是方法体，里面也允许有返回值。\n\n**当方法体中只有返回值而没有其他语句时候，大括号和 `return` 关键字都可以省略不写。**\n\n\n### 2. 方法引用\n\n*只要用.引用不报错的，都可以将.换成:*\n\n| 类型                      | 语法                           |\n| ------------------------- | ------------------------------ |\n| 1、引用静态方法           | ClassName::staticMethodName    |\n| 2、引用构造函数           | ClassName::new                 |\n| 3、引用特定类型的实例方法 | ClassName::instanceMethodName  |\n| 4、引用特定对象的实例方法 | objectName::instanceMethodName |\n\n\n## 二、Java8新增函数式接口\n\n### 1. Predicate接口\n\nPredicate 接口只有一个参数，返回boolean类型。该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）\n\n```\nPredicate<String> predicate = (s) -> s.length() > 0;\n```\n根据前面的语法我们知道小括号里面可以放入参，大括号里面放出参，当大括号里面只有返回值时候，大括号和 `return` 关键字也可以省略。如上。\n### 2. Function 接口\n\nFunction 接口有一个参数并且返回一个结果，并附带了一些可以和其他函数组合的默认方法（compose, andThen）：\n\n```\nFunction<Integer, Integer> function = (x) -> 2 * x;\n```\n同理，这个接口有一个入参和出参，如果返回体重不包含其他逻辑，只有一个返回值，大括号和 `return` 关键字也可以省略。如上。\n\n### 3. Supplier 接口\n\nSupplier 接口返回一个任意范型的值，和Function接口不同的是该接口没有任何参数\n\n```\npublic class Main{\n    public static void main(String[] args) {\n        //构造方法\n        Supplier<Main> supplier = () -> new Main();\n        Supplier<Main> mainSupplier = Main::new;\n        Supplier<Main> mainSupplier1 = Main::staticMethod;\n    }\n    private static Main staticMethod() {\n        return new Main();\n    }\n}\n```\n\n因为没有入参，所以小括号里面什么都不用写。当遇到这种情况，同样可以用上面其他两种来替换\n\n### 4. Consumer 接口\n\nConsumer 是一个只有入参，但是无出参的接口。\n\n```\npublic class Main {\n    public static void main(String[] args) {\n        List<String> dataList = Arrays.asList(\"1\", \"2\");\n\n        //特定类的静态方法\n        dataList.forEach(Main::staticMethod);\n        dataList.forEach((x) -> System.out.println(x));\n        dataList.forEach(System.out::println);\n\n    }\n    private static void staticMethod(String name) {\n        System.out.println(\"对象静态方法引用:\" + name);\n    }\n}\n```\n\n## 三、快速记忆\n\n虽然新增的函数式接口并不多，但是想要一次性死记住，还是有一点点的难度。小编的学习方式是\n理解这记忆。\n\n| 类型         | 简记           |\n| ------------ | -------------- |\n| 1、Predicate | 条件类型       |\n| 2、Supplier  | 无入参，有出参 |\n| 3、Function  | 有入参，有出参 |\n| 4、Consumer  | 有入参，无出参 |\n\n\n最后求关注,求订阅,谢谢你的阅读!\n\n\n![](https://img.springlearn.cn/blog/learn_1589360371000.png)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/java2/函数式编程.md b/docs/learn/java2/函数式编程.md
--- a/docs/learn/java2/函数式编程.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/java2/函数式编程.md	(date 1655373430244)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/mybatis/AuthPlugin.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: true\nfooter: true\npassword: 111\nbacktotop: true\ntitle: 第11篇:Mybatis权限插件设计\ncategory: Mybatis\n---\n<PageBanner/>\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/mybatis/AuthPlugin.md b/docs/learn/mybatis/AuthPlugin.md
--- a/docs/learn/mybatis/AuthPlugin.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/mybatis/AuthPlugin.md	(date 1655373430477)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/maven/maven-surefire-plugin.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: auto\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: maven-surefire-plugin\ncategory: Maven\n---\n\n> maven-surefire-plugin Surefire 插件在test构建生命周期阶段用于执行应用程序的单元测试。\n\n![](https://maven.apache.org/images/maventxt_logo_200.gif)\n\n[maven-surefire-plugin官网](https://maven.apache.org/surefire/maven-surefire-plugin/index.html)\n\n\n## 一、介绍\n\n如果你执行过mvn test或者执行其他maven命令时跑了测试用例，你就已经用过maven-surefire-plugin了。\nmaven-surefire-plugin是maven里执行测试用例的插件，不显示配置就会用默认配置。\n这个插件的surefire:test命令会默认绑定maven执行的test阶段。\n\n如果你自己声明了，那么可以指定自己的版本，并且可以配置自定义的参数。\n\n## 二、实践\n\n### 2.1 用法\n\n```\n <build>\n    <pluginManagement>\n      <plugins>\n        <plugin>\n          <groupId>org.apache.maven.plugins</groupId>\n          <artifactId>maven-surefire-plugin</artifactId>\n          <version>3.0.0-M5</version>\n        </plugin>\n      </plugins>\n    </pluginManagement>\n  </build>\n```\n\n### 2.2 使用方法\n\n`mvn test`\n\n## 三、源码分析\n\n### 3.1 学习目标\n\n::: info\n框架整体比较复杂，但是对于我们有学习价值的东西不多，我们没必要太深入研究。在此只提几个关键的知识点学习。\n:::\n\n1. maven-surefire-plugin的常用参数及作用\n2. maven-surefire-plugin实现单测的原理\n\n### 3.2 学习搭建环境\n\n```xml\n    <!-- 先声明插件版本 -->\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-surefire-plugin</artifactId>\n                <!-- JUnit 5 requires Surefire version 2.22.0 or higher -->\n                <version>2.22.0</version>\n            </plugin>\n        </plugins>\n    </build>\n    <!-- 然后引入依赖,方便debug跟进源码-->\n      <dependency>\n          <groupId>junit</groupId>\n          <artifactId>junit</artifactId>\n          <version>4.13.2</version>\n          <scope>test</scope>\n      </dependency>\n      <dependency>\n          <groupId>org.apache.maven.plugins</groupId>\n          <artifactId>maven-surefire-plugin</artifactId>\n          <version>3.0.0-M5</version>\n      </dependency>\n\n      <dependency>\n          <groupId>org.apache.maven</groupId>\n          <artifactId>maven-core</artifactId>\n          <version>3.8.4</version>\n      </dependency>\n\n      <dependency>\n          <groupId>org.apache.maven.surefire</groupId>\n          <artifactId>surefire-junit4</artifactId>\n          <version>3.0.0-M5</version>\n      </dependency>\n\n      <dependency>\n          <groupId>org.apache.maven</groupId>\n          <artifactId>maven-plugin-api</artifactId>\n          <version>${dep.maven-api.version}</version>\n      </dependency>\n      <dependency>\n          <groupId>org.apache.maven</groupId>\n          <artifactId>maven-model</artifactId>\n          <version>${dep.maven-api.version}</version>\n      </dependency>\n      <dependency>\n          <groupId>org.apache.maven.plugin-tools</groupId>\n          <artifactId>maven-plugin-annotations</artifactId>\n          <version>${dep.maven-api.version}</version>\n      </dependency>\n      <dependency>\n          <groupId>org.apache.maven.plugins</groupId>\n          <artifactId>maven-plugin-plugin</artifactId>\n          <version>${dep.maven-api.version}</version>\n      </dependency>\n```\n\n### 3.3 找到插件入口\n\n![](https://img.springlearn.cn/blog/learn_1645113430000.png)\n\n前面通过学习知道Mojo是运行的核心类,而SurefirePlugin就是Mojo的子类。\n由此可知,如果要学习这个 `maven-surefire-plugin`，入口就是在SurefirePlugin类。\n\n\n![](https://img.springlearn.cn/blog/learn_1644857307000.png)\n\n\n![](https://img.springlearn.cn/blog/learn_1645114616000.png)\n\n\n## 四、 带着问题来学习\n\n\n### 4.1 常用的参数都有那些\n\n大多数为不常用的\n\n|是否常用|参数名|使用方法|解释|\n|:---|:---|:---:|:---:|\n|常用|skipTests|-D,或者xml配置标签|用于跳过单测|\n|常用|maven.test.skip.exec|-D,或者xml配置标签|用于跳过单测|\n|常用|maven.test.skip|-D,或者xml配置标签|用于跳过单测|\n|不常用|testClassesDirectory|xml配置标签|指定测试模块目录编译后目录|\n|不常用|maven.test.dependency.excludes|-D,或者xml配置标签|要排除的依赖,格式:groupId:artifactId|\n|不常用|maven.test.additionalClasspath|-D,或者xml配置标签|追加classpath|\n|不常用|project.build.testSourceDirectory|xml配置标签|指定测试模块目录源码目录|\n|不常用|excludes|xml配置|指定规则的类不需要被单测，eg: **/*Test.java|\n|不常用|surefire.reportNameSuffix|-D,或者xml配置标签|test报表后缀|\n|不常用|maven.test.redirectTestOutputToFile|-D,或者xml配置标签|运行的单侧输出重定向到report目录中|\n|不常用|failIfNoTests|-D,或者xml配置标签|如果没有单测就报错|\n|不常用|forkMode|-D,或者xml配置标签|运行模式|\n|不常用|jvm|-D,或者xml配置标签|指定jvm目录,如果不指定会读取系统|\n|不常用|argLine|-D,或者xml配置标签|Jvm运行参数|\n|不常用|threadCount|-D,或者xml配置标签|线程数|\n|不常用|forkCount|-D,或者xml配置标签|指定启用多少个vm,1.5C 以数字结尾,数字乘以cpu核心数|\n|不常用|reuseForks|-D,或者xml配置标签|是否可重新使用forks进程|\n|不常用|disableXmlReport|-D,或者xml配置标签|禁用xml报告|\n|不常用|enableassertions|-D,或者xml配置标签|启用断言assert语句|\n\n\n\n**forkMode 可设置值有 “never”， “once”， “always” 和 “pertest”。**\n\n- pretest： 每一个测试创建一个新进程，为每个测试创建新的JVM是单独测试的最彻底方式，但也是最慢的，不适合hudson上持续回归。\n- once：在一个进程中进行所有测试。once为默认设置，在Hudson上持续回归时建议使用默认设置。\n- always：在一个进程中并行的运行脚本，Junit4.7以上版本才可以使用，surefire的版本要在2.6以上提供这个功能，\n\n\n### 4.2 知识点\n\n``` \n// 大于等于2.0.0，小于2.1.2\nVersionRange range = VersionRange.createFromVersionSpec(\"[2.0.0,2.1.2)\");\nSystem.out.println(range.containsVersion(new DefaultArtifactVersion(\"1.0\")));\nSystem.out.println(range.containsVersion(new DefaultArtifactVersion(\"2.0.0\")));\nSystem.out.println(range.containsVersion(new DefaultArtifactVersion(\"2.1.1\")));\nSystem.out.println(range.containsVersion(new DefaultArtifactVersion(\"2.1.2\")));\nSystem.out.println(\"------------\");\nVersionRange range2 = VersionRange.createFromVersionSpec(\"[2.0.0-M1SN,2.1.2)\");\nSystem.out.println(range2.containsVersion(new DefaultArtifactVersion(\"2.1.1-M2\")));\n```\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/maven/maven-surefire-plugin.md b/docs/learn/maven/maven-surefire-plugin.md
--- a/docs/learn/maven/maven-surefire-plugin.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/maven/maven-surefire-plugin.md	(date 1655373430306)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: auto
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/mybatis/插件分析.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: true\nfooter: true\npassword: 111\nbacktotop: true\ntitle: 第08篇:Mybatis的插件设计分析\ncategory: Mybatis\n---\n\n<PageBanner/>\n\n\n参考文档: [官方文档](https://mybatis.org/mybatis-3/zh/configuration.html#plugins)\n\n## 一、 插件设计介绍\n\nMybatis 中的插件都是通过代理方式来实现的,通过拦截执行器中指定的方法来达到改变核心执行代码的方式。举一个列子,查询方法核心都是通过 Executor来进行sql执行的。那么我们就可以通过拦截下面的方法来改变核心代码。基本原理就是这样,下面我们在来看 Mybatis 是如何处理插件。\n\n```java \npublic interface Executor {\n\n  ResultHandler NO_RESULT_HANDLER = null;\n\n  int update(MappedStatement ms, Object parameter) throws SQLException;\n\n  <E> List<E> query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey cacheKey, BoundSql boundSql) throws SQLException;\n\n  <E> List<E> query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException;\n\n  <E> Cursor<E> queryCursor(MappedStatement ms, Object parameter, RowBounds rowBounds) throws SQLException;\n  ...\n}\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20191224102308710.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70)\n\n| 名称                | 类型 | 描述                                            |\n| ------------------- | ---- | ----------------------------------------------- |\n| `Interceptor`       | 接口 | 插件都需要实现的接口,封装代理执行方法及参数信息 |\n| `InterceptorChain`  | 类   | 拦截链                                          |\n| `InvocationHandler` | 接口 | JDK代理的接口,凡是JDK中的代理都要实现该接口     |\n| `@Intercepts`       | 注解 | 用于声明要代理和 `@Signature` 配合使用          |\n| `@Signature`        | 注解 | 用于声明要代理拦截的方法                        |\n| `Plugin`            | 类   | 代理的具体生成类                                |\n\n## 1.1 Interceptor\n\n插件都需要实现的接口,封装代理执行方法及参数信息\n\n```java\npublic interface Interceptor {\n    // 执行方法体的封装,所有的拦截方法逻辑都在这里面写。\n  Object intercept(Invocation invocation) throws Throwable;\n    // 如果要代理,就用Plugin.wrap(...),如果不代理就原样返回\n  Object plugin(Object target);\n    // 可以添加配置,主要是xml配置时候可以从xml中读取配置信息到拦截器里面自己解析\n  void setProperties(Properties properties);\n}\n```\n\n## 1.2 InterceptorChain\n\n拦截链,为什么需要拦截链,假如我们要对A进行代理, 具体的代理类有B和C。 我们要同时将B和C的逻辑都放到代理类里面，那我们会首先将A和B生成代理类,然后在前面生成代理的基础上将C和前面生成的代理类在生成一个代理对象。这个类就是要做这件事 `pluginAll`\n\n```java\npublic class InterceptorChain {\n\n  private final List<Interceptor> interceptors = new ArrayList<Interceptor>();\n  \n  // 这里target就是A,而List中的Interceptor就相当于B和C,通过循环方式生成统一代理类\n  public Object pluginAll(Object target) {\n    for (Interceptor interceptor : interceptors) {\n      //1. 是否需要代理,需要代理生成代理类放回,不需要原样返回。通过for循环的方式将所有对应的插件整合成一个代理对象\n      target = interceptor.plugin(target);\n    }\n    return target;\n  }\n  ...\n}\n```\n\n\n\n## 1.3 InvocationHandler\n\nJDK代理的接口,凡是JDK中的代理都要实现该接口。这个比较基础，如果这个不清楚,那么代理就看不懂了。所以就不说了。\n\n```java\npublic interface InvocationHandler {\n      public Object invoke(Object proxy, Method method, Object[] args)\n        throws Throwable;\n}\n```\n\n\n\n## 1.4 `@Intercepts` 和 `@Signature`\n\n这两个注解是配合使用的,用于指定要代理的类和方法。前面①说了,插件的核心逻辑是拦截执行器的方法,那么这里我们看下如何声明要拦截的类和方法。我们看一下分页插件如何声明拦截。\n\n\n| 属性     | 解释                                                   |\n|--------|------------------------------------------------------|\n| type   | 就是要拦截的类(Executor/ParameterHandler/ResultSetHandler/StatementHandler) |\n| method | 要拦截的方法                                               |\n| args   | 要拦截的方法的参数(因为有相同的方法,所以要指定拦截的方法和方法参数)                  |\n\n```java\n@Intercepts(@Signature(type = Executor.class, method = \"query\", args = { MappedStatement.class, Object.class,\n        RowBounds.class, ResultHandler.class }))\npublic class MybatisPagerPlugin implements Interceptor {\n}\n```\n\n`args` 要拦截的方法的入参(因为有相同的方法,所以要指定拦截的方法和方法参数)，比如 `Executor` 中就有2个 `query` 方法。所以要通过args来确定要拦截哪一个。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20191224111008677.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70)\n\n\n## 1.5 Plugin\n\n代理的具体生成类,解析 `@Intercepts` 和 `@Signature`  注解生成代理。\n\n我们看几个重要的方法。\n\n| 方法名           | 处理逻辑                                     |\n| ---------------- | -------------------------------------------- |\n| getSignatureMap  | 解析@Intercepts和@Signature,找到要拦截的方法 |\n| getAllInterfaces | 找到代理类的接口,jdk代理必须要有接口         |\n| invoke           | 是否需要拦截判断                             |\n\n\n\n```java\npublic class Plugin implements InvocationHandler {\n  \n  //解析@Intercepts和@Signature找到要拦截的方法\n  private static Map<Class<?>, Set<Method>> getSignatureMap(Interceptor interceptor) {\n    Intercepts interceptsAnnotation = interceptor.getClass().getAnnotation(Intercepts.class);\n    // issue #251\n    if (interceptsAnnotation == null) {\n      throw new PluginException(\"No @Intercepts annotation was found in interceptor \" + interceptor.getClass().getName());      \n    }\n    Signature[] sigs = interceptsAnnotation.value();\n    Map<Class<?>, Set<Method>> signatureMap = new HashMap<Class<?>, Set<Method>>();\n    for (Signature sig : sigs) {\n      Set<Method> methods = signatureMap.get(sig.type());\n      if (methods == null) {\n        methods = new HashSet<Method>();\n        signatureMap.put(sig.type(), methods);\n      }\n      try {\n        //通过方法名和方法参数查找方法\n        Method method = sig.type().getMethod(sig.method(), sig.args());\n        methods.add(method);\n      } catch (NoSuchMethodException e) {\n        throw new PluginException(\"Could not find method on \" + sig.type() + \" named \" + sig.method() + \". Cause: \" + e, e);\n      }\n    }\n    return signatureMap;\n  }\n  \n  //因为是jdk代理所以必须要有接口,如果没有接口,就不会生成代理\n  private static Class<?>[] getAllInterfaces(Class<?> type, Map<Class<?>, Set<Method>> signatureMap) {\n    Set<Class<?>> interfaces = new HashSet<Class<?>>();\n    while (type != null) {\n      for (Class<?> c : type.getInterfaces()) {\n        if (signatureMap.containsKey(c)) {\n          interfaces.add(c);\n        }\n      }\n      type = type.getSuperclass();\n    }\n    return interfaces.toArray(new Class<?>[interfaces.size()]);\n  }\n  \n  @Override\n  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n    try {\n      //执行时候看当前执行的方法是否需要被拦截,如果需要就调用拦截器中的方法\n      Set<Method> methods = signatureMap.get(method.getDeclaringClass());\n      if (methods != null && methods.contains(method)) {\n        return interceptor.intercept(new Invocation(target, method, args));\n      }\n      return method.invoke(target, args);\n    } catch (Exception e) {\n      throw ExceptionUtil.unwrapThrowable(e);\n    }\n  }\n}\n```\n\n## 二、问题总结\n\n## 2.1 插件能拦截那些类?\n\n前面已经说过了，这里在总结下。这部分的源码在 `Configuration`。可以看到很简单只有一行。`InterceptorChain#pluginAll`\n\n```java \n  public ParameterHandler newParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql) {\n    ParameterHandler parameterHandler = mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);\n    parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler);\n    return parameterHandler;\n  }\n\n  public ResultSetHandler newResultSetHandler(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler,\n      ResultHandler resultHandler, BoundSql boundSql) {\n    ResultSetHandler resultSetHandler = new DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds);\n    resultSetHandler = (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);\n    return resultSetHandler;\n  }\n\n  public StatementHandler newStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) {\n    StatementHandler statementHandler = new RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);\n    statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);\n    return statementHandler;\n  }\n  \n  public Executor newExecutor(Transaction transaction, ExecutorType executorType) {\n    executorType = executorType == null ? defaultExecutorType : executorType;\n    executorType = executorType == null ? ExecutorType.SIMPLE : executorType;\n    Executor executor;\n    if (ExecutorType.BATCH == executorType) {\n      executor = new BatchExecutor(this, transaction);\n    } else if (ExecutorType.REUSE == executorType) {\n      executor = new ReuseExecutor(this, transaction);\n    } else {\n      executor = new SimpleExecutor(this, transaction);\n    }\n    if (cacheEnabled) {\n      executor = new CachingExecutor(executor);\n    }\n    executor = (Executor) interceptorChain.pluginAll(executor);\n    return executor;\n  }\n```\n\n### 2.1.1 ParameterHandler\n\nParameterHandler的核心方法是setParameters()方法，该方法主要负责调用PreparedStatement的set*()方法为SQL语句绑定实参:\n这里能做到的扩展不多。\n\n```java \npublic interface ParameterHandler {\n  // 对方法的入参进行处理,注意只有在 statementType=\"CALLABLE\" 生效\n  Object getParameterObject();\n  // 预处理参数处理\n  void setParameters(PreparedStatement ps) throws SQLException;\n}\n```\n\n我们来实现一下,我们插入user信息,通过插件的方式修改入参。\n\n```java \n    /**\n     * 注意getParameterObject只会在 statementType=\"CALLABLE\"生效\n     * insert into T_USER (token_id, uid, name)\n     * values (#{tokenId,jdbcType=CHAR}, #{uid,jdbcType=INTEGER}, #{name,jdbcType=CHAR})\n     */\n    @Intercepts(@Signature(type = ParameterHandler.class, method = \"setParameters\", args = {PreparedStatement.class}))\n    public static class ParameterInterceptor implements Interceptor {\n        @Override\n        public Object intercept(Invocation invocation) throws Throwable {\n            Object proceed = invocation.proceed();\n            PreparedStatement preparedStatement = (PreparedStatement) invocation.getArgs()[0];\n            // 插入时候修改第三个参数,也就是name = 孙悟空\n            int parameterCount = preparedStatement.getParameterMetaData().getParameterCount();\n            if (parameterCount != 0) {\n                preparedStatement.setString(3, \"孙悟空\");\n            }\n            return proceed;\n        }\n    }\n\n    @Test\n    public void parameterHandler() {\n        // 读取配置信息(为什么路径前不用加/,因为是相对路径。maven编译后的资源文件和class文件都是在一个包下,所以不用加/就是当前包目录)\n        InputStream mapperInputStream = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"mybatisConfig.xml\");\n        // 生成SqlSession工厂,SqlSession从名字上看就是,跟数据库交互的会话信息,负责将sql提交到数据库进行执行\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(mapperInputStream, \"development\");\n        // 获取Mybatis配置信息\n        Configuration configuration = sqlSessionFactory.getConfiguration();\n        configuration.addInterceptor(new ParameterInterceptor());\n        // 参数: autoCommit,从名字上看就是是否自动提交事务\n        SqlSession sqlSession = sqlSessionFactory.openSession(false);\n        // 获取Mapper\n        TUserMapper mapper = configuration.getMapperRegistry().getMapper(TUserMapper.class, sqlSession);\n        TUser tUser = new TUser();\n        tUser.setName(\"唐三藏\");\n        tUser.setTokenId(\"testTokenId1\");\n        mapper.insert(tUser);\n        // 这里虽然设置的名字是唐三藏，但是插件中修改为了孙悟空\n        System.out.println(mapper.selectAll());\n        // 数据插入后，执行查询，然后回滚数据\n        sqlSession.rollback();\n    }\n```\n\n\n\n### 2.1.2 ResultSetHandler\n\n从名字就可以看出来是对结果集进行处理。这里我们通过插件的方式, 在查询语句中增加一条数据库原本不存在的数据。\n\n```java \n    /**\n     * 通过对list集合的数据进行修改,增加一条数据库不存在的数据\n     */\n    @Intercepts(@Signature(type = ResultSetHandler.class, method = \"handleResultSets\", args = {Statement.class}))\n    public static class ResultSetHandlerInterceptor implements Interceptor {\n        @Override\n        public Object intercept(Invocation invocation) throws Throwable {\n            Object proceed = invocation.proceed();\n            if (proceed instanceof List) {\n                ArrayList<TUser> newResult = (ArrayList<TUser>) proceed;\n                TUser tUser = new TUser();\n                tUser.setName(\"如来佛祖\");\n                newResult.add(tUser);\n                proceed = newResult;\n            }\n            return proceed;\n        }\n    }\n\n    @Test\n    public void resultSetHandlerTest() {\n        // 读取配置信息(为什么路径前不用加/,因为是相对路径。maven编译后的资源文件和class文件都是在一个包下,所以不用加/就是当前包目录)\n        InputStream mapperInputStream = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"mybatisConfig.xml\");\n        // 生成SqlSession工厂,SqlSession从名字上看就是,跟数据库交互的会话信息,负责将sql提交到数据库进行执行\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(mapperInputStream, \"development\");\n        // 获取Mybatis配置信息\n        Configuration configuration = sqlSessionFactory.getConfiguration();\n        configuration.addInterceptor(new ResultSetHandlerInterceptor());\n        // 参数: autoCommit,从名字上看就是是否自动提交事务\n        SqlSession sqlSession = sqlSessionFactory.openSession(false);\n        // 获取Mapper\n        TUserMapper mapper = configuration.getMapperRegistry().getMapper(TUserMapper.class, sqlSession);\n        System.out.println(mapper.selectAll());\n        // 数据插入后，执行查询，然后回滚数据\n        sqlSession.rollback();\n    }\n```\n\n### 2.1.3 StatementHandler\n\n\n```java \n    /**\n     * 我们本来是一条查询语句，我们打印下sql信息\n     */\n    @Intercepts(@Signature(type = StatementHandler.class, method = \"query\", args = {Statement.class, ResultHandler.class}))\n    public static class StatementHandlerInterceptor implements Interceptor {\n\n        @Override\n        public Object intercept(Invocation invocation) throws Throwable {\n            Object proceed = invocation.proceed();\n            Object[] args = invocation.getArgs();\n            if (args[0] instanceof ClientPreparedStatement) {\n                ClientPreparedStatement statement = (ClientPreparedStatement) args[0];\n                if (statement.getQuery() instanceof ClientPreparedQuery) {\n                    System.out.println(((ClientPreparedQuery) statement.getQuery()).getOriginalSql());\n                }\n            }\n            return proceed;\n        }\n    }\n\n    @Test\n    public void resultSetHandlerTest() {\n        // 读取配置信息(为什么路径前不用加/,因为是相对路径。maven编译后的资源文件和class文件都是在一个包下,所以不用加/就是当前包目录)\n        InputStream mapperInputStream = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"mybatisConfig.xml\");\n        // 生成SqlSession工厂,SqlSession从名字上看就是,跟数据库交互的会话信息,负责将sql提交到数据库进行执行\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(mapperInputStream, \"development\");\n        // 获取Mybatis配置信息\n        Configuration configuration = sqlSessionFactory.getConfiguration();\n        configuration.addInterceptor(new StatementHandlerInterceptor());\n        // 参数: autoCommit,从名字上看就是是否自动提交事务\n        SqlSession sqlSession = sqlSessionFactory.openSession(false);\n        // 获取Mapper\n        TUserMapper mapper = configuration.getMapperRegistry().getMapper(TUserMapper.class, sqlSession);\n        System.out.println(mapper.selectAll());\n        // 数据插入后，执行查询，然后回滚数据\n        sqlSession.rollback();\n    }\n```\n\n### 2.1.4 Executor\n\nExecutor 是个好东西，从他能获取基本你能想到的所有信息。你可以在这里做sql动态变更、也可以做sql语句分析，同时也可以获取某个Mapper的签名信息。总之功能非常强大。一般的插件都是\n在这里做文章。如下面例子就是动态的修改了sql。\n\n```java \n    /**\n     * 动态修改sql信息。\n     * 这里因为我们知道要使用查询语句,所以不做sql分析。如果要学习sql分析请看其他文章\n     */\n    @Intercepts(@Signature(type = Executor.class, method = \"query\",\n            args = {MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class}))\n    public static class ExecutorInterceptor implements Interceptor {\n        @Override\n        public Object intercept(Invocation invocation) throws Throwable {\n            Object[] args = invocation.getArgs();\n            if (args[0] instanceof MappedStatement) {\n                MappedStatement arg = (MappedStatement) args[0];\n                Configuration configuration = arg.getConfiguration();\n                StaticSqlSource staticSqlSource = new StaticSqlSource(configuration, \"select name from T_USER\");\n                Field sqlSourceField = arg.getClass().getDeclaredField(\"sqlSource\");\n                sqlSourceField.setAccessible(true);\n                sqlSourceField.set(arg, staticSqlSource);\n            }\n            return invocation.proceed();\n        }\n    }\n\n    @Test\n    public void executor() {\n        // 读取配置信息(为什么路径前不用加/,因为是相对路径。maven编译后的资源文件和class文件都是在一个包下,所以不用加/就是当前包目录)\n        InputStream mapperInputStream = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"mybatisConfig.xml\");\n        // 生成SqlSession工厂,SqlSession从名字上看就是,跟数据库交互的会话信息,负责将sql提交到数据库进行执行\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(mapperInputStream, \"development\");\n        // 获取Mybatis配置信息\n        Configuration configuration = sqlSessionFactory.getConfiguration();\n        configuration.addInterceptor(new ExecutorInterceptor());\n        // 参数: autoCommit,从名字上看就是是否自动提交事务\n        SqlSession sqlSession = sqlSessionFactory.openSession(false);\n        // 获取Mapper\n        TUserMapper mapper = configuration.getMapperRegistry().getMapper(TUserMapper.class, sqlSession);\n        System.out.println(mapper.selectAll());\n        // 数据插入后，执行查询，然后回滚数据\n        sqlSession.rollback();\n    }\n```\n\n## 2.2 如何定义一个拦截器?\n\n\n| 属性     | 解释                                                   |\n|--------|------------------------------------------------------|\n| type   | 就是要拦截的类(Executor/ParameterHandler/ResultSetHandler/StatementHandler) |\n| method | 要拦截的方法                                               |\n| args   | 要拦截的方法的参数(因为有相同的方法,所以要指定拦截的方法和方法参数)                  |\n\n```java \n    @Intercepts(@Signature(type = Executor.class, method = \"query\",\n            args = {MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class}))\n    public static class ExecutorInterceptor implements Interceptor {\n        @Override\n        public Object intercept(Invocation invocation) throws Throwable {\n            Object[] args = invocation.getArgs();\n            if (args[0] instanceof MappedStatement) {\n                MappedStatement arg = (MappedStatement) args[0];\n                Configuration configuration = arg.getConfiguration();\n                StaticSqlSource staticSqlSource = new StaticSqlSource(configuration, \"select name from T_USER\");\n                Field sqlSourceField = arg.getClass().getDeclaredField(\"sqlSource\");\n                sqlSourceField.setAccessible(true);\n                sqlSourceField.set(arg, staticSqlSource);\n            }\n            return invocation.proceed();\n        }\n    }\n```\n\n## 2.3 插件的设计缺陷\n\n`InterceptorChain` 的设计非常简单，里面就是一个list集合。但是在进行代理的时候，并没有顺序。假设我们要对sql进行代理。\n\n<Badge text=\"select * from users\" type=\"warn\"/>\n\n1. 第一个插件，我们在sql后加上 ` where id > 1`\n2. 第二个插件，我们在sql后机上 `limit 10`\n\n按照我们设想的最终sql会变成 `select * from users where id > 1 limit 10`\n\n但是我们知道mybatis是没有顺序的, 那么很可能会出现最终的sql变成 `select * from user limit 10 where id > 1`，此时就会报错。\n\n所以我们要注意这里。\n\n```java \n  public void addInterceptor(Interceptor interceptor) {\n    interceptorChain.addInterceptor(interceptor);\n  }\n  public StatementHandler newStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) {\n    StatementHandler statementHandler = new RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);\n    statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);\n    return statementHandler;\n  }\n```\n\n## 三、可以借鉴的知识点\n\n## 3.1 插件的设计模式\n\n拦截链 + 插件设计\n\n```java \npublic class Test {\n    public static void main(String[] args) {\n        InterceptorChain chain = new InterceptorChain();\n        PrintInterceptor printInterceptor = new PrintInterceptor();\n        Properties properties = new Properties();\n        properties.setProperty(\"name\",\"https://blog.springlearn.cn\");\n        printInterceptor.setProperties(properties);\n        chain.addInterceptor(printInterceptor);\n        Animal person = (Animal) chain.pluginAll(new Person());\n        String nihao = person.say(\"nihao\");\n        System.out.println(nihao);\n    }\n\n    public interface Animal{\n        String say(String message);\n        String say(String name, String message);\n    }\n\n    public static class Person implements Animal {\n        public String say(String message) {\n            return message;\n        }\n\n        public String say(String name, String message) {\n            return name + \" say: \" + message;\n        }\n    }\n\n    @Intercepts(@Signature(type = Animal.class, method = \"say\", args = {String.class}))\n    public static class PrintInterceptor implements Interceptor {\n        private String name;\n\n        @Override\n        public Object intercept(Invocation invocation) throws Throwable {\n            System.out.println(name + \": before print ...\");\n            Object proceed = invocation.proceed();\n            System.out.println(name + \": after print ...\");\n            return proceed;\n        }\n    }\n}\n\n```\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/mybatis/插件分析.md b/docs/learn/mybatis/插件分析.md
--- a/docs/learn/mybatis/插件分析.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/mybatis/插件分析.md	(date 1655373430450)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/maven/自定义maven插件.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: auto\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 自定义插件教程\npassword: 111\nicon: zuanshi\ncategory: Maven\n---\n\n> Maven插件官网: https://maven.apache.org/guides/plugin/guide-java-plugin-development.html\n\n::: info 前言介绍\n前面我们大概了解了Maven的生命周期,本篇主要是学习如何在Maven的生命周期内指定一些插件的执行。主要分为3个步骤。<br>\n <Badge text=\"1\" type=\"tip\" vertical=\"middle\"/> 第一个步骤先了解学习下Maven官方的命名规则建议。<br>\n <Badge text=\"2\" type=\"tip\" vertical=\"middle\"/> 第二个步骤根据命名规则,我们自定义一个插件 Mojo。<br>\n <Badge text=\"3\" type=\"tip\" vertical=\"middle\"/> 第三个部分学习如何向插件内 Mojo 注入一些，Maven的配置和自定义的配置信息。<br>\n:::\n\n\n## 一、命名规范\n\n- 官方的命名规则: `maven-<yourplugin>-plugin`（注意“Maven”位于插件名称的开头)\n- 个人自定义建议: `<yourplugin>-maven-plugin`（注意“Maven”位于插件名称的中间)\n\n个人不得使用官方命名规则,因为它是 Apache Maven 团队使用的插件保留命名模式。\n如果个人使用这种命名模式是会侵犯了 Apache Maven 商标。`org.apache.maven.plugins`\n\n\n## 二、自定义插件\n\n当我们使用idea创建一个maven插件,里面已经为我们创建了一个Mojo。定义Mojo首先要集成\n`AbstractMojo` 抽象类。另外要声明这个Mojo的名字和Maven执行阶段。有两种方法声明\n\n[mojo-api-specification](https://maven.apache.org/developers/mojo-api-specification.html)\n\n### 2.1 使用javadoc的方式声明\n\n因为maven诞生比较早,当时没有注解。所以使用了javadoc。\n\n[Maven Plugin Tool for Java Annotated with Mojo Javadoc Tags](https://maven.apache.org/plugin-tools/maven-plugin-tools-java/index.html)\n\n\n```java\n/**\n* Goal which touches a timestamp file.\n*\n* @goal touch\n* @phase process-sources\n*/\npublic class MyMojo extends AbstractMojo {\n\n    @Override\n    public void execute()\n    throws MojoExecutionException {\n    getLog().info(\"我是一个Maven插件: FirstDemo\");\n    }\n}\n```\n\n指定mvn install 安装到本地仓库,然后找个项目执行一下。\n\n```\n[INFO] Scanning for projects...\n[INFO]\n[INFO] ---------------------< org.example:nobug-learn-01 >---------------------\n[INFO] Building nobug-learn-01 1.0-SNAPSHOT\n[INFO] --------------------------------[ jar ]---------------------------------\n[INFO]\n[INFO] --- firstdemo-maven-plugin:1.0-SNAPSHOT:touch (default-cli) @ nobug-learn-01 ---\n[INFO] 我是一个Maven插件: FirstDemo\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time:  0.296 s\n[INFO] Finished at: 2021-11-26T17:00:32+08:00\n[INFO] ------------------------------------------------------------------------\n```\n\n### 2.2 使用注解的方式\n\n前面使用javadoc的形式来定义缺失有点显得过时了,现在我们可以使用注解的方式来定义插件。但是首先需要引入注解包\n下面这些依赖直接拷贝进去就行，注意如果你的maven版本太低，可能会识别不了注解。所以建议制定下构建插件的maven为\n3.5\n\n[Maven Plugin Tools Java5 Annotations](https://maven.apache.org/plugin-tools/maven-plugin-tools-annotations/index.html)\n\n使用 @Mojo 注解定义插件, Mojo中有一个非常重要的属性需要知道下。\n\n|属性值|说明|\n|:--:|:--:|\n|name|插件名称|\n|defaultPhase|绑定的声明周期|\n|requiresDependencyResolution|在插件运行之前就将所有的依赖模块给构建好|\n|requiresDependencyCollection|这个注解不会解析依赖项的文件,只分析依赖关系|\n\n建议requiresDependencyCollection是要指定的,不然你得到的maven插件中,是不会分析依赖关系的。\n\n\n==下面的依赖建议你直接拷贝使用==\n\n- 注意第一行一定不能忘记\n\n```xml {1} \n    <packaging>maven-plugin</packaging> \n    <properties>\n        <dep.maven-api.version>3.5.2</dep.maven-api.version>\n    </properties>\n    <dependencies>\n        <dependency>\n            <groupId>org.apache.maven</groupId>\n            <artifactId>maven-plugin-api</artifactId>\n            <version>${dep.maven-api.version}</version>\n        </dependency>\n        <dependency>\n            <groupId>org.apache.maven</groupId>\n            <artifactId>maven-model</artifactId>\n            <version>${dep.maven-api.version}</version>\n        </dependency>\n        <dependency>\n            <groupId>org.apache.maven.plugin-tools</groupId>\n            <artifactId>maven-plugin-annotations</artifactId>\n            <version>${dep.maven-api.version}</version>\n        </dependency>\n        <dependency>\n            <groupId>org.apache.maven.plugins</groupId>\n            <artifactId>maven-plugin-plugin</artifactId>\n            <version>3.5</version>\n        </dependency>\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>3.8.1</version>\n            <scope>test</scope>\n        </dependency>\n        <dependency>\n            <groupId>org.apache.maven</groupId>\n            <artifactId>maven-core</artifactId>\n            <version>3.8.5</version>\n        </dependency>\n    </dependencies>\n   <!--注意这一步也非常重要，否则如果你系统的maven版本太低，就可能无法识别maven的注解-->\n    <build>\n    <plugins>\n     <plugin>\n      <groupId>org.apache.maven.plugins</groupId>\n      <artifactId>maven-plugin-plugin</artifactId>\n      <version>3.5</version>\n     </plugin>\n    </plugins>\n    </build>\n```\n\nMojo类\n```java\n@Mojo(name = \"myMojo\", defaultPhase = LifecyclePhase.VALIDATE, threadSafe = true)\n@Execute(phase = LifecyclePhase.VALIDATE)\npublic class MyMojo\n        extends AbstractMojo {\n\n    public void execute()\n            throws MojoExecutionException {\n        getLog().info(\"我是一个Maven插件: FirstDemo\");\n    }\n}\n```\n\n注意: 自定义的maven插件是没办法直接就执行的，一定要在build中指定要执行的mojo。如下代码。\n\n```\n<plugin>\n    <groupId>org.example</groupId>\n    <artifactId>firstdemo-maven-plugin</artifactId>\n    <version>1.2-SNAPSHOT</version>\n    <executions>\n        <execution>\n        <!--                        如果插件中没有生命周期,这里要进行声明。如果插件中声明了就不用写这个-->\n         <phase>clean</phase>\n         <goals>\n         <!--                            自定义的插件,不会自动执行,要在这里进行声明-->\n            <goal>myMojo</goal>\n        </goals>\n        </execution>\n    </executions>\n</plugin>\n```\n\n\n\n\n\n## 三、参数注入\n\nmaven插件中是可以自定以参数的,通过配置然后传递到Mojo类中。 主要使用 `@Parameter` 注解完成，下面是详细介绍。\n\n\n\n主要使用`@Parameter`进行定义。\n\n| 字段         | 说明                       |\n| ------------ | -------------------------- |\n| name         | 声明参数的名字             |\n| alias        | 声明一个别名               |\n| property     | 从pom的propertys标签中读取,或是-Dtest=123 使用-D添加到命令行 |\n| defaultValue | 字段的默认值               |\n| required     | 是否必须                   |\n| readonly     | 是否只读                   |\n\n字段的类型可以是多样的。\n\n## 3.1 外部参数注入\n\n\n### 3.1.1 boolean类型\n\n这包括类型为 boolean 和 Boolean 的变量。 读取配置时，文本“true”会导致参数设置为 true，所有其他文本都会导致参数设置为 false。 例子：\n\n```\n    /**\n     * My boolean.\n     */\n    @Parameter\n    private boolean myBoolean;\n```\n\n`<myBoolean>true</myBoolean>`\n\n### 3.1.2 Integer类型\n\n这包括类型为 byte、Byte、int、Integer、long、Long、short 和 Short 的变量。 读取配置时，使用 Integer.parseInt() 或相应类的 valueOf() 方法将 XML 文件中的文本转换为整数值。 这意味着字符串必须是有效的十进制整数值，仅由数字 0 到 9 组成，前面有一个可选的 - 表示负值。 例子：\n\n```\n    /**\n     * My Integer.\n     */\n    @Parameter\n    private Integer myInteger;\n```\n\n`<myInteger>10</myInteger>`\n\n### 3.1.3 Double类型\n这包括类型为 double、Double、float 和 Float 的变量。 读取配置时，XML 文件中的文本使用相应类的 valueOf() 方法转换为二进制形式。\n```\n    /**\n     * My Double.\n     */\n    @Parameter\n    private Double myDouble;\n```\n\n`<myDouble>1.0</myDouble>`\n\n### 3.1.4 Date类型\n\n这包括类型为日期的变量。 读取配置时，XML 文件中的文本使用以下日期格式之一进行转换：“yyyy-MM-dd HH:mm:ss.S a”（示例日期为“2005-10-06 2:22 :55.1 PM”）或“yyyy-MM-dd HH:mm:ssa”（示例日期为“2005-10-06 2:22:55PM”）。 请注意，解析是使用 DateFormat.parse() 完成的，它允许对格式进行一些宽容。 如果该方法可以解析指定的日期和时间，即使它与上面的模式不完全匹配，它也会这样做。 例子：\n\n```\n    /**\n     * My Date.\n     */\n    @Parameter\n    private Date myDate;\n```\n\n`<myDate>2005-10-06 2:22:55.1 PM</myDate>`\n\n### 3.1.5 File类型\n这包括类型为 File 的变量。 读取配置时，XML 文件中的文本用作所需文件或目录的路径。 如果路径是相对的（不以 / 或 C: 之类的驱动器号开头），则该路径是相对于包含 POM 的目录。 例子：\n```\n    /**\n     * My File.\n     */\n    @Parameter\n    private File myFile;\n```\n\n`<myFile>c:\\temp</myFile>`\n\n### 3.1.6 URL\n\n这包括变量类型的 URL。 读取配置时，使用 XML 文件中的文本作为 URL。 格式必须遵循 RFC 2396 准则，并且看起来像任何 Web 浏览器 URL (scheme://host:port/path/to/file)。 转换 URL 时，对 URL 任何部分的内容都没有限制。\n\n```\n    /**\n     * My URL.\n     */\n    @Parameter\n    private URL myURL;\n```\n\n`<myURL>http://maven.apache.org</myURL>`\n\n### 3.1.7 枚举\n\n也可以使用枚举类型参数。 首先你需要定义你的枚举类型，然后你可以在参数定义中使用枚举类型：\n```\n    public enum Color {\n      GREEN,\n      RED,\n      BLUE\n    }\n\n    /**\n     * My Enum\n     */\n    @Parameter\n    private Color myColor;\n```\n\n`<myColor>GREEN</myColor>`\n\n### 3.1.8 Arrays\n\n```\n    /**\n     * My Array.\n     */\n    @Parameter\n    private String[] myArray;\n```\n\n```\n<myArray>\n  <param>value1</param>\n  <param>value2</param>\n</myArray>\n```\n\n### 3.1.9 Collections\n\n此类别涵盖任何实现 java.util.Collection 的类，例如 ArrayList 或 HashSet。 这些参数是通过多次指定参数来配置的，就像数组一样。 例子：\n\n```\n   /**\n     * My List.\n     */\n    @Parameter\n    private List myList;\n```\n\n```\n<myList>\n  <param>value1</param>\n  <param>value2</param>\n</myList>\n```\n\n### 3.1.10 Maps\n\n此类别涵盖任何实现 java.util.Map（例如 HashMap）但未实现 java.util.Properties 的类。 这些参数是通过在参数配置中以 <key>value</key> 形式包含 XML 标签来配置的。 例子：\n\n```\n    /**\n     * My Map.\n     */\n    @Parameter\n    private Map myMap;\n```\n\n```\n<myMap>\n  <key1>value1</key1>\n  <key2>value2</key2>\n</myMap>\n```\n\n### 3.1.11 Properties\n\n此类别涵盖实现 java.util.Properties 的任何地图。 这些参数是通过在参数配置中以 <property><name>myName</name> <value>myValue</value> </property> 形式包含 XML 标记来配置的。 例子：\n\n```\n    /**\n     * My Properties.\n     */\n    @Parameter\n    private Properties myProperties;\n```\n\n\n```\n<myProperties>\n  <property>\n    <name>propertyName1</name>\n    <value>propertyValue1</value>\n  <property>\n  <property>\n    <name>propertyName2</name>\n    <value>propertyValue2</value>\n  <property>\n</myProperties>\n```\n\n### 3.1.12 Object\n\n```\n    /**\n     * My Object.\n     */\n    @Parameter\n    private MyObject myObject;\n```\n\n```\n<myObject>\n  <myField>test</myField>\n</myObject>\n```\n\n\n## 3.2 Maven组件注入\n\n### 3.2.1 MavenSession\n\n包含Maven执行请求对象和结果,当前模块和总模块。和依赖模块信息等信息\n\n```\n    @Parameter(defaultValue = \"${session}\", readonly = true)\n    private MavenSession session;\n```\n\n### 3.2.2 MavenProject\n\n当前模块，及模块依赖\n\n```\n    @Parameter(defaultValue = \"${project}\", readonly = true)\n    private MavenProject project;\n```\n### 3.2.3 MojoExecution\n\n```\n    @Parameter(defaultValue = \"${mojoExecution}\", readonly = true)\n    private MojoExecution mojo;\n```\n\n### 3.2.4 PluginDescriptor\n\n```\n    @Parameter(defaultValue = \"${plugin}\", readonly = true)\n    private PluginDescriptor plugin;\n```\n\n### 3.2.5 Settings\n\n```\n    /**\n     * maven的配置信息\n     */\n    @Parameter(defaultValue = \"${settings}\", readonly = true)\n    private Settings settings;\n```\n\n\n### 3.2.6. 项目路径\n\n```\n    /**\n     * 项目路径\n     */\n    @Parameter(defaultValue = \"${project.basedir}\", readonly = true)\n    private File basedir;\n```\n\n### 3.2.7. 编译后目录\n\n```\n    /**\n     * 编译后目录\n     */\n    @Parameter(defaultValue = \"${project.build.directory}\", readonly = true)\n    private File target;\n```\n\n## 四、插件执行\n\n> 类似问题: https://www.coder.work/article/3592058\n\n::: danger 注意\n我们自己开发的插件,要想执行必须要在项目的pom文件中来指定,插件不会默认来进行执行的。如下。\n:::\n\n```\n<plugin>\n    <groupId>org.example</groupId>\n    <artifactId>firstdemo-maven-plugin</artifactId>\n    <version>1.2-SNAPSHOT</version>\n    <executions>\n        <execution>\n        <!--                        如果插件中没有生命周期,这里要进行声明。如果插件中声明了就不用写这个-->\n         <phase>clean</phase>\n         <goals>\n         <!--                            自定义的插件,不会自动执行,要在这里进行声明-->\n            <goal>myMojo</goal>\n        </goals>\n        </execution>\n    </executions>\n</plugin>\n```\n\n- [x] phase 如果插件中没有生命周期,这里要进行声明。如果插件中声明了就不用写这个\n- [x] goal  自定义的插件,不会自动执行,要在这里进行声明\n\n\n### 命令行执行\n\n- `mvn org.example:firstdemo-maven-plugin:1.4-SNAPSHOT:myMojo`\n\n- `mvn ${groupId}:${artifactId}:${version}:${mojoName}`\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/maven/自定义maven插件.md b/docs/learn/maven/自定义maven插件.md
--- a/docs/learn/maven/自定义maven插件.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/maven/自定义maven插件.md	(date 1655373430562)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: auto
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/maven/maven-resources-plugin.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: auto\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: maven-resources-plugin\ncategory: Maven\n---\n\n> maven-resources-plugin\n\n资源插件处理将项目资源复制到输出目录。有两种不同的资源：主要资源和测试资源。区别在于主要资源是与主要源代码相关联的资源，而测试资源与测试源代码相关联。\n\n因此，这允许主要源代码及其单元测试的资源分离。\n\n从 2.3 版开始，这个插件使用Maven Filtering共享组件来过滤资源。\n\n![](https://maven.apache.org/images/maventxt_logo_200.gif)\n\n[maven-resources-plugin官网](https://maven.apache.org/plugins/maven-resources-plugin/)\n\n\n## 主要功能\n\n- resources:resources\n将主源代码的资源复制到主输出目录。\n这个目标通常会自动执行，因为它默认绑定到流程资源生命周期阶段。它总是使用 project.build.resources 元素来指定资源，并且默认使用 project.build.outputDirectory 来指定复制目标。\n\n- resources:testResources\n将测试源代码的资源复制到测试输出目录。\n这个目标通常会自动执行，因为它默认绑定到 process-test-resources 生命周期阶段。它总是使用 project.build.testResources 元素来指定资源，并且默认使用 project.build.testOutputDirectory 来指定复制目标。\n\n- resources:copy-resources\n将资源复制到输出目录。此目标要求您配置要复制的资源，并指定 outputDirectory。\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/maven/maven-resources-plugin.md b/docs/learn/maven/maven-resources-plugin.md
--- a/docs/learn/maven/maven-resources-plugin.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/maven/maven-resources-plugin.md	(date 1655373430344)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: auto
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/maven/spring-boot-maven-plugin.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: auto\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: spring-boot-maven-plugin\ncategory: Maven\n---\n\n> spring-boot-maven-plugin\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/maven/spring-boot-maven-plugin.md b/docs/learn/maven/spring-boot-maven-plugin.md
--- a/docs/learn/maven/spring-boot-maven-plugin.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/maven/spring-boot-maven-plugin.md	(date 1655373430383)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: auto
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/other/bug.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: false\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 八阿哥的剑\n---\n\n**作者: 八阿哥的剑**\n\n*博客: https://springlearn.cn*\n\n::: tip 一日一句毒鸡汤\n问世间钱为何物，只叫人生死相许。！\uD83D\uDE04\n:::\n\n\n## Java原生版本监控\n\n```java\npublic class JavaWatchAPI {\n\n    public static void main(String[] args) throws Exception {\n        //第一步：取得WatchService\n        WatchService watchService = FileSystems.getDefault().newWatchService();\n        //第二步：确定要监控的路径\n        Path path = Paths.get(\"/Users/liuxin/Github/nobug-learn-project/nobug-learn-01/src/main/java\");\n\n        //第三步：为本路径绑定WatchService，并确定监控的事件\n        path.register(\n                watchService,\n                // StandardWatchEventKinds.ENTRY_CREATE—当有新文件时触发。可能是创建了一个新文件\n                StandardWatchEventKinds.ENTRY_CREATE,\n                // StandardWatchEventKinds.ENTRY_DELETE—当文件被删除、移动或重命名时触发\n                StandardWatchEventKinds.ENTRY_DELETE,\n                // StandardWatchEventKinds.ENTRY_MODIFY—当文件被修改时触发。\n                StandardWatchEventKinds.ENTRY_MODIFY);\n        // StandardWatchEventKinds.OVERFLOW—触发表示丢失或丢弃的事件。\n        WatchKey key = null;\n        while ((key = watchService.take()) != null) {\n            for (WatchEvent<?> event : key.pollEvents()) {\n                System.out.println(\"事件\" + event.kind() + \"发生了，文件是：\" + event.context());\n            }\n            key.reset();\n        }\n    }\n}\n\n```\n\n\n## Common IO 工具包监控\n\n\n```java\npackage cn.github.chinesszz;\n\nimport org.apache.commons.io.filefilter.FileFilterUtils;\nimport org.apache.commons.io.monitor.FileAlterationListener;\nimport org.apache.commons.io.monitor.FileAlterationMonitor;\nimport org.apache.commons.io.monitor.FileAlterationObserver;\nimport org.junit.Test;\n\nimport java.io.File;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * @author liuxin\n * 2021/11/9 8:55 下午\n */\npublic class CommonIOAPI {\n\n    public static void main(String[] args) throws Exception {\n        File directory = new File(\"/Users/liuxin/Github/nobug-learn-project/nobug-learn-01/src/main/java\");\n        // 轮询间隔 5 秒\n        long interval = TimeUnit.SECONDS.toMillis(5);\n        // 创建一个文件观察器用于处理文件的格式\n        FileAlterationObserver observer = new FileAlterationObserver(directory, FileFilterUtils.and(\n                FileFilterUtils.fileFileFilter(), FileFilterUtils.suffixFileFilter(\".txt\"),\n                FileFilterUtils.prefixFileFilter(\"lx\")));\n        // 设置文件变化监听器\n        observer.addListener(new MyFileListener());\n        FileAlterationMonitor monitor = new FileAlterationMonitor(interval, observer);\n        monitor.start();\n        System.out.println(1);\n    }\n\n    @Test\n    public void watchDir() throws Exception {\n        File directory = new File(\"/Users/liuxin/Github/nobug-learn-project/nobug-learn-01/src/main/java\");\n        FileAlterationObserver fileAlterationObserver = new FileAlterationObserver(directory, FileFilterUtils.and(\n                FileFilterUtils.directoryFileFilter()));\n        long interval = TimeUnit.SECONDS.toMillis(5);\n        // 设置文件变化监听器\n        fileAlterationObserver.addListener(new MyFileListener());\n        FileAlterationMonitor monitor = new FileAlterationMonitor(interval, fileAlterationObserver);\n        monitor.start();\n        while (true);\n    }\n\n    static final class MyFileListener implements FileAlterationListener {\n        @Override\n        public void onStart(FileAlterationObserver fileAlterationObserver) {\n            System.out.println(\"monitor start scan files..\");\n        }\n\n\n        @Override\n        public void onDirectoryCreate(File file) {\n            System.out.println(file.getName() + \" director created.\");\n        }\n\n\n        @Override\n        public void onDirectoryChange(File file) {\n            System.out.println(file.getName() + \" director changed.\");\n        }\n\n\n        @Override\n        public void onDirectoryDelete(File file) {\n            System.out.println(file.getName() + \" director deleted.\");\n        }\n\n\n        @Override\n        public void onFileCreate(File file) {\n            System.out.println(file.getName() + \" created.\");\n        }\n\n\n        @Override\n        public void onFileChange(File file) {\n            System.out.println(file.getName() + \" changed.\");\n        }\n\n\n        @Override\n        public void onFileDelete(File file) {\n            System.out.println(file.getName() + \" deleted.\");\n        }\n\n\n        @Override\n        public void onStop(FileAlterationObserver fileAlterationObserver) {\n            System.out.println(\"monitor stop scanning..\");\n        }\n    }\n}\n\n\n```\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/other/bug.md b/docs/learn/other/bug.md
--- a/docs/learn/other/bug.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/other/bug.md	(date 1655373430281)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: false
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/other/重剑无锋大巧不工.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: false\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 重剑无锋大巧不工\n---\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/other/重剑无锋大巧不工.md b/docs/learn/other/重剑无锋大巧不工.md
--- a/docs/learn/other/重剑无锋大巧不工.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/other/重剑无锋大巧不工.md	(date 1655373430385)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: false
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/other/如何学会复盘.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: false\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 如何学会复盘\nsidebarDepth: 3\n---\n\n\n[不懂复盘，再努力都是低水平重复](https://mp.weixin.qq.com/s/skP5pXvjsepvoOTMRmGEFw)\n\n## 一、复盘三角\n\n“复盘三角”，也就是记录、反思、提炼这三个动作。\n\n### 1.1 记录\n\n一天过完以后，把你当天或者过往一天的主要发生记录下来，遇到了什么人，谈了什么话，做了什么事，情绪怎么样……\n\n\n\n刚开始的时候，最好老老实实把一整天能记录的都记录下来，作为一种刻意练习，作为一种基本功的修炼。\n\n\n\n有很多人会怀疑，说记录会不会是在浪费时间，其背后的意思，实际上是想有一个取巧的办法，能不花时间也有反思的成果，我目前的看法是，别想多了，还是老老实实、扎硬寨打呆仗。\n\n\n\n为什么要如实记录？因为我们的大脑不一定靠谱，大脑自己会编造事实，事后就变成了“我以为”，实际上不是真相。记忆有时候是会骗人的。\n\n\n\n当我们有一些我们无法接受的情况发生时，如果我们很痛苦的话，大脑就倾向于抹掉那一部分或者掩盖、改写一部分，好让自己变得舒服一点。\n\n### 1.2 反思\n\n就某个点、某件事慢慢进行剖析，比如为什么有这种情绪？为什么不愉快，发生了什么？为什么发生？我的判断是什么？我为什么会有这种判断？这种判断是一时的还是一种固有的模式？怎么做，才能避免？\n\n### 1.3 提炼\n\n复盘到最后，提炼形成行动指南，用以指导自己的行动。\n\n\n\n提炼很简单，就是形成一句话，复盘到最后，你要找到一句话，用这句话作为你的行动指南，作为你的方法论，作为你的原则和价值观，然后再去践行出来。\n\n\n\n提炼也不简单，这句话要求有触发效应，能够在一个场景当中有效的指引自己，当你一想到这句话，就会让自己的行为有所改变。\n\n\n\n我们的行为处事要有一套指引体系，要有一套指南。我们要用这些东西去逐渐规范、干预、调整自己的行为，用这些东西去重塑一个不同的自己。\n\n\n\n这些指南、指引，实际上就是一些所谓的原则。史蒂芬·柯维的7个习惯就是7个原则，稻盛和夫的六项精进也是6个原则。\n\n\n\n但这些原则是史蒂芬·柯维、稻盛和夫的，不是你的，虽然你很认同，但是它不一定能指导你的实践，你需要转化成自己的，拥有自己的原则。\n\n就像达利欧在《原则》当中所指出的，“最重要的事情是总结出你自己的原则，最好将其写下来，尤其是在你与其他人共事的情况下。”\n\n\n\n提炼这个步骤就是直接指向原则，这一步就是为了生产我们工作和生活的原则的。提炼的标准最好是：自己的语言，够具体，一句话，记得住，用得上。\n\n\n## 二、好的复盘长什么样？\n\n### 2.1 好的复盘首先都是“过电影”\n\n所谓“过电影”，就是对过去发生的事情一幕幕进行回顾。一天结束以后，先把一天的主要经历过一遍，今天到底发生了什么，今天到底过得怎么样，需要做到心里有数，掌握一定的素材，搞清事实状况，然后才能梳理出个所以然。\n\n### 2.2 复自己的盘\n\n复盘需要指向自己，如果复盘来复盘去，找到的都是别人的问题，看到的都是别人的毛病，那就不叫复盘，那叫批评大会、抱怨大会、吐槽大会。\n\n\n\n所以还差一个东西，就是自我批评。有一个词叫反求诸己，这才是真正意义上的复盘。\n\n### 2.3 复盘给自己看\n\n当你写复盘的时候，不要想着写给别人看，本着这样的心态去写，自己面对自己。\n\n### 2.4 复盘自己的痛苦\n\n《原则》的作者达利欧有一个公式：痛苦+反思=进步。没有经历足够的痛苦，没有痛彻心扉，反思通常也会停留于表面，不会那么深刻。\n所以，当你经历痛苦的时候，最好把痛苦记录下来。当然，这种时候还不是反思的最佳时刻，因为你很难保持头脑清醒。最好是在痛苦之后，进行回顾和反思。\n\n### 2.5 好的复盘会指向并加速行动\n\n我们判断一个复盘好不好，不是看你的复盘的文字写得好不好，而是看复盘之后，你有没有采取相应的行动，有没有取得相应的成果。复盘不是目的，而是达成目的的一种手段。\n\n### 2.6 好的复盘需要不断质疑\n\n复盘也需要更多的质疑。质疑什么？质疑自己的基本假设，自己的判断标准。\n\n\n\n这一点是最难的，首先，你要能看到自己行为处事背后的原则和标准，其次，你要能够对这些原则和标准进行自我质疑。这不是一日之功，这才是复盘中最难突破的地方。\n\n\n## 三、复盘的三个标准\n\n### 3.1 能反观\n\n很多人在参加一项培训之后会要求自己进行复盘，但他们更多所做的动作其实叫复习，把学到的东西再过一遍，看看老师讲了什么、做了什么练习或者最触动自己的是什么。\n\n\n\n他们更多所做的是记忆或者说强化记忆的行为，从复盘的角度来看，只是完成了反观的一部分工作——反回头去看。\n\n不过，这还不彻底，还要去看看所学的内容如何和自己的工作相结合，如何去落地和应用，从而让自己的工作效率和成果有所改变。还要对照学习的内容，看自己有哪些优势和不足，找出差距，然后才能有机会弥补差距。\n\n\n\n这就是“能反观”。\n\n### 3.2 会反思\n\n“能反观”之外，还要做到“会反思”。根据史蒂芬·柯维的“观为得”模型，想法决定行为，行为决定结果。也就是所谓的“观”决定“为”，“为”决定“得”。\n\n\n\n反思就是从结果倒推，去看看我们当初到底都做了什么，有哪些行为，然后再去看我们所有行为背后的想法，为什么要这样去做，为什么有这些行为，原因是什么，背后的信念假设、思维模式是什么。\n\n``` \n比如家里来了客人，作为家长，你希望自己的女儿将玩具和客人的孩子分享，但是你的孩子的表现令你非常失望，她把玩具据为己有，一点也不愿意分享。你刚开始还好言相劝，慢慢变成了言语威胁，最后竟演变成了打骂，家里立刻变得乌烟瘴气。\n\n\n\n从结果倒推，家里气氛不好，发生了什么呢？原来是你打了孩子。你为什么要打孩子呢？因为她不愿意分享，你觉得非常没有礼貌。\n\n\n\n再去倒推“观”的层面，你会发现孩子不配合，让自己在客人面前失了面子。要把玩具跟别人分享，这是你的需求，不是孩子的需求。\n\n\n\n再倒推，你可能会发现自己很虚伪，孩子却很真实；你可能会发现，孩子只有先学会拥有，才能学会分享；你可能会发现，自己之前对待孩子的方式有问题，你让孩子养成了吃独食的习惯，没有学会分享；你可能会发现，自己一直也是这样，跟人交往不愿多付出，只是一味索取，所以孩子也不知道什么叫付出和分享，等等等等。\n\n\n\n最后你一定会在自己身上发现很多问题，这个过程，就是反思，我们用的是“得-为-观”倒推的方法。\n```\n\n### 3.3 有反省\n\n一般的复盘，最多到这里就截止了，实际上，更高层面的复盘，还要有反省。\n\n\n\n有了反省，自己反观、反思出来的问题，才能得到真正的解决，你的固有模式才有可能被调整，你的“木马程序”才有可能被清除。\n\n反省是从事上，回到心上，去看自己的起心动念，去除恶念、保持善念。\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/other/如何学会复盘.md b/docs/learn/other/如何学会复盘.md
--- a/docs/learn/other/如何学会复盘.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/other/如何学会复盘.md	(date 1655373430262)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: false
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/other/java-watch-file.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: false\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: Get新技能,Java实现文件监控\n---\n\n**作者: 八阿哥的剑**\n\n*博客: https://springlearn.cn*\n\n::: tip 一日一句毒鸡汤\n问世间钱为何物，只叫人生死相许。！\uD83D\uDE04\n:::\n\n\n## Java原生版本监控\n\n```java\npublic class JavaWatchAPI {\n\n    public static void main(String[] args) throws Exception {\n        //第一步：取得WatchService\n        WatchService watchService = FileSystems.getDefault().newWatchService();\n        //第二步：确定要监控的路径\n        Path path = Paths.get(\"/Users/liuxin/Github/nobug-learn-project/nobug-learn-01/src/main/java\");\n\n        //第三步：为本路径绑定WatchService，并确定监控的事件\n        path.register(\n                watchService,\n                // StandardWatchEventKinds.ENTRY_CREATE—当有新文件时触发。可能是创建了一个新文件\n                StandardWatchEventKinds.ENTRY_CREATE,\n                // StandardWatchEventKinds.ENTRY_DELETE—当文件被删除、移动或重命名时触发\n                StandardWatchEventKinds.ENTRY_DELETE,\n                // StandardWatchEventKinds.ENTRY_MODIFY—当文件被修改时触发。\n                StandardWatchEventKinds.ENTRY_MODIFY);\n        // StandardWatchEventKinds.OVERFLOW—触发表示丢失或丢弃的事件。\n        WatchKey key = null;\n        while ((key = watchService.take()) != null) {\n            for (WatchEvent<?> event : key.pollEvents()) {\n                System.out.println(\"事件\" + event.kind() + \"发生了，文件是：\" + event.context());\n            }\n            key.reset();\n        }\n    }\n}\n\n```\n\n\n## Common IO 工具包监控\n\n\n```java\npackage cn.github.chinesszz;\n\nimport org.apache.commons.io.filefilter.FileFilterUtils;\nimport org.apache.commons.io.monitor.FileAlterationListener;\nimport org.apache.commons.io.monitor.FileAlterationMonitor;\nimport org.apache.commons.io.monitor.FileAlterationObserver;\nimport org.junit.Test;\n\nimport java.io.File;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * @author liuxin\n * 2021/11/9 8:55 下午\n */\npublic class CommonIOAPI {\n\n    public static void main(String[] args) throws Exception {\n        File directory = new File(\"/Users/liuxin/Github/nobug-learn-project/nobug-learn-01/src/main/java\");\n        // 轮询间隔 5 秒\n        long interval = TimeUnit.SECONDS.toMillis(5);\n        // 创建一个文件观察器用于处理文件的格式\n        FileAlterationObserver observer = new FileAlterationObserver(directory, FileFilterUtils.and(\n                FileFilterUtils.fileFileFilter(), FileFilterUtils.suffixFileFilter(\".txt\"),\n                FileFilterUtils.prefixFileFilter(\"lx\")));\n        // 设置文件变化监听器\n        observer.addListener(new MyFileListener());\n        FileAlterationMonitor monitor = new FileAlterationMonitor(interval, observer);\n        monitor.start();\n        System.out.println(1);\n    }\n\n    @Test\n    public void watchDir() throws Exception {\n        File directory = new File(\"/Users/liuxin/Github/nobug-learn-project/nobug-learn-01/src/main/java\");\n        FileAlterationObserver fileAlterationObserver = new FileAlterationObserver(directory, FileFilterUtils.and(\n                FileFilterUtils.directoryFileFilter()));\n        long interval = TimeUnit.SECONDS.toMillis(5);\n        // 设置文件变化监听器\n        fileAlterationObserver.addListener(new MyFileListener());\n        FileAlterationMonitor monitor = new FileAlterationMonitor(interval, fileAlterationObserver);\n        monitor.start();\n        while (true);\n    }\n\n    static final class MyFileListener implements FileAlterationListener {\n        @Override\n        public void onStart(FileAlterationObserver fileAlterationObserver) {\n            System.out.println(\"monitor start scan files..\");\n        }\n\n\n        @Override\n        public void onDirectoryCreate(File file) {\n            System.out.println(file.getName() + \" director created.\");\n        }\n\n\n        @Override\n        public void onDirectoryChange(File file) {\n            System.out.println(file.getName() + \" director changed.\");\n        }\n\n\n        @Override\n        public void onDirectoryDelete(File file) {\n            System.out.println(file.getName() + \" director deleted.\");\n        }\n\n\n        @Override\n        public void onFileCreate(File file) {\n            System.out.println(file.getName() + \" created.\");\n        }\n\n\n        @Override\n        public void onFileChange(File file) {\n            System.out.println(file.getName() + \" changed.\");\n        }\n\n\n        @Override\n        public void onFileDelete(File file) {\n            System.out.println(file.getName() + \" deleted.\");\n        }\n\n\n        @Override\n        public void onStop(FileAlterationObserver fileAlterationObserver) {\n            System.out.println(\"monitor stop scanning..\");\n        }\n    }\n}\n\n\n```\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/other/java-watch-file.md b/docs/learn/other/java-watch-file.md
--- a/docs/learn/other/java-watch-file.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/other/java-watch-file.md	(date 1655373430557)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: false
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/other/程序猿到底有没有必要买一台阿里云服务器.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: false\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 程序猿到底有没有必要买一台阿里云服务器\n---\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2019122518192512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70)\n\n**做为一名程序猿多多少少每天都在跟服务器打交道,尤其是后端的小伙伴,那么你是否也有这样的想法呢 ?**\n\n\n\n### 一、个人服务器究竟能做什么?\n\n#### 1. 搭建个人博客\n软件开发这个行业,知识技术日新月异,作为一名合格专注的程序猿每天都会浏览各种各样的技术网站,在这里我们排出一些大的技术博客网站,我们也经常会看到很多个人的技术博主。一般拥有个人博客网站的都是在某一个领域有很深认识的大牛,会经常把自己的学到的知识积累下来,分享给大家。那么如果要搭建自己的个人博客就必须要有一台个人服务器啦。 但是排出一种情况就是有些个人博主会把自己的博客部署在 `gitlab` 或者`github`、`coding` 的静态Pages上,然后通过域名`CNAME` 的方式访问, 像小编我自己之前也是用后面这种情况,可以免费部署自己的个人博客。但是唯一缺点就是访问太慢了。\n\n**下面就是小编我自己的个人网站,主要做Java后端的知识分享(非营利性哦)**\n[![在这里插入图片描述](https://img-blog.csdnimg.cn/20191225183752474.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70)](https://blog.springlearn.cn/)\n\n#### 2. 搭建个人知识库\n做为技术人,我们每天都要处理各种各样的数据,有公司数据、有个人数据、或者碎片的知识点、API信息、备忘录信息等。相信每个开发者都会有这个需求吧，一般我们可以使用 `有道云笔记` 、 `印象笔记`。 小编使用的是前者，但是突然有一段时间不能用了,原因当然不是有道云挂了, 而是很多公司为了信息安全禁止员工登陆这种网站,\n比如云盘类网站, 当然就包括上面的。这个时候当我们访问上面的网站时候就会被公司后台记录，或者是直接就访问不到。这个时候我们就要考虑搭建一个人知识库了。小编现在用的是 `showdoc`。 非常简单。\n\n登陆服务器安装 `docker` 运行下面命令即可\n\n```bash\ndocker pull xd2idwf5.mirror.aliyuncs.com/star7th/showdoc;\ndocker tag xd2idwf5.mirror.aliyuncs.com/star7th/showdoc:latest star7th/showdoc:latest;\nmkdir showdoc_data;\nmkdir showdoc_data/html;\nchmod  -R 777 showdoc_data;\ndocker run -d --name showdoc -p 6666:80 -v /root/showdoc_data/html:/var/www/html/      star7th/showdoc\n```\n\n**下面是小编的个人知识库**\n\n[![在这里插入图片描述](https://img-blog.csdnimg.cn/20191225184550675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70)](http://doc.springlearn.cn)\n#### 3. 搭建个人网盘\n网盘的用处只有一个就是存储文件,市面上的产品之前有很多但是近两年很多都倒闭了,不过现在还有 `百度网盘`依然坚挺。但是(太...慢了)。 那么我们就自己来搭建一个吧。小编使用的网盘是 `Seafile`\n\nSeafile是一个开源、专业、可靠的云存储平台；解决文件集中存储、共享和跨平台访问等问题，除了一般网盘所提供的云存储以及共享功能外，Seafile还提供消息通信。 具体安装也不难。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20191225185205331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70)\n\n#### 4. 部署个人应用\n这个需求应该是购买服务器的最终目的，就是部署自己的服务, 小编就是部署的自己的博客应用。 使用nginx作为方向代理。不得不说使用自己服务器就是比免费的速度快。\n\nhttp://blog.springlearn.cn/ 响应在5毫秒内\nhttp://www.hanframework.com/ 免费的响应在400毫秒内\n\n虽然都不到1秒,但是具体使用时候用户体验差距还是很大的。可以自己体验下。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20191225185514458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70)\n\n### 二、购买了服务器你还需要哪些知识储备\n\n#### 1. 服务器ssh登录\n当我们购买了服务器我们有两种登陆方式\n1. 用户名和密码登陆\n2. 秘钥登陆\n   这两种登陆都离不开 `ssh` 命令\n\n**第一种**\n`ssh root@127.32.32.122` 然后输入用户密码\n\n**第二种**\n`ssh aliyun`  直接就访问\n\n对于如何配置小编就不说了,百度搜索就很多答案,如果不想搜索或者有问题，可以给小编私信。小编给你解决。\n\n#### 2. 服务器器安全组配置\n安全组这个概念,如果没有购买过服务器的应该不是很清楚,其实就是防火墙的意思。当我们购买了阿里/百度/腾讯/华为/七牛之类的服务器，在后台都有一个安全组管理的。一个入站,一个出站端端口配置。 这个要注意,如果不配置的话，你是访问不到你的端口的\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20191225190257549.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70)\n#### 3. 域名配置\n我们可以选择一个自己心仪的域名, 一般域名很便宜一年`三十` 左右。但是别钻牛角尖, 天价的域名也很多。\n\n域名配置主要是域名转发之类的。\n\n1. 第一种情况: 如果要将域名配置到一台服务器上使用，那么这种情况域名必须要备案，备案一般服务商会帮我们备案，我们只要提供认证信息,一般一周内可以下来。\n2. 第二种情况: 如果我们没有服务器我们也可以购买一个域名,我们在配置域名转发的时候,可以不指定服务器,而是转发到一个CNAEM别名上也可以使用。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20191225191224799.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70)\n#### 4. 部署应用\n\n不会做饭的老司机不是好的厨师,同样只会写代码,不会部署的程序猿不是合格的程序猿。\uD83D\uDE38。\n\n部署应用我们可以使用 `docker` + `nginx或apache` 。 具体 `nginx` 和 `docker` 的使用网上很多就不细说了，如果你要购买服务器这些都是你要储备的知识点。\n\n### 三、购买服务器要注意什么\n\n#### 1. 价格\n作为软件开发者,能免费的东西绝对不花钱, 上面的各种场景,其实我们都可以使用免费的来替代。 除了部署应用。那么我们就研究下价格。 一般运营商的套路都是年底大甩卖。所以年中和年头不是购买服务器的时间, 一般都在 `双十一` 、`双十二`期间会大降价。\n关于价格对比的我们就以`2核4G`的服务器作为对比, 因为这个配置就能满足我们的需求。 那么我们就看看运营商的价格，因为是双十二期间,所以阿里云最近在搞活动,所以阿里云目前我看是最低的，新用户3年只要799。【如果不是新用户可以用其他人账号买,小编就是用自己家人账号买的】\n\n\n1. 七牛云2核4g三年 ￥1767.61\n2. 腾讯云2核4g三年 ￥3897\n3. 华为云2核4g三年 ￥6,440.70\n4. 阿里云2核4g三年 ￥1807.2(常规价) ￥799(活动价格)\n\n[活动优惠券领取](https://www.aliyun.com/minisite/goods?userCode=oab21mxz)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20191225192246879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20191225192305678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20191225192332835.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2019122519235837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70)\n#### 2. 售后(本人真实体验不是喷子,不是职业黑)\n服务器一般什么情况下会有售后呢?\n当出现服务器 `cpu` 飙高, 流量异常被恶意攻击的时候,就考验售后了。我们就看服务商的工单回复速度。因为小编就用过阿里云和七牛云所以就对比下两家的工单体验吧。\n\n1. 阿里云无论回复速度还是质量都满意。\n2. 七牛云回复慢就算了，一个问题给我转几个人,每次让我重新再问一遍(没地方吐槽,就在这里吧)\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20191225192754639.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70)\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20191225192935155.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70)\n\n\n\n**时间到,下班了... 喜欢小编的可以关注一下,持续为你分享干货知识**\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/other/程序猿到底有没有必要买一台阿里云服务器.md b/docs/learn/other/程序猿到底有没有必要买一台阿里云服务器.md
--- a/docs/learn/other/程序猿到底有没有必要买一台阿里云服务器.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/other/程序猿到底有没有必要买一台阿里云服务器.md	(date 1655373430498)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: false
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/school/students.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: auto\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 匆匆那年\n---\n\n1. 介绍下自己的学习情况\n2. 大学生的迷茫不是问题，问题要如何正确面对\n3. 大学生要知道学习\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/school/students.md b/docs/learn/school/students.md
--- a/docs/learn/school/students.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/school/students.md	(date 1655373430135)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: auto
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/spring/README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: true\nfooter: true\nbacktotop: true\ntitle: Spring\n---\n\n:::info 为什么是春天？\nSpring 让每个人都可以更快、更轻松、更安全地编写 Java。Spring 对速度、简单性和生产力的关注使其成为世界上最受欢迎的Java 框架。\n:::\n\n![](https://img.springlearn.cn/blog/learn_1647175180000.png)\n\n\n- Spring\n- SpringBoot\n- SpringCloud\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/spring/README.md b/docs/learn/spring/README.md
--- a/docs/learn/spring/README.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/spring/README.md	(date 1655373430181)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/test/案例分享.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 案例分享\n---\n\n## 前言\n\n:::info 单测覆盖率为应用质量指标化提供解决方案\n\n**一口吃不了一个胖子, 由于每个人的认识不一样,要想达到理想的状态,显然是不可能的。此章节主要从实践出发,一步一步带领我们完成一个有效的可复用的单元测试的编写。**\n\n:::\n\n\n## 一、目标\n\n### 1.1 质量保障\n\n**单测是保证项目质量的手段,而不是目的。**\n\n\n通过 `mvn test ` 在每次编译时候，对代码进行测试。以到达可持续集成的目的。这里的关键是在每次服务发布的时候,首先要运行测试用例。\n只有这样,我们的单测用例才有价值,才能提前发现问题。\n\n![](https://img.springlearn.cn/blog/learn_1621248108000.png)\n\n### 1.2 打扫屋子\n\n要解决前面的这个问题,就要求我们编写正确的测试用例。因为大多数项目目前的编译脚本都是,跳过单元测试的.\n`mvn -Dmaven.test.skip=true`, 之所以这样是因为大多数的单测都是为 `debug` 写的,一旦在编译的时候执行单测用例,\n就会编译不通过。所以要想达到可持续集成的目的, 就要先把阻塞应用的单元测试用例给移除。\n\n我们可以通过 `@Ignore` 来。 当然这不是说不允许你写debug的单测,而是要我们<Highlight color=\"#ffffff\" bg=\"#117eed\"> 遵守一个约定</Highlight>, 对那种debug的单测, 必须人工执行的单测\n我们要通过 `@Ignore` 来标记, 避免我们执行单测时候失败。\n\n### 1.3 发挥价值\n\n如果做到了 1.1 和 1.2 那么单测的价值有会真正体现出来了。但是这一切的一切的前提是我们要编写出正确的符合规范的单测用例。\n\n![](https://i0.hdslb.com/bfs/article/7698c4b6720896ccd93fffc15257b79122fe06df.gif)\n\n## 二、真实案例分享\n\n首先这里我们使用到的技术,其实再前面的技术框架中都有列举了,所以这里就不详细说明了。这里就分享几个测试用例。\n\n### 2.1 查询接口测试用例 难度:⭐️\n\n![](https://img.springlearn.cn/blog/learn_1620982729000.png)\n\n对于上图这种仅仅涉及到读的接口,是比较简单的。我们的验证点其实只有两个。\n\n1. web接口是否可以调用\n2. 接口查询条件是否有效\n\n\n#### 2.1.1 启动web服务器\n\n随机web端口,执行单测的时候启动一个web容器,用来模拟Web接口测试。\n\n```java\n@RunWith(SpringRunner.class)\n@SpringBootTest(classes = CenterProviderApplication.class,\n                webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n// 指定启动类\npublic class BaseApplicationTest {\n\n    protected URL base;\n\n    @LocalServerPort\n    private int port;\n\n    @Before\n    public void setUp() throws Exception {\n        this.base = new URL(\"http://localhost:\" + port + \"/pms/\");\n    }\n}\n```\n#### 2.1.2 编写接口\n\n\n这里就验证了Web的请求,同时可以进度查询条件的校验。当然这里也可以加上返回值类型的校验\n\n```java\npublic class CommonControllerTest extends BaseApplicationTest {\n\n    @Resource\n    private CommonController commonController;\n\n    /**\n     * 使用测试工具进行web端测试\n     *\n     */\n    @Test\n    public void goodsList() {\n        GoodsListDTO dto = new GoodsListDTO();\n        dto.setSize(5L);\n        dto.setCurrent(1L);\n        // 使用该方法允许数据Mock\n        JsonResult<DiyPage<PmsGoodsVO>> result = TestWebUtils.web(this.base).mockWhen(commonController).goodsList(dto);\n        // 非空判断\n        Assert.assertNotNull(result);\n        // 接口响应值判断\n        Assert.assertTrue(result.getMsg(), result.isSuccess());\n        // 接口数据输出\n        System.out.println(TestConsole.color(\"执行结果:\"));\n        System.out.println(TestConsole.colors(result, AnsiColor.BRIGHT_BLUE));\n    }\n}\n```\n\n看到这里我们能亲身感受到,对于纯粹读的接口测试用例是比较容易编写的。一个项目只用维护一次就好了,开发同学也不会每次都去维护这个用例。\n虽然这个用例简单,但是我们能在每次发布完成后自动化的去执行校验。能帮助我们提前发现问题。\n\n### 2.2 读写测试用例 难度:⭐️⭐️\n\n![](https://img.springlearn.cn/blog/learn_1620988529000.png)\n\n像这种读写操作,且涉及到对外部数据调用的接口。我们要使用Mockito技术,对外部对象进行代理,并制定其中的行为。\n如下图这个测试用例,看下如何编写测试用例。\n\n![](https://img.springlearn.cn/blog/learn_1620989004000.png)\n\n首先分析下涉及到的接口。\n\n- saveArrivalOrder 这个接口里面是包含了内部的业务逻辑和外部的数据调用,包含了下面两个外部的接口依赖。\n1. noticeTransportNodeNote 在保存到货通知单的时候,通知库存增加商品的在途库存数量的\n2. syncPurchaseOrder      在保存到货通知单的时候,是通知仓储做到货准备的\n\n\n这个业务中我们只需要验证我们内部的逻辑即可,涉及到外部的调用只需要验证代码即可,并不真的需要仓库和库存系统做\n真实的业务处理。所以我们就要针对这两个方法做数据mock我们使用到的技术就是Mockito做对象行为的mock。如下案例。\n\n\n主要看注释,我们在调用接口的时候,先通过给外部接口最Mockito代理,然后指定动作的出入参数。\n\n```java\npublic class NoticeOrderControllerTest extends BaseApplicationTest {\n\n    @Autowired\n    NoticeOrderController controller;\n\n    /**\n     * 接口穿插在po单创建的单侧里面\n     */\n    @Test\n    public void saveArrivalOrder() {\n        // 1. 构建保存单据的参数(从浏览器中复制数据)\n        String saveOrderJson =  \"{}\"\n        NoticeOrderDTO noticeOrder = TestConsole.toObject(saveOrderJson, ArrivalNoticeOrderDTO.class);\n\n        // 2. mock库存中心返回 - inventoryTransportClient.noticeTransportNodeNote\n        JsonResult<Boolean> noticeResult = JsonResult.success(true);\n        Mockito.doReturn(noticeResult).when(inventoryTransportClient).noticeTransportNodeNote(Mockito.any());\n        // 3. mock同步中控台 - bookingOrderPmsFeignClient.syncPurchaseOrder(bookingOrderDetailDTO)\n        JsonResult<Object> syncResult = JsonResult.success();\n        Mockito.doReturn(syncResult).when(bookingOrderPmsFeignClient).syncPurchaseOrder(Mockito.any());\n\n        // 4. 执行保存+提交(走网络请求,事务不会自动回滚,如果想自动回滚直接调用,controller.saveArrivalOrder(arrivalNoticeOrder))\n        arrivalNoticeOrder.setStatus(1);\n        JsonResult<Long> longJsonResult = TestWebUtils.web(this.base).when(ArrivalNoticeOrderController.class)\n                .saveArrivalOrder(arrivalNoticeOrder);\n        PmsAssert.assertSuccess(longJsonResult);\n\n        // 5. 验证关闭(这里因为我要验证关闭接口,所以不要自动会馆)\n        Mockito.doReturn(syncResult).when(bookingOrderPmsFeignClient).cancelPurchaseOrder(Mockito.any());\n        Mockito.doReturn(noticeResult).when(inventoryTransportClient).cancelTransportNode(Mockito.any());\n\n        JsonResult<Void> jsonResult = TestWebUtils.web(this.base).when(ArrivalNoticeOrderController.class)\n                .closeOrder((longJsonResult.getData()));\n        PmsAssert.assertSuccess(jsonResult);\n    }\n```\n\n这个案例,我们可以学会如何使用Mockito做外部接口的代理,整体难度也不是很大。\n\n### 2.3 读写接口(复杂接口) 难度:⭐️⭐️⭐️⭐️\n\n针对项目中核心流程, 可能并不仅仅是一个接口，而是有依赖关系的多个接口。\n\n\n针对系统核心链路流程，我们是有必要维护些自动化流程的测试用例。然后对每个接口中的出入参数进行校验。**当做到这一步的时候\n其实我们在发布时候就会更加有底气。敢于去重构代码了。**因为在项目迭代发布的过程中，我们会先跑一边单测。只要单测流程能通过，说明这个核心链路的流程问题就不会太大。\n\n\n当然这里不是说一定没有问题, 而是有问题的几率变小了。如果说出现问题了,我们的自动化流程没有提前发现，那么说明这些场景,我们的单测流程没有覆盖到, 那么这个时候我们再补充我们的自动化流程。\n\n\n\n**注意这里的自动化流程，跟测试同学的自动化流程是有区别的。开发的自动化流程的测试目标是自身项目的代码，所以我们关于外部接口都是通过Mock来模拟的。而测试同学的\n自动化流程，都是走真实的系统调用。**\n\n#### 2.3.1 业务说明\n\n\n1. 创建一个包含一个商品的，草稿状态的临时采购单【验证保存接口】\n\n2. 模拟用户对采购单的商品进行二次修改【验证修改逻辑接口】\n\n3. 模拟对已经审核的采购单,添加不同类型货通知单【验证不同单据到货通知单的校验接口】\n\n4. 对已经创建的到货通知单进行人工关闭【验证关闭】\n\n5. 关闭所有到货通知单【验证关闭】\n\n6. 关闭采购单【验证采购关闭】\n\n\n做到业务流程闭环\n\n```java\n    @Test\n    public void tempPurchaseOrderSave() {\n        String saveOrderJson = \"{\\\"poOrderItemList\\\":[{\\\"id\\\":null,\\\"goodsId\\\":\\\"1\\\",\\\"skuId\\\":\\\"1001062\\\",\\\"goodsName\\\":\\\"ABM品牌招商手册包11112\\\",\\\"englishName\\\":\\\"1\\\",\\\"goodsCode\\\":\\\"9314807022860\\\",\\\"brandCode\\\":\\\"brand230\\\",\\\"brandName\\\":\\\"34 西班牙\\\",\\\"specificationModel\\\":\\\"12ml/瓶\\\",\\\"wmsItemList\\\":[{\\\"purchaseNum\\\":null,\\\"warehouseName\\\":\\\"DHL\\\",\\\"warehouseCode\\\":0},{\\\"purchaseNum\\\":null,\\\"warehouseName\\\":\\\"PCA\\\",\\\"warehouseCode\\\":1},{\\\"purchaseNum\\\":null,\\\"warehouseName\\\":\\\"EWE\\\",\\\"warehouseCode\\\":2},{\\\"purchaseNum\\\":null,\\\"warehouseName\\\":\\\"新西兰仓\\\",\\\"warehouseCode\\\":3}],\\\"purchaseNum\\\":30,\\\"goodProductNum\\\":30,\\\"purchasePrice\\\":\\\"10\\\",\\\"expectDeliveryDate\\\":\\\"2021-05-12\\\",\\\"actualPurchaseNum\\\":null}],\\\"tradeCompanyIdList\\\":[\\\"13\\\"],\\\"supplierId\\\":\\\"347\\\",\\\"businessLineId\\\":\\\"1\\\",\\\"sameChainId\\\":49,\\\"title\\\":\\\"mevan test自动跑验证流程\\\",\\\"companyId\\\":null,\\\"channelCode\\\":\\\"ABM\\\",\\\"brandCode\\\":\\\"brand230\\\",\\\"purchaseBrandId\\\":\\\"1374262965415165953\\\",\\\"currencyCode\\\":\\\"AUD\\\",\\\"tradeType\\\":20,\\\"deliveryWarehouseId\\\":null,\\\"transferWarehouseId\\\":\\\"542\\\",\\\"salesWarehouseId\\\":\\\"9\\\",\\\"giveawayOrderSign\\\":1,\\\"ids\\\":\\\"\\\"}\";\n        PurchaseOrderDTO purchaseOrderDTO = TestConsole.toObject(saveOrderJson, PurchaseOrderDTO.class);\n        purchaseOrderDTO.setTitle(\"mvn test(临时订单自动化流程验证)\");\n        List<PurchaseOrderDetailDTO> poOrderItemList = purchaseOrderDTO.getPoOrderItemList();\n        for (PurchaseOrderDetailDTO purchaseOrderDetailDTO : poOrderItemList) {\n            // 赠品刚开始设置成1\n            purchaseOrderDetailDTO.setGiveawayNum(1);\n            purchaseOrderDetailDTO.setExpectDeliveryDate(JodaTimeUtils.addDay(new Date(), 1));\n        }\n        // 1. 执行保存\n        Long purchaseOrderId = createPurchaseOrder(purchaseOrderDTO);\n\n        // 2. 然后修改下商品明细\n        List<PurchaseOrderDetailDTO> updateOrderDetailList = purchaseOrderDTO.getPoOrderItemList();\n        EnhanceStream.findAny(updateOrderDetailList)\n                .ifPresent(order -> {\n                    order.setGiveawayNum(0);\n                });\n        purchaseOrderDTO.setId(purchaseOrderId);//第二次要修改要orderType\n        purchaseOrderDTO.setOrderType(PurchaseOrderTypeEnum.TEMPORARY_ORDER.getKey());\n        updatePurchaseOrder(purchaseOrderDTO);\n\n        PurchaseOrderDTO audit = new PurchaseOrderDTO();\n        audit.setId(purchaseOrderId);\n        audit.setSameChainId(purchaseOrderDTO.getSameChainId());\n        audit.setTradeCompanyIdList((purchaseOrderDTO.getTradeCompanyIdList()));\n        audit.setSupplierId(purchaseOrderDTO.getSupplierId());\n        audit.setCompanyId(purchaseOrderDTO.getCompanyId());\n\n        // 2. 执行审核\n        JsonResult<Void> auditJson = TestWebUtils.web(this.base).when(PurchaseOrderController.class).audit(audit);\n        PmsAssert.assertSuccess(auditJson);\n\n        // 3. 订单查询\n        PurchaseOrderVO purchaseOrderDetail = queryPurchaseOrderDetail(purchaseOrderId);\n\n        // 3.1 对po单主单里面的必填值\n        assertPo(purchaseOrderDetail, false, purchaseOrderDetail);\n\n        // 4. 生成三笔到货通知单,然后关闭\n        createArrivalOrderAndClose(purchaseOrderId);\n\n        // 5. PO订单手动关闭\n        closePurchaseOrder(purchaseOrderId, \"maven test 自动化脚本\");\n\n    }\n```\n\n当执行完上面的单测用例,就完成了采购核心链路的自动化流程,就会生成下面单据。\n\n采购单\n\n![](https://img.springlearn.cn/blog/learn_1621232807000.png)\n\n到货通知单\n\n![](https://img.springlearn.cn/blog/learn_1621232854000.png)\n\n\n\n## 三、可复用能力\n\n通过2我们知道如何使用Mockito做对象行为的mock。还有一个点要思考的,这里单独拿出来说。就是测试用例的可复用行。什么叫可复用性呢?\n就是说你这个单侧用例,在每次代码提交和编译时候执行，是否会有问题。如果是,且只能运行一次,那么这个就是不合格的。要做到可复用还要考虑两个地方。\n\n### 3.1 接口参数动态生成\n\n为什么要动态生成呢? 因为比如我们指定了一个id去作为查询条件,那么当我们这个id被删除的时候,这个测试用例一定是失败的。\n这种场景下我们就应该动态去查询一个。如下，我们查询采购单的全链路数据。那么首先我先查询所有的有效的采购单,然后拿出任意一条\n作为测试用例的查询条件即可。\n\n```java\n    @Test\n    public void queryFullLinkData() {\n        // 执行测试用例时候,动态获取一个采购单code\n        String orderCode = testOrderUtils.purchaseOrderCode();\n        TrackFullLinkDTO trackFullLinkDTO = new TrackFullLinkDTO();\n        trackFullLinkDTO.setCurrent(1L);\n        trackFullLinkDTO.setSize(10L);\n        trackFullLinkDTO.setPurchaseOrderCode(orderCode);\n        JsonResult<TrackFullLinkVO> fullLinkData = TestWebUtils.web(this.base).when(PurchaseOrderController.class).queryFullLinkData(trackFullLinkDTO);\n        PmsAssert.assertSuccess(fullLinkData);\n    }\n```\n\n上面这个用例只用声明一个测试的bean对象即可。在我们的 `src/test/java`包中。\n\nTestComponent\n\n```java\n@TestComponent\npublic class TestOrderUtils {\n\n    @Resource\n    private ArrivalNoticeOrderController arrivalNoticeOrderController;\n\n    public String purchaseOrderCode() {\n        return purchaseOrder().getOrderCode();\n    }\n```\n\n### 3.2 业务流程要闭环\n\n\n1. 要么数据执行完成自动回滚\n2. 要么数据不回滚,但是业务流程要闭环。\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/test/案例分享.md b/docs/learn/test/案例分享.md
--- a/docs/learn/test/案例分享.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/test/案例分享.md	(date 1655373430453)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/test/使用断言.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 使用断言\n---\n\n\n:::danger 断言\n\n单测方法尽可能去使用断言,明确方法的执行结果\n\n:::\n\n## 一、单测的目的\n\n我们单测的目的就是为了确定,被测试的方法或者是接口是否符合业务要求。\n其中一些方法是只要跑成功就算成功了,但是其实大部分方法还是要看其中的返回值是否符合预期。\n\n\n在平时的开发中发现许多同学只是喜欢把结果打印出来,人工去验证数据。这其实就跟JUnit的口号相违背了。\nJUnit的口号: <Highlight color=\"green\">keep the bar green to keep the code clean。</Highlight>\n\n\n![](/junit-success.gif)\n\n\n### 1.1 正确的单测一定是有断言的\n\n断言明确执行结果,如果你要看数据也可以把结果打印出来。但是断言也要加上。\n`JUnit` 为我们提供了一些辅助的函数，就是用来帮助我们来判断被测试的方法是否如我们预期的效果一样正常执行。\n\n## 二、断言API\n\n### 2.1 assertEquals\n\n- assertEquals(Object expected, Object actual)\n- assertEquals(String message, Object expected, Object actual)\n\nString message： 可选参数，将在发生错误时报告这个消息\nObject expected： 期望值，一般为用户指定的内容\nObject actual： 被测试的代码实际返回的结果\n\n### 2.2 assertTrue 与 assertFalse\n\n-   assertTrue(boolean condition)\n-   assertTrue(String message, boolean condition)  \n\nString message： 可选参数，将在发生错误时报告这个消息\nboolean condition：待验证的 Boolean 类型值\n\nassertTrue 该断言用来验证给定的布尔型值是否为真，如果结果为假，则验证失败；\n相反，assertFalse 用来验证给定的布尔型值是否为假，如果结果为真，则验证失败。\n\n### 2.3 assertNull 与 assertNotNull\n\n-   assertNull(Object object)  \n-   assertNull(String message, Object object)  \n\nString message： 可选参数，将会在发生错误时报告这个消息\nObject object： 待验证是否为 Null 的对象\n\nassertNull 该断言用来验证给定的对象是否为 Null ,如果给定对象为 非Null，则验证失败。\n相反，assertNotNull 用来验证给定的对象是否为 非Null，如果为 Null，则验证失败。\n\n### 2.4 assertSame 与 assertNotSame\n\n-   assertSame(Object expected, Object actual)  \n-   assertSame(String message, Object expected, Object actual)  \n\nString message： 可选参数，将会在发生错误时报告这个消息\nObject expected：期望值\nObject actual：被测试代码返回的实际值\n\nassertSame 该断言用来验证 expected 和 actual 的引用是否为同一个对象的引用，如果不是同一引用，则验证失败。\n相反，assertNotSame 用来验证 expected 和 actual 的引用是否为不同对象的引用，如果为同一对象引用，则验证失败。\n\n### 2.5 Fail\n\n- Fail()\n- Fail(String message)\n\n\nString message是个可选参数，假如提供，将会在发生错误时报告这个消息。\n\n该断言会使测试立即失败，通常用在测试不能达到的分支上（如异常）。\n\n\n## 三、断言匹配\n\n依赖包\n\n```java \nimport org.hamcrest.Matchers;\nimport org.hamcrest.core.AllOf;\nimport org.hamcrest.core.AnyOf;\n```\n\n### 3.1 Matchers匹配器\n\n```java \n        // 是否相等\n        Assert.assertThat(2, Matchers.is(2));\n        // 2 小于等于2\n        Assert.assertThat(2,Matchers.lessThanOrEqualTo(2));\n        Map<String,String> map = new HashMap<>();\n        map.put(\"name\",\"jay\");\n        // map 中是否包含key为name的元素\n        Assert.assertThat(map,Matchers.hasKey(\"name\"));\n        // map 中是否包含value为jay的元素\n        Assert.assertThat(map,Matchers.hasValue(\"jay\"));\n        // map 中是否包含name等于jay的元素\n        Assert.assertThat(map,Matchers.hasEntry(\"name\",\"jay\"));\n```\n### 3.2 AllOf\n\n```java \n   // 2 小于4同时也小于3\n   Assert.assertThat(2, AllOf.allOf(Matchers.lessThan(4), Matchers.lessThan(3)));\n```\n\n### 3.3 AnyOf\n\n```java \n   // 2 大于1小于3\n   Assert.assertThat(2, AnyOf.anyOf(Matchers.greaterThan(1), Matchers.lessThan(3)));\n```\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/test/使用断言.md b/docs/learn/test/使用断言.md
--- a/docs/learn/test/使用断言.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/test/使用断言.md	(date 1655373430402)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/test/单测维护.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 单测维护\n---\n\n\n:::info 单测维护\n\n:::\n\n## 一、考虑不要跳过单测\n\n目前我们都是跳过单测的,测试都是每次改造完成后,手工去进行验证。\n验证没有问题就提测了。这样的单测是没有维护性的。\n\n当我们建立起单测体系后,真正重视单测维护后,就可以考虑不要跳过单元测试\n这样,每次编译时候都可以执行一遍单测用例,观察失败的单测试服是这次改造的bug导致。\n\n\n## 二、后期维护单测\n\n开发时间紧张,没有进行单测就提测了,测试也通过了。对于这类代码后期可以补充上单测。方便后面进行业务调整时候,进行单测验证。\n\n只有这样开发人员才更有底气。\n\n## 三、售后服务\n\n应用Owner要督促,应用成员要重视。做好应用质量把控。\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/test/单测维护.md b/docs/learn/test/单测维护.md
--- a/docs/learn/test/单测维护.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/test/单测维护.md	(date 1655373430542)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/test/MockDataAPI.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: MockData API\n---\n\n\n`JMockData` 是一款国人开发用来生成模拟数据的工具\n\n\n\n## 基础类型\n\n| 描述         | 类型                                                         |\n| ------------ | ------------------------------------------------------------ |\n| 基础类型     | `byte` `boolean` `char` `short` `int` `long` `float` `double` |\n| 包装类型包装 | `Byte` `Boolean` `Character` `Short` `Integer` `Long` `Float` `Double` |\n| 常用类型     | `BigDecimal` `BigInteger` `Date` `LocalDateTime` `LocalDate` `LocalTime` `java.sql.Timestamp` `String` `Enum` |\n| 多维数组     | 以上所有类型的多维数组 如：`int[]` `int[][]` `int[][][]` .... etc. |\n\n```java \n//基本类型模拟\nint intNum = JMockData.mock(int.class);\nint[] intArray = JMockData.mock(int[].class);\nInteger integer = JMockData.mock(Integer.class);\nInteger[] integerArray = JMockData.mock(Integer[].class);\n//常用类型模拟\nBigDecimal bigDecimal = JMockData.mock(BigDecimal.class);\nBigInteger bigInteger = JMockData.mock(BigInteger.class);\nDate date = JMockData.mock(Date.class);\nString str = JMockData.mock(String.class);\n```\n\n## JAVA对象\n\n模拟bean，被模拟的数据最好是plain bean，通过反射给属性赋值。\n\n```java \npublic class User {\n\n    private String name;\n\n    private int age;\n\n    private long cardId;\n    \n}  \n```\n\n```java \n    @Test\n    public void test() {\n        User mock = JMockData.mock(User.class);\n        // User{name='jrq2b', age=9338, cardId=2850}\n        System.out.println(mock);\n    }  \n```\n\n## 容器类型\n\n```java \n@Test\n//******注意TypeReference要加{}才能模拟******\npublic void testTypeRefrence() {\n  //模拟基础类型，不建议使用这种方式，参考基础类型章节直接模拟。\n  Integer integerNum = JMockData.mock(new TypeReference<Integer>(){});\n  Integer[] integerArray = JMockData.mock(new TypeReference<Integer[]>(){});\n  //模拟集合\n  List<Integer> integerList = JMockData.mock(new TypeReference<List<Integer>>(){});\n  //模拟数组集合\n  List<Integer[]> integerArrayList = JMockData.mock(new TypeReference<List<Integer[]>>(){});\n  //模拟集合数组\n  List<Integer>[] integerListArray = JMockData.mock(new TypeReference<List<Integer>[]>(){});\n  //模拟集合实体\n  List<BasicBean> basicBeanList = JMockData.mock(new TypeReference<List<BasicBean>>(){});\n  //各种组合忽略。。。。map同理。下面模拟一个不知道什么类型的map\n  Map<List<Map<Integer, String[][]>>, Map<Set<String>, Double[]>> some = JMockData.mock(new TypeReference<Map<List<Map<Integer, String[][]>>, Map<Set<String>, Double[]>>>(){});\n}\n```\n\n## 范围配置\n\n前面说了可以模拟各种数据,不同类型的数据都允许指定一个范围。\n如下\n\n```java \nSystem.out.println(\nJMockData.mock(Date.class,MockConfig.newInstance()\n.dateRange(\"2018-11-20\", \"2018-11-30\")));\n```\n\n```java title=\"允许指定模拟数据的范围或者是排除\"\n        MockConfig mockConfig = new MockConfig()\n                // 全局配置\n                .globalConfig()\n                .setEnabledStatic(false)\n                .setEnabledPrivate(false)\n                .setEnabledPublic(false)\n                .setEnabledProtected(false)\n                .sizeRange(1, 1)\n                .charSeed((char) 97, (char) 98)\n                .byteRange((byte) 0, Byte.MAX_VALUE)\n                .shortRange((short) 0, Short.MAX_VALUE)\n                // 某些字段（名等于integerNum的字段、包含float的字段、double开头的字段）配置\n                .subConfig(\"integerNum\", \"*float*\", \"double*\")\n                .intRange(10, 11)\n                .floatRange(1.22f, 1.50f)\n                .doubleRange(1.50, 1.99)\n                .longRange(12, 13)\n                .dateRange(\"2018-11-20\", \"2018-11-30\")\n                .stringSeed(\"SAVED\", \"REJECT\", \"APPROVED\")\n                .sizeRange(1, 1)\n                // 全局配置\n                .globalConfig()\n                // 排除所有包含list/set/map字符的字段。表达式不区分大小写。\n                .excludes(\"*List*\", \"*Set*\", \"*Map*\");\n```\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/test/MockDataAPI.md b/docs/learn/test/MockDataAPI.md
--- a/docs/learn/test/MockDataAPI.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/test/MockDataAPI.md	(date 1655373430746)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/test/测试范围.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 测试范围\n---\n\n\n:::info\n项目中拿些类需要进行单元测试呢?\n单测不是目的,是手段。目的都是保证质量\n:::\n\n## 一、从项目分层维度设计单测用例\n\n常见的项目分层有一下这些。\n\n- Web层\n- Service层\n- domain层\n- Integration层\n- Common层 公用类必须要做\n\n\n### 1.1 Web层   【忽略】\n\n一般web层已经上线不会发生改动,往往改动的是新增或者删除参数。可以忽略。\n\n### 1.2 Service层   【建议】\n\nService层往往是程序的接口层,接受来自Web或者Message、Job的调用。Service的逻辑会覆盖大部分的下游分层。Service是我们的业务入口\n接口往往不会改变,改变最多的是它的实现。这一层我们要做好单元测试。\n\n\n但是这一层的单元测试可能会涉及数据的读写和外部的数据读写。可以使用Mockito数据进行替换外部数据的返回。\n内部数据的读写可以通过事务回滚的方式处理,主要验证自己代码中对这些数据的结算逻辑是否有问题。\n\n\n这一层入参的数据往往会很多,对系统也有相关的依赖,自行评估方案。\n这里提供两个曲线救国的方案:\n1. 如果不好测试可以对程序的最小单元进行测试,曲线救国。\n2. 对某个方法中,不满足测试场景的接口,进行Mockito,以跳过这段逻辑。\n\n\n### 1.3 Domain层   【建议】\n\n这一层和Service的业务是比较相像的,只不过不会有Service层一样那么复杂,参考上文。\n\n### 1.4 Integration层 【建议】\n\n防腐层,主要逻辑就是对外部接口的调用,主要测试不要出现NPE。参数的输入值做好非空非null判断,对返回结果做好非空和非null。\n\n```java \npublic List<GoodsBaseMsgDTO> querySkuList(Long skuId, Long brandId, String goodsName) {\n        if (Objects.isNull(skuId) && Objects.isNull(brandId) && StringUtils.isBlank(goodsName)) {\n            // 根据业务来判断是报错还是为空\n            return EnhanceStream.emptyList();\n        }\n        GoodsMsgQueryParam queryParam = new GoodsMsgQueryParam();\n        queryParam.setBrandId(brandId);\n        queryParam.setSkuId(skuId);\n        queryParam.setGoodsName(goodsName);\n        JsonResult<PageData<GoodsBaseMsgDTO>> pageDataJsonResult = goodsStockApi.pageQuerySkuList(queryParam);\n        PageData<GoodsBaseMsgDTO> pageData = JsonResultUtils.orElseGetSafeData(pageDataJsonResult, new PageData<GoodsBaseMsgDTO>());\n        if (Objects.isNull(pageData)) {\n            return EnhanceStream.emptyList();\n        }\n        return pageData.getRecords();\n    }\n    \npublic static <T> T orElseGetSafeData(JsonResult<T> result, T defaultValue) {\n        if (null != result && result.isSuccess() && Objects.nonNull(result.getData())) {\n            return result.getData();\n        } else {\n            if (Objects.nonNull(result)){\n                log.error(result.getMsg());\n            }\n            return Objects.nonNull(defaultValue) ? defaultValue : null;\n        }\n}    \n```\n\n外部提供的 `Feign` 接口, 在没有提供实现之前可以先使用 `Mockito`进行Mock\n帮助完成接口的测试。\n\n```java \npublic class TradeShopIntegrationImplTest extends BaseApplicationTest {\n\n    @Autowired\n    private TradeShopIntegration shopBrandIntegration;\n\n    @MockBean\n    private BrandServiceApi brandService;\n    \n    @MockBean\n    private GoodsStockApi goodsStockApi;\n    \n    @Test\n    public void testGetAllBrands() {\n        Mockito.doReturn(JsonResult.failure(\"fail\")).when(goodsStockApi).getSkuList(Mockito.any());\n        // 底层调用的是goodsStockApi.getSkuList()\n        List<GoodsBaseMsgDTO> goodsBaseMsgDTOS = shopBrandIntegration.queryAllSku();\n        // 因为前面声明了返回fail。所以这里没有数据返回。\n        JsonConsoleUtils.println(goodsBaseMsgDTOS);\n        // 这里跟上面的区别就是,如果没有声明返回值,就走原来的方法。\n        List<OutBrandDTO> allBrands = shopBrandIntegration.getAllBrands();\n        JsonConsoleUtils.println(allBrands);\n    }\n    \n}    \n\n```\n\n### 1.5 Common层   【必须  】\n\n这一层基本出现的都是工具类,主要是功能性代码,自己提供的工具类,一定要做好单元测试。主要是考虑\n异常情况和极限的情况。工具类因为变动的不会太频繁所以维护成本是也比较低的。\n\n[Mockito学习跳转](https://ddd.springlearn.cn/docs/test/spring-boot-testing)\n\n\n## 二、针对核心计算逻辑设计单测用例\n\n比较核心的计算逻辑进行测试。比如根据外部数据进行组装生成新的数据模型的方法。\n\n## 三、忽略测试\n\n在实际开发中可能有些测试只是为了验证某些数据,每次执行要提前准备数据之类的。这种特殊的单测,只能人工指定运行的\n我们可以忽略它,使用`@Ignore` 忽略。这样在Maven运行单测时候,会只运行你没有进行忽略的单测。\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/test/测试范围.md b/docs/learn/test/测试范围.md
--- a/docs/learn/test/测试范围.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/test/测试范围.md	(date 1655373430354)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/test/命名规则.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 命名规则\n---\n\n\n:::info 命名规则\n单测类: 类名 + `Test` 整体大驼峰\n\n单测方法: `test` + 方法名 整体小驼峰\n:::\n\n### 保证目录结构是一致的\n\n在这里有个误区,发现很多同学都是随意去创建测试类,其实这不是一个好的习惯,在Maven项目中,\n要尽量保证测试类与被测类的目录结构是一致的。如下图一样。这样的好处是,我们可以快速在\n这两个类中进行快捷键跳转,也方便我们去新增测试方法。<Highlight color=\"green\">跳转快捷键和创建快捷键保持一致,见下文.</Highlight>\n\n\n![](https://img.springlearn.cn/blog/learn_1618123124000.png)\n\n其实Idea已经为我们提供了快捷操作,如下图。\n\n![](/junit.gif)\n\n\n### 快捷键\n\n![](https://img.springlearn.cn/blog/learn_1618036976000.png)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/test/命名规则.md b/docs/learn/test/命名规则.md
--- a/docs/learn/test/命名规则.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/test/命名规则.md	(date 1655373430259)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/test/技术选型.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 技术选型\n---\n\n## 一、JUnit\n\n\n[JUnit](https://junit.org/junit5/)目标是为JVM上的开发人员端测试创建最新的基础。这包括关注Java 8及更高版本，以及启用许多不同的测试样式。\n\n强制使用 `Junit3` 以上版本, 目前最新的版本是 `Junit5`, 常用的是 `JUnit4`,建议使用<Highlight color=\"#25c2a0\">JUnit4</Highlight>\n或者使用<Highlight color=\"#25c2a0\">JUnit5</Highlight>。\n\n这里有一个小坑。如果SpringBoot2.1.x版本依赖的Junit4。SpringBoot应用要通过 @RunWith + @SpringBootTest。\n在SpringBoot后续的版本依赖JUnit5,直接使用@SpringBootTest即可。\n\n```xml\n\n<dependency>\n    <groupId>junit</groupId>\n    <artifactId>junit</artifactId>\n    <version>4.12</version>\n    <scope>test</scope>\n</dependency>\n```\n\n## 二、Mockito\n\n[Mockito](https://site.mockito.org/) 是一个非常不错的模拟框架。它使您可以使用干净简单的API编写漂亮的测试。Mockito不会给您带来麻烦，因为这些测试的可读性很强，并且会产生清晰的验证错误。\n\n![](https://github.com/mockito/mockito.github.io/raw/master/img/logo%402x.png)\n\n\nmockito-core只包含mockito类，而mockito-all包含mockito类以及一些依赖项，其中一个是hamcrest。\n\n实际上mockito-all已停产according to the mockito website\n\n```xml\n<!-- https://mvnrepository.com/artifact/org.mockito/mockito-core -->\n<dependency>\n    <groupId>org.mockito</groupId>\n    <artifactId>mockito-core</artifactId>\n    <version>3.8.0</version>\n    <scope>test</scope>\n</dependency>\n```\n\n代码实例\n```java \n    \n    // 根据这个原理,我们可以mock所有未实现的功能,比如三方的接口\n    @Test\n    public void test(){\n        List mockList = Mockito.mock(List.class);\n        Mockito.doReturn(12).when(mockList).get(0);\n        // 12\n        System.out.println(mockList.get(0));\n        Assert.assertSame(12,mockList.get(0));\n    }\n```\n\n## 三、JMockData\n\n`JMockData` 是一款国人开发用来生成模拟数据的工具,对象太复杂,模拟数据复制太难? 一行代码搞定。\n\n```xml \n   <dependency>\n       <groupId>com.github.jsonzou</groupId>\n       <artifactId>jmockdata</artifactId>\n       <version>4.3.0</version>\n       <scope>test</scope>\n   </dependency>\n```\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/test/技术选型.md b/docs/learn/test/技术选型.md
--- a/docs/learn/test/技术选型.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/test/技术选型.md	(date 1655373430444)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/test/数据隔离.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 数据隔离\n---\n\n:::info 数据隔离\n\n数据隔离一直是一个测试的痛点，测试数据可能是 `mock` 的数据,所以单测过程中,难免会造成脏数据\n这种场景,有通用的解决方案。`JUnit` 已经帮我们做好了。这里我们只讲实操和用法。\n如果有兴趣的话可以研究下 <Highlight>TransactionalTestExecutionListener</Highlight>\n:::\n\n\n## 解决方案\n\n:::note 单测引导类配置说明\n- @Transactional 如果加上这个注解,就代表全局的单测,事务执行完都会自动回滚\n- @Rollback(false) 如果想某个方法事务不回滚,可以单独在方法上设置。<Highlight color=\"#25c2a0\">【方法级别>全局】</Highlight>\n:::\n\n\n下面这两个方法\n- 第一个方法因为是使用测试全局事务配置,所以默认是回滚。\n- 第二个方法因为使用了方法事务配置,所以会忽略全局配置,然后提交事务。\n\n\n单测引导类配置\n```java\n@Slf4j\n@ActiveProfiles({\"local\"})\n// 使用Spring容器引导\n@RunWith(SpringRunner.class)\n// 默认就是回滚,不用加@Rollback,如果全局不想回滚就在这个吧@Rollback(false),如果某个单测不想回滚,就放到单侧类上\n@Transactional\n@SpringBootTest(classes = {CenterProviderApplication.class}) // 指定启动类\npublic class BaseApplicationTest {\n\n    // 全局事务,默认自动回滚\n    @Test\n    public void testInsert() {\n        String json = \"{\\n\" +\n                \"  \\\"id\\\": 1344215264312557570,\\n\" +\n                \"  \\\"arrivalOrderId\\\": 1344215264287391745,\\n\" +\n                \"  \\\"goodsDeployId\\\": 1344170561282879489,\\n\" +\n                \"  \\\"expectedReceiveNum\\\": 150,\\n\" +\n                \"}\";\n        OrderDetailDO orderDetail = TestConsole.toObject(json, ArrivalNoticeOrderDetailDO.class);\n        orderDetail.setId(null);\n        orderDetail.setCreaterId(888888L);\n        // true\n        Assert.assertTrue(DB.insert(orderDetail) > 0);\n        // notNull\n        Assert.assertNotNull(DB.selectById(orderDetail.getId()));\n    }\n    \n    // 方法事务>全局事务, 这里声明了不自动回滚\n    @Test\n    @Rollback(value = false)\n    public void testInsert() {\n        String json = \"{\\n\" +\n                \"  \\\"id\\\": 1344215264312557570,\\n\" +\n                \"  \\\"arrivalOrderId\\\": 1344215264287391745,\\n\" +\n                \"  \\\"goodsDeployId\\\": 1344170561282879489,\\n\" +\n                \"  \\\"expectedReceiveNum\\\": 150,\\n\" +\n                \"}\";\n        OrderDetailDO orderDetail = TestConsole.toObject(json, ArrivalNoticeOrderDetailDO.class);\n        orderDetail.setId(null);\n        orderDetail.setCreaterId(888888L);\n        // true\n        Assert.assertTrue(DB.insert(orderDetail) > 0);\n        // notNull\n        Assert.assertNotNull(DB.selectById(orderDetail.getId()));\n    }\n}\n```\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/test/数据隔离.md b/docs/learn/test/数据隔离.md
--- a/docs/learn/test/数据隔离.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/test/数据隔离.md	(date 1655373430778)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/test/README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: true\nfooter: true\nbacktotop: true\ntitle: 单元测试专题\n---\n\n![](https://img.springlearn.cn/blog/learn_1617880083000.png)\n\n\n沉淀、分享、成长、让自己和他人都有所收货。\n\n## 一、前言\n\n本系列文章主要的目的是提高大家对代码的单测意识, 其中文章主要会分享单测过程中,常见的测试场景及这些场景的解决方案和处理思路。\n为了能使大家更好的了解单元测试,作为程序员首先从源码入手,分享JUnit的运行原理。在先了解了JUnit的原理后,再来回顾我们的问题场景, 就自然而然的从根源深处解决大家的测单痛点以及大家对单测框架不熟悉的情况。\n\n\n\n## 二、单测的意义\n\n![](https://img.springlearn.cn/blog/learn_1617886822000.png)\n\n很多人说单测没有意义, 这是完全不正确的思想。相信随着码龄增加你会越发的认同这句话。据国外研究统计软件系统中最大的成本是\n维护成本,所以你能看到凡是开源的框架单测一定是非常丰富的,因为它要去迭代升级,要去向下兼容版本。如果没有单测那就是完全的黑盒。\n是好是坏听从天意,这是没有质量保证的。这点是软件系统都具有的所以说就这一点,就证明了单测的必须性。下面谈几个不写单元测试的说法。\n\n### 2.1 压缩开发时间,任务延期\n\n或许说中国的国情跟国外的不一样,中国的系统或者说是业务系统更新的快,单测用完就失效。写单测会压缩开发时间,导致任务延期。从眼下看是压缩了开发的时间,但是它提高了开发的质量,一定程度上减少了系统的维护成本。其次单测并不是说要对你所有的方法进行测试, 这个要针对业务系统情况,把系统的核心业务中使用到的核心方法进行详细的单测维护即可。系统的核心逻辑是不会经常变动的,\n所以这部分的单测就是你整个单测的核心。\n\n### 2.2 公司性质\n\n像一般政府的项目基本都会给到外部的公司来竞争,部分的外包公司只注重交付,不注重质量。或者说这个项目就是一个xx工程, 没有实用价值。\n只要上线就行。也不用维护。对于这种的确实现状是都不会写单元测试。(因为整个项目就是没有任何实用价值)\n\n### 2.3 别人都不写,我为啥要写\n\n代码是有温度的,养成好的习惯从自己做起。好习惯会传染,需要一个<Highlight color='green'>好的带头人</Highlight>。团队内部成员每个人都有自己负责的功能区域。\n只要每个人针对自己的功能区域的核心计算逻辑写好单测,那么一定是好处大于坏处的。另外要写在平时,不要专门找时间来写代码。那样就容易把单测当做是任务去完成,就失去了写单测的意义。\n\n<Highlight color=\"red\">相信你所认为虽然很正确,但是做起来很傻逼的事情,一定有人在默默的坚持着。努力做一个优秀的人。</Highlight>\n\n### 2.4 代码都测完了,要测试干嘛\n\n自己测完了,要测试干嘛。首先如果你有这样的想法,那么一定是因为你不了解测试的工作。测试是开发的补充,他一定不是开发的保姆。测试\n是对应用或系统的整体场景或者说功能的验证, 他不能对你代码的最小单元进行验证。所谓代码的最小单元一定是开发同学最了解的,代码的最小单元\n就是你定义的代码块,方法,技术框架。这部分测试同学是无法帮你验证的。我们这里举一个例子。\n\n软件工程师好比是盖大楼的,具体每一堵墙砖头如何摆放,房间如何设计,是否关注采光这是你设计师要干的事情,而测试好比质量验收,会看你整栋\n大楼是否有倾斜,水电煤气是否可以使用。测试同学并不了解所有的细节。\n\n![](https://img.springlearn.cn/blog/learn_1618206722000.png)\n\n开发和测试看到的东西不是完全一样的,越往上测试的黑盒越大。\n\n![](https://img.springlearn.cn/blog/learn_1618051810000.png)\n\n\n### 2.5 应付覆盖率指标\n\n当然如果公司对这个有要求,一定会有应付的办法。最差的情况就是全部都是为了应付而写代码。从价值观上来看,这是不对的。从实用性上来看这是没有任何价值的。那么如何解决这个办法呢? 价值观来保证咯。那么就需要一个指标了(非硬性指标), 把数据量化展示出来,作为应用质量的一个参考的因素。\n就算你全是应付而写,也一定有一定的价值。\n\n另外要说一点的是<Highlight color=\"red\">单测行覆盖率高不代表应用的质量就一定高,</Highlight>但是单测行覆盖率低一定代表着这个应用出现质量问题的可能性就越大。\n这无疑增加了业务风险和测试成本。为了减少业务风险和测试成本,希望大家提高对单测的意识。\n\n**那么我们在上升一点总结下如何提高应用的质量呢? 请看下文**\n\n\n\n## 三、应用质量的看法\n\n应用质量如何来衡量, 这是一个完全可以通过指标来进行衡量的。那么究竟如何指标化呢? 这里首先对应用质量进行一个拆分。\n\n![](https://img.springlearn.cn/blog/learn_1617889750000.png)\n\n可以将应用质量分为两种:\n\n1. 代码编程质量(编程风格)\n2. 业务编程质量(业务是否清晰,异常场景的考虑)\n\n\n### 3.1 代码编程质量\n\n代码编程质量往往只的是开发人员的编程风格,基于团队成员风格的相似度。\n也可以说是代码的可读性,可维护性,方法的复杂度,方法的执行效率。这个是最容易指标化处理的。\n基于规则引擎,进行静态代码扫描就可以扫描出。Sonar 或者 阿里规约都可以完成。\n他们都会把问题分为四个等级Blocker, Critical, Major, Minor/Trivial。\n\n#### 3.1.1  Blocker\n即系统无法执行、崩溃或严重资源不足、应用模块无法启动或异常退出、无法测试、造成系统不稳定。\n\n#### 3.1.2 Critical\n即影响系统功能或操作，主要功能存在严重缺陷，但不会影响到系统稳定性。\n\n#### 3.1.3 Major\n即界面、性能缺陷、兼容性。\n\n#### 3.1.4 Minor/Trivial\n\n即易用性及建议性问题。\n\n\n<Highlight color=\"red\">质量分计算</Highlight>\n\n\n:::danger 质量分计算\n\n100-(Blocker*100+Critical*10+Major*1)/(代码数/100)\n- Blocker 占比100%,因为是比较严重的问题\n- Critical 低于Blocker占比10%\n- Major 性能缺陷占比1%\n  :::\n\n\n### 2.2 业务编程质量\n\n- 对软件设计的最小单位进行正确性检测，如函数或一个类的方法。\n- 系统集成测试\n\n![](https://img.springlearn.cn/blog/learn_1618206722000.png)\n\n#### 2.2.1 UT由开发同学保证\n\n开发同学进行最小单元测试, 数据如何进行衡量呢?\n\n基于Jenkins的 `Jcoco` 插件,会统计行覆盖率，类覆盖率，复杂方法覆盖率等。输出一个\n可视化的图表。\n\n#### 2.2.2 IT由自动化测试同学编写\n\n\n## 四、代码编程质量例子\n\n面向对象的思想写入复用性高的代码\n\n```java\n\n// 姓名，家乡，大学，专业，兴趣爱好，单位职称 \npublic interface Introduce{\n     // 这是一个介绍类,负责介绍自己\n     public void introduce();\n}\n\npublic class XiaoMing implements Introduce{\n\n     public void introduce(){\n         sout(\"我叫小明\")\n         sout(\"我的老家是河南南阳\")\n         sout(\"我的家乡就坐落在河南南阳邓州市\")\n         sout(\"邓州市一个美丽的城市,是中国邓姓的发源地\")\n         sout(\"邓州也是河南境内人口最多的一个县级城市\")\n         sout(\"我大学是在河南大学\")\n         sout(\"河南大学简称河大，是一所位于中国河南省开封市涵盖文、史、哲、经、管、\n         法、理、工、医、农、教育、艺术等12个学科门类的省部共建型综合性公立大学。\")\n         sout(\"我的专业是计算机与信息工程\")\n         sout(\"我的个人爱好是写博客、打游戏、做美食、偶会也会跑跑步\")\n         sout(\"从业xx年,目前在公司的职称是xxx\")\n     }\n}\n\npublic class XiaoMing implements Introduce{\n\n     private void introduceHometown(){\n         sout(\"我的老家是河南南阳\")\n         sout(\"我的家乡就坐落在河南南阳邓州市\")\n         sout(\"邓州市一个美丽的城市,是中国邓姓的发源地\")\n         sout(\"邓州也是河南境内人口最多的一个县级城市\")\n     }\n     \n     private void introduceSchool(){\n         sout(\"我大学是在河南大学\")\n         sout(\"河南大学简称河大，是一所位于中国河南省开封市涵盖文、史、哲、经、管、\n         法、理、工、医、农、教育、艺术等12个学科门类的省部共建型综合性公立大学。\")\n     }\n     \n     private void introduceMajor(){\n         sout(\"我的专业是计算机与信息工程\")\n     }\n     \n     private void introduceInterest(){\n         sout(\"我的个人爱好是写博客、打游戏、做美食、偶会也会跑跑步\")\n     }\n     \n     // 将任务进行拆分,拆分的维度是逻辑顺序,然后抽离出方法,抽离的维度是单一职责。\n     // 这样的好处是工能化,模块化,便于复用。\n     public void introduce(){\n         sout(\"我叫小明\");\n         introduceHometown();\n         introduceSchool();\n         introduceMajor();\n         introduceInterest();\n         sout(\"从业xx年,目前在公司的职称是xxx\");\n     }\n}\n```\n\n有人会说了,明明很简单就搞定了,为啥多写了这么多方法。这是因为你的思维没有转变过来,简单来说就是要\n学会用面向对象的方法去写代码,不要写面向过程的代码了。如果高级点说就是代码层面上的领域驱动。\n领域驱动和面向过程最大的相同就是思想上都是要对问题进行拆分成最小粒度,已解决代码冗余重复,以方便重复组装利用\n,以达到快速简单维护的目的。\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/test/README.md b/docs/learn/test/README.md
--- a/docs/learn/test/README.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/test/README.md	(date 1655373430531)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/test/FeignMock.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: Feign Mock注意事项\n---\n\n\n## 一、Feign接口模拟\n\n以下两种API的用法会导致你Feign类型推断不出来,建议使用最后一种\n\n```java title=\"建议使用最后一种\"\n        Mockito.when(arrivalOrderFeignClient.listArrivalNoticeBatch(new PmsArrivalNoticeBatchQueryDTO())).thenReturn(JsonResult.success(result));\n        Mockito.doReturn(JsonResult.success(result)).when(arrivalOrderFeignClient).listArrivalNoticeBatch(Mockito.any());\n```\n\n## 二、Mapper接口要使用Mock\n\n对于Service层的数据测试,Mapper类使用@MockBean。保证数据都是模拟的。\n\n对于Dal层数据测试,Mapper使用真实的示例信息。\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/test/FeignMock.md b/docs/learn/test/FeignMock.md
--- a/docs/learn/test/FeignMock.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/test/FeignMock.md	(date 1655373430552)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/test/事务回滚原理.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 事务回滚原理\n---\n\n\n在前文单测类注入中我们知道.JUnit提供了一些监听器,允许\n当单测方法执行时候去对单测上下文进行调整。所以呢事务回滚也是基于\n这里的特性完成的。<Version>基于SpringBoot 2.1.x版本分析</Version>\n\n![](https://img.springlearn.cn/blog/learn_1617795655000.png)\n\n\n### 源码分析\n\nSpring中为了适配不通的数据库,提供了事务平台的概念。 `PlatformTransactionManager` 只要实现了该接口\n就允许对事务进行控制。具体事务的控制是通过工具类来处理的。 `TransactionContextHolder` 可以获取当前线程\n执行的事务上下文。JUnit通过该工具拿到事务的上下文,然后对此做响应的修改。具体的\n修改逻辑见下文注释。两句话解释清楚。\n\n`TransactionalTestExecutionListener`\n\n伪代码分析\n\n```java {1,40} \n    // 单测方法执行前,移除容器原来的事务管理器,然后开启一个新的事务\n    @Override\n\tpublic void beforeTestMethod(final TestContext testContext) throws Exception {\n\t\tMethod testMethod = testContext.getTestMethod();\n\t\tClass<?> testClass = testContext.getTestClass();\n\t\tAssert.notNull(testMethod, \"Test method of supplied TestContext must not be null\");\n\n\t\tTransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext();\n\t\tAssert.state(txContext == null, \"Cannot start new transaction without ending existing transaction\");\n\n\t\tPlatformTransactionManager tm = null;\n\t\tTransactionAttribute transactionAttribute = this.attributeSource.getTransactionAttribute(testMethod, testClass);\n\n\t\tif (transactionAttribute != null) {\n\t\t\ttransactionAttribute = TestContextTransactionUtils.createDelegatingTransactionAttribute(testContext,\n\t\t\t\ttransactionAttribute);\n\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Explicit transaction definition [\" + transactionAttribute +\n\t\t\t\t\t\t\"] found for test context \" + testContext);\n\t\t\t}\n\n\t\t\tif (transactionAttribute.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttm = getTransactionManager(testContext, transactionAttribute.getQualifier());\n\t\t\tAssert.state(tm != null,\n\t\t\t\t\t() -> \"Failed to retrieve PlatformTransactionManager for @Transactional test: \" + testContext);\n\t\t}\n\n\t\tif (tm != null) {\n\t\t\ttxContext = new TransactionContext(testContext, tm, transactionAttribute, isRollback(testContext));\n\t\t\trunBeforeTransactionMethods(testContext);\n\t\t\ttxContext.startTransaction();\n\t\t\tTransactionContextHolder.setCurrentTransactionContext(txContext);\n\t\t}\n\t}\n\t\n\t// 单测方法执行结束后,结束事务然后回滚或提交\n\t@Override\n\tpublic void afterTestMethod(TestContext testContext) throws Exception {\n\t\tMethod testMethod = testContext.getTestMethod();\n\t\tAssert.notNull(testMethod, \"The test method of the supplied TestContext must not be null\");\n\n\t\tTransactionContext txContext = TransactionContextHolder.removeCurrentTransactionContext();\n\t\t// If there was (or perhaps still is) a transaction...\n\t\tif (txContext != null) {\n\t\t\tTransactionStatus transactionStatus = txContext.getTransactionStatus();\n\t\t\ttry {\n\t\t\t\t// If the transaction is still active...\n\t\t\t\tif (transactionStatus != null && !transactionStatus.isCompleted()) {\n\t\t\t\t\ttxContext.endTransaction();\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\trunAfterTransactionMethods(testContext);\n\t\t\t}\n\t\t}\n\t}\n```\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/test/事务回滚原理.md b/docs/learn/test/事务回滚原理.md
--- a/docs/learn/test/事务回滚原理.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/test/事务回滚原理.md	(date 1655373430448)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/test/MockitoAPI.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: Mockito API\n---\n\n\n:::danger 注意\n\n这里只是介绍原生的Mockito的API,针对SpringBoot应用有更简单的调用方式\n:::\n\n\n\n## 一、Mockito加载方式\n\nMockito可以配合JUnit使用,也可以单独使用。有两种方式来引入Mockito\n\n### 1.1 方式:1 不依赖Spring容器\n\n如果你的单测不依赖容器,那么使用这种方式是比较方便和简介的。但是如果\n依赖容器,我们是到JUnit的原理是只要发现有一个Runner就会返回,如果这里指定了\nMockitoJUnitRunner那么SpringRunner就不会被使用。\n\n指定MockitoJUnitRunner\n\n```java\n   @RunWith(MockitoJUnitRunner.class)\n   public class ExampleTest {\n   \n       @Mock\n       private List list;\n   \n       @Test\n       public void shouldDoSomething() {\n           list.add(100);\n       }\n   }\n```\n\n### 1.2 方式:2 依赖容器\n\n方式2是依赖于Spring容器的,所以要求我们在单测方法执行前来通知Mockito来处理\n他的逻辑,处理他说使用的注解。JUnit4的@Before注解就是做好的加载时机,因为我们\n可以这样写。\n\n```java \n   /**\n     * 将单测类中依赖Mockito的属性,进行处理。\n     * 帮我们实现 Mockito.mock()\n     */\n    @Before\n    public void setUp() {\n        MockitoAnnotations.initMocks(this);\n    }\n```\n\n## 二、Mockito必知概念\n\n### 2.1 完全模拟 Mock\n\n什么是完全模拟,使用的注解就是@Mock。被Mock的对象,所有的方法都不会被\n真正的执行。\n\n### 2.2 部分模拟 Spy\n\n部分模拟,使用的注解就是@Spy(间谍一样)。被声明的方法走Mock,没有声明的方法\n还是由实例进行执行和反馈。\n\n\n## 三、代码实例\n\n这里的例子我们为了启动快速,不依赖Spring容器。直接new出来对象。\n另外多说一句,其实就算依赖Spring容器,当@Before方法执行前所有的示例其实也都是已经注入好的了。\n\n下面所有的演示围绕这个类进行\n\n```java\npublic class MockitoEmp {\n        public String getName() {\n            return \"真实的MockitoTest\";\n        }\n\n        public Integer getAge() {\n            return 23;\n        }\n    }\n```\n### 3.1 @Mock\n\n手动声明\n\n```java\nMockitoEmp mock = Mockito.mock(MockitoEmp.class);\n```\n\n:::info 说明\n前面说了这个是完全模拟,所有的动作都是模拟的。看下面代码颜色\n标记的地方,我们只声明了getName使用Mock返回。但是当我们\n调用getAge() 的时候竟然也是假数据。\n:::\n\n基于注解和@Before自动声明\n\n```java {19,22}\n\npublic class MockitoTest {\n\n    // 整个对象都是Mock的\n    @Mock\n    private MockitoEmp mock = new MockitoEmp();\n\n    /**\n     * 将单测类中依赖Mockito的属性,进行处理。\n     * 帮我们实现 Mockito.mock()\n     */\n    @Before\n    public void setUp() {\n        MockitoAnnotations.initMocks(this);\n    }\n\n    @Test\n    public void testMock() {\n        Mockito.doReturn(\"Mock数据\").when(mock).getName();\n        //等价于Mockito.when(mock.getName()).thenReturn(\"Mock数据\");\n        // Mock数据\n        Assert.assertSame(\"Mock数据\", mock.getName());\n        // getAge() 方法没有用Mockito声明动作, 应该是多少呢?\n        Assert.assertSame(0, mock.getAge());\n        // 0\n        System.out.println(mock.getAge());\n    }\n}\n\n```\n\n### 3.2 @Spy\n\n手动声明\n\n```java\nMockitoEmp spy = Mockito.spy(MockitoEmp.class);\n```\n\n:::info 说明\nSpy部分模拟,下面的例子和上面基本一样,唯一不一样的是我们吧 @Mock换成了@Spy。\n此时getAge() 方法就不是模拟的了。\n:::\n\n基于注解和@Before自动声明\n\n```java {21,23}\n\npublic class MockitoTest {\n\n    // 整个对象都是Mock的\n    @Mock\n    private MockitoEmp mock = new MockitoEmp();\n\n    /**\n     * 将单测类中依赖Mockito的属性,进行处理。\n     * 帮我们实现 Mockito.mock()\n     */\n    @Before\n    public void setUp() {\n        MockitoAnnotations.initMocks(this);\n    }\n\n    @Test\n    public void testSpy() {\n        Mockito.doReturn(\"Mock数据\").when(spy).getName();\n        // Mock数据\n        Assert.assertSame(\"Mock数据\", spy.getName());\n        // getAge() 方法没有用Mockito声明动作, 应该是多少呢?\n        Assert.assertSame(23, spy.getAge());\n        // 23\n        System.out.println(spy.getAge());\n    }\n}\n\n```\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/test/MockitoAPI.md b/docs/learn/test/MockitoAPI.md
--- a/docs/learn/test/MockitoAPI.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/test/MockitoAPI.md	(date 1655373430286)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/test/启动缓慢.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 启动缓慢\n---\n\n:::info 启动缓慢分析\n\n当应用中拥有大对象,可能会导致单侧启动比较慢,针对这种问题有不同的解决方案\n\n:::\n\n\n\n### SpringBoot 2.2 解决方案\n\n```\nspring.main.lazy-initialization = true\n```\n\nSpringApplication 会自动添加一个叫 `LazyInitializationBeanFactoryPostProcessor`的处理器\n![](https://img.springlearn.cn/blog/learn_1617787733000.png)\n\n### SpringBoot 2.2 以前\n\n给应用上下文提前装载一个类似的处理器,然后通过 `BeanFactoryPostProcessor` 在容器刷新前循环将 `BeanDefinition` 声明懒加载\n\n```java\npublic class BeanLazyApplicationContextInitializer implements ApplicationContextInitializer<ConfigurableApplicationContext> {\n\n    @Override\n    public void initialize(ConfigurableApplicationContext applicationContext) {\n        applicationContext.addBeanFactoryPostProcessor(new LazyBeanDefinitionPostProcessor());\n    }\n\n    public static class LazyBeanDefinitionPostProcessor implements BeanFactoryPostProcessor, Ordered {\n\n        @Override\n        public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {\n            for (String beanName : beanFactory.getBeanDefinitionNames()) {\n                BeanDefinition beanDefinition = beanFactory.getBeanDefinition(beanName);\n                if (beanDefinition instanceof AbstractBeanDefinition) {\n                    beanDefinition.setLazyInit(true);\n                }\n            }\n        }\n\n        @Override\n        public int getOrder() {\n            return Ordered.HIGHEST_PRECEDENCE;\n        }\n    }\n\n}\n```\n\n:::tip 测试引导类配置变更\n\n- @ContextConfiguration 通过容器初始化去新增处理器\n- @ActiveProfiles       指定测试环境激活的配置是local\n:::\n\n\n@ContextConfiguration添加处理器\n```java\n@Slf4j\n@ActiveProfiles({\"local\"})\n@ContextConfiguration(initializers = {BeanLazyApplicationContextInitializer.class})\n// 使用Spring容器引导\n@RunWith(SpringRunner.class)\n@SpringBootTest(classes = {CenterProviderApplication.class}) // 指定启动类\npublic class BaseApplicationTest {\n    \n}\n```\n\n### 如何确定版本?\n\n`Idea` 中搜索 `@SpringApplication` 查看所在的包\n![](https://img.springlearn.cn/blog/learn_1617787113000.png)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/test/启动缓慢.md b/docs/learn/test/启动缓慢.md
--- a/docs/learn/test/启动缓慢.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/test/启动缓慢.md	(date 1655373430784)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/test/极限测试.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 极限测试\n---\n\n:::danger 极限测试\n\n- 最大值\n- 最小值\n- null值\n- 空值\n- 异常\n  :::\n\n### 这段代码会执行通过吗?\n\n```java \n  int a = 24 * 24 * 60 * 60 * 1000;\n  int b = 25 * 24 * 60 * 60 * 1000;\n  Assert.assertTrue(b > a);\n```\n\n关于测试用例的要思考下是否要使用极限值,验证。\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/test/极限测试.md b/docs/learn/test/极限测试.md
--- a/docs/learn/test/极限测试.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/test/极限测试.md	(date 1655373430597)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/test/如何知道是否依赖Spring容器.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: ②如何知道是否依赖Spring容器\n---\n\n\n默认使用 `BlockJUnit4ClassRunner` 来进行运行。即不依赖容器。\n假如说如果需要容器怎么办呢 ? <Version>基于SpringBoot 2.1.x版本分析</Version>\n\n```java\n@RunWith(SpringRunner.class)\n@SpringBootTest(classes = {Application.class}) // 指定启动类\npublic class BaseApplicationTest {\n}\n```\n\n- SpringRunner告诉JUnit要使用Spring容器\n- SpringBootTest告诉JUnit容器的引导类是这个\n\n\nJUnit是如何实现的呢?\n\n![](https://img.springlearn.cn/blog/learn_1617791013000.png)\n\n前面启动类中我们使用的注解是 `@RunWith` 和 `@SpringBootTest` 那么哪里来解析这个的呢?\n\n\n![](https://img.springlearn.cn/blog/learn_1617791209000.png)\n\n\n由此 `JUnit` 知道要使用 `SpringRunner` 进行引导。\n\n由上图我们知道 `SpringRunner` 实例化的入参就是当前的测试类。那么后续所有的奥妙就在这里了。\n我们跟进构造往下追究。\n\n![](https://img.springlearn.cn/blog/learn_1617795279000.png)\n\n`BootstrapUtils#resolveTestContextBootstrapper`\n拿到SpringBoot的测试引导类 `SpringBootTestContextBootstrapper`\n\n![](https://img.springlearn.cn/blog/learn_1617795346000.png)\n\n拿到SpringBoot容器的启动 `Main` 函数。\n\n到此已经拿到了所有的SpringBoot容器启动参数了。\n\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/test/如何知道是否依赖Spring容器.md b/docs/learn/test/如何知道是否依赖Spring容器.md
--- a/docs/learn/test/如何知道是否依赖Spring容器.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/test/如何知道是否依赖Spring容器.md	(date 1655373430105)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/test/消息验证.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 消息验证\n---\n\n:::info\n\n这一是凑数的,想表达的内容只有一点: 消息入口不应该出现复杂的业务逻辑。\n对于消息的验证,我们只需要验证消息收发是否正常即可。处理方案就是将消息与\n业务分离测试。\n\n:::\n\neg:\n\nMessage入口就类似于Web入口一样。我们复杂的业务逻辑一定不会再入口处直接写代码，\n如果是这样写的那么维护性和复用性一定是很差的。\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/test/消息验证.md b/docs/learn/test/消息验证.md
--- a/docs/learn/test/消息验证.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/test/消息验证.md	(date 1655373430379)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/maven/README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: auto\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: Maven基础入门\ncategory: Maven\n---\n\n\n> Maven 翻译为\"专家\"、\"内行\"，是 Apache 下的一个纯 Java 开发的开源项目。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。\nMaven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。\nMaven 也可被用于构建和管理各种项目，例如 C#，Ruby，Scala 和其他语言编写的项目。Maven 曾是 Jakarta 项目的子项目，现为由 Apache 软件基金会主持的独立 Apache 项目。\n\n## Maven 默认插件\n\n已知 Maven 使用 plugin 来执行实际操作的，在默认情况下，Maven 会绑定以下几个插件来完成基本操作。\n\n| plugin                 | function                                              | life cycle phase        |\n| ---------------------- | ----------------------------------------------------- | ----------------------- |\n| maven-clean-plugin     | 清理上一次执行创建的目标文件                          | clean                   |\n| maven-resources-plugin | 处理源资源文件和测试资源文件                          | resources,testResources |\n| maven-compiler-plugin  | 编译源文件和测试源文件                                | compile,testCompile     |\n| maven-surefire-plugin  | 执行测试文件                                          | test                    |\n| maven-jar-plugin       | 创建 jar                                              | jar                     |\n| maven-install-plugin   | 安装 jar，将创建生成的 jar 拷贝到 .m2/repository 下面 | install                 |\n| maven-deploy-plugin    | 发布 jar                                              | deploy                  |\n\n如果针对各个 plugin 有特殊配置的话，需要显示指定 plugin 和 属性配置。\n\n\n## Maven 生命周期\n\n> 官网地址: http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html\n\n下面列出了default,clean和site生命周期的所有构建阶段，它们按照指定的时间点之前的顺序执行。\n\n`mvn test -X` 查看debug日志\n\n```\n[DEBUG] Lifecycle clean -> [pre-clean, clean, post-clean]\n[DEBUG] Lifecycle site -> [pre-site, site, post-site, site-deploy]\n[DEBUG] Lifecycle default -> [validate, initialize, generate-sources, process-sources, generate-resources, process-resources, compile, process-classes, generate-test-sources, process-test-sources, generate-test-resources, process-test-resources, test-compile, process-test-classes, test, prepare-package, package, pre-integration-test, integration-test, post-integration-test, verify, install, deploy]\n```\n\n### default生命周期\n\n| 阶段                      | 描述                                                         |\n| :------------------------ | :----------------------------------------------------------- |\n| `validate`                | 验证项目是否正确并且所有必要的信息都可用。                   |\n| `initialize`              | 初始化构建状态，例如设置属性或创建目录。                     |\n| `generate-sources`        | 生成包含在编译中的任何源代码。                               |\n| `process-sources`         | 处理源代码，例如过滤任何值。                                 |\n| `generate-resources`      | 生成包含在包中的资源。                                       |\n| `process-resources`       | 将资源复制并处理到目标目录中，准备打包。                     |\n| `compile`                 | 编译项目的源代码。                                           |\n| `process-classes`         | 对编译生成的文件进行后处理，例如对 Java 类进行字节码增强。   |\n| `generate-test-sources`   | 生成任何测试源代码以包含在编译中。                           |\n| `process-test-sources`    | 处理测试源代码，例如过滤任何值。                             |\n| `generate-test-resources` | 创建用于测试的资源。                                         |\n| `process-test-resources`  | 将资源复制并处理到测试目标目录中。                           |\n| `test-compile`            | 将测试源代码编译到测试目标目录中                             |\n| `process-test-classes`    | 对测试编译生成的文件进行后处理，例如对 Java 类进行字节码增强。 |\n| `test`                    | 使用合适的单元测试框架运行测试。这些测试不应该要求打包或部署代码。 |\n| `prepare-package`         | 在实际包装之前执行准备包装所需的任何操作。这通常会导致包的解压缩、处理版本。 |\n| `package`                 | 获取编译后的代码并将其打包为其可分发格式，例如 JAR。         |\n| `pre-integration-test`    | 在执行集成测试之前执行所需的操作。这可能涉及诸如设置所需环境之类的事情。 |\n| `integration-test`        | 如有必要，处理并部署包到可以运行集成测试的环境中。           |\n| `post-integration-test`   | 执行集成测试后执行所需的操作。这可能包括清理环境。           |\n| `verify`                  | 运行任何检查以验证包裹是否有效并符合质量标准。               |\n| `install`                 | 将包安装到本地存储库中，用作本地其他项目的依赖项。           |\n| `deploy`                  | 在集成或发布环境中完成，将最终包复制到远程存储库以与其他开发人员和项目共享。 |\n\n### site生命周期\n\n| 阶段          | 描述                                     |\n| :------------ | :--------------------------------------- |\n| `pre-site`    | 在实际项目现场生成之前执行所需的流程     |\n| `site`        | 生成项目的站点文档                       |\n| `post-site`   | 执行完成站点生成和准备站点部署所需的流程 |\n| `site-deploy` | 将生成的站点文档部署到指定的 Web 服务器  |\n\n\n### clean生命周期\n\n| 阶段         | 描述                             |\n| :----------- | :------------------------------- |\n| `pre-clean`  | 在实际项目清理之前执行所需的流程 |\n| `clean`      | 删除先前构建生成的所有文件       |\n| `post-clean` | 执行完成项目清理所需的流程       |\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/maven/README.md b/docs/learn/maven/README.md
--- a/docs/learn/maven/README.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/maven/README.md	(date 1655373430360)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: auto
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/test/影响范围.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 影响范围\n---\n\n\n:::danger 注意影响\n\n所有的单测一定针对不是生产环境,一般线上发布我们会声明不运行单测。\n如何考虑环境因素呢?\n\n两个解决办法:\n- 应用维度环境分离 spring.profiles.active=test\n- 测试基类指定环境 @ActiveProfiles(\"test\")\n  :::\n\n\n## 一、影响范围考虑哪些因素?\n\n\n### 1.1 是否影响测试环境?\n\n可以设置单测事务不提交,保证对数据无影响。\n\n### 1.2 是否对业务无影响?\n\n检查是否做了环境隔离。\n\n### 1.3 是否可重复跑?\n\n如果前两点都已经解决,那么就可以重复跑。\n重复跑可以模拟验证幂等或者重复提交的问题。\n\n## 三、什么时候写单测\n\n后端开发进度: 开发50% + 单元测试30% + 联调20%\n\n1. 自己代码开发完成后,就应该进行单测。\n2. 自己代码开发完了,其他人没有开发完。可以进行Mockito单测,先确保自己的代码没问题。\n3. 对自己负责的功能模块进行单测维护。\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/test/影响范围.md b/docs/learn/test/影响范围.md
--- a/docs/learn/test/影响范围.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/test/影响范围.md	(date 1655373430131)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/test/SpringBootTesting.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: SpringBoot Testing\n---\n\n![](https://img.springlearn.cn/blog/learn_1618140868000.png)\n\n前面我们对Mockito的用法有了一个了解,这里告诉大家一个好消息,SpringBoot已经帮我们继承了\n这些框架,而且提供了更加简单好用的API。\n\n\n## 一、Mockito加载方式\n\n前面我们说了两种加载方式 `MockitoJUnitRunner` 和 ` MockitoAnnotations.initMocks(this);`\n这些在SpringBoot中都不需要了。\n\n所以这一段就是废话, 不用在看了。但是相信你已经看完了。\n\n## 二、Mockito必知概念\n\n这些概念,参考Mockito章节,概念统统保留。\n\n### 2.1 完全模拟 MockBean\n\n只需要将@Mock 换成 @MockBean即可\n\n### 2.2 部分模拟 SpyBean\n\n只需要将@Spy 换成 @MockBean即可。主要这里有一个小坑。\n如果是Feign接口,使用@SpyBean会报错。提示final class不能被代理。\n\n原因是SpringBoot依赖的Mockito版本太古老了,是2.23.4。从Mockito2.7.6\n开始已经解决了这个问题, 我们可以通过引入下面依赖解决。\n\n```xml\n <dependency>\n    <groupId>org.mockito</groupId>\n    <artifactId>mockito-inline</artifactId>\n    <version>3.3.3</version>\n</dependency>\n```\n\n解决方案就是帮我们新增了一个配置,启动Mockit的插件来生成代理。\n大概原理就是及不实用JDK代理,也不是Cglib代理。\n`DefaultMockitoPlugins` & `InlineByteBuddyMockMaker`\n![](https://img.springlearn.cn/blog/learn_1617877205000.png)\n\n\n## 三、代码实例\n\n\n### 3.1 @MockBean 完全模拟\n\n没有被声明的方法返回值,对象类型返回null,基本类型是返回默认类型。\n\n@MockBean完全模拟\n\n```java\n\n\npublic class TradeShopIntegrationImplTest extends BaseApplicationTest {\n\n    @Autowired\n    private TradeShopIntegration shopBrandIntegration;\n\n    @MockBean\n    private BrandServiceApi brandService;\n    \n    @MockBean\n    private GoodsStockApi goodsStockApi;\n    \n    @Test\n    public void testGetAllBrands() {\n        Mockito.doReturn(JsonResult.failure(\"fail\")).when(goodsStockApi).getSkuList(Mockito.any());\n        // 底层调用的是goodsStockApi.getSkuList()\n        List<GoodsBaseMsgDTO> goodsBaseMsgDTOS = shopBrandIntegration.queryAllSku();\n        // 因为前面声明了返回fail。所以这里没有数据返回。\n        JsonConsoleUtils.println(goodsBaseMsgDTOS);\n        // 这里因为使用的是Mock完全模拟,所以尽管前面没有声明返回值,就默认返回null\n        List<OutBrandDTO> allBrands = shopBrandIntegration.getAllBrands();\n        JsonConsoleUtils.println(allBrands);\n    }\n    \n}    \n```\n\n### 3.1 @SpyBean 部分模拟\n\n没有被声明的方法返回值,走原来逻辑。\n\n@SpyBean部分模拟\n\n```java {22}\n\n\npublic class TradeShopIntegrationImplTest extends BaseApplicationTest {\n\n    @Autowired\n    private TradeShopIntegration shopBrandIntegration;\n\n    @MockBean\n    private BrandServiceApi brandService;\n    \n    @MockBean\n    private GoodsStockApi goodsStockApi;\n    \n    @Test\n    public void testGetAllBrands() {\n        Mockito.doReturn(JsonResult.failure(\"fail\")).when(goodsStockApi).getSkuList(Mockito.any());\n        // 底层调用的是goodsStockApi.getSkuList()\n        List<GoodsBaseMsgDTO> goodsBaseMsgDTOS = shopBrandIntegration.queryAllSku();\n        // 因为前面声明了返回fail。所以这里没有数据返回。\n        JsonConsoleUtils.println(goodsBaseMsgDTOS);\n        // 这里跟上面的区别就是,如果没有声明返回值,就走原来的方法。\n        List<OutBrandDTO> allBrands = shopBrandIntegration.getAllBrands();\n        JsonConsoleUtils.println(allBrands);\n    }\n    \n}    \n```\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/test/SpringBootTesting.md b/docs/learn/test/SpringBootTesting.md
--- a/docs/learn/test/SpringBootTesting.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/test/SpringBootTesting.md	(date 1655373430362)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/test/谁在调用JUnit.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: ①谁在调用JUnit\n---\n\n当点击了执行单例,发生了什么事情? <Version>基于SpringBoot 2.1.x版本分析</Version>\n\n![](https://img.springlearn.cn/blog/learn_1617790044000.png)\n\n可以看到idea会将单侧的类和方法传递给JUnit。最终由\n\n![](https://img.springlearn.cn/blog/learn_1617790263000.png)\n\n\n可以看到最终是由 `AllDefaultPossibilitiesBuilder` 来进行了承接 。所以到这里我们就找到了入口。后续所有的能力,都要从JUnit中去寻找了。\n\n```java\n    @Override\n    public Runner getRunner() {\n        if (runner == null) {\n            synchronized (runnerLock) {\n                if (runner == null) {\n                    runner = new AllDefaultPossibilitiesBuilder(canUseSuiteMethod).safeRunnerForClass(fTestClass);\n                }\n            }\n        }\n        return runner;\n    }\n```\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/test/谁在调用JUnit.md b/docs/learn/test/谁在调用JUnit.md
--- a/docs/learn/test/谁在调用JUnit.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/test/谁在调用JUnit.md	(date 1655373430247)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/.vuepress/public/js/.qiniu_pythonsdk_hostscache.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>{\"http:3jws4LSQj3Nwi_bWktpNReSf2Rh4D4CU6rTcZlrA:springlearn\": {\"upHosts\": [\"http://up.qiniu.com\", \"http://upload.qiniu.com\", \"-H up.qiniu.com http://183.131.7.3\"], \"ioHosts\": [\"http://iovip.qbox.me\"], \"deadline\": 1652082498}}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/.vuepress/public/js/.qiniu_pythonsdk_hostscache.json b/docs/.vuepress/public/js/.qiniu_pythonsdk_hostscache.json
--- a/docs/.vuepress/public/js/.qiniu_pythonsdk_hostscache.json	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/.vuepress/public/js/.qiniu_pythonsdk_hostscache.json	(date 1655370038219)
@@ -1,1 +1,1 @@
-{"http:3jws4LSQj3Nwi_bWktpNReSf2Rh4D4CU6rTcZlrA:springlearn": {"upHosts": ["http://up.qiniu.com", "http://upload.qiniu.com", "-H up.qiniu.com http://183.131.7.3"], "ioHosts": ["http://iovip.qbox.me"], "deadline": 1652082498}}
\ No newline at end of file
+{"http:3jws4LSQj3Nwi_bWktpNReSf2Rh4D4CU6rTcZlrA:springlearn": {"upHosts": ["http://up.qiniu.com", "http://upload.qiniu.com", "-H up.qiniu.com http://183.131.7.3"], "ioHosts": ["http://iovip.qbox.me"], "deadline": 1655456438}}
\ No newline at end of file
Index: docs/learn/test/JUnitAPI.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: JUnit API\n---\n\n\n:::tip\n只打印的单测是没有意义的,正确使用单测工具, 提高单测质量。\n:::\n\n\n\n## 一、常用注解\n\n### 1.1 @Before & @After\n\n单测类中每个单测方法执行都会触发这两个方法\n\n```java \n    @Before\n    public void before() {\n        System.out.println(\"before\");\n    }\n\n    @After\n    public void after() {\n        System.out.println(\"after\");\n    }\n```\n\n### 1.2 @BeforeClass & @AfterClass\n\n区别与上一个,不管单测类中有几个单测方法,都只会执行一次\n\n要用静态修饰\n\n```java \n    @BeforeClass\n    public static void beforeClass() {\n        System.out.println(\"beforeClass\");\n    }\n\n    @AfterClass\n    public static void afterClass() {\n        System.out.println(\"afterClass\");\n    }\n```\n\n:::info 代码实例\n\n针对上面说的两个注解演示一下\n\n- beforeClass\n- before\n- testOne\n- after\n- before\n- testTwo\n- after\n- afterClass\n  :::\n\n---\n```java\npublic class JUnitTest {\n\n    @BeforeClass\n    public static void beforeClass() {\n        System.out.println(\"beforeClass\");\n    }\n\n    @Before\n    public void before() {\n        System.out.println(\"before\");\n    }\n\n    @Test\n    public void testOne() {\n        System.out.println(\"testOne\");\n    }\n\n    @Test\n    public void testTwo() {\n        System.out.println(\"testTwo\");\n    }\n\n    @AfterClass\n    public static void afterClass() {\n        System.out.println(\"afterClass\");\n    }\n\n    @After\n    public void after() {\n        System.out.println(\"after\");\n    }\n}\n\n```\n\n### 1.3 @Timed\n\n被修饰的方法会加上一个时间限制,如果超过了指定的时间范围,就算单侧代码执行成功\n了也被认为是失败。(注意该方法依赖于SpringBoot容器)\n\n@Timed\n\n```java\n    @Test\n    @Timed(millis = 2000)\n    public void testTimeout() {\n        System.out.println(\"testOne\");\n    }\n```\n\n### 1.4 @Repeat\n\n指定当前单测方法被执行的次数,如果被该注解修饰\n将会被重复执行。(注意该方法依赖于SpringBoot容器)\n\n@Repeat\n\n```java\n    @Test\n    @Repeat(3)\n    public void testOne() {\n        System.out.println(\"testOne\");\n    }\n```\n\n## 二、断言API\n\n断言的好处在于程序帮忙判断单测结果。不需要人工在接入验证数据。JUnit的口号就是\n\n`keep the bar green to keep the code clean。`\n\n一个不用观察输出就知道代码有没有问题的高效单元测试工具。\n\n```\nimport org.hamcrest.Matchers;\nimport org.hamcrest.core.AllOf;\nimport org.hamcrest.core.AnyOf;\n```\n\n### 2.1 Matchers\n\nMatchers\n```java\n        // 是否相等\n        Assert.assertThat(2, Matchers.is(2));\n        // 2 小于等于2\n        Assert.assertThat(2,Matchers.lessThanOrEqualTo(2));\n        Map<String,String> map = new HashMap<>();\n        map.put(\"name\",\"jay\");\n        // map 中是否包含key为name的元素\n        Assert.assertThat(map,Matchers.hasKey(\"name\"));\n        // map 中是否包含value为jay的元素\n        Assert.assertThat(map,Matchers.hasValue(\"jay\"));\n        // map 中是否包含name等于jay的元素\n        Assert.assertThat(map,Matchers.hasEntry(\"name\",\"jay\"));\n```\n### 2.2 AllOf\n全部满足\n\n```java\n   // 2 小于4同时也小于3\n   Assert.assertThat(2, AllOf.allOf(Matchers.lessThan(4), Matchers.lessThan(3)));\n```\n### 2.3 AnyOf\n\n任意满足\n\n```java\n   // 2 大于1小于3\n   Assert.assertThat(2, AnyOf.anyOf(Matchers.greaterThan(1), Matchers.lessThan(3)));\n```\n\n## 三、结果验证\n\n### 3.1 空值验证\n\n```java\n    @Test\n    public void test() {\n        Object o = new Object();\n        // 非空验证\n        Assert.assertNotNull(o);\n        // 空值验证\n        Assert.assertNull(null);\n    }    \n```\n\n### 3.2 逻辑验证\n\n```java\n    import static org.hamcrest.MatcherAssert.*;\n    import static org.hamcrest.CoreMatchers.*;\n    public calss Test{\n        @Test\n        public void test() {\n            //测试变量是否大于指定值\n            ArrivalNoticeOrderDO ao = new ArrivalNoticeOrderDO();\n            ao.setId(12L);\n            //测试所有条件必须成立\n            assertThat(ao.getId(), allOf(is(12L)));\n            //测试只要有一个条件成立\n            assertThat(ao.getId(), anyOf(is(50), is(12L)));\n            //测试变量值等于指定值\n            assertThat(ao.getId(), is(12L));\n        }\n    }\n```\n\n### 3.3 异常验证\n\n```java\n    /**\n     * 预期异常\n     */\n    @Test(expected = NullPointerException.class)\n    public void testError(){\n        Object o = null;\n        System.out.println(o.toString());\n    }\n```\n\n\n## 四、快速创建\n\n建议使用 `Idea` 自动创建, 不要手动创建。\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/test/JUnitAPI.md b/docs/learn/test/JUnitAPI.md
--- a/docs/learn/test/JUnitAPI.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/test/JUnitAPI.md	(date 1655373430776)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: .idea/modules.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"ProjectModuleManager\">\n    <modules>\n      <module fileurl=\"file://$PROJECT_DIR$/.idea/blog.iml\" filepath=\"$PROJECT_DIR$/.idea/blog.iml\" />\n    </modules>\n  </component>\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/modules.xml b/.idea/modules.xml
--- a/.idea/modules.xml	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/.idea/modules.xml	(date 1654753644222)
@@ -2,7 +2,7 @@
 <project version="4">
   <component name="ProjectModuleManager">
     <modules>
-      <module fileurl="file://$PROJECT_DIR$/.idea/blog.iml" filepath="$PROJECT_DIR$/.idea/blog.iml" />
+      <module fileurl="file://$PROJECT_DIR$/.idea/JavaGuide.iml" filepath="$PROJECT_DIR$/.idea/JavaGuide.iml" />
     </modules>
   </component>
 </project>
\ No newline at end of file
Index: docs/learn/网站地图.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: false\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: true\nfooter: true\nbacktotop: true\nlayout: NewLayout\ntitle: 重剑无锋大巧不工\nnoPageCopyright: true\nblankHome: true\n---\n\n[//]: # (<MacbookAir/>)\n[//]: # (![]&#40;https://img.springlearn.cn/blog/learn_1648126927000.png&#41;)\n\n[//]: # (<Coding/>)\n\n<Djt/>\n\n\n![](https://img.springlearn.cn/blog/learn_1610273706000.png)\n\n\n![](https://img.springlearn.cn/blog/learn_1610273619000.png)\n\n\n<DownloadBtn url='https://nodejs.org/dist/v15.9.0/node-v15.9.0.pkg' />\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/网站地图.md b/docs/learn/网站地图.md
--- a/docs/learn/网站地图.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/网站地图.md	(date 1655373430339)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: false
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/test/JUnit单测类属性注入.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: JUnit单测类属性注入\n---\n\n\n通过前面的阅读我们已经能拿到了所有的容器启动参数。那么我们可以思考下。我们自己的\n单测类其实并没有交给容器来管理,那么我们的单测类中的属性都是什么时候注入的呢?\n\n答案就在 `TestExecutionListener`\n\n```java\npublic interface TestExecutionListener {\n\n\tdefault void beforeTestClass(TestContext testContext) throws Exception {\n\t}\n\n\tdefault void prepareTestInstance(TestContext testContext) throws Exception {\n\t}\n\n\tdefault void beforeTestMethod(TestContext testContext) throws Exception {\n\t}\n\n\tdefault void beforeTestExecution(TestContext testContext) throws Exception {\n\t}\n\n\tdefault void afterTestExecution(TestContext testContext) throws Exception {\n\t}\n\n\tdefault void afterTestMethod(TestContext testContext) throws Exception {\n\t}\n\n\tdefault void afterTestClass(TestContext testContext) throws Exception {\n\t}\n\n}\n```\n\n\n![](https://img.springlearn.cn/blog/learn_1617795655000.png)\n\n通过名字我们发现了貌似一个可以进行依赖注入的类。没错就是在这里,在单侧方法执行前。通过\n\n```java\npublic class DependencyInjectionTestExecutionListener extends AbstractTestExecutionListener {\n\t@Override\n\tpublic void beforeTestMethod(TestContext testContext) throws Exception {\n\t\tif (Boolean.TRUE.equals(testContext.getAttribute(REINJECT_DEPENDENCIES_ATTRIBUTE))) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Reinjecting dependencies for test context [\" + testContext + \"].\");\n\t\t\t}\n\t\t\tinjectDependencies(testContext);\n\t\t}\n\t}\n\n\tprotected void injectDependencies(TestContext testContext) throws Exception {\n\t\tObject bean = testContext.getTestInstance();\n\t\tClass<?> clazz = testContext.getTestClass();\n\t\tAutowireCapableBeanFactory beanFactory = testContext.getApplicationContext().getAutowireCapableBeanFactory();\n\t\tbeanFactory.autowireBeanProperties(bean, AutowireCapableBeanFactory.AUTOWIRE_NO, false);\n\t\tbeanFactory.initializeBean(bean, clazz.getName() + AutowireCapableBeanFactory.ORIGINAL_INSTANCE_SUFFIX);\n\t\ttestContext.removeAttribute(REINJECT_DEPENDENCIES_ATTRIBUTE);\n\t}\n}\t\n```\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/test/JUnit单测类属性注入.md b/docs/learn/test/JUnit单测类属性注入.md
--- a/docs/learn/test/JUnit单测类属性注入.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/test/JUnit单测类属性注入.md	(date 1655373430756)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/test/测试成本.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 测试成本\n---\n\n\n:::info\n测试成本到底有多大? 你认为你写的代码需不需要测试? 为了引出成本的话题, 我们先从实际工作中出发\n看看你能否经受住这些灵魂的考验吧。\n:::\n\n\n## 一、灵魂深处的拷问\n\n- 你的代码质量如何度量？\n- 你是如何保证代码质量？\n- 你敢随时重构代码吗？\n- 你是如何确保重构的代码依然保持正确性？\n- 你是否有足够信心在没有测试的情况下随时发布你的代码？\n\n\uD83D\uDCE2 如果答案都比较犹豫，那么就证明我们非常需要单元测试。(ps: 不会有人心里想的是我们需要测试同学吧 \uD83D\uDE0F)\n\n==它能带给我们很多保障：==\n\n---\n- 代码质量持续有保障\n- 重构正确性保障\n- 增强自信心\n- 自动化运行\n---\n\nWeb 应用中的单元测试更加重要，在 Web 产品快速迭代的时期，每个测试用例都给应用的稳定性提供了一层保障。 API 升级，测试用例可以很好地检查代码是否向下兼容。 对于各种可能的输入，一旦测试覆盖，都能明确它的输出。 代码改动后，可以通过测试结果判断代码的改动是否影响已确定的结果。\n\n所以，应用的 Controller、Service、Common、Manager 等代码，都必须有对应的单元测试保证代码质量。 当然，框架和插件的每个功能改动和重构都需要有相应的单元测试，并且要求尽量做到修改的代码能被 100% 覆盖到。\n\n特别是中大型项目，经过多年的代码迭代，业务逻辑复杂，代码改动很容易牵一发动全身，\n单元测试就能给应用的稳定性提供了一层保障。不用面对qa的灵魂拷问：\n\n<Highlight color=\"#ff603f\">为什么老是你的bug最多！</Highlight>\n\n\n## 二、单测是手段不是目的\n\n> 单测行覆盖率高不代表应用的质量就一定高,但是单测行覆盖率低一定代表着这个应用出现质量问题的可能性就越大\n\n还是引用前面话,我们不要为了单测而写单测,如果是把单测当做是目的来做,那么就偏离了单测的意义,自然而然你就认为\n这个单测的成本是高的。... ... ... ... ... ... ... <Highlight color=\"#ff603f\">你品你细品</Highlight>\n\n![](https://img.springlearn.cn/blog/learn_1618049846000.png)\n\n## 三、软件的质量不是测试出来的，而是设计和维护出来的\n\n<Highlight color=\"#ff603f\">你品你细品</Highlight>\n\n![](https://img.springlearn.cn/blog/learn_1618206722000.png)\n\n作为底层开发人员, 我们清晰每一行代码, 也就是最小执行单元。哪里容易出现错误，这次改造涉及到了那些代码。一线开发人员一定是最清楚的人,没有之一。\n\n从这个角度来了, 这就不是成本的问题了, 是职责范围内的事情。\n\n如果单元测试都不做,就好比我去街上买鸡蛋, 我问老板鸡蛋是好是坏, 老板说我不知道, 然后说坏了拿来可以换。\n你认为那个成本更大呢? 那个代价更大呢? 玩意坏鸡蛋把人吃坏了，这老板岂不是赔了夫人又折兵,还要受到法律的制裁?\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/test/测试成本.md b/docs/learn/test/测试成本.md
--- a/docs/learn/test/测试成本.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/test/测试成本.md	(date 1655373430442)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/test/异步验证.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 异步验证\n---\n\n\n:::danger 请听题\n对于下面这段代码你觉得单测能通过吗?\n:::\n\n异步场景\n\n```java\n    @Test\n    public void test() {\n        ExecutorService executorService = Executors.newFixedThreadPool(3);\n        executorService.submit(new Runnable() {\n            @SneakyThrows\n            @Override\n            public void run() {\n                Thread.sleep(5000);\n                Object obj = null;\n                System.out.println(obj.toString());\n            }\n        });\n        System.out.println(\"单侧结束\");\n    }\n```\n\n## 一、常用解决方案\n\n### 1.1 white解决简单暴力\n\nwhite解决\n```java\n    @Test\n    public void test() {\n        ExecutorService executorService = Executors.newFixedThreadPool(3);\n        executorService.submit(new Runnable() {\n            @SneakyThrows\n            @Override\n            public void run() {\n                Thread.sleep(5000);\n                Object obj = null;\n                System.out.println(obj.toString());\n            }\n        });\n        System.out.println(\"单侧结束\");\n        white(true);\n    }\n```\n\n### 1.2 LockSupport最大时间限制\n\nLockSupport.parkNanos()线程挂起\n```java\n    @Test\n    public void test() {\n        ExecutorService executorService = Executors.newFixedThreadPool(3);\n        executorService.submit(new Runnable() {\n            @SneakyThrows\n            @Override\n            public void run() {\n                Thread.sleep(5000);\n                Object obj = null;\n                System.out.println(obj.toString());\n            }\n        });\n        System.out.println(\"单侧结束\");\n         // 挂起指定时间\n        LockSupport.parkNanos(TimeUnit.SECONDS.toNanos(6));\n    }\n```\n\n## 二、基于上面两种配合JUnit定制\n\n### 2.1 使用演示\n\n\n\n\n\uD83D\uDCE2 注意这里的 @Timed 原生是不具备这个能力的,要基于JUnit进行扩展。\n\n@Timed 灵活控制时间\n```java {2}\n    @Test\n    @Timed(millis = 5000)\n    public void test() {\n        ExecutorService executorService = Executors.newFixedThreadPool(3);\n        executorService.submit(new Runnable() {\n            @SneakyThrows\n            @Override\n            public void run() {\n                Thread.sleep(5000);\n                System.out.println(\"任务执行结束\");\n            }\n        });\n        System.out.println(\"单侧结束\");\n    }\n```\n\n### 2.2 扩展实现\n\n同样是基于LockSupport线程挂起方案,类似于切面解决。\n\n扩展TestExecutionListener\n\n```java {39}\n\n    private Map<String, Long> timedMap = new HashMap<>();\n\n    private Map<String, Long> beforeTestCostMap = new HashMap<>();\n    \n    @Override\n    public void beforeTestMethod(TestContext testContext) throws Exception {\n        String key = testContext.getTestMethod().getName();\n        beforeTestCostMap.put(key, System.currentTimeMillis());\n        Timed timedA = AnnotationUtils.getAnnotation(testContext.getTestMethod(), Timed.class);\n        if (Objects.nonNull(timedA)) {\n            timedMap.put(testContext.getTestMethod().getName(), timedA.millis());\n        }\n        Method testMethod = testContext.getTestMethod();\n        printActiveProfile(testContext);\n        checkTransactional(testContext);\n        TestConsole.colorPrintln(AnsiColor.BLUE, \"西魏陶渊明发起了一个单侧用例: {}#{}\", testContext.getTestClass(), testMethod.getName());\n    }\n\n    @Override\n    public void afterTestMethod(TestContext testContext) throws Exception {\n        String key = testContext.getTestMethod().getName();\n        Long afterTestCost = System.currentTimeMillis();\n        Long beforeTestCost = beforeTestCostMap.get(key);\n        long timed = timedMap.get(key);\n        // 如果耗时已经大于指定的时间了,就直接过\n        if ((timed <= 0) || afterTestCost - beforeTestCost > timed) {\n            Throwable testException = testContext.getTestException();\n            if (Objects.nonNull(testException)) {\n                TestConsole.colorPrintln(AnsiColor.BRIGHT_RED, \"测试用例执行失败了,快检查检查吧。\uD83D\uDE92\");\n            } else {\n                TestConsole.colorPrintln(\"用例执行成功。\uD83D\uDCAA\");\n            }\n        } else {\n            // 如果不够,就要挂起指定时间。（减去1000毫秒,给Timed预留的时间）\n            long nanos = TimeUnit.MILLISECONDS.toNanos(timed - (afterTestCost - beforeTestCost) - 1000);\n            // 主线程挂起,等待异步执行\n            System.err.printf(\"Timed任务挂起通知: 主线程挂起%d s,等待异步执行%n\", TimeUnit.NANOSECONDS.toSeconds(nanos));\n            LockSupport.parkNanos(nanos);\n        }\n\n    }\n```\n\n### 2.3 引导类配置\n\n- @TestExecutionListeners 注意声明添加模式是合并(默认是替换)\n\n```java {7}\n@Slf4j\n@ActiveProfiles({\"local\"})\n@ContextConfiguration(initializers = {BeanLazyApplicationContextInitializer.class})\n// 使用Spring容器引导\n@RunWith(SpringRunner.class)\n// 合并模式下,增加测试执行监听器\n@TestExecutionListeners(value = PmsSentryTestExecutionListener.class, mergeMode = TestExecutionListeners.MergeMode.MERGE_WITH_DEFAULTS)\n// 默认就是回滚,不用加@Rollback,如果全局不想回滚就在这个吧@Rollback(false),如果某个单测不想回滚,就放到单侧类上\n@Transactional\n@SpringBootTest(classes = {CenterProviderApplication.class}) // 指定启动类\npublic class BaseApplicationTest {\n}\n```\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/test/异步验证.md b/docs/learn/test/异步验证.md
--- a/docs/learn/test/异步验证.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/test/异步验证.md	(date 1655373430422)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/mybatis/Mybatissql日志打印.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: true\nfooter: true\nbacktotop: true\ntitle: 第13篇:Mybatis中打印Sql信息\ncategory: Mybatis\n---\n\n\n::: tip Sql打印需求\n在Mybatis中如果我们要对我们的sql信息进行检查, 只能启动Spring容器, 去执行根据成功和失败来判断我们的逻辑是否有问题。\n此时会比较耗时,因为要启动容器。基于这个痛点, 本文要设计一个工具。使我们不依赖Spring容器,也不依赖任何外部插件，直接就把\nSql信息的打印出来。\n:::\n\n仓库地址: https://github.com/lxchinesszz/mybatis-sql-helper\n\n\n使用方法\n\n```java \nOrderBatchEntityQuery query = JMockData.mock(OrderBatchEntityQuery.class);\n// 如果需要绑定xml就使用bindMapper\nQuickMapperChecker.analyse(QuickMapperChecker.mock(IOrderMapper.class).list(query))\n   .bindMapper(\"mapper/center/ReplenishOrderMapper.xml\").printSql();   \n// 如果完全依赖注解跟简单\nQuickMapperChecker.analyse(QuickMapperChecker.mock(IOrderMapper.class).list(query))\n   .printSql();   \n```\n\n## 一、设计思路\n\n\n![](https://img.springlearn.cn/blog/learn_1651310469000.png)\n\n基于前面我们对Mybatis的学习,我们知道所有的sql信息,都会被解析成MappedStatement,并保存在 Configuration。\n那么我们要做的\n\n第一步就是解析sql信息成MappedStatement。而在Mybatis中的sql是可以写在Mapper.xml也可以使用注解形式,\n直接写到接口类中的。\n\n第二个知识点,Mybatis中是可以使用很多标签的如 <where/> <if/> <foreach/> <include/> 这些标签要先处理成sql信息。\n\n第三步组装sql信息, 前面的学习我们知道sql信息如果是$变量符,那么会在直接会编译成sql信息。而动态sql是由DynamicSqlSource来直接解析参数\n生成sql的。那么我们就需要将#占位符都调换成变量符,然后利用DynamicSqlSource给直接生成sql信息的。\n\n第四步sql信息格式化。\n\n第五步使用方法设计。\n\n## 二、思路实现\n\n## 2.1 MappedStatement解析\n\n### 2.1.1 xml参数解析\n\n```java \nprivate void loadMappedStatementByMapperFile(String mapperXmlFile) throws Exception {\n    InputStream resourceAsStream = Resources.getResourceAsStream(mapperXmlFile);\n    Map<String, XNode> sqlFragments = configuration.getSqlFragments();\n    new XMLMapperBuilder(resourceAsStream, configuration, mapperXmlFile, sqlFragments).parse();\n}\n```\n\n### 2.1.2 注解sql解析\n\n```java \nprivate void loadMappedStatementByAnnotation() {\n    MapperAnnotationBuilder mapperAnnotationBuilder =\n        new MapperAnnotationBuilder(configuration, quickMapperChecker.mapper);\n    mapperAnnotationBuilder.parse();\n}\n```\n\n当执行完上面的代码,所有MappedStatement就生成了并保存到你指定的Configuration中了。\n\n\n## 2.2 Sql中标签解析\n\n### 2.2.1 Include 标签解析\n\n拿到所有的sql执行标签\"select|insert|update|delete\",去执行include参数替换。\nincludeParser.applyIncludes(child.getNode());执行后 include 标签就替换成真正的sql片段了。\n```java \n private XNode findNode() throws Exception {\n        InputStream resourceAsStream = Resources.getResourceAsStream(this.mapperFile);\n        XPathParser xPathParser = new XPathParser(resourceAsStream);\n        XNode mapperNode = xPathParser.evalNode(\"/mapper\");\n        List<XNode> children = mapperNode.getChildren();\n        for (XNode child : children) {\n            if (child.getStringAttribute(\"id\").equals(quickMapperChecker.methodName)) {\n                MapperBuilderAssistant mapperBuilderAssistant =\n                    new MapperBuilderAssistant(configuration, quickMapperChecker.mapperFile);\n                mapperBuilderAssistant.setCurrentNamespace(mapper.getName());\n                XMLIncludeTransformer includeParser = new XMLIncludeTransformer(configuration, mapperBuilderAssistant);\n                includeParser.applyIncludes(child.getNode());\n                return child;\n            }\n        }\n        // \"select|insert|update|delete\"\n        return null;\n    };\n```\n\n### 2.2.1 其他标签解析\n\n```java \n private void initNodeHandlerMap() {\n    nodeHandlerMap.put(\"trim\", new TrimHandler());\n    nodeHandlerMap.put(\"where\", new WhereHandler());\n    nodeHandlerMap.put(\"set\", new SetHandler());\n    nodeHandlerMap.put(\"foreach\", new ForEachHandler());\n    nodeHandlerMap.put(\"if\", new IfHandler());\n    nodeHandlerMap.put(\"choose\", new ChooseHandler());\n    nodeHandlerMap.put(\"when\", new IfHandler());\n    nodeHandlerMap.put(\"otherwise\", new OtherwiseHandler());\n    nodeHandlerMap.put(\"bind\", new BindHandler());\n  }\n```\n\n这里我们要使用XMLScriptBuilder#parseDynamicTags。很可惜这个方法是受到保护的。\n我们只能使用反射来对参数进行解析。\n\n\n```java \n // 解析xml中的标签信息\n Method parseDynamicTags = XMLScriptBuilder.class.getDeclaredMethod(\"parseDynamicTags\", XNode.class);\n parseDynamicTags.setAccessible(true);\n\n XMLScriptBuilder xmlScriptBuilder = new XMLScriptBuilder(configuration, node);\n MixedSqlNode rootSqlNode = (MixedSqlNode)parseDynamicTags.invoke(xmlScriptBuilder, node);\n```\n\n\n### 2.2.2 bind参数生成\n\n这里要说明下,我们举一个列子。以下面例子,我们拿到的参数是query。\n\n```java \nList<OrderDO> list(@Param(\"query\") OrderBatchEntityQuery query);\n```\n\n而他的xml比较复杂的。\n\n```xml \n<select id=\"list\" resultType=\"com.center.dal.entity.OrderDO\">\n        select *\n        from order as ro\n                 left join order_detail rod on ro.id = rod.replenish_order_id\n        <where>\n            <if test=\"@com.center.dal.util.MybatisIfUtils@isNotEmpty(query.ids)\">\n                and ro.id in\n                <foreach collection=\"query.ids\" open=\"(\" separator=\",\" index=\"index\" item=\"id\"\n                         close=\")\">\n                    #{id}\n                </foreach>\n            </if>\n            <if test=\"@com.center.dal.util.MybatisIfUtils@isNotEmpty(query.orderCode)\">\n                and ro.order_code = #{query.orderCode}\n            </if>\n            <if test=\"@com.center.dal.util.MybatisIfUtils@isNotEmpty(query.statusList)\">\n                and ro.status in\n                <foreach collection=\"query.statusList\" open=\"(\" separator=\",\" index=\"index\" item=\"status\"\n                         close=\")\">\n                    #{status}\n                </foreach>\n            </if>\n            <if test=\"@com.center.dal.util.MybatisIfUtils@isNotEmpty(query.title)\">\n                and ro.title = #{query.title}\n            </if>\n            <if test=\"@com.center.dal.util.MybatisIfUtils@isNotEmpty(query.salesWarehouseId)\">\n                and ro.sales_warehouse_id = #{query.salesWarehouseId}\n            </if>\n            <if test=\"@com.center.dal.util.MybatisIfUtils@isNotEmpty(query.brandCode)\">\n                and ro.brand_code = #{query.brandCode}\n            </if>\n            <if test=\"@com.center.dal.util.MybatisIfUtils@isNotEmpty(query.businessLineId)\">\n                and ro.business_line_id = #{query.businessLineId}\n            </if>\n            <if test=\"@com.center.dal.util.MybatisIfUtils@isNotEmpty(query.signOwnerCode)\">\n                and ro.sign_owner_code = #{query.signOwnerCode}\n            </if>\n            <if test=\"@com.center.dal.util.MybatisIfUtils@isNotEmpty(query.storageOwnerCode)\">\n                and ro.storage_owner_code = #{query.storageOwnerCode}\n            </if>\n            <if test=\"@com.center.dal.util.MybatisIfUtils@isNotEmpty(query.goodsBarcodes)\">\n                and rod.goods_barcode in\n                <foreach collection=\"query.goodsBarcodes\" open=\"(\" separator=\",\" index=\"index\" item=\"goods_barcode\"\n                         close=\")\">\n                    #{goods_barcode}\n                </foreach>\n            </if>\n        </where>\n    </select>\n\n```\n\n以上参数分为2部分,一部分是原始方法参数的解析。\n\n![](https://img.springlearn.cn/blog/learn_1651311823000.png)\n\n而BoundsSql中ParameterMapping是这样的。\n\n![](https://img.springlearn.cn/blog/learn_1651311916000.png)\n\n需要拿到参数中每个的数据信息。\n\n```java \n // 解析xml中的标签信息\n Method parseDynamicTags = XMLScriptBuilder.class.getDeclaredMethod(\"parseDynamicTags\", XNode.class);\n parseDynamicTags.setAccessible(true);\n\n XMLScriptBuilder xmlScriptBuilder = new XMLScriptBuilder(configuration, node);\n MixedSqlNode rootSqlNode = (MixedSqlNode)parseDynamicTags.invoke(xmlScriptBuilder, node);\n DynamicContext context = new DynamicContext(configuration, namedParams);\n rootSqlNode.apply(context);\n // 标签信息参数解析\n Map<String, Object> bindings = context.getBindings();\n```\n![](https://img.springlearn.cn/blog/learn_1651312104000.png)\n\n到这里复杂标签中的参数就获取到了。\n\n## 2.3 占位符替换成变量符\n\n### 2.3.1 占位符替换变量符\n\n因为#占位符都会先调换成?。而参数都会按照顺序放在ParameterMapping中。\n\n![](https://img.springlearn.cn/blog/learn_1651312283000.png)\n\n这里我们要写代码将?替换成${ParameterMapping#getProperty}。\n\n```java \n    /**\n     * 处理占位符已经被替换成?的时候，用于将占位符重新替换成变量符\n     *\n     * @param sql\n     *            占位符sql\n     * @param index\n     *            占位符当前处理的索引\n     * @param parameterMappings\n     *            占位符参数信息\n     * @return String 变量符sql\n     */\n    private String resetSql(String sql, int index, List<ParameterMapping> parameterMappings, MetaObject metaObject) {\n        int i = sql.indexOf(\"?\");\n        if (i > -1) {\n            ParameterMapping parameterMapping = parameterMappings.get(index);\n            String property = parameterMapping.getProperty();\n            Class<?> javaType = parameterMapping.getJavaType();\n            Object value = metaObject.getValue(parameterMapping.getProperty());\n            String s;\n            if (javaType.equals(String.class) || value instanceof String) {\n                s = sql.replaceFirst(\"\\\\?\", \"\\\"\\\\${\" + property + \"}\\\"\");\n            } else {\n                s = sql.replaceFirst(\"\\\\?\", \"\\\\${\" + property + \"}\");\n            }\n            sql = resetSql(s, ++index, parameterMappings, metaObject);\n        }\n        return sql;\n    }\n```\n\n### 2.3.2 生成Sql\n\n利用变量符能直接生成sql的能力，我们直接将参数准备好，使用就好了。\n\n```java \n // 获取原始参数信息\n Object namedParams = paramNameResolver.getNamedParams(quickMapperChecker.args);\n // 复杂参数解析\n Map<String, Object> bindings = context.getBindings();\n // 标签参数 + 原始参数\n ((Map)namedParams).putAll(bindings);\n TextSqlNode textSqlNode = new TextSqlNode(resetSql(sql, 0, parameterMappings, metaObject));\n new DynamicSqlSource(configuration, textSqlNode).getBoundSql(namedParams).getSql());\n```\n\n## 2.4 sql格式化\n\n这里我们就直接使用druid库中的sql格式化工具\n\n```xml \n       <dependency>\n            <groupId>com.alibaba</groupId>\n            <artifactId>druid</artifactId>\n            <version>1.2.6</version>\n        </dependency>\n```\n\n这里因为我们知道是mysql数据库所以执行使用mysql格式化\n```java\nSQLUtils.formatMySql(boundSql.getSql());\n```\n\n\n## 2.5 使用方法设计\n\n基于上门的代码,首先我们已经不依赖Spring容器了,所以要想分析sql就不用启动整个项目了。\n直接将要分析的类和方法进行执行就行了。\n\n```java \nOrderBatchEntityQuery query = JMockData.mock(OrderBatchEntityQuery.class);\n// 如果需要绑定xml就使用bindMapper\nQuickMapperChecker.analyse(QuickMapperChecker.mock(IOrderMapper.class).list(query))\n   .bindMapper(\"mapper/center/ReplenishOrderMapper.xml\").printSql();   \n// 如果完全依赖注解跟简单\nQuickMapperChecker.analyse(QuickMapperChecker.mock(IOrderMapper.class).list(query))\n   .printSql();   \n```\n\n\n\n\n## 三、完整代码\n\n代码较为简单这里附带源码\n\n## 3.1 Mybatis 使用\n\n```java \n@NoArgsConstructor\npublic class QuickMapperChecker {\n\n    /**\n     * 方法签名id\n     */\n    @Getter\n    public String mapperId;\n\n    @Setter\n    public String methodName;\n\n    /**\n     * 方法参数\n     */\n    @Getter\n    private Object[] args;\n\n    /**\n     * 参数解析器\n     */\n    @Getter\n    private ParamNameResolver paramNameResolver;\n\n    /**\n     * mapper类型\n     */\n    private Class<?> mapper;\n\n    /**\n     * mybatis配置\n     */\n    @Getter\n    private Configuration configuration;\n\n    @Getter\n    @Setter\n    private String mapperFile;\n\n    private boolean simple;\n\n    public QuickMapperChecker(String mapperId, Object[] args, ParamNameResolver paramNameResolver, Class<?> mapper,\n                              Configuration configuration) {\n        this.mapperId = mapperId;\n        this.args = args;\n        this.paramNameResolver = paramNameResolver;\n        this.mapper = mapper;\n        this.configuration = configuration;\n    }\n\n    public static QuickMapperChecker proxy() {\n        if (Objects.isNull(quickMapperChecker)) {\n            quickMapperChecker = new QuickMapperChecker();\n            quickMapperChecker.simple = true;\n        }\n        return quickMapperChecker;\n    }\n\n    private static QuickMapperChecker quickMapperChecker;\n\n    private static final Map<Class<?>, Object> PRIMITIVE_WRAPPER_TYPE_MAP = new IdentityHashMap<>(8);\n\n    static {\n        PRIMITIVE_WRAPPER_TYPE_MAP.put(Boolean.class, false);\n        PRIMITIVE_WRAPPER_TYPE_MAP.put(Byte.class, 0);\n        PRIMITIVE_WRAPPER_TYPE_MAP.put(Character.class, \"\");\n        PRIMITIVE_WRAPPER_TYPE_MAP.put(Double.class, 0D);\n        PRIMITIVE_WRAPPER_TYPE_MAP.put(Float.class, 0L);\n        PRIMITIVE_WRAPPER_TYPE_MAP.put(Integer.class, 0);\n        PRIMITIVE_WRAPPER_TYPE_MAP.put(Long.class, 0L);\n        PRIMITIVE_WRAPPER_TYPE_MAP.put(Short.class, 0);\n        PRIMITIVE_WRAPPER_TYPE_MAP.put(Void.class, Void.TYPE);\n\n        PRIMITIVE_WRAPPER_TYPE_MAP.put(boolean.class, false);\n        PRIMITIVE_WRAPPER_TYPE_MAP.put(byte.class, 0);\n        PRIMITIVE_WRAPPER_TYPE_MAP.put(char.class, \"\");\n        PRIMITIVE_WRAPPER_TYPE_MAP.put(double.class, 0D);\n        PRIMITIVE_WRAPPER_TYPE_MAP.put(float.class, 0L);\n        PRIMITIVE_WRAPPER_TYPE_MAP.put(int.class, 0);\n        PRIMITIVE_WRAPPER_TYPE_MAP.put(long.class, 0L);\n        PRIMITIVE_WRAPPER_TYPE_MAP.put(short.class, 0);\n        PRIMITIVE_WRAPPER_TYPE_MAP.put(void.class, null);\n    }\n\n    private static Class<?>[] interfacesFromMapper(Class<?> mapper) {\n        Class<?>[] interfaces = mapper.getInterfaces();\n        List<Class<?>> interfacesClass = new ArrayList<>();\n        if (interfaces.length > 0) {\n            interfacesClass.addAll(Arrays.asList(interfaces));\n        }\n        if (mapper.isInterface()) {\n            interfacesClass.add(mapper);\n        }\n        return interfacesClass.toArray(new Class[]{});\n    }\n\n    public static <T> T mock(Class<T> mapper) throws Exception {\n        return mock(mapper, new Configuration());\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public static <T> T mock(Class<T> mapper, Configuration configuration) throws Exception {\n        return (T) Proxy.newProxyInstance(mapper.getClassLoader(), interfacesFromMapper(mapper),\n                (proxy, method, args) -> {\n                    String mapperId = method.getDeclaringClass().getName() + \".\" + method.getName();\n                    if (Objects.isNull(quickMapperChecker)) {\n                        quickMapperChecker = new QuickMapperChecker(mapperId, args,\n                                new ParamNameResolver(configuration, method), mapper, configuration);\n                        quickMapperChecker.setMethodName(method.getName());\n                    } else {\n                        boolean simple = quickMapperChecker.simple;\n                        quickMapperChecker = new QuickMapperChecker(mapperId, args,\n                                new ParamNameResolver(configuration, method), mapper, configuration);\n                        quickMapperChecker.simple = simple;\n                        quickMapperChecker.setMethodName(method.getName());\n                    }\n                    Class<?> returnType = method.getReturnType();\n                    Object result = PRIMITIVE_WRAPPER_TYPE_MAP.get(returnType);\n                    if (quickMapperChecker.simple) {\n                        quickMapperChecker.printSql();\n                    }\n                    return Objects.nonNull(result) ? result : new DefaultObjectFactory().create(returnType);\n                });\n    }\n\n    /**\n     * 处理占位符已经被替换成?的时候，用于将占位符重新替换成变量符\n     *\n     * @param sql               占位符sql\n     * @param index             占位符当前处理的索引\n     * @param parameterMappings 占位符参数信息\n     * @return String 变量符sql\n     */\n    private String resetSql(String sql, int index, List<ParameterMapping> parameterMappings, MetaObject metaObject) {\n        int i = sql.indexOf(\"?\");\n        if (i > -1) {\n            ParameterMapping parameterMapping = parameterMappings.get(index);\n            String property = parameterMapping.getProperty();\n            Class<?> javaType = parameterMapping.getJavaType();\n            Object value = metaObject.getValue(parameterMapping.getProperty());\n            String s;\n            if (javaType.equals(String.class) || value instanceof String) {\n                s = sql.replaceFirst(\"\\\\?\", \"\\\"\\\\${\" + property + \"}\\\"\");\n            } else {\n                s = sql.replaceFirst(\"\\\\?\", \"\\\\${\" + property + \"}\");\n            }\n            sql = resetSql(s, ++index, parameterMappings, metaObject);\n        }\n        return sql;\n    }\n\n    /**\n     * sql打印\n     *\n     * @return String\n     * @throws Exception 未知异常\n     */\n    public String getSql() throws Exception {\n        if (!StringUtils.isBlank(this.mapperFile)) {\n            loadMappedStatementByMapperFile(this.mapperFile);\n        }\n        loadMappedStatementByAnnotation();\n        boolean hasMapped = configuration.hasStatement(quickMapperChecker.mapperId);\n        if (!hasMapped) {\n            throw new RuntimeException(\n                    \"未找到MappedStatement,请检查是否需要绑定mapper xml文件:[\" + quickMapperChecker.mapperId + \"]\");\n        }\n        MappedStatement mappedStatement = configuration.getMappedStatement(quickMapperChecker.mapperId);\n        SqlSource sqlSource = mappedStatement.getSqlSource();\n        Object namedParams = paramNameResolver.getNamedParams(quickMapperChecker.args);\n        BoundSql boundSql = mappedStatement.getBoundSql(namedParams);\n        // 占位符\n        if (sqlSource instanceof RawSqlSource || sqlSource instanceof DynamicSqlSource) {\n            // 占位sql，将#替换成$\n            String sql = boundSql.getSql();\n            List<ParameterMapping> parameterMappings = boundSql.getParameterMappings();\n            XNode node = findNode();\n            if (Objects.nonNull(node)) {\n                // 解析xml中的标签信息\n                Method parseDynamicTags = XMLScriptBuilder.class.getDeclaredMethod(\"parseDynamicTags\", XNode.class);\n                parseDynamicTags.setAccessible(true);\n\n                XMLScriptBuilder xmlScriptBuilder = new XMLScriptBuilder(configuration, node);\n                MixedSqlNode rootSqlNode = (MixedSqlNode) parseDynamicTags.invoke(xmlScriptBuilder, node);\n                DynamicContext context = new DynamicContext(configuration, namedParams);\n                rootSqlNode.apply(context);\n                // 标签信息参数解析\n                Map<String, Object> bindings = context.getBindings();\n                // 标签参数 + 原始参数\n                ((Map) namedParams).putAll(bindings);\n            }\n            MetaObject metaObject = configuration.newMetaObject(namedParams);\n            processDate(parameterMappings, metaObject);\n            TextSqlNode textSqlNode = new TextSqlNode(resetSql(sql, 0, parameterMappings, metaObject));\n            return SQLUtils\n                    .formatMySql((new DynamicSqlSource(configuration, textSqlNode).getBoundSql(namedParams).getSql()));\n        } else {\n            return SQLUtils.formatMySql(boundSql.getSql());\n        }\n    }\n\n    private void processDate(List<ParameterMapping> parameterMappings, MetaObject metaObject) {\n        for (ParameterMapping parameterMapping : parameterMappings) {\n            String property = parameterMapping.getProperty();\n            Object value = metaObject.getValue(property);\n            if (value instanceof Date) {\n                metaObject.setValue(property, DatePatternEnum.DATE_TIME_PATTERN.format((Date) value));\n            }\n        }\n    }\n\n    private XNode findNode() throws Exception {\n        InputStream resourceAsStream = Resources.getResourceAsStream(this.mapperFile);\n        XPathParser xPathParser = new XPathParser(resourceAsStream);\n        XNode mapperNode = xPathParser.evalNode(\"/mapper\");\n        List<XNode> children = mapperNode.getChildren();\n        for (XNode child : children) {\n            if (child.getStringAttribute(\"id\").equals(quickMapperChecker.methodName)) {\n                MapperBuilderAssistant mapperBuilderAssistant =\n                        new MapperBuilderAssistant(configuration, quickMapperChecker.mapperFile);\n                mapperBuilderAssistant.setCurrentNamespace(mapper.getName());\n                XMLIncludeTransformer includeParser = new XMLIncludeTransformer(configuration, mapperBuilderAssistant);\n                includeParser.applyIncludes(child.getNode());\n                return child;\n            }\n        }\n        // \"select|insert|update|delete\"\n        return null;\n    }\n\n    ;\n\n    private void loadMappedStatementByAnnotation() {\n        MapperAnnotationBuilder mapperAnnotationBuilder =\n                new MapperAnnotationBuilder(configuration, quickMapperChecker.mapper);\n        mapperAnnotationBuilder.parse();\n    }\n\n    private void loadMappedStatementByMapperFile(String mapperXmlFile) throws Exception {\n        InputStream resourceAsStream = Resources.getResourceAsStream(mapperXmlFile);\n        Map<String, XNode> sqlFragments = configuration.getSqlFragments();\n        new XMLMapperBuilder(resourceAsStream, configuration, mapperXmlFile, sqlFragments).parse();\n    }\n\n    public void printSql() throws Exception {\n        ColorConsole.colorPrintln(\"\uD83D\uDE80 格式化SQL:\");\n        ColorConsole.colorPrintln(AnsiColor.BRIGHT_MAGENTA, \"{}\", getSql());\n    }\n\n    /**\n     * sql信息进行检查\n     *\n     * @param t   泛型\n     * @param <T> 泛型\n     * @return QuickMapperChecker\n     */\n    public static <T> QuickMapperChecker analyse(T t) {\n        // 1. 调用方法\n        return quickMapperChecker;\n    }\n\n    /**\n     * 绑定mapper文件\n     *\n     * @param mapperFile mapper文件地址\n     * @return QuickMapperChecker\n     */\n    public QuickMapperChecker bindMapper(String mapperFile) {\n        quickMapperChecker.setMapperFile(mapperFile);\n        return quickMapperChecker;\n    }\n}\n\n```\n\n## 3.2 Mybatis Plus 使用\n\n```java \n/**\n * 无需启动容器对sql信息进行检查\n *\n * @author liuxin 2022/4/27 17:48\n */\n@NoArgsConstructor\npublic class QuickMapperPlusChecker {\n\n    /**\n     * 方法签名id\n     */\n    @Getter\n    public String mapperId;\n\n    @Setter\n    public String methodName;\n\n    /**\n     * 方法参数\n     */\n    @Getter\n    private Object[] args;\n\n    /**\n     * 参数解析器\n     */\n    @Getter\n    private ParamNameResolver paramNameResolver;\n\n    /**\n     * mapper类型\n     */\n    private Class<?> mapper;\n\n    /**\n     * mybatis配置\n     */\n    @Getter\n    private MybatisConfiguration configuration;\n\n    @Getter\n    @Setter\n    private String mapperFile;\n\n    private boolean simple;\n\n    public QuickMapperPlusChecker(String mapperId, Object[] args, ParamNameResolver paramNameResolver, Class<?> mapper,\n        MybatisConfiguration configuration) {\n        this.mapperId = mapperId;\n        this.args = args;\n        this.paramNameResolver = paramNameResolver;\n        this.mapper = mapper;\n        this.configuration = configuration;\n    }\n\n    public static QuickMapperPlusChecker proxy() {\n        if (Objects.isNull(quickMapperChecker)) {\n            quickMapperChecker = new QuickMapperPlusChecker();\n            quickMapperChecker.simple = true;\n        }\n        return quickMapperChecker;\n    }\n\n    private static QuickMapperPlusChecker quickMapperChecker;\n\n    private static final Map<Class<?>, Object> PRIMITIVE_WRAPPER_TYPE_MAP = new IdentityHashMap<>(8);\n\n    static {\n        PRIMITIVE_WRAPPER_TYPE_MAP.put(Boolean.class, false);\n        PRIMITIVE_WRAPPER_TYPE_MAP.put(Byte.class, 0);\n        PRIMITIVE_WRAPPER_TYPE_MAP.put(Character.class, \"\");\n        PRIMITIVE_WRAPPER_TYPE_MAP.put(Double.class, 0D);\n        PRIMITIVE_WRAPPER_TYPE_MAP.put(Float.class, 0L);\n        PRIMITIVE_WRAPPER_TYPE_MAP.put(Integer.class, 0);\n        PRIMITIVE_WRAPPER_TYPE_MAP.put(Long.class, 0L);\n        PRIMITIVE_WRAPPER_TYPE_MAP.put(Short.class, 0);\n        PRIMITIVE_WRAPPER_TYPE_MAP.put(Void.class, Void.TYPE);\n\n        PRIMITIVE_WRAPPER_TYPE_MAP.put(boolean.class, false);\n        PRIMITIVE_WRAPPER_TYPE_MAP.put(byte.class, 0);\n        PRIMITIVE_WRAPPER_TYPE_MAP.put(char.class, \"\");\n        PRIMITIVE_WRAPPER_TYPE_MAP.put(double.class, 0D);\n        PRIMITIVE_WRAPPER_TYPE_MAP.put(float.class, 0L);\n        PRIMITIVE_WRAPPER_TYPE_MAP.put(int.class, 0);\n        PRIMITIVE_WRAPPER_TYPE_MAP.put(long.class, 0L);\n        PRIMITIVE_WRAPPER_TYPE_MAP.put(short.class, 0);\n        PRIMITIVE_WRAPPER_TYPE_MAP.put(void.class, null);\n    }\n\n    private static Class<?>[] interfacesFromMapper(Class<?> mapper) {\n        Class<?>[] interfaces = mapper.getInterfaces();\n        List<Class<?>> interfacesClass = new ArrayList<>();\n        if (interfaces.length > 0) {\n            interfacesClass.addAll(Arrays.asList(interfaces));\n        }\n        if (mapper.isInterface()) {\n            interfacesClass.add(mapper);\n        }\n        return interfacesClass.toArray(new Class[] {});\n    }\n\n    public static <T> T mock(Class<T> mapper) throws Exception {\n        return mock(mapper, new MybatisConfiguration());\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public static <T> T mock(Class<T> mapper, MybatisConfiguration configuration) throws Exception {\n        return (T)Proxy.newProxyInstance(mapper.getClassLoader(), interfacesFromMapper(mapper),\n            (proxy, method, args) -> {\n                String mapperId = mapper.getName() + \".\" + method.getName();\n                if (Objects.isNull(quickMapperChecker)) {\n                    quickMapperChecker = new QuickMapperPlusChecker(mapperId, args,\n                        new ParamNameResolver(configuration, method), mapper, configuration);\n                    quickMapperChecker.setMethodName(method.getName());\n                } else {\n                    boolean simple = quickMapperChecker.simple;\n                    quickMapperChecker = new QuickMapperPlusChecker(mapperId, args,\n                        new ParamNameResolver(configuration, method), mapper, configuration);\n                    quickMapperChecker.simple = simple;\n                    quickMapperChecker.setMethodName(method.getName());\n                }\n                Class<?> returnType = method.getReturnType();\n                Object result = PRIMITIVE_WRAPPER_TYPE_MAP.get(returnType);\n                if (quickMapperChecker.simple) {\n                    quickMapperChecker.printSql();\n                }\n                return Objects.nonNull(result) ? result : new DefaultObjectFactory().create(returnType);\n            });\n    }\n\n    /**\n     * 处理占位符已经被替换成?的时候，用于将占位符重新替换成变量符\n     *\n     * @param sql\n     *            占位符sql\n     * @param index\n     *            占位符当前处理的索引\n     * @param parameterMappings\n     *            占位符参数信息\n     * @return String 变量符sql\n     */\n    private String resetSql(String sql, int index, List<ParameterMapping> parameterMappings, MetaObject metaObject) {\n        int i = sql.indexOf(\"?\");\n        if (i > -1) {\n            ParameterMapping parameterMapping = parameterMappings.get(index);\n            String property = parameterMapping.getProperty();\n            Class<?> javaType = parameterMapping.getJavaType();\n            Object value = metaObject.getValue(parameterMapping.getProperty());\n            String s;\n            if (javaType.equals(String.class) || value instanceof String) {\n                s = sql.replaceFirst(\"\\\\?\", \"\\\"\\\\${\" + property + \"}\\\"\");\n            } else {\n                s = sql.replaceFirst(\"\\\\?\", \"\\\\${\" + property + \"}\");\n            }\n            sql = resetSql(s, ++index, parameterMappings, metaObject);\n        }\n        return sql;\n    }\n\n    /**\n     * sql打印\n     * \n     * @return String\n     * @throws Exception\n     *             未知异常\n     */\n    public String getSql() throws Exception {\n        if (!StringUtils.isBlank(this.mapperFile)) {\n            loadMappedStatementByMapperFile(this.mapperFile);\n        }\n        loadMappedStatementByAnnotation();\n        new SqlRunnerInjector().inject(configuration);\n        boolean hasMapped = configuration.hasStatement(quickMapperChecker.mapperId);\n        if (!hasMapped) {\n            throw new RuntimeException(\n                \"未找到MappedStatement,请检查是否需要绑定mapper xml文件:[\" + quickMapperChecker.mapperId + \"]\");\n        }\n        MappedStatement mappedStatement = configuration.getMappedStatement(quickMapperChecker.mapperId);\n        SqlSource sqlSource = mappedStatement.getSqlSource();\n        Object namedParams = paramNameResolver.getNamedParams(quickMapperChecker.args);\n        BoundSql boundSql = mappedStatement.getBoundSql(namedParams);\n        // 占位符\n        if (sqlSource instanceof RawSqlSource || sqlSource instanceof DynamicSqlSource) {\n            // 占位sql，将#替换成$\n            String sql = boundSql.getSql();\n            List<ParameterMapping> parameterMappings = boundSql.getParameterMappings();\n\n            XNode node = findNode();\n            if (Objects.nonNull(node)) {\n                XMLScriptBuilder xmlScriptBuilder = new XMLScriptBuilder(configuration, node);\n                // 解析xml中的标签信息\n                Method parseDynamicTags = XMLScriptBuilder.class.getDeclaredMethod(\"parseDynamicTags\", XNode.class);\n                parseDynamicTags.setAccessible(true);\n                MixedSqlNode rootSqlNode = (MixedSqlNode)parseDynamicTags.invoke(xmlScriptBuilder, node);\n                DynamicContext context = new DynamicContext(configuration, namedParams);\n                rootSqlNode.apply(context);\n                // 标签信息参数解析\n                Map<String, Object> bindings = context.getBindings();\n                // 标签参数 + 原始参数\n                ((Map)namedParams).putAll(bindings);\n            }\n            MetaObject metaObject = configuration.newMetaObject(namedParams);\n            processDate(parameterMappings, metaObject);\n            TextSqlNode textSqlNode = new TextSqlNode(resetSql(sql, 0, parameterMappings, metaObject));\n            return SQLUtils\n                .formatMySql((new DynamicSqlSource(configuration, textSqlNode).getBoundSql(namedParams).getSql()));\n        } else {\n            return SQLUtils.formatMySql(boundSql.getSql());\n        }\n    }\n\n    private void processDate(List<ParameterMapping> parameterMappings, MetaObject metaObject) {\n        for (ParameterMapping parameterMapping : parameterMappings) {\n            String property = parameterMapping.getProperty();\n            Object value = metaObject.getValue(property);\n            if (value instanceof Date) {\n                metaObject.setValue(property, DatePatternEnum.DATE_TIME_PATTERN.format((Date)value));\n            }\n        }\n    }\n\n    private XNode findNode() throws Exception {\n        if (StringUtils.isNotBlank(this.mapperFile)) {\n            InputStream resourceAsStream = Resources.getResourceAsStream(this.mapperFile);\n            XPathParser xPathParser = new XPathParser(resourceAsStream);\n            XNode mapperNode = xPathParser.evalNode(\"/mapper\");\n            List<XNode> children = mapperNode.getChildren();\n            for (XNode child : children) {\n                if (child.getStringAttribute(\"id\").equals(quickMapperChecker.methodName)) {\n                    MapperBuilderAssistant mapperBuilderAssistant =\n                        new MapperBuilderAssistant(configuration, quickMapperChecker.mapperFile);\n                    mapperBuilderAssistant.setCurrentNamespace(mapper.getName());\n                    XMLIncludeTransformer includeParser =\n                        new XMLIncludeTransformer(configuration, mapperBuilderAssistant);\n                    includeParser.applyIncludes(child.getNode());\n                    return child;\n                }\n            }\n        }\n        // \"select|insert|update|delete\"\n        return null;\n    };\n\n    private void loadMappedStatementByAnnotation() {\n        MybatisMapperAnnotationBuilder mapperAnnotationBuilder =\n            new MybatisMapperAnnotationBuilder(configuration, quickMapperChecker.mapper);\n        mapperAnnotationBuilder.parse();\n    }\n\n    private void loadMappedStatementByMapperFile(String mapperXmlFile) throws Exception {\n        InputStream resourceAsStream = Resources.getResourceAsStream(mapperXmlFile);\n        Map<String, XNode> sqlFragments = configuration.getSqlFragments();\n        new XMLMapperBuilder(resourceAsStream, configuration, mapperXmlFile, sqlFragments).parse();\n    }\n\n    public void printSql() throws Exception {\n        ColorConsole.colorPrintln(\"\uD83D\uDE80 格式化SQL:\");\n        ColorConsole.colorPrintln(AnsiColor.BRIGHT_MAGENTA, \"{}\", getSql());\n    }\n\n    /**\n     * sql信息进行检查\n     * \n     * @param t\n     *            泛型\n     * @return QuickMapperChecker\n     * @param <T>\n     *            泛型\n     */\n    public static <T> QuickMapperPlusChecker analyse(T t) {\n        // 1. 调用方法\n        return quickMapperChecker;\n    }\n\n    /**\n     * 绑定mapper文件\n     * \n     * @param mapperFile\n     *            mapper文件地址\n     * @return QuickMapperChecker\n     */\n    public QuickMapperPlusChecker bindMapper(String mapperFile) {\n        quickMapperChecker.setMapperFile(mapperFile);\n        return quickMapperChecker;\n    }\n}\n\n```\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/mybatis/Mybatissql日志打印.md b/docs/learn/mybatis/Mybatissql日志打印.md
--- a/docs/learn/mybatis/Mybatissql日志打印.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/mybatis/Mybatissql日志打印.md	(date 1655373430485)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/tools/pool2/字符串常量池.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: true\nfooter: true\nbacktotop: true\ntitle: 字符串常量池\n---\n\n<Djt/>\n\n**本篇课程不来虚的,上来就是干活,现在发车。小编通过代码案例及比喻,带你一窥究竟。**\n\n## 为什么会有常量池的概念?\n\n不知道小伙伴们是否有思考过这个问题? 没有思考也无所谓,小编在这里类比一下,大家就会清晰了。\n什么是池? 我们听的最多的池,应该是数据库连接池. 为什么会有数据库连接池,其实就是为了节省资源,提高性能,防止重复创建连接,避免占用内存和网络资源。\n\n常量池其实就是跟数据库连接池的目的都是一样的。那么他是如何实现的呢? 因为常量池是JVM的概念，源码我们也不好看,所以我们还以连接池来类比,请看下文。\n\n## 池化的目标就是缓存和管理\n\n稍微提一点池化的概念,其实就是对资源做一个包装,在包装层来加一些对这个资源的属性信息,比如使用次数,最后操作时间,最长生命周期一样。然后通过后台线程对资源包装层的扫描,来对真实资源的做一个管理。Google的Guava的Cache就是这么做的,我们自己也可以利用 `common-pool2` 工具包自己来做,或者说池化。\n\n## JVM常量池就相当于一个缓存\n\n常量就是不会改变的信息,那么既然是不会改变的信息,系统中只存在一份,就可以了。存在多份也是浪费内存资源。然而在Java中只要是new的信息都会在堆上开辟一个新的空间,为了解决这个问题,JVM中才出现了字符串常量池的概念。但是只有直接用`\"\"`修饰的字符,才会被加入到常量池中,当再次用`\"\"`创建的时候,会首先从常量池中去获取。\n\n```\nString s1 = \"1\";\nString s2 = \"1\";\n//true\nSystem.out.print(s1==s2); \nString s3 = new String(\"1\");\nString s4 = new String(\"1\");\n//false\nSystem.out.print(s3==s4); \n```\n\n我们可以把常量池理解为一个Map<String,String>做的缓存容器。只不过这个缓存机制是有JVM使用C语言写的。我们看不到而已。\n\n\n## String.intern()的使用\n\n![](https://img.springlearn.cn/blog/learn_1567773914000.png)\n\n`new` 出来的 `String` 类型是否也能使用常量池呢? 当然可以,就是通过 `intern` 方法\n这个方法的意思就是先到缓存中(也就是常量池中)查询当前对象是否存在,存在就返回常量池中地址,不存在就加入常量池。我们可以用一段伪代码来解释一波。\n```\n        //双引号直接放入常量池\n        String s1 = \"1\";\n        String s2 = new String(\"1\");\n        //false\n        System.out.println(s1 == s2);\n        //先到常量池中查询是否有”1“,存在就将常量池中对象返回,不存在就放到常量池中(此时常量池中存在s1)\n        //于是就将s1的值重新复制给s3,所以s1 == s3\n        String s3 = new String(\"1\").intern();\n        //true\n        System.out.println(s1 == s3);\n```\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/tools/pool2/字符串常量池.md b/docs/learn/tools/pool2/字符串常量池.md
--- a/docs/learn/tools/pool2/字符串常量池.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/tools/pool2/字符串常量池.md	(date 1655373430326)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/spring/Spring循环依赖.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: true\nfooter: true\nbacktotop: true\ntitle: Spring循环依赖\ncategory: Spring\n---\n\n![](https://img.springlearn.cn/blog/learn_1647108921000.png)\n\n**作者: 八阿哥的剑**\n\n*博客: https://springlearn.cn*\n\n::: tip 一日一句毒鸡汤\n问世间钱为何物，只叫人生死相许。！\uD83D\uDE04\n:::\n\n写文章不容易，如果感觉还行，请点个关注，点关注不迷路。\n\n## 一、什么是循环依赖\n\n这种简单的问题，直接伪代码吧。\n\n```java \n@Service\npublic class A {\n    @Autowired\n    private B b;\n}\n\n@Service\npublic class B {\n    @Autowired\n    private A a;\n}\n```\n\n我中有你，你中有我。\n\n\n## 二、解决循环依赖思路\n\n思路其实非常简单还是用伪代码来说明\n\n```java \nA a = new A();\nB b = new B();\na.setB(b);\nb.setA(a);\n```\n\n思路就是这么简单，先分别把A和B给实例化。\n这时候实例化的A和B仅仅是完成了实例化,内部的属性其实都没有。\n只有当执行了3、4行才算正常完成。 \n\n```java {3,4}\nA a = new A();\nB b = new B();\na.setB(b);\nb.setA(a);\n```\n\n通过上面的代码我们总结下，要想实现循环注入。首先要满足第一个条件。\n\n1. **能被实例化**\n- 有空构造\n- 或有构造且构造参数满足能被实例化。\n\n好了，知道这点就成了，相信让你来实现循环注入，应该也可以了吧。其实就这么简单 ?\n\n那我们来看Spring如何来实现的。相信看完你就头大了。但是没关系，基本原理你已经知道了。\n带着这个思路来看Spring的源码就简单了。 \n\n## 三、Spring如何解决循环依赖\n\n首先我们要知道Spring中的bean, 有两种形式。\n- 第一种是单例。所谓单例就是容器中这个类，只会存在一个实例。不管你调用了多少次 `getBean(String beanName)` 返回的都是一个实例(因为每次都从缓存中获取的实例)。\n- 第二种是原型。所谓原型就是容器中这个类，没有缓存。每次都是新建一个Bean。\n\n在这里我们思考下，如果要你来实现循环注入，以上两种模式。你能用那一个? \n要想实现循环注入，即这个Bean必须要有一个缓存的地方。不然每次都是创建，虽然能完成实例化，但是实例化后，需要注入的 `bean` 无法实现注入，就会陷入死循环。\n\n这里第二个必要因素就出来了。\n\n==2. 必须要是单例==\n\n\n好了，知道这么多我们开始看源码吧。\n\n### 3.1 Spring中创建Bean的步骤\n\n- 实例化，createBeanInstance，就是new了个对象。\n- 属性注入，populateBean， 就是 set 一些属性值。\n- 初始化，initializeBean，执行一些 aware 接口中的方法，initMethod，AOP代理等\n\n### 3.2 循环依赖三层缓存\n\n注意看细节，每个缓存的数据类型是什么? 后面要考。\n\n![](https://img.springlearn.cn/blog/learn_1647104251000.png)\n\n- 一级缓存 `Map<String, Object> singletonObjects `\n  - 如果等于空，或者当前单例正在创建中(即只完成了实例化)。就从二级缓存中获取。\n- 二级缓存 `Map<String, Object> earlySingletonObjects` \n  - 如果等于空，就从三级缓存中获取。\n- 三级缓存 `Map<String, ObjectFactory<?>> singletonFactories`\n  - 创建Bean的一个工厂，允许容器中定义特殊的，生成Bean的方法。使用 `addSingletonFactory`\n\n\n其实要想实现循环依赖只用2个缓存就行。三级缓存的意义是为了完成某些功能。至于什么功能呢? 这里先不说后面看流程。\n\n```java {3}\nprotected Object getSingleton(String beanName, boolean allowEarlyReference) {\n\t\tObject singletonObject = this.singletonObjects.get(beanName);\n\t\tif (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {\n\t\t\tsynchronized (this.singletonObjects) {\n\t\t\t\tsingletonObject = this.earlySingletonObjects.get(beanName);\n\t\t\t\tif (singletonObject == null && allowEarlyReference) {\n\t\t\t\t\tObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);\n\t\t\t\t\tif (singletonFactory != null) {\n\t\t\t\t\t\tsingletonObject = singletonFactory.getObject();\n\t\t\t\t\t\tthis.earlySingletonObjects.put(beanName, singletonObject);\n\t\t\t\t\t\tthis.singletonFactories.remove(beanName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn singletonObject;\n\t}\n```\n\n好我们知道有这两个缓存就继续往下看源码。当 `getSingleton` 是 `null`。继续往下走。其他源码就跳过了，不是本篇的主要内容，我们只看\n解决循环依赖的核心代码。\n\n- doCreateBean#createBeanInstance 先实现实例化。\n- 当前bean是单例,不会添加到二级缓存，直接就添加到三级缓存中,注意这里不是添加的Bean，而是生成Bean的工厂方法 `ObjectFactory(#getEarlyBeanReference)`。\n```java {8}\n\t   boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&\n\t\t\t\tisSingletonCurrentlyInCreation(beanName));\n\t\tif (earlySingletonExposure) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Eagerly caching bean '\" + beanName +\n\t\t\t\t\t\t\"' to allow for resolving potential circular references\");\n\t\t\t}\n\t\t\taddSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));\n\t\t} \n```\n- doCreateBean#populateBean 实现属性注入\n\n以上面的代码的例子，A创建时候被加入到了三级缓存中，然后继续执行 `populateBean`。发现要依赖B。然后依次从缓存中\n来找这个A。最终在三级缓存中读取到了B。然后实现注入。这里三级缓存中的 `Bean`。 有可能只是完成了 `new`。但是容器\n不管，先完成循环注入。至于注入的东西是否是完全品还是半成品不关心，因为都是单例所以，后面在注入属性也没关系。\n这里我们知道单例的用处了吧。试想一下，如果不是单例模式，而是原型模式。那么bean就必须是完全品，不然就陷入了死循环。\n\n下面我们还用伪代码的方式再来说一篇实现思路。\n\n```java \n// createBeanInstance先实例化，然后加入到三级缓存中\nA a = new A();\n// a在执行populateBean的时候，发现要注入属性B，于是就使用getBean。\n// getBean(b) 执行createBeanInstance先实例化\nB b = new B();\n// 然后加入到三级缓存中，b在执行populateBean注入属性值的时候。发现也依赖了A。\n// 然后从缓存中找到办成品A。于是乎B的注入就完成，然后再执行B的init方法。\nb.setA(a);\n// B完成后,则返回到A的populateBean也注入了B。然后在执行A的init方法\na.setB(b);\n```\n到这里就完成了循环注入，这里有点绕，小编画了一个图，大家跟着序号来看，然后好好理解下。\n\n\n![](https://img.springlearn.cn/blog/learn_1647104949000.png)\n\n通过这个图其实我们能发现一个问题。B此时从三级缓存中拿到的A是一个半成品的A。\n假如B在执行初始化方法的时候,依赖A的populateBean注入的属性。那么此时一定会拿不到的。\n下面写点伪代码，说一下这个问题。\n\n### 3.3 发现点问题\n\n#### 3.3.1 半成品问题-1\n\n\n```java \n@Component\npublic class A implements InitializingBean {\n\n    @Autowired\n    private B b;\n\n    @Value(\"${a.name}\")\n    private String name;\n\n    public String getName() {\n        return name;\n    }\n\n    @Override\n    public void afterPropertiesSet() throws Exception {\n        System.out.println(\"A:\" + b);\n    }\n}\n\n@Component\npublic class B implements InitializingBean {\n\n    @Autowired\n    private A a;\n\n    @Override\n    public void afterPropertiesSet() throws Exception {\n        System.out.println(\"B:\" + a.getName());\n    }\n}\n```\n\n![](https://img.springlearn.cn/blog/learn_1647105136000.png)\n\n通过上图我们知道B会先执行初始化，而这里B的初始化 ==(图例8)== 会依赖A的参数注入 ==(图例4)== 。而B在执行初始化的时候。A(图例4没有完全完成注入)并没有完成属性注入。\n那么我们此时在拿到A的getName一定是空的。\n\n**以上代码执行就是:**\n```java \nB:null\nA:com.example.demo.B@38aa816f\n```\n\n#### 3.3.2 半成品问题-2\n\nA的BeanPostProcessor没有执行,那么假如我们想要对A进行方法代理。B在执行初始化的时候,调用A的 `getName`。会成功代理上吗?\n\n```java \n@Component\npublic class A implements InitializingBean {\n\n    @Autowired\n    private B b;\n\n    private final String name = \"孙悟空\";\n\n    public String getName() {\n        return name;\n    }\n\n    @Override\n    public void afterPropertiesSet() throws Exception {\n        System.out.println(\"A:\" + b);\n    }\n}\n@Component\npublic class B implements InitializingBean {\n\n    @Autowired\n    private A a;\n\n    @Override\n    public void afterPropertiesSet() throws Exception {\n        System.out.println(\"B:\" + a.getName());\n    }\n}\n@Aspect\n@Component\npublic class AopConfig {\n\n    /**\n     * 精确匹配类名\n     */\n    @Pointcut(\"within(A)\")\n    private void matchClass() {\n    }\n\n    @Before(\"matchClass()\")\n    public void beforeMatchClassName() {\n        System.out.println(\"--------精确匹配类名-------\");\n    }\n\n}\n\n```\n\n**执行结果:**\n\n```java \n--------精确匹配类名-------\nB:孙悟空\nA:com.example.demo.B@5e01a982\n```\n\n发现疑问了吗? 前面我们说了,在执行B图例8的时候(b的初始化方法)，A图例9并没有执行，那为什么这里会代理成功呢?\n![](https://img.springlearn.cn/blog/learn_1647105949000.png)\n\n::: info 答案揭晓\n这里在添加缓存的时候，并不是直接把实例添加到缓存中的。\n而是将图例9的逻辑，封装到\nObjectFactory的方式添加到缓存中的。\nObjectFactory#getObject时候执行了Bean\n的处理。(AOP代理等)\n:::\n\n**注意: 这里并不是把所有的处理器都包装到ObjectFactory方法中,而是有选择的使用,只有实现了SmartInstantiationAwareBeanPostProcessor接口\n才会放到里面。**\n\n\n![](https://img.springlearn.cn/blog/learn_1647106252000.png)\n\n答案就在这里，这里执行了。一些特殊逻辑的处理器。当实现了 `SmartInstantiationAwareBeanPostProcessor` 接口。\n就可以提前对那些半成品的Bean进行处理。 \n```java {4,5,6,7}\nprotected Object getEarlyBeanReference(String beanName, RootBeanDefinition mbd, Object bean) {\n\t\tObject exposedObject = bean;\n\t\tif (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {\n\t\t\tfor (SmartInstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().smartInstantiationAware) {\n\t\t\t\texposedObject = bp.getEarlyBeanReference(exposedObject, beanName);\n\t\t\t}\n\t\t}\n\t\treturn exposedObject;\n\t}\n```\n\n比如AOP的实现类。\n![](https://img.springlearn.cn/blog/learn_1647106893000.png)\n\n\n这里我们在思考一个问题。A半成品的时候被AOP代理了一次，那么当A在执行Bean处理器的时候岂不是有要被代理一次吗? \n\nAbstractAutoProxyCreator#getEarlyBeanReference\n\n第一次代理时候会被加到缓存中。\n\n```java \n    public Object getEarlyBeanReference(Object bean, String beanName) {\n        Object cacheKey = this.getCacheKey(bean.getClass(), beanName);\n        this.earlyProxyReferences.put(cacheKey, bean);\n        return this.wrapIfNecessary(bean, beanName, cacheKey);\n    }\n```\n\n第二次时候在执行AOP后置处理器,会先判断缓存,如果缓存中存在就不在处理了。\n\n```java \n   public Object postProcessAfterInitialization(@Nullable Object bean, String beanName) {\n        if (bean != null) {\n            Object cacheKey = this.getCacheKey(bean.getClass(), beanName);\n            if (this.earlyProxyReferences.remove(cacheKey) != bean) {\n                return this.wrapIfNecessary(bean, beanName, cacheKey);\n            }\n        }\n\n        return bean;\n    }\n```\n\n## 四、知识点总结\n\n### 4.1 满足循环依赖的条件是什么?\n\n1. 必须是单例模式\n2. 循环依赖类,必须能实例化(空构造,或构造参数满足循环依赖条件)\n\n### 4.2 循环依赖可能导致什么问题?\n\n在执行初始化的时候，如果初始化方法，依赖循环来的属性注入参数，可能导致获取不到数据信息的情况\n\n如上面问题1。\n\n### 4.3 为什么要用三级缓存而不是二级缓存?\n\n为了满足Spring声明周期方法,即对半成品的B进行提前生命周期处理。如实现AOP。\n\n\n## 五、开放性问题\n\n只使用一级缓存，和三级缓存是否就能解决循环依赖，并且满足bean一些特殊逻辑处理呢（eg:aop）?\n\n```java {11}\nprotected Object getSingleton(String beanName, boolean allowEarlyReference) {\n\t\t// Quick check for existing instance without full singleton lock\n\t\tObject singletonObject = this.singletonObjects.get(beanName);\n\t\tif (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {\n\t\t\tsingletonObject = this.earlySingletonObjects.get(beanName);\n\t\t\tif (singletonObject == null && allowEarlyReference) {\n\t\t\t\tsynchronized (this.singletonObjects) {\n\t\t\t\t\t// Consistent creation of early reference within full singleton lock\n\t\t\t\t\tsingletonObject = this.singletonObjects.get(beanName);\n\t\t\t\t\tif (singletonObject == null) {\n\t\t\t\t\t\tsingletonObject = this.earlySingletonObjects.get(beanName);\n\t\t\t\t\t\tif (singletonObject == null) {\n\t\t\t\t\t\t\tObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);\n\t\t\t\t\t\t\tif (singletonFactory != null) {\n\t\t\t\t\t\t\t\tsingletonObject = singletonFactory.getObject();\n\t\t\t\t\t\t\t\tthis.earlySingletonObjects.put(beanName, singletonObject);\n\t\t\t\t\t\t\t\tthis.singletonFactories.remove(beanName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn singletonObject;\n\t}\n\n```\n\n小编回答:  仅仅使用1级缓存和3级缓存完全可以的。\n\n之所以使用2级缓存是因为三级缓存是ObjectFactory#getObject()。是每次都从工厂里面去拿。而使用了2级缓存，仅仅是为了提高性能。\n而设计的。所以一单这个单例Bean完成后。会里面把二级和三级缓存给移除掉。\n\n\n```java \nprotected void addSingleton(String beanName, Object singletonObject) {\n\t\tsynchronized (this.singletonObjects) {\n\t\t\tthis.singletonObjects.put(beanName, singletonObject);\n\t\t\tthis.singletonFactories.remove(beanName);\n\t\t\tthis.earlySingletonObjects.remove(beanName);\n\t\t\tthis.registeredSingletons.add(beanName);\n\t\t}\n\t}\n```\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/spring/Spring循环依赖.md b/docs/learn/spring/Spring循环依赖.md
--- a/docs/learn/spring/Spring循环依赖.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/spring/Spring循环依赖.md	(date 1655373430505)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/project/jmvn/README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: true\nfooter: true\nbacktotop: true\ntitle: 基于命令行的Java脚手架\n---\n\n::: tip jmvn\n\n现阶段SpringBoot + Maven多模块是构建Java后台项目的标准格式，但是Maven多模块和成熟的Java项目结构搭建起来也是比较费力的。\n对于一个老鸟来说可能需要5分钟,但是对于一个小白或者是非专业认识,可能需要更长的时间。\n这里提供一个命令行交互式的构建工具，希望能解决这种简单重复的工作。\njmvn就是为了解决这问题诞生的, 一个快速构建Maven多模块应用的构建工具 [![](https://img.shields.io/badge/-jmvn-green?style=for-the-badge&logo=appveyor)](https://github.com/lxchinesszz/mvn-cli\n)\n它不仅能提供快速构建项目的能力，同时也能快速的安装数据模型生成Java对象,同时也可能快速导出数据库表结构信息，生成表结构文档。\n:::\n\n\n## 背景 & 目标\n\n目标打造一个简单好用的 Java 服务脚手架工具，让任何没有开发经验的同学都能快速构建一个可以运行的项目\n\n工具围绕几个方面进行开发, 力求在以下方面提高开发的工作效率, 同时同过脚手架的方式从一开始就统一下项目结构和模型。\n\n- 深度定制 (定制公司标准的项目结构)\n- 快速构建标准的Maven多模块服务\n- 支持数据库模型快速安装 (一次配置终生使用, 多快好省)\n- 数据库模型文档一键导出 (每次表结构变更, 快速导出最新表文档)\n\n## 一、介绍 | Introduce\n\n快速构建支持SpringBoot的Maven多模块应用,启动及快速打包部署\n\n- 支持Maven多模块构建、\n- 数据库模型安装、\n- 数据库模型导出),\n- 统一项目规范,\n- 提高工作效率,\n- 可进行深度定制。\n\n\n## 二、快速安装 | Fast installation\n\n## 2.1 Node环境安装\n\n:::: code-group\n\n::: code-group-item Window\n\n```\nhttps://nodejs.org/dist/v14.15.5/node-v14.15.5-x64.msi\n```\n\n:::\n\n::: code-group-item Mac:active\n\n```\nhttps://nodejs.org/dist/v15.9.0/node-v15.9.0.pkg\n```\n\n:::\n\n::::\n\n\n## 2.2 安装\n\n```\n➜ npm i jmvn -g\n```\n\n## 三、功能介绍\n\n## 3.1 快速构建 | To quickly build\n\n![](https://img.springlearn.cn/blog/learn_1650116393000.png)\n\n### 3.1.1 命令行构建项目 | Command line build\n\n```\nℹ Build:shop/shop-web/src/main/java/com/github/shop/web/\nℹ Build:shop/shop-web/src/main/resources/\nℹ Build:shop/shop-web/src/main/java/com/github/shop/web/\nℹ MavenHooks webPath:shop/shop-web/src/main/java/com/github/shop/web/\n✔ Build: Add SpringBoot Config:shop/shop-web/src/main/resources/application.yml\nℹ Build:shop/shop-service/src/main/java/com/github/shop/service/\nℹ Build:shop/shop-service/src/main/resources/\nℹ Build:shop/shop-service/src/main/java/com/github/shop/service/\nℹ MavenHooks servicePath:shop/shop-service/src/main/java/com/github/shop/service/\nℹ Build:shop/shop-domain/src/main/java/com/github/shop/domain/\nℹ Build:shop/shop-domain/src/main/resources/\nℹ Build:shop/shop-domain/src/main/java/com/github/shop/domain/\nℹ MavenHooks domainPath:shop/shop-domain/src/main/java/com/github/shop/domain/\nℹ Build:shop/shop-dal/src/main/java/com/github/shop/dal/\nℹ Build:shop/shop-dal/src/main/resources/\nℹ Build:shop/shop-dal/src/main/java/com/github/shop/dal/\nℹ MavenHooks dalPath:shop/shop-dal/src/main/java/com/github/shop/dal/\nℹ Build:shop/shop-integration/src/main/java/com/github/shop/integration/\nℹ Build:shop/shop-integration/src/main/resources/\nℹ Build:shop/shop-integration/src/main/java/com/github/shop/integration/\nℹ MavenHooks integrationPath:shop/shop-integration/src/main/java/com/github/shop/integration/\nℹ Build:shop/shop-config/src/main/java/com/github/shop/config/\nℹ Build:shop/shop-config/src/main/resources/\nℹ Build:shop/shop-config/src/main/java/com/github/shop/config/\nℹ MavenHooks configPath:shop/shop-config/src/main/java/com/github/shop/config/\nℹ Build:shop/shop-common/src/main/java/com/github/shop/common/\nℹ Build:shop/shop-common/src/main/resources/\nℹ Build:shop/shop-common/src/main/java/com/github/shop/common/\nℹ MavenHooks commonPath:shop/shop-common/src/main/java/com/github/shop/common/\n✔ GitIgnore before\n   __  ____   ___  __    _______   ____\n  /  |/  / | / / |/ /___/ ___/ /  /  _/\n / /|_/ /| |/ /    /___/ /__/ /___/ /\n/_/  /_/ |___/_/|_/    \\___/____/___/  Application shop Build Success\n\n✔ \uD83D\uDE80 JMVN CLI v1.0.6\n┌────────┬────────┬──────────┬────────────────┬──────────────────────────────────────┬────────┐\n│ 项目名 │ 作者   │ 项目版本 │ SpringBoot版本 │ 描述                                 │ 端口号 │\n├────────┼────────┼──────────┼────────────────┼──────────────────────────────────────┼────────┤\n│ shop   │ 周杰伦 │ 1.0.0    │ 0.5.1-RELEASE  │ 一个基于SpringBoot的商城项目后台服务 │ 10086  │\n└────────┴────────┴──────────┴────────────────┴──────────────────────────────────────┴────────┘\n✔ GitIgnore invoke\n✔ GitIgnore after\n```\n\n## 3.2 安装数据库库模型 | Install the database library model\n\n### 3.2.1 配置安装信息 | Configure installation information#\n\n- 配置项目开发数据库地址\n- 配置模型命名规则及安装目录\n\n```json\n{\n  \"dbConfig\": {\n    \"host\": \"10.*.*.121\",\n    \"user\": \"o*test\",\n    \"password\": \"9G****RZ\",\n    \"database\": \"***\"\n  },\n  \"models\": [\n    {\n      \"suffix\": \"DO\",\n      \"tableName\": [\n        \"w_order\",\n        \"w_push_order\"\n      ],\n      \"path\": \"scm-dao/src/main/java/com/idanchuang/scm/dao/entity/Do\"\n    }\n  ]\n}\n```\n\n### 3.2.2 执行命令 | Execute the command\n\n![](https://img.springlearn.cn/blog/learn_1650116518000.png)\n\n```\n➜ jmvn\nJMVN CLI v1.0.6\nUsage: jmvn [options] [command]\n\n快速构建支持SpringBoot的Maven多模块应用\n\nOptions:\n  -V, --version        output the version number\n  -h, --help           display help for command\n\nCommands:\n  init                 创建一个新的Maven多模块项目\n  install|i [options]  安装数据模型\n  export [options]     导出数据模型 (支持命令行模式 & 交互模式)\n  help [command]       display help for command\n```\n\n## 3.3 导出数据模型文档 | Export data model documents\n\n为了方便我们写技术文档, 支持直接导出成 markdown 格式文档。\n\n![](https://img.springlearn.cn/blog/learn_1650116581000.png)\n\n\n## 四、发布记录 | Release record\n\n**1.0.1**\n\n构建服务\n支持注册命令\n\n**1.0.2**\n\n代码精简及优化\n版本检测及升级\n\n**1.0.3**\n\nfix端口号映射问题\n\n**1.0.4**\n\n优化版本检测,在网络差场景的用户体验\n\n## 五、定制 | Custom\n\n\n为了达到深度定制的能力, 你所看到的一切都是可配置的。在模块每一层创建的同时也提供了钩子方法。允许你在钩子节点去做定制开发 。\n**[MavenHooks.js](https://github.com/lxchinesszz/mvn-cli/blob/master/action/MavenHooks.js)**\n\n欢迎感兴趣的小伙伴一起参与开发, \uD83D\uDE80 `call me！`\n\n微信: `lxchinesszz`\n邮箱: `lxchinesszz@163.com`\n\n## 六、扩展知识 | Expand the knowledge\n\n\n[代码命名规范参考建议](/learn/design/Java代码规范全部奉上/)\n\n项目结构设计支持配置, 在配置前请确定你的编程方法论和价值观。以下文档仅供参考。也是当前工具所保持的价值观。\n\n## 6.1 分层命名 | Hierarchical naming\n\n![](https://img.springlearn.cn/blog/learn_1650116968000.png)\n明确业务分层架构，定义领取模型, 编程不迷茫\n\n![](https://img.springlearn.cn/blog/learn_1650116958000.png)\n\n\n## 6.2 数据模型规范 | Data model specification\n![](https://img.springlearn.cn/blog/learn_1650117078000.png)\n迪米特法则: 不要和陌生人说话,数据模型之间保持最少的了解 迪米特法则: 不要和陌生人说话,数据模型之间保持最少的了\n\n![](https://img.springlearn.cn/blog/learn_1650117093000.png)\n\n## 七、插件开发 | Plug-in development\n\n脚手架工具会将在每个 Maven Module 创建过程中去发出不同对应的事件, 插件开发者可以不同的事件类型来开发插件。\n\n## 7.1 事件类型 | The event type\n\n\n| 事件类型     | 事件说明     | 环境信息                                   |\n| ------------ | ------------ | ------------------------------------------ |\n| BUILD_BEFORE | 构建前触发 | - |\n| BUILD_WEB | 构建web层触发 | { projectConfig: Object, currentPath: '' } |\n| BUILD_SERVICE | 构建service层触发 | { projectConfig: Object, currentPath: '' } |\n| BUILD_DOMAIN | 构建domain层触发 | { projectConfig: Object, currentPath: '' } |\n| BUILD_DAL | 构建dal层触发 | { projectConfig: Object, currentPath: '' } |\n| BUILD_INTEGRATION | 构建integration层触发 | { projectConfig: Object, currentPath: '' } |\n| BUILD_CONFIG | 构建config层触发 | { projectConfig: Object, currentPath: '' } |\n| BUILD_COMMON | 构建common通用层触发 | { projectConfig: Object, currentPath: '' } |\n| BUILD_COMPLETE | 构建完成触发 | { \"namespace\":Array[7], \"config\":Object, \"dbConfig\":Object, \"models\":Array[1], \"projectConfig\":Object } |\n| BUILD_JAVA_RESOURCE | 构建java资源文件时候触发 | { projectConfig: Object, currentPath: '' } |\n| BUILD_JAVA_WEB_RESOURCE | 构建java, Web资源文件时候触发 | { projectConfig: Object, currentPath: '' } |\n\n## 7.2 插件生命周期函数 | Life cycle function\n\n![](https://img.springlearn.cn/blog/learn_1650117675000.png)\n\n\n## 7.3 插件开发示例 | The sample\n\n\n### 7.3.1 创建目录 | Create a directory\n\n\n`plugins` 目录下创建插件子目录\n\n\n### 7.3.2 实现插件生命周期函数 | Write a function\n\n\n插件支持before、invoke、error、after。插件的核心逻辑在invoke，可以直接实现该方法即可。\n\n\n所有的声明周期函数都有且只有一个入参，但是不同事件入参信息是不一样的，可以参考 7.1 事件类型, 参数说明。\n\n\n```javascript\n// 方式1: 仅仅实现核心逻辑,不关注生命周期函数\nnew Plugin('GitIgnore', 'GitIgnore创建', PluginEventType.BUILD_COMPLETE, new GitAction().createGitIgnoreFile);\n\n// 方式2: 通过方法重写方式实现,生命周期方法\nlet plugin2 = new Plugin('GitIgnore', 'GitIgnore创建', PluginEventType.BUILD_COMPLETE);\n\nplugin2.before = function(envConfig){\n\tconsole.log('插件before')\n}\n\nplugin2.after  = function(envConfig){\n\tconsole.log('插件before')\n}\n```\n\n\n### 7.3.3 注册开发好的插件 | To register the plugin\n\n\n`plugins.Install.js`  进行注册\n```javascript\n/**\n * 定义插件\n *\n * before->invoke->success->after\n * error异常捕捉执行\n * @param name 插件名称\n * @param desc 插件说明\n * @param type 插件类型\n * @param action 插件核心逻辑\n * @constructor\n */\nfunction Plugin(name, desc, type, action) {}\n\n// 注册一个git忽略文件插件,接受maven构建完成事件\nPlugins.register(new Plugin('GitIgnore', 'GitIgnore创建', PluginEventType.BUILD_COMPLETE, new GitAction().createGitIgnoreFile))\n```\n\n\n### 7.3.4 完整的参数入参 | Parameters for details\n\n\n- 项目名称 `tests` 为例\n```json\n{\n    \"namespace\":[\n        {\n            \"type\":\"web\",\n            \"path\":\"tests/tests-web/src/main/java/com/idanchuang/tests/web/\",\n            \"packagePath\":\"com/idanchuang/tests/web\"\n        },\n        {\n            \"type\":\"service\",\n            \"path\":\"tests/tests-service/src/main/java/com/idanchuang/tests/service/\",\n            \"packagePath\":\"com/idanchuang/tests/service\"\n        },\n        {\n            \"type\":\"domain\",\n            \"path\":\"tests/tests-domain/src/main/java/com/idanchuang/tests/domain/\",\n            \"packagePath\":\"com/idanchuang/tests/domain\"\n        },\n        {\n            \"type\":\"dal\",\n            \"path\":\"tests/tests-dal/src/main/java/com/idanchuang/tests/dal/\",\n            \"packagePath\":\"com/idanchuang/tests/dal\"\n        },\n        {\n            \"type\":\"integration\",\n            \"path\":\"tests/tests-integration/src/main/java/com/idanchuang/tests/integration/\",\n            \"packagePath\":\"com/idanchuang/tests/integration\"\n        },\n        {\n            \"type\":\"config\",\n            \"path\":\"tests/tests-config/src/main/java/com/idanchuang/tests/config/\",\n            \"packagePath\":\"com/idanchuang/tests/config\"\n        },\n        {\n            \"type\":\"common\",\n            \"path\":\"tests/tests-common/src/main/java/com/idanchuang/tests/common/\",\n            \"packagePath\":\"com/idanchuang/tests/common\"\n        }\n    ],\n    \"config\":{\n        \"_projectName\":\"tests\",\n        \"_web\":\"web\",\n        \"_biz\":\"service\",\n        \"_domain\":\"domain\",\n        \"_dal\":\"dal\",\n        \"_integration\":\"integration\",\n        \"_config\":\"config\",\n        \"_common\":\"common\",\n        \"_groupId\":\"com.idanchuang\",\n        \"_projectVersion\":\"1.0.0\",\n        \"_projectDescription\":\"description\",\n        \"_springBootVersion\":\"0.5.1-RELEASE\"\n    },\n    \"projectConfig\":{\n        \"projectName\":\"tests\",\n        \"web\":\"web\",\n        \"biz\":\"service\",\n        \"domain\":\"domain\",\n        \"dal\":\"dal\",\n        \"integration\":\"integration\",\n        \"config\":\"config\",\n        \"common\":\"common\",\n        \"groupId\":\"com.idanchuang\",\n        \"projectVersion\":\"1.0.0\",\n        \"mavenSurefireJavaVersion\":\"1.8\",\n        \"projectDescription\":\"description\",\n        \"springBootVersion\":\"0.5.1-RELEASE\",\n        \"port\":\"8081\",\n        \"projectAuthor\":\"mvn-cli\",\n        \"modelFlag\":true\n    }\n}\n```\n\n\n## 7.4 插件测试 | Plug-in Test\n\n配置完成即可进行 `debug`\n\n\n![](https://img.springlearn.cn/blog/learn_1650117812000.png)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/project/jmvn/README.md b/docs/learn/project/jmvn/README.md
--- a/docs/learn/project/jmvn/README.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/project/jmvn/README.md	(date 1655373430389)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/.vuepress/theme/styles/code/index.styl
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>{$contentClass}\n  code\n    //color var(--text-color-l20)\n    //padding 0.25rem 0.5rem\n    //margin 0\n    //font-size 0.85em\n    //border-radius 3px\n    //overflow-wrap break-word\n    border: 0;\n    padding: 2px 4px;\n    color: #D83B64;\n    background-color: #f9f2f4;\n    border-radius: 3px;\n    position: relative;\n    bottom: 1px;\n    font-family: monospace;\n    .token\n      &.deleted\n        color #EC5975\n\n      &.inserted\n        color var(--accent-color)\n  mark\n    border: 0;\n    padding: 2px 4px;\n    color: #fff;\n    background-color: #42b983;\n    border-radius: 3px;\n    position: relative;\n    bottom: 1px;\n    font-family: monospace;\n\n{$contentClass}\n  pre, pre[class*='language-']\n    line-height 1.4\n    padding 1.25rem 1.5rem\n    margin 0.85rem 0\n    background var(--code-bgcolor)\n    border-radius 6px\n    overflow auto\n\n    code\n      color var(--grey3)\n      padding 0\n      background transparent !important\n      border-radius 0\n\ndiv[class*='language-']\n  position relative\n  background var(--code-bgcolor)\n  border-radius 6px\n\n  &.line-numbers-mode\n    padding-left $lineNumbersWrapperWidth\n\n  .highlight-lines\n    user-select none\n    padding-top 1.3rem\n    position absolute\n    top 0\n    left 0\n    width 100%\n    line-height 1.4\n\n  pre, pre[class*='language-']\n    background transparent\n    position relative\n    z-index 1\n\n    code\n      position relative !important\n\n  &::before\n    position absolute\n    z-index 3\n    top 0.8em\n    right 1em\n    font-size 0.75rem\n\n  &:not(.line-numbers-mode)\n    .line-numbers-wrapper\n      display none\n\n  &.line-numbers-mode\n    .highlight-lines .highlighted\n      position relative\n\n      &:before\n        content ' '\n        position absolute\n        z-index 3\n        top 0\n        left 0\n        display block\n        width $lineNumbersWrapperWidth\n        height 100%\n\n    pre\n      vertical-align middle\n\n    .line-numbers-wrapper\n      position absolute\n      top 0\n      left 0\n      width $lineNumbersWrapperWidth\n      text-align center\n      padding 1.25rem 0\n      line-height 1.4\n\n      br\n        user-select none\n\n      .line-number\n        position relative\n        z-index 4\n        user-select none\n        font-size 0.85em\n\n    &::after\n      content ''\n      position absolute\n      z-index 2\n      top 0\n      left 0\n      width $lineNumbersWrapperWidth\n      height 100%\n      border-radius 6px 0 0 6px\n      background var(--code-bgcolor)\n\n      @media (max-width $MQMobileNarrow)\n        border-radius 0\n\nfor lang in $codeLang\n  div{'[class~=\"language-' + lang + '\"]'}\n    &:before\n      content '' + lang\n\ndiv[class~='language-javascript']\n  &:before\n    content 'js'\n\ndiv[class~='language-typescript']\n  &:before\n    content 'ts'\n\ndiv[class~='language-markup']\n  &:before\n    content 'html'\n\ndiv[class~='language-markdown']\n  &:before\n    content 'md'\n\ndiv[class~='language-json']:before\n  content 'json'\n\ndiv[class~='language-ruby']:before\n  content 'rb'\n\ndiv[class~='language-python']:before\n  content 'py'\n\ndiv[class~='language-bash']:before\n  content 'sh'\n\ndiv[class~='language-php']:before\n  content 'php'\n\ndiv[class~='language-stylus']:before\n  content 'styl'\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/.vuepress/theme/styles/code/index.styl b/docs/.vuepress/theme/styles/code/index.styl
--- a/docs/.vuepress/theme/styles/code/index.styl	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/.vuepress/theme/styles/code/index.styl	(date 1654013241332)
@@ -9,6 +9,7 @@
     border: 0;
     padding: 2px 4px;
     color: #D83B64;
+    font-weight: 500;
     background-color: #f9f2f4;
     border-radius: 3px;
     position: relative;
Index: docs/learn/spring/Spring动态绑定配置.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: true\nfooter: true\nbacktotop: true\ntitle: 动态绑定配置\ncategory: Spring\n---\n\n![](https://img.springlearn.cn/blog/learn_1652957155000.png)\n\n## 一、如何实现动态配置\n\n在Spring体系下,如果实现了ConfigurationProperties则会自动刷新。而如果只使用`@Value`的方法,要加上 `@RefreshScope` 才能实现。\n本篇文章我们来分别研究下他们的原理。然后在来看看其他的方案是如何做的吧。\n\n## 二、实现原理\n\n## 2.1 @ConfigurationProperties\n\n所有被`@ConfigurationProperties`修饰的类都会被ConfigurationPropertiesBeans处理\n\n1. 实现`BeanPostProcessor`处理器，初始化时候判断是否被`@ConfigurationProperties`修饰,如果是就保存到`ConfigurationPropertiesBeans#beans属性中`\n\n```java \n    public Object postProcessBeforeInitialization(Object bean, String beanName)\n\t\t\tthrows BeansException {\n\t\t// 1. 如果已经被RefreshScope修饰了,也会自动更新就不用在处理了。 \t\n\t\tif (isRefreshScoped(beanName)) {\n\t\t\treturn bean;\n\t\t}\n\t\tConfigurationProperties annotation = AnnotationUtils\n\t\t\t\t.findAnnotation(bean.getClass(), ConfigurationProperties.class);\n\t\tif (annotation != null) {\n\t\t\tthis.beans.put(beanName, bean);\n\t\t}\n\t\telse if (this.metaData != null) {\n\t\t\tannotation = this.metaData.findFactoryAnnotation(beanName,\n\t\t\t\t\tConfigurationProperties.class);\n\t\t\tif (annotation != null) {\n\t\t\t\tthis.beans.put(beanName, bean);\n\t\t\t}\n\t\t}\n\t\treturn bean;\n\t}\n\n```\n\n\n2. ConfigurationPropertiesRebinder 实现 `EnvironmentChangeEvent` 变更事件, 当收到EnvironmentChangeEvent事件 \n会重新触发绑定事件。需要绑定的bean就从ConfigurationPropertiesBeans#beans属性中获取。\n\n具体的实现类 `ConfigurationPropertiesRebinder`\n\n1. 先调用销毁方法\n2. 然后重新初始化\n```java \n    // 接受事件\n    public void onApplicationEvent(EnvironmentChangeEvent event) {\n\t\tif (this.applicationContext.equals(event.getSource())\n\t\t\t\t// Backwards compatible\n\t\t\t\t|| event.getKeys().equals(event.getSource())) {\n\t\t\trebind();\n\t\t}\n\t}\n\t// 重新绑定\n    public boolean rebind(String name) {\n\t\tif (!this.beans.getBeanNames().contains(name)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this.applicationContext != null) {\n\t\t\ttry {\n\t\t\t\tObject bean = this.applicationContext.getBean(name);\n\t\t\t\tif (AopUtils.isAopProxy(bean)) {\n\t\t\t\t\tbean = ProxyUtils.getTargetObject(bean);\n\t\t\t\t}\n\t\t\t\tif (bean != null) {\n\t\t\t\t\tthis.applicationContext.getAutowireCapableBeanFactory()\n\t\t\t\t\t\t\t.destroyBean(bean);\n\t\t\t\t\tthis.applicationContext.getAutowireCapableBeanFactory()\n\t\t\t\t\t\t\t.initializeBean(bean, name);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (RuntimeException e) {\n\t\t\t\tthis.errors.put(name, e);\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthis.errors.put(name, e);\n\t\t\t\tthrow new IllegalStateException(\"Cannot rebind to \" + name, e);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n```\n\n## 2.2 @RefreshScope\n\n`@RefreshScope` 的原理相对流程较长，首先他需要你将类用 `@RefreshScope`来修饰。\n\n\n1. 首先明确那些是被修饰的`AnnotatedBeanDefinitionReader#registerBean`。\n\n```java AnnotatedBeanDefinitionReader#registerBean\n<T> void doRegisterBean(Class<T> annotatedClass, @Nullable Supplier<T> instanceSupplier, @Nullable String name,\n\t\t\t@Nullable Class<? extends Annotation>[] qualifiers, BeanDefinitionCustomizer... definitionCustomizers) {\n\n\t\tAnnotatedGenericBeanDefinition abd = new AnnotatedGenericBeanDefinition(annotatedClass);\n\t\tif (this.conditionEvaluator.shouldSkip(abd.getMetadata())) {\n\t\t\treturn;\n\t\t}\n\n\t\tabd.setInstanceSupplier(instanceSupplier);\n\t\tScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(abd);\n\t\tabd.setScope(scopeMetadata.getScopeName());\n\t\t...\n\t\tBeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName);\n\t\t// 创建bean描述信息 beanClass = ScopedProxyFactoryBean\n\t\t// ScopedProxyCreator#createScopedProxy->ScopedProxyUtils#createScopedProxy\n\t\tdefinitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);\n\t\tBeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry);\n\n}\t\t\n```\n\n2. 被Scope修饰的beanClass都是ScopedProxyFactoryBean\n    - GenericScope 实现BeanFactoryPostProcessor 会提前将RefreshScope注册到BeanFactory中\n    - beanFactory.registerScope(this.name, this)\n    - 当执行完上面 AbstractBeanFactory#scopes属性中就有值了。对于RefreshScope name = refresh\n```java \npublic class GenericScope implements Scope, BeanFactoryPostProcessor,\n\t\tBeanDefinitionRegistryPostProcessor, DisposableBean {\n\n}\npublic class RefreshScope extends GenericScope implements ApplicationContextAware,\n\t\tApplicationListener<ContextRefreshedEvent>, Ordered {\t\n}\t\t\n```\n \n3. 当getBean时候,对于域对象会有特殊的处理逻辑,会调用 `Scope#get(String name, ObjectFactory<?> objectFactory)`\n\n```java \n\tprotected <T> T doGetBean(final String name, @Nullable final Class<T> requiredType,\n\t\t\t@Nullable final Object[] args, boolean typeCheckOnly) throws BeansException {\n\t\t\t...\n\t\t\t\t// 创建单例逻辑\n\t\t\t\tif (mbd.isSingleton()) {\n\t\t\t\t\t...\n\t\t\t\t\tbean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);\n\t\t\t\t}\n\t\t\t\t// 创建原型逻辑\n\t\t\t\telse if (mbd.isPrototype()) {\n\t\t\t\t\t...\n\t\t\t\t\tbean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t    // 创建域对象\n\t\t\t\t    // refresh\n\t\t\t\t\tString scopeName = mbd.getScope();\n\t\t\t\t\t// RefreshScope\n\t\t\t\t\tfinal Scope scope = this.scopes.get(scopeName);\n\t\t\t\t\tif (scope == null) {\n\t\t\t\t\t\tthrow new IllegalStateException(\"No Scope registered for scope name '\" + scopeName + \"'\");\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tObject scopedInstance = scope.get(beanName, () -> {\n\t\t\t\t\t\t\tbeforePrototypeCreation(beanName);\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\treturn createBean(beanName, mbd, args);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfinally {\n\t\t\t\t\t\t\t\tafterPrototypeCreation(beanName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn (T) bean;\n\t}\n```\n\n\n```java \npublic interface Scope {\n\tObject get(String name, ObjectFactory<?> objectFactory); \n}\npublic class GenericScope implements Scope, BeanFactoryPostProcessor,\n\t\tBeanDefinitionRegistryPostProcessor, DisposableBean {}\npublic class RefreshScope extends GenericScope implements ApplicationContextAware,\n\t\tApplicationListener<ContextRefreshedEvent>, Ordered {}\t\t\n```\n\n4. RefreshEventListener 接受事件，触发刷新操作\n\n```java \npublic class RefreshEventListener implements SmartApplicationListener {\n    private ContextRefresher refresh;\n    @Override\n\tpublic void onApplicationEvent(ApplicationEvent event) {\n\t\tif (event instanceof ApplicationReadyEvent) {\n\t\t\thandle((ApplicationReadyEvent) event);\n\t\t}\n\t\telse if (event instanceof RefreshEvent) {\n\t\t\thandle((RefreshEvent) event);\n\t\t}\n\t}\n\n\tpublic void handle(ApplicationReadyEvent event) {\n\t\tthis.ready.compareAndSet(false, true);\n\t}\n\n\tpublic void handle(RefreshEvent event) {\n\t\tif (this.ready.get()) { // don't handle events before app is ready\n\t\t\tlog.debug(\"Event received \" + event.getEventDesc());\n\t\t\tSet<String> keys = this.refresh.refresh();\n\t\t\tlog.info(\"Refresh keys changed: \" + keys);\n\t\t}\n\t}\n}\n```\n\n5. ContextRefresher#refresh\n   1. refreshEnvironment刷新环境\n   2. 调用RefreshScope#refreshAll\n\n```java \npublic class ContextRefresher {\n   public synchronized Set<String> refresh() {\n\t\tSet<String> keys = refreshEnvironment();\n\t\tthis.scope.refreshAll();\n\t\treturn keys;\n\t}\n\n\tpublic synchronized Set<String> refreshEnvironment() {\n\t\tMap<String, Object> before = extract(\n\t\t\t\tthis.context.getEnvironment().getPropertySources());\n\t\taddConfigFilesToEnvironment();\n\t\tSet<String> keys = changes(before,\n\t\t\t\textract(this.context.getEnvironment().getPropertySources())).keySet();\n\t\tthis.context.publishEvent(new EnvironmentChangeEvent(this.context, keys));\n\t\treturn keys;\n\t}\n}\n```\n\n6. RefreshScope#refreshAll\n会将容器中的bean给销毁。\n而ScopedProxyFactoryBean中getObject是一个代理对象。带代理类每次都从容器中获取。而容器前面已经将被RefreshScope修饰的类给销毁了\n测试拿到的对象就是重新从容器中生成的。\n\n```java  \npublic class ScopedProxyFactoryBean extends ProxyConfig\n\t\timplements FactoryBean<Object>, BeanFactoryAware, AopInfrastructureBean {\n\tprivate Object proxy;\t\n\tprivate final SimpleBeanTargetSource scopedTargetSource = new SimpleBeanTargetSource();\n\t@Override\n\tpublic void setBeanFactory(BeanFactory beanFactory) {\n        ...\n\t\tProxyFactory pf = new ProxyFactory();\n\t\tpf.copyFrom(this);\n\t\tpf.setTargetSource(this.scopedTargetSource);\n\t\tthis.proxy = pf.getProxy(cbf.getBeanClassLoader());\n\t}\n}\t\t\n\npublic class SimpleBeanTargetSource extends AbstractBeanFactoryBasedTargetSource {\n\t@Override\n\tpublic Object getTarget() throws Exception {\n\t\treturn getBeanFactory().getBean(getTargetBeanName());\n\t}\n}\n```\n\n## 三、其他方案\n\n因为我们项目中用的是阿波罗，那我们只看阿波罗是如何来做的吧。\n在阿波罗只用使用@Value就行了\n\n## 3.1 先扫描@Value注解\n\n将被@Value修饰的Bean和配置key先生成一个`SpringValue`对象然后注册到`SpringValueRegistry`中\n\n```java \npublic class SpringValueProcessor extends ApolloProcessor implements BeanFactoryPostProcessor, BeanFactoryAware {\n   protected void processField(Object bean, String beanName, Field field) {\n       // register @Value on field\n       Value value = field.getAnnotation(Value.class);\n       if (value == null) {\n         return;\n       }\n       Set<String> keys = placeholderHelper.extractPlaceholderKeys(value.value());\n   \n       if (keys.isEmpty()) {\n         return;\n       }\n   \n       for (String key : keys) {\n         SpringValue springValue = new SpringValue(key, value.value(), bean, beanName, field, false);\n         springValueRegistry.register(beanFactory, key, springValue);\n         logger.debug(\"Monitoring {}\", springValue);\n       }\n  }\n}\n```\n\n## 3.2 找到需要更新的Bean\n\n接受到配置变更事件后,遍历本地变更的配置key，然后将本次key关联需要变更的Bean,从`springValueRegistry`中找到。\n\n```java \npublic class AutoUpdateConfigChangeListener implements ConfigChangeListener{\n   @Override\n  public void onChange(ConfigChangeEvent changeEvent) {\n    Set<String> keys = changeEvent.changedKeys();\n    if (CollectionUtils.isEmpty(keys)) {\n      return;\n    }\n    for (String key : keys) {\n      // 1. check whether the changed key is relevant\n      Collection<SpringValue> targetValues = springValueRegistry.get(beanFactory, key);\n      if (targetValues == null || targetValues.isEmpty()) {\n        continue;\n      }\n\n      // 2. update the value\n      for (SpringValue val : targetValues) {\n        updateSpringValue(val);\n      }\n    }\n  }\n}\n```\n\n## 3.3 通过反射的方法注入\n\n```java \npublic class SpringValue {\n   public void update(Object newVal) throws IllegalAccessException, InvocationTargetException {\n       if (isField()) {\n         injectField(newVal);\n       } else {\n         injectMethod(newVal);\n       }\n     }\n    private void injectField(Object newVal) throws IllegalAccessException {\n       Object bean = beanRef.get();\n       if (bean == null) {\n         return;\n       }\n       boolean accessible = field.isAccessible();\n       field.setAccessible(true);\n       field.set(bean, newVal);\n       field.setAccessible(accessible);\n     }\n}\n```\n\n非常简单，高效。相比使用@RefreshScope是不是清爽多了呢?\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/spring/Spring动态绑定配置.md b/docs/learn/spring/Spring动态绑定配置.md
--- a/docs/learn/spring/Spring动态绑定配置.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/spring/Spring动态绑定配置.md	(date 1655373430567)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/mybatis/Mapper代理对象创建.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: true\nfooter: true\npassword: 111\nbacktotop: true\ntitle: 第04篇:Mybatis代理对象生成\ncategory: Mybatis\n---\n\n<PageBanner/>\n\n\n## 一、架构分析\n\nMybatis中Mapper一般只是一个接口,  那么为什么能执行数据操作的呢? 那肯定是基于代理没得说。在了解Mybatis如何实现代理\n前,  我们先大概看下它的架构是什么样的,  对这些关键的类有个大概的认识,  知道它所处的位置在哪里。\n\n![](https://img.springlearn.cn/blog/learn_1649424512000.png)\n\n本篇我们只深入研究下代理层,   学习下mybatis是如何进行代理操作的,   而关于sql的最终执行,   放到下一篇执行流程中来研究。\n\n\n## 二、源码分析\n\n![](https://img.springlearn.cn/blog/learn_1649301019000.png)\n\n首先不要慌,  看上面这个图,  Mybatis的代理流程还是比较简单的。下面主要看下每个核心的类是做什么用的。\n\n## 2.1 MapperProxyFactory\n\n- 代理工厂里面看代码是比较简单的,  就是利用Proxy创建代理对象。\n- 对于已经生成的代理方法,  直接放到MethodCache缓存起来。\n\n```java \npublic class MapperProxyFactory<T> {\n\n  private final Class<T> mapperInterface;\n  private final Map<Method,   MapperMethodInvoker> methodCache = new ConcurrentHashMap<>();\n\n  // Jdk代理Proxy,  可以看到主要逻辑在MapperProxy中\n  protected T newInstance(MapperProxy<T> mapperProxy) {\n    return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(),   new Class[] { mapperInterface },   mapperProxy);\n  }\n\n  public T newInstance(SqlSession sqlSession) {\n    final MapperProxy<T> mapperProxy = new MapperProxy<>(sqlSession,   mapperInterface,   methodCache);\n    return newInstance(mapperProxy);\n  }\n\n}\n```\n\n## 2.2 MapperProxy \n\nMapperProxy 的代理逻辑也非常简单,  就以下三个能力,  看图理解。\n\n![](https://img.springlearn.cn/blog/learn_1649079715000.png)\n\n下面将核心的处理代码给挑选了出来,  增加了注释。\n\n```java \npublic class MapperProxy<T> implements InvocationHandler,   Serializable {\n  @Override\n  public Object invoke(Object proxy,   Method method,   Object[] args) throws Throwable {\n    try {\n      // Object方法直接执行\n      if (Object.class.equals(method.getDeclaringClass())) {\n        return method.invoke(this,   args);\n      } else {\n        // 其他方法生成代理方法\n        return cachedInvoker(method).invoke(proxy,   method,   args,   sqlSession);\n      }\n    } catch (Throwable t) {\n      throw ExceptionUtil.unwrapThrowable(t);\n    }\n  }\n  \n  private MapperMethodInvoker cachedInvoker(Method method) throws Throwable {\n    try {\n      return MapUtil.computeIfAbsent(methodCache,   method,   m -> {\n        // 如果是默认方法\n        if (m.isDefault()) {\n          try {\n            if (privateLookupInMethod == null) {\n              // 生成java8的语法解析生成代理方法\n              return new DefaultMethodInvoker(getMethodHandleJava8(method));\n            } else {\n              // // 生成java9的语法解析生成代理方法\n              return new DefaultMethodInvoker(getMethodHandleJava9(method));\n            }\n          } catch (IllegalAccessException | InstantiationException | InvocationTargetException\n              | NoSuchMethodException e) {\n            throw new RuntimeException(e);\n          }\n        } else {\n        // 不是默认方法,   生成代理方法 MapperMethod\n          return new PlainMethodInvoker(new MapperMethod(mapperInterface,   method,   sqlSession.getConfiguration()));\n        }\n      });\n    } catch (RuntimeException re) {\n      Throwable cause = re.getCause();\n      throw cause == null ? re : cause;\n    }\n  }\n}\n```\n\n## 2.3 PlainMethodInvoker\n\n前面说了代理方法主要有三种场景。\n\n![](https://img.springlearn.cn/blog/learn_1649079715000.png)\n\n1. Object方法直接method.invoker(this,  args);\n2. default关键字修饰的方法,  是DefaultMethodInvoker\n3. 而更重要的要执行sql的代理Invoker是PlainMethodInvoker\n\n\nPlainMethodInvoker 才是真正处理需要进行sql的具体实现类。真正的代理逻辑在 MapperMethod 中。\n\n```java \nprivate static class PlainMethodInvoker implements MapperMethodInvoker {\n    private final MapperMethod mapperMethod;\n\n    public PlainMethodInvoker(MapperMethod mapperMethod) {\n      super();\n      this.mapperMethod = mapperMethod;\n    }\n\n    @Override\n    public Object invoke(Object proxy,   Method method,   Object[] args,   SqlSession sqlSession) throws Throwable {\n      return mapperMethod.execute(sqlSession,   args);\n    }\n  }\n```\n\nMapperMethod,  简单看下流程,   里面有2个重要的实现类,   分别用于判断sql类型,   处理方法参数(解析@Param参数)并最终交给SqlSession执行。到这里就把代理的\n流程给搞清楚了。但是具体sql怎么组装参数,   如何调用数据库jdbc接口,   都还没有看到。这部分内容。我们放到下一篇 [第05篇:Mybatis的SQL执行流程分析](../Mybatis执行流程分析)\n\n```java \npublic class MapperMethod {\n\n  private final SqlCommand command;\n  private final MethodSignature method;\n\n  public MapperMethod(Class<?> mapperInterface,   Method method,   Configuration config) {\n    this.command = new SqlCommand(config,   mapperInterface,   method);\n    this.method = new MethodSignature(config,   mapperInterface,   method);\n  }\n\n  public Object execute(SqlSession sqlSession,   Object[] args) {\n    Object result;\n    switch (command.getType()) {\n      case INSERT: {\n        Object param = method.convertArgsToSqlCommandParam(args);\n        result = rowCountResult(sqlSession.insert(command.getName(),   param));\n        break;\n      }\n      case UPDATE: {\n        Object param = method.convertArgsToSqlCommandParam(args);\n        result = rowCountResult(sqlSession.update(command.getName(),   param));\n        break;\n      }\n      case DELETE: {\n        Object param = method.convertArgsToSqlCommandParam(args);\n        result = rowCountResult(sqlSession.delete(command.getName(),   param));\n        break;\n      }\n      case SELECT:\n        if (method.returnsVoid() && method.hasResultHandler()) {\n          executeWithResultHandler(sqlSession,   args);\n          result = null;\n        } else if (method.returnsMany()) {\n          result = executeForMany(sqlSession,   args);\n        } else if (method.returnsMap()) {\n          result = executeForMap(sqlSession,   args);\n        } else if (method.returnsCursor()) {\n          result = executeForCursor(sqlSession,   args);\n        } else {\n          Object param = method.convertArgsToSqlCommandParam(args);\n          result = sqlSession.selectOne(command.getName(),   param);\n          if (method.returnsOptional()\n              && (result == null || !method.getReturnType().equals(result.getClass()))) {\n            result = Optional.ofNullable(result);\n          }\n        }\n        break;\n      case FLUSH:\n        result = sqlSession.flushStatements();\n        break;\n      default:\n        throw new BindingException(\"Unknown execution method for: \" + command.getName());\n    }\n    if (result == null && method.getReturnType().isPrimitive() && !method.returnsVoid()) {\n      throw new BindingException(\"Mapper method '\" + command.getName()\n          + \" attempted to return null from a method with a primitive return type (\" + method.getReturnType() + \").\");\n    }\n    return result;\n  }\n\n}\n```\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/mybatis/Mapper代理对象创建.md b/docs/learn/mybatis/Mapper代理对象创建.md
--- a/docs/learn/mybatis/Mapper代理对象创建.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/mybatis/Mapper代理对象创建.md	(date 1655373430516)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/mybatis/Mybatis执行流程分析.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: true\nfooter: true\npassword: 111\nbacktotop: true\ntitle: 第05篇:Mybatis的SQL执行流程分析\ncategory: Mybatis\n---\n\n<PageBanner/>\n\n\n## 一、前言\n\n前面我们知道了Mybatis是如何进行代理的, 但是最终 `PlainMethodInvoker` 中是如何将参数转组装成Sql,并执行处理Sql返回值的地方还都没看到。本篇我们就带着如下三个问题开始我们的探索吧。\n\n![](https://img.springlearn.cn/blog/learn_1649427915000.png)\n\n本篇内容因为涉及跟jdbc的知识,如果对这部分内容有点遗忘,请先[JDBC知识复习](../mybatis/环境搭建/#_2-2-1-jdbc驱动)，另本篇内容知识点较多,目录较复杂,建议根据文字结合\n代码在实践的过程中一起学习。最好也可以自己debug一下。会收获更大。做好准备现在发车。\n\n![](https://img.springlearn.cn/blog/learn_1649428750000.png)\n\n## 二、流程分析\n\n## 2.1 Sql是如何组装参数的?\n\n![](https://img.springlearn.cn/blog/learn_1649428892000.png)\n\n在组装参数之前我们先来提一个小问题,sql的类型是如何判断的。sql类型有增删该查。\n除了查询会有结果集外，其他三种都是返回更新行数。他们对应的处理逻辑也是不一样的。\n我们要先弄清这个问题。\n\n### 2.1.1 sql类型如何判断?\n\n我们知道sql的类型是可以通过关键字来判断的,如select/update/delete/insert。那么在Mybatis中哪里能输入sql呢?\n一种有2种方式。\n\n1. 在Mapper.xml中直接编写sql，如下示例。\n\n```xml \n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"orm.example.dal.mapper.TUserMapper\">\n    <delete id=\"deleteByPrimaryKey\" parameterType=\"java.lang.String\">\n        delete from T_USER\n        where token_id = #{tokenId,jdbcType=CHAR}\n    </delete>\n    <insert id=\"insert\" parameterType=\"orm.example.dal.model.TUser\">\n        insert into T_USER (token_id, uid, name)\n        values (#{tokenId,jdbcType=CHAR}, #{uid,jdbcType=INTEGER}, #{name,jdbcType=CHAR})\n    </insert>\n    <update id=\"updateByPrimaryKey\" parameterType=\"orm.example.dal.model.TUser\">\n        update T_USER\n        set uid = #{uid,jdbcType=INTEGER},\n        name = #{name,jdbcType=CHAR}\n        where token_id = #{tokenId,jdbcType=CHAR}\n    </update>\n    <select id=\"selectAll\" resultMap=\"BaseResultMap\">\n        select token_id, uid, name\n        from T_USER\n    </select>\n\n</mapper>\n```\n2. 在Mapper类中使用注解编写sql\n\n```java \npublic interface TUserMapper {\n    @Select(\"select * from t_user where id = #{id}\")\n    TUser selectById(Long id);\n}    \n```\n这些sql信息都保存在 MappedStatement。在PlainMethodInvoker通过SqlCommand进行调用。\n\n- line(9) 最终通过type = ms.getSqlCommandType() 获取sql的类型\n\n```java {9}\nSqlCommand sqlCommand = new SqlCommand(config, mapperInterface, method);\n\n// 构造参数中找MappedStatement\npublic SqlCommand(Configuration configuration, Class<?> mapperInterface, Method method) {\n      final String methodName = method.getName();\n      final Class<?> declaringClass = method.getDeclaringClass();\n      MappedStatement ms = resolveMappedStatement(mapperInterface, methodName, declaringClass,\n          configuration);\n      type = ms.getSqlCommandType();\n}          \n// 寻找方法是接口全路径名.方法名\nprivate MappedStatement resolveMappedStatement(){\n    String statementId = mapperInterface.getName() + \".\" + methodName;\n    configuration.hasStatement(statementId)\n}\n```\n \n那么MappedStatement中的SqlCommandType是如何获取的呢?\n\n### 2.1.1.1 xml文件方式\n\n解析xml标签来实现\n\nXMLMapperBuilder#parseStatementNode\n\n- line(11) 通过标签来映射成指定的类型SqlCommandType\n\n```xml {11}\npublic class XMLStatementBuilder extends BaseBuilder {\n public void parseStatementNode() {\n    String id = context.getStringAttribute(\"id\");\n    String databaseId = context.getStringAttribute(\"databaseId\");\n\n    if (!databaseIdMatchesCurrent(id, databaseId, this.requiredDatabaseId)) {\n      return;\n    }\n\n    String nodeName = context.getNode().getNodeName();\n    SqlCommandType sqlCommandType = SqlCommandType.valueOf(nodeName.toUpperCase(Locale.ENGLISH));\n  }\n}  \npublic enum SqlCommandType {\n  UNKNOWN, INSERT, UPDATE, DELETE, SELECT, FLUSH\n}    \n```\n\n### 2.1.1.2 注解方式\n\n一定是解析注解方法 AnnotationWrapper。将不同的注解解析成SqlCommandType。如下伪代码。通过解析方法上的注解,判断注解类型,来确定sql的类型。\nMapperAnnotationBuilder#getAnnotationWrapper(method, true, statementAnnotationTypes)\n\n```java \nprivate class AnnotationWrapper {\n    private final Annotation annotation;\n    private final String databaseId;\n    private final SqlCommandType sqlCommandType;\n\n    AnnotationWrapper(Annotation annotation) {\n      super();\n      this.annotation = annotation;\n      if (annotation instanceof Select) {\n        databaseId = ((Select) annotation).databaseId();\n        sqlCommandType = SqlCommandType.SELECT;\n      } else if (annotation instanceof Update) {\n        databaseId = ((Update) annotation).databaseId();\n        sqlCommandType = SqlCommandType.UPDATE;\n      } else if (annotation instanceof Insert) {\n        databaseId = ((Insert) annotation).databaseId();\n        sqlCommandType = SqlCommandType.INSERT;\n      } else if (annotation instanceof Delete) {\n        databaseId = ((Delete) annotation).databaseId();\n        sqlCommandType = SqlCommandType.DELETE;\n      } else if (annotation instanceof SelectProvider) {\n        databaseId = ((SelectProvider) annotation).databaseId();\n        sqlCommandType = SqlCommandType.SELECT;\n      } else if (annotation instanceof UpdateProvider) {\n        databaseId = ((UpdateProvider) annotation).databaseId();\n        sqlCommandType = SqlCommandType.UPDATE;\n      } else if (annotation instanceof InsertProvider) {\n        databaseId = ((InsertProvider) annotation).databaseId();\n        sqlCommandType = SqlCommandType.INSERT;\n      } else if (annotation instanceof DeleteProvider) {\n        databaseId = ((DeleteProvider) annotation).databaseId();\n        sqlCommandType = SqlCommandType.DELETE;\n      } else {\n        sqlCommandType = SqlCommandType.UNKNOWN;\n        if (annotation instanceof Options) {\n          databaseId = ((Options) annotation).databaseId();\n        } else if (annotation instanceof SelectKey) {\n          databaseId = ((SelectKey) annotation).databaseId();\n        } else {\n          databaseId = \"\";\n        }\n      }\n    }\n\n    Annotation getAnnotation() {\n      return annotation;\n    }\n\n    SqlCommandType getSqlCommandType() {\n      return sqlCommandType;\n    }\n}    \n\n```\n\n到这里我们知道了sql类型是如何区分出来的，既然能区分出来，就知道如何去执行sql了。\n是不是很简单? 当然看的话很简单，但是如何让你自己来找，你能找到吗? 所以建议在阅读的时候\n要自己去源码中找找。\n\n### 2.1.2 sql参数如何组装?\n\n在mybatis中有两种处理sql参数的地方,第一种是`#{}` 占位符，第二种是`${}` 变量符。这两种都是处理参数的方式。那说到这里,不得不提的就是sql注入的黑客技术。\nsql注入就是就是利用了变量符。将我们原来的sql进行恶意的修改。举一个例子。下面根据用户id和用户密码查询用户信息。\n\n`select * from t_user as u where u.pass = ${user_pass} and u.id = ${user_id}`\n\n那么如何在不知道密码只有用户id的情况下查询到用户信息呢? 我们只需要将sql转换成下面这样即可。\n\n`select * from t_user as u where u.pass = '' or 1 = 1 and u.id = ${user_id}`\n\n那mybatis允许我们这样做吗? 允许，如果我们使用的是 `${}` 变量符,那么mybatis只是将参数和变量符进行替换。你输入的参数可能也会被当成sql去执行了。如下代码示例。\n\n```java \npublic interface T4UserMapper {\n    /**\n     * 获取用户信息\n     *\n     * @param uid     用户id\n     * @param tokenId token\n     * @return TUser\n     */\n    @Select(\"select * from t_user where token_id = ${token_id} and uid = ${uid}\")\n    TUser queryUserById(@Param(\"uid\") Long uid, @Param(\"token_id\") String tokenId);\n}\npublic class Test{\n    @Test\n    public void sql(){\n        // 读取配置信息\n        InputStream mapperInputStream = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"example05/mybatisConfig.xml\");\n        // 生成SqlSession工厂,SqlSession从名字上看就是,跟数据库交互的会话信息,负责将sql提交到数据库进行执行\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(mapperInputStream, \"development\");\n        // 获取Mybatis配置信息\n        Configuration configuration = sqlSessionFactory.getConfiguration();\n        SqlSession sqlSession = sqlSessionFactory.openSession(false);\n        // debug\n        T4UserMapper mapper = configuration.getMapper(T4UserMapper.class, sqlSession);\n        // 模拟sql注入\n        System.out.println(mapper.queryUserById(37L,\"0 or 1 = 1\"));\n    }\n}    \n\nSetting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@62ddbd7e]\n==>  Preparing: select * from t_user where token_id = 0 or 1 = 1 and uid = 37\n==> Parameters: \n<==    Columns: uid, name, token_id\n<==        Row: 37, 无天, 60\n<==      Total: 1\nTUser(tokenId=null, uid=37, name=无天)\n```\n\n\n要想避免这样的问题,我们只需要将`${}` 变量符,都替换成`#{}` 占位符就好了。那么Mybatis只会将你的参数当做是参数处理，不会当做是sql执行。如下代码示例。\n```java \npublic interface T4UserMapper {\n    /**\n     * 获取用户信息\n     *\n     * @param uid     用户id\n     * @param tokenId token\n     * @return TUser\n     */\n    @Select(\"select * from t_user where token_id = #{token_id} and uid = #{uid}\")\n    TUser queryUserById(@Param(\"uid\") Long uid, @Param(\"token_id\") String tokenId);\n}\npublic class Test{\n    @Test\n    public void sql(){\n        // 读取配置信息\n        InputStream mapperInputStream = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"example05/mybatisConfig.xml\");\n        // 生成SqlSession工厂,SqlSession从名字上看就是,跟数据库交互的会话信息,负责将sql提交到数据库进行执行\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(mapperInputStream, \"development\");\n        // 获取Mybatis配置信息\n        Configuration configuration = sqlSessionFactory.getConfiguration();\n        SqlSession sqlSession = sqlSessionFactory.openSession(false);\n        // debug\n        T4UserMapper mapper = configuration.getMapper(T4UserMapper.class, sqlSession);\n        // 模拟sql注入 => null\n        System.out.println(mapper.queryUserById(37L,\"0 or 1 = 1\"));\n    }\n}  \n\nCreated connection 798981583.\nSetting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@2f9f7dcf]\n==>  Preparing: select * from t_user where token_id = ? and uid = ?\n==> Parameters: 0 or 1 = 1(String), 37(Long)\n<==      Total: 0\nnull\n```\n\n以上演示代码可以在 `com.test.example05.SqlParseTest`中找到。那么无论是变量符还是占位符，其实都是sql组装,下面我们正式开始学习。\n\n==同样我们先提两个问题==\n\n![](https://img.springlearn.cn/blog/learn_1649510242000.png)\n\n### 2.1.2.1 方法参数如何来解析\n\n![](https://img.springlearn.cn/blog/learn_1649510559000.png)\n\n关键代码就在MapperMethod的execute的入参 Object [] args;\n关于参数的处理都在这里处理了。MethodSignature#convertArgsToSqlCommandParam。\n\n```java \npublic class MapperMethod {\n  public Object execute(SqlSession sqlSession, Object[] args) {\n    Object result;\n    switch (command.getType()) {\n      case INSERT: {\n        Object param = method.convertArgsToSqlCommandParam(args);\n        result = rowCountResult(sqlSession.insert(command.getName(), param));\n        break;\n      }\n      case UPDATE: {\n        Object param = method.convertArgsToSqlCommandParam(args);\n        result = rowCountResult(sqlSession.update(command.getName(), param));\n        break;\n      }\n      case DELETE: {\n        Object param = method.convertArgsToSqlCommandParam(args);\n        result = rowCountResult(sqlSession.delete(command.getName(), param));\n        break;\n      }\n    ....  \n    return result;\n  }\n}\n```\n\n```java \npublic Object convertArgsToSqlCommandParam(Object[] args) {\n    return paramNameResolver.getNamedParams(args);\n}\n```\n\n参数会被解析成什么样呢? 关键代码就在这里。\n\n```java \n public Object getNamedParams(Object[] args) {\n    final int paramCount = names.size();\n    // 没有参数直接返回\n    if (args == null || paramCount == 0) {\n      return null;\n    } else if (!hasParamAnnotation && paramCount == 1) {\n      // 没有注解只有一个参数\n      Object value = args[names.firstKey()];\n      return wrapToMapIfCollection(value, useActualParamName ? names.get(0) : null);\n    } else {\n      final Map<String, Object> param = new ParamMap<>();\n      int i = 0;\n      // names key = 参数下标 value = @Param里面的值\n      for (Map.Entry<Integer, String> entry : names.entrySet()) {\n        // key = @Param里面的值,value = args[index] 真实数据\n        param.put(entry.getValue(), args[entry.getKey()]);\n        // 生成param1,参数\n        final String genericParamName = GENERIC_NAME_PREFIX + (i + 1);\n        // ensure not to overwrite parameter named with @Param\n        if (!names.containsValue(genericParamName)) {\n          param.put(genericParamName, args[entry.getKey()]);\n        }\n        i++;\n      }\n      return param;\n    }\n  }\n```\n\n我们直接说结论,如果方法签名中使用了@Param注解结论,则占位符中的参数名就是注解的值。如果没有注解在就是arg+参数的位置.\n\n`com.test.example04.MethodSignatureTest`\n\n|参数类型|方法签名|参数值|结果|\n|:--|:--|:--|:--|\n|解析单参数不带@Param|TUser queryUserByName(String name)|methodSignature.convertArgsToSqlCommandParam(new Object[]{\"孙悟空\"})|孙悟空|\n|解析单参数带@Param|TUser queryUserById(@Param(\"userId\") Long id)|methodSignature.convertArgsToSqlCommandParam(new Object[]{1L})|{userId=1, param1=1}|\n|解析多参数不带@Param|TUser queryUserByTokenId(Long tokenId,String name)|methodSignature.convertArgsToSqlCommandParam(new Object[]{1L, \"孙悟空\"})|{arg0=1, arg1=孙悟空, param1=1, param2=孙悟空}|\n|解析多参数带@Param|TUser queryUserByTokenId(@Param(\"tokenId\") Long tokenId, @Param(\"name\") String name)|methodSignature.convertArgsToSqlCommandParam(new Object[]{1L, \"孙悟空\"})|{tokenId=1, name=孙悟空, param1=1, param2=孙悟空}|\n\n如果项目编译中设置了编译后保存参数名，那么可以获取代码中编写的参数名。\n\n![](https://img.springlearn.cn/blog/learn_1649512062000.png)\n\n好了到这里我们知道方法的参数最终都会被Mybatis重新解析,解析后的结果可以看以上的表格。主要就是为拼装参数提前准备数据。下面我们看sql信息最终是如何最终组装的吧。\n\n\n### 2.1.2.2 方法参数组装\n\n![](https://img.springlearn.cn/blog/learn_1649512620000.png)\n\n这里我们思考一下，变量符应该是动态sql,在调用jdbc时候应该是下面的例子。\n\n```java \n PreparedStatement preparedStatement = connection.prepareStatement(\"select * from t_user where token_id = 0 or 1 = 1 and uid = 37\");\n```\n\n那么我们就寻找哪里有这样的代码。\n\n![](https://img.springlearn.cn/blog/learn_1649514573000.png)\n\nPreparedStatementHandler#instantiateStatement.\n\n```java \n@Override\n  protected Statement instantiateStatement(Connection connection) throws SQLException {\n    String sql = boundSql.getSql();\n    if (mappedStatement.getKeyGenerator() instanceof Jdbc3KeyGenerator) {\n      String[] keyColumnNames = mappedStatement.getKeyColumns();\n      if (keyColumnNames == null) {\n        return connection.prepareStatement(sql, PreparedStatement.RETURN_GENERATED_KEYS);\n      } else {\n        return connection.prepareStatement(sql, keyColumnNames);\n      }\n    } else if (mappedStatement.getResultSetType() == ResultSetType.DEFAULT) {\n      return connection.prepareStatement(sql);\n    } else {\n      return connection.prepareStatement(sql, mappedStatement.getResultSetType().getValue(), ResultSet.CONCUR_READ_ONLY);\n    }\n  }\n```\n关键的代码就在这里静态sql,直接从MappedStatement#getBoundSql(Object parameterObject)#getSql()获取组装后的代码。\n\n![](https://img.springlearn.cn/blog/learn_1649514858000.png)\n\n```java \n  @Override\n  public <E> List<E> doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException {\n    Statement stmt = null;\n    try {\n      Configuration configuration = ms.getConfiguration();\n      StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);\n      stmt = prepareStatement(handler, ms.getStatementLog());\n      return handler.query(stmt, resultHandler);\n    } finally {\n      closeStatement(stmt);\n    }\n  }\n  \n  // 这里parameterObject就是前面对方法参数的解析返回值。通过mappedStatement.getBoundSql(parameterObject)组装静态sql\n  protected PreparedStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) {\n    this.configuration = mappedStatement.getConfiguration();\n    this.executor = executor;\n    this.mappedStatement = mappedStatement;\n    this.rowBounds = rowBounds;\n\n    this.typeHandlerRegistry = configuration.getTypeHandlerRegistry();\n    this.objectFactory = configuration.getObjectFactory();\n    if (boundSql == null) { // issue #435, get the key before calculating the statement\n      generateKeys(parameterObject);\n      boundSql = mappedStatement.getBoundSql(parameterObject);\n    }\n\n    this.boundSql = boundSql;\n    this.parameterHandler = configuration.newParameterHandler(mappedStatement, parameterObject, boundSql);\n    this.resultSetHandler = configuration.newResultSetHandler(executor, mappedStatement, rowBounds, parameterHandler, resultHandler, boundSql);\n  }\n```\n\n好了，到这里我们就知道静态sql是哪里组装的了。关键点就在BoundSql这个类是如何构建的。我们以注解方式举例。\n\n在构建MappedStatement的时候,MapperBuilderAssistant#parse会解析Mapper类所有的方法,获取方法上的注解,生成Sql的信息。\n判断sql类型,如果是${}变量符,Sql资源就是DynamicSqlSource动态Sql。如果是#{}占位符就是RawSqlSource会将占位符替换成`?`,同时生成ParameterMapping信息\n用于方法执行时候使用PreparedStatement去set参数信息。\n\n![](https://img.springlearn.cn/blog/learn_1649520231000.png)\n\n下面我们以示例中的代码来看下BoundSql中究竟有什么信息。\n\n![](https://img.springlearn.cn/blog/learn_1649520894000.png)\n\n那么对于第一种DynamicSqlSource动态sql,参数信息是如何组装的呢?\n\n```java \npublic class DynamicSqlSource implements SqlSource {\n\n  private final Configuration configuration;\n  private final SqlNode rootSqlNode;\n\n  public DynamicSqlSource(Configuration configuration, SqlNode rootSqlNode) {\n    this.configuration = configuration;\n    this.rootSqlNode = rootSqlNode;\n  }\n\n  @Override\n  public BoundSql getBoundSql(Object parameterObject) {\n    DynamicContext context = new DynamicContext(configuration, parameterObject);\n    // 处理sql中如果有<if><where><Trim>等自带标签的情况,同时处理将变量符提供换成真正的参数。\n    rootSqlNode.apply(context);\n    // 当执行完上面的流程变量符就被替换成真正的参数了。下面在看是否同时也包含了#{}占位符,如果包含就替换成?\n    // 在调换成?的同时新增一个ParameterMapping对象\n    SqlSourceBuilder sqlSourceParser = new SqlSourceBuilder(configuration);\n    Class<?> parameterType = parameterObject == null ? Object.class : parameterObject.getClass();\n    SqlSource sqlSource = sqlSourceParser.parse(context.getSql(), parameterType, context.getBindings());\n    BoundSql boundSql = sqlSource.getBoundSql(parameterObject);\n    context.getBindings().forEach(boundSql::setAdditionalParameter);\n    return boundSql;\n  }\n\n}\n```\n\n核心的方法就是变量符替换,下面直接将核心的代码展示出来。\n\n```java \n    @Test\n    public void dynamicSql() throws Exception {\n        // 读取配置信息(为什么路径前不用加/,因为是相对路径。maven编译后的资源文件和class文件都是在一个包下,所以不用加/就是当前包目录)\n        InputStream mapperInputStream = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"example05/mybatisConfig.xml\");\n        // 生成SqlSession工厂,SqlSession从名字上看就是,跟数据库交互的会话信息,负责将sql提交到数据库进行执行\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(mapperInputStream, \"development\");\n        // 获取Mybatis配置信息\n        Configuration configuration = sqlSessionFactory.getConfiguration();\n        // 生成动态Sql\n        TextSqlNode textSqlNode = new TextSqlNode(\"select * from t_user where token_id = ${token_id} and uid = ${uid}\");\n        DynamicSqlSource dynamicSqlSource = new DynamicSqlSource(configuration, textSqlNode);\n\n        // 装参数\n        MapperMethod.ParamMap<Object> paramMap = new MapperMethod.ParamMap<Object>();\n        paramMap.put(\"uid\",37L);\n        paramMap.put(\"token_id\",\"0 or 1 = 1\");\n        BoundSql boundSql = dynamicSqlSource.getBoundSql(paramMap);\n        System.out.println(boundSql.getSql());\n    }\n    \n    @Test\n    public void dynamicSql2(){\n        // 读取配置信息(为什么路径前不用加/,因为是相对路径。maven编译后的资源文件和class文件都是在一个包下,所以不用加/就是当前包目录)\n        InputStream mapperInputStream = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"example05/mybatisConfig.xml\");\n        // 生成SqlSession工厂,SqlSession从名字上看就是,跟数据库交互的会话信息,负责将sql提交到数据库进行执行\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(mapperInputStream, \"development\");\n        // 获取Mybatis配置信息\n        Configuration configuration = sqlSessionFactory.getConfiguration();\n\n        // 装参数\n        MapperMethod.ParamMap<Object> paramMap = new MapperMethod.ParamMap<Object>();\n        paramMap.put(\"uid\",37L);\n        paramMap.put(\"token_id\",\"0 or 1 = 1\");\n        DynamicContext context = new DynamicContext(configuration, paramMap);\n\n        // 生成动态Sql\n        TextSqlNode textSqlNode = new TextSqlNode(\"select * from t_user where token_id = ${token_id} and uid = ${uid}\");\n        textSqlNode.apply(context);\n        System.out.println(context.getSql());\n    }\n```\n\n好了，我们知道动态sql其实就是${}，变量符号替换。\n下面我们看静态sql是如何处理占位符的吧。\n\n![](https://img.springlearn.cn/blog/learn_1649523284000.png)\n\n前面我们说了静态sql,在初始化时候就会将占位符替换成? 同时生成一个ParameterMapping对象,然后在执行sql时候通过PreparedStatement进行set参数信息。\n那么我们先看占位符如何替换成?的吧。实现逻辑其实就在RawSqlSource的构造方法中。\n\n- line(1-5) 在Mybatis初始化时候,会生成RawSqlSource。在构造中去调换占位符\n- line(8-19) 占位符替换的实现方式,最终生成StaticSqlSource\n- line(22-28) 占位符返回?的同时,生成一个ParameterMapping对象\n\n```java {1-5,8-19,22-28}\npublic RawSqlSource(Configuration configuration, String sql, Class<?> parameterType) {\n    SqlSourceBuilder sqlSourceParser = new SqlSourceBuilder(configuration);\n    Class<?> clazz = parameterType == null ? Object.class : parameterType;\n    sqlSource = sqlSourceParser.parse(sql, clazz, new HashMap<>());\n}\n  \n// sql = select * from t_user where token_id = #{token_id} and uid = #{uid}\npublic SqlSource parse(String originalSql, Class<?> parameterType, Map<String, Object> additionalParameters) {\n    ParameterMappingTokenHandler handler = new ParameterMappingTokenHandler(configuration, parameterType, additionalParameters);\n    // 对\n    GenericTokenParser parser = new GenericTokenParser(\"#{\", \"}\", handler);\n    String sql;\n    if (configuration.isShrinkWhitespacesInSql()) {\n      sql = parser.parse(removeExtraWhitespaces(originalSql));\n    } else {\n      sql = parser.parse(originalSql);\n    }\n    return new StaticSqlSource(configuration, sql, handler.getParameterMappings());\n  }\n \n // 会将占位符号#{token_id}替换成 ？同时生成一个ParameterMapping对象。\n private static class ParameterMappingTokenHandler extends BaseBuilder implements TokenHandler {\n    // content = token_id\n    @Override\n    public String handleToken(String content) {\n      parameterMappings.add(buildParameterMapping(content));\n      return \"?\";\n    }\n }  \n```\n\n到这里占位符的解析已经很清楚了。BoundSql中的数据我们也知道了，我们直接看参数组装的逻辑吧。\n\n![](https://img.springlearn.cn/blog/learn_1649524815000.png)\n\n1. 从boundSql中获取占位符信息。\n2. 根据占位符获取参数信息\n3. 根据参数类型确定使用那个TypeHandler，如果都没有指定就用UnknownTypeHandler\n4. UnknownTypeHandler会根据参数的类型，从默认配置中找到要用的类型,如果是Long类型就是PreparedStatement#setLong，如果是String类型就是PreparedStatement#setString\n\n```java \npublic class DefaultParameterHandler implements ParameterHandler {\n  @Override\n  public void setParameters(PreparedStatement ps) {\n    ErrorContext.instance().activity(\"setting parameters\").object(mappedStatement.getParameterMap().getId());\n    List<ParameterMapping> parameterMappings = boundSql.getParameterMappings();\n    if (parameterMappings != null) {\n      for (int i = 0; i < parameterMappings.size(); i++) {\n        ParameterMapping parameterMapping = parameterMappings.get(i);\n        if (parameterMapping.getMode() != ParameterMode.OUT) {\n          Object value;\n          String propertyName = parameterMapping.getProperty();\n          if (boundSql.hasAdditionalParameter(propertyName)) { // issue #448 ask first for additional params\n            value = boundSql.getAdditionalParameter(propertyName);\n          } else if (parameterObject == null) {\n            value = null;\n          } else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) {\n            value = parameterObject;\n          } else {\n            MetaObject metaObject = configuration.newMetaObject(parameterObject);\n            value = metaObject.getValue(propertyName);\n          }\n          TypeHandler typeHandler = parameterMapping.getTypeHandler();\n          JdbcType jdbcType = parameterMapping.getJdbcType();\n          if (value == null && jdbcType == null) {\n            jdbcType = configuration.getJdbcTypeForNull();\n          }\n          try {\n            typeHandler.setParameter(ps, i + 1, value, jdbcType);\n          } catch (TypeException | SQLException e) {\n            throw new TypeException(\"Could not set parameters for mapping: \" + parameterMapping + \". Cause: \" + e, e);\n          }\n        }\n      }\n    }\n  }\n\n}\n\n```\n\n好了到这里我们就搞清楚Mybatis中的参数是如何组装的了。 以及Jdbc是如何执行sql的了。\n这部分内容比较复杂，仅仅通过看是看不明白的，建议根据文中的代码自己走一边。加深理解。\n\n下面我们看Mybatis是如何处理返回值的吧。\n\n\n## 2.2 Sql结果集是如何转换方法返回值的?\n\n我们重新回到PreparedStatementHandler中跟数据库打交道的地方,当PreparedStatement#execute发送sql给数据库后,最终处理结果集的类是\nResultHandler，下面我们就围绕这个类做分析。\n\n```java \n  @Override\n  public <E> List<E> query(Statement statement, ResultHandler resultHandler) throws SQLException {\n    PreparedStatement ps = (PreparedStatement) statement;\n    ps.execute();\n    return resultSetHandler.handleResultSets(ps);\n  }\n```\n\nResultSetHandler,我们看接口定义,处理结果集就在这里了。我们再来看实现。\n\n```java \npublic interface ResultSetHandler {\n\n  <E> List<E> handleResultSets(Statement stmt) throws SQLException;\n\n  <E> Cursor<E> handleCursorResultSets(Statement stmt) throws SQLException;\n\n  void handleOutputParameters(CallableStatement cs) throws SQLException;\n\n}\n```\n\n默认的实现DefaultResultSetHandler。Mybatis实现较为复杂，我们一开始可能看不懂。我们先用原生的jdbc来自己实现一边。\n然后脑子里有一个思路，然后在根据思路来看DefaultResultSetHandler的实现吧。\n\n### 2.2.1 JDBC提供的结果处理API\n\n思路是statement执行完后会返回结果集ResultSet。\n结果集包含了返回的数据及这些数据对应的字段信息。\n然后拿到这些字段信息分别从结果集中获取数据。下面的代码如果明白了，我们就去看Mybatis中的源码\n\n```java \n    @Test\n    public void resultMetaData() throws Exception {\n        String dbUrl = \"jdbc:mysql://127.0.0.1:3306/test\";\n        String user = \"root\";\n        String pass = \"123456\";\n        // 1. 获取数据库连接\n        Connection connection = DriverManager.getConnection(dbUrl, user, pass);\n        Statement statement = connection.createStatement();\n        // 2. 执行sql语句获取结果集\n        ResultSet resultSet = statement.executeQuery(\"select uid,name,token_id as tokenId from T_User\");\n        // 3. 从结果集中，获取数据库返回的数据列名\n        ResultSetMetaData metaData = resultSet.getMetaData();\n        int columnCount = metaData.getColumnCount();\n        // 所有的列名\n        List<String> columnNames = new ArrayList<>();\n        // 列名对应的java类型\n        Map<String, Class<?>> column2JavaTypeAsMap = new HashMap<>();\n        for (int i = 1; i <= columnCount; i++) {\n            System.out.println(\"字段:\" + metaData.getColumnName(i) + \"是否自增:\" + metaData.isAutoIncrement(i));\n            System.out.println(\"字段名:\" + metaData.getColumnName(i));\n            System.out.println(\"字段别名:\" + metaData.getColumnLabel(i));\n            System.out.println(\"MySql字段类型:\" + metaData.getColumnTypeName(i));\n            // Java 类的完全限定名称\n            System.out.println(\"Java字段类型:\" + metaData.getColumnClassName(i));\n            // 获取指定列的指定列大小。\n            System.out.println(\"字段长度:\" + metaData.getPrecision(i));\n            System.out.println(\"字段保留小数位:\" + metaData.getScale(i));\n            System.out.println(\"字段属于的表名:\" + metaData.getTableName(i));\n            System.out.println(\"是否可为空:\" + metaData.isNullable(i));\n            // 这里使用别名,如果没有别名的情况,别名跟字段名是一样的。\n            columnNames.add(metaData.getColumnLabel(i));\n            column2JavaTypeAsMap.put(metaData.getColumnLabel(i), Class.forName(metaData.getColumnClassName(i)));\n        }\n        int row = 1;\n        while (resultSet.next()) {\n            System.out.println(\"----------第\" + row + \"行数据开始----------\");\n            for (String columnName : columnNames) {\n                Object columnValue = getValue(columnName, resultSet, column2JavaTypeAsMap);\n                System.out.println(\"列:\" + columnName + \":value:\" + columnValue);\n            }\n            System.out.println(\"----------第\" + row + \"行数据结束----------\");\n            row++;\n        }\n        resultSet.close();\n        statement.close();\n        connection.close();\n    }\n\n    /**\n     * 根据不同的字段类型,调用不同的方法获取数据\n     *\n     * @param columnName           列名\n     * @param resultSet            集合集\n     * @param column2JavaTypeAsMap 字段对应的Java类型\n     * @return 结果值\n     * @throws Exception 未知异常\n     */\n    public Object getValue(String columnName, ResultSet resultSet, Map<String, Class<?>> column2JavaTypeAsMap) throws Exception {\n        Class<?> column2JavaType = column2JavaTypeAsMap.get(columnName);\n        Object value = null;\n        if (column2JavaType.equals(Integer.class)) {\n            value = resultSet.getInt(columnName);\n        } else if (column2JavaType.equals(String.class)) {\n            value = resultSet.getString(columnName);\n        }\n        return value;\n    }\n    \n字段:uid是否自增:true\n字段名:uid\n字段别名:uid\nMySql字段类型:INT\nJava字段类型:java.lang.Integer\n字段长度:11\n字段保留小数位:0\n字段属于的表名:t_user\n是否可为空:0\n字段:name是否自增:false\n字段名:name\n字段别名:name\nMySql字段类型:CHAR\nJava字段类型:java.lang.String\n字段长度:32\n字段保留小数位:0\n字段属于的表名:t_user\n是否可为空:1\n字段:token_id是否自增:false\n字段名:token_id\n字段别名:tokenId\nMySql字段类型:CHAR\nJava字段类型:java.lang.String\n字段长度:64\n字段保留小数位:0\n字段属于的表名:t_user\n是否可为空:0\n----------第1行数据开始----------\n列:uid:value:37\n列:name:value:无天\n列:tokenId:value:60\n----------第1行数据结束----------\n----------第2行数据开始----------\n列:uid:value:9846\n列:name:value:斗战胜佛\n列:tokenId:value:80\n----------第2行数据结束----------\n----------第3行数据开始----------\n列:uid:value:9847\n列:name:value:净坛使者\n列:tokenId:value:90\n----------第3行数据结束----------\n----------第4行数据开始----------\n列:uid:value:9848\n列:name:value:无量功德佛祖\n列:tokenId:value:100\n----------第4行数据结束----------\n```\n\nResultSetMetaData 方法是比较重要的，这里把他常用的api方法及解释以表格形式列举一下。\n当我们拿到返回的列名，就可以直接根据列名来返回数据了。\n\n|方法|含义|示例|\n|:--|:--|:--|\n|ResultSetMetaData#getColumnName|获取数据库字段名|name|\n|ResultSetMetaData#getColumnLabel|查询语句中字段别名,如果没有保持跟字段名一致|user_id as userId,这里就是userId|\n|ResultSetMetaData#getColumnTypeName|返回Sql字段类型|INT、CHAR|\n|ResultSetMetaData#getColumnClassName|返回Java字段类型的完整限定名|java.lang.String、java.lang.Integer|\n|ResultSetMetaData#getPrecision|获取定义的字段长度|int(11),返回11|\n|ResultSetMetaData#getScale|获取字段定义的保留小数位|-|\n|ResultSetMetaData#getTableName|字段对应的表|-|\n|ResultSetMetaData#isNullable|字段是否可以为空|-|\n|ResultSetMetaData#isAutoIncrement|是否数据库自增字段|-|\n|ResultSetMetaData#isAutoIncrement|是否数据库自增字段|-|\n\n### 2.2.2 Mybatis获取结果集\n\n思考下结果集可能是什么?\n\n1. 场景一: 可能返回的是List\n```java \n    @Select(\"select * from t_user\")\n    List<TUser> queryAllUsers();\n```\n2. 场景二: 可能返回的是单个对象\n\n```java \n    @Select(\"select * from t_user where uid = #{uid}\")\n    TUser queryUserByPlaceholderId(@Param(\"uid\") Long uid);\n```\n3. 场景三: 更新语句返回结果集是条数。\n\n```java \n    @Update(\"update t_user set name = #{name}\")\n    int updateName(@Param(\"uid\") Long uid, @Param(\"name\") String name);\n```\n4. 场景四: 更新语句返回boolean\n```java \n    @Update(\"update t_user set name = #{name} where uid = #{uid}\")\n    boolean updateNameById(@Param(\"uid\") Long uid, @Param(\"name\") String name);\n```\n\n分别来分析。\n\n### 场景一:\n\n```java \npublic class MapperMethod {\n    private final MethodSignature method;\n    public Object execute(SqlSession sqlSession, Object[] args) {\n        Object result;\n        switch (command.getType()) {\n          case SELECT:\n            if (method.returnsVoid() && method.hasResultHandler()) {\n              executeWithResultHandler(sqlSession, args);\n              result = null;\n            } else if (method.returnsMany()) {\n              result = executeForMany(sqlSession, args);\n            } else if (method.returnsMap()) {\n              result = executeForMap(sqlSession, args);\n            } else if (method.returnsCursor()) {\n              result = executeForCursor(sqlSession, args);\n            } else {\n              Object param = method.convertArgsToSqlCommandParam(args);\n              result = sqlSession.selectOne(command.getName(), param);\n              if (method.returnsOptional()\n                  && (result == null || !method.getReturnType().equals(result.getClass()))) {\n                result = Optional.ofNullable(result);\n              }\n            }\n            break;\n          case FLUSH:\n            result = sqlSession.flushStatements();\n            break;\n          default:\n            throw new BindingException(\"Unknown execution method for: \" + command.getName());\n        }\n        if (result == null && method.getReturnType().isPrimitive() && !method.returnsVoid()) {\n          throw new BindingException(\"Mapper method '\" + command.getName()\n              + \" attempted to return null from a method with a primitive return type (\" + method.getReturnType() + \").\");\n        }\n        return result;\n      }\n}\n```\n\n可以看到这里对于方法的返回值判断是根据MethodSignature,MethodSignature不仅提供了对参数的解析,同时也是对方法的分析。\n包括判断方法的返回值，我们看它的内部属性。\n\n```java \n public static class MethodSignature {\n    // 是否返回集合\n    private final boolean returnsMany;\n    // 是否返回是map结构\n    private final boolean returnsMap;\n    // 是否没有返回值\n    private final boolean returnsVoid;\n    // 是否返回的是游标\n    private final boolean returnsCursor;\n    // 是否返回的是Optional对象\n    private final boolean returnsOptional;\n    // 返回值类型\n    private final Class<?> returnType;\n    // 返回map结构使用的key字段\n    private final String mapKey;\n    // 如果入参是ResultHandler 记录器下标\n    private final Integer resultHandlerIndex;\n    // 如果参数是RowBounds，记录其下标\n    private final Integer rowBoundsIndex;\n    // 参数处理\n    private final ParamNameResolver paramNameResolver;\n    \n  }  \n```\n\n如果发现是返回List。则MethodSignature#returnsMany=true。直接调用SqlSession#selectList\n\n```java \nprivate <E> Object executeForMany(SqlSession sqlSession, Object[] args) {\n    List<E> result;\n    Object param = method.convertArgsToSqlCommandParam(args);\n    // 方法中是否包含逻辑分页参数RowBounds\n    if (method.hasRowBounds()) {\n      // 如果有就获取逻辑分页参数\n      RowBounds rowBounds = method.extractRowBounds(args);\n      // 执行sql\n      result = sqlSession.selectList(command.getName(), param, rowBounds);\n    } else {\n      result = sqlSession.selectList(command.getName(), param);\n    }\n    // issue #510 Collections & arrays support\n    if (!method.getReturnType().isAssignableFrom(result.getClass())) {\n      if (method.getReturnType().isArray()) {\n        return convertToArray(result);\n      } else {\n        return convertToDeclaredCollection(sqlSession.getConfiguration(), result);\n      }\n    }\n    return result;\n  }\n```\n\n最终在DefaultResultSetHandler#handleResultSets处理返回值。下面的代码看了先不要害怕,其实\n思路跟我们用jdbc来处理是一样的。第一要拿到返回的数据信息。第二要将返回的数据信息包装成方法的返回值。\n只不过Mybatis将上面的两个能力,都提供成了对应的接口。其中数据的返回集就是ResultSetWrapper,从返回集中获取数据是TypeHandler。\n而将数据库返回的行数据，转换成方法的返回值就要用到ResultMap。\n\n```java \n  @Override\n  public List<Object> handleResultSets(Statement stmt) throws SQLException {\n    ErrorContext.instance().activity(\"handling results\").object(mappedStatement.getId());\n\n    final List<Object> multipleResults = new ArrayList<>();\n\n    int resultSetCount = 0;\n    // 读取返回的数据信息(jdbcType,javaType,列名和别名)\n    ResultSetWrapper rsw = getFirstResultSet(stmt);\n    // Mapper签名中找到返回集应该信息\n    List<ResultMap> resultMaps = mappedStatement.getResultMaps();\n    int resultMapCount = resultMaps.size();\n    // 做个校验,如果sql执行后没有任何返回信息，但是Mapper签名中却指定了返回映射信息。则会报错告警 A query was run and no Result Maps were found for the Mapped Statement\n    validateResultMapsCount(rsw, resultMapCount);\n    while (rsw != null && resultMapCount > resultSetCount) {\n      ResultMap resultMap = resultMaps.get(resultSetCount);\n      // 处理返回集\n      handleResultSet(rsw, resultMap, multipleResults, null);\n      rsw = getNextResultSet(stmt);\n      cleanUpAfterHandlingResultSet();\n      resultSetCount++;\n    }\n\n    String[] resultSets = mappedStatement.getResultSets();\n    if (resultSets != null) {\n      while (rsw != null && resultSetCount < resultSets.length) {\n        ResultMapping parentMapping = nextResultMaps.get(resultSets[resultSetCount]);\n        if (parentMapping != null) {\n          String nestedResultMapId = parentMapping.getNestedResultMapId();\n          ResultMap resultMap = configuration.getResultMap(nestedResultMapId);\n          handleResultSet(rsw, resultMap, null, parentMapping);\n        }\n        rsw = getNextResultSet(stmt);\n        cleanUpAfterHandlingResultSet();\n        resultSetCount++;\n      }\n    }\n\n    return collapseSingleResultList(multipleResults);\n  }\n```\n\n下面我们看这几个关键类。ResultSetWrapper。这个的源码是不是有点想我们前面自己写的原生jdbc的方法了?\n拿到返回的列名和对应的java类型。\n\n```java \n public ResultSetWrapper(ResultSet rs, Configuration configuration) throws SQLException {\n    super();\n    this.typeHandlerRegistry = configuration.getTypeHandlerRegistry();\n    this.resultSet = rs;\n    final ResultSetMetaData metaData = rs.getMetaData();\n    final int columnCount = metaData.getColumnCount();\n    for (int i = 1; i <= columnCount; i++) {\n      columnNames.add(configuration.isUseColumnLabel() ? metaData.getColumnLabel(i) : metaData.getColumnName(i));\n      jdbcTypes.add(JdbcType.forCode(metaData.getColumnType(i)));\n      classNames.add(metaData.getColumnClassName(i));\n    }\n  }\n```\n\nTypeHandler 是从jdbc中获取数据的接口，这个功能就跟前面我们用原生API实现时候的getValue方法类似。\n主要是根据数据的类型，来确定是调用ResultSet#getString还是调用ResultSet#getInt等方法。\n\n```java \npublic interface TypeHandler<T> {\n\n  void setParameter(PreparedStatement ps, int i, T parameter, JdbcType jdbcType) throws SQLException;\n\n  T getResult(ResultSet rs, String columnName) throws SQLException;\n\n  T getResult(CallableStatement cs, int columnIndex) throws SQLException;\n}\n```\n\nResultMap 是返回数据对应的Java对象。会在生成MappedStatement时候构建完成。如果是在xml中定义了就是 `<resultMap/>` 标签,如果没有就是\n根据返回类自动生成一个resultMap。可以看到这个类属性其实跟他的标签是一样的。\n\n```java \npublic class ResultMap {\n  private Configuration configuration;\n\n  // 如果配置了<resultMap id=\"BaseResultMap\" ，就是类全路径名+BaseResultMap。如果没有就是类名加方法名+Inline\n  private String id;\n  private Class<?> type;\n  private List<ResultMapping> resultMappings;\n  private List<ResultMapping> idResultMappings;\n  private List<ResultMapping> constructorResultMappings;\n  private List<ResultMapping> propertyResultMappings;\n  private Set<String> mappedColumns;\n  private Set<String> mappedProperties;\n  private Discriminator discriminator;\n  private boolean hasNestedResultMaps;\n  private boolean hasNestedQueries;\n  private Boolean autoMapping;\n}\n```\n\nResultMap的标签功能比较强大,我们深入研究下。举一个例子。\n\n```java \n/**\n * 一个学校，一个校长，多个学生\n * name,headMaster(id,name),users()\n * 2022/4/10 22:07\n */\n@Data\npublic class School {\n\n    private Long id;\n\n    private String name;\n\n    private SchoolHeadMaster schoolHeadMaster;\n\n    private List<Student> students;\n\n}\n@Data\npublic class SchoolHeadMaster {\n\n    private Long id;\n\n    private String name;\n}\n\n@Data\npublic class Student {\n\n    private Long id;\n\n    private String name;\n}\n```\n\n配置文件如下\n\n```xml \n<mapper namespace=\"orm.example.dal.mapper.SchoolMapper\">\n    <resultMap id=\"BaseResultMap\" type=\"orm.example.dal.model.TUser\">\n        <id column=\"token_id\" jdbcType=\"CHAR\" property=\"tokenId\"/>\n        <result column=\"uid\" jdbcType=\"INTEGER\" property=\"uid\"/>\n        <result column=\"name\" jdbcType=\"CHAR\" property=\"name\"/>\n    </resultMap>\n\n    <resultMap id=\"schoolResultMap\" type=\"orm.example.dal.model.School\">\n        <result column=\"schoolId\" jdbcType=\"CHAR\" property=\"id\"/>\n        <result column=\"schoolName\" jdbcType=\"CHAR\" property=\"name\"/>\n        <!--        学校校长跟学校关系1对1-->\n        <association property=\"schoolHeadMaster\" javaType=\"orm.example.dal.model.SchoolHeadMaster\">\n            <id column=\"hmId\" property=\"id\"/>\n            <result column=\"schoolHeadName\" jdbcType=\"CHAR\" property=\"name\"/>\n        </association>\n        <!--        学生关系是1对n-->\n        <collection property=\"students\" javaType=\"list\" ofType=\"orm.example.dal.model.Student\">\n            <id column=\"studentId\" property=\"id\"/>\n            <result column=\"studentName\" jdbcType=\"CHAR\" property=\"name\"/>\n        </collection>\n    </resultMap>\n\n\n    <select id=\"selectSchool\" resultMap=\"schoolResultMap\">\n        select school.id as 'schoolId', school.name as 'schoolName', hm.id as 'hmId', hm.name as 'schoolHeadName', s.name as 'studentName', s.id as 'studentId'\n        from school\n                 left join head_master hm on hm.id = school.head_master_id\n                 left join student s on school.id = s.school_id\n    </select>\n</mapper>\n```\n\n执行数据验证 `com.test.example05.ResultMapTest#parseResultMap`\n\n- line(11-22) 获取MappedStatement观察复杂对象ResultMap是什么样。\n\n![](https://img.springlearn.cn/blog/learn_1649604916000.png)\n\n- line(25-26) 观察mybatis如何填充数据。\n\n```java {11-22,25-26}\n    @Test\n    public void parseResultMap() {\n        // 读取配置信息(为什么路径前不用加/,因为是相对路径。maven编译后的资源文件和class文件都是在一个包下,所以不用加/就是当前包目录)\n        InputStream mapperInputStream = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"example05/mybatisConfig-ResultMap.xml\");\n        // 生成SqlSession工厂,SqlSession从名字上看就是,跟数据库交互的会话信息,负责将sql提交到数据库进行执行\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(mapperInputStream, \"development\");\n        // 获取Mybatis配置信息\n        Configuration configuration = sqlSessionFactory.getConfiguration();\n\n        // 只要看这个复杂对象如何映射。\n        MappedStatement selectSchool = configuration.getMappedStatement(\"orm.example.dal.mapper.SchoolMapper.selectSchool\");\n        ResultMap resultMap = selectSchool.getResultMaps().get(0);\n        // 确定是一个复杂对象，规则是XMLMapperBuilder#processNestedResultMappings,只要发现查询语句对象的结果中有以下标签\"association\", \"collection\", \"case\"。就是复杂sql\n        System.out.println(\"是否复杂对象:\" + resultMap.hasNestedResultMaps());\n        List<ResultMapping> propertyResultMappings = resultMap.getPropertyResultMappings();\n        for (ResultMapping propertyResultMapping : propertyResultMappings) {\n            // 1. 属性:id,db列名:schoolId,JavaType:class java.lang.Long\n            // 2. 属性:name,db列名:schoolName,JavaType:class java.lang.String\n            // 3. 属性:schoolHeadMaster,db列名:null,JavaType:class orm.example.dal.model.SchoolHeadMaster,映射NestedResultMapId\n            // 4. 属性:students,db列名:null,JavaType:interface java.util.List,映射NestedResultMapId\n            printResultMapping(propertyResultMapping, configuration);\n        }\n\n        // [School(id=1, name=西天小学, schoolHeadMaster=SchoolHeadMaster(id=1, name=如来), students=[Student(id=1, name=孙悟空), Student(id=2, name=猪八戒), Student(id=3, name=唐三藏)])]\n        List<School> schools = configuration.getMapper(SchoolMapper.class, sqlSessionFactory.openSession(false)).selectSchool();\n        System.out.println(schools);\n    }\n\n    private static void printResultMapping(ResultMapping propertyResultMapping, Configuration configuration) {\n        String property = propertyResultMapping.getProperty();\n        System.out.println(\"属性:\" + property + \",db列名:\" + propertyResultMapping.getColumn() + \",JavaType:\" + propertyResultMapping.getJavaType() + \",映射NestedResultMapId:\" + propertyResultMapping.getNestedResultMapId());\n        String nestedResultMapId = propertyResultMapping.getNestedResultMapId();\n        // 如果不等于空,说明是复杂对象。从配置文件中获取复杂属性的映射集合\n        if (Objects.nonNull(nestedResultMapId)) {\n            ResultMap nestedResultMap = configuration.getResultMap(nestedResultMapId);\n            System.out.println(nestedResultMap.getType());\n            System.out.println(\"是否复杂对象:\" + nestedResultMap.hasNestedResultMaps());\n            List<ResultMapping> propertyResultMappings = nestedResultMap.getPropertyResultMappings();\n            for (ResultMapping resultMapping : propertyResultMappings) {\n                printResultMapping(resultMapping, configuration);\n            }\n        }\n    }\n```\n\n下面我们就看如何填充数据了。同样我们直接手撸代码。\n\n| schoolId | schoolName | hmId | schoolHeadName | studentName | studentId |\n| :--- | :--- | :--- | :--- | :--- | :--- |\n| 1 | 西天小学 | 1 | 如来 | 孙悟空 | 1 |\n| 1 | 西天小学 | 1 | 如来 | 猪八戒 | 2 |\n| 1 | 西天小学 | 1 | 如来 | 唐三藏 | 3 |\n| 2 | 湖畔大学 | 2 | 马云 | 马化腾 | 4 |\n| 2 | 湖畔大学 | 2 | 马云 | 谢霆锋 | 5 |\n| 2 | 湖畔大学 | 2 | 马云 | 张学友 | 6 |\n\nMybatis中处理返回值，分一下基础。简单对象和复杂对象这里我们直接用复杂对象距离。\n可以看到School中有2个基本属性和1个对象属性还有一个集合属性。\n\n看这个图。\n\n![](https://img.springlearn.cn/blog/learn_1649604916000.png)\n\n这部分示例代码在 `com.test.example05.ResultMapTest#handlerResultSet`\n\n- line(26) 首先我们要获取数据库返回列信息\n- line(30) 一行一行读取数据，每次执行ResultSet#next就是下一行\n- line(41) 因为我们School中有一个是集合属性,需要将多行数据转换成一行。此时我们执行完getRowValue\n  会生成一个数据。但是这个数据不能直接就用, 还需要将第二行的数据也赋值到第一行的返回值中,这是我们就将\n  第一行的数据返回值,带进去。\n- line(41) 我们如何知道这6行数据如何合并。规则: 简单对象进行拼接，School中简单对象是id,和name。\n- line(44) getRowValue中的每个方法都要注意看\n- line(93-99) 主要处理是否需要合并行，合并行的时候直接填充数据接口。而不是合并则缓存中查不到数据，就重新生成一个结果。\n- line(104) 判断ResultMap是否是一个复杂对象,这里School是一个复杂对象,因为不仅有一个HeadMaster还有一个List的学生集合。\n- line(109) 第一次进去这里会有4个对象,id，name,schoolHeadMaster,students\n- line(115-118) 对于School中的id和name都会在这几行被执行了。可以看到根据javaType找到了TypeHandler，然后TypeHandler负责取值。\n- line(141) 对于schoolHeadMaster这个属性,是复杂对象,School中的Java类型是SchoolHeadMaster和他对应的ResultMap中的类型是一样的，\n            则递归去获取数据,因为SchoolHeadMaster中也是都简单类型的id和name,所以最终也会在line(115-118)被执行了。\n- line(125-138) School中的students，java类型是List,ResultMap中类型是Student，所以要先从第一行的数据去获取这个属性\n  看List是否被实例化了，如果没有就实例化。然后执行add操作给list中数据追加值。\n\n\n主要这里我们使用了MetaObject这个工具,是一个包装方法。不详细介绍了，如果还不清楚请跳转\n\n[第03篇:Mybatis核心类详细介绍](http://localhost:8080/learn/mybatis/%E6%A0%B8%E5%BF%83%E7%B1%BB%E4%BB%8B%E7%BB%8D/#_1-5-objectwrapperfactory-%E5%AF%B9%E8%B1%A1%E5%8C%85%E8%A3%85%E5%B7%A5%E5%8E%82)\n```java {26}\n    @Test\n    public void handlerResultSet() throws Exception {\n\n        // 读取配置信息(为什么路径前不用加/,因为是相对路径。maven编译后的资源文件和class文件都是在一个包下,所以不用加/就是当前包目录)\n        InputStream mapperInputStream = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"example05/mybatisConfig-ResultMap.xml\");\n        // 生成SqlSession工厂,SqlSession从名字上看就是,跟数据库交互的会话信息,负责将sql提交到数据库进行执行\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(mapperInputStream, \"development\");\n        // 获取Mybatis配置信息\n        Configuration configuration = sqlSessionFactory.getConfiguration();\n\n        // 只要看这个复杂对象如何映射。\n        MappedStatement selectSchool = configuration.getMappedStatement(\"orm.example.dal.mapper.SchoolMapper.selectSchool\");\n        ResultMap resultMap = selectSchool.getResultMaps().get(0);\n\n        PreparedStatement preparedStatement = execute(\"select school.id   as 'schoolId',\\n\" +\n                \"       school.name as 'schoolName',\\n\" +\n                \"       hm.id       as 'hmId',\\n\" +\n                \"       hm.name     as 'schoolHeadName',\\n\" +\n                \"       s.name      as 'studentName',\\n\" +\n                \"       s.id        as 'studentId'\\n\" +\n                \"from school\\n\" +\n                \"         left join head_master hm on hm.id = school.head_master_id\\n\" +\n                \"         left join student s on school.id = s.school_id\");\n        // 2. 执行sql语句获取结果集\n        preparedStatement.execute();\n        ResultSetWrapper firstResultSet = getFirstResultSet(preparedStatement, configuration);\n        ResultSet resultSet = firstResultSet.getResultSet();\n        Map<String, Object> one2ManyAsMap = new HashMap<>();\n        // 3. 处理结果转换,一行一行读取数据\n        while (resultSet.next()) {\n            // 3.1 用于判断多行数据是否要合并 规则: 简单对象属性，如果一样则可以合并。\n            // 如: 下面数据返回值是 List<School> schools；School（Long id,String name,SchoolHeadMaster schoolHeadMaster,List<Student> students）\n            //INSERT INTO MY_TABLE(schoolId, schoolName, hmId, schoolHeadName, studentName, studentId) VALUES (1, '西天小学', 1, '如来', '孙悟空', 1);\n            //INSERT INTO MY_TABLE(schoolId, schoolName, hmId, schoolHeadName, studentName, studentId) VALUES (1, '西天小学', 1, '如来', '猪八戒', 2);\n            //INSERT INTO MY_TABLE(schoolId, schoolName, hmId, schoolHeadName, studentName, studentId) VALUES (1, '西天小学', 1, '如来', '唐三藏', 3);\n            //INSERT INTO MY_TABLE(schoolId, schoolName, hmId, schoolHeadName, studentName, studentId) VALUES (2, '湖畔大学', 2, '马云', '马化腾', 4);\n            //INSERT INTO MY_TABLE(schoolId, schoolName, hmId, schoolHeadName, studentName, studentId) VALUES (2, '湖畔大学', 2, '马云', '谢霆锋', 5);\n            //INSERT INTO MY_TABLE(schoolId, schoolName, hmId, schoolHeadName, studentName, studentId) VALUES (2, '湖畔大学', 2, '马云', '张学友', 6);\n            // 我们如何知道这6行数据如何合并。规则: 简单对象进行拼接，School中简单对象是id,和name。\n            // 所以这里构建的缓存key就是 id + name。相同就不新建返回值,而是对返回值二次赋值\n            String cacheKey = getCacheKey(resultMap, resultSet, configuration);\n            Object parentObject = one2ManyAsMap.get(cacheKey);\n            // 3.2 开始填充数据\n            parentObject = getRowValue(resultMap, firstResultSet, configuration, parentObject);\n            one2ManyAsMap.put(cacheKey, parentObject);\n        }\n        for (Object value : one2ManyAsMap.values()) {\n            System.out.println(value);\n        }\n    }\n\n    private PreparedStatement execute(String sql) throws Exception {\n        String dbUrl = \"jdbc:mysql://127.0.0.1:3306/test\";\n        String user = \"root\";\n        String pass = \"123456\";\n        // 1. 获取数据库连接\n        Connection connection = DriverManager.getConnection(dbUrl, user, pass);\n        return connection.prepareStatement(sql);\n    }\n\n    private ResultSetWrapper getFirstResultSet(Statement stmt, Configuration configuration) throws SQLException {\n        ResultSet rs = stmt.getResultSet();\n        while (rs == null) {\n            if (stmt.getMoreResults()) {\n                rs = stmt.getResultSet();\n            } else {\n                if (stmt.getUpdateCount() == -1) {\n                    break;\n                }\n            }\n        }\n        return rs != null ? new ResultSetWrapper(rs, configuration) : null;\n    }\n\n    private static String getCacheKey(ResultMap resultMap, ResultSet resultSet, Configuration configuration) throws Exception {\n        StringBuffer sb = new StringBuffer();\n        sb.append(resultMap.getId());\n        List<ResultMapping> propertyResultMappings = resultMap.getPropertyResultMappings();\n        for (ResultMapping propertyResultMapping : propertyResultMappings) {\n            if (propertyResultMapping.isSimple()) {\n                Class<?> javaType = propertyResultMapping.getJavaType();\n                TypeHandler<?> typeHandler = configuration.getTypeHandlerRegistry().getTypeHandler(javaType);\n                sb.append(propertyResultMapping.getProperty());\n                Object propertyValue = typeHandler.getResult(resultSet, propertyResultMapping.getColumn());\n                sb.append(propertyValue);\n            }\n        }\n        return sb.toString();\n    }\n\n    private static Object getRowValue(ResultMap resultMap, ResultSetWrapper firstResultSet, Configuration configuration, Object rowValue) throws Exception {\n        // 获取返回值的实体类\n        Object returnValue = null;\n        // 如果不等于空说明是处理合并,那么不构建新对象,只在合并的对象上重新赋值。\n        if (Objects.nonNull(rowValue)) {\n            returnValue = rowValue;\n        } else {\n            // 等于空说明是第一次进入,直接构建返回值示例。\n            returnValue = configuration.getObjectFactory().create(resultMap.getType());\n        }\n        // 下面对实例方法进行赋值，利用工具类MetaObject包装提供统一的赋属性方法\n        MetaObject metaObject = configuration.newMetaObject(returnValue);\n        // 判断是否是嵌套对象\n        boolean nestedFlag = resultMap.hasNestedResultMaps();\n        ResultSet resultSet = firstResultSet.getResultSet();\n        // 判断是否简单对象\n        if (nestedFlag) {\n            // 非简单对象,说明需要判断属性各自需要的映射对象\n            List<ResultMapping> propertyResultMappings = resultMap.getPropertyResultMappings();\n            for (ResultMapping propertyResultMapping : propertyResultMappings) {\n                Class<?> javaType = propertyResultMapping.getJavaType();\n                String nestedResultMapId = propertyResultMapping.getNestedResultMapId();\n                Object propertyValue;\n                // 是空说明,当前属性是基本属性\n                if (Objects.isNull(nestedResultMapId)) {\n                    // 获取当前属性的Java类型,从配置中获取该类型,读取ResultSet要使用的方法。eg:StringTypeHandler 使用ResultSet#getString\n                    TypeHandler<?> typeHandler = configuration.getTypeHandlerRegistry().getTypeHandler(javaType);\n                    propertyValue = typeHandler.getResult(resultSet, propertyResultMapping.getColumn());\n                } else {\n                    // 不等于空说明是嵌套对象,从配置中读取嵌套对象的映射信息\n                    ResultMap nestedResultMap = configuration.getResultMap(nestedResultMapId);\n                    // 嵌套对象的java类型。eg: School(students),这里的Java类型就是Student\n                    Class<?> nestedJavaType = nestedResultMap.getType();\n                    // 若果是list方式,外面的javaType=list，里面是真实java对象\n                    if (!javaType.equals(nestedJavaType) && Collection.class.isAssignableFrom(javaType)) {\n                        propertyValue = getRowValue(nestedResultMap, firstResultSet, configuration, null);\n                        MetaObject parentMetaObject = configuration.newMetaObject(returnValue);\n                        // 获取父对象School 获取students的List\n                        Object collect = parentMetaObject.getValue(propertyResultMapping.getProperty());\n                        if (Objects.isNull(collect)) {\n                            // 如果是null，则将list实例化\n                            collect = configuration.getObjectFactory().create(javaType);\n                            parentMetaObject.setValue(propertyResultMapping.getProperty(), collect);\n                        }\n                        // 给list中添加信息\n                        MetaObject metaCollectObject = configuration.newMetaObject(collect);\n                        metaCollectObject.add(propertyValue);\n                        propertyValue = collect;\n                    } else {\n                        // 简单对象\n                        propertyValue = getRowValue(nestedResultMap, firstResultSet, configuration, null);\n                    }\n                }\n                metaObject.setValue(propertyResultMapping.getProperty(), propertyValue);\n            }\n        } else {\n            List<ResultMapping> propertyResultMappings = resultMap.getPropertyResultMappings();\n            for (ResultMapping propertyResultMapping : propertyResultMappings) {\n                Class<?> javaType = propertyResultMapping.getJavaType();\n                TypeHandler<?> typeHandler = configuration.getTypeHandlerRegistry().getTypeHandler(javaType);\n                Object propertyValue = typeHandler.getResult(resultSet, propertyResultMapping.getColumn());\n                metaObject.setValue(propertyResultMapping.getProperty(), propertyValue);\n            }\n        }\n        return returnValue;\n    }\n```\n\n好了到这里对于场景1中，返回list中的数据就处理好了。\n\n````java \n  private <E> Object executeForMany(SqlSession sqlSession, Object[] args) {\n    List<E> result;\n    Object param = method.convertArgsToSqlCommandParam(args);\n    if (method.hasRowBounds()) {\n      RowBounds rowBounds = method.extractRowBounds(args);\n      result = sqlSession.selectList(command.getName(), param, rowBounds);\n    } else {\n      result = sqlSession.selectList(command.getName(), param);\n    }\n    // issue #510 Collections & arrays support\n    if (!method.getReturnType().isAssignableFrom(result.getClass())) {\n      if (method.getReturnType().isArray()) {\n        return convertToArray(result);\n      } else {\n        return convertToDeclaredCollection(sqlSession.getConfiguration(), result);\n      }\n    }\n    return result;\n  }\n````\n\n\n### 场景二:\n\n如果是单个对象,在基于场景一的返回值上加一个判断,如果结果只要1个就只取第一个。\n如果是多个，则报错。\n\n```java \n  public <T> T selectOne(String statement, Object parameter) {\n    // Popular vote was to return null on 0 results and throw exception on too many.\n    List<T> list = this.selectList(statement, parameter);\n    if (list.size() == 1) {\n      return list.get(0);\n    } else if (list.size() > 1) {\n      throw new TooManyResultsException(\"Expected one result (or null) to be returned by selectOne(), but found: \" + list.size());\n    } else {\n      return null;\n    }\n  }\n```\n\n### 场景三:\n\n更新语句直接 Statement#getUpdateCount 获取更新数量\n\n```java \n  public int update(Statement statement) throws SQLException {\n    PreparedStatement ps = (PreparedStatement) statement;\n    ps.execute();\n    int rows = ps.getUpdateCount();\n    Object parameterObject = boundSql.getParameterObject();\n    KeyGenerator keyGenerator = mappedStatement.getKeyGenerator();\n    keyGenerator.processAfter(executor, mappedStatement, ps, parameterObject);\n    return rows;\n  }\n```\n\n### 场景四:\n\n排除查询,其他语句返回都是int类型的更新成数量。那么假如方法是boolean类型，或者Long和Void呢\n\n```java \npublic class MapperMethod {\n  private Object rowCountResult(int rowCount) {\n    final Object result;\n    if (method.returnsVoid()) {\n      result = null;\n    } else if (Integer.class.equals(method.getReturnType()) || Integer.TYPE.equals(method.getReturnType())) {\n      result = rowCount;\n    } else if (Long.class.equals(method.getReturnType()) || Long.TYPE.equals(method.getReturnType())) {\n      result = (long) rowCount;\n    } else if (Boolean.class.equals(method.getReturnType()) || Boolean.TYPE.equals(method.getReturnType())) {\n      result = rowCount > 0;\n    } else {\n      throw new BindingException(\"Mapper method '\" + command.getName() + \"' has an unsupported return type: \" + method.getReturnType());\n    }\n    return result;\n  }\n}  \n```\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/mybatis/Mybatis执行流程分析.md b/docs/learn/mybatis/Mybatis执行流程分析.md
--- a/docs/learn/mybatis/Mybatis执行流程分析.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/mybatis/Mybatis执行流程分析.md	(date 1655373430333)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/mybatis/Mybatis缓存设计.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: true\nfooter: true\npassword: 111\nbacktotop: true\ntitle: 第07篇:Mybatis缓存装饰器\ncategory: Mybatis\n---\n\n\n![](https://img.springlearn.cn/blog/learn_1648571408000.png)\n\n\n:::tip\nMyBatis 对缓存的设计是非常巧妙的。花样很多,但却不是真的花样。因为`Mybatis`只是对 `Map`数据结构的封装, 但是却实现了很多挺好用的能力。\n如果单单从设计模式上的角度来,其实就是典型的装饰器模式, 装饰器模式其实并不难,所以我们不讲设计模式, 本篇文章我们来看看`Mybatils` 缓存设计巧妙的点。\n:::\n\n[官方文档](https://mybatis.net.cn/sqlmap-xml.html#cache)\n\n下面通过简单的代码review来分析下这11个缓存类设计的巧妙点。（因为是对博客重构,历史图片就没有补充,图上只有10个,请讲究下）\n\n---\n## 一、模式分析\n\n![](https://img.springlearn.cn/blog/learn_1648571612000.png)\n从目录就很清晰看出,核心就是`impl` 包下面只有一个,其他都是装饰器模式，在\n`decorators` 包下\n\n:::tip\n\n其实上面就是`Mybatis` 关于 `Cache` 的核心实现,其实看到这里还没有很多知识点. 那么我们从中能学到什么呢? 如果真要找一条学习的点,那么就是:\n\n设计要面向接口设计，而不是具体实现。 这样当我们要重写 `Cache` ，比如说我们不想底层用 `HashMap` 来实现了,其实我们只要实现一下 `Cache` 接口，然后替换掉`PerpetualCache`就可以了。对于使用者其实并不感知。\n\n:::\n## 1.1 Cache\n\n接口设计没有什么好讲的，提供获取和添加方法，跟Map接口一样。 本篇我们要一起Review的类都会实现该接口的。\n\n(这句话简直就是废话,大佬勿喷,就是简单提醒。意思就是其实代码不难)\n\n```java\npublic interface Cache {\n\n  String getId();\n  \n  void putObject(Object key, Object value);\n  \n  Object getObject(Object key);\n\n  Object removeObject(Object key);\n\n  void clear();\n\n  int getSize();\n  \n  ReadWriteLock getReadWriteLock();\n\n}\n```\n\n## 1.2 PerpetualCache\n\n这个类就是 `Mybatis` 缓存最底层的设计, 看一下就知道其实是对 `Map` 的封装。\n其实我们只要知道他是简单的 `HashMap` 的封装就可以了。因为代码实战是太简单了,没啥分析的。\n\n```java\npublic class PerpetualCache implements Cache {\n  // 唯一标识\n  private final String id;\n  // 就是一个HashMap结构\n  private Map<Object, Object> cache = new HashMap<Object, Object>();\n\n  public PerpetualCache(String id) {\n    this.id = id;\n  }\n\n  @Override\n  public String getId() {\n    return id;\n  }\n\n  @Override\n  public int getSize() {\n    return cache.size();\n  }\n\n  @Override\n  public void putObject(Object key, Object value) {\n    cache.put(key, value);\n  }\n\n  @Override\n  public Object getObject(Object key) {\n    return cache.get(key);\n  }\n\n  @Override\n  public Object removeObject(Object key) {\n    return cache.remove(key);\n  }\n\n  @Override\n  public void clear() {\n    cache.clear();\n  }\n  // 基本没啥用,外层谁要用,谁重写\n  @Override\n  public ReadWriteLock getReadWriteLock() {\n    return null;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (getId() == null) {\n      throw new CacheException(\"Cache instances require an ID.\");\n    }\n    if (this == o) {\n      return true;\n    }\n    if (!(o instanceof Cache)) {\n      return false;\n    }\n\n    Cache otherCache = (Cache) o;\n    return getId().equals(otherCache.getId());\n  }\n\n  @Override\n  public int hashCode() {\n    if (getId() == null) {\n      throw new CacheException(\"Cache instances require an ID.\");\n    }\n    return getId().hashCode();\n  }\n\n}\n\n```\n\n\n## 二、开始重头戏\n\n从这里我们主要一起看下,代码设计的巧妙之处,一个一个研究下,以下这10个类。看 `Mybatis` 是如何巧妙设计的。\n\n![](https://img.springlearn.cn/blog/learn_1648571791000.png)\n\n## 2.1 BlockingCache\nBlockingCache是一个简单和低效的`Cache`的装饰器,我们主要看几个重要方法。\n```java\npublic class BlockingCache implements Cache {\n\n  private long timeout;\n  //实现Cache接口的缓存对象\n  private final Cache delegate;\n  //对每个key生成一个锁对象\n  private final ConcurrentHashMap<Object, ReentrantLock> locks;\n\n  public BlockingCache(Cache delegate) {\n    this.delegate = delegate;\n    this.locks = new ConcurrentHashMap<Object, ReentrantLock>();\n  }\n\n  @Override\n  public String getId() {\n    return delegate.getId();\n  }\n\n  @Override\n  public int getSize() {\n    return delegate.getSize();\n  }\n\n  @Override\n  public void putObject(Object key, Object value) {\n    try {\n      delegate.putObject(key, value);\n    } finally {\n      //释放锁。 为什么不加锁? 所以get和put是组合使用的，当get加锁,如果没有就查询数据库然后put释放锁，然后其他线程就可以直接用缓存数据了。\n      releaseLock(key);\n    }\n  }\n\n  @Override\n  public Object getObject(Object key) {\n    //1. 当要获取一个key,首先对key进行加锁操作,如果没有锁就加一个锁,有锁就直接锁\n    acquireLock(key);\n    Object value = delegate.getObject(key);\n    if (value != null) {\n      //2. 如果缓存命中,就直接解锁\n      releaseLock(key);\n    }\n    //3. 当value=null, 就是说没有命中缓存,那么这个key就会被锁住,其他线程进来都要等待\n    return value;\n  }\n\n  @Override\n  public Object removeObject(Object key) {\n    // 移除key的时候,顺便清楚缓存key的锁对象\n    releaseLock(key);\n    return null;\n  }\n\n  @Override\n  public void clear() {\n    delegate.clear();\n  }\n\n  @Override\n  public ReadWriteLock getReadWriteLock() {\n    return null;\n  }\n  \n  private ReentrantLock getLockForKey(Object key) {\n    ReentrantLock lock = new ReentrantLock();\n    ReentrantLock previous = locks.putIfAbsent(key, lock);\n    //如果key对应的锁存在就返回,没有就创建一个新的\n    return previous == null ? lock : previous;\n  }\n  \n  private void acquireLock(Object key) {\n    Lock lock = getLockForKey(key);\n    //1. 如果设置超时时间,就可以等待timeout时间(如果超时了报错)\n    if (timeout > 0) {\n      try {\n        boolean acquired = lock.tryLock(timeout, TimeUnit.MILLISECONDS);\n        if (!acquired) {\n          throw new CacheException(\"Couldn't get a lock in \" + timeout + \" for the key \" +  key + \" at the cache \" + delegate.getId());  \n        }\n      } catch (InterruptedException e) {\n        throw new CacheException(\"Got interrupted while trying to acquire lock for key \" + key, e);\n      }\n    } else {\n      //2. 如果没有设置,直接就加锁(如果这个锁已经被人用了,那么就一直阻塞这里。等待上一个释放锁)\n      lock.lock();\n    }\n  }\n  \n  private void releaseLock(Object key) {\n    ReentrantLock lock = locks.get(key);\n    if (lock.isHeldByCurrentThread()) {\n      lock.unlock();\n    }\n  }\n\n  public long getTimeout() {\n    return timeout;\n  }\n\n  public void setTimeout(long timeout) {\n    this.timeout = timeout;\n  }  \n}\n```\n\n\n**建议**看代码注释\n\n| 方法          | 解释                                             |\n| ------------- | ------------------------------------------------ |\n| acquireLock   | 加锁操作                                         |\n| getObject     | 进来加锁,如果缓存存在就释放锁,不存在就不释放锁。 |\n| putObject     | 添加元素并释放锁                                 |\n| removeObject  | 移除key的时候,顺便清楚缓存key的锁对象            |\n| getLockForKey | 如果key对应的锁存在就返回,没有就创建一个新的     |\n\n**思考**\n1. 这个因为每次key请求都会加lock真的会很慢吗? 我们举两种场景。\n\n注意这个加lock并不是对get方法加lock,而是对每个要get的key来加lock。\n\n**场景一:** 试想一种场景,当有10个线程同时从数据库查询一个key为123的数据时候，当第一个线程来首先从cache中读取时候，这个时候其他九个线程是会阻塞的，因为这个key已经被加lock了。当第一个线程get这个key完成时候，其他线程才能继续走。这种场景来说是不好的，\n\n**场景二:** 但是当第一个线程来发现cache里面没有数据这个时候其他线程会阻塞，而第一个线程会从db中查询，然后在put到cache里面。这样其他9个线程就不需要在去查询db了,就减少了9次db查询。\n\n\n## 2.2 FifoCache\n**FIFO( First Input First Output),简单说就是指先进先出**\n\n如何实现先进先出呢? 其实非常简单,当put时候,先判断是否需要执行淘汰策略,如果要执行淘汰,就 移除先进来的。 直接通过 `Deque` API 来实现先进先出。\n\n```java\n  private final Cache delegate;\n  private final Deque<Object> keyList;\n  private int size;\n\n  public FifoCache(Cache delegate) {\n    this.delegate = delegate;\n    this.keyList = new LinkedList<Object>();\n    this.size = 1024;\n  }\n\n@Override\n  public void putObject(Object key, Object value) {\n      //1. put时候就判断是否需要淘汰\n    cycleKeyList(key);\n    delegate.putObject(key, value);\n  }\n  private void cycleKeyList(Object key) {\n    keyList.addLast(key);\n    //1. size默认如果大于1024就开始淘汰\n    if (keyList.size() > size) {\n      //2. 利用Deque队列移除第一个。\n      Object oldestKey = keyList.removeFirst();\n      delegate.removeObject(oldestKey);\n    }\n  }\n```\n\n## 2.3 LoggingCache\n从名字上看就是跟日志有关， `LoggingCache` 会在 `debug`级别下把缓存命中率给统计出来,然后通过日志系统打印出来。\n\n```java\npublic Object getObject(Object key) {\n    requests++;\n    final Object value = delegate.getObject(key);\n    if (value != null) {\n      hits++;\n    }\n    //1. 打印缓存命中率\n    if (log.isDebugEnabled()) {\n      log.debug(\"Cache Hit Ratio [\" + getId() + \"]: \" + getHitRatio());\n    }\n    return value;\n  }\n```\n\n除此之外没有什么其他功能。我们主要看下他是如何统计缓存命中率的。其实很简单。\n\n```java\npublic class LoggingCache implements Cache {\n\n  private final Log log;\n  private final Cache delegate;\n  //1. 总请求次数\n  protected int requests = 0;\n  //2. 命中次数\n  protected int hits = 0;\n \n  ...\n}  \n```\n\n在get请求时候无论是否命中,都自增总请求次数( `request` ), 当get命中时候自增命中次数( `hits` )\n\n```java\npublic Object getObject(Object key) {\n    //1. 无论是否命中,都自增总请求次数( `request` )\n    requests++;\n    final Object value = delegate.getObject(key);\n    if (value != null) {\n      //2. get命中时候自增命中次数( `hits` )\n      hits++;\n    }\n    if (log.isDebugEnabled()) {\n      log.debug(\"Cache Hit Ratio [\" + getId() + \"]: \" + getHitRatio());\n    }\n    return value;\n  }\n```\n\n然后我们看命中率怎么算 `getHitRatio()`\n\n`命中率 = 命中次数 / 总请求次数`\n```java\n private double getHitRatio() {\n    return (double) hits / (double) requests;\n  }\n```\n\n\n## 2.4 LruCache\nLRU是Least Recently Used的缩写，即最近最少使用。\n\n首先我们看如何实现 `LRU` 策略。\n它其实就是利用 `LinkedHashMap`来实现 `LRU` 策略, `JDK` 提供的 `LinkedHashMap`天然就支持 `LRU` 策略。\n`LinkedHashMap` 有一个特点如果开启LRU策略后,每次获取到数据后,都会把数据放到最后一个节点，这样第一个节点肯定是最近最少用的元素。\n\n```java\npublic V get(Object key) {\n        Node<K,V> e;\n        if ((e = getNode(hash(key), key)) == null)\n            return null;\n        //1. 判断是否开始LRU策略\n        if (accessOrder)\n            //2. 开启就往后面放\n            afterNodeAccess(e);\n        return e.value;\n    }\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2019122316004441.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70)\n构造中先声明LRU淘汰策略,当size()大于构造中声明的1024就可以在每次\nputObject时候将要淘汰的移除掉。这点非常的巧妙,不知道你学习到了没 ?\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20191223160143543.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70)\n\n## 2.5 ScheduledCache\n\n定时删除,设计巧妙,可以借鉴。\n\n```java\npublic class ScheduledCache implements Cache {\n\n  private final Cache delegate;\n  protected long clearInterval;\n  protected long lastClear;\n\n  public ScheduledCache(Cache delegate) {\n    this.delegate = delegate;\n    //1. 指定多久清理一次缓存\n    this.clearInterval = 60 * 60 * 1000; // 1 hour\n    //2. 设置初始值\n    this.lastClear = System.currentTimeMillis();\n  }\n\n  public void setClearInterval(long clearInterval) {\n    this.clearInterval = clearInterval;\n  }\n\n  @Override\n  public String getId() {\n    return delegate.getId();\n  }\n\n  @Override\n  public int getSize() {\n    clearWhenStale();\n    return delegate.getSize();\n  }\n\n  @Override\n  public void putObject(Object key, Object object) {\n    clearWhenStale();\n    delegate.putObject(key, object);\n  }\n\n  @Override\n  public Object getObject(Object key) {\n    return clearWhenStale() ? null : delegate.getObject(key);\n  }\n\n  @Override\n  public Object removeObject(Object key) {\n    clearWhenStale();\n    return delegate.removeObject(key);\n  }\n\n  @Override\n  public void clear() {\n    //1. 记录最近删除一次时间戳\n    lastClear = System.currentTimeMillis();\n    //2. 清理掉缓存信息\n    delegate.clear();\n  }\n\n  @Override\n  public ReadWriteLock getReadWriteLock() {\n    return null;\n  }\n\n  @Override\n  public int hashCode() {\n    return delegate.hashCode();\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    return delegate.equals(obj);\n  }\n\n  private boolean clearWhenStale() {\n    if (System.currentTimeMillis() - lastClear > clearInterval) {\n      clear();\n      return true;\n    }\n    return false;\n  }\n\n}\n\n```\n\n**核心代码**\n\n1. 构造中指定多久清理一次缓存(1小时)\n2. 设置初始值\n3. `clearWhenStale()` 核心方法\n4. 然后在每个方法中调用一次这段代码,判断是否需要清理。\n\n```java\nprivate boolean clearWhenStale() {\n    //1. 当前时间 - 最后清理时间,如果大于定时删除时间,说明要执行清理了。\n    if (System.currentTimeMillis() - lastClear > clearInterval) {\n      clear();\n      return true;\n    }\n    return false;\n  }\n```\n\n## 2.6 SerializedCache\n\n从名字上看就是支持序列化的缓存,那么我们就要问了，为啥要支持序列化?\n\n**为啥要支持序列化?**\n\n因为如果多个用户同时共享一个数据对象时，同时都引用这一个数据对象。如果有用户修改了这个数据对象，那么其他用户拿到的就是已经修改过的对象，这样就是出现了线程不安全。\n\n**如何解决这种问题**\n\n1. 加锁当一个线程在操作时候,其他线程不允许操作\n2. 新生成一个对象,这样多个线程获取到的数据就不是一个对象了。\n\n**只看一下核心代码**\n\n1. `putObject` 将对象序列化成`byte[]`\n2. `getObject` 将`byte[]`反序列化成对象\n\n```java\npublic void putObject(Object key, Object object) {\n    if (object == null || object instanceof Serializable) {\n      //1. 将对象序列化成byte[]\n      delegate.putObject(key, serialize((Serializable) object));\n    } else {\n      throw new CacheException(\"SharedCache failed to make a copy of a non-serializable object: \" + object);\n    }\n  }\nprivate byte[] serialize(Serializable value) {\n    try {\n      ByteArrayOutputStream bos = new ByteArrayOutputStream();\n      ObjectOutputStream oos = new ObjectOutputStream(bos);\n      oos.writeObject(value);\n      oos.flush();\n      oos.close();\n      return bos.toByteArray();\n    } catch (Exception e) {\n      throw new CacheException(\"Error serializing object.  Cause: \" + e, e);\n    }\n  }\n\n public Object getObject(Object key) {\n    Object object = delegate.getObject(key);\n    //1. 获取时候将byte[]反序列化成对象\n    return object == null ? null : deserialize((byte[]) object);\n  }\n  private Serializable deserialize(byte[] value) {\n    Serializable result;\n    try {\n      ByteArrayInputStream bis = new ByteArrayInputStream(value);\n      ObjectInputStream ois = new CustomObjectInputStream(bis);\n      result = (Serializable) ois.readObject();\n      ois.close();\n    } catch (Exception e) {\n      throw new CacheException(\"Error deserializing object.  Cause: \" + e, e);\n    }\n    return result;\n  }\n```\n\n这种就类似于深拷贝,因为简单的浅拷贝会出现线程安全问题,而这种办法,因为字节在被反序列化时，会在创建一个新的对象，这个新的对象的数据和原来对象的数据一模一样。所以说跟深拷贝一样。\n\n[Java开发之深浅拷贝](https://blog.springlearn.cn/posts/43446/)\n\n\n## 2.7 SoftCache\n从名字上看,Soft其实就是软引用。软引用就是如果内存够,GC就不会清理内存,只有当内存不够用了会出现OOM时候,才开始执行GC清理。\n\n如果要看明白这个源码首先要先了解一点垃圾回收,垃圾回收的前提是还有没有别的地方在引用这个对象了。如果没有别的地方在引用就可以回收了。\n本类中为了阻止被回收所以声明了一个变量`hardLinksToAvoidGarbageCollection`，\n也指定了一个将要被回收的垃圾队列`queueOfGarbageCollectedEntries` 。\n\n这个类的主要内容是当缓存value已经被垃圾回收了，就自动把key也清理。\n\n`Mybatis` 在实际中并没有使用这个类。\n\n```java\npublic class SoftCache implements Cache {\n  private final Deque<Object> hardLinksToAvoidGarbageCollection;\n  private final ReferenceQueue<Object> queueOfGarbageCollectedEntries;\n  private final Cache delegate;\n  private int numberOfHardLinks;\n\n  public SoftCache(Cache delegate) {\n    this.delegate = delegate;\n    this.numberOfHardLinks = 256;\n    this.hardLinksToAvoidGarbageCollection = new LinkedList<Object>();\n    this.queueOfGarbageCollectedEntries = new ReferenceQueue<Object>();\n  }\n}  \n```\n**先看下变量声明**\n\n`hard Links To Avoid Garbage Collection`\n硬连接,避免垃圾收集\n`queue Of Garbage Collected Entries`\n垃圾要收集的队列\n`number Of Hard Links`\n硬连接数量\n\n```java\n@Override\n  public void putObject(Object key, Object value) {\n    //1. 清除已经被垃圾回收的key\n    removeGarbageCollectedItems();\n    //2. 注意看SoftEntry(),声明一个SoftEnty对象,指定垃圾回收后要进入的队列\n    //3. 当SoftEntry中数据要被清理,会添加到类中声明的垃圾要收集的队列中\n    delegate.putObject(key, new SoftEntry(key, value, queueOfGarbageCollectedEntries));\n  }\n\n  @Override\n  public Object getObject(Object key) {\n    Object result = null;\n    @SuppressWarnings(\"unchecked\") // assumed delegate cache is totally managed by this cache\n    SoftReference<Object> softReference = (SoftReference<Object>) delegate.getObject(key);\n    if (softReference != null) {\n      result = softReference.get();\n      if (result == null) {\n        //1. 如果数据已经没有了,就清理这个key\n        delegate.removeObject(key);\n      } else {\n        // See #586 (and #335) modifications need more than a read lock \n        synchronized (hardLinksToAvoidGarbageCollection) {\n          //2. 如果key存在,读取时候加一个锁操作,并将缓存值添加到硬连接集合中,避免垃圾回收\n          hardLinksToAvoidGarbageCollection.addFirst(result);\n          //3. 构造中指定硬链接最大256,所以如果已经有256个key的时候回开始删除最先添加的key\n          if (hardLinksToAvoidGarbageCollection.size() > numberOfHardLinks) {\n            hardLinksToAvoidGarbageCollection.removeLast();\n          }\n        }\n      }\n    }\n    return result;\n  }\n\n  @Override\n  public void clear() {\n    //执行三清\n    synchronized (hardLinksToAvoidGarbageCollection) {\n      //1.清除硬链接队列\n      hardLinksToAvoidGarbageCollection.clear();\n    }\n    //2. 清除垃圾队列\n    removeGarbageCollectedItems();\n    //3. 清除缓存\n    delegate.clear();\n  }\n\n  private void removeGarbageCollectedItems() {\n    SoftEntry sv;\n    //清除value已经gc准备回收了,就就将key也清理掉\n    while ((sv = (SoftEntry) queueOfGarbageCollectedEntries.poll()) != null) {\n      delegate.removeObject(sv.key);\n    }\n  }\n```\n\n\n## 2.8 SynchronizedCache\n\n从名字看就是同步的缓存,从代码看即所有的方法都被`synchronized`修饰。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20191223175457202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70)\n\n## 2.9 TransactionalCache\n从名字上看就应该能隐隐感觉到跟事务有关,但是这个事务呢又不是数据库的那个事务。只是类似而已是, 即通过 `java` 代码来实现了一个暂存区域,如果事务成功就添加缓存，事务失败就回滚掉或者说就把暂存区的信息删除,不进入真正的缓存里面。 这个类是比较重要的一个类,因为所谓的二级缓存就是指这个类。既然说了\uD83C\uDFA7缓存就顺便提一下一级缓存。但是说一级缓存就设计到 `Mybatis`架构里面一个 `Executor` 执行器\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20191223193000589.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70)\n\n所有的查询都先从一级缓存中查询\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20191223193115847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70)\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20191223193308898.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70)\n\n看到这里不由己提一个面试题,面试官会问你知道`Mybatis` 的一级缓存吗?\n一般都会说`Mybatis` 的一级缓存就是 `SqlSession` 自带的缓存,这么说也对就是太笼统了，因为 `SqlSession`其实就是生成 `Executor` 而一级缓存就是里面query方法中的 `localCache`。这个时候我们就要看下了`localCache` 究竟是什么?\n看一下构造,突然豁然开朗。原来本篇文章讲的基本就是一级缓存的实现呀。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20191223193711876.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70)\n\n说到这里感觉有点跑题了，我们不是要看 `TransactionalCache` 的实现吗?\n\n`clearOnCommit` 为false就是这个事务已经完成了,可以从缓存中读取数据了。\n\n当`clearOnCommit`为 `true` ,这个事务正在进行中呢?  来的查询都给你返回 `null` , 等到 `commit` 提交时候在查询就可以从缓存中取数据了。\n\n```java\npublic class TransactionalCache implements Cache {\n\n  private static final Log log = LogFactory.getLog(TransactionalCache.class);\n    // 真正的缓存\n  private final Cache delegate;\n  // 是否清理已经提交的实物\n  private boolean clearOnCommit;\n  // 可以理解为暂存区\n  private final Map<Object, Object> entriesToAddOnCommit;\n  // 缓存中没有的key\n  private final Set<Object> entriesMissedInCache;\n\n  public TransactionalCache(Cache delegate) {\n    this.delegate = delegate;\n    this.clearOnCommit = false;\n    this.entriesToAddOnCommit = new HashMap<Object, Object>();\n    this.entriesMissedInCache = new HashSet<Object>();\n  }\n\n  @Override\n  public String getId() {\n    return delegate.getId();\n  }\n\n  @Override\n  public int getSize() {\n    return delegate.getSize();\n  }\n\n  @Override\n  public Object getObject(Object key) {\n    // 先从缓存中拿数据\n    Object object = delegate.getObject(key);\n    if (object == null) {\n      // 如果没有添加到set集合中\n      entriesMissedInCache.add(key);\n    }\n    // 返回数据库的数据。\n    if (clearOnCommit) {\n      return null;\n    } else {\n      return object;\n    }\n  }\n\n  @Override\n  public ReadWriteLock getReadWriteLock() {\n    return null;\n  }\n\n  @Override\n  public void putObject(Object key, Object object) {\n    entriesToAddOnCommit.put(key, object);\n  }\n\n  @Override\n  public Object removeObject(Object key) {\n    return null;\n  }\n\n  @Override\n  public void clear() {\n    clearOnCommit = true;\n    entriesToAddOnCommit.clear();\n  }\n\n  public void commit() {\n    if (clearOnCommit) {\n      delegate.clear();\n    }\n    flushPendingEntries();\n    reset();\n  }\n\n  public void rollback() {\n    unlockMissedEntries();\n    reset();\n  }\n\n  private void reset() {\n    //1. 是否清除提交\n    clearOnCommit = false;\n    //2. 暂存区清理,代表这个事务从头开始做了，之前的清理掉\n    entriesToAddOnCommit.clear();\n    //3. 同上\n    entriesMissedInCache.clear();\n  }\n    \n  /** \n   * 将暂存区的数据提交到缓存中\n   **/\n  private void flushPendingEntries() {\n    for (Map.Entry<Object, Object> entry : entriesToAddOnCommit.entrySet()) {\n      delegate.putObject(entry.getKey(), entry.getValue());\n    }\n    //如果缓存中不包含这个key,就将key对应的value设置为默认值null\n    for (Object entry : entriesMissedInCache) {\n      if (!entriesToAddOnCommit.containsKey(entry)) {\n        delegate.putObject(entry, null);\n      }\n    }\n  }\n\n  // 移除缺失的key,就是这个缓存中没有的key都移除掉\n  private void unlockMissedEntries() {\n    for (Object entry : entriesMissedInCache) {\n      try {\n        delegate.removeObject(entry);\n      } catch (Exception e) {\n        log.warn(\"Unexpected exception while notifiying a rollback to the cache adapter.\"\n            + \"Consider upgrading your cache adapter to the latest version.  Cause: \" + e);\n      }\n    }\n  }\n\n}\n\n```\n\n## 2.10 WeakCache\n从名字上看跟 `SoftCache` 有点关系,Soft引用是当内存不够用时候才清理, 而`Weak` 弱引用则相反, 只要有GC就会回收。 所以他们的类型特性并不是自己实现的，而是依赖于 `Reference<T>` 类的特性，所以代码就不看了基本和 `SoftCache` 实现一摸一样。\n\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/mybatis/Mybatis缓存设计.md b/docs/learn/mybatis/Mybatis缓存设计.md
--- a/docs/learn/mybatis/Mybatis缓存设计.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/mybatis/Mybatis缓存设计.md	(date 1655373430200)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/.vuepress/config.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>const {config} = require(\"vuepress-theme-hope\");\nconst path = require(\"path\");\nmodule.exports = config({\n    theme: path.resolve(__dirname, './theme'),\n    title: \"西魏陶渊明\",\n    description: \"桃花潭水深千尺\",\n    author: '西魏陶渊明',\n    blog: true,\n    dest: \"./dist\",\n    head: [\n        [\n            \"script\",\n            {src: \"https://img.springlearn.cn/learn_9957c49cd4d8fb645569586a438024db.react.production.min.js\"},\n        ],\n        [\n            \"script\",\n            {\n                src: \"https://img.springlearn.cn/learn_a775a739f8300fa1057643160208e962.react-dom.production.min.js\",\n            },\n        ],\n        [\"script\", {src: \"https://img.springlearn.cn/learn_f71f954c936a7a5bc107119f656be7a8.vue.min.js\"}],\n        [\n            \"script\",\n            {src: \"https://img.springlearn.cn/learn_3d5c67462f6ac197a271d1e178f295e9.min.js \"},\n        ],\n        ['link', {\n            rel: 'icon',\n            type: \"image/x-icon\",\n            href: 'https://img.springlearn.cn/learn_d98f09cdad8fa38168ec59c15a508490.ico'\n        }],\n        // ['link', {\n        //     rel: 'stylesheet',\n        //     href: 'https://img.springlearn.cn/learn_41d489b6f8e99292d8d2c4ca59e10664.tailwind.min.css'\n        // }],\n        // [\n        //     \"script\",\n        //     {\n        //         src: \"https://cdnjs.cloudflare.com/ajax/libs/gsap/3.2.6/gsap.min.js\",\n        //     },\n        // ],\n        [\n            'script',\n            {charset: 'utf-8', src: 'https://readmore.openwrite.cn/js/readmore.js'},\n        ], [\n            'script',\n            {charset: 'utf-8', src: ' https://img.springlearn.cn/learn_eed96b41c5dfddf972e76e7922f60fc8.jquery.min.js'}\n        ]\n    ],\n    locales: {\n        // \"/play/\": {\n        //     lang: \"en-ZH\",\n        //     title: \"娱乐区\",\n        //     // 默认是 false, 设置为 true 来启用\n        //     editLinks: true,\n        //     editLinkText: 'Edit this page on 娱乐区',\n        // },\n        \"/\": {\n            lang: \"zh-CN\",\n            title: \"西魏陶渊明\",\n            // 默认是 false, 设置为 true 来启用\n            editLinks: true,\n            editLinkText: '编辑学习区',\n            description: \"vuepress-theme-hope 的 demo\",\n        },\n    },\n    encrypt: {\n        title: 'Hello'\n    },\n    // 主题配置\n    // https://vuepress-theme-hope.github.io/zh/config/theme/feature/\n    themeConfig: {\n        //主题色和深色模式设置选项配置。 'auto-switch' | 'switch' | 'auto' | 'disable'\n        darkmode: 'switch',\n        anchorBanner: 'https://img.springlearn.cn/learn_c3d5074d94563b8297f81633f171d230.jpeg',\n        postMedia: 'https://img.springlearn.cn/blog/learn_1653269759000.png',\n        breadcrumb: false,\n        // 不允许变色\n        themeColor: false,\n        // 是否开启毒鸡汤,模式。如果开启home将不在使用tagline。而是随机获取毒鸡汤\n        dujitang: false,\n        // 正文上门的鸡汤，数据获取来自一言\n        homeJitang: false,\n        fullscreen: false,\n        encrypt: {\n            title: '扫描公众号,输入暗号获取密码,解锁全站文章',\n            errorHint: '暗号不对,有内鬼,终止交易'\n        },\n        adList: [\n            // {\n            //     link: 'https://www.aliyun.com/minisite/goods?userCode=oab21mxz&amp;share_source=copy_link',\n            //     img: 'https://img.springlearn.cn/learn_41803d11c899f1b682c70b16e7335cf5.jpg'\n            // },\n            {\n                link: '',\n                img: 'https://img.springlearn.cn/learn_9ea02e620c7d483bfa2d310c1440d3e9.png'\n            }\n        ],\n        friendLink: [\n            {\n                link: 'https://bugstack.cn/',\n                desc: 'bugstack 虫洞栈'\n            },\n            {\n                link: 'https://www.toutiao.com/c/user/token/MS4wLjABAAAAUpgfl4Z-CCzEU1PqmX4f2a7OZ3RxnTpYZ5euMr_6ZE4/?#mid=1563737358895105',\n                desc: '今日头条'\n            },\n            {\n                link: 'https://blog.csdn.net/message_lx',\n                desc: 'CSDN'\n            }\n        ],\n        // 默认为 \"Edit this page\"\n        logo: \"https://img.springlearn.cn/learn_d98f09cdad8fa38168ec59c15a508490.ico\",\n        searchPlaceholder: '斯是陋室惟吾德馨',\n        hostname: \"https://java.springlearn.cn/\",\n        author: \"西魏陶渊明\",\n        repo: \"https://github.com/lxchinesszz/JavaGuide\",\n        docsBranch: \"master\",\n        docsDir: \"docs\",\n        editLinks: true,\n        nav: [\n            {text: \"指南\", link: \"/learn/\", icon: \"creative\"}\n        ],\n        sidebarDepth: 4,\n        displayAllHeaders: true,\n        locales: {\n            // \"/play/\": {\n            //     lang: 'en-ZH', // 将会被设置为 <html> 的 lang 属性\n            //     label: '娱乐区',\n            //     selectText: 'Languages',\n            //     ariaLabel: 'Languages',\n            //     editLinkText: 'Edit this page on GitHub',\n            // },\n            \"/\": {\n                lang: 'zh-CN',\n                // 多语言下拉菜单的标题\n                selectText: '选择语言',\n                // 编辑链接文字\n                editLinks: true,\n                editLinkText: '在 GitHub 上编辑此页',\n                label: '学习区',\n                encrypt: {\n                    title: '扫描获取密码',\n                    errorHint: 'TMD，难道你想白嫖?'\n                },\n                nav: [\n                    {text: \"InfoQ\", link: \"/learn/误入歧途/\", icon: \"creative\"},\n                    // { text: \"大学生专题\", link: \"/learn/school/students\", icon: \"study\" },\n                    {\n                        text: 'Java',\n                        ariaLabel: 'Java',\n                        items: [\n                            {text: 'Java编程', link: '/learn/java/'},\n                            // {text: 'Java八股文', link: '/learn/java2/'},\n                            // {text: 'JVM', link: '/language/japanese/'},\n                            {text: '分布式服务', link: '/learn/distributed/'},\n                            {text: '测试专题', link: '/learn/test/'}\n                        ]\n                    },\n                    {\n                        text: 'Maven扩展',\n                        items: [\n                            {\n                                text: '基础入门', items: [\n                                    {text: 'Maven基础', link: '/learn/maven/'},\n                                    {text: '自定义插件', link: '/learn/maven/自定义maven插件/'}\n                                ]\n                            },\n                            {\n                                text: '源码分析', items: [\n                                    {text: 'spring-boot-maven-plugin', link: '/learn/maven/spring-boot-maven-plugin/'},\n                                    {text: 'maven-resources-plugin', link: '/learn/maven/maven-resources-plugin/'},\n                                    {text: 'maven-surefire-plugin', link: '/learn/maven/maven-surefire-plugin/'}\n                                ]\n                            },\n                            {\n                                text: '扩展开发', items: [\n                                    {text: '编译卡点插件', link: '/learn/maven/plugin/artifact-check-maven-plugin/'},\n                                ]\n                            }\n                        ]\n                    },\n                    {\n                        text: '框架篇',\n                        ariaLabel: 'Java',\n                        items: [\n                            {text: 'Spring', link: '/learn/spring/'},\n                            {text: 'Mybatis', link: '/learn/mybatis/'},\n                            // {text: 'Mybatis-Plus', link: '/language/jap1333anese/'},\n                            // {text: 'Dubbo', link: '/language/japa222nese/'},\n                            // {text: 'Job', link: '/language/japa444nese/'},\n                        ]\n                    },\n                    {\n                        text: '工具篇',\n                        ariaLabel: 'tools',\n                        items: [\n                            {text: '反射框架', link: '/learn/tools/reflections/'},\n                            {text: '字节码', link: '/learn/tools/bytecode/Javassist'},\n                            {text: 'SQL解析', link: '/learn/tools/druid/'},\n                            {text: 'Guava', link: '/learn/tools/guava/'},\n                            {text: '池化技术', link: '/learn/tools/pool2/'},\n                            {text: 'Arthas', link: '/learn/tools/arthas/'},\n                            {text: 'RxJava', link: '/learn/tools/rxjava/'},\n                            {text: 'Reactor', link: '/learn/tools/Reactor/'},\n                            {text: 'Disruptor', link: '/learn/tools/disruptor/'},\n                            {text: 'JMH基准测试', link: '/learn/tools/jmh/'},\n                            {text: '内存布局', link: '/learn/tools/jol/'},\n                        ]\n                    },\n                    {\n                        text: '实战项目',\n                        items: [\n                            {\n                                text: '效率工具', items: [\n                                    {text: 'Jmvn', link: '/learn/project/jmvn/'},\n                                    {text: 'Java脚手架', link: '/learn/project/start/'},\n                                    {text: 'Alfred Plugin', link: '/learn/project/alfred/'},\n                                    {text: 'Tomato 新特性', link: 'https://tomato.springlearn.cn/'},\n                                    {text: 'Mojito 通信组件', link: 'https://mojito.springlearn.cn/'},\n                                    {text: 'JVM调优&问题排查', link: '/learn/project/jvm/'},\n                                ]\n                            }\n                        ]\n                    },\n\n                    // {\n                    //     text: '字节码',\n                    //     items: [\n                    //         {\n                    //             text: '工具篇', items: [\n                    //                 { text: 'Javassist', link: '/language/chinese/' },\n                    //                 { text: 'Japanese', link: '/language/japanese/' }\n                    //             ]\n                    //         },\n                    //         {\n                    //             text: '扩展开发', items: [\n                    //                 { text: 'Chinese', link: '/language/chinese/' },\n                    //                 { text: 'Japanese', link: '/language/japanese/' }\n                    //             ]\n                    //         }\n                    //     ]\n                    // },\n                    {\n                        text: 'Database',\n                        items: [\n                            {\n                                text: '关系型数据库', items: [\n                                    {text: 'Mysql', link: '/learn/databases/sql/'},\n                                ]\n                            },\n                            {\n                                text: 'NoSql', items: [\n                                    {text: 'Redis', link: '/learn/databases/nosql/redis/'},\n                                    {text: 'Mongo', link: '/learn/databases/nosql/mongo/'}\n                                ]\n                            },\n                            {\n                                text: '图数据库', items: [\n                                    {text: 'Neo4J', link: '/learn/databases/map/'},\n                                ]\n                            }\n                        ]\n                    },\n                    {\n                        text: '设计&规范',\n                        items: [\n                            {\n                                text: '规范', items: [\n                                    {text: 'Java代码规范全部奉上', link: '/learn/design/Java代码规范全部奉上'},\n                                    {text: '中文文档写作规范', link: '/learn/design/中文文档写作规范'},\n                                    {text: '年终总结汇报大纲', link: '/learn/design/年终总结汇报大纲'}\n                                ]\n                            },\n                            {\n                                text: '设计', items: [\n                                    {text: '领域驱动模型的思考与认知', link: '/learn/design/领域驱动模型的思考与认知'},\n                                    {text: '六大原则 & 23种设计模式', link: '/learn/design/六脉神剑'},\n                                ]\n                            },\n                            {\n                                text: '总结 & 复盘', items: [\n                                    {text: '悟已往之不谏知来者其可追', link: '/learn/other/如何学会复盘'},\n                                ]\n                            }\n                        ]\n                    },\n                    {\n                        text: '博客搭建',\n                        items: [\n                            {\n                                text: '博客框架', items: [\n                                    {text: 'hexo', link: '/learn/blog/hexo/'},\n                                    {text: 'vuepress', link: '/learn/blog/vuepress/'},\n                                    {text: 'docsify', link: '/learn/blog/docsify/'}\n                                ]\n                            },\n                            {\n                                text: '服务器选择', items: [\n                                    {text: '自搭建服务', link: '/learn/chinese/'},\n                                    {text: 'Vercel', link: '/language/japanese1/'}\n                                ]\n                            },\n                            {\n                                text: '域名选择', items: [\n                                    {text: 'Chinese', link: '/language/chinese/'},\n                                    {text: 'Japanese', link: '/language/japanes2e/'}\n                                ]\n                            }\n                        ]\n                    }\n                ],\n                sidebar: {\n                    \"/learn/java/\": [\n                        {\n                            title: \" 第一章 基础内容\",\n                            icon: \"jichushuju\",\n                            collapsable: false,\n                            children: ['Java异常体系', '函数式编程', 'JMX', 'SPI', 'hooks函数', '委派双亲之类加载器', '四大引用', 'synchronized', '分布式锁', 'HashMap']\n                        },\n                        {\n                            title: \" 第二章 多线程编程\",\n                            icon: \"xiancheng\",\n                            collapsable: false,\n                            children: ['线程池', '拒绝策略', '线程安全之锁操作', '线程组', '线程工厂', '线程隔离', '线程安全']\n                        },\n                        {\n                            title: \" 第三章 并发编程\",\n                            icon: \"xiancheng\",\n                            collapsable: false,\n                            children: ['Semaphore', 'CountDownLatch', 'CyclicBarrier', 'ReadWriteLock', '原子操作', 'Condition', 'BlockingQueue', 'Contended']\n                        }\n                    ],\n                    \"/learn/databases/sql/\": [\n                        {\n                            title: \"优化相关\",\n                            icon: \"xiancheng\",\n                            collapsable: false,\n                            children: ['垃圾SQL', 'explain', 'SQL优化示例', 'SQL索引性能优化', 'SQL锁机制', '海量数据模拟', 'join']\n                        }\n                    ],\n                    \"/learn/databases/nosql/redis/\": [\n                        {\n                            title: \"优化相关\",\n                            icon: \"xiancheng\",\n                            collapsable: false,\n                            children: ['Redis缓存穿透雪崩问题']\n                        }\n                    ],\n                    \"/learn/java2/\": [\n                        {\n                            title: \"基础能力\",\n                            icon: \"creative\",\n                            collapsable: false,\n                            children: [{\n                                title: 'v1',\n                                path: '/learn/java2/Java异常体系'\n                            }, {\n                                title: 'v2',\n                                path: '/learn/java2/函数式编程'\n                            }]\n                        }\n                    ],\n                    \"/learn/spring/\": [\n                        {\n                            title: \"基础知识\",\n                            icon: \"creative\",\n                            collapsable: false,\n                            children: ['Spring循环依赖', 'AOP', 'EL', 'Endpoint监控端点扩展', 'Spring动态绑定配置', 'Web接口资源是如何保存起来的']\n                        }\n                    ],\n                    \"/learn/mybatis/\": [\n                        {\n                            title: \"源码学习\",\n                            icon: \"creative\",\n                            collapsable: false,\n                            children: ['环境搭建', '配置文件解析', '核心类介绍']\n                        }\n                        ,\n                        {\n                            title: \"专题文章\",\n                            icon: \"creative\",\n                            collapsable: false,\n                            children: ['Mapper代理对象创建', 'Mybatis执行流程分析', 'Mybatis一级二级缓存设计', 'Mybatis缓存设计']\n                        }\n                        ,\n                        {\n                            title: \"插件扩展\",\n                            icon: \"creative\",\n                            collapsable: false,\n                            children: ['插件分析', \"LimitPlugin\", \"PagePlugin\", \"AuthPlugin\"]\n                        }\n                        ,\n                        {\n                            title: \"工具类\",\n                            icon: \"creative\",\n                            collapsable: false,\n                            children: ['MetaObject', 'Mybatissql日志打印']\n                        }\n                    ],\n                    \"/learn/tools/guava/\": [\n                        {\n                            title: \"数据类型扩展\",\n                            icon: \"creative\",\n                            collapsable: false,\n                            children: [{\n                                title: 'guava-map集合',\n                                path: '/learn/tools/guava/guava-map'\n                            }]\n                        },\n                        {\n                            title: \"工具扩展\",\n                            icon: \"creative\",\n                            collapsable: false,\n                            children: [{\n                                title: 'guava-retry重试组件',\n                                path: '/learn/tools/guava/guava-retry'\n                            }, {\n                                title: 'spring-retry重试组件',\n                                path: '/learn/tools/guava/spring-retry'\n                            },\n                                {\n                                    title: 'guava-cache内存缓存',\n                                    path: '/learn/tools/guava/guava-cache'\n                                }]\n                        }\n                    ],\n                    \"/learn/test/\": [\n                        {\n                            title: \"技术框架\",\n                            icon: \"creative\",\n                            collapsable: false,\n                            children: [{\n                                title: '技术选型',\n                                path: '/learn/test/技术选型'\n                            }, {\n                                title: 'JUnit API',\n                                path: '/learn/test/JUnitAPI'\n                            }, {\n                                title: 'MockData API',\n                                path: '/learn/test/MockDataAPI'\n                            }, {\n                                title: 'Mockito API',\n                                path: '/learn/test/MockitoAPI'\n                            }, {\n                                title: 'SpringBoot Testing',\n                                path: '/learn/test/SpringBootTesting'\n                            }, {\n                                title: 'Feign Mock注意事项',\n                                path: '/learn/test/FeignMock'\n                            }]\n                        },\n                        {\n                            title: \"源码分析\",\n                            icon: \"kit\",\n                            collapsable: false,\n                            children: [{\n                                title: '谁在调用JUnit',\n                                path: '/learn/test/谁在调用JUnit'\n                            }, {\n                                title: '如何知道是否依赖Spring容器',\n                                path: '/learn/test/如何知道是否依赖Spring容器'\n                            }, {\n                                title: 'JUnit单测类属性注入',\n                                path: '/learn/test/JUnit单测类属性注入'\n                            }, {\n                                title: '事务回滚原理',\n                                path: '/learn/test/事务回滚原理'\n                            }]\n                        },\n                        {\n                            title: \"场景分析\",\n                            icon: \"changjingguanli\",\n                            collapsable: false,\n                            children: [{\n                                title: '测试成本',\n                                path: '/learn/test/测试成本'\n                            }, {\n                                title: '启动缓慢',\n                                path: '/learn/test/启动缓慢'\n                            }, {\n                                title: '数据隔离',\n                                path: '/learn/test/数据隔离'\n                            }, {\n                                title: '消息验证',\n                                path: '/learn/test/消息验证'\n                            }, {\n                                title: '异步验证',\n                                path: '/learn/test/异步验证'\n                            }]\n                        },\n                        {\n                            title: \"单测标准\",\n                            icon: \"icon-standard\",\n                            collapsable: false,\n                            children: [{\n                                title: '命名规则',\n                                path: '/learn/test/命名规则'\n                            }, {\n                                title: '使用断言',\n                                path: '/learn/test/使用断言'\n                            }, {\n                                title: '极限测试',\n                                path: '/learn/test/极限测试'\n                            }, {\n                                title: '测试范围',\n                                path: '/learn/test/测试范围'\n                            }, {\n                                title: '影响范围',\n                                path: '/learn/test/影响范围'\n                            }, {\n                                title: '单测维护',\n                                path: '/learn/test/单测维护'\n                            }]\n                        },\n                        {\n                            title: \"案例分享\",\n                            icon: \"fenxiang\",\n                            collapsable: false,\n                            children: [{\n                                title: '难度指数',\n                                path: '/learn/test/案例分享'\n                            }]\n                        },\n                    ],\n                    \"/learn/tools/arthas/\": [\n                        {\n                            title: \"快速入门\",\n                            icon: \"creative\",\n                            collapsable: false,\n                            children: ['learn']\n                        },\n                        {\n                            title: \"进阶使用\",\n                            icon: \"creative\",\n                            collapsable: false,\n                            children: ['base-cli', 'jvm-cli', 'class-cli', 'watch-cli']\n                        }\n                    ],\n                    \"/learn/tools/pool2/\": [\n                        {\n                            title: \"推荐文章\",\n                            icon: \"creative\",\n                            collapsable: false,\n                            children: ['字符串常量池']\n                        }\n                    ],\n                    \"/learn/tools/reflections/\": [\n                        {\n                            title: \"推荐文章\",\n                            icon: \"creative\",\n                            collapsable: false,\n                            children: ['Java泛型']\n                        }\n                    ],\n                    \"/learn/project/jmvn/\": [\n                        {\n                            title: \"快速入门\",\n                            icon: \"creative\",\n                            collapsable: false,\n                            children: ['introduction', 'introduction-install']\n                        },\n                        {\n                            title: \"使用配置\",\n                            icon: \"creative\",\n                            collapsable: false,\n                            children: ['jmvn-init', 'jmvn-install', 'jmvn-export']\n                        },\n                        {\n                            title: \"插件开发\",\n                            icon: \"creative\",\n                            collapsable: false,\n                            children: ['jmvn-plugin']\n                        }\n                    ],\n                    \"/learn/project/alfred/\": [\n                        {\n                            title: \"自定义工作流\",\n                            icon: \"creative\",\n                            collapsable: false,\n                            children: ['create-alfred', 'alfred-worflow-js']\n                        }\n                    ],\n                    \"/learn/distributed/\": [\n                        {\n                            title: \"基础知识\",\n                            icon: \"creative\",\n                            collapsable: false,\n                            children: [\n                                '分布式注册中心',\n                                '分布式负载均衡',\n                                '分布式服务调用',\n                                '分布式配置中心',\n                                '分布式服务降级',\n                                '分布式服务限流',\n                                '分布式服务熔断',\n                                '分布式服务网关',\n                                '分布式链路追踪',\n                                '分布式事务处理']\n                        }\n                    ]\n                },\n            },\n        },\n        markdown: {\n            lineNumbers: true\n        },\n        footer: {\n            display: true,\n            content: \" 只要坚持不懈，嘲笑你的人，迟早会被你笑死。\",\n        },\n        comment: {\n            type: \"waline\",\n            serverURL: \"https://waline-fawn-six.vercel.app\",\n        },\n        copyright: {\n            status: \"global\",\n        },\n        git: {\n            timezone: \"Asia/Shanghai\",\n        },\n        mdEnhance: {\n            enableAll: true,\n            // 支持居中\n            align: true,\n            codegroup: true,\n            presentation: {\n                plugins: [\n                    \"highlight\",\n                    \"math\",\n                    \"search\",\n                    \"notes\",\n                    \"zoom\",\n                    \"anything\",\n                    \"audio\",\n                    \"chalkboard\",\n                ],\n            },\n        },\n        pwa: {\n            favicon: \"https://img.springlearn.cn/learn_d98f09cdad8fa38168ec59c15a508490.ico\",\n            cachePic: true,\n            apple: {\n                icon: \"/assets/icon/apple-icon-152.png\",\n                statusBarColor: \"black\",\n            },\n            msTile: {\n                image: \"/assets/icon/ms-icon-144.png\",\n                color: \"#ffffff\",\n            },\n            manifest: {\n                icons: [\n                    {\n                        src: \"/assets/icon/chrome-mask-512.png\",\n                        sizes: \"512x512\",\n                        purpose: \"maskable\",\n                        type: \"image/png\",\n                    },\n                    {\n                        src: \"/assets/icon/chrome-mask-192.png\",\n                        sizes: \"192x192\",\n                        purpose: \"maskable\",\n                        type: \"image/png\",\n                    },\n                    {\n                        src: \"/assets/icon/chrome-512.png\",\n                        sizes: \"512x512\",\n                        type: \"image/png\",\n                    },\n                    {\n                        src: \"/assets/icon/chrome-192.png\",\n                        sizes: \"192x192\",\n                        type: \"image/png\",\n                    },\n                ],\n                shortcuts: [\n                    {\n                        name: \"Guide\",\n                        short_name: \"Guide\",\n                        url: \"/guide/\",\n                        icons: [\n                            {\n                                src: \"/assets/icon/guide-maskable.png\",\n                                sizes: \"192x192\",\n                                purpose: \"maskable\",\n                                type: \"image/png\",\n                            },\n                            {\n                                src: \"/assets/icon/guide-monochrome.png\",\n                                sizes: \"192x192\",\n                                purpose: \"monochrome\",\n                                type: \"image/png\",\n                            },\n                        ],\n                    },\n                ],\n            },\n        },\n        plugins: [\n            [\n                \"active-hash\",\n                {\n                    // your 你的选项\n                    offset: 0\n                },\n            ],\n        ],\n    },\n});\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/.vuepress/config.js b/docs/.vuepress/config.js
--- a/docs/.vuepress/config.js	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/.vuepress/config.js	(date 1655373354396)
@@ -44,6 +44,10 @@
         ], [
             'script',
             {charset: 'utf-8', src: ' https://img.springlearn.cn/learn_eed96b41c5dfddf972e76e7922f60fc8.jquery.min.js'}
+        ],
+        [
+            'script',
+            {charset: 'utf-8', src: 'https://img.springlearn.cn/learn_d67ad5eb7554e8aed39db1a4d7948ea6.pure.mini.js'}
         ]
     ],
     locales: {
@@ -366,7 +370,7 @@
                             title: "基础知识",
                             icon: "creative",
                             collapsable: false,
-                            children: ['Spring循环依赖', 'AOP', 'EL', 'Endpoint监控端点扩展', 'Spring动态绑定配置', 'Web接口资源是如何保存起来的']
+                            children: ['Spring循环依赖', 'AOP', 'EL', 'Endpoint监控端点扩展', 'Spring动态绑定配置', 'Web接口资源是如何保存起来的', 'Spring声明式事务的实现方案', 'FactoryBean接口实例化']
                         }
                     ],
                     "/learn/mybatis/": [
@@ -381,7 +385,7 @@
                             title: "专题文章",
                             icon: "creative",
                             collapsable: false,
-                            children: ['Mapper代理对象创建', 'Mybatis执行流程分析', 'Mybatis一级二级缓存设计', 'Mybatis缓存设计']
+                            children: ['Mapper代理对象创建', 'Mybatis执行流程分析', 'Mybatis一级二级缓存设计', 'Mybatis缓存设计', '事务的实现方案']
                         }
                         ,
                         {
@@ -553,6 +557,14 @@
                             children: ['Java泛型']
                         }
                     ],
+                    "/learn/project/jvm/": [
+                        {
+                            title: "推荐文章",
+                            icon: "creative",
+                            collapsable: false,
+                            children: ['JVM参数配置说明', 'JVM']
+                        }
+                    ],
                     "/learn/project/jmvn/": [
                         {
                             title: "快速入门",
@@ -607,7 +619,9 @@
         },
         footer: {
             display: true,
-            content: " 只要坚持不懈，嘲笑你的人，迟早会被你笑死。",
+            content: " 只要坚持不懈，嘲笑你的人，迟早会被你笑死。 <span id=\"busuanzi_container_site_pv\">本站总访问量<span id=\"busuanzi_value_site_pv\"></span>次</span> <span id=\"busuanzi_container_site_uv\">\n" +
+                "  本站访客数<span id=\"busuanzi_value_site_uv\"></span>人次\n" +
+                "</span>",
         },
         comment: {
             type: "waline",
Index: docs/learn/mybatis/LimitPlugin.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: true\nfooter: true\npassword: 111\nbacktotop: true\ntitle: 第09篇:Mybatis查询限制插件设计\ncategory: Mybatis\n---\n<PageBanner/>\n\n## 一、实现目标\n\n目标: 针对Mysql数据库实现动态修改sql的能力，增加上limit的查询限制。\n\n## 二、知识扩展\n\n首先下了解下有那些的分页技术。\n\n## 2.1 物理分页\n\n所谓物理分页是数据库直接提供了分页的预发, 如mysql的limit,oracle的rownum,好处是效率高;不好的地方就是不同数据库有不同的语法。\n\n## 2.2 逻辑分页\n\n逻辑分页利用游标分页，好处是所有数据库都统一，坏处就是效率低。\n\n## 二、实现分析\n\n首先我们先易后难,先说逻辑分页。\n\n## 2.1 逻辑分页\n\n首先我们看下Mybatis中当执行查询时候的代码,当返回是list时候。会走到executeForMany方法中。\n该方法主要判断是否需要进行逻辑分页。代码不难,看就完了。\n```java \npublic class MapperMethod {\n    public Object execute(SqlSession sqlSession, Object[] args) {\n        ....\n        case SELECT:\n        if (method.returnsVoid() && method.hasResultHandler()) {\n          executeWithResultHandler(sqlSession, args);\n          result = null;\n        } else if (method.returnsMany()) {\n          result = executeForMany(sqlSession, args);\n        }  \n        ...\n    }\n    \n    private <E> Object executeForMany(SqlSession sqlSession, Object[] args) {\n        List<E> result;\n        // 参数解析\n        Object param = method.convertArgsToSqlCommandParam(args);\n        // 判断是否逻辑分页了。\n        if (method.hasRowBounds()) {\n          RowBounds rowBounds = method.extractRowBounds(args);\n          result = sqlSession.selectList(command.getName(), param, rowBounds);\n        } else {\n          result = sqlSession.selectList(command.getName(), param);\n        }\n        ....   \n    }\n}\n```\nhasRowBounds 可以判断当前的方法是否要走逻辑分页。\nMethodSignature#hasRowBounds的逻辑也比较简单,就是判断方法入参中是否包含了RowBounds,如下代码。\n\n```java \npublic class MethodSignature{\n    public MethodSignature(Configuration configuration, Class<?> mapperInterface, Method method) {\n      this.rowBoundsIndex = getUniqueParamIndex(method, RowBounds.class);\n      this.resultHandlerIndex = getUniqueParamIndex(method, ResultHandler.class);\n      this.paramNameResolver = new ParamNameResolver(configuration, method);\n    }\n    private Integer getUniqueParamIndex(Method method, Class<?> paramType) {\n      Integer index = null;\n      final Class<?>[] argTypes = method.getParameterTypes();\n      for (int i = 0; i < argTypes.length; i++) {\n        if (paramType.isAssignableFrom(argTypes[i])) {\n          if (index == null) {\n            index = i;\n          } else {\n            throw new BindingException(method.getName() + \" cannot have multiple \" + paramType.getSimpleName() + \" parameters\");\n          }\n        }\n      }\n      return index;\n    }\n    public boolean hasRowBounds() {\n      return rowBoundsIndex != null;\n    }\n}    \n```\n\n如果方法入参中有RowBounds则会逻辑分页,如果没有指定则使用默认RowBounds即不限制数量。说不限制其实也限制了，\n就是Integer.MAX_VALUE \uD83D\uDE02\n\n```java  \npublic class DefaultSqlSession implements SqlSession {\n  @Override\n  public <E> List<E> selectList(String statement, Object parameter) {\n    return this.selectList(statement, parameter, RowBounds.DEFAULT);\n  }\n}  \n\npublic class RowBounds {\n\n  public static final int NO_ROW_OFFSET = 0;\n  public static final int NO_ROW_LIMIT = Integer.MAX_VALUE;\n  public static final RowBounds DEFAULT = new RowBounds();\n\n  private final int offset;\n  private final int limit;\n\n  public RowBounds() {\n    this.offset = NO_ROW_OFFSET;\n    this.limit = NO_ROW_LIMIT;\n  }\n} \n```\n\n那么逻辑分页的处理游标的地方在哪里呢? 因为前面我们已经对Mybatis的所有执行流程分析过了,所以这个时候我们应该有自己的思考了。\n应该是在jdbc执行后 处理返回数据的时候，那么应该就是在DefaultResultSetHandler中。直接看源码吧。\n\n- line(4-16) 用于处理偏移量, 如从第四页开始,则执行next跳过前三行。\n- line(17-19) 处理限制数量，如最大查询5行，如果返回值中大于5就返回false就不在添加数据。\n- line(25) 填过偏移量\n- line(26) 判断limit\n\n```java {4-16,17-19,25,26}\n\npublic class DefaultResultSetHandler implements ResultSetHandler {\n \n  private void skipRows(ResultSet rs, RowBounds rowBounds) throws SQLException {\n    if (rs.getType() != ResultSet.TYPE_FORWARD_ONLY) {\n      if (rowBounds.getOffset() != RowBounds.NO_ROW_OFFSET) {\n        rs.absolute(rowBounds.getOffset());\n      }\n    } else {\n      for (int i = 0; i < rowBounds.getOffset(); i++) {\n        if (!rs.next()) {\n          break;\n        }\n      }\n    }\n  }\n  private boolean shouldProcessMoreRows(ResultContext<?> context, RowBounds rowBounds) {\n    return !context.isStopped() && context.getResultCount() < rowBounds.getLimit();\n  }\n  \n  private void handleRowValuesForSimpleResultMap(ResultSetWrapper rsw, ResultMap resultMap, ResultHandler<?> resultHandler, RowBounds rowBounds, ResultMapping parentMapping)\n      throws SQLException {\n    DefaultResultContext<Object> resultContext = new DefaultResultContext<>();\n    ResultSet resultSet = rsw.getResultSet();\n    skipRows(resultSet, rowBounds);\n    while (shouldProcessMoreRows(resultContext, rowBounds) && !resultSet.isClosed() && resultSet.next()) {\n      ResultMap discriminatedResultMap = resolveDiscriminatedResultMap(resultSet, resultMap, null);\n      Object rowValue = getRowValue(rsw, discriminatedResultMap, null);\n      storeObject(resultHandler, resultContext, rowValue, parentMapping, resultSet);\n    }\n  }\n}  \n```\n\n好了，知道了这些我们就开始分析我们要如何使用插件了吧。对就是拦截ResultSetHandler,利用反射的方法,将默认的\nRowBounds添加limit限制。\n\n```java \n    /**\n     * 那我们就拦截处理结果.\n     * 启用反射修改默认的RowBounds limit属性\n     */\n    @Intercepts(@Signature(type = ResultSetHandler.class, method = \"handleResultSets\", args = {Statement.class}))\n    public static class DefaultRowBoundsHandler implements Interceptor {\n\n        @Override\n        public Object intercept(Invocation invocation) throws Throwable {\n            Object target = invocation.getTarget();\n            Field rowBounds = target.getClass().getDeclaredField(\"rowBounds\");\n            rowBounds.setAccessible(true);\n            RowBounds originRowBounds = (RowBounds) rowBounds.get(target);\n            // 如果是默认的则替换下\n            if (originRowBounds.equals(RowBounds.DEFAULT)) {\n                MetaObject metaObject = MetaObject.forObject(originRowBounds, new DefaultObjectFactory(), new DefaultObjectWrapperFactory(), new DefaultReflectorFactory());\n                metaObject.setValue(\"limit\", 2);\n            }\n            return invocation.proceed();\n        }\n    }\n    @Test\n    public void limitAddRowBounds(){\n        // 读取配置信息(为什么路径前不用加/,因为是相对路径。maven编译后的资源文件和class文件都是在一个包下,所以不用加/就是当前包目录)\n        InputStream mapperInputStream = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"example01/mybatisConfig.xml\");\n        // 生成SqlSession工厂,SqlSession从名字上看就是,跟数据库交互的会话信息,负责将sql提交到数据库进行执行\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(mapperInputStream, \"development\");\n        // 获取Mybatis配置信息\n        Configuration configuration = sqlSessionFactory.getConfiguration();\n        // 添加上我们的拦截器\n        configuration.addInterceptor(new DefaultRowBoundsHandler());\n        // 参数: autoCommit,从名字上看就是是否自动提交事务\n        SqlSession sqlSession = sqlSessionFactory.openSession(false);\n        // 获取Mapper\n        TUserMapper mapper = configuration.getMapperRegistry().getMapper(TUserMapper.class, sqlSession);\n        // 如果自己加了RowBounds，则不自动加limit\n        RowBounds rowBounds = new RowBounds(0, 3);\n        List<TUser> users1 = mapper.selectRowBounds(rowBounds);\n        System.out.println(users1.size());\n        // 如果不加显示,默认limit = 2\n        List<TUser> users = mapper.selectAll();\n        System.out.println(users.size());\n    }\n```\n\n好了，到这里逻辑分页已经搞定了。注意奥,这里只拦截了 `ResultSetHandler#handleResultSets` 其他两个没有拦截。\n注意奥这里只是一个思路，其实解决还有几种方法，我们要学会举一反三，比如我们也可以拦截 `Executor#query` 直接修改入参中的RowBounds参数。\n\n## 2.2 物理分页\n\n物理分页就是给sql添加上参数。那么sql信息都在哪里呢? 就在下图中。\n\n![](https://img.springlearn.cn/blog/learn_1649779778000.png)\n\n那么我们如何能修改参数呢? 当然就是从下面两个类中利用反射来给sql增加上limit了。那么我们在哪里拦截呢?\n\n首先确定拦截地方,首先上面两个类。RawSqlSource(占位符)、DynamicSqlSource(变量符)。都属于MappedStatement的内部属性，只要我们能\n拿到MappedStatement就可以了。\n\n![](https://img.springlearn.cn/blog/learn_1649782868000.png)\n\n其中Executor中就可以。那么我们开始操作吧。\n\n- line(14) RawSqlSource 占位符是最好处理的,内部属性就是StaticSqlSource,而StaticSqlSource中的sql是现成的直接造就行了。\n- line(26) DynamicSqlSource 变量符,稍微有点难搞,因为你不能直接拿到sql,所以我们只能去重写它。如下。\n- line(48-63) 从DynamicContext拿到原生sql然后,跟上面一样。\n\n```java {14,26,48-63}\n    /**\n     * 那我们就拦截处理结果.\n     * 启用反射修改默认的RowBounds limit属性\n     */\n    @Intercepts(@Signature(type = Executor.class, method = \"query\",\n            args = {MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class}))\n    public static class PhysicalHandler implements Interceptor {\n\n        @Override\n        public Object intercept(Invocation invocation) throws Throwable {\n            Object[] args = invocation.getArgs();\n            MappedStatement ms = (MappedStatement) args[0];\n            SqlSource sqlSource = ms.getSqlSource();\n            if (sqlSource instanceof RawSqlSource) {\n                MetaObject rawSqlSource = ms.getConfiguration().newMetaObject((RawSqlSource) sqlSource);\n                Object staticSqlSource = rawSqlSource.getValue(\"sqlSource\");\n                MetaObject metaObject = ms.getConfiguration().newMetaObject(staticSqlSource);\n                String sql = (String) metaObject.getValue(\"sql\");\n                if (sql.indexOf(\"limit\") <= 0) {\n                    String limitSql = sql + \" limit 2\";\n                    System.out.println(limitSql);\n                    metaObject.setValue(\"sql\", limitSql);\n                }\n            }\n            // 如果是动态sql,则需要解析\n            if (sqlSource instanceof DynamicSqlSource) {\n                MetaObject metaObject = ms.getConfiguration().newMetaObject(ms);\n                LimitDynamicSqlSource limitDynamicSqlSource = new LimitDynamicSqlSource((DynamicSqlSource) sqlSource);\n                metaObject.setValue(\"sqlSource\", limitDynamicSqlSource);\n            }\n            return invocation.proceed();\n        }\n    }\n\n    public static class LimitDynamicSqlSource implements SqlSource {\n\n        private final Configuration configuration;\n\n        private final SqlNode rootSqlNode;\n        \n        public LimitDynamicSqlSource(DynamicSqlSource dynamicSqlSource) {\n            MetaObject metaObject = MetaObject.forObject(dynamicSqlSource, new DefaultObjectFactory(), new DefaultObjectWrapperFactory(), new DefaultReflectorFactory());\n            this.configuration = (Configuration) metaObject.getValue(\"configuration\");\n            this.rootSqlNode = (SqlNode) metaObject.getValue(\"rootSqlNode\");\n        }\n\n        @Override\n        public BoundSql getBoundSql(Object parameterObject) {\n            DynamicContext context = new DynamicContext(configuration, parameterObject);\n            rootSqlNode.apply(context);\n            SqlSourceBuilder sqlSourceParser = new SqlSourceBuilder(configuration);\n            Class<?> parameterType = parameterObject == null ? Object.class : parameterObject.getClass();\n            String sql = context.getSql();\n            String limitSql = sql;\n            // 给原生sql增加limit\n            if (sql.indexOf(\"limit\") <= 0) {\n                limitSql = sql + \" limit 2\";\n                System.out.println(limitSql);\n            }\n            SqlSource sqlSource = sqlSourceParser.parse(limitSql, parameterType, context.getBindings());\n            BoundSql boundSql = sqlSource.getBoundSql(parameterObject);\n            context.getBindings().forEach(boundSql::setAdditionalParameter);\n            return boundSql;\n        }\n    }\n```\n\n\n好了我们直接来验证下吧。\n\n\n```java \n    /**\n     * 物理分页\n     * 就是拼装sql\n     */\n    @Test\n    public void physicalLimit() {\n        // 读取配置信息(为什么路径前不用加/,因为是相对路径。maven编译后的资源文件和class文件都是在一个包下,所以不用加/就是当前包目录)\n        InputStream mapperInputStream = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"example01/mybatisConfig.xml\");\n        // 生成SqlSession工厂,SqlSession从名字上看就是,跟数据库交互的会话信息,负责将sql提交到数据库进行执行\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(mapperInputStream, \"development\");\n        // 获取Mybatis配置信息\n        Configuration configuration = sqlSessionFactory.getConfiguration();\n        // 添加上我们的拦截器\n        configuration.addInterceptor(new PhysicalHandler());\n        // 参数: autoCommit,从名字上看就是是否自动提交事务\n        SqlSession sqlSession = sqlSessionFactory.openSession(false);\n        // 获取Mapper\n        TUserMapper mapper = configuration.getMapperRegistry().getMapper(TUserMapper.class, sqlSession);\n        List<TUser> users = mapper.selectAll();\n        System.out.println(users.size());\n    }\n```\n\n好了，到这里我们就实现了动态修改sql了。重要的是思路, 思路决定出路。要学会举一反三。本篇所有的代码示例都在\n\n`com.test.plugin.LimitPluginTest`\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/mybatis/LimitPlugin.md b/docs/learn/mybatis/LimitPlugin.md
--- a/docs/learn/mybatis/LimitPlugin.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/mybatis/LimitPlugin.md	(date 1655373430373)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/spring/EL.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: true\nfooter: true\nbacktotop: true\ntitle: Spring EL表达式使用指南\ncategory: Spring\n---\n\n![](https://img.springlearn.cn/blog/learn_1610710891000.png)\n\n<Djt/>\n\n> 好久没有发现这么好的文章了,今天逛头条发现了一篇好文章,在这里转载一下\n> 大家可以学习一下,文章原文地址见参考。希望支持原作者,在头条点一个关注。\n\n## 一、概述\n\nSpring表达式语言全称为“Spring Expression Language”，缩写为“SpEL”。是一个支持查询，并在运行时操纵一个对象图功能、是一门强大的表达式语言。SpEL是单独模块，只依赖于core模块，可以被独立使用、运行。\n\n\n**参考文章**\n\n[SpringEpel](https://docs.spring.io/spring-integration/docs/5.3.0.RELEASE/reference/html/spel.html#spel)\n\n[玩转SpEL](https://www.toutiao.com/i6911604368844292620/)\n## 二、作用\n\n### 2.1 基本表达式\n\n字面量表达式、关系，逻辑与算数运算表达式、字符串连接及截取表达式、三目运算、正则表达式、括号优先级表达式；\n\n### 2.2 类相关表达式\n\n类类型表达式、类实例化、instanceof表达式、变量定义及引用、赋值表达式、自定义函数、对象属性存取及安全导航表达式、对象方法调用、Bean引用；\n\n### 2.3 集合相关表达式\n\n内联List、内联数组、集合，字典访问、列表，字典，数组修改、集合投影、集合选择；不支持多维内联数组初始化；不支持内联字典定义；\n\n### 2.4 其他表达式\n\n模板表达式。\n\n## 三、主要类\n\n### 3.1 ExpressionParser\n\n表达式解析器接口，包含了(Expression) parseExpression(String), (Expression) parseExpression(String, ParserContext)两个接口方法\n\n### 3.2 ParserContext\n\n解析器上下文接口，主要是对解析器Token的抽象类，包含3个方法：getExpressionPrefix,getExpressionSuffix和isTemplate，就是表示表达式从什么符号开始什么符号结束，是否是作为模板（包含字面量和表达式）解析。\n\n\n### 3.3 Expression\n\n表达式的抽象，是经过解析后的字符串表达式的形式表示。通过expressionInstance.getValue方法，可以获取表示式的值。也可以通过调用getValue(EvaluationContext)，从评估（evaluation)上下文中获取表达式对于当前上下文的值\n\n\n### 3.4 EvaluationContext\n\n估值上下文接口，只有一个setter方法：`setVariable(String, Object)`，通过调用该方法，可以为evaluation提供上下文变量\n\n## 四、案例运用\n\n### 4.1 基础的Hello\n\n```\n@Test\npublic void baseTest() {\n// 字符串表达式\n    String exp = \"Hello , #{ #username }\";\n    // 表达式解析器\n    ExpressionParser parser = new SpelExpressionParser();\n    // 表达式上下文\n    EvaluationContext context = new StandardEvaluationContext();\n    context.setVariable(\"username\", \"纹银三百两\");\n    // 解析\n    Expression expression = parser.parseExpression(exp, new TemplateParserContext());\n    System.out.println(expression.getValue(context, String.class));\n  }\n\n```\n基础结果：\n```\nHello , 纹银三百两\n```\n\n\n### 4.2 关系运算符\n\n```\n//true\nboolean trueValue1 = parser.parseExpression(\"2 == 2\").getValue(Boolean.class);\n//false\nboolean falseValue1 = parser.parseExpression(\"2 < -5.0\").getValue(Boolean.class);\n//true\nboolean trueValue2 = parser.parseExpression(\"'black' < 'block'\").getValue(Boolean.class);\n//false，字符xyz是否为int类型\nboolean falseValue2 = parser.parseExpression(\"'xyz' instanceof T(int)\").getValue(Boolean.class);\n//true，正则是否匹配\nboolean trueValue3 =parser.parseExpression(\"'5.00' matches '^-?\\\\d+(\\\\.\\\\d{2})?$'\").getValue(Boolean.class);\n//false\nboolean falseValue3=parser.parseExpression(\"'5.0067' matches '^-?\\\\d+(\\\\.\\\\d{2})?$'\").getValue(Boolean.class);\n```\n### 4.3 逻辑运算符\n\n```\n// -- AND 与运算 --\n//false \nboolean falseValue4 = parser.parseExpression(\"true and false\").getValue(Boolean.class);\n // -- OR 或运算--\n//true\nboolean trueValue5 = parser.parseExpression(\"true or false\").getValue(Boolean.class);\n//false\nboolean falseValue5 = parser.parseExpression(\"!true\").getValue(Boolean.class);\n```\n\n### 4.4 算术运算符\n\n```\n// Addition\nint two = parser.parseExpression(\"1 + 1\").getValue(Integer.class); // 2\nString testString =\nparser.parseExpression(\"'test' + ' ' + 'string'\").getValue(String.class); // 'test string'\n// Subtraction\nint four = parser.parseExpression(\"1 - -3\").getValue(Integer.class); // 4\ndouble d = parser.parseExpression(\"1000.00 - 1e4\").getValue(Double.class); // -9000\n// Multiplication\nint six = parser.parseExpression(\"-2 * -3\").getValue(Integer.class); // 6\ndouble twentyFour = parser.parseExpression(\"2.0 * 3e0 * 4\").getValue(Double.class); // 24.0\n// Division\nint minusTwo = parser.parseExpression(\"6 / -3\").getValue(Integer.class); // -2\ndouble one = parser.parseExpression(\"8.0 / 4e0 / 2\").getValue(Double.class); // 1.0\n// Modulus\nint three = parser.parseExpression(\"7 % 4\").getValue(Integer.class); // 3\nint one = parser.parseExpression(\"8 / 5 % 2\").getValue(Integer.class); // 1\n// Operator precedence\nint minusTwentyOne = parser.parseExpression(\"1+2-3*8\").getValue(Integer.class); // -21\n```\n\n## 五、组合使用\n\n```\n@Test\n  public void expressionTest() {\n    String exp = \"1 between {1, 2} and 1>2\";\n    ExpressionParser parser = new SpelExpressionParser();\n    Expression expression = parser.parseExpression(exp);\n    //false\n    System.out.println(expression.getValue(boolean.class));\n  }\n```\n\n## 六、操作类\n\n### 6.1 类类型\n\n```\n@Test\npublic void classTypeTest() {\n    ExpressionParser parser = new SpelExpressionParser();\n    //java.lang包类访问\n    Class<String> result1 = parser.parseExpression(\"T(String)\").getValue(Class.class);\n    //class java.lang.String\n    System.out.println(result1);\n\n    //其他包类访问\n    String expression2 = \"T(spel.SpElTest)\";\n    Class<SpElTest> value = parser.parseExpression(expression2).getValue(Class.class);\n    //true\n    System.out.println(value == SpElTest.class);\n\n    //类静态字段访问\n    int result3 = parser.parseExpression(\"T(Integer).MAX_VALUE\").getValue(int.class);\n    //true\n    System.out.println(result3 == Integer.MAX_VALUE);\n\n    //类静态方法调用\n    int result4 = parser.parseExpression(\"T(Integer).parseInt('1')\").getValue(int.class);\n    //1\n    System.out.println(result4);\n  }\n```\n\n### 6.2 自定义函数\n\n```\n/**\n   * 两数之和\n   */\npublic static Integer add(Integer x, Integer y) {\n    return x + y;\n  }\n\n@Test\npublic void functionTest() throws NoSuchMethodException {\n    // 表达式\n    String exp = \"#{ #add(4,5)}\";\n    // 表达式上下文\n    StandardEvaluationContext context = new StandardEvaluationContext();\n    Method add = SpElTest.class.getDeclaredMethod(\"add\", Integer.class, Integer.class);\n    context.registerFunction(\"add\", add);\n    // 表达式解析器\n    ExpressionParser parser = new SpelExpressionParser();\n    // 解析\n    Expression expression = parser.parseExpression(exp, new TemplateParserContext());\n    // 9\n    System.out.println(expression.getValue(context, Integer.class));\n  }\n```\n\n### 6.3 类属性\n\n```\n @Test\n  public void assignTest() {\n    String exp = \"username: #{#user.username},age: #{#user.age}\";\n    StandardEvaluationContext context = new StandardEvaluationContext();\n    Person person = new Person()\n        .setUsername(\"纹银三百两\")\n        .setAge(23);\n    context.setVariable(\"user\", person);\n    ExpressionParser parser = new SpelExpressionParser();\n    Expression expression = parser.parseExpression(exp, new TemplateParserContext());\n    //username: 纹银三百两,age: 23\n    System.out.println(expression.getValue(context, String.class));\n  }\n```\n\n## 七、模板表达式\n\n指定模板 `%{ }`\n\n```\n@Test\npublic void templateTest() {\n    SpelExpressionParser parser = new SpelExpressionParser();\n    ParserContext context = new TemplateParserContext(\"%{\", \"}\");\n    Expression expression = parser.parseExpression(\"你好:%{#name},正在学习:%{#lesson}，加油、奋斗！！！\", context);\n    EvaluationContext evaluationContext = new StandardEvaluationContext();\n    evaluationContext.setVariable(\"name\", \"纹银三百两\");\n    evaluationContext.setVariable(\"lesson\", \"spring高手系列。\");\n    String value = expression.getValue(evaluationContext, String.class);\n    //你好:纹银三百两,正在学习:spring高手系列。加油、奋斗！！！\n    System.out.println(value);\n  }\n```\n\n## 八、规则引擎\n\n### 8.1 背景\n\n假设人员注册信息(姓名、年龄、性别），自定义其中规则，如下：\n\n李家好汉（李姓，男，且满18岁）\n豆蔻少女（13-15岁，女性）\n\n### 8.2 实现\n\n```\n@Test\n  public void ruleTest() {\n    Person person1 = new Person().setUsername(\"小龙女\").setAge(14).setSex(1);\n    checkRule(FastJsonUtil.parseMap(JSON.toJSONString(person1)));\n    Person person2 = new Person().setUsername(\"张三\").setAge(18).setSex(0);\n    checkRule(FastJsonUtil.parseMap(JSON.toJSONString(person2)));\n    Person person3 = new Person().setUsername(\"李四\").setAge(20).setSex(0);\n    checkRule(FastJsonUtil.parseMap(JSON.toJSONString(person3)));\n\n  }\n\n  /**\n   * 规则check\n   *\n   * @param exp 参数map\n   */\n  private static void checkRule(Map<String, Object> exp) {\n    ExpressionParser parser = new SpelExpressionParser();\n    //规则容器\n    Map<String, String> ruleMap = Maps.newHashMap();\n    String rule1 = \"( #username.contains({'李'}) and  #age > 18 and #sex == 0 )\";\n    ruleMap.put(\"李家好汉\", rule1);\n    String rule2 = \"( #age between {13,15} and #sex == 1 )\";\n    ruleMap.put(\"豆蔻少女\", rule2);\n    EvaluationContext spElContext = getSpElContext(exp);\n    ruleMap.keySet().forEach(key -> {\n      String ruleV = ruleMap.get(key);\n      Boolean isPass = parser.parseExpression(ruleV).getValue(spElContext, Boolean.class);\n      if (Objects.nonNull(isPass) && isPass) {\n        System.out.println(\"username:【\" + exp.get(\"username\") + \"】,命中规则:【\" + key+\"】\");\n      }\n\n    });\n  }\n\n  /**\n   * 解析表达式需要的上下文，透传请求参数\n   *\n   * @param param 参数\n   * @return 返回结果\n   */\n  private static EvaluationContext getSpElContext(Map<String, Object> param) {\n    StandardEvaluationContext evaluationContext = new StandardEvaluationContext();\n    for (Entry<String, Object> entry : param.entrySet()) {\n      if (entry.getValue() != null) {\n        evaluationContext.setVariable(entry.getKey(), entry.getValue());\n      }\n    }\n    return evaluationContext;\n  }\n```\n\n**结果：**\n\n```\nusername:【小龙女】,命中规则:【豆蔻少女】\nusername:【李四】,命中规则:【李家好汉】\n```\n\n## 九、总结\n\nSpring EL表达式，作为JAVA的内置语言，十分强大。主要可以用来做表达式解析，或者规则链路，且可以操作函数方法；从而达到一种动态的链路规则解析效果。\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/spring/EL.md b/docs/learn/spring/EL.md
--- a/docs/learn/spring/EL.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/spring/EL.md	(date 1655373430430)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/spring/AOP.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: true\nfooter: true\nbacktotop: true\ntitle: AOP 使用指南\ncategory: Spring\n---\n\n\n![](https://img.springlearn.cn/blog/learn_1593954110000.png)\n\n<PageBanner/>\n\n\n[![](https://img.shields.io/badge/%E6%BA%90%E7%A0%81-AOP-green)](https://github.com/lxchinesszz/spring-learning)\n---\n\n## 一、常用注解\n\n注解 | 说明\n---|---\n@Before | 前置通知, 在方法执行之前执行\n@After | 后置通知, 在方法执行之后执行\n@AfterRunning | 返回通知 在方法返回结果之后执行\n@AfterThrowing | 异常通知在方法抛出异常之后\n@Around | 环绕通知, 围绕着方法执行\n\n---\n\n\n## 二、切面表达式\n\n注解 | 说明\n---|---\nwithin | 拦截指定类及指定包下所有的类\n@within | 拦截被指定注解修饰的类\nthis | 拦截指定的类型\nargs | 拦截指定参数类型的方法\n@annotation | 拦截带指定注解的方法\n@args | 拦截方法入参被中@args指定的注解(入参只能有一个)\nexecution | 表达式详情见下文\n---\n\n## 三、API使用案例\n\n## 3.1 within\n\n### a. API说明\n\n1. 精确匹配类名\n2. 模糊匹配包中所有的类\n3. 模糊匹配包中所有的带Impl后缀的\n\n### b. 目录\n\n```\n└── WithinMatchProcessor\n    ├── AopWithinMatchProcessor.java\n    ├── CokeImpl.java\n    ├── Water.java\n    └── readme.md\n```\n\n### c. 拦截代码\n\n```java\n@Aspect\n@Component\npublic class AopWithinMatchProcessor {\n\n    /**\n     * 精确匹配类名\n     */\n    @Pointcut(\"within(spring.learning.aop.WithinMatchProcessor.Water)\")\n    private void matchClassName() {\n    }\n\n    /**\n     * 模糊匹配包中所有的类\n     */\n    @Pointcut(\"within(spring.learning.aop.WithinMatchProcessor.*)\")\n    private void matchAllClassFromPackage() {\n    }\n\n    /**\n     * 模糊匹配包中所有的带Impl后缀的\n     */\n    @Pointcut(\"within(spring.learning.aop.WithinMatchProcessor.*Impl)\")\n    private void matchClassFromPackage() {\n    }\n\n\n    @Before(\"matchClassName()\")\n    public void beforeMatchClassName() {\n        System.out.println(\"--------精确匹配类名-------\");\n    }\n\n    @Before(\"matchAllClassFromPackage()\")\n    public void beforeMatchAllClassFormPackage() {\n        System.out.println(\"--------模糊匹配包中所有的类-------\");\n    }\n\n    @Before(\"matchClassFromPackage()\")\n    public void beforeMatchClassFromPackage() {\n        System.out.println(\"--------模糊匹配包中所有的带Impl后缀的-------\");\n    }\n\n\n}\n\n```\n\n## 3.2 @within\n\n### a. API说明\n\n拦截被指定注解标注的类\n\n### b. 目录\n\n```\n├── AnnotationWithinMatchProcessor\n│   ├── AopAnnotationWithinMatchProcessor.java\n│   ├── Log.java\n│   ├── Sprite.java\n│   └── readme.md\n\n```\n\n### c. 拦截代码\n\n```java\n@Log(tag = \"SpriteLog\")\n@Component\npublic class Sprite {\n\n    public void drink() {\n        System.out.println(\"空参数\");\n    }\n\n    public void drink(Integer age) {\n        System.out.println(\"age\");\n    }\n\n\n    public String name() {\n        return \"Sprite.name\";\n    }\n\n    public void toCalculate() throws Exception {\n        System.out.println(0 / 0);\n    }\n}\n\n@Aspect\n@Component\npublic class AopAnnotationWithinMatchProcessor {\n\n\n    /**\n     * 注意可以将注解,放到参数中,此时@within()会将参数入参名去找到注解的类型\n     * 凡是被Log标记的类,都会被拦截\n     *\n     * @param spriteLog 注解\n     */\n    @Before(\"@within(spriteLog)\")\n    public void beforeAnnotationMatch(Log spriteLog) {\n        System.out.println(\"--------拦截被Log修饰类的所有方法\" + spriteLog.tag() + \"-------\");\n    }\n\n\n    /**\n     * 返回值\n     *\n     * @param value     返回值\n     * @param spriteLog 注解\n     */\n    @AfterReturning(value = \"@within(spriteLog)\", returning = \"value\")\n    public void afterReturningAnnotationMatch(String value, Log spriteLog) {\n        System.out.println(\"afterReturningAnnotationMatch返回值:\" + value + \",注解:\" + spriteLog);\n    }\n\n    /**\n     * 拦截异常\n     *\n     * @param e         异常\n     * @param spriteLog 拦截日志\n     */\n    @AfterThrowing(value = \"@within(spriteLog)\", throwing = \"e\")\n    public void AfterThrowingAnnotationMatch(Exception e, Log spriteLog) {\n        System.out.println(e.getMessage());\n    }\n\n}\n```\n\n## 3.3 this\n\n### a. API说明\n\n拦截指定的类\n\n### b. 目录\n\n```\n├── ThisMatchProcessor\n│   ├── AopThisMatchProcessor.java\n│   ├── ThisPerson.java\n│   └── readme.md\n\n```\n\n### c. 拦截代码\n\n```java\n@Aspect\n@Component\npublic class AopThisMatchProcessor {\n\n    @Before(value = \"this(ThisPerson)\")\n    public void thisMatch() {\n        System.out.println(\"--------------ThisPerson------------\");\n    }\n}\n\n```\n\n## 3.4 args\n\n### a. API说明\n\n```java\n@Component\npublic class Person {\n\n    public String info(String name) {\n        return \"姓名：\" + name;\n    }\n\n    public String info(String name, Integer age) {\n        return \"姓名：\" + name + \",年龄:\" + age;\n    }\n}\n```\nPerson类中有两个info方法,但是入参不一样,假如要拦截指定入参的方法时候,就可以使用args\n\n### b. 目录\n\n```\n├── ArgsMatchProcessor\n│   ├── AopArgsMatchProcessor.java\n│   ├── Person.java\n│   └── readme.md\n```\n\n### c. 拦截代码\n\n可以看到args 和 within可以通过&&来进行,联合匹配。另外可以通过returning方法指定方法的返回值。但是注意，类型要和要拦截的方法的返回类型匹配。否则会报错。\n\n```java\n@Aspect\n@Component\npublic class AopArgsMatchProcessor {\n\n    @AfterReturning(value = \"within(Person) && args(name,age)\", returning = \"value\")\n    public void beforeArgs(Integer age, String name, String value) {\n        System.out.println(\"拦截器逻辑----------------------------\");\n        System.out.println(\"入参name:\" + name);\n        System.out.println(\"入参age:\" + age);\n        System.out.println(\"返回值:\" + value);\n        System.out.println(\"拦截器逻辑----------------------------\");\n    }\n}\n```\n\n## 3.5 @annotation\n\n### a. API说明\n\n拦截被指定注解标记的方法。\n\n### b. 目录\n\n```\n├── AnnotationMethodMatchProcessor\n│   ├── AopAnnotationMethodMatchProcessor.java\n│   ├── LogMethod.java\n│   └── Main.java\n\n```\n\n### c. 代码\n\n```java\n@Aspect\n@Component\npublic class AopAnnotationMethodMatchProcessor {\n\n\n    @Before(value = \"@annotation(logMethod) && args(args)\")\n    public void annotationMethodMatch(LogMethod logMethod, String args) {\n        System.out.println(\"注解方法匹配\");\n    }\n}\n```\n\n## 3.6 @args\n\n### a. API说明\n\n拦截方法中入参被@args指定注解的方法。\n\n### b. 目录\n\n```\n├── AnnotationArgsMatchProcessor\n│   ├── AopAnnotationArgsMatchProcessor.java\n│   ├── Apple.java\n│   ├── Fruit.java\n│   ├── Orange.java\n│   └── Teacher.java\n```\n\n### c. 代码\n\n注意当出现以下异常说明aop声明的拦截范围太广泛了，导致了一些不能拦截的类被拦截从而报错了，此时只用缩小拦截的范围即可\n```\n Cannot subclass final class org.springframework.boot.autoconfigure.AutoConfigurationPackages$BasePackages\n ```\n\n缩小拦截范围如下使用this拦截指定类型\n\n```java\n@Aspect\n@Component\npublic class AopAnnotationArgsMatchProcessor {\n\n    @Before(value = \"@args(fruit) && this(Teacher)\")\n    public void annotationMethodMatch(Fruit fruit) {\n        System.out.println(\"拦截被Fruit+tag:\"+fruit.tag());\n    }\n}\n\n```\n\n## 3.7 execution\n\n### a. API说明\n\nexecution()是最常用的切点函数，其语法如下所示：\n\n`execution(<修饰符模式>? <返回类型模式> <方法名模式>(<参数模式>) <异常模式>?) 除了返回类型模式、方法名模式和参数模式外，其它项都是可选的`\n\n\n\n表达式 | 说明\n---|---\nexecution(public * *(..)) | 匹配所有目标类的public方法\nexecution(* *Test(..)) | 匹配目标类所有以To为后缀的方法\nexecution(*spring.learning.Water.*(..)) | 匹配Water接口所有方法\nexecution(*spring.learning.Water+.*(..)) | 匹配Water接口以及实现类中所有方法(包括Water接口中没有的方法)\nexecution(* spring.learning.*(..))| 匹配spring.learning包下所有的类所有方法\nexecution(* spring.learning..*(..))| 匹配spring.learning包及其子孙包下所有的类所有方法\nexecution(* spring..*.*Dao.find*(..))|匹配包名前缀为spring的任何包下类名后缀为Dao的方法，方法名必须以find为前缀\nexecution(* info(String,Integer)) | 匹配info方法中,第一个参数是String,第二个Integer的方法\nexecution(* info(String,*))) | 匹配info方法中,第一个参数是String,第二个任意类型\nexecution(* info(String,..))) | 匹配info方法中,第一个参数是String,后面任意参数\nexecution(* info(Object+))) | 匹配info方法中,方法拥有一个入参，且入参是Object类型或该类的子类\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/spring/AOP.md b/docs/learn/spring/AOP.md
--- a/docs/learn/spring/AOP.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/spring/AOP.md	(date 1655373430435)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: package.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>{\n  \"name\": \"java-guide\",\n  \"version\": \"1.0.0\",\n  \"description\": \"西魏陶渊明的个人笔记\",\n  \"license\": \"MIT\",\n  \"scripts\": {\n    \"docs:build\": \"vuepress build docs\",\n    \"docs:clean-dev\": \"vuepress dev docs --no-cache\",\n    \"docs:dev\": \"vuepress dev docs\",\n    \"docs:eject-theme\": \"vuepress eject-hope docs\"\n  },\n  \"devDependencies\": {\n    \"vuepress\": \"^1.9.7\",\n    \"vuepress-theme-hope\": \"^1.28.4\"\n  },\n  \"dependencies\": {\n    \"js-cookie\": \"^3.0.1\",\n    \"swiper\": \"^8.1.5\",\n    \"vuepress\": \"^1.9.7\",\n    \"vuepress-theme-hope\": \"^1.28.4\"\n  }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/package.json b/package.json
--- a/package.json	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/package.json	(date 1654740210131)
@@ -5,7 +5,7 @@
   "license": "MIT",
   "scripts": {
     "docs:build": "vuepress build docs",
-    "docs:clean-dev": "vuepress dev docs --no-cache",
+    "docs:clean-dev": "vuepress dev docs -p 6676 --no-cache",
     "docs:dev": "vuepress dev docs",
     "docs:eject-theme": "vuepress eject-hope docs"
   },
Index: docs/learn/mybatis/环境搭建.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: true\nfooter: true\nbacktotop: true\ntitle: 第01篇:Mybatis学习之环境搭建\ncategory: Mybatis\n---\n\n<PageBanner/>\n\n## 一、环境搭建\n\n### 1.1 数据库脚本\n\n```sql\nSET NAMES utf8;\nSET FOREIGN_KEY_CHECKS = 0;\n\n-- ----------------------------\n--  Table structure for `T_USER`\n-- ----------------------------\nDROP TABLE IF EXISTS `T_USER`;\nCREATE TABLE `T_USER` (\n  `uid` int(11) NOT NULL AUTO_INCREMENT COMMENT '用户id',\n  `name` char(32) DEFAULT NULL,\n  `token_id` char(64) NOT NULL,\n  PRIMARY KEY (`uid`,`token_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\nSET FOREIGN_KEY_CHECKS = 1;\n```\n\n### 1.2 POM依赖\n\n```xml\n<plugin>\n    <groupId>org.mybatis.generator</groupId>\n    <artifactId>mybatis-generator-maven-plugin</artifactId>\n    <version>1.3.2</version>\n    <configuration>\n        <configurationFile>${basedir}/src/main/resources/generator/generatorConfig.xml</configurationFile>\n        <overwrite>true</overwrite>\n        <verbose>true</verbose>\n    </configuration>\n</plugin>\n```\n\n### 1.3 执行脚本生成代码\n\nmysql数据库记得要安装好,如果clone代码下来学习,记得要改成自己的数据库。\n当上面的步骤都完成后,并输入自己的mysql地址和用户信息后。就可以执行下面脚本了。\n\n`mvn mybatis-generator:generate`\n\n执行后就会生成我们本节要说的所有内容代码了。\n\n``` \n➜ tree\n.\n├── LICENSE\n├── README.md\n├── pom.xml\n└── src\n    ├── main\n    │   ├── java\n    │   │   └── orm\n    │   │       └── example\n    │   │           └── dal\n    │   │               ├── mapper\n    │   │               │   └── TUserMapper.java\n    │   │               └── model\n    │   │                   └── TUser.java\n    │   └── resources\n    │       ├── generator\n    │       │   └── generatorConfig.xml\n    │       └── mapper\n    │           └── TUserMapper.xml\n    └── test\n        └── java\n\n13 directories, 7 files\n\n\n```\n\n## 二、原生jdbc知识复习\n\n## 2.1 JDBC是什么？\n\nJDBC代表Java数据库连接(Java Database Connectivity)，它是用于Java编程语言和数据库之间的数据库无关连接的标准Java API，换句话说：JDBC是用于在Java语言编程中与数据库连接的API。\n\n1. 连接到数据库\n2. 创建SQL或MySQL语句\n3. 在数据库中执行SQL或MySQL查询\n4. 查看和修改结果记录\n\n### 2.1.1 代码示例\n\n```java \n    @Test\n    public void jdbc() throws Exception {\n        String dbUrl = \"jdbc:mysql://127.0.0.1:3306/test\";\n        String user = \"root\";\n        String pass = \"123456\";\n        Connection connection = DriverManager.getConnection(dbUrl, user, pass);\n        Statement statement = connection.createStatement();\n        ResultSet resultSet = statement.executeQuery(\"select * from T_User\");\n        while (resultSet.next()) {\n            String name = resultSet.getString(\"name\");\n            System.out.println(name);\n        }\n        statement.close();\n        resultSet.close();\n        connection.close();\n    }\n```\n\n\n## 2.2 jdbc知识点\n\n### 2.2.1 jdbc驱动\n\n通过前面的例子,我们看到我们都是调用 java.sql的包下面的类创建的与数据库交互的工具。那么我们试想一下。\njava怎么知道我们用的数据库是什么呢? 如果不知道他怎么知道如何进行交互呢?\n\n其实就是 java.sql定义了一系列的接口定义, 由具体的第三方数据库来实现这些定义。从而进行底层的交互。\n这里因为我们使用的是mysql数据库，所以 Connection的具体实现就是mysql的数据驱动类 ConnectionImpl。\n\n\nDriverManager 怎么知道我们要用mysql的实现呢? 这里面用到的数据就是java原生的spi能力。\n\n![](https://img.springlearn.cn/blog/learn_1648648826000.png)\n\n\n```java \n private static void loadInitialDrivers() {\n    ServiceLoader<Driver> loadedDrivers = ServiceLoader.load(Driver.class);\n    Iterator<Driver> driversIterator = loadedDrivers.iterator();\n }\n```\n\n当获得了与数据库的连接后，就可以与数据库进行交互了。 JDBC Statement，CallableStatement和PreparedStatement接口定义了可用于发送SQL或PL/SQL命令，并从数据库接收数据的方法和属性。\n它们还定义了有助于在Java和SQL数据类型的数据类型差异转换的方法。\n\n|接口|说明|特点|\n|:--|:--|:--|\n|Statement|用于对数据库进行通用访问，在运行时使用静态SQL语句时很有用。 Statement接口不能接受参数。|Statement每次的执行都需要编译SQL|\n|PreparedStatement|当计划要多次使用SQL语句时使用。PreparedStatement接口在运行时接受输入参数。|PreparedStatement会预编译，会被缓冲，在缓存区中可以发现预编译的命令，虽然会被再次解析，但不会被再次编译，能够有效提高系统性能|\n|CallableStatement|当想要访问数据库存储过程时使用。CallableStatement接口也可以接受运行时输入参数。|CallableStatement支持存储过程|\n\n### 2.2.2 Statement\nStatement对象后，可以使用它来执行一个SQL语句，它有三个执行方法可以执行\n\n- boolean execute (String SQL) ： 如果可以检索到ResultSet对象，则返回一个布尔值true; 否则返回false。使用此方法执行SQLDDL语句或需要使用真正的动态SQL，可使用于执行创建数据库，创建表的SQL语句等等。\n- int executeUpdate (String SQL): 返回受SQL语句执行影响的行数。使用此方法执行预期会影响多行的SQL语句，例如:INSERT，UPDATE或DELETE语句。\n- ResultSet executeQuery(String SQL)：返回一个ResultSet对象。 当您希望获得结果集时，请使用此方法，就像使用SELECT语句一样。\n\n```java \n    @Test\n    public void statement() throws Exception {\n        String dbUrl = \"jdbc:mysql://127.0.0.1:3306/test\";\n        String user = \"root\";\n        String pass = \"123456\";\n        Connection connection = DriverManager.getConnection(dbUrl, user, pass);\n        connection.setAutoCommit(false);\n        Statement statement = connection.createStatement();\n        // true\n        System.out.println(statement.execute(\"insert into t_user (name,token_id) values ('孙武空','007')\"));\n        ResultSet resultSet = statement.executeQuery(\"select * from t_user\");\n        while (resultSet.next()) {\n            String name = resultSet.getString(\"name\");\n            System.out.println(name);\n        }\n        connection.rollback();\n        statement.close();\n        connection.close();\n    }\n```\n\n### 2.2.3 PreparedStatement\n\nPreparedStatement接口扩展了Statement接口，它添加了比Statement对象更好一些优点的功能。\n此语句可以动态地提供/接受参数。\n\n```java \n    @Test\n    public void prepareStatement() throws Exception {\n        String dbUrl = \"jdbc:mysql://127.0.0.1:3306/test\";\n        String user = \"root\";\n        String pass = \"123456\";\n        Connection connection = DriverManager.getConnection(dbUrl, user, pass);\n        connection.setAutoCommit(false);\n        PreparedStatement preparedStatement = connection.prepareStatement(\"insert into t_user (name,token_id) values (?,?)\");\n        preparedStatement.setString(1, \"唐三藏\");\n        preparedStatement.setString(2, \"tok\");\n        preparedStatement.execute();\n\n        ResultSet resultSet = preparedStatement.executeQuery(\"select * from t_user\");\n        while (resultSet.next()) {\n            String name = resultSet.getString(\"name\");\n            System.out.println(name);\n        }\n        connection.rollback();\n        preparedStatement.close();\n        connection.close();\n    }\n```\n\n### 2.2.4 CallableStatement\n\n类似Connection对象创建Statement和PreparedStatement对象一样，它还可以使用同样的方式创建CallableStatement对象，该对象将用于执行对数据库存储过程的调用。\n\n```java \n    @Test\n    public void callableStatement() throws Exception {\n        String dbUrl = \"jdbc:mysql://127.0.0.1:3306/test\";\n        String user = \"root\";\n        String pass = \"123456\";\n        Connection connection = DriverManager.getConnection(dbUrl, user, pass);\n        // 1. 创建一个存储过程\n        String call =\n                \"CREATE PROCEDURE delete_matches(IN del_name varchar(64))\\n\" +\n                        \"begin\\n\" +\n                        \"    delete from t_user where name = del_name;\\n\" +\n                        \"end;\";\n        Statement statement = connection.createStatement();\n        statement.execute(\"DROP PROCEDURE IF EXISTS delete_matches;\");\n        statement.execute(call);\n\n        // 执行存储过程\n        CallableStatement callableStatement = connection.prepareCall(\"call delete_matches(?)\");\n        callableStatement.setString(1, \"孙武空\");\n        callableStatement.execute();\n\n        // 查询结果检查存储过程是否成功\n        ResultSet resultSet = statement.executeQuery(\"select * from t_user\");\n        while (resultSet.next()) {\n            String name = resultSet.getString(\"name\");\n            System.out.println(name);\n        }\n        statement.close();\n        callableStatement.close();\n        connection.close();\n    }\n```\n\n:::tip\njdbc主要提供跟数据库的交互,其主要的类就是上面演示的。通过上面的复习。我们要清楚下面几个类的作用。\n后面我们在学习mybatis时候,我们看mybatis是如何对下面类的封装,从而实现orm映射的。\n:::\n\n\n|关键类|说明|\n|:--|:--|\n|Connection|数据库连接|\n|Statement|静态sql执行|\n|PreparedStatement|预处理sql|\n|CallableStatement|存储过程执行|\n|ResultSet|返回结果集|\n\n\n## 三、抛转引玉 \n\n前面我们首先搭建了mybaits的开发环境,然后又对jdbc的知识进行了复习。下面我们就开始学习mybait的源码,看mybatis是如何对\njdbc一步一步进行封装从而实现了orm的映射吧。\n首先我们先看下下面演示代码。\n\n\n```java\n    @Test\n    public void mapper() {\n        // 读取配置信息(为什么路径前不用加/,因为是相对路径。maven编译后的资源文件和class文件都是在一个包下,所以不用加/就是当前包目录)\n        InputStream mapperInputStream = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"mybatisConfig.xml\");\n        // 生成SqlSession工厂,SqlSession从名字上看就是,跟数据库交互的会话信息,负责将sql提交到数据库进行执行\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(mapperInputStream, \"development\");\n        // 获取Mybatis配置信息\n        Configuration configuration = sqlSessionFactory.getConfiguration();\n        // 参数: autoCommit,从名字上看就是是否自动提交事务\n        SqlSession sqlSession = sqlSessionFactory.openSession(false);\n        // 获取Mapper\n        TUserMapper mapper = configuration.getMapperRegistry().getMapper(TUserMapper.class, sqlSession);\n        TUser tUser = new TUser();\n        tUser.setName(\"testUser1\");\n        tUser.setTokenId(\"testTokenId1\");\n        mapper.insert(tUser);\n        // 获取插入的数据\n        System.out.println(mapper.selectAll());\n        // 数据插入后，执行查询，然后回滚数据\n        sqlSession.rollback();\n    }\n```\n\njdbc的原生操作基本已经看不到了。我们已经使用Mybatis实现了与数据库的交互。可以看到并没有看到sql信息。\n因为sql信息都维护在TUserMapper.xml里面,Mybatis帮我们把TUserMapper.xml和TUserMapper建立了关系。\n最终将原本要通过jdbc实现的操作通过代理的方式，并最终通过TUserMapper这个接口进行交互了。\n\n请问到这里勾起你的好奇心了没有呢? 想不想知道为什么能这样吗? 想不想知道mybaits究竟做了什么,以及是怎么做的呢?\n本系列文章会带你一探究竟。在开始之前我们先指定一下学习目标吧。\n\n## 3.1 学习目标制定\n\n- 配置文件是如何解析成 `Configuration` ?\n- `sql` 和数据库是如何交互的 `SqlSession` ?\n- `mapper.xml` 和 `Mapper` 是如何绑定的`MapperRegistry` ?\n- `Mybatis` 是如何做动态代理的 ?\n- Mybatis中如何利用插件实现扩展的?\n- Jdbc的Statement在Mybatis是如何封装的?\n- 以及Mybatis中很多好用的工具类.\n\n## 3.2 学习后我们能得到什么\n\n- 从配置文件解析中我们能学会,如果解析占位符。并将占位符填充真实数据。\n- 通过对 `SqlSession` 的学习,我们会了解到Mybatis的缓存设计,批处理任务,事务等操作。\n- 通过对 `MapperRegistry` 的学习, 我们会了解到如何实现 `orm(对象关系映射)` 框架。\n- 我们会收货很多设计的思路，而思路决定出路。\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/mybatis/环境搭建.md b/docs/learn/mybatis/环境搭建.md
--- a/docs/learn/mybatis/环境搭建.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/mybatis/环境搭建.md	(date 1655373430140)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/mybatis/配置文件解析.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: true\nfooter: true\nbacktotop: true\ntitle: 第02篇:Mybatis配置文件解析\ncategory: Mybatis\n---\n<PageBanner/>\n\n## 一、配置文件分析\n\n::: note 文件分析\n在上一篇的代码中,我们看到了一个非常重要文件,这里我们先来人肉分析看,然后看下代码是如何解析的,毕竟代码也是人写的。\n思路决定出路,我们如果有思路,然后在看源码会更加的具有分析的能动性。\n:::\n\n<Badge text=\"mybatisConfig.xml\" type=\"warn\"/>\n\n```java {4}\n    @Test\n    public void mapper() {\n        // 读取配置信息(为什么路径前不用加/,因为是相对路径。maven编译后的资源文件和class文件都是在一个包下,所以不用加/就是当前包目录)\n        InputStream mapperInputStream = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"mybatisConfig.xml\");\n        // 生成SqlSession工厂,SqlSession从名字上看就是,跟数据库交互的会话信息,负责将sql提交到数据库进行执行\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(mapperInputStream, \"development\");\n        // 获取Mybatis配置信息\n        Configuration configuration = sqlSessionFactory.getConfiguration();\n        // 参数: autoCommit,从名字上看就是是否自动提交事务\n        SqlSession sqlSession = sqlSessionFactory.openSession(false);\n        // 获取Mapper\n        TUserMapper mapper = configuration.getMapperRegistry().getMapper(TUserMapper.class, sqlSession);\n        TUser tUser = new TUser();\n        tUser.setName(\"testUser1\");\n        tUser.setTokenId(\"testTokenId1\");\n        mapper.insert(tUser);\n        // 获取插入的数据\n        System.out.println(mapper.selectAll());\n        // 数据插入后，执行查询，然后回滚数据\n        sqlSession.rollback();\n    }\n```\n\n### 1.1 mybatisConfig.xml\n\n::: tip 注意看高亮行\n1. line(4) dtd文件是xml的约束文件,用于约束 `xml` 标签中属性\n2. line(8) properties标签,指定了配置信息文件是 `application.properties`\n3. line(11-13) mybatis的配置信息\n4. line(15-27) mybatis支持多环境配置\n5. line(30-32) 映射文件\n:::\n\n基于上面的行，我们来讲解。\n\n```xml {4,8,11-13,15-27,30-32}\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n\n    <!-- 指定properties配置文件， 我这里面配置的是数据库相关 -->\n    <properties resource=\"application.properties\"></properties>\n\n    <!-- 指定Mybatis使用log4j -->\n    <settings>\n        <setting name=\"logImpl\" value=\"LOG4J\"/>\n    </settings>\n\n    <environments default=\"development\">\n        <environment id=\"development\">\n            <transactionManager type=\"JDBC\"/>\n            <dataSource type=\"POOLED\">\n                <!-- 上面指定了数据库配置文件， 配置文件里面也是对应的这四个属性 -->\n                <property name=\"driver\" value=\"${datasource.driver-class-name}\"/>\n                <property name=\"url\" value=\"${datasource.url}\"/>\n                <property name=\"username\" value=\"${datasource.username}\"/>\n                <property name=\"password\" value=\"${datasource.password}\"/>\n\n            </dataSource>\n        </environment>\n    </environments>\n\n    <!-- 映射文件，mybatis精髓， 后面才会细讲 -->\n    <mappers>\n        <mapper resource=\"mapper/TUserMapper.xml\"/>\n    </mappers>\n\n</configuration>\n```\n\n## 二、知识点讲解\n\n## 2.1 xml约束文件dtd\n\n为什么要学习dtd约束文件呢? 当你学会dtd约束文件后,你就知道这个标签有那些属性，知道标签及子标签信息。\n当有一天你要写开源框架的时候,你也可以来定义你自己的配置文件规则。这部分知识了解就行。不需要死记硬背。\n因为记住也基本没啥用,只要做到看到了认识，需要用了知道去哪里抄代码学习就够了。\n\n### 2.1.1 元素 & 属性 & 属性值\n\n[dtd文件](https://www.w3school.com.cn/dtd/index.asp)\n\n|域|示例|语法|例子|\n|:--|:--|:--|:--|\n|元素|声明根元素标签|`<!ELEMENT 元素名称 (元素内容)>`|`<!ELEMENT students(student)>`,元素students有一个student|\n|元素|空元素|`<!ELEMENT 元素名称 EMPTY>`|`<br />`|\n|元素|元素只出现一次|`<!ELEMENT 元素名称 (子元素名称)>`|`<!ELEMENT students(student)>`,元素students至少有一个student|\n|元素|元素最少出现一次|`<!ELEMENT 元素名称 (子元素名称+)>`|`<!ELEMENT students(student+)>`,元素students最少有一个student|\n|元素|声明出现零次或多次的元素|`<!ELEMENT 元素名称 (子元素名称*)>`|`<!ELEMENT students(student*)>`,元素students可以有多个student,也可以一个没有|\n|元素|声明“非.../既...”类型的内容|`<!ELEMENT note (to,from,header,(message|body))>`|`<!ELEMENT student(name,age,(boy|girl))>`,元素student有一个name和age标签,有一个boy或者girl标签|\n|元素|声明混合型的内容|`<!ELEMENT note (#PCDATA|to|from|header|message)*>`| `<!ELEMENT note (#PCDATA|to|from|header|message)*>`\"note\" 元素可包含出现零次或多次的 PCDATA、\"to\"、\"from\"、\"header\" 或者 \"message\" |\n|属性|属性声明|`<!ATTLIST 元素名称 属性名称 属性类型 默认值>`|`<!ATTLIST payment type CDATA \"check\">`,payment有一个属性type,类型为字符类型,默认值check|\n\n`<!ATTLIST 元素名称 属性名称 属性类型 默认值>`\n\n**值类型**\n\n|类型|描述|\n|:--|:--|\n|CDATA|\t值为字符数据 (character data)|\n|(en1|en2|..)|此值是枚举列表中的一个值|\n|ID|值为唯一的 id|\n|IDREF|值为另外一个元素的 id|\n|IDREFS|值为其他 id 的列表|\n|NMTOKEN|值为合法的 XML 名称|\n|NMTOKENS|值是一个实体|\n|ENTITIES|值是一个实体列表|\n|NOTATION|此值是符号的名称|\n|xml:|值是一个预定义的 XML 值|\n\n**默认值参数可使用下列值**\n\n|类型|描述|\n|:--|:--|\n|值|\t属性的默认值|\n|#REQUIRED|属性值是必需的|\n|#IMPLIED|属性不是必需的|\n|#FIXED value|属性值是固定的|\n\n\n\n## 2.2 configuration标签分析\n\n前面我们知道了dtd约束文件,我们就可以看下,configuration标签一共有那些子标签及属性信息了。\n\n[mybatis-3-config.dtd](http://mybatis.org/dtd/mybatis-3-config.dtd)\n\n通过分析dtd文件,我们知道有那些子标签及属性信息。内容比较长。但是不是很重要。这里只要知道就行。\n\n后面我们看如何使用代码来解析这些标签。\n\n\n![](/blog/img/Mybatis配置标签.svg)\n\n## 2.3 Mybatis配置解析核心逻辑\n\n:::tip 思路决定出路\n- line(6) `sqlSessionFactory.getConfiguration()`\n\n由此来看所有的解析都是在SqlSessionFactoryBuilder进行完成的.\n具体的解析xml代码我们不研究，这里我们只要搞清楚它的调用关系,及实现的代码在哪里即可。如果这里\n看懂，其实都会得到一个结论。就是mybaits的源码是比较简单的,因为他的配置是比较集中的，无论是xml方式或者是注解方式。\n最终所有的配置信息都在 `Configuration` 类中。\n:::\n\n\n\n```java {6}\n    @Test\n    public void configuration() {\n        // 读取配置信息(为什么路径前不用加/,因为是相对路径。maven编译后的资源文件和class文件都是在一个包下,所以不用加/就是当前包目录)\n        InputStream mapperInputStream = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"mybatisConfig.xml\");\n        // 生成SqlSession工厂,SqlSession从名字上看就是,跟数据库交互的会话信息,负责将sql提交到数据库进行执行\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(mapperInputStream, \"development\");\n        // 获取Mybatis配置信息,由此来看所有的解析都是在SqlSessionFactoryBuilder进行完成的.\n        Configuration configuration = sqlSessionFactory.getConfiguration();\n    }\n```\n\n### 2.3.1 new SqlSessionFactoryBuilder().build\n\n这里可以看到就是核心类就是使用 `XMLConfigBuilder` 进行解析。下面我们就主要分析 `XMLConfigBuilder`\n\n```java \npublic SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) {\n    try {\n      XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);\n      return build(parser.parse());\n    } catch (Exception e) {\n      throw ExceptionFactory.wrapException(\"Error building SqlSession.\", e);\n    } finally {\n      ErrorContext.instance().reset();\n      try {\n        inputStream.close();\n      } catch (IOException e) {\n        // Intentionally ignore. Prefer previous error.\n      }\n    }\n  }\n```\n\n\n### 2.3.2 核心配置类解析(XMLConfigBuilder)\n\n:::note 重点关注\n1. line(8), 我们看到核心解析类是 `XPathParser parser = new XPathParser()`\n2. line(17), 标签的解析都在 `parseConfiguration`\n3. line(17), 思考下为什么先解析 `propertiesElement(root.evalNode(\"properties\"))`\n:::\n\n```java  {8,17}\npublic class XMLConfigBuilder extends BaseBuilder {\n\n  private boolean parsed;\n  private final XPathParser parser;\n  private String environment;\n  private final ReflectorFactory localReflectorFactory = new DefaultReflectorFactory();\n  \n  public Configuration parse() {\n    if (parsed) {\n      throw new BuilderException(\"Each XMLConfigBuilder can only be used once.\");\n    }\n    parsed = true;\n    parseConfiguration(parser.evalNode(\"/configuration\"));\n    return configuration;\n  }\n  \n  private void parseConfiguration(XNode root) {\n    try {\n      // issue #117 read properties first\n      propertiesElement(root.evalNode(\"properties\"));\n      Properties settings = settingsAsProperties(root.evalNode(\"settings\"));\n      loadCustomVfs(settings);\n      loadCustomLogImpl(settings);\n      typeAliasesElement(root.evalNode(\"typeAliases\"));\n      pluginElement(root.evalNode(\"plugins\"));\n      objectFactoryElement(root.evalNode(\"objectFactory\"));\n      objectWrapperFactoryElement(root.evalNode(\"objectWrapperFactory\"));\n      reflectorFactoryElement(root.evalNode(\"reflectorFactory\"));\n      settingsElement(settings);\n      // read it after objectFactory and objectWrapperFactory issue #631\n      environmentsElement(root.evalNode(\"environments\"));\n      databaseIdProviderElement(root.evalNode(\"databaseIdProvider\"));\n      typeHandlerElement(root.evalNode(\"typeHandlers\"));\n      mapperElement(root.evalNode(\"mappers\"));\n    } catch (Exception e) {\n      throw new BuilderException(\"Error parsing SQL Mapper Configuration. Cause: \" + e, e);\n    }\n  }\n}  \n```\n\n看到上面代码是不是就恍然大悟了，原来配置文件的标签都是在这里解析呀。这里的主要思路就是将xml解析成Java对象然后放到\nConfiguration中。具体任何实现呢? 感兴趣可以自己研究下。\n\n### 2.3.3 Configuration属性介绍\n\n那么这些数据最终哪里会使用呢，我们专门留一片文章, 详细分析。这里先看看Configuration内部都有那些关键的配置类把。\n\n|属性|解释|\n|:--|:--|\n|TypeAliasRegistry|key是一个别名,value是一个class对象|\n|Properties variables|配置文件中占位符的变量配置|\n|InterceptorChain interceptorChain|拦截链,用于拦截方法,实现插件|\n|ObjectFactory objectFactory|对象实例化统一的工厂方法,我们不用都反射来实例化了|\n|ObjectWrapperFactory objectWrapperFactory|包装对象后为其提供统一的属性操作方法。我们不用通过反射来修改对象属性值了 |\n|ReflectorFactory reflectorFactory|反射工厂,用于生成一个反射信息对象,具有缓存的作用|\n|Environment environment|环境信息包含(事务管理器和数据源)|\n|TypeHandlerRegistry typeHandlerRegistry|主要处理jdbc的返回数据，转换成Java对象|\n|MapperRegistry mapperRegistry|Mapper生成的处理类,包含代理的逻辑|\n\n\n### 2.3.4 Mapper.xml 解析\n\n**XMLMapperBuilder**\n\n解析Mapper对应的xml配置文件,这里面包含了sql的信息。\n\nmapper的dtd约束文件更多,可以参考: https://mybatis.org/mybatis-3/zh/sqlmap-xml.html#\n```xml\n    <!-- 映射文件，mybatis精髓， 后面才会细讲 -->\n    <mappers>\n        <mapper resource=\"mapper/TUserMapper.xml\"/>\n    </mappers>\n```\n\n![](/blog/img/Mapper.svg)\n\n这里就要介绍一个重要的类的，`MapperBuilderAssistant` Mapper构建辅助工具类。\n\n|属性|解释|\n|:--|:--|\n|MapperBuilderAssistant|Mapper构建辅助工具类(缓存配置)|\n|CacheRefResolver|决定如何使用缓存|\n|ParameterMapping|当sql中使用到了#{}占位符时候,负责填充sql参数|\n|ResultMapResolver|返回值映射|\n|Map<String, XNode> sqlFragments|sql片段|\n|MappedStatement|Mapper方法的所有信息(出参，入参，及sql信息等)|\n\n## 2.4 Mybatis可以借鉴的知识点\n\n### 2.4.1 占位符解析逻辑\n\n在第一篇的时候我们说过，从配置文件解析中我们能学会,如果解析占位符。并将占位符填充真实数据。这里我们就具体说下是如何解析。\n还记得前面让思考下为什么先解析 `propertiesElement(root.evalNode(\"properties\"))`。\n\n答案就是为了先读取变量信息，方便后面给依赖的信息，给填充值。\n\n我们直接说答案: 具体谁来做了这个事情，从职责划分上来看，这个其实还是属于xml文件解析。所以是 `XPathParser parser`\nXPathParser中填充上变量信息，这样XPathParser在解析的时候会自动将 `${}` 填充上真实的数据。\n```java \n    // 执行后,会解析properties标签,并且将属性赋值给XPathParser\n    propertiesElement(root.evalNode(\"properties\"));\n    parser.setVariables(defaults);\n    configuration.setVariables(defaults);\n\n    // XPathParser 生成节点时候,属性信息会提前处理。\n    public XNode(XPathParser xpathParser, Node node, Properties variables) {\n       this.xpathParser = xpathParser;\n       this.node = node;\n       this.name = node.getNodeName();\n       this.variables = variables;\n       this.attributes = parseAttributes(node);\n       this.body = parseBody(node);\n     }\n     // 发现是占位符，就从变量中读取。\n     // ${datasource.driver-class-name} 替换成变量值里面的数据。\n     public static String parse(String string, Properties variables) {\n       VariableTokenHandler handler = new VariableTokenHandler(variables);\n       GenericTokenParser parser = new GenericTokenParser(\"${\", \"}\", handler);\n       return parser.parse(string);\n     }\n```\n\n### 2.4.2 Mybatis Resources 工具\n\n可以从配置文件中或者网络中解析配置，生成 `Resources` 对象\n\n```java \n      String resource = context.getStringAttribute(\"resource\");\n      if (resource != null) {\n        defaults.putAll(Resources.getResourceAsProperties(resource));\n      } else if (url != null) {\n        defaults.putAll(Resources.getUrlAsProperties(url));\n      }\n      parser.setVariables(defaults);\n      configuration.setVariables(defaults);\n      \n      // 从资源中获取流\n      InputStream inputStream = Resources.getResourceAsStream(resource)\n      // 从url中获取流\n      InputStream inputStream = Resources.getUrlAsStream(url)\n```\n\n### 2.4.3 Mybatis PropertyParser 占位符解析\n\n```java \n    @Test\n    public void propertyParser() {\n        Properties variables = new Properties();\n        variables.put(\"datasource.driver-class-name\", \"com.mysql.cj.jdbc.Driver\");\n        // 变量中有就从变量中获取 参数信息: com.mysql.cj.jdbc.Driver\n        System.out.println(PropertyParser.parse(\"参数信息: ${datasource.driver-class-name}\", variables));\n        // 变量中没有就直接返回key datasource.url\n        System.out.println(PropertyParser.parse(\"datasource.url\", variables));\n    }\n```\n\n### 2.4.4 反射工厂 ReflectorFactory\n\n在Mybatis中使用到的反射地方蛮多的，那么都知道反射是相对比较耗时间，那么我们来看Mybatis是如何利用反射工厂来提高反射的性能的?\n\n缓存，对要使用的Class类，做反射并保存起来, 生成的对象是 `Reflector`。\n\n`ReflectorFactory reflectorFactory = new DefaultReflectorFactory();`\n\n```java \npublic interface ReflectorFactory {\n\n  boolean isClassCacheEnabled();\n\n  void setClassCacheEnabled(boolean classCacheEnabled);\n\n  Reflector findForClass(Class<?> type);\n}\n\npublic class Reflector {\n\n  private final Class<?> type;\n  private final String[] readablePropertyNames;\n  private final String[] writablePropertyNames;\n  private final Map<String, Invoker> setMethods = new HashMap<>();\n  private final Map<String, Invoker> getMethods = new HashMap<>();\n  private final Map<String, Class<?>> setTypes = new HashMap<>();\n  private final Map<String, Class<?>> getTypes = new HashMap<>();\n  private Constructor<?> defaultConstructor;\n\n  private Map<String, String> caseInsensitivePropertyMap = new HashMap<>();\n}\n```\n\n![](https://img.springlearn.cn/blog/learn_1648446512000.png)\n\n```java \n    @Test\n    public void reflector() throws Exception {\n        ReflectorFactory reflectorFactory = new DefaultReflectorFactory();\n        Reflector forClass = reflectorFactory.findForClass(TUser.class);\n        TUser user = (TUser) forClass.getDefaultConstructor().newInstance();\n        forClass.getSetInvoker(\"uid\").invoke(user, new Object[]{1});\n        forClass.getSetInvoker(\"name\").invoke(user, new Object[]{\"孙悟空\"});\n        forClass.getSetInvoker(\"tokenId\").invoke(user, new Object[]{\"tokenId\"});\n        // 1\n        System.out.println(forClass.getGetInvoker(\"uid\").invoke(user, new Object[]{}));\n        // 孙悟空\n        System.out.println(forClass.getGetInvoker(\"name\").invoke(user, new Object[]{}));\n    }\n```\n\n### 2.4.5 异常上下文设计 ErrorContext\n\n1. 在代码执行的过程中,将关键信息通过 `ErrorContext.instance().message()` 保存进去。利用到了线程隔离的知识。\n2. `ErrorContext.instance()` 是利用 `ThreadLocal` 进行线程隔离。\n3. 异常打印后,进行 `reset` 重置。\n\n```java \n public int update(String statement, Object parameter) {\n    try {\n      dirty = true;\n      MappedStatement ms = configuration.getMappedStatement(statement);\n      return executor.update(ms, wrapCollection(parameter));\n    } catch (Exception e) {\n      throw wrapException(\"Error updating database.  Cause: \" + e, e);\n    } finally {\n      // 完成之后异常上下文进行重置\n      ErrorContext.instance().reset();\n    }\n  }\n  \n  // 将异常上线文中报错的错误都打印出来。\n  public static RuntimeException wrapException(String message, Exception e) {\n    return new PersistenceException(ErrorContext.instance().message(message).cause(e).toString(), e);\n  }\n```\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/mybatis/配置文件解析.md b/docs/learn/mybatis/配置文件解析.md
--- a/docs/learn/mybatis/配置文件解析.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/mybatis/配置文件解析.md	(date 1655373430425)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/mybatis/核心类介绍.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: true\nfooter: true\nbacktotop: true\ntitle: 第03篇:Mybatis核心类详细介绍\ncategory: Mybatis\n---\n\n:::info 核心类介绍\n前面我们知道Mybatis的解析原理,知道了在 `Configuration` 、`MapperBuilderAssistant` 出现了很多核心的类。\n正是由这些类来实现了,Mybatis的核心功能。所以要想完全搞懂 Mybatis,这些类就必须要进行深入的研究，废话不多少，直接就开始吧。\n:::\n\n其实这里面的每个类要都能单独拆出来一篇进行详细说明，但是这里我们只取其精华，知道他的作用，及如何使用。和能借鉴的地方就可以了。\n\n## 一、Configuration\n\n|属性|解释|\n|:--|:--|\n|TypeAliasRegistry|key是一个别名,value是一个class对象|\n|Properties variables|配置文件中占位符的变量配置|\n|InterceptorChain interceptorChain|拦截链,用于拦截方法,实现插件|\n|ObjectFactory objectFactory|对象实例化统一的工厂方法|\n|ObjectWrapperFactory objectWrapperFactory| 扩展使用，允许用户自定义包装对象ObjectWrapper |\n|ReflectorFactory reflectorFactory|反射工厂,用于生成一个反射信息对象|\n|Environment environment|环境信息包含(事务管理器和数据源)|\n|TypeHandlerRegistry typeHandlerRegistry|数据库返回数据类型转换成Java对象的处理器，或是Java数据类型转换jdbc数据类型的处理器|\n|MapperRegistry mapperRegistry|Mapper生成的处理类,包含代理的逻辑|\n\n## 1.1 TypeAliasRegistry\n\n> key是别名,value是对应的Class<?>\n\n这个在什么时候用的呢? 前面我们通过解析xml，发现很多的dtd约束，文件的值类型都是 CDATA 即 字符串。 但是这些字符串最终是要解析成指定的字节码的。\n怎么知道字符串对应的是哪个java类呢? 那么这个功能就交给 `TypeAliasRegistry`。允许你将一个java类注册一个别名。这样你就可以在配置文件中用别名\n来替换java类了。\n\n```java \n    @Test\n    public void TypeAliasRegistry() {\n        TypeAliasRegistry typeAliasRegistry = new TypeAliasRegistry();\n        System.out.println(typeAliasRegistry.resolveAlias(\"byte\"));\n    }\n```\n\n## 1.2 Properties\n\n这个java类就不用介绍了，在`Configuration` 就是存储的配置信息，允许你在mybatis中任意地方使用${}进行访问数据。\n\n比如你可以这样用? 配置一个全局的limit限制数量\n\n```properties\ndatasource.driver-class-name=com.mysql.cj.jdbc.Driver\ndatasource.url=jdbc:mysql://127.0.0.1:3306/test\ndatasource.username=root\ndatasource.password=123456\ndatasource.globalLimit=1000\n```\n\n```java \npublic interface TUserMapper {\n    @Select(\"select * from t_user where uid = ${id} limit ${datasource.globalLimit} \")\n    List<TUser> selectById(Long id);\n}    \n```\n\n## 1.3 InterceptorChain\n\n内容较多,开单独的篇幅进行介绍; [第07篇:Mybatis的插件设计分析](%E6%8F%92%E4%BB%B6%E5%88%86%E6%9E%90/)\n\n从名字就可以看到是一个拦截链; 主要是实现插件的功能。核心思路是, 通过拦截类的方法来实现插件。\n\nMyBatis 允许你在映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包括：\n\n- Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)\n- ParameterHandler (getParameterObject, setParameters)\n- ResultSetHandler (handleResultSets, handleOutputParameters)\n- StatementHandler (prepare, parameterize, batch, update, query)\n\n```java \npublic class InterceptorChain {\n\n  private final List<Interceptor> interceptors = new ArrayList<>();\n\n  public Object pluginAll(Object target) {\n    for (Interceptor interceptor : interceptors) {\n      target = interceptor.plugin(target);\n    }\n    return target;\n  }\n\n  public void addInterceptor(Interceptor interceptor) {\n    interceptors.add(interceptor);\n  }\n\n  public List<Interceptor> getInterceptors() {\n    return Collections.unmodifiableList(interceptors);\n  }\n\n}\n\npublic interface Interceptor {\n\n  Object intercept(Invocation invocation) throws Throwable;\n\n  default Object plugin(Object target) {\n    return Plugin.wrap(target, this);\n  }\n\n  default void setProperties(Properties properties) {\n    // NOP\n  }\n\n}\n```\n\n## 1.4 ObjectFactory 对象工厂\n\n在Mybatis中或者说是orm框架中, 使用到反射的地方较多。那么就一定会遇到实例化的问题。具体如何实例化。就是使用对象工厂。\n之所以提供个工厂, 小编个人认为还是为了扩展使用。但是实际中一般不会扩展这个类。因为该有的功能默认的就已经具备了。\n\n```java \npublic interface ObjectFactory {\n  \n  // 配置信息\n  default void setProperties(Properties properties) {}\n  // 根据空构造来实例化\n  <T> T create(Class<T> type);\n  // 根据构造参数来实例化\n  <T> T create(Class<T> type, List<Class<?>> constructorArgTypes, List<Object> constructorArgs);\n  // 判断是否是Collection子类\n  <T> boolean isCollection(Class<T> type);\n\n}\n\n```\n\n## 1.5 ObjectWrapperFactory 对象包装工厂\n\n他的作用主要是提供外面的扩展，允许用户自己去创建包装对象。实际框架中不会用到这个对象。我们只要知道他的作用是什么行。 \n我们重点说一下 ObjectWrapper 。\n\nObjectWrapper的主要作用是，提供统一的属性操作方法。主要在MetaObject被使用,如下。\n\n```java \npublic class MetaObject {\n\n  private final Object originalObject;\n  private final ObjectWrapper objectWrapper;\n  private final ObjectFactory objectFactory;\n  private final ObjectWrapperFactory objectWrapperFactory;\n  private final ReflectorFactory reflectorFactory;\n\n  private MetaObject(Object object, ObjectFactory objectFactory, ObjectWrapperFactory objectWrapperFactory, ReflectorFactory reflectorFactory) {\n    this.originalObject = object;\n    this.objectFactory = objectFactory;\n    this.objectWrapperFactory = objectWrapperFactory;\n    this.reflectorFactory = reflectorFactory;\n\n    if (object instanceof ObjectWrapper) {\n      this.objectWrapper = (ObjectWrapper) object;\n    } else if (objectWrapperFactory.hasWrapperFor(object)) {\n      this.objectWrapper = objectWrapperFactory.getWrapperFor(this, object);\n    } else if (object instanceof Map) {\n      this.objectWrapper = new MapWrapper(this, (Map) object);\n    } else if (object instanceof Collection) {\n      this.objectWrapper = new CollectionWrapper(this, (Collection) object);\n    } else {\n      this.objectWrapper = new BeanWrapper(this, object);\n    }\n  }\n}  \n```\n\n\n我们看到普通的对象,被包装成 ObjectWrapper后就可以使用通用的API来获取和修改对象数值型,以及可以获取属性值的类型信息,如下面的例子。\n\n![](https://img.springlearn.cn/blog/learn_1648542576000.png)\n\n```java \n    @Test\n    public void objectWrapper(){\n        // 读取配置信息(为什么路径前不用加/,因为是相对路径。maven编译后的资源文件和class文件都是在一个包下,所以不用加/就是当前包目录)\n        InputStream mapperInputStream = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"mybatisConfig.xml\");\n        // 生成SqlSession工厂,SqlSession从名字上看就是,跟数据库交互的会话信息,负责将sql提交到数据库进行执行\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(mapperInputStream, \"development\");\n        // 获取Mybatis配置信息\n        Configuration configuration = sqlSessionFactory.getConfiguration();\n        Map<String,String> map = new HashMap<>();\n        map.put(\"name\",\"孙悟空\");\n        MetaObject metaObject = MetaObject.forObject(map, configuration.getObjectFactory(), configuration.getObjectWrapperFactory(), configuration.getReflectorFactory());\n        System.out.println(metaObject.getValue(\"name\"));\n        // 复制\n        metaObject.setValue(\"age\",18);\n        // {name=孙悟空, age=18}\n        System.out.println(map);\n\n        TUser tUser = new TUser();\n        tUser.setName(\"唐三藏\");\n        MetaObject tUserMetaObject = MetaObject.forObject(tUser, configuration.getObjectFactory(), configuration.getObjectWrapperFactory(), configuration.getReflectorFactory());\n        // 唐三藏\n        System.out.println(tUserMetaObject.getValue(\"name\"));\n\n        List<TUser> users = new ArrayList<>();\n        users.add(tUser);\n        MetaObject tUserMetaObjects = MetaObject.forObject(users, configuration.getObjectFactory(), configuration.getObjectWrapperFactory(), configuration.getReflectorFactory());\n        tUserMetaObjects.add(new TUser());\n        // [TUser(tokenId=null, uid=null, name=唐三藏), TUser(tokenId=null, uid=null, name=null)]\n        System.out.println(tUserMetaObjects.getOriginalObject());\n    }\n```\n\n## 1.6 ReflectorFactory 反射工厂\n\n从名字看就是反射的工厂，主要是为了生成 Reflector 对象。Reflector 对反射的信息进行了缓存。用的时候直接从缓存中获取。\n\n```java \npublic interface ReflectorFactory {\n\n  boolean isClassCacheEnabled();\n\n  void setClassCacheEnabled(boolean classCacheEnabled);\n\n  Reflector findForClass(Class<?> type);\n}\n```\n\n## 1.7 Environment 环境\n\n这里面的环境属性,是比较重要。因为他直接决定了你要跟那个数据库交互。以及事务如何处理。\n\n```java \npublic final class Environment {\n  private final String id;\n  private final TransactionFactory transactionFactory;\n  private final DataSource dataSource;\n}  \n```\n\n```java \nprivate SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) {\n    Transaction tx = null;\n    try {\n      final Environment environment = configuration.getEnvironment();\n      final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);\n      tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);\n      final Executor executor = configuration.newExecutor(tx, execType);\n      return new DefaultSqlSession(configuration, executor, autoCommit);\n    } catch (Exception e) {\n      closeTransaction(tx); // may have fetched a connection so lets call close()\n      throw ExceptionFactory.wrapException(\"Error opening session.  Cause: \" + e, e);\n    } finally {\n      ErrorContext.instance().reset();\n    }\n  }\n```\n\n## 1.8 TypeHandlerRegistry\n\nTypeHandler + Registry, 从名字来看又是一个类型注册器用于反射使用。看来mybatis中用于反射的工具类是在太多了。那么TypeHandler究竟有什么用呢?\nTypeHandler 是对Statement和ResultSet负责。\nResultSet 是从数据库获取的数据的载体，Statement 是准备向数据库提交数据的载体。TypeHandler 的作用就是\n根据数据类型, 处理跟数据的输入和输出信息。看下面接口。\n\n```java \npublic interface TypeHandler<T> {\n\n  void setParameter(PreparedStatement ps, int i, T parameter, JdbcType jdbcType) throws SQLException;\n\n  /**\n   * Gets the result.\n   *\n   * @param rs\n   *          the rs\n   * @param columnName\n   *          Colunm name, when configuration <code>useColumnLabel</code> is <code>false</code>\n   * @return the result\n   * @throws SQLException\n   *           the SQL exception\n   */\n  T getResult(ResultSet rs, String columnName) throws SQLException;\n\n  T getResult(ResultSet rs, int columnIndex) throws SQLException;\n\n  T getResult(CallableStatement cs, int columnIndex) throws SQLException;\n\n}\n```\n\n这里举一个例子，比如name这个字段在数据库是varchar类型,但是java对象中name是一个Name对象。那么如何处理呢?\n我们自定义一个处理器。\n```java \npublic class NameTypeHandler implements TypeHandler<Name> {\n\n    @Override\n    public void setParameter(PreparedStatement ps, int i, Name parameter, JdbcType jdbcType) throws SQLException {\n        ps.setString(i, parameter.getFirstName() + \"-\" + parameter.getSurname());\n    }\n\n    @Override\n    public Name getResult(ResultSet rs, String columnName) throws SQLException {\n        String name = rs.getString(columnName);\n        String[] split = name.split(\"-\");\n        return new Name(split[0], split[1]);\n    }\n}    \n```\n\n然后在配置文件中声明注册器,用于将java对象转换成jdbc数据库字段类型。同时也将数据库查询到的jdbc类型转换成java对象。\n\n```xml \n    <configuration>\n        <typeHandlers>\n            <typeHandler handler=\"orm.example.dal.type.NameTypeHandler\" javaType=\"orm.example.dal.model.Name\"></typeHandler>\n        </typeHandlers>\n    </configuration>    \n    <mapper>\n         <insert id=\"insert\" parameterType=\"orm.example.dal.model.T2User\">\n            <!--\n              WARNING - @mbggenerated\n              This element is automatically generated by MyBatis Generator, do not modify.\n              This element was generated on Sun Mar 27 23:01:23 CST 2022.\n            -->\n            insert into T_USER (token_id, uid, name)\n            values (#{tokenId,jdbcType=CHAR}, #{uid,jdbcType=INTEGER}, #{name,javaType=orm.example.dal.model.Name })\n        </insert>\n    </mapper>\n```\n\n我们执行下面代码,可以看到我们将数据类型转换成了jdbc存到了数据库，同时执行查询时候又将jdbc类型转换成了java对象。这就是它的作用。\n\n```java {19}\n    @Test\n    public void test() {\n        // 读取配置信息(为什么路径前不用加/,因为是相对路径。maven编译后的资源文件和class文件都是在一个包下,所以不用加/就是当前包目录)\n        InputStream mapperInputStream = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"mybatisConfig.xml\");\n        // 生成SqlSession工厂,SqlSession从名字上看就是,跟数据库交互的会话信息,负责将sql提交到数据库进行执行\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(mapperInputStream, \"development\");\n        // 获取Mybatis配置信息\n        Configuration configuration = sqlSessionFactory.getConfiguration();\n        configuration.getTypeHandlerRegistry().register(new NameTypeHandler());\n        // 参数: autoCommit,从名字上看就是是否自动提交事务\n        SqlSession sqlSession = sqlSessionFactory.openSession(false);\n        // 获取Mapper\n        T2UserMapper mapper = configuration.getMapperRegistry().getMapper(T2UserMapper.class, sqlSession);\n        T2User tUser = new T2User();\n        Name name = new Name(\"孙\",\"悟空\");\n        tUser.setName(name);\n        tUser.setTokenId(\"西天取经\");\n        mapper.insert(tUser);\n        // 获取插入的数据: T2User(tokenId=西天取经, uid=32, name=Name(surname=悟空, firstName=孙))\n        System.out.println(mapper.selectByPrimaryKey(\"西天取经\"));\n        // 数据插入后，执行查询，然后回滚数据\n        sqlSession.rollback();\n    }\n```\n\n## 1.9 MapperRegistry\n\n看到Registry又知道了，这货又是一个类似Map的工具类。肯定是跟Mapper有关系。下面代码关键在于13和17行。\nMybatis中获取Mapper对象都是从 MapperRegistry中获取的。\n\n- line(13) `new MapperProxyFactory<>(type)` 接口生成代理对象\n- line(17) `MapperAnnotationBuilder` 用于解析Mybatis支持的注解,并添加到 `Configuration`\n\n这两个类比较重要我们开单独的篇幅进行说明。\n\n```java {13,17}\npublic class MapperRegistry {\n\n  private final Configuration config;\n  private final Map<Class<?>, MapperProxyFactory<?>> knownMappers = new HashMap<>();\n  \n  public <T> void addMapper(Class<T> type) {\n    if (type.isInterface()) {\n      if (hasMapper(type)) {\n        throw new BindingException(\"Type \" + type + \" is already known to the MapperRegistry.\");\n      }\n      boolean loadCompleted = false;\n      try {\n        knownMappers.put(type, new MapperProxyFactory<>(type));\n        // It's important that the type is added before the parser is run\n        // otherwise the binding may automatically be attempted by the\n        // mapper parser. If the type is already known, it won't try.\n        MapperAnnotationBuilder parser = new MapperAnnotationBuilder(config, type);\n        parser.parse();\n        loadCompleted = true;\n      } finally {\n        if (!loadCompleted) {\n          knownMappers.remove(type);\n        }\n      }\n    }\n  }\n}\n```\n\n## 1.10 SqlSession\n\nSqlSession相当于一千个桥梁,负责将方法参数,发送给数据库,并且将数据库返回值组装成方法的返回值。\n\n在SqlSession中有几个比较重要的类，如下图。他们负责不同的逻辑。\n分别处理入参(ParameterHandler)，处理出参(ResultSetHandler)，生成Jdbc(StatementHandler)，处理缓存相关(Executor)。\n是一个非常重要的一个类。后面我们的学习中会经常看到。\n\n![](https://img.springlearn.cn/blog/learn_1649170321000.png)\n\n\n```java \npublic interface SqlSession extends Closeable {\n\n  <T> T selectOne(String statement);\n\n  <T> T selectOne(String statement, Object parameter);\n\n  int insert(String statement);\n\n  int insert(String statement, Object parameter);\n\n  int update(String statement);\n\n  int update(String statement, Object parameter);\n\n  int delete(String statement);\n\n  int delete(String statement, Object parameter);\n\n  void commit();\n\n  void commit(boolean force);\n\n  void rollback();\n\n  void rollback(boolean force);\n\n  List<BatchResult> flushStatements();\n\n  @Override\n  void close();\n\n  void clearCache();\n\n  Configuration getConfiguration();\n\n  <T> T getMapper(Class<T> type);\n\n  Connection getConnection();\n}\n```\n\n我们看增删改查的方法入参无非2个。1个是statement,1个是入参。\n其中statement主要是为了获取 MappedStatement。如下\n\n```java \nprivate <E> List<E> selectList(String statement, Object parameter, RowBounds rowBounds, ResultHandler handler) {\n    try {\n      MappedStatement ms = configuration.getMappedStatement(statement);\n      return executor.query(ms, wrapCollection(parameter), rowBounds, handler);\n    } catch (Exception e) {\n      throw ExceptionFactory.wrapException(\"Error querying database.  Cause: \" + e, e);\n    } finally {\n      ErrorContext.instance().reset();\n    }\n  }\n```\n\n另外一个入参是为了组装sql信息。MappedStatement#getBoundSql 获取sql信息。\n\n\n```java \n  @Override\n  public <E> List<E> query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException {\n    BoundSql boundSql = ms.getBoundSql(parameter);\n    CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql);\n    return query(ms, parameter, rowBounds, resultHandler, key, boundSql);\n  }\n```\n\n## 二、MapperBuilderAssistant\n\n|属性|解释|\n|:--|:--|\n|MapperBuilderAssistant|Mapper构建辅助工具类(缓存配置)|\n|CacheRefResolver|决定如何使用缓存|\n|ParameterMapping|参数映射类|\n|ResultMapResolver|返回值映射|\n|Map<String, XNode> sqlFragments|sql片段|\n|MappedStatement|Mapper方法的所有信息(出参，入参)|\n\n## 2.1 MapperBuilderAssistant\n\nMapper构建工具类,下面小编列举了几个方法。可以看出来基本都是用于处理sql结果集向java对象转换使用，和对Mapper方法签名分析生成sql的工具。\n下面我们一个一个来看看。\n\n```java\npublic class MapperBuilderAssistant extends BaseBuilder {\n    // 确定使用那个缓存\n    public Cache useCacheRef(String namespace);\n    // 生成2级缓存对象\n    public Cache useNewCache(...);\n    // 每个参数的信息\n    public ParameterMapping buildParameterMapping();\n    // 生成结构集\n    public ResultMap addResultMap();\n    // 鉴别器\n    public Discriminator buildDiscriminator();\n    // 生成Mapper签名\n    public MappedStatement addMappedStatement();\n    // 获取方言处理器\n    public LanguageDriver getLanguageDriver(Class<? extends LanguageDriver> langClass);\n}\n```\n\n### 2.1.1 Cache\n\nMybatis 缓存的接口定义,用于缓存查询sql的结果。Mybatis中一级缓存和二级缓存是一个面试经常会考的问题。这个类我们也单独开一篇私聊。\n\n### 2.1.2 ParameterMapping & ResultMapping\n\n从名字中能看到就是对Mapper中方法的入参和出参的映射关系类。\n\n```java \npublic class ParameterMapping {\n  private Configuration configuration;\n  private String property;\n  private ParameterMode mode;\n  private Class<?> javaType = Object.class;\n  private JdbcType jdbcType;\n  private Integer numericScale;\n  private TypeHandler<?> typeHandler;\n  private String resultMapId;\n  private String jdbcTypeName;\n  private String expression;\n}  \n```\n如图所示,会对方法的每个参数,生成一个 ParameterMapping对象。存储了java类型和db的类型的映射关系。\n![](https://img.springlearn.cn/blog/learn_1648656572000.png)\n\n### 2.1.3 ResultMap\n\n从名字看就是对jdbc结果集向Mapper返回值的映射关系，用于将jdbc数据重新映射成Java对象。\n\n```java \n    @Test\n    public void resultSet(){\n        // 读取配置信息(为什么路径前不用加/,因为是相对路径。maven编译后的资源文件和class文件都是在一个包下,所以不用加/就是当前包目录)\n        InputStream mapperInputStream = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"mybatisConfig.xml\");\n        // 生成SqlSession工厂,SqlSession从名字上看就是,跟数据库交互的会话信息,负责将sql提交到数据库进行执行\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(mapperInputStream, \"development\");\n        // 获取Mybatis配置信息\n        Configuration configuration = sqlSessionFactory.getConfiguration();\n        SqlSession sqlSession = sqlSessionFactory.openSession(false);\n        TUserMapper mapper = configuration.getMapper(TUserMapper.class,sqlSession);\n        System.out.println(mapper.selectAll());\n        MappedStatement mappedStatement = configuration.getMappedStatement(\"orm.example.dal.mapper.TUserMapper.selectAll\");\n        List<ResultMap> resultMaps = mappedStatement.getResultMaps();\n        System.out.println(resultMaps);\n    }\n```\n\n![](https://img.springlearn.cn/blog/learn_1648657325000.png)\n\n\n### 2.1.4 LanguageDriver\n\n主要用于生成 SqlSource，动态sql(XMLLanguageDriver)或者静态sql(RawLanguageDriver)\n\n```java \n\npublic interface LanguageDriver {\n \n  ParameterHandler createParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql);\n\n  SqlSource createSqlSource(Configuration configuration, XNode script, Class<?> parameterType);\n \n  SqlSource createSqlSource(Configuration configuration, String script, Class<?> parameterType);\n\n}\n```\n\n动态sql可以处理下面这些标签\n\n```java \n private void initNodeHandlerMap() {\n    nodeHandlerMap.put(\"trim\", new TrimHandler());\n    nodeHandlerMap.put(\"where\", new WhereHandler());\n    nodeHandlerMap.put(\"set\", new SetHandler());\n    nodeHandlerMap.put(\"foreach\", new ForEachHandler());\n    nodeHandlerMap.put(\"if\", new IfHandler());\n    nodeHandlerMap.put(\"choose\", new ChooseHandler());\n    nodeHandlerMap.put(\"when\", new IfHandler());\n    nodeHandlerMap.put(\"otherwise\", new OtherwiseHandler());\n    nodeHandlerMap.put(\"bind\", new BindHandler());\n  }\n```\n\n## 2.2 CacheRefResolver\n\n确定每个Mapper配置的缓存\n\n```java \npublic class CacheRefResolver {\n  private final MapperBuilderAssistant assistant;\n  private final String cacheRefNamespace;\n\n  public CacheRefResolver(MapperBuilderAssistant assistant, String cacheRefNamespace) {\n    this.assistant = assistant;\n    this.cacheRefNamespace = cacheRefNamespace;\n  }\n\n  public Cache resolveCacheRef() {\n    return assistant.useCacheRef(cacheRefNamespace);\n  }\n}\n```\n## 2.3 MappedStatement\n\n可以说关于Mapper所有的信息都在这个类里面,包括sql信息、入参及返回值类型、sql类型（SqlCommandType）、是否使用缓存、\n是否刷新缓存、StatementType类型。\n\n```java \npublic final class MappedStatement {\n  // mapper/TUserMapper.xml\n  private String resource;\n  // 全局配置\n  private Configuration configuration;\n  // orm.example.dal.mapper.TUserMapper.insert\n  private String id;\n  // \n  private Integer fetchSize;\n  // 超时时间\n  private Integer timeout;\n  // StatementType.PREPARED\n  private StatementType statementType;\n  // ResultSetType.DEFAULT(-1),\n  private ResultSetType resultSetType;\n  // RawSqlSource\n  private SqlSource sqlSource;\n  private Cache cache;\n  private ParameterMap parameterMap;\n  private List<ResultMap> resultMaps;\n  private boolean flushCacheRequired;\n  private boolean useCache;\n  private boolean resultOrdered;\n  // SqlCommandType（ UNKNOWN, INSERT, UPDATE, DELETE, SELECT, FLUSH）\n  private SqlCommandType sqlCommandType;\n  // 生成id\n  private KeyGenerator keyGenerator;\n  private String[] keyProperties;\n  private String[] keyColumns;\n  private boolean hasNestedResultMaps;\n  private String databaseId;\n  private Log statementLog;\n  private LanguageDriver lang;\n  private String[] resultSets;\n}  \n```\n\n生成主要有2种方法。\n\n1. xml的方式 XMLStatementBuilder\n2. 通过注解的方式 MapperAnnotationBuilder\n\n```java \npublic class XMLMapperBuilder extends BaseBuilder \n    public void parse() {\n        // 如果有资源文件先解析xml,并保存到Configuration#addMappedStatement\n        if (!configuration.isResourceLoaded(resource)) {\n          // XMLStatementBuilder进行解析\n          configurationElement(parser.evalNode(\"/mapper\"));\n          configuration.addLoadedResource(resource);\n          // 同时使用MapperAnnotationBuilder类解析\n          bindMapperForNamespace();\n        }\n    \n        parsePendingResultMaps();\n        parsePendingCacheRefs();\n        parsePendingStatements();\n      }\n}  \n\npublic class MapperAnnotationBuilder{\n      // 只有包含了下面注解的方法才会被解析\n      private static final Set<Class<? extends Annotation>> statementAnnotationTypes = Stream\n      .of(Select.class, Update.class, Insert.class, Delete.class, SelectProvider.class, UpdateProvider.class,\n          InsertProvider.class, DeleteProvider.class)\n      .collect(Collectors.toSet());\n      \n     public  void parseStatement(Method method) {\n        final Class<?> parameterTypeClass = getParameterType(method);\n        final LanguageDriver languageDriver = getLanguageDriver(method);\n        // 判断是否包含了上面的注解\n        getAnnotationWrapper(method, true, statementAnnotationTypes)\n        .ifPresent(statementAnnotation -> {})\n     }   \n}    \n```\n\nMapper配置文件在解析的时候首先,回去解析xml,然后解析注解。如果两种方式都存在那么就会提示错误。\n\n\n:::danger\nCaused by: java.lang.IllegalArgumentException: Mapped Statements collection already contains value for orm.example.dal.mapper.TUserMapper.selectAll. please check mapper/TUserMapper.xml and orm/example/dal/mapper/TUserMapper.java (best guess)\nat org.apache.ibatis.session.Configuration$StrictMap.put(Configuration.java:1014)\nat org.apache.ibatis.session.Configuration$StrictMap.put(Configuration.java:970)\n:::\n\n\n原因就在 StrictMap。\n\n```java \npublic V put(String key, V value) {\n      if (containsKey(key)) {\n        throw new IllegalArgumentException(name + \" already contains value for \" + key\n            + (conflictMessageProducer == null ? \"\" : conflictMessageProducer.apply(super.get(key), value)));\n      }\n      if (key.contains(\".\")) {\n        final String shortKey = getShortName(key);\n        if (super.get(shortKey) == null) {\n          super.put(shortKey, value);\n        } else {\n          super.put(shortKey, (V) new Ambiguity(shortKey));\n        }\n      }\n      return super.put(key, value);\n}\n```\n\n## 三、可以借鉴的知识点\n\n## 3.1 包装器模式\n\nObjectWrapper\n\nObjectWrapper的主要作用是，提供统一的属性操作方法。主要在MetaObject被使用,如下。\n\n```java \n     @Test\n    public void objectWrapper() {\n        TUser mock = JMockData.mock(TUser.class);\n        MetaObject metaObject = MetaObject.forObject(mock, new DefaultObjectFactory(), new DefaultObjectWrapperFactory(), new DefaultReflectorFactory());\n        boolean name = metaObject.hasGetter(\"name\");\n        if (name) {\n            // iuslA4Xp\n            System.out.println(metaObject.getValue(\"name\"));\n        }\n\n        Map<String,Object> map = new HashMap<>();\n        map.put(\"age\",18);\n        MetaObject metaMap = MetaObject.forObject(map, new DefaultObjectFactory(), new DefaultObjectWrapperFactory(), new DefaultReflectorFactory());\n        boolean age = metaMap.hasGetter(\"age\");\n        if (age) {\n            // 18 \n            System.out.println(metaMap.getValue(\"age\"));\n        }\n    }\n```\n\n## 3.2 MetaClass\n\n反射工具类\n\n```java \n    @Test\n    public void metaClass()throws Exception{\n        MetaClass metaClass = MetaClass.forClass(TUser.class, new DefaultReflectorFactory());\n        TUser blankUser = new TUser();\n        metaClass.getSetInvoker(\"name\").invoke(blankUser,new Object[]{\"孙悟空\"});\n        // 孙悟空\n        System.out.println(blankUser.getName());\n    }\n```\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/mybatis/核心类介绍.md b/docs/learn/mybatis/核心类介绍.md
--- a/docs/learn/mybatis/核心类介绍.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/mybatis/核心类介绍.md	(date 1655373430085)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/tools/jmh/README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: auto\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\nsidebarDepth: 3\ntitle: JMH基准测试\npassword: 123\nicon: zuanshi\n---\n\n[参考链接](https://www.zhihu.com/question/276455629/answer/1259967560)\n\n[官方文档](http://openjdk.java.net/projects/code-tools/jmh/)\n\n[性能调优必备利器之 JMH](https://www.bbsmax.com/A/qVdeEr01dP/)\n\n## 一、JMH\n\nJMH即Java Microbenchmark Harness，是Java用来做基准测试的一个工具，该工具由OpenJDK提供并维护，测试结果可信度高。\n\n基准测试Benchmark是测量、评估软件性能指标的一种测试，对某个特定目标场景的某项性能指标进行定量的和可对比的测试。\n\n## 1.1 为什么要用JMH\n\nif 快还是 switch 快？HashMap 的初始化 size 要不要指定，指定之后性能可以提高多少？各种序列化方法哪个耗时更短？\n\n无论出自何种原因需要进行性能评估，量化指标总是必要的。\n\n在大部分场合，简单地回答谁快谁慢是远远不够的，如何将程序`性能量化`呢？\n\n这就需要我们的主角 JMH 登场了！\n\n## 二、前期准备\n\n## 2.1 引入依赖\n```xml \n<dependencies>\n    <dependency>\n        <groupId>org.openjdk.jmh</groupId>\n        <artifactId>jmh-core</artifactId>\n        <version>1.23</version>\n    </dependency>\n \n    <dependency>\n        <groupId>org.openjdk.jmh</groupId>\n        <artifactId>jmh-generator-annprocess</artifactId>\n        <version>1.23</version>\n    </dependency>\n</dependencies>\n```\n\n## 2.2 安装插件\n\n[jmh-java-microbenchmark-harness](https://plugins.jetbrains.com/plugin/7529-jmh-java-microbenchmark-harness)\n\n![](https://img.springlearn.cn/blog/learn_1653405994000.png)\n\n当安装插件后,只要被`@Benchmark`就会认为是一个test方法,出现执行按钮\n![](https://img.springlearn.cn/blog/learn_1653405953000.png)\n\n当然也可以不安装插件,如下代码也会进行输出\n\n```java \n    public static void main(String[] args) throws Exception {\n        Options opt = new OptionsBuilder()\n                .include(BenchmarkTest.class.getSimpleName())\n                .resultFormat(ResultFormatType.JSON)\n                .build();\n        new Runner(opt).run();\n    }\n```\n\n## 三、使用说明\n\n在正式使用前,先介绍下JMH基准测试中可以使用的注解。\n\n![](https://img.springlearn.cn/blog/learn_1653716179000.png)\n\n## 3.1 @BenchmarkMode\n\n用来配置 Mode 选项，可用于类或者方法上，这个注解的 value 是一个数组，可以把几种 Mode 集合在一起执行，如：@BenchmarkMode({Mode.SampleTime, Mode.AverageTime})，还可以设置为 Mode.All，即全部执行一遍。\n\n1. Throughput：整体吞吐量，每秒执行了多少次调用，单位为 ops/time\n2. AverageTime：用的平均时间，每次操作的平均时间，单位为 time/op\n3. SampleTime：随机取样，最后输出取样结果的分布\n4. SingleShotTime：只运行一次，往往同时把 Warmup 次数设为 0，用于测试冷启动时的性能\n5. All：上面的所有模式都执行一次\n\n\n## 3.2 @State\n\n通过 State 可以指定一个对象的作用范围，JMH 根据 scope 来进行实例化和共享操作。@State 可以被继承使用，如果父类定义了该注解，子类则无需定义。由于 JMH 允许多线程同时执行测试，不同的选项含义如下\n\n1. Scope.Benchmark：所有测试线程共享一个实例，测试有状态实例在多线程共享下的性能\n2. Scope.Group：同一个线程在同一个 group 里共享实例\n3. Scope.Thread：默认的 State，每个测试线程分配一个实例\n\n## 3.3 @OutputTimeUnit\n\n为统计结果的时间单位，可用于类或者方法注解\n\n\n## 3.4 @Warmup\n预热所需要配置的一些基本测试参数，可用于类或者方法上。一般前几次进行程序测试的时候都会比较慢，所以要让程序进行几轮预热，保证测试的准确性。参数如下所示：\n\n1. iterations：预热的次数\n2. time：每次预热的时间\n3. timeUnit：时间的单位，默认秒\n4. batchSize：批处理大小，每次操作调用几次方法\n\n为什么需要预热？\n>因为 JVM 的 JIT 机制的存在，如果某个函数被调用多次之后，JVM 会尝试将其编译为机器码，从而提高执行速度，所以为了让 benchmark 的结果更加接近真实情况就需要进行预热。\n\n## 3.5 @Measurement\n\n实际调用方法所需要配置的一些基本测试参数，可用于类或者方法上，参数和 @Warmup 相同。\n\n1. iterations：执行的次数\n2. time：每次执行时间\n3. timeUnit：时间的单位，默认秒\n4. batchSize：批处理大小，每次操作调用几次方法\n\n## 3.6 @Threads\n\n配置同时起多少个线程执行，默认值世 Runtime.getRuntime().availableProcessors()\n\n## 3.7 @Fork\n\n进行 fork 的次数，可用于类或者方法上。如果 fork 数是 2 的话，则 JMH 会 fork 出两个进程来进行测试。\n\n## 3.8 @Param\n\n指定某项参数的多种情况，特别适合用来测试一个函数在不同的参数输入的情况下的性能，只能作用在字段上，使用该注解必须定义 @State 注解。\n\n## 四、场景案例\n\n- [可视化分析平台](https://jmh.morethan.io/)\n- [JMH Visual Chart](http://deepoove.com/jmh-visual-chart/)\n\n## 4.1 for循环性能\n\n循环100w次,并输出。预热2次,执行2次,2个线程,1个进程,统计结果单位毫秒。\n\n![](https://img.springlearn.cn/blog/learn_1653717279000.png)\n\n|方法|平均耗时|\n|:--:|:--:|\n|普通for循环|7898ms|\n|增强for循环|8078ms|\n|迭代器|8314ms|\n|Stream循环|9085ms|\n\n```java \n\nimport org.openjdk.jmh.annotations.*;\nimport org.openjdk.jmh.results.format.ResultFormatType;\nimport org.openjdk.jmh.runner.Runner;\nimport org.openjdk.jmh.runner.options.Options;\nimport org.openjdk.jmh.runner.options.OptionsBuilder;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\n\n@BenchmarkMode(Mode.AverageTime)\n@OutputTimeUnit(TimeUnit.MILLISECONDS)\n@Warmup(iterations = 2)\n@Measurement(iterations = 2)\n@Threads(2)\n@Fork(1)\n@State(Scope.Thread)\npublic class ForBenchmarkTest {\n\n    private static List<Integer> integers;\n\n    static {\n        integers = generate(1000000);\n    }\n\n    private static List<Integer> generate(Integer max) {2\n        List<Integer> result = new ArrayList<>(max);\n        for (int i = 0; i < max; i++) {\n            result.add(i);\n        }\n        return result;\n    }\n\n    @Benchmark\n    public void forTest() {\n        for (int i = 0; i < integers.size(); i++) {\n            System.out.println(integers.get(i));\n        }\n    }\n\n    @Benchmark\n    public void forEachTest() {\n        for (Integer integer : integers) {\n            System.out.println(integer);\n        }\n    }\n\n    @Benchmark\n    public void iteratorTest() {\n        Iterator<Integer> iterator = integers.iterator();\n        while (iterator.hasNext()) {\n            System.out.println(iterator.next());\n        }\n    }\n\n    @Benchmark\n    public void streamForEachTest() {\n        integers.forEach(System.out::println);\n    }\n\n    public static void main(String[] args) throws Exception {\n        Options opt = new OptionsBuilder()\n                .include(ForBenchmarkTest.class.getSimpleName())\n                .resultFormat(ResultFormatType.JSON)\n                .build();\n        new Runner(opt).run();\n    }\n}\n\n```\n\n\n## 4.2 反射性能\n\n![](https://img.springlearn.cn/blog/learn_1653719819000.png)\n\n通过上面数据可以得到。反射缺失很耗时。开启安全检查比不开启耗时, 如果反射在加上缓存,会比较好一点。\n\n- metaClass1k 是1k次操作，反射+缓存\n- metaClass1w 是1w次操作，反射+缓存\n- test1k 是1k次正常操作\n- test1w 是1w次正常操作\n- testReflection1k 是1k次操作，反射\n- testReflection1w 是1w次操作，反射\n- testReflectionAccessible1k 是1k次操作，反射，关闭安全检查\n- testReflectionAccessible1k 是1w次操作，反射，关闭安全检查\n\n```java \n@BenchmarkMode(Mode.AverageTime)\n@OutputTimeUnit(TimeUnit.SECONDS)\n@Warmup(iterations = 5, time = 1)\n@Measurement(iterations = 10, time = 1)\n@Threads(2)\n@Fork(1)\n@State(Scope.Thread)\npublic class ReflectionBenchmarkTest {\n\n    private static class Mode {\n        private Integer age;\n\n        public void setAge(Integer age) {\n            this.age = age;\n        }\n    }\n\n    @Benchmark\n    public void test1k() {\n        Mode mode = new Mode();\n        Loops.loop(1000, mode::setAge);\n    }\n\n    @Benchmark\n    public void testReflection1k() {\n        Mode mode = new Mode();\n        Loops.loop(1000, i -> {\n            Method setAge = null;\n            try {\n                setAge = mode.getClass().getMethod(\"setAge\", Integer.class);\n                setAge.invoke(mode, i);\n            } catch (Throwable e) {\n                throw new RuntimeException(e);\n            }\n        });\n    }\n\n    @Benchmark\n    public void testReflectionAccessible1k() {\n        Mode mode = new Mode();\n        Loops.loop(1000, i -> {\n            Method setAge = null;\n            try {\n                setAge = mode.getClass().getMethod(\"setAge\", Integer.class);\n                setAge.setAccessible(true);\n                setAge.invoke(mode, i);\n            } catch (Throwable e) {\n                throw new RuntimeException(e);\n            }\n        });\n    }\n\n    @Benchmark\n    public void test1w() {\n        Mode mode = new Mode();\n        Loops.loop(10000, mode::setAge);\n    }\n\n    @Benchmark\n    public void testReflection1w() {\n        Mode mode = new Mode();\n        Loops.loop(10000, i -> {\n            Method setAge = null;\n            try {\n                setAge = mode.getClass().getMethod(\"setAge\", Integer.class);\n                setAge.invoke(mode, i);\n            } catch (Throwable e) {\n                throw new RuntimeException(e);\n            }\n        });\n    }\n\n    @Benchmark\n    public void testReflectionAccessible1w() {\n        Mode mode = new Mode();\n        Loops.loop(10000, i -> {\n            Method setAge = null;\n            try {\n                setAge = mode.getClass().getMethod(\"setAge\", Integer.class);\n                setAge.setAccessible(true);\n                setAge.invoke(mode, i);\n            } catch (Throwable e) {\n                throw new RuntimeException(e);\n            }\n        });\n    }\n\n    @Benchmark\n    public void metaClass1k() {\n        MetaClass metaClass = MetaClass.forClass(Mode.class, new DefaultReflectorFactory());\n        Mode mode = new Mode();\n        Loops.loop(10000, i -> {\n            try {\n                Invoker setAge = metaClass.getSetInvoker(\"age\");\n                setAge.invoke(mode, new Object[]{i});\n            } catch (Throwable e) {\n                throw new RuntimeException(e);\n            }\n        });\n    }\n\n    @Benchmark\n    public void metaClass1w() {\n        MetaClass metaClass = MetaClass.forClass(Mode.class, new DefaultReflectorFactory());\n        Mode mode = new Mode();\n        Loops.loop(10000, i -> {\n            try {\n                Invoker setAge = metaClass.getSetInvoker(\"age\");\n                setAge.invoke(mode, new Object[]{i});\n            } catch (Throwable e) {\n                throw new RuntimeException(e);\n            }\n        });\n    }\n\n\n    public static void main(String[] args) throws Exception {\n        Options opt = new OptionsBuilder()\n                .include(ReflectionBenchmarkTest.class.getSimpleName())\n                .resultFormat(ResultFormatType.JSON)\n                .build();\n        new Runner(opt).run();\n    }\n}\n\n```\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/tools/jmh/README.md b/docs/learn/tools/jmh/README.md
--- a/docs/learn/tools/jmh/README.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/tools/jmh/README.md	(date 1655373430513)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: auto
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/distributed/README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 分布式服务\ncategory: 分布式\n---\n\n<Djt/>\n\n**本系列文章不讲具体的微服务框架, 只`研究其中的实现思路`。会从 `Spring cloud` 和 `double` 等框架中举例。\n从而来了解微服务架构的设计思路。**\n\n\n\n### 什么是微服务？\n\n微服务是一种现代的软件方法，应用程序代码以小的、可管理的部分交付，独立于其他部分。\n\n### 为什么要构建微服务？\n\n它们的小规模和相对隔离可以带来许多额外的好处，例如更容易维护、提高生产力、更大的容错性、更好的业务一致性等等。\n\n![](https://spring.io/images/diagram-microservices-88e01c7d34c688cb49556435c130d352.svg)\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/distributed/README.md b/docs/learn/distributed/README.md
--- a/docs/learn/distributed/README.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/distributed/README.md	(date 1655373430371)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/distributed/分布式注册中心.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 第01篇:分布式注册中心\ncategory: 分布式\n---\n\n![](https://img.springlearn.cn/blog/learn_1652941175000.png)\n\n## 一、什么是注册中心\n\n![](https://img.springlearn.cn/blog/learn_1652941012000.png)\n\n\n什么是`注册中心`，`注册中心` 往往是在分布式的应用体系下才会遇到的。对于分布式体系应用都是横向进行扩展。如下图`User App`这个服务，具有2台服务器\n但是当用户从网关进来访问, 网关是如何知道这个 `User App`有几台服务及每台服务的网络地址是什么呢? 所以就需要有一个地方能收集到每台应用的地址及命名。\n往往这个地方就被叫做 `注册中心`。分布式环境下的应用在启动时候都会向这个地方来注册自己的网络地址，及命名。\n\n## 二、注册中心的职责\n\n![](https://img.springlearn.cn/blog/learn_1652941926000.png)\n\n`但是注册中心只能注册服务吗?` 当然不是,如果仅仅只做这个事情，那么岂不是浪费了自己的资源呢? 注册中心要做到 \n\n![](https://img.springlearn.cn/blog/learn_1652942499000.png)\n\n好了，我们看下再分布式的环境下，注册中心的位置有多`重要`了，如果没有了注册中心，网络上的服务都是`瞎子`了。所以这个系统\n的设计我们要重新考虑到他的`可用性`，以及就算注册中心挂了，各服务之间不要里面就瞎。最起码要留给注册中心一个`重启的时间`。\n\n\n好了，知道这么多，我们直接开始设计吧。\n\n## 三、设计注册中心\n\n## 3.1 ip地址获取\n\n这里要注意的点是不要拿到了127.0.0.1这个本地回环地址。类似工具网络很多,这不是重点。看下就行。\n\n```java \npublic class HostUtils {\n    private static String ip;\n    private static String hostName;\n    private static void resolveHost() throws Exception {\n        InetAddress localHost = InetAddress.getLocalHost();\n        hostName = localHost.getHostName();\n        ip = localHost.getHostAddress();\n        if (localHost.isLoopbackAddress()) {\n            Enumeration<NetworkInterface> networkInterfaces = NetworkInterface.getNetworkInterfaces();\n            while (networkInterfaces.hasMoreElements()) {\n                NetworkInterface networkInterface = networkInterfaces.nextElement();\n                Enumeration<InetAddress> inetAddresses = networkInterface.getInetAddresses();\n                while (inetAddresses.hasMoreElements()) {\n                    InetAddress inetAddress = inetAddresses.nextElement();\n                    if (!inetAddress.isLoopbackAddress() && (inetAddress instanceof Inet4Address)) {\n                        ip = inetAddress.getHostAddress();\n                    }\n                }\n            }\n        }\n    }\n    public static String getIp() {\n        return ip;\n    }\n    public static String getHostName() {\n        return hostName;\n    }\n    static {\n        try {\n            resolveHost();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n## 3.2 通信协议 & 技术选型\n\n通信协议一般为了兼容多语言环境, 最好使用的http协议。因为应用比较广泛。当然你也可以自定义协议。这里推荐一个\n小编基于Netty封装的通信框架 [mojito](https://mojito.springlearn.cn/) 这里我们主要考虑通用性,使用\nhttp协议。因为现在微服务使用 ==Spring Cloud== 的较多，所以我们的注册中心的框架选型使用 ==Spring Boot==\n\n这里我们可以使用SpringBoot的[Endpoint](/learn/spring/Endpoint监控端点扩展/) 实现自己的扩展点，同时也可以使用服务自带的健康检查能力,进行状态监控。\n\n下面描述下实现思路\n\n\n## 3.3 交互流程\n\n### 3.3.1 服务端能力\n\n- 提供服务注册接口\n  - 数据可以落到数据库, 同时记录内存缓存，服务量大可以考虑使用redis\n  - 同时要落到文件中, 避免数据库挂了能从文件中恢复到缓存中\n- 提供服务下线接口\n  - 当服务下线，主动调用注册中心下线接口，注册中心要提供被动接受下线能力\n  - 当轮训到服务状态不好,主动将服务标记为下线，当服务状态恢复重新标记为正常\n- 提供服务健康检查能力\n  - 轮训已注册的机器的健康检查接口，动态更新节点状态\n  - 启动定时任务,定时发送状态检查,检查客户端服务状态\n- 提供服务发现接口\n  - 通过传递服务名，返回服务名对应的服务列表\n- 提供应用配置能力\n  - 做到服务隔离,不要把某个服务的配置,推送到全部服务器,只需要推动到这个服务对应的节点即可\n  - 能主动发起配置变更消息\n\n### 3.3.2 客户端能力\n\n- 服务注册能力\n  - 实现 `ApplicationContextInitializer` 应用启动时候读取应用配置,然后将自己注册到注册中心\n  - 将注册中心的配置,同时拉下来,放到Spring配置环境\n- 服务重新或者宕机主动下线\n  - 利用`@PreDestroy`销毁方法,或者注册[Jvm Hooks](/learn/java/hooks%E5%87%BD%E6%95%B0/)程序\n- 服务发现能力\n  - 根据服务名获取服务列表接口，同时缓存到本地一份\n  - 如果注册中心无响应，要能使用本地缓存, 给注册中心留一个重启的时间\n- 监听服务器配置信息\n  - 将监听到的配置变更刷新到Spring容器 [动态绑定配置方案参考](/learn/spring/Spring动态绑定配置/)\n- 打开健康检查\n\n## 四、常见的注册中心\n\n[注册中心对比](https://blog.csdn.net/sanmi8276/article/details/113513488)\n\n## 4.1 Zookeeper\n\n[什么是ZooKeeper？](https://zhuanlan.zhihu.com/p/62526102)\n\n可以用ZooKeeper来做：统一配置管理、统一命名服务、分布式锁、集群管理。\n\nZooKeeper的数据结构，跟Unix文件系统非常类似，可以看做是一颗树，每个节点叫做ZNode。每一个节点可以通过路径来标识，结构图如下：\n\n![](https://img.springlearn.cn/blog/learn_1653357711000.png)\n\n那ZooKeeper这颗\"树\"有什么特点呢？？ZooKeeper的节点我们称之为Znode，Znode分为两种类型：\n\n短暂/临时(Ephemeral)：当客户端和服务端断开连接后，所创建的Znode(节点)会自动删除\n持久(Persistent)：当客户端和服务端断开连接后，所创建的Znode(节点)不会删除\n\n另外Zookeeper提供了节点监听的能力,当节点发生变化会发起通知事件。我们可以根据这个特性做一些事情,比如节点被删除就移除注册在这个节点上的服务。\n\n[zookeepr api](/learn/other/zookeeper/)\n\n\n\n\n## 4.2 Eureka\n\n[Eureka是干什么的?](https://blog.csdn.net/buyaoshuohua1/article/details/119620675)\nEureka是SpringBoot默认的注册中心组件。没有配置的能力\n\n## 4.3 Consul\n\nConsul是用于服务发现和配置的工具。Consul是分布式的，高度可用的，并且具有极高的可伸缩性，而且开发使用都很简便。它提供了一个功能齐全的控制面板，主要特点是：服务发现、健康检查、键值存储、安全服务通信、多数据中心、ServiceMesh。Consul在设计上把很多分布式服务治理上要用到的功能都包含在内了。\n\n\n## 4.4 Nacos\n\nNacos致力于发现、配置和管理微服务。Nacos提供了一组简单易用的特性集，帮助您实现动态服务发现、服务配置管理、服务及流量管理。Nacos更敏捷和容易地构建、交付和管理微服务平台。 Nacos 是构建以“服务”为中心的现代应用架构(例如微服务范式、云原生范式)的服务基础设施。Nacos支持作为RPC注册中心，例如：支持Dubbo框架；也具备微服务注册中心的能力，例如：SpringCloud框架。\n\n## 五、总结\n\n市面上的注册中心有以上这些，核心逻辑思路都大差不差。其中Consul和Nacos是支持配置的。如果我们开发注册中心的话,没必要研究其源码。\n只有当我们要做注册中心,这个时候我们可以去研究下源码。对于一般开发使用,只要知道他是做什么的就好了。\n\n![](https://img.springlearn.cn/blog/learn_1653371613000.png)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/distributed/分布式注册中心.md b/docs/learn/distributed/分布式注册中心.md
--- a/docs/learn/distributed/分布式注册中心.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/distributed/分布式注册中心.md	(date 1655373430502)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/distributed/分布式配置中心.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 第04篇:分布式配置中心\ndraft: ture\ncategory: 分布式\n---\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/distributed/分布式配置中心.md b/docs/learn/distributed/分布式配置中心.md
--- a/docs/learn/distributed/分布式配置中心.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/distributed/分布式配置中心.md	(date 1655373430537)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/distributed/分布式负载均衡.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: true\nfooter: true\nbacktotop: true\ntitle: 第02篇:分布式负载均衡\nsticky: true\nyuanchuang: true\ncategory: 分布式\nimage: https://img.springlearn.cn/blog/learn_1652886627000.png\n---\n\n![](https://img.springlearn.cn/blog/learn_1652886627000.png)\n\n## 一、什么叫负载均衡\n\n什么叫`负载均衡`, 所谓负载。先可以理解为当流量请求到某一个微服务应用, 则这么微服务应用就承受了负载。\n\n`什么叫均衡`如下图，浏览器发送了3次请求,后台有2个节点的微服务应用。但是每次都请求在某一台。而另外一台一直空闲没有流量。这种情况就是不均衡的。\n\n![](https://img.springlearn.cn/blog/learn_1652839006000.png)\n\n已上图为例，实际情况可能并不一定是一次请求，也可能是`一次任务的调用`。但是不论实际情况是什么, 负载均衡就是要解决一个事情，就是`让流量均衡的分布`。`防止服务器过载运行`产生故障。\n\n## 二、常见解决思路\n\n所谓负载均衡就是从一个集服务器集合中，找到一个最适合的服务器。去进行操作处理。所以首先我们先定义一个服务器集合。\n然后我们再通过常见的算法去进行挑选。\n\n`List<String> services;`\n\n## 2.1 随机算法\n\n```java\n public static String random(List<String> services) {\n        Random random = new Random();\n        String[] addressArr = services.toArray(new String[0]);\n        // random\n        return addressArr[random.nextInt(services.size())];\n }\n```\n\n## 2.2 轮训算法\n\n```java \npublic class RoundBalanceTest {\n\n    public static void main(String[] args) {\n        List<String> services = Arrays.asList(\"service1\", \"service2\", \"service3\");\n        XxlBalanceTest.manyRoute(i -> {\n            // 请求次数,取模。serviceKey 可以更细粒度的控制轮训\n            ColorConsole.colorPrintln(\"轮训负载({}):{}\", i, round(services));\n        });\n    }\n\n    private static final AtomicInteger atomicInteger = new AtomicInteger();\n\n    private static String round(List<String> services) {\n        int count = atomicInteger.get();\n        if (count >= Integer.MAX_VALUE) {\n            atomicInteger.set(0);\n        }\n        atomicInteger.incrementAndGet();\n        String[] toArray = services.toArray(new String[0]);\n        return toArray[count % toArray.length];\n    }\n}\n```\n\n## 2.3 加权算法\n\n加权算法的有很多的变异算法, 可以通过配置的方式，也可以通过某种策略动态的给每台服务器进行加权，从而来提高被轮训到的次数。\n这里说两种网上常见的实现。\n\n\n### 2.3.1 简单加权算法\n\n一个简单暴力的加权算法,如下图。按照权重，重新构建集合。然后再将集合进行取模轮训即可。即可实现一个最简单\n的加权算法。\n\n![](https://img.springlearn.cn/blog/learn_1652884737000.png)\n\n代码实现也是比较简单的,如下代码。 \n\n```java \npublic class WeightBalanceTest {\n\n    private static class Server {\n\n        private String host;\n\n        private Integer port;\n\n        public Server(String host, Integer port) {\n            this.host = host;\n            this.port = port;\n        }\n\n        @Override\n        public String toString() {\n            return \"Server{\" +\n                    \"host='\" + host + '\\'' +\n                    \", port=\" + port +\n                    '}';\n        }\n    }\n\n    private static final AtomicInteger atomicInteger = new AtomicInteger();\n\n    public static Server round(List<Server> services) {\n        int count = atomicInteger.get();\n        if (count >= Integer.MAX_VALUE) {\n            atomicInteger.set(0);\n        }\n        atomicInteger.incrementAndGet();\n        Server[] toArray = services.toArray(new Server[0]);\n        return toArray[count % toArray.length];\n    }\n\n    public static void main(String[] args) {\n        Map<Server, Integer> confWeight = new HashMap<>();\n        confWeight.put(new Server(\"127.0.0.1\", 80), 2);\n        confWeight.put(new Server(\"127.0.0.1\", 81), 3);\n        confWeight.put(new Server(\"127.0.0.1\", 82), 5);\n\n        List<Server> servers = new ArrayList<>();\n        for (Map.Entry<Server, Integer> entity : confWeight.entrySet()) {\n            Server server = entity.getKey();\n            Integer weight = entity.getValue();\n            for (int i = 0; i < weight; i++) {\n                servers.add(server);\n            }\n        }\n        Loops.loop(10, i -> {\n            ColorConsole.colorPrintln(\"第{}次,权重轮训{}\", i, round(servers));\n        });\n    }\n\n}\n```\n\n\n``` \n第0次,权重轮训Server{host='127.0.0.1', port=80}  \n第1次,权重轮训Server{host='127.0.0.1', port=80}  \n第2次,权重轮训Server{host='127.0.0.1', port=82}  \n第3次,权重轮训Server{host='127.0.0.1', port=82}  \n第4次,权重轮训Server{host='127.0.0.1', port=82}  \n第5次,权重轮训Server{host='127.0.0.1', port=82}  \n第6次,权重轮训Server{host='127.0.0.1', port=82}  \n第7次,权重轮训Server{host='127.0.0.1', port=81}  \n第8次,权重轮训Server{host='127.0.0.1', port=81}  \n第9次,权重轮训Server{host='127.0.0.1', port=81}  \n```\n但这样还是不均匀的, 相同的ip可能被连续的访问到其实就没有做到负载均衡。\n\n### 2.3.2 平滑加权算法\n\n主要解决上面那种不平滑的方案。这种方案是由[nginx](https://github.com/phusion/nginx/commit/27e94984486058d73157038f7950a0a36ecc6e35)提出来的。\n算法的数学原理。\n\n- 最大权重，减总权重\n- 当前权重加上原权重\n\n如下权重变化。\n\n| 轮数 | 选择前的当前权重 | 选择节点 | 选择后的当前权重 |\n| ---- | ---------------- | -------- | ---------------- |\n| 1    | {5, 1, 1}        | a        | {-2, 1, 1}       |\n| 2    | {3, 2, 2}        | a        | {-4, 2, 2}       |\n| 3    | {1, 3, 3}        | b        | {1, -4, 3}       |\n| 4    | {6, -3, 4}       | a        | {-1, -3, 4}      |\n| 5    | {4, -2, 5}       | c        | {4, -2, -2}      |\n| 6    | {9, -1, -1}      | a        | {2, -1, -1}      |\n| 7    | {7, 0, 0}        | a        | {0, 0, 0}        |\n\n下面我们通过代码来实现。\n\n- 首先我们定义出服务器模型, `weight` 是初始配置的权重，`currentWeight` 是计算后的权重。\n- 初始值 `weight = currentWeight`\n\n```java \n    @Data\n    @AllArgsConstructor\n    @ToString\n    @EqualsAndHashCode\n    private static class Server {\n        private String host;\n        private Integer port;\n        // 初始化权重\n        private Integer weight;\n        // 计算后的当前权重\n        private Integer currentWeight;\n    }\n```\n\n然后我们根据算法的核心点来选择节点。这里我们先不考虑性能只说思路，有了思路在自己来优化代码。\n\n1. ==line(3-6)==  首先获取总权重\n2. ==line(8-14)== 然后获取当前最大权重的节点\n3. ==line(16-21)== 重新计算权重(`主要使用算法的思想`)\n   - 当前最大权重节点，重新计算权重。当前权重 = 当前权重 - 总权重 + 原始权重\n   - 其他节点，重新计算权重。当前权重 = 当前权重 + 原始权重\n\n```java {3-6,8-14,16-21}\n    public static Server selectServer(List<Server> servers) {\n        // 获取总权重\n        Integer totalWeight = 0;\n        for (Server server : servers) {\n            totalWeight += server.getWeight();\n        }\n        // 根据权重从小到大排序\n        List<Server> sortByCurrentWeight = servers.stream().sorted(Comparator.comparing(Server::getCurrentWeight))\n                .collect(Collectors.toList());\n        // 集合反转,从大到小排序\n        Collections.reverse(sortByCurrentWeight);\n        // 当前最大权重\n        Server maxWeightServer = sortByCurrentWeight.get(0);\n        // 重新计算权重\n        for (Server server : servers) {\n            if (server.equals(maxWeightServer)) {\n                server.setCurrentWeight(server.getCurrentWeight() - totalWeight);\n            }\n            server.setCurrentWeight(server.getCurrentWeight() + server.getWeight());\n        }\n        return maxWeightServer;\n    }\n```\n\n可以看到非常的平滑均匀，每个ip都会被分散。\n\n``` \n第0次,平滑权重轮训WeightBalanceTest2.Server(host=127,0,0,1, port=8080, weight=4, currentWeight=1)\n第1次,平滑权重轮训WeightBalanceTest2.Server(host=127,0,0,1, port=8081, weight=2, currentWeight=-1)\n第2次,平滑权重轮训WeightBalanceTest2.Server(host=127,0,0,1, port=8080, weight=4, currentWeight=2)\n第3次,平滑权重轮训WeightBalanceTest2.Server(host=127,0,0,1, port=8082, weight=1, currentWeight=-2)\n第4次,平滑权重轮训WeightBalanceTest2.Server(host=127,0,0,1, port=8080, weight=4, currentWeight=3)\n第5次,平滑权重轮训WeightBalanceTest2.Server(host=127,0,0,1, port=8081, weight=2, currentWeight=0)\n第6次,平滑权重轮训WeightBalanceTest2.Server(host=127,0,0,1, port=8080, weight=4, currentWeight=4)\n```\n\n\n## 三、举例子\n\n![](https://www.gif.cn/Upload/newsucai/2022-05-12/165233481994659.gif)\n\n**好了前面，我们把常见的负载均衡算法都介绍完了，当然实际中的还有很多变异的算法，但是核心思想基本都是以上的思想。下面我们来\n看看常见的开源框架中都使用了那些算法吧。**\n\n`具体算法如何实现不主要研究，只要知道其中的思想即可。如果开发中要使用，在去借鉴就好。`\n\n## 3.1 xxljob\n\nxxl内置了5种负载机制在 `LoadBalance` 可以找到，其中默认是轮训算法。前两种就不说了，就是上面我们提的。还有其他三种\n\n1. XxlRpcLoadBalanceLRUStrategy \n   - LRU，即：最近最少使用淘汰算法（Least Recently Used）\n   - 利用迭代器进行轮训: lruItem.entrySet().iterator().next().getKey().并且最长时间没有被用到的会被删除。\n2. XxlRpcLoadBalanceLFUStrategy\n   - LFU，即：最不经常使用淘汰算法（Least Frequently Used）。\n   - 使用次数最少的会优先被选中\n3. XxlRpcLoadBalanceConsistentHashStrategy\n   - 一致性Hash算法 [Hash一致性](/learn/other/一致性hash问题/)\n   - 思路: 将每个节点进行hash,每个地址虚拟5个节点,然后放到TreeMap里面进行排序。\n   - 每次对serviceKey进行hash然后获取TreeMap中距离hash最近的一个节点\n   - 每个serviceKey对应的服务是唯一的\n\n[一致性hash](/learn/other/%E4%B8%80%E8%87%B4%E6%80%A7hash%E9%97%AE%E9%A2%98/)\n```java \npublic enum LoadBalance {\n    RANDOM(new XxlRpcLoadBalanceRandomStrategy()),\n    ROUND(new XxlRpcLoadBalanceRoundStrategy()),\n    LRU(new XxlRpcLoadBalanceLRUStrategy()),\n    LFU(new XxlRpcLoadBalanceLFUStrategy()),\n    CONSISTENT_HASH(new XxlRpcLoadBalanceConsistentHashStrategy());\n} \n\npublic abstract class XxlRpcLoadBalance {\n    // serviceKey 是job的服务名拼接，addressSet是一共能选的机器\n    public abstract String route(String serviceKey, TreeSet<String> addressSet);\n}   \n```\n\n## 3.2 Ribbon\n\n`Ribbon` 是 SpringCloud体系下一个核心的负载均衡组件。\n\n```java \npublic interface ILoadBalancer {\n    // 添加服务器列表\n\tpublic void addServers(List<Server> newServers);\n\t// 选择可用的服务\n\tpublic Server chooseServer(Object key);\n\t// 标记服务下线\n\tpublic void markServerDown(Server server);\n\t// 当前活跃的服务\n    public List<Server> getReachableServers();\n    // 当前所有的服务\n\tpublic List<Server> getAllServers();\n}\n\npublic interface IRule{\n    // 真正来做选择的接口\n    public Server choose(Object key);\n    \n    public void setLoadBalancer(ILoadBalancer lb);\n    \n    public ILoadBalancer getLoadBalancer();    \n}\n```\n\n![](https://img.springlearn.cn/blog/learn_1652939033000.png)\n\n| 序号 | 实现类                    | 负载均衡策略                                                 |\n| ---- | ------------------------- | ------------------------------------------------------------ |\n| 1    | RoundRobinRule            | 按照线性轮询策略，即按照一定的顺序依次选取服务实例           |\n| 2    | RandomRule                | 随机选取一个服务实例                                         |\n| 3    | RetryRule                 | 按照 RoundRobinRule（轮询）的策略来获取服务，如果获取的服务实例为 null 或已经失效，则在指定的时间之内不断地进行重试（重试时获取服务的策略还是 RoundRobinRule 中定义的策略），如果超过指定时间依然没获取到服务实例则返回 null 。 |\n| 4    | WeightedResponseTimeRule  | WeightedResponseTimeRule 是 RoundRobinRule 的一个子类，它对 RoundRobinRule 的功能进行了扩展。  根据平均响应时间，来计算所有服务实例的权重，响应时间越短的服务实例权重越高，被选中的概率越大。刚启动时，如果统计信息不足，则使用线性轮询策略，等信息足够时，再切换到 WeightedResponseTimeRule。 |\n| 5    | BestAvailableRule         | 继承自 ClientConfigEnabledRoundRobinRule。先过滤点故障或失效的服务实例，然后再选择并发量最小的服务实例。 |\n| 6    | AvailabilityFilteringRule | 先过滤掉故障或失效的服务实例，然后再选择并发量较小的服务实例。 |\n| 7    | ZoneAvoidanceRule         | 默认的负载均衡策略，综合判断服务所在区域（zone）的性能和服务（server）的可用性，来选择服务实例。在没有区域的环境下，该策略与轮询（RandomRule）策略类似。 |\n\n## 3.3 dubbo\n\n\n`dubbo` 负载均衡接口\n\n```java  \n@SPI(RandomLoadBalance.NAME)\npublic interface LoadBalance {\n    @Adaptive(\"loadbalance\")\n    <T> Invoker<T> select(List<Invoker<T>> invokers, URL url, Invocation invocation) throws RpcException;\n}\n```\n\n![](https://img.springlearn.cn/learn_dad4a02061611976e7f89376d893dfe6.png)\n\n可以看到常用的算法都提供了，可能具体的实现方式可能不一样。\n\n| 序号  | 实现类                    | 负载均衡策略                                                 |\n|-----| ------------------------- | ------------------------------------------------------------ |\n| 1   | RandomLoadBalance  |随机算法|\n| 2   | RoundRobinLoadBalance   | 加权轮训| \n| 3   | LeastActiveLoadBalance   |当前最少调用的服务先被选中|\n| 4   | ConsistentHashLoadBalance   |一致性hash算法|\n\n\n## 四、总结\n\n\n- xxl的负载均衡是无状态的\n- Ribbon和dubbo有些策略是有状态的，比如会记录服务当前的活跃次数和耗时将这些也算入到权重\n\n`无状态设计具有通用性比较简答。而有状态设计虽然不能通用,但是会充分考虑到服务器的性能进行负载。`\n\n假如我们来涉及负载均衡，要采用那种设计呢?\n\n其次我们还有那些场景需要关心呢? 请留下你的评论。\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/distributed/分布式负载均衡.md b/docs/learn/distributed/分布式负载均衡.md
--- a/docs/learn/distributed/分布式负载均衡.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/distributed/分布式负载均衡.md	(date 1655373430377)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/distributed/分布式服务网关.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 第08篇:分布式服务网关\ndraft: ture\ncategory: 分布式\n---\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/distributed/分布式服务网关.md b/docs/learn/distributed/分布式服务网关.md
--- a/docs/learn/distributed/分布式服务网关.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/distributed/分布式服务网关.md	(date 1655373430391)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/distributed/分布式服务熔断.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 第07篇:分布式服务熔断\ndraft: ture\ncategory: 分布式\n---\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/distributed/分布式服务熔断.md b/docs/learn/distributed/分布式服务熔断.md
--- a/docs/learn/distributed/分布式服务熔断.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/distributed/分布式服务熔断.md	(date 1655373430079)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/distributed/分布式服务调用.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: true\nfooter: true\nbacktotop: true\ntitle: 第03篇:分布式服务调用\ndraft: ture\ncategory: 分布式\n---\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/distributed/分布式服务调用.md b/docs/learn/distributed/分布式服务调用.md
--- a/docs/learn/distributed/分布式服务调用.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/distributed/分布式服务调用.md	(date 1655373430408)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/.vuepress/theme/styles/palette.styl
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/* basic color */\n$accentColor ?= #3eaf7c\n$textColor ?= #242424\n$darkTextColor ?= #9e9e9e\n$bgColor ?= #fff\n$darkBgColor ?= #1e1e1e\n$bgColorLight ?= #f8f8f8\n$darkBgColorLight ?= #272727\n$bgColorBlur ?= rgba(255, 255, 255, 0.9)\n$darkBgColorBlur ?= rgba(30, 30, 30, 0.9)\n$borderColor ?= #eaecef\n$darkBorderColor ?= #302d28\n$codeBgColor ?= #ecf4fa\n$darkCodeBgColor ?= #282c34\n$arrowBgColor ?= #ccc\n$darkArrowBgColor ?= #333\n/* colors provided by theme */\n$boxShadowColor ?= #f0f1f2\n$darkBoxShadowColor ?= #0f0e0d\n$cardShadowColor ?= rgba(0, 0, 0, 0.15)\n$darkCardShadowColor ?= rgba(0, 0, 0, 0.3)\n/* * theme-color */\n$colorPicker ?= {\n  red: #e74c3c,\n  blue: #3498db,\n  green: #3eaf7c,\n  orange: #f39c12,\n  purple: #8e44ad\n}\n/* badge color */\n$badgeTipColor ?= #42b983\n$badgeWarningColor ?= darken(#ffe564, 35%)\n$badgeErrorColor ?= #DA5961\n/* layout */\n$navbarHeight ?= 3.6rem\n$navbarMobileHeight ?= 3.25rem\n$navbarHorizontalPadding ?= 1.5rem\n$navbarMobileHorizontalPadding ?= 1rem\n$navbarVerticalPadding ?= 0.7rem\n$navbarMobileVerticalPadding ?= 0.5rem\n$sidebarWidth ?= 18rem\n$mobileSidebarWidth ?= $sidebarWidth\n$contentWidth ?= 820px\n$homePageWidth ?= 960px\n/* responsive breakpoints */\n$MQWide ?= 1440px // wide screen\n$MQNormal ?= 1280px // desktop\n$MQNarrow ?= 959px // narrow desktop / iPad\n$MQMobile ?= 719px // wide mobile\n$MQMobileNarrow ?= 419px // narrow mobile\n/* code block */\n$lineNumbersWrapperWidth ?= 2.5rem\n$codeLang ?= js ts html md vue css sass scss less stylus go java c sh yaml py docker dockerfile makefile\n/* content class */\n$contentClass ?= '.theme-default-content'\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/.vuepress/theme/styles/palette.styl b/docs/.vuepress/theme/styles/palette.styl
--- a/docs/.vuepress/theme/styles/palette.styl	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/.vuepress/theme/styles/palette.styl	(date 1654337830511)
@@ -1,5 +1,7 @@
 /* basic color */
+// nprogress 导航进度条颜色
 $accentColor ?= #3eaf7c
+//$accentColor ?= #2a6be1
 $textColor ?= #242424
 $darkTextColor ?= #9e9e9e
 $bgColor ?= #fff
Index: docs/learn/distributed/分布式服务限流.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 第06篇:分布式服务限流\ndraft: ture\ncategory: 分布式\n---\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/distributed/分布式服务限流.md b/docs/learn/distributed/分布式服务限流.md
--- a/docs/learn/distributed/分布式服务限流.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/distributed/分布式服务限流.md	(date 1655373430612)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/spring/Endpoint监控端点扩展.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: true\nfooter: true\nbacktotop: true\ntitle: Spring Boot Endpoint监控端点扩展\ncategory: SpringBoot\n---\n\n::: tip\n什么是端点? 端点就是SpringBoot通过web或者jmx的方式向外部暴露应用的信息,或者上下文的信息。SpringCloud-Admin就是根据此技术来进行实现的。他们用到的技术就是@Endpoint，而不是通过自己@GetMapping之类进行实现的。下面小编就带大家一起来学习端点的使用。学会本文后在利用前面我们讲过的autoconfigure的自动化配置后，你就可以开发更高级的SpringBoot应用(非业务系统)。本教程将带你从业务系统开发者转变为研发系统开发者。\n:::\n\n用过SpringBoot的同学可能知道，SpringBoot有很多监控端点,比如当我们引入健康监控组件\n\n```xml \n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-actuator</artifactId>\n  <version>2.6.7</version>\n</dependency>\n```\n\n系统就会自动暴露出许多,web端口供外部调用，获取应用的信息，或者上下文的信息。\n\n![image-20190308191019856](https://img.springlearn.cn/learn_010cf865b5c13bd4a2c855dbf383a81d.jpg)\n\n\n## 一、如何定义端点\n\n可以使用`@Endpoint`,`@WebEndpoint`,`@JmxEndpoint`,或者`EndpointWebExtension`来实现HTTP方式的端点,可以是传统SpringMVC也可以是最新的`Spring WebFlux`\n\n\n- `@Endpoint`相当于`@WebEndpoint`和`@JmxEndpoint`的整合。web和jmx方式都支持\n\n- `@WebEndpoint` 只会生成web的方式的端点监控\n\n![image-20190308190517126](https://img.springlearn.cn/learn_b2c367712133b4affaf175b38eaad3cc.jpg)\n\n- `JmxEndpoint` 只会生成Jmx的方式监控\n\n![image-20190308183731989](https://img.springlearn.cn/learn_6490cd4917d5633fbbe9b205eb191dde.jpg)\n\n| Operation          | HTTP method |\n| ------------------ | ----------- |\n| `@ReadOperation`   | `GET`       |\n| `@WriteOperation`  | `POST`      |\n| `@DeleteOperation` | `DELETE`    |\n\n\n## 二、路径规则\n\n默认的基础路径是` /actuator`,如果一个端点配置的路径是`sessions`,那么它的全路径就是`/actuator/sessions`\n\n```java\n@Component\n@WebEndpoint(id = \"sessions\")\npublic class MyHealthEndpoint {\n  @ReadOperation\n  public Info get(@Selector String name) {\n    return new Info(name, \"23\");\n  }\n}\n```\n\n`@Selector` 的含义是让这个路径变成`/actuator/sessions/{name}` 我们能从路径上获取一个入参。\n\n\n## 三、相关配置\n\n### 3.1 自定义管理端点路径\n\n`management.endpoints.web.base-path = /manage`\n\n此配置会将`/actuator/sessions/{name}`转换成`/manage/sessions/{name}`\n\n### 3.2 自定义管理服务器地址\n\n默认端口和应用的端口是一致的,但是也可以通过配置的方式改变端口\n\n```\nmanagement.server.port = 8081\nmanagement.server.address = 127.0.0.1\n```\n\n### 3.3 激活端点\n\n```\n//激活所有的端点的web方式请求\nmanagement.endpoints.web.exposure.include=*\n//关闭端点web方式\nmanagement.endpoints.web.exposure.exclude=env,beans\n//激活所有的JMX方式请求\nmanagement.endpoints.jmx.exposure.include=*\n```\n\n### 3.4 跨域方式请求\n\n```\n//允许跨域的网址\nmanagement.endpoints.web.cors.allowed-origins=http://example.com\n//允许跨域的方法\nmanagement.endpoints.web.cors.allowed-methods=GET,POST\n```\n\n\n## 四、总结\n\n最后我们来总结。\n其实@WebEndpoint 就相当于`声明成一个@RestController`的控制类而请求方法分别被下面注解代替。\n\n| Operation          | HTTP method |\n| ------------------ | ----------- |\n| `@ReadOperation`   | `GET`       |\n| `@WriteOperation`  | `POST`      |\n| `@DeleteOperation` | `DELETE`    |\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/spring/Endpoint监控端点扩展.md b/docs/learn/spring/Endpoint监控端点扩展.md
--- a/docs/learn/spring/Endpoint监控端点扩展.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/spring/Endpoint监控端点扩展.md	(date 1655373430226)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/distributed/分布式服务降级.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 第05篇:分布式服务降级\ndraft: ture\ncategory: 分布式\n---\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/distributed/分布式服务降级.md b/docs/learn/distributed/分布式服务降级.md
--- a/docs/learn/distributed/分布式服务降级.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/distributed/分布式服务降级.md	(date 1655373430594)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/distributed/分布式链路追踪.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 第09篇:分布式链路追踪\ndraft: ture\ncategory: 分布式\n---\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/distributed/分布式链路追踪.md b/docs/learn/distributed/分布式链路追踪.md
--- a/docs/learn/distributed/分布式链路追踪.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/distributed/分布式链路追踪.md	(date 1655373430423)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/distributed/分布式事务处理.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 第10篇:分布式事务处理\ndraft: ture\ncategory: 分布式\n---\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/distributed/分布式事务处理.md b/docs/learn/distributed/分布式事务处理.md
--- a/docs/learn/distributed/分布式事务处理.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/distributed/分布式事务处理.md	(date 1655373430097)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/java/Contended.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: true\nfooter: true\nbacktotop: true\ntitle: 性能优化之@Contended减少伪共享\ncategory: Java进阶\n---\n\n## 一、什么叫伪共享\n\n说到伪共享,就要说CPU缓存,我们程序执行时候信息会被保存到CPU缓存中\n而这些缓存中的数据可能被多线程访问,假如一个线程还没处理完，另外一个线程\n就对数据进行了修改,就会导致上一个线程发生幻读的情况,比如刚才看到a=1,然后准备a = a+1。\n但是还没做,另外一个线程就先将a变成2了。导致了上一个线程计算后本来应该是a = 1 + 1,变成了a = 2 + 1\n计算结果就不对了。\n\n那么对于这种情况当然是不允许发生的，解决方案就是当发现另外一个线程更新了共享变量，就会把cpu缓存中的数据给失效。\n然后都重新读取最新的变量值。\n\n==这里有一个前提是共享变量，因为两个线程都会用到a,所以a是共享变量。==\n\n那么我们在聊伪共享就简单了，下面举一个伪共享变量的例子。\n\n```java \npublic class ContendedTest {\n\n    volatile long a;\n    \n    volatile long b;\n    \n    @Test\n    public void test() throws Exception {\n        ContendedTest c = new ContendedTest();\n        Thread thread1 = new Thread(() -> {\n            for (int i = 0; i < 10000_0000L; i++) {\n                c.a = i;\n            }\n        });\n        Thread thread2 = new Thread(() -> {\n            for (int i = 0; i < 10000_0000L; i++) {\n                c.b = i;\n            }\n        });\n        final long start = System.nanoTime();\n        thread1.start();\n        thread2.start();\n        thread1.join();\n        thread2.join();\n        // 1933\n        System.out.println((System.nanoTime() - start) / 100_0000);\n    }\n     \n}    \n```\n\n\n两个线程分别来更新a和b属性,根据缓存失效的原理,因为a和b都在同一个对象中,当一个属性被更新,就会触发cpu缓存失效。\n那么等于这种情况cpu缓存就没什么用了。我们思考下两个线程分别更新a和b，而a和b没有任何关系。那么a和b是共享变量吗?\n当然不是,这就叫伪共享。\n\n\n## 二、主动告诉程序伪共享\n\n我们可以使用 `@Contended` 来声明伪共享变量,从而是cpu不更新缓存。 \n本地测试时候记得加上jvm参数 ==-XX:-RestrictContended==，否则无效哦。\n\n```java \npublic class ContendedTest {\n\n    @Contended\n    volatile int a;\n\n    @Contended\n    volatile int b;\n\n    @Test\n    public void test() throws Exception {\n        ContendedTest c = new ContendedTest();\n        Thread thread1 = new Thread(() -> {\n            for (int i = 0; i < 10000_0000L; i++) {\n                c.a = i;\n            }\n        });\n        Thread thread2 = new Thread(() -> {\n            for (int i = 0; i < 10000_0000L; i++) {\n                c.b = i;\n            }\n        });\n        final long start = System.nanoTime();\n        thread1.start();\n        thread2.start();\n        thread1.join();\n        thread2.join();\n        System.out.println((System.nanoTime() - start) / 100_0000);\n    }\n}\n```\n\n那么你猜下性能能提高多少呢? 前者`1933`后者`758ms`,差不多2.5倍的样子。\n\n\n那么留下一个问题? 有多少场景都在使用`@Contended`呢? 知道的请留言评论。\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/java/Contended.md b/docs/learn/java/Contended.md
--- a/docs/learn/java/Contended.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/java/Contended.md	(date 1655373430110)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/spring/Web接口资源是如何保存起来的.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: true\nfooter: true\nbacktotop: true\ntitle: Web接口资源是如何保存起来的?\ncategory: SpringBoot\n---\n\n\n## 前言\n\n在我们使用 `SpringBoot` 开发中,我们定义一接口是下面这样的\n\n```\n@RestController\npublic class UserController{\n    \n    @GetMapping( name = \"/getUserName\")\n    public String getUserName(){\n        return \"Hello World\";\n    }\n}\n```\n\n这时候我们思考一个问题,我们在浏览器上只输入了一个URL地址,怎么就能访问到这个接口的呢？于是乎就引出了\n今天我们要讨论的话题。Spring中的Web接口资源是如何保存起来的?\n\n\n## 一、Spring中的Web接口资源是如何保存起来的?\n\n在我们学习之前我们可以先自己来进行思考一下。处理逻辑是什么样的？\n\n- Spring容器解析 `@RequestMapping` 注解。当然这个注解又派生了其他的注解比如。\n\n```\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@RequestMapping(method = RequestMethod.POST)\npublic @interface PostMapping {}\n\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@RequestMapping(method = RequestMethod.PUT)\npublic @interface PutMapping {}\n\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@RequestMapping(method = RequestMethod.GET)\npublic @interface GetMapping {}\n\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@RequestMapping(method = RequestMethod.DELETE)\npublic @interface DeleteMapping {}\n```\n\n- 我们猜测Spring源码中一定会对`@RestController` 和 `@Controller`标记的类,里面的每个\n  Method进行处理,判断是否包含了上面的注解。注解那么多Spring肯定不会这样一个一个去处理。我们可以看到\n  上面的注解都使用了`@AliasFor`注解。其中奥妙就在这里。看下面例子代码。\n- 我们猜测Spring肯定对这些Method判断是否有`@RequestMapping`有注解。\n\n### 1. @AliasFor使用\n\n```\n@RestController\npublic class PostController {\n\n    @ApiOperation(value = \"查询Bbs所有文章\")\n    @PostMapping(value = \"/query/bbs/posts\", produces = MediaType.APPLICATION_JSON_VALUE)\n    public Result<PostAllResponse> queryBbsPostAll(@RequestBody PostAllSelectRequest postAllSelectRequest) {\n        return postBiz.queryBbsPostAll(postAllSelectRequest);\n    }\n\n    public static void main(String[] args) {\n        Method queryBbsPostAll = ClassUtils.getMethod(PostController.class, \"queryBbsPostAll\",PostAllSelectRequest.class);\n        PostMapping annotation = AnnotationUtils.findAnnotation(queryBbsPostAll, PostMapping.class);\n        ///query/bbs/posts\n        System.out.println(StringUtils.arrayToCommaDelimitedString(annotation.value()));\n        //application/json\n        System.out.println(StringUtils.arrayToCommaDelimitedString(annotation.produces()));\n        //是否包含RequestMapping: true\n        System.out.println(\"是否包含RequestMapping: \"+AnnotatedElementUtils.hasAnnotation(queryBbsPostAll,RequestMapping.class));\n\n        RequestMapping mergedAnnotation = AnnotatedElementUtils.getMergedAnnotation(queryBbsPostAll, RequestMapping.class);\n        ///query/bbs/posts\n        System.out.println(StringUtils.arrayToCommaDelimitedString(mergedAnnotation.value()));\n    }\n}\n\n```\n\n可以看到只要使用下面代码就能把被`@PostMapping`等等的注解都涵盖了。\n\n```\nSystem.out.println(\"是否包含RequestMapping: \"+AnnotatedElementUtils.hasAnnotation(queryBbsPostAll,RequestMapping.class));\nRequestMapping mergedAnnotation = AnnotatedElementUtils.getMergedAnnotation(queryBbsPostAll, RequestMapping.class);\n```\n\n### 2. 解析请求Method\n\n`AbstractHandlerMethodMapping` 实现 `InitializingBean`。在当前 `Bean`初始化时候会执行\n\n`afterPropertiesSet -> initHandlerMethods`\n\n从这里开始解析Web资源类的信息。请小伙伴们看下面的截图,截图中源码已经把类名也截上了,方便小伙伴们自己在根据截图看一遍源码。\n\n```\npublic abstract class AbstractHandlerMethodMapping<T> extends AbstractHandlerMapping implements InitializingBean {\n\n    @Override\n    public void afterPropertiesSet() {\n        initHandlerMethods();\n    }\n    \n    /**\n\t * Scan beans in the ApplicationContext, detect and register handler methods.\n\t * @see #getCandidateBeanNames()\n\t * @see #processCandidateBean\n\t * @see #handlerMethodsInitialized\n\t */\n    protected void initHandlerMethods() {\n        for (String beanName : getCandidateBeanNames()) {\n            if (!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) {\n                processCandidateBean(beanName);\n            }\n        }\n        handlerMethodsInitialized(getHandlerMethods());\n    }\n}\n```\n\n**RequestMappingHandlerMapping解析Method上的RequestMapping信息**\n\n![](https://img.springlearn.cn/blog/learn_1596563456000.png)\n\nisHandler 方法判断是否是web资源类。 当一个类被标记了 `@Controller 或者@RequestMapping`。 注意 `@RestController` 是`@Controller`的派生类。所以这里只用判断 `@Controller 或者@RequestMapping`就行了。\n\n![](https://img.springlearn.cn/blog/learn_1596563605000.png)\n\ndetectHandlerMethods方法就是真正开始解析Method的逻辑。通过解析Method上的 `@RequestMapping`或者其他派生的注解。生成请求信息。\n注意这个请求信息里面也是有很多逻辑的不过不是本篇讨论的重点,就不说了。稍微提一下。根据规则来匹配url逻辑就在这里面。\n\n![](https://img.springlearn.cn/blog/learn_1596563872000.png)\n\n这里我们能看到源码里拿到了Method并拿到了执行这个Method的实例Bean。在这里封装成了HandlerMethod并注册到了MappingRegistry中。\n![](https://img.springlearn.cn/blog/learn_1596564039000.png)\n\n在注册的过程中把RequestMapping中的路径信息同事也放到一个urlLookup中。key是url,value是Mapping信息。\n![](https://img.springlearn.cn/blog/learn_1596564246000.png)\n\n到这里其实我们就把本篇的议题就说明清楚了。下面我们在看下SpringWeb是如何将http请求信息路由到具体的HandlerMethod的吧。\n\n### 3. 最后串一下流程\n\n看了前面的截图,我们知道Spring是如何把这些Web资源信息给保存起来的了。然后就看是`DispatcherServlet`的逻辑了。\n\n首先`DispatcherServlet` 是一个Servlet。Servlet相信大家都都知道就不重点说原理。 我们直接看\n`doService` -> `doDispatch` 方法\n\n![](https://img.springlearn.cn/blog/learn_1596564523000.png)\n\n根据请求路径,找到从Mapping信息,然后根据Mapping信息匹配到具体的HandlerMethod。 ok本篇内容就到这里。谢谢大家。\n![](https://img.springlearn.cn/blog/learn_1596565589000.png)\n![](https://img.springlearn.cn/blog/learn_1596564759000.png)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/spring/Web接口资源是如何保存起来的.md b/docs/learn/spring/Web接口资源是如何保存起来的.md
--- a/docs/learn/spring/Web接口资源是如何保存起来的.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/spring/Web接口资源是如何保存起来的.md	(date 1655373430580)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/tools/jol/README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: auto\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\nsidebarDepth: 3\ntitle: Java Object 内存布局\npassword: 123\nicon: zuanshi\n---\n\n[参考链接](https://blog.csdn.net/uuqaz/article/details/123340729)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/tools/jol/README.md b/docs/learn/tools/jol/README.md
--- a/docs/learn/tools/jol/README.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/tools/jol/README.md	(date 1655373430400)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: auto
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/other/一致性hash问题.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: false\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 一致性hash问题\nsidebarDepth: 3\n---\n\n![](https://img.springlearn.cn/learn_aecfc8e243edb199c726728413b1522c.gif)\n\n## 一、介绍\n\n一致性哈希主要解决的问题,是互联网中的热点问题,及当cache环境改变,能动态感知,避免继续向已经坏掉的空间,插入新值.\n\n## 二、不一致会有什么问题?\n\n## 2.1 缓存的例子\n\n有 N 个 cache 服务器（后面简称 cache ），那么如何将一个对象 object 映射到 N 个 cache 上呢，你很可能会采用类似下面的通用方法计算 object 的 hash\n\n求余算法: hash(Object) % N\n\n有多个cache: cache[0] cache[1] cache[2] cache[3], 然后要\n\n- put 4%4 insert 到cache[0]=A\n\n- put 1%4 insert 到cache[1]=B\n\n- put 2%4 insert 到cache[2]=C\n\n- put 3%4 insert 到cache[3]=D\n\n假如cache[0] A节点突然挂了,此时获取cache[0]会有问题,put 5%3(本来4个节点-1一个节点) insert cache[2] ,之前是插入C,但是之后cache[2]=D,此时,一台错误会对全局产生影响.(因为cache的位置都发生了变化),这样就不能维护hash算法的单调性,可能之前已经插入了,但是后面就要覆盖.\n\n\n<del>cache[0]=A</del>\n\n- cache[0]=B\n- cache[1]=C\n- cache[2]=D\n\n\n## 2.3 数据迁移例子\n\n假如有10条数据，3个节点，如果按照取模的方式。\n\n![](https://img.springlearn.cn/blog/learn_1652926998000.png)\n\n总结: 数据在增加了一个节点后，3,4,5,6,7,8,9都需要做搬迁，成本太高了\n\n那么采用一致性hash后怎么样呢?\n\n### 2.3.1 一致性hash如何处理?\n对 a b c 分别做哈希映射\n\n![](https://img.springlearn.cn/blog/learn_1652927183000.png)\n\n当大于228都存203节点,于是就维护了一个圆形,即所有数据都能找到其节点了\n\n![](https://img.springlearn.cn/blog/learn_1652927207000.png)\n\n当新加入节点d,可以算出d的hash\n\n==node d: 216==\n\n![](https://img.springlearn.cn/blog/learn_1652927238000.png)\n\n对数据进行迁移(其实只影响209~216之间的数,即达到了我们的目的)\n\n## 三、总结\n\n`一致性hash的算法，就是不去确定唯一的下标，而是将节点先形成一个hash环,每次获取当前hash最近的节点。这样就算挂了一个节点，影响也是最小的`。\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/other/一致性hash问题.md b/docs/learn/other/一致性hash问题.md
--- a/docs/learn/other/一致性hash问题.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/other/一致性hash问题.md	(date 1655373430119)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: false
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/java/BlockingQueue.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: Java并发包队列之BlockingQueue\ncategory: Java进阶\n---\n\n## 一、什么是BlockingQueue\n\nBlockingQueue即阻塞队列，从阻塞这个词可以看出，在某些情况下对阻塞队列的访问可能会造成阻塞。被阻塞的情况主要有如下两种：\n\n1. 当队列满了的时候进行入队列操作\n2. 当队列空了的时候进行出队列操作\n   因此，当一个线程试图对一个已经满了的队列进行入队列操作时，它将会被阻塞，除非有另一个线程做了出队列操作；同样，当一个线程试图对一个空队列进行出队列操作时，它将会被阻塞，除非有另一个线程进行了入队列操作。\n\n\n## 二、BlockingQueue的用法\n\n阻塞队列主要用在生产者/消费者的场景，下面这幅图展示了一个线程生产、一个线程消费的场景：\n\n![](http://img.blog.csdn.net/20150929153140497)\n\n负责生产的线程不断的制造新对象并插入到阻塞队列中，直到达到这个队列的上限值。队列达到上限值之后生产线程将会被阻塞，直到消费的线程对这个队列进行消费。同理，负责消费的线程不断的从队列中消费对象，直到这个队列为空，当队列为空时，消费线程将会被阻塞，除非队列中有新的对象被插入。\n\n\n\n## 三、BlockingQueue接口中的方法\n\n阻塞队列一共有四套方法分别用来进行insert、remove和examine，当每套方法对应的操作不能马上执行时会有不同的反应，下面这个表格就分类列出了这些方法：\n| -       | Throws Exception | Special Value | Blocks | Times Out                   |\n| ------- | ---------------- | ------------- | ------ | --------------------------- |\n| Insert  | add(o)           | offer(o)      | put(o) | offer(o, timeout, timeunit) |\n| Remove  | remove(o)        | poll()        | take() | poll(timeout, timeunit)     |\n| Examine | element()        | peek()        |        |                             |\n\n\n\n\n1. ThrowsException：如果操作不能马上进行，则抛出异常\n2. SpecialValue：如果操作不能马上进行，将会返回一个特殊的值，一般是true或者false\n3. Blocks:如果操作不能马上进行，操作会被阻塞\n4. TimesOut:如果操作不能马上进行，操作会被阻塞指定的时间，如果指定时间没执行，则返回一个特殊值，一般是true或者false\n   需要注意的是，我们不能向BlockingQueue中插入null，否则会报NullPointerException。\n\n## 四、BlockingQueue的实现类\n\nBlockingQueue只是java.util.concurrent包中的一个接口，而在具体使用时，我们用到的是它的实现类，当然这些实现类也位于java.util.concurrent包中。在Java6中，BlockingQueue的实现类主要有以下几种：\n\n1. ArrayBlockingQueue\n2. DelayQueue\n3. LinkedBlockingQueue\n4. PriorityBlockingQueue\n5. SynchronousQueue\n\n\n### 4.1 ArrayBlockingQueue\n\nArrayBlockingQueue是一个有边界的阻塞队列，它的内部实现是一个数组。有边界的意思是它的容量是有限的，我们必须在其初始化的时候指定它的容量大小，容量大小一旦指定就不可改变。\n\nArrayBlockingQueue是以先进先出的方式存储数据，最新插入的对象是尾部，最新移出的对象是头部。下面是一个初始化和使用ArrayBlockingQueue的例子：\n\nBlockingQueue queue = new ArrayBlockingQueue(1024);\nqueue.put(\"1\");\nObject object = queue.take();\n\n\n### 4.2 DelayQueue\n\nDelayQueue阻塞的是其内部元素，DelayQueue中的元素必须实现 java.util.concurrent.Delayed接口，这个接口的定义非常简单：\n```\npublic interface Delayed extends Comparable<Delayed> {\nlong getDelay(TimeUnit unit);\n}\n```\ngetDelay()方法的返回值就是队列元素被释放前的保持时间，如果返回0或者一个负值，就意味着该元素已经到期需要被释放，此时DelayedQueue会通过其take()方法释放此对象。\n\n从上面Delayed 接口定义可以看到，它还继承了Comparable接口，这是因为DelayedQueue中的元素需要进行排序，一般情况，我们都是按元素过期时间的优先级进行排序。\n\n例1：为一个对象指定过期时间\n\n首先，我们先定义一个元素，这个元素要实现Delayed接口\n```\npublic class DelayedElement implements Delayed {\n  private long expired;\n  private long delay;\n  private String name;\n\n  DelayedElement(String elementName, long delay) {\n         this. name = elementName;\n         this. delay= delay;\n         expired = ( delay + System. currentTimeMillis());\n  }\n\n  @Override\n  public int compareTo(Delayed o) {\n        DelayedElement cached=(DelayedElement) o;\n         return cached.getExpired()> expired?1:-1;\n  }\n\n  @Override\n  public long getDelay(TimeUnit unit) {\n\n         return ( expired - System. currentTimeMillis());\n  }\n\n  @Override\n  public String toString() {\n         return \"DelayedElement [delay=\" + delay + \", name=\" + name + \"]\";\n  }\n\n  public long getExpired() {\n         return expired;\n  }\n\n}\n```\n设置这个元素的过期时间为3s\n\n```\npublic class DelayQueueExample {\n  public static void main(String[] args) throws InterruptedException {\n        DelayQueue<DelayedElement> queue= new DelayQueue<>();\n        DelayedElement ele= new DelayedElement( \"cache 3 seconds\",3000);\n         queue.put( ele);\n        System. out.println( queue.take());\n\n  }\n}\n```\n运行这个main函数，我们可以发现，我们需要等待3s之后才会打印这个对象。\n\n其实DelayQueue应用场景很多，比如定时关闭连接、缓存对象，超时处理等各种场景，下面我们就拿学生考试为例让大家更深入的理解DelayQueue的使用。\n\n例2：把所有考试的学生看做是一个DelayQueue，谁先做完题目释放谁\n\n\n首先，我们构造一个学生对象\n\n```\npublic class Student implements Runnable,Delayed{\n  private String name;  //姓名\n  private long costTime;//做试题的时间\n  private long finishedTime;//完成时间\n\n  public Student(String name, long costTime) {\n         this. name = name;\n         this. costTime= costTime;\n         finishedTime = costTime + System. currentTimeMillis();\n  }\n\n  @Override\n  public void run() {\n        System. out.println( name + \" 交卷,用时\" + costTime /1000);\n  }\n\n  @Override\n  public long getDelay(TimeUnit unit) {\n         return ( finishedTime - System. currentTimeMillis());\n  }\n\n  @Override\n  public int compareTo(Delayed o) {\n        Student other = (Student) o;\n         return costTime >= other. costTime?1:-1;\n  }\n\n}\n```\n\n然后在构造一个教师对象对学生进行考试\n```\npublic class Teacher {\n  static final int STUDENT_SIZE = 30;\n  public static void main(String[] args) throws InterruptedException {\n        Random r = new Random();\n        //把所有学生看做一个延迟队列\n        DelayQueue<Student> students = new DelayQueue<Student>();\n        //构造一个线程池用来让学生们“做作业”\n        ExecutorService exec = Executors.newFixedThreadPool(STUDENT_SIZE);\n         for ( int i = 0; i < STUDENT_SIZE; i++) {\n               //初始化学生的姓名和做题时间\n               students.put( new Student( \"学生\" + (i + 1), 3000 + r.nextInt(10000)));\n        }\n        //开始做题\n        while(! students.isEmpty()){\n               exec.execute( students.take());\n        }\n         exec.shutdown();\n  }\n}\n```\n我们看一下运行结果：\n\n```\n学生2 交卷,用时3\n学生1 交卷,用时5\n学生5 交卷,用时7\n学生4 交卷,用时8\n学生3 交卷,用时11\n```\n通过运行结果我们可以发现，每个学生在指定开始时间到达之后就会“交卷”（取决于getDelay()方法），并且是先做完的先交卷（取决于compareTo()方法）。\n\n\n### 4.3 LinkedBlockingQueue\n\nLinkedBlockingQueue阻塞队列大小的配置是可选的，如果我们初始化时指定一个大小，它就是有边界的，如果不指定，它就是无边界的。说是无边界，其实是采用了默认大小为Integer.MAX_VALUE的容量 。它的内部实现是一个链表。\n\n和ArrayBlockingQueue一样，LinkedBlockingQueue 也是以先进先出的方式存储数据，最新插入的对象是尾部，最新移出的对象是头部。下面是一个初始化和使LinkedBlockingQueue的例子：\n```\nBlockingQueue<String> unbounded = new LinkedBlockingQueue<String>();\nBlockingQueue<String> bounded   = new LinkedBlockingQueue<String>(1024);\nbounded.put(\"Value\");\nString value = bounded.take();\n```\n\n\n### 4.4 PriorityBlockingQueue\n\nPriorityBlockingQueue是一个没有边界的队列，它的排序规则和 java.util.PriorityQueue一样。需要注意，PriorityBlockingQueue中允许插入null对象。\n\n所有插入PriorityBlockingQueue的对象必须实现 java.lang.Comparable接口，队列优先级的排序规则就是按照我们对这个接口的实现来定义的。\n\n另外，我们可以从PriorityBlockingQueue获得一个迭代器Iterator，但这个迭代器并不保证按照优先级顺序进行迭代。\n\n下面我们举个例子来说明一下，首先我们定义一个对象类型，这个对象需要实现Comparable接口：\n\n```\npublic class PriorityElement implements Comparable<PriorityElement> {\nprivate int priority;//定义优先级\nPriorityElement(int priority) {\n    //初始化优先级\n    this.priority = priority;\n}\n@Override\npublic int compareTo(PriorityElement o) {\n    //按照优先级大小进行排序\n    return priority >= o.getPriority() ? 1 : -1;\n}\npublic int getPriority() {\n    return priority;\n}\npublic void setPriority(int priority) {\n    this.priority = priority;\n}\n@Override\npublic String toString() {\n    return \"PriorityElement [priority=\" + priority + \"]\";\n}\n}\n```\n然后我们把这些元素随机设置优先级放入队列中\n\n```\npublic class PriorityBlockingQueueExample {\npublic static void main(String[] args) throws InterruptedException {\n    PriorityBlockingQueue<PriorityElement> queue = new PriorityBlockingQueue<>();\n    for (int i = 0; i < 5; i++) {\n        Random random=new Random();\n        PriorityElement ele = new PriorityElement(random.nextInt(10));\n        queue.put(ele);\n    }\n    while(!queue.isEmpty()){\n        System.out.println(queue.take());\n    }\n}\n}\n```\n\n看一下运行结果：\n```\nPriorityElement [priority=3]\nPriorityElement [priority=4]\nPriorityElement [priority=5]\nPriorityElement [priority=8]\nPriorityElement [priority=9]\n\n```\n\n### 4.5 SynchronousQueue\n\nSynchronousQueue队列内部仅允许容纳一个元素。当一个线程插入一个元素后会被阻塞，除非这个元素被另一个线程消费。\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/java/BlockingQueue.md b/docs/learn/java/BlockingQueue.md
--- a/docs/learn/java/BlockingQueue.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/java/BlockingQueue.md	(date 1655373430547)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/tools/disruptor/README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: auto\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\nsidebarDepth: 3\ntitle: Disruptor高性能队列\npassword: 123\nicon: zuanshi\n---\n\n::: info 介绍\nDisruptor是英国外汇交易公司LMAX开发的一个高性能队列，研发的初衷是解决内存队列的延迟问题。与Kafka、RabbitMQ用于服务间的消息队列不同，disruptor一般用于线程间消息的传递。基于Disruptor开发的系统单线程能支撑每秒600万订单。\n\ndisruptor适用于多个线程之间的消息队列，`作用与ArrayBlockingQueue有相似之处`，但是disruptor从功能、性能都远好于ArrayBlockingQueue，当多个线程之间传递大量数据或对性能要求较高时，可以考虑使用disruptor作为ArrayBlockingQueue的替代者。\n官方也对disruptor和ArrayBlockingQueue的性能在不同的应用场景下做了对比，目测性能只有有5~10倍左右的提升。\n:::\n\n\n## 一、Disruptor的好处\n\n通过前面的介绍我们知道Disruptor作用与ArrayBlockingQueue类似,适用于多个线程之间的消息队列。为什么呢?\n因为Java中的队列就以BlockingQueue为例子,从命名上就能看出是一个阻塞的队列。当多线程的环境下会进行加锁。所以导致了性能不高，而Disruptor的设计\n非常的巧妙,他形成了一个环形队列。通过消除锁,从而提高了性能。\n\n[如何你还不了解Queue,请点这里✈️](/learn/java/BlockingQueue/)\n\nLog4j2 异步输出，在使用了Disruptor的提升如下图。来源[log4j2官网](https://logging.apache.org/log4j/2.x/performance.html)\n\n![](https://img.springlearn.cn/blog/learn_1653013607000.png)\n\n\n## 二、为什么这么快\n\n这里涉及到的知识点比较多,如果想学性能优化的同学可以去看看。可以学习里面的设计思想和优化的方向。\n\n[Disruptor详解](https://www.jianshu.com/p/bad7b4b44e48)\n\n[伪共享概念](/learn/java/Contended/)\n\n## 三、如何使用\n\n```xml \n        <dependency>\n            <groupId>com.lmax</groupId>\n            <artifactId>disruptor</artifactId>\n            <version>3.4.2</version>\n        </dependency>\n```\n\n## 3.1 定义Disruptor\n\n```java \n        //指定RingBuffer大小,\n        //必须是2的N次方\n        int bufferSize = 1024;\n\n        //构建Disruptor\n        Disruptor<LongEvent> disruptor\n                = new Disruptor<>(\n                LongEvent::new,\n                bufferSize,\n                DaemonThreadFactory.INSTANCE);\n```\n\n## 3.2 定义事件处理器\n\n```java \n        //注册事件处理器\n        disruptor.handleEventsWith(\n                (event, sequence, endOfBatch) ->\n                        System.out.println(\"E: \" + event));\n```\n\n## 3.3 生产数据\n\n```java \n        //启动Disruptor\n        disruptor.start();\n\n        //获取RingBuffer\n        RingBuffer<LongEvent> ringBuffer\n                = disruptor.getRingBuffer();\n        //生产Event\n        ByteBuffer bb = ByteBuffer.allocate(8);\n        for (long l = 0; l < 10; l++) {\n            bb.putLong(0, l);\n            //生产者生产消息\n            ringBuffer.publishEvent(\n                    (event, sequence, buffer) ->\n                            event.setValue(buffer.getLong(0)), bb);\n        }\n```\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/tools/disruptor/README.md b/docs/learn/tools/disruptor/README.md
--- a/docs/learn/tools/disruptor/README.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/tools/disruptor/README.md	(date 1655373430590)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: auto
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/blog/hexo/README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: Hexo\n---\n\n\n:::info\nHexo的风格个人感觉类似于QQ空间,属于自己的私人领地。文章比较琐碎,不太适合专题类、系列类的文档,其次是对Markdown的支持比较一般,\n部分主体支持代码高亮等功能。\n好处是简单,小编的第一个博客空间就是基于Hexo。目前也在维护中。\n:::\n\n## 一、[Hexo](https://hexo.io/zh-cn/)\n\n\n[![](https://img.shields.io/badge/Hexo-%E7%A4%BA%E4%BE%8B-green)](https://blog.springlearn.cn/)\n\n\n`Hexo` 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。\n\n## 二、安装\n\n### 2.1 安装前提\n\n安装 Hexo 相当简单，只需要先安装下列应用程序即可：\n\n- Node.js (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)\n- Git\n- npm\n\n### 2.2 安装\n\n首先利用 `npm` 下载 \n\n```bash\nnpm install -g hexo-cli;\n\nmdkir myblog;\n\ncd myblog;\n\nhexo init;\n```\n\n\n## 三、使用\n\n`hexo` 的命令非常简单，小编用了很多年，基本上只有2个。你知道是哪两个吗? \n\n### 3.1 new 新建文章\n\n`$ hexo new [layout] <title>`\n\n- layout 是博客布局，基本不会用\n- title 就是博客的名字\n\n### 3.2 generate 文章编译\n\n生成静态文件。\n\n`$ hexo generate`\n\n该命令可以简写为：\n\n`$ hexo g`\n\n### 3.3 server 本地运行\n\n启动服务器,本地运行\n\n`$ hexo server`\n\n### 3.4 deploy 远程部署\n\n部署远程\n\n`$ hexo deploy`\n\n该命令可以简写为：\n\n`$ hexo d`\n\n### 3.5 clean 清理缓存\n\n`$ hexo clean`\n\n清除缓存文件 (db.json) 和已生成的静态文件 (public)。\n\n在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。\n\n### 3.6 version\n\n`$ hexo version`\n\n显示 Hexo 版本。\n\n\n## 四、部署\n\n`hexo` 的配置文件都在根目录下的 `_config.yml` 文件下。如果要部署远程，非常简单。\n\n```yml\ndeploy:\n    type: git\n    repo:\n#      可以使用github    \n#      github: https://github.com/lxchinesszz/lxchinesszz.github.io.git\n      coding: https://e.coding.net/lxchinesszz/lxchinesszz.git\n    branch: master\n```\n\n\n- 1. 这里需要注意，如果使用github部署, 仓库的名字是有讲究的。名字要跟github的账户名前缀一直。\n`lxchinesszz.github.io`\n- 2. 打开设置要配置一下域名，如果不配置域名默认就是 `https://lxchinesszz.github.io/`\n\n![](https://img.springlearn.cn/blog/learn_1640502249000.png)\n\n### 4.1 本地部署\n\n`hexo s`\n\n### 4.2 远程部署\n\n`hexo g -d` \n\n或者是\n\n`hexo g`  + `hexo d`\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/blog/hexo/README.md b/docs/learn/blog/hexo/README.md
--- a/docs/learn/blog/hexo/README.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/blog/hexo/README.md	(date 1655373430750)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/project/jmvn/jmvn-init.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: true\nfooter: true\nbacktotop: true\ntitle: 创建项目\n---\n\n::: tip jmvn init\n快到你无法想象，丝滑的感觉\n:::\n\n## 使用命令快速创建项目\n\n你可以方便的使用工具创建基于SpringBoot的Maven多模块应用，如下示例。\n\n![](https://img.springlearn.cn/learn_600dd8ab8ca8e139c8bc37f5fc1b5801.gif)\n\n项目创建后会自动生成一个配置文件。默认项目的结构如下。\n\n![](https://img.springlearn.cn/blog/learn_1650473598000.png)\n\n```json\n{\n  \"namespace\":[\n    {\n      \"type\":\"web\",\n      \"path\":\"example/example-web/src/main/java/com/github/example/web/\",\n      \"packagePath\":\"com/github/example/web\"\n    },\n    {\n      \"type\":\"service\",\n      \"path\":\"example/example-service/src/main/java/com/github/example/service/\",\n      \"packagePath\":\"com/github/example/service\"\n    },\n    {\n      \"type\":\"domain\",\n      \"path\":\"example/example-domain/src/main/java/com/github/example/domain/\",\n      \"packagePath\":\"com/github/example/domain\"\n    },\n    {\n      \"type\":\"dal\",\n      \"path\":\"example/example-dal/src/main/java/com/github/example/dal/\",\n      \"packagePath\":\"com/github/example/dal\"\n    },\n    {\n      \"type\":\"integration\",\n      \"path\":\"example/example-integration/src/main/java/com/github/example/integration/\",\n      \"packagePath\":\"com/github/example/integration\"\n    },\n    {\n      \"type\":\"config\",\n      \"path\":\"example/example-config/src/main/java/com/github/example/config/\",\n      \"packagePath\":\"com/github/example/config\"\n    },\n    {\n      \"type\":\"common\",\n      \"path\":\"example/example-common/src/main/java/com/github/example/common/\",\n      \"packagePath\":\"com/github/example/common\"\n    }\n  ],\n  \"config\":{\n\n  },\n  \"dbConfig\":{\n    \"host\":\"\",\n    \"user\":\"\",\n    \"password\":\"\",\n    \"database\":\"\"\n  },\n  \"models\":[\n    {\n      \"suffix\":\"DO\",\n      \"tableName\":[\n\n      ],\n      \"path\":\"\"\n    }\n  ]\n}\n```\n\n## 手动添加配置文件\n\n当你项目已经创建完成，但是想要使用的情况下, 你是可以通过配置的方式来支持的。\n\n首先在项目的根目录创建文件 `.jmvn.json`\n\n\n```json\n{\n  \"namespace\": [\n  ],\n  \"config\": {},\n  \"dbConfig\": {\n    \"host\": \"10.*.*.8\",\n    \"user\": \"root\",\n    \"password\": \"123456\",\n    \"database\": \"test\"\n  },\n  \"models\": [\n    {\n      \"suffix\": \"DO\",\n      \"tableName\": [\n        \"user\",\n        \"user_detail\"\n      ],\n      \"path\": \"example-dal/src/main/java/com/example/dal/entity\"\n    }\n  ]\n}\n```\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/project/jmvn/jmvn-init.md b/docs/learn/project/jmvn/jmvn-init.md
--- a/docs/learn/project/jmvn/jmvn-init.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/project/jmvn/jmvn-init.md	(date 1655373430375)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/blog/docsify/README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: Docsify\n---\n\n## 一、docsify\n\n`Hexo` 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。\n[hexo](https://hexo.io/zh-cn/)\n\n## 二、安装\n\n### 2.1 安装前提\n\n安装 Hexo 相当简单，只需要先安装下列应用程序即可：\n\n- Node.js (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)\n- Git\n- npm\n\n### 2.2 安装\n\n首先利用 `npm` 下载 \n\n```bash\nnpm install -g hexo-cli;\n\nmdkir myblog;\n\ncd myblog;\n\nhexo init;\n```\n\n\n## 三、使用\n\n`hexo` 的命令非常简单，小编用了很多年，基本上只有2个。你知道是哪两个吗? \n\n### 3.1 new 新建文章\n\n`$ hexo new [layout] <title>`\n\n- layout 是博客布局，基本不会用\n- title 就是博客的名字\n\n### 3.2 generate 文章编译\n\n生成静态文件。\n\n`$ hexo generate`\n\n该命令可以简写为：\n\n`$ hexo g`\n\n### 3.3 server 本地运行\n\n启动服务器,本地运行\n\n`$ hexo server`\n\n### 3.4 deploy 远程部署\n\n部署远程\n\n`$ hexo deploy`\n\n该命令可以简写为：\n\n`$ hexo d`\n\n### 3.5 clean 清理缓存\n\n`$ hexo clean`\n\n清除缓存文件 (db.json) 和已生成的静态文件 (public)。\n\n在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。\n\n### 3.6 version\n\n`$ hexo version`\n\n显示 Hexo 版本。\n\n\n## 四、部署\n\n`hexo` 的配置文件都在根目录下的 `_config.yml` 文件下。如果要部署远程，非常简单。\n\n```yml\ndeploy:\n    type: git\n    repo:\n#      可以使用github    \n#      github: https://github.com/lxchinesszz/lxchinesszz.github.io.git\n      coding: https://e.coding.net/lxchinesszz/lxchinesszz.git\n    branch: master\n```\n\n\n- 1. 这里需要注意，如果使用github部署, 仓库的名字是有讲究的。名字要跟github的账户名前缀一直。\n`lxchinesszz.github.io`\n- 2. 打开设置要配置一下域名，如果不配置域名默认就是 `https://lxchinesszz.github.io/`\n\n![](https://img.springlearn.cn/blog/learn_1640502249000.png)\n\n### 4.1 本地部署\n\n`hexo s`\n\n### 4.2 远程部署\n\n`hexo g -d` \n\n或者是\n\n`hexo g`  + `hexo d`\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/blog/docsify/README.md b/docs/learn/blog/docsify/README.md
--- a/docs/learn/blog/docsify/README.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/blog/docsify/README.md	(date 1655373430474)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/project/jmvn/jmvn-install.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: true\nfooter: true\nbacktotop: true\ntitle: 数据模型安装\n---\n\n::: tip jmvn instll 数据安装\n`jmvn` 一个好用的功能就是支持数据安装，这个功能是我比较喜欢的。因为在项目\n中开发过程中，经常会出现,表结构进行变更，可能是增加些表注释，增加个字段。这个时候就要同步来\n修改数据模型。是比较繁琐的。当你尝试过 `jmvn install` 功能后，这个问题就能彻底解决了。\n只需要运行 `jmvn install` 命令，数据模型就会同步更改。\n:::\n\n\n\n\n## 配置如下\n\n在你的项目 `.jmvn.json` 中添加如下。`jmvn` 会读取 `dbConfig` 中数据库的配置。\n写入到 `models` 中指定的目录 `path`。\n\n```json \n{\n  \"namespace\": [\n  ],\n  \"config\": {},\n  \"dbConfig\": {\n    \"host\": \"10.*.*.8\",\n    \"user\": \"root\",\n    \"password\": \"123456\",\n    \"database\": \"test\"\n  },\n  \"models\": [\n    {\n      \"suffix\": \"DO\",\n      \"tableName\": [\n        \"user\",\n        \"user_detail\"\n      ],\n      \"path\": \"example-dal/src/main/java/com/example/dal/entity\"\n    }\n  ]\n}\n```\n\n你可以在models中使用suffix添加Java文件的后缀名。\neg: user表，最终写成java文件为 UserDO\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/project/jmvn/jmvn-install.md b/docs/learn/project/jmvn/jmvn-install.md
--- a/docs/learn/project/jmvn/jmvn-install.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/project/jmvn/jmvn-install.md	(date 1655373430539)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/blog/vuepress/README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nicon: ability\nbacktotop: true\ntitle: Vuepress\n---\n\n:::info Vuepress\nVuepress 从名字上看就知道跟Vue关系不一般,是的它是基于Vue进行开发的。Vue的官网也是使用这个框架来做的。他的好处是比较适合\n专题类文章, 对Markdown语法完全支持,通知支持代码高亮,比较适合技术类文章, 但是稍微有些难度, 适合有点经验的开发同学。\n:::\n\n## 一、Vuepress\n\n`Hexo` 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。\n[hexo](https://hexo.io/zh-cn/)\n\n## 二、像数 1, 2, 3 一样容易\n\n这里是Vuepress原生主题,比较简单。\n\n```\n# 安装\nyarn global add vuepress # 或者：npm install -g vuepress\n\n# 新建一个 markdown 文件\necho '# Hello VuePress!' > README.md\n\n# 开始写作\nvuepress dev .\n\n# 构建静态文件\nvuepress build .\n```\n\n::: warning\n注意\n请确保你的 Node.js 版本 >= 8.6。\n:::\n\n## 三、主题安装\n\n这里只推荐一个主题,本网站的主题也是使用的这个。\n\n### 3.1 [vuepress-theme-hope](https://vuepress-theme-hope.github.io/zh/guide/get-started/install/#)\n\n``` \nnpm init vuepress-theme-hope \n```\n\n注意目录一定要在.vuepress/config.js\n\n```js\n// .vuepress/config.js\nconst { config } = require(\"vuepress-theme-hope\");\n\nmodule.exports = config({\n  // your config here\n});\n```\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/blog/vuepress/README.md b/docs/learn/blog/vuepress/README.md
--- a/docs/learn/blog/vuepress/README.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/blog/vuepress/README.md	(date 1655373430163)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/project/jmvn/jmvn-export.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: true\nfooter: true\nbacktotop: true\ntitle: 数据模型导出\n---\n\n::: tip jmvn export 数据模型导出\n`jmvn` 另一个好用的功能就是数据导出，这个功能的主要用处是，在写技术方案时候将数据模型输出到文档中。支持markdown语法。\n:::\n\n\n## 自动读取配置进行导出\n\n如果你已经在配置文件中了dbConfig相关信息，则会自动读取配置信息。你只需要输入要导出的表名即可。\n\n```json\n{\n  \"namespace\": [\n  ],\n  \"config\": {},\n  \"dbConfig\": {\n    \"host\": \"10.80.20.8\",\n    \"user\": \"abm_dev\",\n    \"password\": \"pOj*4Z%^izKy0o23o8aH\",\n    \"database\": \"pms_dev\"\n  }\n}\n```\n\n## 根据命令提示完成导出\n\n如果你没有在配置文件中添加dbConfig相关信息，请根据命令提示来进行完成导出。\n\n![](https://img.springlearn.cn/learn_53218775085b88f319e37ca3811c5cd7.gif)\n\n## 纯命令方式导出\n\n如果你在配置文件中已经添加了dbConfig相关信息，但是又不想使用这个进行导出。则可以在命令后添加 `-c` 以强制使用输入参数来进行导出。\n\n``` \njmvn export -c -m -h 10.80.20.8 -u abm_dev -p 'pOj*4Z%^izKy0o23o8aH' -t replenish_order -db pms_dev\n```\n\n### 查看导出帮助文档\n\n``` \n➜ jmvn help export                                                                                   \nJMVN CLI v1.0.6\nUsage: jmvn export [options]\n\n导出数据模型 (支持命令行模式 & 交互模式)\n\nOptions:\n  -c, --commanded [String]  命令行模式运行\n  -m, --markdown [String]   导出markdown格式\n  -h, --host [String]       数据库[host]\n  -u, --user [String]       数据库登陆用户\n  -p, --password [String]   登陆密码(明文请注意安全)\n  -t, --tables [String]     要导出的表模型(支持,分隔)\n  -db, --database [String]  指定要导出的库\n  --help                    display help for command\n\n```\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/project/jmvn/jmvn-export.md b/docs/learn/project/jmvn/jmvn-export.md
--- a/docs/learn/project/jmvn/jmvn-export.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/project/jmvn/jmvn-export.md	(date 1655373430381)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/tools/druid/README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\nsidebarDepth: 3\ntitle: Druid SQL解析\nicon: zuanshi\n---\n\n![](https://img.springlearn.cn/blog/learn_1648308606000.png)\n\n:::info\n本篇主要学习Druid 对Sql的语法解析。学习完之后,我们可以对任意sql进行解析,同时也可以基于AST语法树来生成sql语句。\n:::\n\n[![](https://img.shields.io/badge/SQL%E8%A7%A3%E6%9E%90-sql--parse--example-green)](https://github.com/lxchinesszz/sql-parse-example)\n\n## 一、AST\n\nAST是abstract syntax tree的缩写，也就是抽象语法树。和所有的Parser一样，Druid Parser会生成一个抽象语法树。\n\n\n在Druid中，AST节点类型主要包括SQLObject、SQLExpr、SQLStatement三种抽象类型。\n\n```java \n\ninterface SQLObject {}\ninterface SQLExpr extends SQLObject {}\ninterface SQLStatement extends SQLObject {}\n\ninterface SQLTableSource extends SQLObject {}\nclass SQLSelect extends SQLObject {}\nclass SQLSelectQueryBlock extends SQLObject {}\n```\n\n## 二、语法树解析\n\n## 2.1 核心类介绍\n\n### 2.1.1 SQLStatemment DQL & DML顶级抽象\n\n- DQL 数据查询语言 select\n- DML 数据操纵语言 insert update delete\n\n最常用的Statement当然是SELECT/UPDATE/DELETE/INSERT，他们分别是\n\n|核心类|说明|\n|:--|:--|\n|SQLSelectStatement|查询语句|\n|SQLUpdateStatement|更新语句|\n|SQLDeleteStatement|删除语句|\n|SQLInsertStatement|新增语句|\n\n```java \n@Test\npublic void statement() {\n    // 以下全部 true\n    System.out.println(SQLUtils.parseSingleMysqlStatement(\"select * from users\") instanceof SQLSelectStatement);\n    System.out.println(SQLUtils.parseSingleMysqlStatement(\"insert into users(id,name,age) values (1,'孙悟空',500)\") instanceof SQLInsertStatement);\n    System.out.println(SQLUtils.parseSingleMysqlStatement(\"update users set name = '唐僧' where id = 1 \") instanceof SQLUpdateStatement);\n    System.out.println(SQLUtils.parseSingleMysqlStatement(\"delete from users where id = 1\") instanceof SQLDeleteStatement);\n}\n```\n\n### 2.1.2 SQLSelect SQL查询\n\nSQLSelectStatement包含一个SQLSelect，SQLSelect包含一个SQLSelectQuery。SQLSelectQuery有主要的两个派生类，\n分别是SQLSelectQueryBlock(单表sql查询)和SQLUnionQuery([union查询](https://www.w3school.com.cn/sql/sql_union.asp))。\n\n```java \n    /**\n     * SQLSelectStatement包含一个SQLSelect，SQLSelect包含一个SQLSelectQuery。SQLSelectQuery有主要的两个派生类，\n     * 分别是SQLSelectQueryBlock(单表sql查询)和SQLUnionQuery(联合查询)。\n     */\n    @Test\n    public void SQLSelectQuery() {\n        // true\n        System.out.println(parseSQLSelectQuery(\"select * from users\") instanceof SQLSelectQueryBlock);\n        // true\n        System.out.println(parseSQLSelectQuery(\"select name from users union select name from school\") instanceof SQLUnionQuery);\n    }\n\n    public SQLSelectQuery parseSQLSelectQuery(String sql) {\n        SQLStatement sqlStatement = SQLUtils.parseSingleMysqlStatement(sql);\n        SQLSelectStatement sqlSelectStatement = Utils.cast(sqlStatement, SQLSelectStatement.class);\n        SQLSelect select = sqlSelectStatement.getSelect();\n        return select.getQuery();\n    }\n```\n\n### 2.1.3 SQLExpr\n\nSQLExpr 是有几个实现类的。\n\n\n```sql \nselect id,name,age from users where id = 1 and name = '孙悟空';\n\nselect u.id, u.name from users as u where id = 1 and name = ?;\n```\n\n\n|核心类|举例|说明|适用范围|快速记忆|\n|:--|:--|:--|:--|:--|\n|SQLIdentifierExpr|id,name,age|SQLIdentifierExpr|查询字段或者where条件|唯一标记|\n|SQLPropertyExpr|u.id,u.name|区别于SQLIdentifierExpr,适用于有别名的场景; SQLPropertyExpr.name = id, SQLPropertyExpr.owner = SQLIdentifierExpr = u）|查询字段或者where条件|有别名就是它|\n|SQLBinaryOpExpr|id = 1, id > 5 |SQLBinaryOpExpr(left = SQLIdentifierExpr = id ,right = SQLValuableExpr = 1)|where条件|有操作符就是它|\n|SQLVariantRefExpr|id = ?|变量|where条件|有变量符就是它|\n|SQLIntegerExpr|id = 1|数字类型|值类型| - |\n|SQLCharExpr|name = '孙悟空'|字符类型|值类型| - |\n\n#### 2.1.3.1 SQLBinaryOpExpr\n\n```java \n    /**\n     * 操作符相关: SQLBinaryOpExpr\n     */\n    @Test\n    public void SQLBinaryOpExpr() {\n        String sql = \"select * from users where id > 1 and age = 18\";\n        SQLSelectQuery sqlSelectQuery = Utils.parseSQLSelectQuery(sql);\n        SQLSelectQueryBlock selectQueryBlock = Utils.cast(sqlSelectQuery, SQLSelectQueryBlock.class);\n        SQLExpr where = selectQueryBlock.getWhere();\n        List<SQLObject> conditions = where.getChildren();\n        // [id > 1 , age = 18] 出现了操作符所以是SQLBinaryOpExpr\n        for (SQLObject condition : conditions) {\n            SQLBinaryOpExpr conditionExpr = Utils.cast(condition, SQLBinaryOpExpr.class);\n            SQLBinaryOperator operator = conditionExpr.getOperator();\n            SQLIdentifierExpr conditionColumn = Utils.cast(conditionExpr.getLeft(), SQLIdentifierExpr.class);\n            SQLValuableExpr conditionColumnValue = Utils.cast(conditionExpr.getRight(), SQLValuableExpr.class);\n            Utils.print(\"条件字段:{},操作符号:{},条件值:{}\", conditionColumn.getName(), operator.name, conditionColumnValue);\n        }\n    }\n```\n\n#### 2.1.3.2 SQLVariantRefExpr\n\n```java \n    @Test\n    public void SQLVariantRefExpr() {\n        String sql = \"select * from users where id = ? and name = ?\";\n        SQLSelectQuery sqlSelectQuery = Utils.parseSQLSelectQuery(sql);\n        SQLSelectQueryBlock selectQueryBlock = Utils.cast(sqlSelectQuery, SQLSelectQueryBlock.class);\n        SQLExpr where = selectQueryBlock.getWhere();\n        List<SQLObject> conditions = where.getChildren();\n        // [id = ?] 出现了变量符,所以要用SQLVariantRefExpr\n        for (SQLObject condition : conditions) {\n            SQLBinaryOpExpr conditionExpr = Utils.cast(condition, SQLBinaryOpExpr.class);\n            SQLBinaryOperator operator = conditionExpr.getOperator();\n            SQLIdentifierExpr conditionColumn = Utils.cast(conditionExpr.getLeft(), SQLIdentifierExpr.class);\n            SQLVariantRefExpr conditionColumnValue = Utils.cast(conditionExpr.getRight(), SQLVariantRefExpr.class);\n            int index = conditionColumnValue.getIndex();\n            Utils.print(\"条件字段:{},操作符号:{},索引位:{}\", conditionColumn.getName(), operator.name, index);\n        }\n    }\n```\n\n### 2.1.4 SQLTableSource\n\n常见的SQLTableSource包括SQLExprTableSource、SQLJoinTableSource、SQLSubqueryTableSource、SQLWithSubqueryClause.Entry\n\n\n|核心类|举例|说明|快速记忆|\n|:--|:--|:--|:--|:--|\n|SQLExprTableSource|select * from emp where i = 3| name = SQLIdentifierExpr = emp| 单表查询 |\n|SQLJoinTableSource|select * from emp e inner join org o on e.org_id = o.id| left = SQLExprTableSource(emp e),right = SQLExprTableSource(org o), condition = SQLBinaryOpExpr(e.org_id = o.id) | join 查询使用 |\n|SQLSubqueryTableSource|select * from (select * from temp) a|from(...)是一个SQLSubqueryTableSource|子查询语句|\n|SQLWithSubqueryClause| WITH RECURSIVE ancestors AS (SELECT * FROM org UNION SELECT f.* FROM org f, ancestors a WHERE f.id = a.parent_id ) SELECT * FROM ancestors; |ancestors AS (...) 是一个SQLWithSubqueryClause.Entry|with|\n\n\n## 2.2 SQL语句解析示例\n\n### 2.2.1 解析 Where\n\n注意如果条件语句中只有一个条件,那么where就是一个 `SQLBinaryOpExpr`。\n当条件大于2个,使用 `where.getChildren()`\n\n```java \n    /**\n     * 判断where要\n     * 1. 注意是SQLBinaryOpExpr(id = 1) or (u.id = 1) 需要注意是否使用了别名<br>\n     * 2. 注意如果只有一个查询添加 where本身就是一个SQLBinaryOpExpr，如果是多个就要用 where.getChildren()<br></>\n     * 如果有别名: SQLPropertyExpr(name = id , ownerName = u)<br>\n     * 如果没别名: SQLIdentifierExpr(name = id) <br></>\n     * 值对象: SQLValuableExpr\n     *\n     * @param where 条件对象\n     */\n    public static void parseWhere(SQLExpr where) {\n        if (where instanceof SQLBinaryOpExpr) {\n            parseSQLBinaryOpExpr(cast(where, SQLBinaryOpExpr.class));\n        } else {\n            List<SQLObject> childrenList = where.getChildren();\n            for (SQLObject sqlObject : childrenList) {\n                // 包含了 left 和 right\n                SQLBinaryOpExpr conditionBinary = cast(sqlObject, SQLBinaryOpExpr.class);\n                parseSQLBinaryOpExpr(conditionBinary);\n            }\n        }\n\n    }\n    \n     public static void parseSQLBinaryOpExpr(SQLBinaryOpExpr conditionBinary) {\n        SQLExpr conditionExpr = conditionBinary.getLeft();\n        SQLExpr conditionValueExpr = conditionBinary.getRight();\n        // 左边有别名所以是SQLPropertyExpr\n        if (conditionExpr instanceof SQLPropertyExpr) {\n            SQLPropertyExpr conditionColumnExpr = cast(conditionExpr, SQLPropertyExpr.class);\n            // 右边根据类型进行转换 id是SQLIntegerExpr name是SQLCharExpr\n            SQLValuableExpr conditionColumnValue = cast(conditionValueExpr, SQLValuableExpr.class);\n            print(\"条件列名:{},条件别名:{},条件值:{}\", conditionColumnExpr.getName(), conditionColumnExpr.getOwnernName(), conditionColumnValue);\n        }\n        // 如果没有别名\n        if (conditionExpr instanceof SQLIdentifierExpr) {\n            SQLIdentifierExpr conditionColumnExpr = cast(conditionExpr, SQLIdentifierExpr.class);\n            SQLValuableExpr conditionColumnValue = cast(conditionValueExpr, SQLValuableExpr.class);\n            print(\"条件列名:{},条件值:{}\", conditionColumnExpr.getName(), conditionColumnValue);\n        }\n    }\n```\n\n### 2.2.2 解析 SQLSelectItem\n\n解析查询的列信息\n\n```java \n    /**\n     * 解析查询字段,注意是否使用了别名.u.id as userId, u.name as userName, u.age as userAge<br>\n     * userId（sqlSelectItem.getAlias）<br>\n     * 如果有别名: u.id( id = SQLPropertyExpr.getName,u = SQLPropertyExpr.getOwnernName)<br>\n     * 如果没别名: id(id = SQLIdentifierExpr.name)\n     *\n     * @param selectColumnList 查询字段\n     */\n    private void parseSQLSelectItem(List<SQLSelectItem> selectColumnList) {\n        for (SQLSelectItem sqlSelectItem : selectColumnList) {\n            // u.id as userId(selectColumnAlias)\n            String selectColumnAlias = sqlSelectItem.getAlias();\n            // u.id = SQLPropertyExpr\n            SQLExpr expr = sqlSelectItem.getExpr();\n            if (expr instanceof SQLPropertyExpr) {\n                SQLPropertyExpr selectColumnExpr = cast(expr, SQLPropertyExpr.class);\n                print(\"列名:{},别名:{},表别名:{}\", selectColumnExpr.getName(), selectColumnAlias, selectColumnExpr.getOwnernName());\n            }\n            if (expr instanceof SQLIdentifierExpr) {\n                SQLIdentifierExpr selectColumnExpr = cast(expr, SQLIdentifierExpr.class);\n                print(\"列名:{},别名:{}\", selectColumnExpr.getName(), selectColumnAlias);\n            }\n        }\n    }\n```\n\n### 2.2.3 解析 SQLUpdateSetItem\n\n```java \n    @Test\n    public void SQLUpdateStatement() {\n        SQLStatement sqlStatement = SQLUtils.parseSingleMysqlStatement(\"update users u set u.name = '唐僧',age = 18 where u.id = 1 \");\n        SQLUpdateStatement sqlUpdateStatement = Utils.cast(sqlStatement, SQLUpdateStatement.class);\n        List<SQLUpdateSetItem> setItems = sqlUpdateStatement.getItems();\n        for (SQLUpdateSetItem setItem : setItems) {\n            SQLExpr column = setItem.getColumn();\n            if (column instanceof SQLPropertyExpr) {\n                SQLPropertyExpr sqlPropertyExpr = Utils.cast(column, SQLPropertyExpr.class);\n                SQLExpr value = setItem.getValue();\n                Utils.print(\"column:{},列owner:{},value:{}\", sqlPropertyExpr.getName(), sqlPropertyExpr.getOwnernName(), value);\n            }\n            if (column instanceof SQLIdentifierExpr) {\n                SQLExpr value = setItem.getValue();\n                Utils.print(\"column:{},value:{}\", column, value);\n            }\n        }\n        SQLExpr where = sqlUpdateStatement.getWhere();\n        Utils.startParse(\"解析where\", Utils::parseWhere, where);\n    }\n```\n\n### 2.2.4 解析 SQLLimit\n\n```java \n    /**\n     * 偏移量,只有2个值\n     *\n     * @param limit 限制\n     */\n    private void parseLimit(SQLLimit limit) {\n        // 偏移量\n        SQLExpr offset = limit.getOffset();\n        // 便宜数量\n        SQLExpr rowCount = limit.getRowCount();\n        print(\"偏移量:{},偏移数量:{}\", offset, rowCount);\n    }\n```\n\n\n### 2.2.5 解析 SQLSelectGroupBy\n\n```java \n    @Test\n    public void groupBy() {\n        SQLStatement sqlStatement = SQLUtils.parseSingleMysqlStatement(\"select name,count(1) as count from users group by name,age having count > 2\");\n        SQLSelectStatement selectStatement = Utils.cast(sqlStatement, SQLSelectStatement.class);\n        SQLSelect select = selectStatement.getSelect();\n        SQLSelectQueryBlock query = Utils.cast(select.getQuery(), SQLSelectQueryBlock.class);\n        SQLSelectGroupByClause groupBy = query.getGroupBy();\n        List<SQLExpr> items = groupBy.getItems();\n        for (SQLExpr item : items) {\n            // group by name\n            // group by age\n            SQLIdentifierExpr groupByColumn = Utils.cast(item, SQLIdentifierExpr.class);\n            Utils.print(\"group by {}\", groupByColumn);\n        }\n    }\n\n```\n### 2.2.6 解析 Having\n\n```java \n    @Test\n    public void having() {\n        SQLStatement sqlStatement = SQLUtils.parseSingleMysqlStatement(\"select name,count(1) as count from users group by name,age having count > 2\");\n        SQLSelectStatement selectStatement = Utils.cast(sqlStatement, SQLSelectStatement.class);\n        SQLSelect select = selectStatement.getSelect();\n        SQLSelectQueryBlock query = Utils.cast(select.getQuery(), SQLSelectQueryBlock.class);\n        SQLSelectGroupByClause groupBy = query.getGroupBy();\n        SQLExpr having = groupBy.getHaving();\n        // 因为只有一个条件,所以having就是SQLBinaryOpExpr\n        SQLBinaryOpExpr havingExpr = Utils.cast(having, SQLBinaryOpExpr.class);\n        // 没有使用别名,所以就是SQLIdentifierExpr\n        SQLExpr left = havingExpr.getLeft();\n        SQLIdentifierExpr leftExpr = Utils.cast(left, SQLIdentifierExpr.class);\n        // 数字类型就是\n        SQLExpr right = havingExpr.getRight();\n        SQLValuableExpr rightValue = Utils.cast(right, SQLValuableExpr.class);\n        SQLBinaryOperator operator = havingExpr.getOperator();\n        // left:count, operator:>,right:2\n        Utils.print(\"left:{}, operator:{},right:{}\", leftExpr.getName(), operator.name, rightValue.getValue());\n    }\n```\n\n## 三、语法树生成\n\n前面的内容如果都搞清楚了,那么我们就能对sql进行解析,通知可以修改sql解析后的语法树,同时再将修改后的语法树,重新转换成sql\n\n## 3.1 修改语法树\n\n### 3.1.1 增加一个条件\n\n```java \n    @Test\n    public void SQLDeleteStatement(){\n        SQLStatement sqlStatement = SQLUtils.parseSingleMysqlStatement(\"delete from users where id = 1\");\n        SQLDeleteStatement sqlDeleteStatement = Utils.cast(sqlStatement, SQLDeleteStatement.class);\n        sqlDeleteStatement.addCondition(SQLUtils.toSQLExpr(\"name = '孙悟空'\"));\n//        DELETE FROM users\n//        WHERE id = 1\n//        AND name = '孙悟空'\n        System.out.println(SQLUtils.toSQLString(sqlDeleteStatement));\n    }\n```\n\n### 3.1.2 修改一个条件值 \n\n将条件id = 1 修改成 id = 2\n\n```java \n    @Test\n    public void SQLDeleteStatement2(){\n        SQLStatement sqlStatement = SQLUtils.parseSingleMysqlStatement(\"delete from users where id = 1\");\n        SQLDeleteStatement sqlDeleteStatement = Utils.cast(sqlStatement, SQLDeleteStatement.class);\n        SQLExpr where = sqlDeleteStatement.getWhere();\n        SQLBinaryOpExpr sqlBinaryOpExpr = Utils.cast(where, SQLBinaryOpExpr.class);\n//        DELETE FROM users\n//        WHERE id = 2\n        sqlBinaryOpExpr.setRight(SQLUtils.toSQLExpr(\"2\"));\n        System.out.println(SQLUtils.toSQLString(sqlDeleteStatement));\n    }\n```\n\n## 四、Visitor模式\n\n访问者模式\n\n所有的AST节点都支持Visitor模式，需要自定义遍历逻辑，可以实现相应的ASTVisitorAdapter派生类\n\n```java \n    public static class CustomerMySqlASTVisitorAdapter extends MySqlASTVisitorAdapter {\n\n        private final Map<String, SQLTableSource> ALIAS_MAP = new HashMap<String, SQLTableSource>();\n\n        private final Map<String, SQLExpr> ALIAS_COLUMN_MAP = new HashMap<String, SQLExpr>();\n\n\n        public boolean visit(SQLExprTableSource x) {\n            String alias = x.getAlias();\n            ALIAS_MAP.put(alias, x);\n            return true;\n        }\n\n        @Override\n        public boolean visit(MySqlSelectQueryBlock x) {\n            List<SQLSelectItem> selectList = x.getSelectList();\n            for (SQLSelectItem sqlSelectItem : selectList) {\n                String alias = sqlSelectItem.getAlias();\n                SQLExpr expr = sqlSelectItem.getExpr();\n                ALIAS_COLUMN_MAP.put(alias, expr);\n            }\n            return true;\n        }\n\n        public Map<String, SQLTableSource> getAliasMap() {\n            return ALIAS_MAP;\n        }\n\n        public Map<String, SQLExpr> getAliasColumnMap() {\n            return ALIAS_COLUMN_MAP;\n        }\n    }\n\n    @Test\n    public void AliasVisitor() {\n        String sql = \"select u.id as userId, u.name as userName, age as userAge from users as u where u.id = 1 and u.name = '孙悟空' limit 2,10\";\n        // 解析SQL\n        SQLStatement sqlStatement = SQLUtils.parseSingleMysqlStatement(sql);\n        CustomerMySqlASTVisitorAdapter customerMySqlASTVisitorAdapter = new CustomerMySqlASTVisitorAdapter();\n        sqlStatement.accept(customerMySqlASTVisitorAdapter);\n        // 表别名:{u=users}\n        System.out.println(\"表别名:\" + customerMySqlASTVisitorAdapter.getAliasMap());\n        // 列别名{userName=u.name, userId=u.id, userAge=age}\n        System.out.println(\"列别名\" + customerMySqlASTVisitorAdapter.getAliasColumnMap());\n    }\n```\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/tools/druid/README.md b/docs/learn/tools/druid/README.md
--- a/docs/learn/tools/druid/README.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/tools/druid/README.md	(date 1655373430193)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/tools/guava/guava-cache.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: Guava-cache\n---\n\n![](https://img.springlearn.cn/blog/learn_1588264022000.png)\n\n**本篇主要是本地缓存代码实战，提供业务中常用的本地缓存使用代码片段(直接跳过看标题五)**\n\n:::info 写在前面\n常在业务系统中做开发,不会点高级知识点,有点不好意思了。在业务系统中，提高系统响应速度，提供系统高并发能力，其实方向很简单，三个方向,六个字而已: **缓存降级限流。**\n当然这是在排除代码质量非常差的情况，如果代码质量很差，都是while循环和高内存占用，那么其实再怎么做都于事无补。除非你有一个马云爸爸，性能不够，机器来凑嘛。阿里云前来支持(1000台机器够了吗?)\n:::\n\n![](https://cdn.nlark.com/yuque/0/2020/png/182855/1588128723239-12cbd329-ab03-4e8c-86be-fd63da9cb39f.png?x-oss-process=image%2Fresize%2Cw_1492)\n\n\n## 一、什么是Guava Cache\n\n```\n<dependency>\n    <groupId>com.google.guava</groupId>\n    <artifactId>guava</artifactId>\n    <version>29.0-jre</version>\n</dependency>\n```\n\n其实就是Google提供的一个开发工具包,里面有很多好用的Java开工具,比如我们本文将的Cache缓存能力。\n说到缓存,每个业务系统中现在都会用到缓存,常用的缓存数据库就是Redis和Memcache,这两款kv数据库最常用的场景就是当缓存使用，极其适合在微服务架构下做缓存使用。速度是极高的，但是跟本地缓存来比，还是算慢的，毕竟本地缓存其实就相当于一个Map集合，本地缓存获取没有网络IO。但是最大的缺点是每台服务器的本地缓存是不能共享的。所以如果要用分布式缓存就可以跳过了。因为本文将的本地缓存使用。\n\n\n说到底其实缓存我们就可以理解为是一个Map集合，不过生产中我们不能用Map来做缓存，除非是缓存的数据只有一点点一点点。否则如果数据量瞬时或者数据积累量很大，很容易就直接就把Map撑爆。导致内存溢出,服务宕机下线风险。 所以我们必须要对Map做控制。\n1. 控制数据量大小\n2. 控制数据生命周期\n3. 如果能做些数据命中率统计更好了\n\n\n对，以上就是Guava Cache已经为我们做好的能力了。我们只用使用就可以了\n\n\n## 二、什么场景适合缓存\n不长更新的数据都可以使用缓存，只要我们定时去刷新缓存获取最新的数据就可以了。\n注意: 凡是使用GuavaCache的地方都可以使用RedisCache,但是使用RedisCache的地方不一定可以使用GuavaCache。因为前面我们也说了Guava是本地缓存，不支持多服务器数据共享,如果要共享缓存数据直接用Redis是更好的选择。\n\n## 三、使用本地缓存,高并发会把机器打爆\n这个担心是逻辑思考的必然,使用缓存主要是提高系统响应效率的,如果用不过把机器搞爆就不好了。所以这种担心很有必要，但是只要弄清楚没参数或者它的实现原理就不用担心了。4和5是快速入门即代码片段，直接根据代码去做不会有问题。\n\n\n## 四、快速入门API\nCacheBuilder\n\n| 属性             | 作用             | 例子                                 |\n| ---------------- | ---------------- | ------------------------------------ |\n| removalListener  | 缓存移除的监听   | 对指定key的删除,做监听               |\n| maximumSize      | 设置最大缓存数量 | 当达到最大数量，会删除多余的缓存记录 |\n| expireAfterWrite | 设置过期时间     | 过期的缓存自动移除                   |\n| recordStats      | 统计信息         | 统计缓存命中率                       |\n\n### 1. 设置最大缓存数量\n\n```java\n    Cache<String,String> cache = CacheBuilder.newBuilder()\n                                 .maximumSize(2).build();\n    cache.put(\"key1\",\"value1\");\n    cache.put(\"key2\",\"value2\");\n    cache.put(\"key3\",\"value3\");\n    // 第一个key是null，因为指定缓存数量是2个，当超过就删除前面一条\n    System.out.println(\"第一个值:\" + cache.getIfPresent(\"key1\"));\n    System.out.println(\"第一个值:\" + cache.getIfPresent(\"key2\"));\n    System.out.println(\"第一个值:\" + cache.getIfPresent(\"key3\"));\n```\n\n### 2. 设置过期时间\n\n```java \n    Cache<String,String> cache = CacheBuilder.newBuilder()\n                                 .maximumSize(2)\n                                 .expireAfterWrite(3,TimeUnit.SECONDS)\n                                     .build();\n    cache.put(\"key1\",\"value1\");\n    int time = 1;\n    while(true){\n        System.out.println(\"第\" + time ++ \"次取到的key1的值为：\" + cache.getIfPresent(\"key1\"));\n        Thread.sleep(1000)\n    }\n```\n### 3. 统计命中率\n\n```java \n    Cache<String,String> cache = CacheBuilder.newBuilder()\n                                 .maximumSize(3)\n                                 .recordStats()\n                                     .build();\n    cache.put(\"key1\",\"value1\");\n    cache.put(\"key2\",\"value2\");\n    cache.put(\"key3\",\"value3\");\n    \n    cache.getIfPresent(\"key1\")\n    cache.getIfPresent(\"key1\")\n    cache.getIfPresent(\"key2\")\n    cache.getIfPresent(\"key3\")\n    // 获取统计信息\n    System.out.println(cache.stats());\n```\n\n**CacheStats**\n\n|属性值|含义|\n|:--|:--|\n|requestCount|返回cache查找缓存的次数|\n|hitCount|命中缓存的次数|\n|missCount|未命中缓存的次数|\n|missRate|返回缓存请求未命中的比率，未命中次数除以请求次数 |\n|loadCount|返回缓存调用load方法加载新值的次数|\n|loadSuccessCount|返回缓存加载新值的成功次数|\n|loadExceptionCount|返回缓存加载新值出现异常的次数|\n|loadExceptionRate|返回缓存加载新值出现异常的比率|\n|totalLoadTime|返回缓存加载新值所耗费的总时间|\n|averageLoadPenalty|缓存加载新值的耗费的平均时间，加载的次数除以加载的总时间|\n|evictionCount|返回缓存中条目被移除的次数|\n\n## 五、代码片段\n\n```java \n    private LoadingCache<Long,UserInfoDTO> userCache;\n    \n    {\n        userCache =  CacheBuilder.newBuilder().maximumSize(30)//缓存30条数据\n                .expireAfterWrite(10,TimeUnit.SECONDS) // 缓存时间10s\n                    .build(// 缓存加载器，如果没有找到key,就去加载这个key到缓存中\n                new CacheLoader<Long,UserInfoDTO>(){\n                    @Override\n                    public UserInfoDTO load(Long key) throws Exception{\n                        return userService.queryById(key);\n                    }\n                }\n            )\n    }\n    \n    public UserInfoDTO queryUserInfoByIdFromCache(Long userId){\n        return userCache.get(userId);\n    }\n```\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/tools/guava/guava-cache.md b/docs/learn/tools/guava/guava-cache.md
--- a/docs/learn/tools/guava/guava-cache.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/tools/guava/guava-cache.md	(date 1655373430550)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/tools/guava/README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: true\nfooter: true\nbacktotop: true\ntitle: Guava：用于 Java 的 Google 核心库\n---\n\n![](https://camo.githubusercontent.com/45e5eb02492f9e3bf6345cfd7ca7ecb42dca2268fef7af35dfe3da82740b4000/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f72656c656173652f676f6f676c652f67756176612e737667)\n![](https://github.com/google/guava/workflows/CI/badge.svg?branch=master)\n\nGuava 是一组来自 Google 的核心 Java 库，其中包括新的集合类型（例如 multimap 和 multiset）、不可变集合、图形库以及用于并发、I/O、散列、缓存、原语、字符串等的实用程序！它广泛用于 Google 内部的大多数 Java 项目，也被许多其他公司广泛使用\n\n\n\n\n\n```xml\n<dependency>\n    <groupId>com.google.guava</groupId>\n    <artifactId>guava</artifactId>\n    <version>31.1-jre</version>\n    <!-- or, for Android: -->\n    <version>31.1-android</version>\n</dependency>\n```\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/tools/guava/README.md b/docs/learn/tools/guava/README.md
--- a/docs/learn/tools/guava/README.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/tools/guava/README.md	(date 1655373430412)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/project/jmvn/introduction-install.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: true\nfooter: true\nbacktotop: true\ntitle: 快速安装\n---\n\n<Djt/>\n\n## Node环境安装\n\n:::: code-group\n\n::: code-group-item Window\n\n```\nhttps://nodejs.org/dist/v14.15.5/node-v14.15.5-x64.msi\n```\n\n:::\n\n::: code-group-item Mac:active\n\n```\nhttps://nodejs.org/dist/v15.9.0/node-v15.9.0.pkg\n```\n\n:::\n\n::::\n\n\n## 命令安装\n\n```\nnpm i jmvn -g\n```\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/project/jmvn/introduction-install.md b/docs/learn/project/jmvn/introduction-install.md
--- a/docs/learn/project/jmvn/introduction-install.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/project/jmvn/introduction-install.md	(date 1655373430350)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/tools/guava/spring-retry.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: Spring-retry重试组件\n---\n\n\n## 一、简介\n\n:::info Spring-retry\n前面我们了解到了,Guava的重试组件,我们可以基于Guava的能力,来封装我们需要的能力来满足我们的业务。今天来分享Spring-Retry重试组件。当然Spring只是帮我们封装好了，如果你不想自定义\n重试组件，那么我们可以直接使用Spring的能力来实现。\n\n\nAPI 也是非常的简单，几个注解就可以搞定。\n:::\n\n[![](https://img.shields.io/badge/%E4%BB%93%E5%BA%93-spring--retry--example-green)](https://github.com/lxchinesszz/spring-retry-example)\n\n\n## 二、依赖\n\n```xml \n    <!--springboot项目都不用引入版本号-->\n    <dependency>\n      <groupId>org.springframework.retry</groupId>\n      <artifactId>spring-retry</artifactId>\n    </dependency>\n    <!--还是需要aop的支持的(如果已经引入了aop就不用再添加这个依赖了)-->\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-aspects</artifactId>\n    </dependency>\n```\n\n## 三、使用\n\n### 3.1 @EnableRetry 开启重试 \n\nSpringBoot启动类上添加开启重试注解\n\n```java\n    @EnableRetry\n    @SpringBootApplication\n    public class Application {\n        public static void main(String[] args) {\n            ConfigurableApplicationContext applicationContext = SpringApplication.run(Application.class, args);\n        }\n    }\n```\n\n### 3.2 @Retryable 重试策略\n\n在需要重试的方法上加注解@Retryable\n\n```java\n    @Retryable(value = RuntimeException.class, maxAttempts = 5, backoff = @Backoff(delay = 100))\n    public String say(String param) {\n        double random = Math.random();\n        if (random > 0.1) {\n            throw new RuntimeException(\"超时\");\n        }\n        return random + \"\";\n    }\n```\n\n- [x] value = RuntimeException.class：是指方法抛出RuntimeException异常时，进行重试。这里可以指定你想要拦截的异常。\n- [x] maxAttempts：是最大重试次数。如果不写，则是默认3次。\n- [x] backoff = @Backoff(delay = 100)：是指重试间隔。delay=100意味着下一次的重试，要等100毫秒之后才能执行。\n\n### 3.3 @Recover 重试失败\n\n当@Retryable方法重试失败之后，最后就会调用@Recover方法。用于@Retryable失败时的“兜底”处理方法。 @Recover的方法必须要与@Retryable注解的方法保持一致，第一入参为要重试的异常，其他参数与@Retryable保持一致，返回值也要一样，否则无法执行！\n\n\n```java \n    @Retryable(value = IllegalAccessException.class)\n    public void say() throws IllegalAccessException {\n        log.info(\"do something... {}\", LocalDateTime.now());\n        throw new IllegalAccessException();\n    }\n\n\n    @Recover\n    public void sayBackup(IllegalAccessException e) {\n        log.info(\"service retry after Recover => {}\", e.getMessage());\n    }\n```\n\n### 3.4 @CircuitBreaker 熔断策略\n\n规定时间内如果重试次数达到了最大次数,开启熔断策略。\n5秒内,这个方法重试了2次,就会断路。直接走@Recover修饰的方法。当超过10s后进行重置,继续走get方法。\n\n注意@Retryable和@CircuitBreaker不要修饰同一个方法。\n\n```java \n    @CircuitBreaker(openTimeout = 5000, maxAttempts = 2,resetTimeout = 10000)\n    public String get(@PathVariable Integer flag) {\n        if (flag > 1) {\n            log.info(\"重试进入\");\n            throw new RuntimeException(\"自定义异常\");\n        }\n        return \"处理正常\";\n    }\n    @Recover\n    public String getBackup(RuntimeException runtimeException) {\n        log.error(\"重试一直失败,进入备用方法:\" + runtimeException.getMessage());\n        return \"备用方法进去\";\n    }\n```\n\n|属性|意思|\n|:--|:--|\n|include|指定处理的异常类。默认为空|\n|exclude|指定不需要处理的异常。默认为空|\n|value|指定要重试的异常。默认为空|\n|maxAttempts|最大重试次数。默认3次|\n|openTimeout|配置熔断器打开的超时时间，默认5s，当超过openTimeout之后熔断器电路变成半打开状态（只要有一次重试成功，则闭合电路）|\n|resetTimeout|配置熔断器重新闭合的超时时间，默认20s，超过这个时间断路器关闭|\n|include|指定处理的异常类。默认为空|\n\n\n\n\n### 3.5 RetryListener 监听器\n\nspring-retry和guava-retry一样同样有监听器。我们可以自定义我们的监听器\n\n```java \n@Slf4j\npublic class DefaultListenerSupport extends RetryListenerSupport {\n    @Override\n    public <T, E extends Throwable> void close(RetryContext context,\n                                               RetryCallback<T, E> callback, Throwable throwable) {\n        log.info(\"onClose\");\n        super.close(context, callback, throwable);\n    }\n\n    @Override\n    public <T, E extends Throwable> void onError(RetryContext context,\n                                                 RetryCallback<T, E> callback, Throwable throwable) {\n        log.info(\"onError\");\n        super.onError(context, callback, throwable);\n    }\n\n    @Override\n    public <T, E extends Throwable> boolean open(RetryContext context,\n                                                 RetryCallback<T, E> callback) {\n        log.info(\"onOpen\");\n        return super.open(context, callback);\n    }\n}\n\n@Configuration\npublic class RetryConfig {\n\n    @Bean\n    public RetryTemplate retryTemplate() {\n        RetryTemplate retryTemplate = new RetryTemplate();\n        SimpleRetryPolicy retryPolicy = new SimpleRetryPolicy(); //设置重试策略\n        retryPolicy.setMaxAttempts(2);\n        retryTemplate.setRetryPolicy(retryPolicy);\n\n        FixedBackOffPolicy fixedBackOffPolicy = new FixedBackOffPolicy(); //设置退避策略\n        fixedBackOffPolicy.setBackOffPeriod(2000L);\n        retryTemplate.setBackOffPolicy(fixedBackOffPolicy);\n        \n        retryTemplate.registerListener(new DefaultListenerSupport()); //设置retryListener\n        return retryTemplate;\n    }\n}\n```\n\n### 3.6 RetryPolicy 重试策略\n\n|属性|意思|\n|:--|:--|\n  |NeverRetryPolicy|只允许调用RetryCallback一次，不允许重试；|\n  |AlwaysRetryPolicy|允许无限重试，直到成功，此方式逻辑不当会导致死循环；|\n  |SimpleRetryPolicy|固定次数重试策略，默认重试最大次数为3次，RetryTemplate默认使用的策略；|\n  |TimeoutRetryPolicy|超时时间重试策略，默认超时时间为1秒，在指定的超时时间内允许重试；|\n  |CircuitBreakerRetryPolicy|有熔断功能的重试策略，需设置3个参数openTimeout、resetTimeout和delegate|\n  |CompositeRetryPolicy|组合重试策略，有两种组合方式，乐观组合重试策略是指只要有一个策略允许重试即可以，悲观组合重试策略是指只要有一个策略不允许重试即可以，但不管哪种组合方式，组合中的每一个策略都会执行。|\n\n### 3.7 BackOffPolicy 退避策略\n\n下一次重试的策略。\n退避是指怎么去做下一次的重试，在这里其实就是等待多长时间。\n\n|属性|意思|\n|:--|:--|\n|FixedBackOffPolicy| 默认固定延迟1秒后执行下一次重试|\n|ExponentialBackOffPolicy| 指数递增延迟执行重试，默认初始0.1秒，系数是2，那么下次延迟0.2秒，再下次就是延迟0.4秒，如此类推，最大30秒。|\n|ExponentialRandomBackOffPolicy| 在上面那个策略上增加随机性|\n|UniformRandomBackOffPolicy| 这个跟上面的区别就是，上面的延迟会不停递增，这个只会在固定的区间随机|\n|StatelessBackOffPolicy| 这个说明是无状态的，所谓无状态就是对上次的退避无感知，从它下面的子类也能看出来|\n\n## 四、总结\n\n天下代码一大抄，看你会抄不会抄。发现无论是guava还是spring的重试，基本都是类似的思路。只是看谁的功能比较鉴权而已。\nguava提供了基础的能力，你任意封装。\nspring基于spring提供了已经完好的能力，直接使用就好。不过因为是spring给你封装的能力，所以你要先了解清楚才行。不然可能使用错误，造成故障。\n\n以上两款工具都挺好，不过他们都不支持分布式重试的能力。不过这已经满足我们的日常开发了，如果真遇到分布式的重试，就自己来实现咯。\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/tools/guava/spring-retry.md b/docs/learn/tools/guava/spring-retry.md
--- a/docs/learn/tools/guava/spring-retry.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/tools/guava/spring-retry.md	(date 1655373430321)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/tools/guava/guava-retry.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: Guava-retry重试组件\n---\n\n## 一、简介\n\n:::info Guava-retry\nGuava 是一组来自 Google 的核心 Java 库，其中包括新的集合类型（例如 multimap 和 multiset）、不可变集合、图形库以及用于并发、I/O、散列、缓存、原语、字符串等的实用程序！它广泛用于 Google\n内部的大多数 Java 项目，也被许多其他公司广泛使用。\n\n\nAPI 非常的简单，我们可以非常轻松的使用，来封装成我们业务中自己的组件。\n:::\n\n## 二、依赖\n\n```xml \n    <dependency>\n        <groupId>com.github.rholder</groupId>\n        <artifactId>guava-retrying</artifactId>\n        <version>2.0.0</version>\n    </dependency>\n```\n\n## 三、使用\n\n### 3.1 指定异常\n\n配置如果发生了 `Exception` 异常进行重试\n\n```java {3}\n    Retryer<User> retry = RetryerBuilder.<User>newBuilder()\n                //发生ConnectException异常时重试\n                .retryIfExceptionOfType(Exception.class)\n                //重试的等待策略 初始等待1s，每次递增1s。如：第一次1s，第二次2s，第三次3s，以此类推...\n                .withWaitStrategy(WaitStrategies.incrementingWait(1, TimeUnit.SECONDS, 1, TimeUnit.SECONDS))\n                //重试3次后停止\n                .withStopStrategy(StopStrategies.stopAfterAttempt(3)).build();\n```\n\n### 3.2 重试策略\n\nWaitStrategy 重试策略\n\n```java {5}\n    Retryer<User> retry = RetryerBuilder.<User>newBuilder()\n                //发生ConnectException异常时重试\n                .retryIfExceptionOfType(Exception.class)\n                //重试的等待策略 初始等待1s，每次递增1s。如：第一次1s，第二次2s，第三次3s，以此类推...\n                .withWaitStrategy(WaitStrategies.incrementingWait(1, TimeUnit.SECONDS, 1, TimeUnit.SECONDS))\n                //重试3次后停止\n                .withStopStrategy(StopStrategies.stopAfterAttempt(3)).build();\n```\n\n| 策略             | 使用方法                                                     | 说明                                                         |\n| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 固定策略         | WaitStrategies.fixedWait(10,TimeUnit.SECONDS)                | 每10秒执行一次                                               |\n| 随机策略         | WaitStrategies.randomWait(100,TimeUnit.SECONDS)              | 0 到 100秒之间随机执行一次                                   |\n| 随机策略         | WaitStrategies.randomWait(10,TimeUnit.SECONDS,20,TimeUnit.SECONDS) | 10 到 20秒之间随机执行一次                                   |\n| 递增策略         | WaitStrategies.incrementingWait(1, TimeUnit.SECONDS, 1, TimeUnit.SECONDS) | 初始等待1s，每次递增1s。如：第一次1s，第二次2s，第三次3s，以此类推... |\n| 异常策略         | WaitStrategies.exceptionWait(...)                            | 不同的异常返回不同的重试时间                                 |\n| 斐波那契数列策略 | WaitStrategies.fibonacciWait(...)                            | 1、1、2、3、5、8、13、21类推                                 |\n\n### 3.3 重试监听器\n\nAttempt 代表每次执行动作，可以获取执行次数，打印执行日志\n\n```java {7}\n Retryer<User> retry = RetryerBuilder.<User>newBuilder()\n                //发生ConnectException异常时重试\n                .retryIfExceptionOfType(Exception.class)\n                //重试的等待策略 初始等待1s，每次递增1s。如：第一次1s，第二次2s，第三次3s，以此类推...\n                .withWaitStrategy(WaitStrategies.incrementingWait(1, TimeUnit.SECONDS, 1, TimeUnit.SECONDS))\n                //重试监听器\n                .withRetryListener(new RetryListener() {\n                    @Override\n                    public <V> void onRetry(Attempt<V> attempt) {\n                        System.out.println(\"重试次数:\" + attempt.getAttemptNumber());\n                        System.out.println(\"异常:\" + attempt.getExceptionCause());\n                        System.out.println(\"返回值:\"+attempt.get());\n                    }\n                })\n                //重试3次后停止\n                .withStopStrategy(StopStrategies.stopAfterAttempt(10)).build();\n```\n\n### 3.4 停止策略\n\nStopStrategy 一般常用的就是重试多少次\n\n```java {7}\n Retryer<User> retry = RetryerBuilder.<User>newBuilder()\n                //发生ConnectException异常时重试\n                .retryIfExceptionOfType(Exception.class)\n                //重试的等待策略 初始等待1s，每次递增1s。如：第一次1s，第二次2s，第三次3s，以此类推...\n                .withWaitStrategy(WaitStrategies.incrementingWait(1, TimeUnit.SECONDS, 1, TimeUnit.SECONDS))\n                //重试3次后停止\n                .withStopStrategy(StopStrategies.stopAfterAttempt(10)).build();\n```\n\n- StopAfterDelayStrategy ：设定一个最长允许的执行时间；比如设定最长执行10s，无论任务执行次数，只要重试的时候超出了最长时间，则任务终止，并返回重试异常RetryException；\n- NeverStopStrategy ：不停止，用于需要一直轮训直到返回期望结果的情况；\n- StopAfterAttemptStrategy ：设定最大重试次数，如果超出最大重试次数则停止重试，并返回重试异常；\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/tools/guava/guava-retry.md b/docs/learn/tools/guava/guava-retry.md
--- a/docs/learn/tools/guava/guava-retry.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/tools/guava/guava-retry.md	(date 1655373430380)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/tools/guava/guava-map.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: Guava-Map\n---\n\n## 一、简介\n\nGuava 是一组来自 Google 的核心 Java 库，其中包括新的集合类型（例如 multimap 和 multiset）、不可变集合、图形库以及用于并发、I/O、散列、缓存、原语、字符串等的实用程序！它广泛用于 Google\n内部的大多数 Java 项目，也被许多其他公司广泛使用。\n\n\nAPI 非常的简单，我们可以非常轻松的使用，来封装成我们业务中自己的组件。\n\n## 二、依赖\n\n```xml \n    <dependency>\n        <groupId>com.google.guava</groupId>\n        <artifactId>guava</artifactId>\n        <version>30.1.1-jre</version>\n    </dependency>\n```\n\n## 三、使用介绍\n\n### 3.1 Table 双键 Map\n\njava中的Map只允许有一个key和一个value存在，但是guava中的Table允许一个value存在两个key。Table中的两个key分别被称为rowKey和columnKey，也就是行和列。\n\n```java \nTable<String,String,Integer> table= HashBasedTable.create();\n//存放元素\ntable.put(\"Hydra\", \"Jan\", 20);\ntable.put(\"Hydra\", \"Feb\", 28);\ntable.put(\"Trunks\", \"Jan\", 28);\ntable.put(\"Trunks\", \"Feb\", 16);\n//取出元素\nInteger dayCount = table.get(\"Hydra\", \"Feb\");\n```\n\n### 3.2 BiMap 双向Map\n\n在普通Map中，如果要想根据value查找对应的key，没什么简便的办法，无论是使用for循环还是迭代器，都需要遍历整个Map。\n而guava中的BiMap提供了一种key和value双向关联的数据结构。\n\n```java {7}\nHashBiMap<String, String> biMap = HashBiMap.create();\nbiMap.put(\"Hydra\",\"Programmer\");\nbiMap.put(\"Tony\",\"IronMan\");\nbiMap.put(\"Thanos\",\"Titan\");\n//使用key获取value\nSystem.out.println(biMap.get(\"Tony\"));\nBiMap<String, String> inverse = biMap.inverse();\n//使用value获取key\nSystem.out.println(inverse.get(\"Titan\"));\n```\n\n注意: 反转后的BiMap并不是一个新的对象，它实现了一种视图的关联，所以对反转后的BiMap执行的所有操作会作用于原先的BiMap上。\n\n```java \nHashBiMap<String, String> biMap = HashBiMap.create();\nbiMap.put(\"Hydra\",\"Programmer\");\nbiMap.put(\"Tony\",\"IronMan\");\nbiMap.put(\"Thanos\",\"Titan\");\nBiMap<String, String> inverse = biMap.inverse();\ninverse.put(\"IronMan\",\"Stark\");\nSystem.out.println(biMap);\n```\n对反转后的BiMap中的内容进行了修改后，再看一下原先BiMap中的内容：\n\n```java \n{Hydra=Programmer, Thanos=Titan, Stark=IronMan}\n```\n可以看到，原先值为IronMan时对应的键是Tony，虽然没有直接修改，但是现在键变成了Stark。\n\n\n\n### 3.3 Multimap 多值Map\n\njava中的Map维护的是键值一对一的关系，如果要将一个键映射到多个值上，那么就只能把值的内容设为集合形式，而在guava中可以使用如下：\n\n```java \nMultimap<String, Integer> multimap = ArrayListMultimap.create();\nmultimap.put(\"day\",1);\nmultimap.put(\"day\",2);\nmultimap.put(\"day\",8);\nmultimap.put(\"month\",3);\n```\n\n打印这个Multimap的内容，可以直观的看到每个key对应的都是一个集合：\n\n``` \n{month=[3], day=[1, 2, 8]}\n```\n\n### 3.4 RangeMap 范围Map\n\n先看一个例子，假设我们要根据分数对考试成绩进行分类，那么代码中就会出现这样丑陋的if-else：\n\n```java \npublic static String getRank(int score){\n    if (0<=score && score<60)\n        return \"fail\";\n    else if (60<=score && score<=90)\n        return \"satisfactory\";\n    else if (90<score && score<=100)\n        return \"excellent\";\n    return null;\n}\n```\n\n而guava中的RangeMap描述了一种从区间到特定值的映射关系，让我们能够以更为优雅的方法来书写代码。下面用RangeMap改造上面的代码并进行测试：\n\n```java \nRangeMap<Integer, String> rangeMap = TreeRangeMap.create();\nrangeMap.put(Range.closedOpen(0,60),\"fail\");\nrangeMap.put(Range.closed(60,90),\"satisfactory\");\nrangeMap.put(Range.openClosed(90,100),\"excellent\");\nSystem.out.println(rangeMap.get(59));\nSystem.out.println(rangeMap.get(60));\nSystem.out.println(rangeMap.get(90));\nSystem.out.println(rangeMap.get(91));\n```\n\n在上面的代码中，先后创建了[0,60)的左闭右开区间、[60,90]的闭区间、(90,100]的左开右闭区间，并分别映射到某个值上。运行结果打印：\n\n``` \nfail\nsatisfactory\nsatisfactory\nexcellent\n```\n\n### 3.5 ClassToInstanceMap 实例Map\n\nClassToInstanceMap是一个比较特殊的Map，它的键是Class，而值是这个Class对应的实例对象。先看一个简单使用的例子，使用putInstance方法存入对象\n\n```java \nClassToInstanceMap<Object> instanceMap = MutableClassToInstanceMap.create();\nUser user=new User(\"Hydra\",18);\nDept dept=new Dept(\"develop\",200);\ninstanceMap.putInstance(User.class,user);\ninstanceMap.putInstance(Dept.class,dept);\n```\n那么，使用ClassToInstanceMap这种方式有什么好处呢?\n\n最明显的就是在取出对象时省去了复杂的强制类型转换，避免了手动进行类型转换的错误。\n所以，如果你想缓存对象，又不想做复杂的类型校验，那么使用方便的ClassToInstanceMap就可以了。\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/tools/guava/guava-map.md b/docs/learn/tools/guava/guava-map.md
--- a/docs/learn/tools/guava/guava-map.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/tools/guava/guava-map.md	(date 1655373430209)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/tools/arthas/jvm-cli.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: JVM相关命令\n---\n\n## 一、启动Arthas\n\n``` \ncurl -O https://arthas.aliyun.com/arthas-boot.jar\njava -jar arthas-boot.jar\n```\n\n启动命令 `java -jar arthas-boot.jar`\n\n\n## 二、选择进程\n\n![](https://img.springlearn.cn/blog/learn_1647178107000.png)\n\n直接选择我们要监控的进程，输入3进入\n\n``` \n[INFO] Attach process 28667 success.\n[INFO] arthas-client connect 127.0.0.1 3658\n  ,---.  ,------. ,--------.,--.  ,--.  ,---.   ,---.                           \n /  O  \\ |  .--. ''--.  .--'|  '--'  | /  O  \\ '   .-'                          \n|  .-.  ||  '--'.'   |  |   |  .--.  ||  .-.  |`.  `-.                          \n|  | |  ||  |\\  \\    |  |   |  |  |  ||  | |  |.-'    |                         \n`--' `--'`--' '--'   `--'   `--'  `--'`--' `--'`-----'                          \n\nwiki       https://arthas.aliyun.com/doc                                        \ntutorials  https://arthas.aliyun.com/doc/arthas-tutorials.html                  \nversion    3.5.6                                                                \nmain_class com.example.demo.DemoApplication                                     \npid        28667                                                                \ntime       2022-03-13 21:31:04   \n```\n\n提示已经连接上进程。\n\n## 三、基础信息查询命令\n\n### 3.1 dashboard 看板命令\n\n输入 `dashboard`\n\n![](https://img.springlearn.cn/blog/learn_1647178404000.png)\n\n会定时将应用信息输出到控制台上。\n\n### 3.2 jad 反向编译\n\n` jad com.example.demo.DemoApplication`\n\n![](https://img.springlearn.cn/blog/learn_1647178673000.png)\n\n\n### 3.3 watch 监控指令\n\n这个命令是比较常用的命令,可以用来分析系统性能。\n\n```java \npackage com.example.demo;\n\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.ResponseBody;\nimport org.springframework.web.bind.annotation.RestController;\n@RestController\npublic class WebController {\n\n    @GetMapping(\"/get\")\n    @ResponseBody\n    public String get(String name) {\n        return name;\n    }\n}\n```\n\n监控这个类 `watch com.example.demo.WebController get returnObj`\n\n|参数名|含义|\n|:--:|:--:|\n|returnObj|返回值|\n|params|入参|\n|target|方法调用方|\n\n`watch com.example.demo.WebController get {params,returnObj,target}`\n\n``` \n[arthas@32818]$ watch com.example.demo.WebController get returnObj\nPress Q or Ctrl+C to abort.\nAffect(class count: 1 , method count: 1) cost in 120 ms, listenerId: 1\nmethod=com.example.demo.WebController.get location=AtExit\nts=2022-03-13 21:41:56; [cost=1.317166ms] result=@String[123]\nmethod=com.example.demo.WebController.get location=AtExit\nts=2022-03-13 21:42:03; [cost=0.051875ms] result=@String[测试]\n```\n\n# 四、退出\n\n输入 `q`\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/tools/arthas/jvm-cli.md b/docs/learn/tools/arthas/jvm-cli.md
--- a/docs/learn/tools/arthas/jvm-cli.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/tools/arthas/jvm-cli.md	(date 1655373430159)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/databases/sql/explain.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: explain调优\n---\n\n![](https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png)\n\n**作者**: 西魏陶渊明\n**博客**: [https://blog.springlearn.cn/](https://blog.springlearn.cn/)\n\n::: tip 西魏陶渊明\n莫笑少年江湖梦，谁不少年梦江湖\n:::\n\n> 这篇文章主要讲 explain 如何使用，还有 explain 各种参数概念，之后会讲优化\n\n# 一、Explain 用法\n\nexplain模拟Mysql优化器是如何执行SQL查询语句的，从而知道Mysql是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈。\n\n**语法**：`Explain + SQL 语句;`\n\n如：`Explain select * from user;` 会生成如下 SQL 分析结果，下面详细对每个字段进行详解\n\n![](https://img.springlearn.cn/blog/learn_1596351159000.png)\n\n## 1. id\n\n是一组数字，代表多个表之间的查询顺序，或者包含子句查询语句中的顺序，id 总共分为三种情况，依次详解\n\n### id相同\n\nid相同，执行顺序由上至下\n![](https://img.springlearn.cn/blog/learn_1596351240000.png)\n\n### id不同\n\nid 不同，如果是子查询，id 号会递增，id 值越大优先级越高，越先被执行\n\n![](https://img.springlearn.cn/blog/learn_1596351303000.png)\n\n\n### id相同和不同\n\nid 相同和不同的情况同时存在\n\n![](https://img.springlearn.cn/blog/learn_1596351331000.png)\n\n## 2. select_type\n\nselect_type 包含以下几种值\n\n`simple`、`primary`、`subquery`、`derived`、`union`、`union result`\n\n### simple\n\n简单的 `select` 查询，查询中不包含子查询或者 `union` 查询\n\n![](https://img.springlearn.cn/blog/learn_1596351522000.png)\n\n### primary\n\n如果 SQL 语句中包含任何子查询，那么子查询的最外层会被标记为 `primary`\n\n![](https://img.springlearn.cn/blog/learn_1596351575000.png)\n\n\n### subquery\n\n在 `select` 或者 `where` 里包含了子查询，那么子查询就会被标记为 `subQquery`，同三.二同时出现\n\n![](https://img.springlearn.cn/blog/learn_1596351651000.png)\n\n\n### derived\n\n在 `from` 中包含的一个子查询，会被标记为衍生查询，会把查询结果放到一个临时表中\n\n![](https://img.springlearn.cn/blog/learn_1596351720000.png)\n\n### union / union result\n\n如果有两个 `select` 查询语句，他们之间用 `union` 连起来查询，那么第二个 `select` 会被标记为 `union`，`union` 的结果被标记为 `union result`。它的 id 是为 null 的\n\n![](https://img.springlearn.cn/blog/learn_1596351779000.png)\n\n## 3. table\n\n表示这一行的数据是哪张表的数据\n\n## 4. type\n\ntype 是代表 MySQL 使用了哪种索引类型，不同的索引类型的查询效率也是不一样的，type 大致有以下种类。\n越往上性能越高。\n\n| Type类型 | 说明                                              |\n| ---- | --------------------------------------------------- |\n| system    | 表中只有一行记录，system 是 const 的特例，几乎不会出现这种情况，可以忽略不计                                           |\n| const    | 必须是用主键索引或者唯一索引放到 where 条件中查询                                                   |\n| eq_ref    | 多表查询中,索引查出来的数据都是唯一的（不能是多个,也不能是0个），常见于唯一索引和主键索引                                               |\n| ref    | 不是主键索引，也不是唯一索引，就是普通的索引，可能会返回多个符合条件的行。               |\n| range   | 体现在对某个索引进行区间范围检索，一般出现在 where 条件中的 between、and、<、>、in 等范围查找中。 |\n| index   | 将所有的索引树都遍历一遍，查找到符合条件的行。索引文件比数据文件还是要小很多，所以比不用索引全表扫描还是要快很多。 |\n| all   | 没用到索引，单纯的将表数据全部都遍历一遍，查找到符合条件的数据                     |\n\n## 5. possible_keys\n\n\n此次查询中涉及字段上若存在索引，则会被列出来，表示可能会用到的索引，但并不是实际上一定会用到的索引\n\n\n## 6. key\n\n此次查询中实际上用到的索引\n\n## 7. key_len\n\n表示索引中使用的字节数，通过该属性可以知道在查询中使用的索引长度，注意：这个长度是最大可能长度，并非实际使用长度，在不损失精确性的情况下，长度越短查询效率越高\n\n## 8. ref\n\n显示关联的字段。如果使用常数等值查询，则显示 const，如果是连接查询，则会显示关联的字段。\n\n![](https://img.springlearn.cn/blog/learn_1596352252000.png)\n\n- tb_emp 表为非唯一性索引扫描，实际使用的索引列为 idx_name，由于 tb_emp.name='rose'为一个常量，所以 ref=const。\n- tb_dept 为唯一索引扫描，从 sql 语句可以看出，实际使用了 PRIMARY 主键索引，ref=db01.tb_emp.deptid 表示关联了 db01 数据库中 tb_emp 表的 deptid 字段。\n\n## 9. rows\n\n根据表信息统计以及索引的使用情况，大致估算说要找到所需记录需要读取的行数，rows 越小越好\n\n\n## 10. extra\n\n不适合在其他列显示出来，但在优化时十分重要的信息\n\n### using  fileSort（重点优化）\n\n俗称 \" 文件排序 \" ，在数据量大的时候几乎是“九死一生”，在 order by 或者在 group by 排序的过程中，order by 的字段不是索引字段，或者 select 查询字段存在不是索引字段，或者 select 查询字段都是索引字段，但是 order by 字段和 select 索引字段的顺序不一致，都会导致 fileSort\n\n如果where后面的查询和order by的索引，不是一个值。就会出现fileSort。\n\n复合索引,夸界,也会出现fileSort。\n\n优化建议: where 什么就order by 什么。 或者 where和order by 按照复合索引顺序，不要跨列或者无序使用\n![](https://img.springlearn.cn/blog/learn_1596352476000.png)\n\n\n### using temporary（重点优化）\n\n使用了临时表保存中间结果，常见于 order by 和 group by 中。\n\n优化建议: 查询哪些列就用哪些列来order by。 能不用创建临时表就不要创建。\n\n![](https://img.springlearn.cn/blog/learn_1596352573000.png)\n\n\n### USING index（重点）\n\n索引覆盖,就是当前sql查询不用读取原文件,只用读取索引。因为查询的列就是索引列\n\n表示相应的 select 操作中使用了覆盖索引（Coveing Index）,避免访问了表的数据行，效率不错！如果同时出现 using where，表明索引被用来执行索引键值的查找；如果没有同时出现 using where，表面索引用来读取数据而非执行查找动作。\n\n![](https://img.springlearn.cn/blog/learn_1596352650000.png)\n\n### Using where\n\n跟using index相反，要回表去查询。\n\n表明使用了 where 过滤\n\n### Using join buffer\n\n使用了连接缓存\n\n### impossible where\n\nwhere 子语句的值总是 false，不能用来获取任何数据。出现这个就要检查sql。\n\neg: select a from test where a = 1 and a = 2。  a肯定不可能即1又是2\n\n### select tables optimized away\n\n在没有 GROUPBY 子句的情况下，基于索引优化 MIN/MAX 操作或者 对于 MyISAM 存储引擎优化 COUNT(*)操作，不必等到执行阶段再进行计算， 查询执行计划生成的阶段即完成优化。\n\n\n### distinct\n\n优化 distinct，在找到第一匹配的元组后即停止找同样值的工作\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/databases/sql/explain.md b/docs/learn/databases/sql/explain.md
--- a/docs/learn/databases/sql/explain.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/databases/sql/explain.md	(date 1655373430323)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/tools/arthas/class-cli.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: class/classloader相关\n---\n\n## 一、启动Arthas\n\n``` \ncurl -O https://arthas.aliyun.com/arthas-boot.jar\njava -jar arthas-boot.jar\n```\n\n启动命令 `java -jar arthas-boot.jar`\n\n\n## 二、选择进程\n\n![](https://img.springlearn.cn/blog/learn_1647178107000.png)\n\n直接选择我们要监控的进程，输入3进入\n\n``` \n[INFO] Attach process 28667 success.\n[INFO] arthas-client connect 127.0.0.1 3658\n  ,---.  ,------. ,--------.,--.  ,--.  ,---.   ,---.                           \n /  O  \\ |  .--. ''--.  .--'|  '--'  | /  O  \\ '   .-'                          \n|  .-.  ||  '--'.'   |  |   |  .--.  ||  .-.  |`.  `-.                          \n|  | |  ||  |\\  \\    |  |   |  |  |  ||  | |  |.-'    |                         \n`--' `--'`--' '--'   `--'   `--'  `--'`--' `--'`-----'                          \n\nwiki       https://arthas.aliyun.com/doc                                        \ntutorials  https://arthas.aliyun.com/doc/arthas-tutorials.html                  \nversion    3.5.6                                                                \nmain_class com.example.demo.DemoApplication                                     \npid        28667                                                                \ntime       2022-03-13 21:31:04   \n```\n\n提示已经连接上进程。\n\n## 三、基础信息查询命令\n\n### 3.1 dashboard 看板命令\n\n输入 `dashboard`\n\n![](https://img.springlearn.cn/blog/learn_1647178404000.png)\n\n会定时将应用信息输出到控制台上。\n\n### 3.2 jad 反向编译\n\n` jad com.example.demo.DemoApplication`\n\n![](https://img.springlearn.cn/blog/learn_1647178673000.png)\n\n\n### 3.3 watch 监控指令\n\n这个命令是比较常用的命令,可以用来分析系统性能。\n\n```java \npackage com.example.demo;\n\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.ResponseBody;\nimport org.springframework.web.bind.annotation.RestController;\n@RestController\npublic class WebController {\n\n    @GetMapping(\"/get\")\n    @ResponseBody\n    public String get(String name) {\n        return name;\n    }\n}\n```\n\n监控这个类 `watch com.example.demo.WebController get returnObj`\n\n|参数名|含义|\n|:--:|:--:|\n|returnObj|返回值|\n|params|入参|\n|target|方法调用方|\n\n`watch com.example.demo.WebController get {params,returnObj,target}`\n\n``` \n[arthas@32818]$ watch com.example.demo.WebController get returnObj\nPress Q or Ctrl+C to abort.\nAffect(class count: 1 , method count: 1) cost in 120 ms, listenerId: 1\nmethod=com.example.demo.WebController.get location=AtExit\nts=2022-03-13 21:41:56; [cost=1.317166ms] result=@String[123]\nmethod=com.example.demo.WebController.get location=AtExit\nts=2022-03-13 21:42:03; [cost=0.051875ms] result=@String[测试]\n```\n\n# 四、退出\n\n输入 `q`\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/tools/arthas/class-cli.md b/docs/learn/tools/arthas/class-cli.md
--- a/docs/learn/tools/arthas/class-cli.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/tools/arthas/class-cli.md	(date 1655373430355)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/databases/sql/join.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: Join大法\n---\n\n\n![](https://img.springlearn.cn/blog/learn_1648086269000.png)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/databases/sql/join.md b/docs/learn/databases/sql/join.md
--- a/docs/learn/databases/sql/join.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/databases/sql/join.md	(date 1655373430607)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/tools/arthas/README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: Arthas（阿尔萨斯） 能为你做什么\n---\n\n![](https://img.springlearn.cn/blog/learn_1647177070000.png)\n\nArthas 是Alibaba开源的Java诊断工具，深受开发者喜爱。\n\n\n\n当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：\n\n- [x] 这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？\n- [x] 我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？\n- [x] 遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？\n- [x] 线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！\n- [x] 是否有一个全局视角来查看系统的运行状况？\n- [x] 有什么办法可以监控到JVM的实时运行状态？\n- [x] 怎么快速定位应用的热点，生成火焰图？\n- [x] 怎样直接从JVM内查找某个类的实例？\n\nArthas支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/tools/arthas/README.md b/docs/learn/tools/arthas/README.md
--- a/docs/learn/tools/arthas/README.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/tools/arthas/README.md	(date 1655373430329)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/tools/arthas/base-cli.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 基础命令\n---\n\n## 一、启动Arthas\n\n``` \ncurl -O https://arthas.aliyun.com/arthas-boot.jar\njava -jar arthas-boot.jar\n```\n\n启动命令 `java -jar arthas-boot.jar`\n\n\n## 二、选择进程\n\n![](https://img.springlearn.cn/blog/learn_1647178107000.png)\n\n直接选择我们要监控的进程，输入3进入\n\n``` \n[INFO] Attach process 28667 success.\n[INFO] arthas-client connect 127.0.0.1 3658\n  ,---.  ,------. ,--------.,--.  ,--.  ,---.   ,---.                           \n /  O  \\ |  .--. ''--.  .--'|  '--'  | /  O  \\ '   .-'                          \n|  .-.  ||  '--'.'   |  |   |  .--.  ||  .-.  |`.  `-.                          \n|  | |  ||  |\\  \\    |  |   |  |  |  ||  | |  |.-'    |                         \n`--' `--'`--' '--'   `--'   `--'  `--'`--' `--'`-----'                          \n\nwiki       https://arthas.aliyun.com/doc                                        \ntutorials  https://arthas.aliyun.com/doc/arthas-tutorials.html                  \nversion    3.5.6                                                                \nmain_class com.example.demo.DemoApplication                                     \npid        28667                                                                \ntime       2022-03-13 21:31:04   \n```\n\n提示已经连接上进程。\n\n## 三、基础信息查询命令\n\n### 3.1 dashboard 看板命令\n\n输入 `dashboard`\n\n![](https://img.springlearn.cn/blog/learn_1647178404000.png)\n\n会定时将应用信息输出到控制台上。\n\n### 3.2 jad 反向编译\n\n` jad com.example.demo.DemoApplication`\n\n![](https://img.springlearn.cn/blog/learn_1647178673000.png)\n\n\n### 3.3 watch 监控指令\n\n这个命令是比较常用的命令,可以用来分析系统性能。\n\n```java \npackage com.example.demo;\n\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.ResponseBody;\nimport org.springframework.web.bind.annotation.RestController;\n@RestController\npublic class WebController {\n\n    @GetMapping(\"/get\")\n    @ResponseBody\n    public String get(String name) {\n        return name;\n    }\n}\n```\n\n监控这个类 `watch com.example.demo.WebController get returnObj`\n\n|参数名|含义|\n|:--:|:--:|\n|returnObj|返回值|\n|params|入参|\n|target|方法调用方|\n\n`watch com.example.demo.WebController get {params,returnObj,target}`\n\n``` \n[arthas@32818]$ watch com.example.demo.WebController get returnObj\nPress Q or Ctrl+C to abort.\nAffect(class count: 1 , method count: 1) cost in 120 ms, listenerId: 1\nmethod=com.example.demo.WebController.get location=AtExit\nts=2022-03-13 21:41:56; [cost=1.317166ms] result=@String[123]\nmethod=com.example.demo.WebController.get location=AtExit\nts=2022-03-13 21:42:03; [cost=0.051875ms] result=@String[测试]\n```\n\n# 四、退出\n\n输入 `q`\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/tools/arthas/base-cli.md b/docs/learn/tools/arthas/base-cli.md
--- a/docs/learn/tools/arthas/base-cli.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/tools/arthas/base-cli.md	(date 1655373430583)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/databases/sql/SQL索引性能优化.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: SQL索引性能优化\n---\n\n![](https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png)\n\n**作者**: 西魏陶渊明\n**博客**: [https://blog.springlearn.cn/](https://blog.springlearn.cn/)\n\n::: tip 西魏陶渊明\n莫笑少年江湖梦，谁不少年梦江湖\n:::\n\n# 建表\n\n```\n// 建表\nCREATE TABLE IF NOT EXISTS staffs(\n    id INT PRIMARY KEY AUTO_INCREMENT,\n    name VARCHAR(24) NOT NULL DEFAULT \"\" COMMENT'姓名',\n    age INT NOT NULL DEFAULT 0 COMMENT'年龄',\n    pos VARCHAR(20) NOT NULL DEFAULT \"\" COMMENT'职位',\n    add_time TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT'入职事件'\n) CHARSET utf8 COMMENT'员工记录表';\n\n// 插入数据\nINSERT INTO `test`.`staffs` (`name`, `age`, `pos`, `add_time`) VALUES ('z3', 22, 'manager', now());\nINSERT INTO `test`.`staffs` (`name`, `age`, `pos`, `add_time`) VALUES ('July', 23, 'dev', now());\nINSERT INTO `test`.`staffs` (`name`, `age`, `pos`, `add_time`) VALUES ('2000', 23, 'dev', now());\n\n// 建立复合索引（即一个索引包含多个字段）\nALTER TABLE staffs ADD INDEX idx_staffs_nameAgePos(name, age, pos);\n\n```\n---\n\n## 优化一、全部用到索引\n\n### 1. 介绍\n\n建立的复合索引包含了几个字段，查询的时候最好能全部用到，而且严格按照索引顺序，这样查询效率是最高的。（最理想情况，具体情况具体分析）\n\n\n### 2. SQL案例\n\n![](https://img.springlearn.cn/blog/learn_1596353647000.png)\n\n## 优化二、最左前缀法则\n\n### 1. 介绍\n\n如果建立的是复合索引，索引的顺序要按照建立时的顺序，即从左到右，如：a->b->c（和 B+树的数据结构有关）\n\n### 2. 无效索引举例\n\n如果用了a和c,那么a索引有效,c无效,因为中间跳过了b\n\n如果用了b和c,那么b索引和c索引都无效,因为跳过了a\n\n如果只用了c,那么也会无效,因为跳过了a和b\n\n![](https://img.springlearn.cn/blog/learn_1596354258000.png)\n\n\n## 优化三、不要对索引做以下处理\n\n### 1. 以下用法会导致索引失效\n\n- 计算，如：+、-、*、/、!=、<>、is null、is not null、or\n- 函数，如：sum()、round()等等\n- 手动/自动类型转换，如：id = \"1\"，本来是数字，给写成字符串了\n\n![](https://img.springlearn.cn/blog/learn_1596354578000.png)\n\n\n## 优化四、索引不要放在范围查询右边\n\n### 1. 举例\n\n比如复合索引：a->b->c，当 where a=\"\" and b>10 and 3=\"\"，这时候只能用到 a 和 b，c 用不到索引，因为在范围之后索引都失效（和 B+树结构有关）\n\n因为b使用了范围,所以右边的索引c就失效了\n\n\n![](https://img.springlearn.cn/blog/learn_1596355600000.png)\n\n\n## 优化五、减少 select * 的使用\n\n### 1. 使用覆盖索引\n\n即：select 查询字段和 where 中使用的索引字段一致。\n\n![](https://img.springlearn.cn/blog/learn_1596355952000.png)\n\n\n## 优化六、like 模糊搜索\n\n### 1. 失效情况\nlike \"%张三%\"\nlike \"%张三\"\n\n### 2. 解决方案\n\n- 使用复合索引，即 like 字段是 select 的查询字段，如：select name from table where name like \"%张三%\"\n使用 like \"张三%\"\n\n- 使用 like \"张三%\"\n\n\n## 优化七、order by 优化\n\n当查询语句中使用 order by 进行排序时，如果没有使用索引进行排序，会出现 filesort 文件内排序，这种情况在数据量大或者并发高的时候，会有性能问题，需要优化。\n\n### 1. filesort 出现的情况举例\n\n- order by 字段不是索引字段\n- order by 字段是索引字段，但是 select 中没有使用覆盖索引，如：`select * from staffs order by age asc;`\n- order by 中同时存在 ASC 升序排序和 DESC 降序排序，如：`select a, b from staffs order by a desc, b asc;`\n- order by 多个字段排序时，不是按照索引顺序进行 order by，即不是按照最左前缀法则，如：`select a, b from staffs order by b asc, a asc;`\n\n### 2. 索引层面解决方法\n\n- 使用主键索引排序\n- 按照最左前缀法则，并且使用覆盖索引排序，多个字段排序时，保持排序方向一致\n- 在 SQL 语句中强制指定使用某索引，force index(索引名字)\n- 不在数据库中排序，在代码层面排序\n\n### 3. order by 排序算法\n\n**双路排序**\n\n*Mysql4.1 之前是使用双路排序，字面的意思就是两次扫描磁盘，最终得到数据，读取行指针和 ORDER BY 列，对他们进行排序，然后扫描已经排好序的列表，按照列表中的值重新从列表中读取对数据输出。也就是从磁盘读取排序字段，在 buffer 进行排序，再从磁盘读取其他字段。*\n\n文件的磁盘 IO 非常耗时的，所以在 Mysql4.1 之后，出现了第二种算法，就是单路排序。\n\n*从磁盘读取查询需要的所有列，按照 orderby 列在 buffer 对它们进行排序，然后扫描排序后的列表进行输出， 它的效率更快一些，避免了第二次读取数据，并且把随机 IO 变成顺序 IO，但是它会使用更多的空间， 因为它把每一行都保存在内存中了。*\n\n当我们无可避免要使用排序时，索引层面没法在优化的时候又该怎么办呢？尽可能让 MySQL 选择使用第二种单路算法来进行排序。这样可以减少大量的随机 IO 操作,很大幅度地提高排序工作的效率。下面看看单路排序优化需要注意的点\n\n**单路排序优化点**\n\n增大 max_length_for_sort_data\n\n*在 MySQL 中,决定使用\"双路排序\"算法还是\"单路排序\"算法是通过参数 maxlength_for sort_data 来决定的。当所有返回字段的最大长度小于这个参数值时,MySQL 就会选择\"单路排序\"算法,反之,则选择\"多路排序\"算法。所以,如果有充足的内存让 MySQL 存放须要返回的非排序字段,就可以加大这个参数的值来让 MySQL 选择使用\"单路排序\"算法。*\n\n去掉不必要的返回字段，避免select *\n\n*当内存不是很充裕时,不能简单地通过强行加大上面的参数来强迫 MySQL 去使用\"单路排序\"算法,否则可能会造成 MySQL 不得不将数据分成很多段,然后进行排序,这样可能会得不偿失。此时就须要去掉不必要的返回字段,让返回结果长度适应 max_length_for_sort_data 参数的限制。*\n\n增大 sort_buffer_size 参数设置\n\n*这个值如果过小的话,再加上你一次返回的条数过多,那么很可能就会分很多次进行排序,然后最后将每次的排序结果再串联起来,这样就会更慢,增大 sort_buffer_size 并不是为了让 MySQL 选择\"单路排序\"算法,而是为了让 MySQL 尽量减少在排序过程中对须要排序的数据进行分段,因为分段会造成 MySQL 不得不使用临时表来进行交换排序。*\n\n但是sort_buffer_size 不是越大越好：\n\n- Sort_Buffer_Size 是一个 connection 级参数,在每个 connection 第一次需要使用这个 buffer 的时候,一次性分配设置的内存。\n- Sort_Buffer_Size 并不是越大越好,由于是 connection 级的参数,过大的设置和高并发可能会耗尽系统内存资源。\n- 据说 Sort_Buffer_Size 超过 2M 的时候,就会使用 mmap() 而不是 malloc() 来进行内存分配,导致效率降低。\n\n\n## 优化八、group by\n\n其原理也是先排序后分组，其优化方式可参考order by。where高于having,能写在where限定的条件就不要去having限定了。\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/databases/sql/SQL索引性能优化.md b/docs/learn/databases/sql/SQL索引性能优化.md
--- a/docs/learn/databases/sql/SQL索引性能优化.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/databases/sql/SQL索引性能优化.md	(date 1655373430446)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/tools/arthas/learn.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 基础教程\n---\n\n## 一、启动Arthas\n\n``` \ncurl -O https://arthas.aliyun.com/arthas-boot.jar\njava -jar arthas-boot.jar\n```\n\n启动命令 `java -jar arthas-boot.jar`\n\n\n## 二、选择进程\n\n![](https://img.springlearn.cn/blog/learn_1647178107000.png)\n\n直接选择我们要监控的进程，输入3进入\n\n``` \n[INFO] Attach process 28667 success.\n[INFO] arthas-client connect 127.0.0.1 3658\n  ,---.  ,------. ,--------.,--.  ,--.  ,---.   ,---.                           \n /  O  \\ |  .--. ''--.  .--'|  '--'  | /  O  \\ '   .-'                          \n|  .-.  ||  '--'.'   |  |   |  .--.  ||  .-.  |`.  `-.                          \n|  | |  ||  |\\  \\    |  |   |  |  |  ||  | |  |.-'    |                         \n`--' `--'`--' '--'   `--'   `--'  `--'`--' `--'`-----'                          \n\nwiki       https://arthas.aliyun.com/doc                                        \ntutorials  https://arthas.aliyun.com/doc/arthas-tutorials.html                  \nversion    3.5.6                                                                \nmain_class com.example.demo.DemoApplication                                     \npid        28667                                                                \ntime       2022-03-13 21:31:04   \n```\n\n提示已经连接上进程。\n\n## 三、基础信息查询命令\n\n### 3.1 dashboard 看板命令\n\n输入 `dashboard`\n\n![](https://img.springlearn.cn/blog/learn_1647178404000.png)\n\n会定时将应用信息输出到控制台上。\n\n### 3.2 jad 反向编译\n\n` jad com.example.demo.DemoApplication`\n\n![](https://img.springlearn.cn/blog/learn_1647178673000.png)\n\n\n### 3.3 watch 监控指令\n\n这个命令是比较常用的命令,可以用来分析系统性能。\n\n```java \npackage com.example.demo;\n\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.ResponseBody;\nimport org.springframework.web.bind.annotation.RestController;\n@RestController\npublic class WebController {\n\n    @GetMapping(\"/get\")\n    @ResponseBody\n    public String get(String name) {\n        return name;\n    }\n}\n```\n\n监控这个类 `watch com.example.demo.WebController get returnObj`\n\n|参数名|含义|\n|:--:|:--:|\n|returnObj|返回值|\n|params|入参|\n|target|方法调用方|\n\n`watch com.example.demo.WebController get {params,returnObj,target}`\n\n``` \n[arthas@32818]$ watch com.example.demo.WebController get returnObj\nPress Q or Ctrl+C to abort.\nAffect(class count: 1 , method count: 1) cost in 120 ms, listenerId: 1\nmethod=com.example.demo.WebController.get location=AtExit\nts=2022-03-13 21:41:56; [cost=1.317166ms] result=@String[123]\nmethod=com.example.demo.WebController.get location=AtExit\nts=2022-03-13 21:42:03; [cost=0.051875ms] result=@String[测试]\n```\n\n# 四、退出\n\n输入 `q`\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/tools/arthas/learn.md b/docs/learn/tools/arthas/learn.md
--- a/docs/learn/tools/arthas/learn.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/tools/arthas/learn.md	(date 1655373430336)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/databases/sql/SQL锁机制.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: SQL锁机制\n---\n\n![](https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png)\n\n**作者**: 西魏陶渊明\n**博客**: [https://blog.springlearn.cn/](https://blog.springlearn.cn/)\n\n::: tip 西魏陶渊明\n莫笑少年江湖梦，谁不少年梦江湖\n:::\n\n## 一、场景模拟\n\n\n```sql\ncreate table shop\n(\n  id int(4) primary key default 0,\n  name varchar(20) default '衣服',\n  status varchar(20) default '可售'\n)engine = innodb default charset=utf8;\n\ninsert into shop  values(1,'衣服','可售');\n```\n\n```\nmysql> select * from shop;\n+----+--------+--------+\n| id | name   | status |\n+----+--------+--------+\n|  1 | 衣服   | 可售   |\n+----+--------+--------+\n1 row in set (0.00 sec)\n```\n\n有一个X姨夫,两个用户并发操作问题\n\nA先看到衣服: X加锁 -> 试衣服 -> 下单 -> 付款 -> 打包 -> X解锁\nB也相对衣服: 发现X已经被A加锁了,等待X解锁。\n\n## 二、锁知识\n\n### 锁类型\na. 读锁(共享锁):\nb. 写锁(互斥锁): 如果当前写操作没有完毕,则无法进行其他的写操作。\n\n### 锁范围\n\n- innodb默认行锁(开销大,加锁慢,锁范围小,易死锁,不容器锁冲突,并发度高)\n- MyISAM默认表锁(开销小,加锁块,无死锁,但是锁范围大容器锁冲突,并发度低)\n\n1. 表锁(对一张表整体加锁)\n2. 行锁(对一行数据进行加锁)\n\n---\n\n## 三、锁分析\n\n### 1. 查看加锁的表\n\n\n`show open tables;`\n\n1代表加锁\n\n```\nmysql> show open tables;\n+--------------------+---------------------------+--------+-------------+\n| Database           | Table                     | In_use | Name_locked |\n+--------------------+---------------------------+--------+-------------+\n| test               | emp                       |      0 |           0 |\n| test               | test_innodb_lock          |      0 |           0 |\n| test               | test03                    |      0 |           0 |\n| test               | teacher2                  |      0 |           0 |\n| test               | course2                   |      0 |           0 |\n| test               | book                      |      0 |           0 |\n| test               | shop                      |      1 |           0 |\n| test               | staffs                    |      0 |           0 |\n| test               | dept                      |      0 |           0 |\n+--------------------+---------------------------+--------+-------------+\n73 rows in set (0.00 sec)\n```\n\n### 2. 查看锁的严重程度\n\n`show status like '%Table_locks%';`\n\n\n```\nmysql> show status like '%Table_locks%';\n+-----------------------+-------+\n| Variable_name         | Value |\n+-----------------------+-------+\n| Table_locks_immediate | 79    |\n| Table_locks_waited    | 0     |\n+-----------------------+-------+\n2 rows in set (0.00 sec)\n```\n\n**Table_locks_immediate** 能立马加锁\n**Table_locks_waited** 越大说明竞争越大\n\n建议:\nTable_locks_immediate/Table_locks_waited > 5000,建议采用innodb,否则建议MyISAM。\n\n\n## 四、模拟加表锁\n\n`lock table 表1 read/write,表2 read/write`\n\n```\nlock table shop write;\n```\n\n\n### 加表读锁\n\n\n如A会话,对shop表加了read锁,则该会话可以对shop表进行读操作,不能进行写操作。\n并且只能读自己加锁了的表,如下面列子最shop加锁,能读shop不能写shop,不能读test03\n\n**如果对shop表加了read锁,那么只能对shop进行读,其他任何操作都不行了**\n\n\n```\nmysql> lock table shop read;\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql> select * from shop\n    -> ;\n+----+--------+-----------+\n| id | name   | status    |\n+----+--------+-----------+\n|  1 | 衣服   | 已占用    |\n+----+--------+-----------+\n1 row in set (0.00 sec)\n\nmysql> update shop set status = '可售' where id = 1;\nERROR 1099 (HY000): Table 'shop' was locked with a READ lock and can't be updated\nmysql> select * from test03;\nERROR 1100 (HY000): Table 'test03' was not locked with LOCK TABLES\n```\n\n![](https://img.springlearn.cn/blog/learn_1596460128000.png)\n\n\n其他B会话中,对于shop表能读不能写,但是不影响操作其他表。\n\n![](https://img.springlearn.cn/blog/learn_1596460283000.png)\n\n### 加表写锁\n\n- 会话A: lock table shop write;\n    当前会话可以对加了锁的表进行任意操作;但是不能操作其他表。\n- 其他会话B:\n    当会话A释放了锁,B才能对这个表进行增删改查;\n\n\n## 五、模拟加行锁\n\n```sql\ncreate table linelock\n(\n    id int(5) primary key auto_increment,\n    name varchar(20)\n) engine = innodb;\n\ninsert into linelock(name) values('1');\ninsert into linelock(name) values('2');\ninsert into linelock(name) values('3');\ninsert into linelock(name) values('4');\ninsert into linelock(name) values('5');\n```\n\n### A窗口写操作\n\n`insert into linelock(name) values('6');`\n\n\n此时B窗口执行update更新会被锁定。\n\n![](https://img.springlearn.cn/blog/learn_1596463371000.png)\n\n当A会话commit之后B就能继续操作了。\n![](https://img.springlearn.cn/blog/learn_1596463461000.png)\n\n行锁是通过事务进行解锁的。\n\n### 行锁转表锁\n\n如果索引列进行了类型转换,则索引失效。\n\n\nA窗口执行\n`update linelock set name = 'ai' where name = 3;`\n\nB窗口执行\n`update linelock set name = 'ax' where name = 4;`\n\n\n![](https://img.springlearn.cn/blog/learn_1596464724000.png)\n\n\n### 间隙锁\n\nupdate linelock set name = 'x' where id > 1 and id < 8;\n\n![](https://img.springlearn.cn/blog/learn_1596465102000.png)\n\n### 行锁分析\n\n`show status like '%innodb_row_lock%';`\n\n```\nmysql> show status like '%innodb_row_lock%';\n+-------------------------------+--------+\n| Variable_name                 | Value  |\n+-------------------------------+--------+\n| Innodb_row_lock_current_waits | 1      |\n| Innodb_row_lock_time          | 207248 |\n| Innodb_row_lock_time_avg      | 34541  |\n| Innodb_row_lock_time_max      | 51605  |\n| Innodb_row_lock_waits         | 6      |\n+-------------------------------+--------+\n5 rows in set (0.00 sec)\n```\n\n![](https://img.springlearn.cn/blog/learn_1596465415000.png)\n\n\n| Variable_name                 | Value  |\n| ------ | ----- |\n| Innodb_row_lock_current_waits | 当前正在等待的锁的数量      |\n| Innodb_row_lock_time          | 等待总时长,从系统启动到现在一共等待时间 |\n| Innodb_row_lock_time_avg      | 平均等待时长  |\n| Innodb_row_lock_time_max      | 最大等待时长  |\n| Innodb_row_lock_waits         | 等待的次数      |\n\n\n### 查询语句加锁\n\n`set autocommit=0;`\n`select * from linelock for update;`\n\n![](https://img.springlearn.cn/blog/learn_1596466172000.png)\n\n\n最后求关注,求订阅,谢谢你的阅读!\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/databases/sql/SQL锁机制.md b/docs/learn/databases/sql/SQL锁机制.md
--- a/docs/learn/databases/sql/SQL锁机制.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/databases/sql/SQL锁机制.md	(date 1655373430509)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/databases/sql/SQL优化示例.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: Mysql优化示例\n---\n\n![](https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png)\n\n**作者**: 西魏陶渊明\n**博客**: [https://blog.springlearn.cn/](https://blog.springlearn.cn/)\n\n::: tip 西魏陶渊明\n莫笑少年江湖梦，谁不少年梦江湖\n:::\n\n## 创建表\n\n```sql\nuse test;\ncreate table test03\n(\n a1 int(4) not null,\n a2 int(4) not null,\n a3 int(4) not null,\n a4 int(4) not null\n);\nalter table test03 add index idx_a1_a2_a3_a4(a1,a2,a3,a4);\n\n```\n---\n\n## 建议一、按照复合索引顺序查询\n\n**需知**\n1. 如果(a,b,c,d)复合索引和查询使用的顺序全部一致,则复合索引全部使用,如果不部分一致或者跨列使用则就是部分使用.\n2. where和order by拼起来也不要跨列,参考反例2和3\n\n### 1. 建议\n\n- 建议: 按照where后面按照顺序使用复合索引\n- 建议: where 和 order by不要跨列\n`explain select a1,a2,a3,a4 from test03 where a1=1 and a2=2 and a3=3 and a4=4;`\n\n![](https://img.springlearn.cn/blog/learn_1596388059000.png)\n\n### 2. 反例1\n\n`explain select a1,a2,a3,a4 from test03 where a4=1 and a3=2 and a2=3 and a1=4;`\n\n可以看到还是一样的,索引都用了，原因是sql在执行时候被sql优化器进行了调整,最后被调整成了上面的顺序写法。\n这是最理想的情况,但是实际中建议开发按照顺序来进行查询。\n![](https://img.springlearn.cn/blog/learn_1596388250000.png)\n\n### 3. 反例2\n\n`explain select a1,a2,a3,a4 from test03 where a1=1 and a2=2 and a4=4 order by a3;`\n\n- 因为查询条件中复合索引跨列了(跨了a3)，所以导致只能用a1 和a2索引。索引key_len变成8了\n- 索引中没有查询a3但是却用a3排序了,导致要回表查询a3\n![](https://img.springlearn.cn/blog/learn_1596388567000.png)\n\n### 4. 反例3\n\n`explain select a1,a2,a3,a4 from test03 where a1=1 and a4=4 order by a3;`\n\n- 跨了a2 a3 所以a4失效只能用a1 所以key_len只有一个\n  where 和 order by拼接起来是否也满足复合顺序,如果不满足\n  就会出现Using filesort\n- 反例2中where 生效的是a1和a2，但是order by是a3。满足复合索引顺序,所以不会出现Using filesort\n\n![](https://img.springlearn.cn/blog/learn_1596389005000.png)\n\n\n`explain select a1,a2,a3,a4 from test03 where a1=1 and a4=4 order by a2,a3;`\n\n- where a1 order by a2 a3 所以不会出现上面Using fileSort\n![](https://img.springlearn.cn/blog/learn_1596389167000.png)\n\n\n## 建议二、单表优化\n\n\n### 建表及需求sql\n\n```\n\ncreate table book\n(\n bid int(4) primary key,\n name varchar(20) not null,\n authorid int(4) not null,\n publicid int(4) not null,\n typeid int(4) not null\n);\n\ninsert into book values(1,'tjava',1,1,2);\ninsert into book values(2,'tjava',2,1,2);\ninsert into book values(3,'tjava',3,2,1);\ninsert into book values(4,'tjava',4,2,3);\n\n```\n\n**查询authorid = 1 并且 typeid 等于2或者3 然后根据typeid 排序**\n\n\n\n`explain select bid from book where  typeid in (2,3) and authorid = 1  order by typeid desc;`\n\n\n```\nmysql> explain select bid from book where  typeid in (2,3) and authorid = 1  order by typeid desc;\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------------------+\n| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                       |\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------------------+\n|  1 | SIMPLE      | book  | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    4 |    25.00 | Using where; Using filesort |\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------------------+\n1 row in set, 1 warning (0.00 sec)\n```\n\n可以看出来未用到索引,type是all。就是全表查询了。\n\n### 1. 优化1加索引\n\n\n`alter table book add index idx_bta(bid,typeid,authorid);`\n\n```\nmysql> explain select bid from book where  typeid in (2,3) and authorid = 1  order by typeid desc;\n+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+------------------------------------------+\n| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra                                    |\n+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+------------------------------------------+\n|  1 | SIMPLE      | book  | NULL       | index | NULL          | idx_bta | 12      | NULL |    4 |    25.00 | Using where; Using index; Using filesort |\n+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+------------------------------------------+\n1 row in set, 1 warning (0.00 sec)\n```\n\n可以看到通过了加索引type由之前的all变成了index,说明有一点进步。但是我们看到还有一个`Using filesort`.前面我们说了出现这个\n是因为额外多了一次查询。根据sql的解析规则，第一个解析的是typeid,第二个是authorid。那么我们先对索引顺序做一个优化。\n\n\n### 2. 优化索引顺序\n\n复合索引一旦进行了升级优化，就要删除了，否则会进行干扰。`drop index idx_bta on book;`\n\n按照sql执行顺序来创建索引。这里我们其实也可以不创建bid，但是如果不创建bid,就要回表去查询bid,所以也建议加上。\n`alter table book add index idx_tab(typeid,authorid,bid);`\n\n```\nmysql> explain select bid,typeid from book where  typeid in (2,3) and authorid = 1  order by typeid desc;\n+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-----------------------------------------------+\n| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra                                         |\n+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-----------------------------------------------+\n|  1 | SIMPLE      | book  | NULL       | range | idx_tab       | idx_tab | 8       | NULL |    2 |   100.00 | Using where; Backward index scan; Using index |\n+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-----------------------------------------------+\n1 row in set, 1 warning (0.00 sec)\n```\n可以看到已经没有了,Using filesort。\n\n### 3. 总结\n\n- 索引优化不会一步到位,要多次优化。\n- 索引顺序会影响查询效率,如果不知道怎么优化,建议sql执行顺序,多尝试几次不同顺序。通过看type的级别来调整。\n- type如果是range或者ref。其实就可以了。如果是index或者all就要考虑是否要进行优化。\n- in会是索引失效\n\n\n## 建议三、多表优化\n\n### 建表及需求sql\n\n```\ncreate table teacher2\n(\n    tid int(4) primary key,\n    cid int(4) not null\n);\n\ninsert into teacher2 values(1,2);\ninsert into teacher2 values(2,1);\ninsert into teacher2 values(3,3);\n\ncreate table course2\n(\n    cid int(4),\n    cname varchar(20)\n);\ninsert into course2 values(1,'java');\ninsert into course2 values(2,'python');\ninsert into course2 values(3,'kotlin');\n```\n\n**需求sql**\n\n`select * from teacher2 t left outer join course2 c on t.cid=c.cid where c.cname = 'java';`\n\n```\nmysql> select * from teacher2 t left outer join course2 c on t.cid=c.cid where c.cname = 'java';\n+-----+-----+------+-------+\n| tid | cid | cid  | cname |\n+-----+-----+------+-------+\n|   2 |   1 |    1 | java  |\n+-----+-----+------+-------+\n1 row in set (0.00 sec)\n```\n\n执行计划分析\n\n```\nmysql> explain select * from teacher2 t left outer join course2 c on t.cid=c.cid where c.cname = 'java';\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+\n| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                              |\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+\n|  1 | SIMPLE      | c     | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |    33.33 | Using where                                        |\n|  1 | SIMPLE      | t     | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |    33.33 | Using where; Using join buffer (Block Nested Loop) |\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+\n2 rows in set, 1 warning (0.00 sec)\n```\n\n可以看到有一个`Using join buffer `。 说明Sql写的太差了，mysql给你加了一个缓存。经过下面的索引优化会去掉。\n\n### 优化1小表驱动大表\n\n当编写语句时候,将数据量小的表放左边(假设此时t表小,on t.cid = c.cid);反之如果c表小(on c.cid = t.tic)\n\n### 优化2加索引\n\n索引建立在经常使用的字段上,本例中t.cid使用频繁。\n\n`alter table teacher2 add index idx_teacher2_cid(cid);`\n\n```\nmysql> explain select * from teacher2 t left outer join course2 c on t.cid=c.cid where c.cname = 'java';\n+----+-------------+-------+------------+------+------------------+------------------+---------+------------+------+----------+-------------+\n| id | select_type | table | partitions | type | possible_keys    | key              | key_len | ref        | rows | filtered | Extra       |\n+----+-------------+-------+------------+------+------------------+------------------+---------+------------+------+----------+-------------+\n|  1 | SIMPLE      | c     | NULL       | ALL  | NULL             | NULL             | NULL    | NULL       |    3 |    33.33 | Using where |\n|  1 | SIMPLE      | t     | NULL       | ref  | idx_teacher2_cid | idx_teacher2_cid | 4       | test.c.cid |    1 |   100.00 | Using index |\n+----+-------------+-------+------------+------+------------------+------------------+---------+------------+------+----------+-------------+\n2 rows in set, 1 warning (0.00 sec)\n\n```\n\n给name也加索引\n\n`alter table course2 add index idx_course2_name(cname);`\n\n```\nmysql> explain select * from teacher2 t left outer join course2 c on t.cid=c.cid where c.cname = 'java';\n+----+-------------+-------+------------+------+------------------+------------------+---------+------------+------+----------+-------------+\n| id | select_type | table | partitions | type | possible_keys    | key              | key_len | ref        | rows | filtered | Extra       |\n+----+-------------+-------+------------+------+------------------+------------------+---------+------------+------+----------+-------------+\n|  1 | SIMPLE      | c     | NULL       | ref  | idx_course2_name | idx_course2_name | 83      | const      |    1 |   100.00 | Using where |\n|  1 | SIMPLE      | t     | NULL       | ref  | idx_teacher2_cid | idx_teacher2_cid | 4       | test.c.cid |    1 |   100.00 | Using index |\n+----+-------------+-------+------------+------+------------------+------------------+---------+------------+------+----------+-------------+\n2 rows in set, 1 warning (0.00 sec)\n```\n\n这样两个查询就都用到了索引。\n\n\n## 建议四、sql优化\n\n### 1. exist和in\n\n如果主查询的数据集大用 `in` ,如果子查询数据量大使用 `exist`\n\n### 2. order by优化\n\nUsing filesort 有两种算法: 双路排序、单路排序(根据IO的次数,即访问磁盘的顺序)\n\n- MySQL4.1前默认使用双路排序,即扫描两次磁盘(1. 从磁盘读取排序字段,2. 扫描其他字段)\n- MySQL4.1后默认使用单路排序,即访问一次磁盘(1. 只读取一次字段,然后在buffer中进行排序)\n\n但是单路排序有隐患就是不一定是只访问一次磁盘,因为加入数据量特别大,则无法将所有字段的\n数据都放到buffer中,要多次分片读取。此时可以考虑调大buffer容量大小。\n\n`set max_length_for_sort_data = 1024` (单位/字节)\n\n如果缓存区大小太小,mysql会自动从单路调整到双路。\n\n**建议**\n\n- 避免使用`select *`\n- 复合索引不要跨列使用,如果where和order尽量也按照顺序使用\n- order by 如果是多个字段,建议都是升序或者都是降序\n\n### 3. 慢查询日志\n\n\n[如何找到垃圾SQL语句,你知道这些方式吗？](https://blog.springlearn.cn/posts/3935/)\n\n慢sql就是mysql提供的一种日志记录,用于记录响应的时间超过阀值得语句;\n\n**查询是否开启慢查询**\n\n`show variables like '%slow_query_log%';`\n\n```\nmysql> show variables like '%slow_query_log%';\n+---------------------+-----------------------------------------+\n| Variable_name       | Value                                   |\n+---------------------+-----------------------------------------+\n| slow_query_log      | OFF                                     |\n| slow_query_log_file | /usr/local/var/mysql/localhost-slow.log |\n+---------------------+-----------------------------------------+\n2 rows in set (0.06 sec)\n```\n\n\n**临时开启:**\n\n```\nset global slow_query_log = 1;\nexit;\nservices mysql restart\n```\n\n**查询慢查询日志阀值**\n\n`show variables like '%long_query_time%';`\n\n```\nmysql> show variables like '%long_query_time%';\n+-----------------+-----------+\n| Variable_name   | Value     |\n+-----------------+-----------+\n| long_query_time | 10.000000 |\n+-----------------+-----------+\n1 row in set (0.00 sec)\n```\n\n**临时设置阀值**\n\n修改完成之后要重新登录生效\n```\nset global long_query_time = 5;\n```\n\n```\nmysql> show variables like '%long_query_time%';\n+-----------------+-----------+\n| Variable_name   | Value     |\n+-----------------+-----------+\n| long_query_time | 10.000000 |\n+-----------------+-----------+\n1 row in set (0.00 sec)\n\nmysql> set global long_query_time = 5;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> show variables like '%long_query_time%';\n+-----------------+-----------+\n| Variable_name   | Value     |\n+-----------------+-----------+\n| long_query_time | 10.000000 |\n+-----------------+-----------+\n1 row in set (0.00 sec)\n\nmysql> exit\nBye\n liuxin@localhost \uE0B0 ~ \uE0B0 mysql -u root -p\nEnter password:\nWelcome to the MySQL monitor.  Commands end with ; or \\g.\nYour MySQL connection id is 9\nServer version: 8.0.16 Homebrew\n\nCopyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.\n\nOracle is a registered trademark of Oracle Corporation and/or its\naffiliates. Other names may be trademarks of their respective\nowners.\n\nType 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.\n\nmysql> show variables like '%long_query_time%';\n+-----------------+----------+\n| Variable_name   | Value    |\n+-----------------+----------+\n| long_query_time | 5.000000 |\n+-----------------+----------+\n1 row in set (0.00 sec)\n\nmysql>\n\n```\n\n#### 超过阀值得数量\n\n`show global status like '%slow_queries%';`\n\n```\nmysql> show global status like '%slow_queries%';\n+---------------+-------+\n| Variable_name | Value |\n+---------------+-------+\n| Slow_queries  | 0     |\n+---------------+-------+\n1 row in set (0.01 sec)\n```\n\n\n## 总结\n\n1. 复合索引,不要跨列或无序使用\n2. 复合索引,尽量使用全索引匹配\n3. 不要在索引上进行计算、函数、类型转换\n4. 复合索引不能使用 != 、 <> 、 is null\n5. like尽量以\"常量\"开头,不要以\"%\"开头,否则索引失效\n6. 尽量不要使用类型转换（显式、隐式）,否则索引失效。where name = 'lx' 可以。where name\n    ![](https://img.springlearn.cn/blog/learn_1596447963000.png)\n7. 尽量不要用or,否则左右索引都可能失效\n    ![](https://img.springlearn.cn/blog/learn_1596448080000.png)\n\n最后求关注,求订阅,谢谢你的阅读!\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/databases/sql/SQL优化示例.md b/docs/learn/databases/sql/SQL优化示例.md
--- a/docs/learn/databases/sql/SQL优化示例.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/databases/sql/SQL优化示例.md	(date 1655373430278)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/tools/arthas/watch-cli.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: monitor/watch/trace相关\n---\n\n## 一、启动Arthas\n\n``` \ncurl -O https://arthas.aliyun.com/arthas-boot.jar\njava -jar arthas-boot.jar\n```\n\n启动命令 `java -jar arthas-boot.jar`\n\n\n## 二、选择进程\n\n![](https://img.springlearn.cn/blog/learn_1647178107000.png)\n\n直接选择我们要监控的进程，输入3进入\n\n``` \n[INFO] Attach process 28667 success.\n[INFO] arthas-client connect 127.0.0.1 3658\n  ,---.  ,------. ,--------.,--.  ,--.  ,---.   ,---.                           \n /  O  \\ |  .--. ''--.  .--'|  '--'  | /  O  \\ '   .-'                          \n|  .-.  ||  '--'.'   |  |   |  .--.  ||  .-.  |`.  `-.                          \n|  | |  ||  |\\  \\    |  |   |  |  |  ||  | |  |.-'    |                         \n`--' `--'`--' '--'   `--'   `--'  `--'`--' `--'`-----'                          \n\nwiki       https://arthas.aliyun.com/doc                                        \ntutorials  https://arthas.aliyun.com/doc/arthas-tutorials.html                  \nversion    3.5.6                                                                \nmain_class com.example.demo.DemoApplication                                     \npid        28667                                                                \ntime       2022-03-13 21:31:04   \n```\n\n提示已经连接上进程。\n\n## 三、基础信息查询命令\n\n### 3.1 dashboard 看板命令\n\n输入 `dashboard`\n\n![](https://img.springlearn.cn/blog/learn_1647178404000.png)\n\n会定时将应用信息输出到控制台上。\n\n### 3.2 jad 反向编译\n\n` jad com.example.demo.DemoApplication`\n\n![](https://img.springlearn.cn/blog/learn_1647178673000.png)\n\n\n### 3.3 watch 监控指令\n\n这个命令是比较常用的命令,可以用来分析系统性能。\n\n```java \npackage com.example.demo;\n\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.ResponseBody;\nimport org.springframework.web.bind.annotation.RestController;\n@RestController\npublic class WebController {\n\n    @GetMapping(\"/get\")\n    @ResponseBody\n    public String get(String name) {\n        return name;\n    }\n}\n```\n\n监控这个类 `watch com.example.demo.WebController get returnObj`\n\n|参数名|含义|\n|:--:|:--:|\n|returnObj|返回值|\n|params|入参|\n|target|方法调用方|\n\n`watch com.example.demo.WebController get {params,returnObj,target}`\n\n``` \n[arthas@32818]$ watch com.example.demo.WebController get returnObj\nPress Q or Ctrl+C to abort.\nAffect(class count: 1 , method count: 1) cost in 120 ms, listenerId: 1\nmethod=com.example.demo.WebController.get location=AtExit\nts=2022-03-13 21:41:56; [cost=1.317166ms] result=@String[123]\nmethod=com.example.demo.WebController.get location=AtExit\nts=2022-03-13 21:42:03; [cost=0.051875ms] result=@String[测试]\n```\n\n# 四、退出\n\n输入 `q`\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/tools/arthas/watch-cli.md b/docs/learn/tools/arthas/watch-cli.md
--- a/docs/learn/tools/arthas/watch-cli.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/tools/arthas/watch-cli.md	(date 1655373430397)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/databases/sql/海量数据模拟.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 海量数据模拟\n---\n\n![](https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png)\n\n**作者**: 西魏陶渊明\n**博客**: [https://blog.springlearn.cn/](https://blog.springlearn.cn/)\n\n::: tip 西魏陶渊明\n莫笑少年江湖梦，谁不少年梦江湖\n:::\n\n## 一、创建表\n\n```sql\ncreate table dept\n(\n dno int(5) primary key default 0,\n dname varchar(20) not null default '',\n loc varchar(30) default ''\n) engine =innodb default charset=utf8;\n\ncreate table emp\n(\n eid int(5) primary key,\n ename varchar(20) not null default '',\n job varchar(20) not null default '',\n deptno int(5) not null default 0\n) engine =innodb default  charset=utf8;\n\n```\n\n## 二、存储函数插入海量数量\n\n存储过程无return,存储函数有。\n\n### 1. 创建存储函数生成id和name\nname随机字符串\n\n```\ndelimiter $\ncreate function randstring(n int) returns varchar(255)\nbegin \n    declare all_str varchar(100) default 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n    declare return_str varchar(255) default '';\n    declare i int default 0;\n    while i <n\n    do\n        set return_str = concat(return_str,substring(all_str,rand()*52,1));\n        set i = i+1;\n    end while;    \n    return return_str;\nend $\n```\n\n\n`ERROR 1418 (HY000): This function has none of DETERMINISTIC, NO SQL, or READS SQL DATA in its declaration and binary logging is enabled (you *might* want to use the less safe log_bin_trust_function_creators variable)`\n\n如果开启了慢慢查询日志,在开启存储函数就会冲突,解决办法1就是管理慢日志查询。\n\n解决办法2:\n\n`show variables like '%log_bin_trust_function_creators%';`\n\n`set global log_bin_trust_function_creators=1;`\n\n\n\nid随机数\n\n```\ndelimiter $\ncreate function rand_num()returns int(5)\nbegin\n    declare i int default 0;\n    set i = floor(rand() * 100);\n    return i;\nend $;    \n```\n\n### 2. 通过存储过程插入海量数据emp\n\n\n```\ncreate procedure insert_emp(in eid_start int(10),in data_times int(10))\nbegin\n    declare i int default 0;\n    set autocommit = 0;\n    repeat\n        insert into emp values(eid_start + i,randstring(5),'other',rand_num());\n        set i = i + 1;\n        until i = data_times\n    end repeat;   \n    commit;\nend $;    \n```\n\n\n### 2. 通过存储过程插入海量数据dept\n\n```\ncreate procedure insert_dept(in dno_start int(10),in data_times int(10))\nbegin\n    declare i int default 0;\n    set autocommit = 0;\n    repeat\n        insert into dept values(dno_start+i,randstring(6),randstring(8));\n        set i = i + 1;\n        until i = data_times\n    end repeat;\ncommit;\nend$    \n```\n\n### 3. 插入海量数据\n\n`delimiter ;`分割符改回原来\n\n员工表插入80w条数据\n`call insert_emp(1000,800000);`\n部门表插入30条数据\n`call insert_dept(10,30);`\n\n\n```\nmysql> select count(1) from emp;\n+----------+\n| count(1) |\n+----------+\n|   800000 |\n+----------+\n1 row in set (0.05 sec)\n\nmysql> select count(1) from dept;\n+----------+\n| count(1) |\n+----------+\n|       30 |\n+----------+\n1 row in set (0.00 sec)\n\n```\n\n## 三、利用profiles分析海量数据\n\n### 1. 打开profiles\n\n```\nset profiling = on;\nshow variables like '%profiling%';\n\nmysql> set profiling = on;\nQuery OK, 0 rows affected, 1 warning (0.00 sec)\n\nmysql> show variables like '%profiling%';\n+------------------------+-------+\n| Variable_name          | Value |\n+------------------------+-------+\n| have_profiling         | YES   |\n| profiling              | ON    |\n| profiling_history_size | 15    |\n+------------------------+-------+\n3 rows in set (0.00 sec)\n\n```\n\n![](https://img.springlearn.cn/blog/learn_1596455359000.png)\n\n\n### 2. 查询每条耗时\n\nprofiles会记录每个sql的耗时\n\n```\nmysql> show profiles;\n+----------+------------+-----------------------------------+\n| Query_ID | Duration   | Query                             |\n+----------+------------+-----------------------------------+\n|        1 | 0.00164000 | show variables like '%profiling%' |\n|        2 | 0.04513900 | select count(1) from emp          |\n|        3 | 0.00056200 | select count(1) from dept         |\n+----------+------------+-----------------------------------+\n3 rows in set, 1 warning (0.00 sec)\n```\n\n但是这样不能精确匹配到耗时在哪里。此时可以使用profile精确来分析sql\n\n\n### 3. 精确查询耗时\n\n**精确**\n根据上面的Query_ID来精确查找\n`show profile all for query 2;`\n\n```\n+--------------------------------+----------+----------+------------+-------------------+---------------------+--------------+---------------+---------------+-------------------+-------------------+-------------------+-------+-------------------------+----------------------+-------------+\n| Status                         | Duration | CPU_user | CPU_system | Context_voluntary | Context_involuntary | Block_ops_in | Block_ops_out | Messages_sent | Messages_received | Page_faults_major | Page_faults_minor | Swaps | Source_function         | Source_file          | Source_line |\n+--------------------------------+----------+----------+------------+-------------------+---------------------+--------------+---------------+---------------+-------------------+-------------------+-------------------+-------+-------------------------+----------------------+-------------+\n| starting                       | 0.000106 | 0.000094 |   0.000012 |                 0 |                   0 |            0 |             0 |             0 |                 0 |                 0 |                 0 |     0 | NULL                    | NULL                 |        NULL |\n| Executing hook on transaction  | 0.000008 | 0.000004 |   0.000004 |                 0 |                   0 |            0 |             0 |             0 |                 0 |                 0 |                 0 |     0 | launch_hook_trans_begin | rpl_handler.cc       |        1106 |\n| starting                       | 0.000013 | 0.000010 |   0.000002 |                 0 |                   0 |            0 |             0 |             0 |                 0 |                 0 |                 0 |     0 | launch_hook_trans_begin | rpl_handler.cc       |        1108 |\n| checking permissions           | 0.000009 | 0.000007 |   0.000003 |                 0 |                   0 |            0 |             0 |             0 |                 0 |                 0 |                 0 |     0 | check_access            | sql_authorization.cc |        2202 |\n| Opening tables                 | 0.000047 | 0.000045 |   0.000002 |                 0 |                   0 |            0 |             0 |             0 |                 0 |                 0 |                 0 |     0 | open_tables             | sql_base.cc          |        5587 |\n| init                           | 0.000012 | 0.000008 |   0.000003 |                 0 |                   0 |            0 |             0 |             0 |                 0 |                 0 |                 0 |     0 | execute                 | sql_select.cc        |         661 |\n| System lock                    | 0.000014 | 0.000012 |   0.000003 |                 0 |                   0 |            0 |             0 |             0 |                 0 |                 0 |                 0 |     0 | mysql_lock_tables       | lock.cc              |         332 |\n| optimizing                     | 0.000010 | 0.000007 |   0.000002 |                 0 |                   0 |            0 |             0 |             0 |                 0 |                 0 |                 0 |     0 | optimize                | sql_optimizer.cc     |         213 |\n| statistics                     | 0.000037 | 0.000023 |   0.000014 |                 0 |                   0 |            0 |             0 |             0 |                 0 |                 0 |                 1 |     0 | optimize                | sql_optimizer.cc     |         423 |\n| preparing                      | 0.000025 | 0.000023 |   0.000003 |                 0 |                   0 |            0 |             0 |             0 |                 0 |                 0 |                 0 |     0 | optimize                | sql_optimizer.cc     |         497 |\n| executing                      | 0.000007 | 0.000004 |   0.000003 |                 0 |                   0 |            0 |             0 |             0 |                 0 |                 0 |                 0 |     0 | exec                    | sql_executor.cc      |         228 |\n| Sending data                   | 0.044768 | 0.072019 |   0.003191 |                 0 |                 810 |            0 |             0 |             0 |                 0 |                 0 |                 9 |     0 | exec                    | sql_executor.cc      |         304 |\n| end                            | 0.000018 | 0.000009 |   0.000010 |                 0 |                   0 |            0 |             0 |             0 |                 0 |                 0 |                 0 |     0 | execute                 | sql_select.cc        |         714 |\n| query end                      | 0.000006 | 0.000004 |   0.000002 |                 0 |                   0 |            0 |             0 |             0 |                 0 |                 0 |                 0 |     0 | mysql_execute_command   | sql_parse.cc         |        4520 |\n| waiting for handler commit     | 0.000013 | 0.000011 |   0.000001 |                 0 |                   0 |            0 |             0 |             0 |                 0 |                 0 |                 0 |     0 | ha_commit_trans         | handler.cc           |        1533 |\n| closing tables                 | 0.000009 | 0.000008 |   0.000002 |                 0 |                   0 |            0 |             0 |             0 |                 0 |                 0 |                 0 |     0 | mysql_execute_command   | sql_parse.cc         |        4566 |\n| freeing items                  | 0.000026 | 0.000012 |   0.000013 |                 0 |                   0 |            0 |             0 |             1 |                 0 |                 0 |                 0 |     0 | mysql_parse             | sql_parse.cc         |        5237 |\n| cleaning up                    | 0.000011 | 0.000009 |   0.000002 |                 0 |                   0 |            0 |             0 |             0 |                 0 |                 0 |                 0 |     0 | dispatch_command        | sql_parse.cc         |        2147 |\n+--------------------------------+----------+----------+------------+-------------------+---------------------+--------------+---------------+---------------+-------------------+-------------------+-------------------+-------+-------------------------+----------------------+-------------+\n18 rows in set, 1 warning (0.00 sec)\n\n```\n\n我们可以看到信息太多了,我们其实只用关系几列的数据就行了。\n\n```\nmysql> show profile cpu,block io for query 2;\n+--------------------------------+----------+----------+------------+--------------+---------------+\n| Status                         | Duration | CPU_user | CPU_system | Block_ops_in | Block_ops_out |\n+--------------------------------+----------+----------+------------+--------------+---------------+\n| starting                       | 0.000106 | 0.000094 |   0.000012 |            0 |             0 |\n| Executing hook on transaction  | 0.000008 | 0.000004 |   0.000004 |            0 |             0 |\n| starting                       | 0.000013 | 0.000010 |   0.000002 |            0 |             0 |\n| checking permissions           | 0.000009 | 0.000007 |   0.000003 |            0 |             0 |\n| Opening tables                 | 0.000047 | 0.000045 |   0.000002 |            0 |             0 |\n| init                           | 0.000012 | 0.000008 |   0.000003 |            0 |             0 |\n| System lock                    | 0.000014 | 0.000012 |   0.000003 |            0 |             0 |\n| optimizing                     | 0.000010 | 0.000007 |   0.000002 |            0 |             0 |\n| statistics                     | 0.000037 | 0.000023 |   0.000014 |            0 |             0 |\n| preparing                      | 0.000025 | 0.000023 |   0.000003 |            0 |             0 |\n| executing                      | 0.000007 | 0.000004 |   0.000003 |            0 |             0 |\n| Sending data                   | 0.044768 | 0.072019 |   0.003191 |            0 |             0 |\n| end                            | 0.000018 | 0.000009 |   0.000010 |            0 |             0 |\n| query end                      | 0.000006 | 0.000004 |   0.000002 |            0 |             0 |\n| waiting for handler commit     | 0.000013 | 0.000011 |   0.000001 |            0 |             0 |\n| closing tables                 | 0.000009 | 0.000008 |   0.000002 |            0 |             0 |\n| freeing items                  | 0.000026 | 0.000012 |   0.000013 |            0 |             0 |\n| cleaning up                    | 0.000011 | 0.000009 |   0.000002 |            0 |             0 |\n+--------------------------------+----------+----------+------------+--------------+---------------+\n18 rows in set, 1 warning (0.01 sec)\n\nmysql>\n```\n\n\n### 4. 全局查询日志\n\n仅仅在调优和开发中使用,生产要关闭\n\n`show variables like '%general_log%';`\n\n开启全局日志记录并将sql都写入到表中\n```\nset global general_log = 1;\nset global log_output = 'table';\n```\n\n```\nmysql> show variables like '%general_log%';\n+------------------+------------------------------------+\n| Variable_name    | Value                              |\n+------------------+------------------------------------+\n| general_log      | OFF                                |\n| general_log_file | /usr/local/var/mysql/localhost.log |\n+------------------+------------------------------------+\n2 rows in set (0.01 sec)\n\nmysql> set global general_log = 1;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> show variables like '%general_log%';\n+------------------+------------------------------------+\n| Variable_name    | Value                              |\n+------------------+------------------------------------+\n| general_log      | ON                                 |\n| general_log_file | /usr/local/var/mysql/localhost.log |\n+------------------+------------------------------------+\n2 rows in set (0.01 sec)\n```\n\n\n开启之后就可以在mysql库中的general_log表中进行查询\n\n`select * from mysql.general_log;`\n![](https://img.springlearn.cn/blog/learn_1596457337000.png)\n\n\n将sql设置到文件中\n\n```\nset global general_log = 1;\nset global log_output = 'file';\nset global general_log_file='/Users/liuxin/general.log';\n```\n\n![](https://img.springlearn.cn/blog/learn_1596457737000.png)\n\n\n最后求关注,求订阅,谢谢你的阅读!\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/databases/sql/海量数据模拟.md b/docs/learn/databases/sql/海量数据模拟.md
--- a/docs/learn/databases/sql/海量数据模拟.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/databases/sql/海量数据模拟.md	(date 1655373430433)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/tools/bytecode/Javassist.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: Javassist\n---\n\n:::info Javassist\nJavassist是一个开源的分析、编辑和创建Java字节码的类库，可以直接编辑和生成Java生成的字节码。\n相对于bcel, asm等这些工具，开发者不需要了解虚拟机指令，就能动态改变类的结构，或者动态生成类。javassist简单易用， 快速。\n:::\n\n[![](https://img.shields.io/badge/%E5%AD%97%E8%8A%82%E7%A0%81%E7%BC%96%E7%A8%8B-bytecode--example-green)](https://github.com/lxchinesszz/bytecode-example)\n\n## 一、核心工具类\n\n|核心类|解释|\n|:--|:--|\n|ClassPool|javassist的类池，使用ClassPool 类可以跟踪和控制所操作的类，它的工作方式与 JVM 类装载器非常相似|\n|CtClass|CtClass提供了类的操作，如在类中动态添加新字段、方法和构造函数、以及改变类、父类和接口的方法。|\n|CtField|类的属性，通过它可以给类创建新的属性，还可以修改已有的属性的类型，访问修饰符等|\n|CtMethod|类中的方法，通过它可以给类创建新的方法，还可以修改返回类型，访问修饰符等， 甚至还可以修改方法体内容代码|\n|CtConstructor|与CtMethod类似|\n\n## 二、API\n\n### 2.1 ClassPool\n\n```java \n    // 类库, jvm中所加载的class\n \tClassPool pool = ClassPool.getDefault();\n\t// 加载一个已知的类, 注：参数必须为全量类名\n\tCtClass ctClass = pool.get(\"com.itheima.Student\");\n\t// 创建一个新的类, 类名必须为全量类名\n\tCtClass tClass = pool.makeClass(\"com.itheima.Calculator\");\n```\n\n### 2.2 CtField\n\n```java \n\t// 获取已知类的属性\n\tCtField ctField = ctClass.getDeclaredField(\"name\");\n\t// 构建新的类的成员变量\n\tCtField ctFieldNew = new CtField(CtClass.intType,\"age\",ctClass);\n\t// 设置类的访问修饰符为public\n\tctFieldNew.setModifiers(Modifier.PUBLIC);\n\t// 将属性添加到类中\n\tctClass.addField(ctFieldNew);\n```\n\n### 2.3 CtMethod\n\n```java \n\t// 获取已有方法\n\t//创建新的方法, 参数1:方法的返回类型，参数2：名称，参数3：方法的参数，参数4：方法所属的类\n\tCtMethod ctMethod = new CtMethod(CtClass.intType, \"calc\", new CtClass[]\n{CtClass.intType,CtClass.intType}, tClass);\n\t// 设置方法的访问修饰\n\tctMethod.setModifiers(Modifier.PUBLIC);\n\t// 将新建的方法添加到类中\n\tctClass.addMethod(ctMethod);\n\t// 方法体内容代码 $1代表第一个参数，$2代表第二个参数\n\tctMethod.setBody(\"return $1 + $2;\"); \n\n\tCtMethod ctMethod = ctClass.getDeclaredMethod(\"sayHello\");\n```\n\n### 2.4 CtConstructor\n\n```java \n    // 获取已有的构造方法, 参数为构建方法的参数类型数组\n    CtConstructor ctConstructor = ctClass.getDeclaredConstructor(new CtClass[]{});\n    // 创建新的构造方法\n    CtConstructor ctConstructor = new CtConstructor(new CtClass[]{CtClass.intType},ctClass); ctConstructor.setModifiers(Modifier.PUBLIC);\n    ctConstructor.setBody(\"this.age = $1;\");\n    ctClass.addConstructor(ctConstructor);\n    // 也可直接创建\n    ctConstructor = CtNewConstructor.make(\"public Student(int age){this.age=age;}\", ctClass);\n```\n\n## 三、示例\n\n```java \npublic class User {\n\n    private String name;\n\n    public User() {\n    }\n\n    public User(String name) {\n        this.name = name;\n    }\n\n    public String sayJavassist() {\n        return \"Hello Javassist\";\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"name='\" + name + '\\'' +\n                '}';\n    }\n}\n```\n\n### 3.1 修改方法\n\n```java \n        // 类库池, jvm中所加载的class\n        ClassPool pool = ClassPool.getDefault();\n        // 获取指定的Student类\n        CtClass ctClass = pool.get(\"com.example.test.User\");\n        // 获取sayHello方法\n        CtMethod ctMethod = ctClass.getDeclaredMethod(\"sayJavassist\");\n        // 在方法的代码后追加 一段代码\n        ctMethod.insertAfter(\"System.out.println(\\\"I'm Javassist.\\\");\");\n        // 使用当前的ClassLoader加载被修改后的类\n        Class<?> newClass = ctClass.toClass();\n        User user = (User) newClass.newInstance();\n        System.out.println(user.sayJavassist());\n```\n\n### 3.2 动态添加方法\n\n```java \n        // 类库池, jvm中所加载的class\n        ClassPool pool = ClassPool.getDefault();\n        // 获取指定的Student类\n        CtClass ctClass = pool.get(\"com.example.test.User\");\n        // 增加方法\n        CtMethod ctMethod = new CtMethod(CtClass.intType, \"getAgeSum\",\n                new CtClass[]{CtClass.intType, CtClass.intType}, ctClass);\n        // 设置方法的访问修饰\n        ctMethod.setModifiers(Modifier.PUBLIC);\n        // 设置方法体代码\n        ctMethod.setBody(\"return $1 + $2;\");\n        // 添加新建的方法到原有的类中\n        ctClass.addMethod(ctMethod);\n        // 加载修改后的类\n        ctClass.toClass();\n        // 创建对象\n        User stu = new User();\n        // 获取calc方法\n        Method dMethod = User.class.getDeclaredMethod(\"getAgeSum\", new Class[]\n                {int.class, int.class});\n        // 反射调用 方法\n        Object result = dMethod.invoke(stu, 10, 20);\n        System.out.println(result);\n```\n\n### 3.3 动态创建类\n\n```java \n        // 类库池, jvm中所加载的class\n        ClassPool pool = ClassPool.getDefault();\n        // 创建一个学校类\n        CtClass schoolClass = pool.makeClass(\"com.example.test.School\");\n        // 设置为公有类\n        schoolClass.setModifiers(Modifier.PUBLIC);\n        // 获取String类型\n        CtClass stringClass = pool.get(\"java.lang.String\");\n        // 获取list类型\n        CtClass listClass = pool.get(\"java.util.List\");\n        // 获取学生的类型\n        CtClass userClass = pool.get(\"com.example.test.User\");\n        // 给学校添加一个校名属性\n        CtField nameField = new CtField(stringClass, \"schoolName\", schoolClass);\n        nameField.setModifiers(Modifier.PUBLIC);\n        schoolClass.addField(nameField);\n        // 给学校添加一个学生集合\n        CtField studentList = new CtField(listClass, \"users\", schoolClass);\n        studentList.setModifiers(Modifier.PUBLIC);\n        schoolClass.addField(studentList);\n        // 给学校一个空构造\n        CtConstructor ctConstructor = CtNewConstructor.make(\"public School() \" +\n                \"{this.schoolName=\\\"湖畔小学\\\";this.users = new java.util.ArrayList();}\", schoolClass);\n        schoolClass.addConstructor(ctConstructor);\n\n        // 给学校一个addUser的方法\n        CtMethod m = new CtMethod(CtClass.voidType, \"addUser\", new CtClass[]{userClass}, schoolClass);\n        m.setModifiers(Modifier.PUBLIC);\n        // 添加学生对象到students属性中, $1代表参数1\n        m.setBody(\"this.users.add($1);\");\n        schoolClass.addMethod(m);\n\n        // 给学校添加一个介绍的方法\n        CtMethod introduce = new CtMethod(CtClass.voidType, \"introduce\", new CtClass[]{}, schoolClass);\n        introduce.setBody(\"System.out.println(\\\"The School name is \\\" + this.schoolName);\");\n        introduce.insertAfter(\"System.out.println(this.users);\");\n        schoolClass.addMethod(introduce);\n\n        // 加载修改后的学校\n        Class<?> schoolLoadClass = schoolClass.toClass();\n        // 构建一个学校(空构造)\n        Object school = schoolLoadClass.newInstance();\n        // 获取添加用户方法\n        Method addUserMethod = schoolLoadClass.getDeclaredMethod(\"addUser\", userClass.toClass());\n        addUserMethod.invoke(school, new User(\"小明\"));\n        addUserMethod.invoke(school, new User(\"小张\"));\n        // 获取介绍方法，把刚才的信息给打印处理\n        Method introduceMethod = school.getClass().getDeclaredMethod(\"introduce\");\n        introduceMethod.invoke(school);\n```\n\n``` \nThe School name is 湖畔小学\n[User{name='小明'}, User{name='小张'}]\n```\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/tools/bytecode/Javassist.md b/docs/learn/tools/bytecode/Javassist.md
--- a/docs/learn/tools/bytecode/Javassist.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/tools/bytecode/Javassist.md	(date 1655373430291)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/databases/sql/README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: MySQL\n---\n\n![](https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png)\n\n**作者**: 西魏陶渊明\n**博客**: [https://blog.springlearn.cn/](https://blog.springlearn.cn/)\n\n::: tip 西魏陶渊明\n莫笑少年江湖梦，谁不少年梦江湖\n:::\n\n\n## MySQL 事务\n\nMySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你既需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！\n\n- 在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。\n- 事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。\n- 事务用来管理 insert,update,delete 语句\n\n一般来说，事务是必须满足4个条件（ACID）：：原子性（**A**tomicity，或称不可分割性）、一致性（**C**onsistency）、隔离性（**I**solation，又称独立性）、持久性（**D**urability）。\n\n- **原子性** 一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。\n- **一致性**在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。\n- **隔离性**数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。\n- **持久性**事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。\n\n>在 MySQL 命令行的默认设置下，事务都是自动提交的，即执行 SQL 语句后就会马上执行 COMMIT 操作。因此要显式地开启一个事务务须使用命令 BEGIN 或 START TRANSACTION，或者执行命令 SET AUTOCOMMIT=0，用来禁止使用当前会话的自动提交。\n\n### 事务控制语句\n\n- BEGIN 或 START TRANSACTION 显式地开启一个事务；\n- COMMIT 也可以使用 COMMIT WORK，不过二者是等价的。COMMIT 会提交事务，并使已对数据库进行的所有修改成为永久性的；\n- ROLLBACK 也可以使用 ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；\n- SAVEPOINT identifier，SAVEPOINT 允许在事务中创建一个保存点，一个事务中可以有多个 SAVEPOINT；\n- RELEASE SAVEPOINT identifier 删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常；\n- ROLLBACK TO identifier 把事务回滚到标记点；\n- SET TRANSACTION 用来设置事务的隔离级别。InnoDB 存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ 和 SERIALIZABLE。\n\n\n### MYSQL 事务处理主要有两种方法\n\n1、用 BEGIN, ROLLBACK, COMMIT来实现\n\n- **BEGIN** 开始一个事务\n- **ROLLBACK** 事务回滚\n- **COMMIT** 事务确认\n\n2、直接用 SET 来改变 MySQL 的自动提交模式:\n\n- **SET AUTOCOMMIT=0** 禁止自动提交\n- **SET AUTOCOMMIT=1** 开启自动提交\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/databases/sql/README.md b/docs/learn/databases/sql/README.md
--- a/docs/learn/databases/sql/README.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/databases/sql/README.md	(date 1655373430587)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/tools/reflections/README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\nsidebarDepth: 3\ntitle: 反射框架Reflections\n---\n\n[Github](https://github.com/ronmamo/reflections)\n\n\n## 一、简介\n\nReflections通过扫描classpath，索引元数据，并且允许在运行时查询这些元数据。\n\n使用Reflections可以很轻松的获取以下元数据信息：\n\n- [x] 获取某个类型的全部子类\n- [x] 只要类型、构造器、方法，字段上带有特定注解，便能获取带有这个注解的全部信息（类型、构造器、方法，字段）\n- [x] 获取所有能匹配某个正则表达式的资源\n- [x] 获取所有带有特定签名的方法，包括参数，参数注解，返回类型\n- [x]  获取所有方法的名字\n- [x] 获取代码里所有字段、方法名、构造器的使用权\n\n\n## 二、Maven依赖\n\n```xml \n<dependency>\n    <groupId>org.reflections</groupId>\n    <artifactId>reflections</artifactId>\n    <version>0.9.11</version>\n</dependency>\n```\n\n## 三、使用方法\n\n### 3.1 实例化\n\n指定要扫描的包名\n\n```java \n// 实例化Reflections，并指定要扫描的包名\nReflections reflections = new Reflections(\"my.project\");\n// 获取某个类的所有子类\nSet<Class<? extends SomeType>> subTypes = reflections.getSubTypesOf(SomeType.class);\n// 获取包含某个注解的所有类\nSet<Class<?>> annotated = reflections.getTypesAnnotatedWith(SomeAnnotation.class);\n  \n```\n\n指定要扫描的包名并添加过滤器\n\n[ConfigurationBuilder API](https://ronmamo.github.io/reflections/org/reflections/util/ConfigurationBuilder.html)\n```java \nReflections reflections = new Reflections(\n  new ConfigurationBuilder()\n    .forPackage(\"com.my.project\")\n    .filterInputsBy(new FilterBuilder().includePackage(\"com.my.project\")));\n```\n\n添加扫描器\n\n[Scanners API](https://ronmamo.github.io/reflections/org/reflections/scanners/Scanners.html)\n```java \n// scan package with specific scanners\nReflections reflections = new Reflections(\n  new ConfigurationBuilder()\n    .forPackage(\"com.my.project\")\n    .filterInputsBy(new FilterBuilder().includePackage(\"com.my.project\").excludePackage(\"com.my.project.exclude\"))\n    .setScanners(TypesAnnotated, MethodsAnnotated, MethodsReturn));\n\n// scan package with all standard scanners\nReflections reflections = new Reflections(\"com.my.project\", Scanners.values());\n```\n\n### 3.2 扫描子类\n\n```java \nSet<Class<? extends Module>> modules = \n    reflections.getSubTypesOf(com.google.inject.Module.class);\n```\n\n### 3.3 扫描注解\n\n```java \n//TypeAnnotationsScanner \nSet<Class<?>> singletons = \n    reflections.getTypesAnnotatedWith(javax.inject.Singleton.class);\n```\n\n### 3.4 扫描资源\n\n```java \n//ResourcesScanner\nSet<String> properties = \n    reflections.getResources(Pattern.compile(\".*\\\\.properties\"));\n```\n\n### 3.5 扫描方法、构造注解\n\n```java \n//MethodAnnotationsScanner\nSet<Method> resources =\n    reflections.getMethodsAnnotatedWith(javax.ws.rs.Path.class);\nSet<Constructor> injectables = \n    reflections.getConstructorsAnnotatedWith(javax.inject.Inject.class);\n```\n\n### 3.6 扫描字段注解\n\n```java \nSet<Field> ids = \n    reflections.getFieldsAnnotatedWith(javax.persistence.Id.class);\n```\n\n### 3.7 扫描方法参数\n\n```java \n//MethodParameterScanner\nSet<Method> someMethods =\n    reflections.getMethodsMatchParams(long.class, int.class);\nSet<Method> voidMethods =\n    reflections.getMethodsReturn(void.class);\nSet<Method> pathParamMethods =\n    reflections.getMethodsWithAnyParamAnnotated(PathParam.class);\n```\n\n### 3.8 扫描方法参数名\n\n```java \nList<String> parameterNames = \n    reflections.getMethodParamNames(Method.class)\n```\n\n### 3.9 扫描方法调用情况\n\n```java \n//MemberUsageScanner\nSet<Member> usages = \n    reflections.getMethodUsages(Method.class)\n```\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/tools/reflections/README.md b/docs/learn/tools/reflections/README.md
--- a/docs/learn/tools/reflections/README.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/tools/reflections/README.md	(date 1655373430416)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/databases/sql/垃圾SQL.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: 如何找到垃圾SQL语句,你知道这些方式吗？\n---\n\n![](https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png)\n\n**作者**: 西魏陶渊明\n**博客**: [https://blog.springlearn.cn/](https://blog.springlearn.cn/)\n\n::: tip 西魏陶渊明\n莫笑少年江湖梦，谁不少年梦江湖\n:::\n\n> 这篇文章主要是讲如何找到需要优化的SQL语句，即找到查询速度非常慢的SQL语句。\n\n\n# 一、慢查询日志\n\n## 1. 何为慢查询日志\n\n- 慢查询日志是MySQL提供的一种日志记录，它用来记录查询响应时间超过阀值的SQL语句\n- 这个时间阀值通过参数 `long_query_time` 设置，如果SQL语句查询时间大于这个值，则会被记录到慢查询日志中，这个值默认是10秒\n- MySQL默认不开启慢查询日志，在需要调优的时候可以手动开启，但是多少会对数据库性能有点影响\n\n## 2. 如何开启慢查询日志\n\n\n查看是否开启了慢查询日志\n\n`SHOW VARIABLES LIKE '%slow_query_log%'`\n\n\n用命令方式开启慢查询日志，但是重启MySQL后此设置会失效\n\n`set global slow_query_log = 1`\n\n永久生效开启方式可以在my.cnf里进行配置，在`mysqld`下新增以下两个参数，重启MySQL即可生效\n\n```\nslow_query_log=1\nslow_query_log_file=日志文件存储路径\n```\n\n\n## 3. 慢查询时间阀值\n\n查看慢查询时间阀值\n\n`SHOW VARIABLES LIKE 'long_query_time%';`\n\n\n修改慢查询时间阀值\n\n`set global long_query_time=3;`\n\n修改后的时间阀值生效\n\n`需要重新连接或者新开一个回话才能看到修改值。`\n\n\n在MySQL配置文件中修改时间阀值\n\n```\n[mysqld]下配置\nslow_query_log=1\nslow_query_log_file=日志文件存储路径\nlong_query_time=3\nlog_output=FILE\n```\n\n# 二、慢查询日志分析工具\n\n慢查询日志可能会数据量非常大，那么我们如何快速找到需要优化的SQL语句呢，这个神奇诞生了，它就是mysqldumpshow。\n\n## 1. mysqldumpslow --help语法\n\n![](https://img.springlearn.cn/blog/learn_1596350361000.png)\n\n通过mysqldumpslow --help可知这个命令是由三部分组成：mysqldumpslow `[日志查找选项] [日志文件存储位置]`。\n\n## 2. 日志查找选项\n\n- s：是表示按何种方式排序\n\n| 选项 | 说明                                                |\n| ---- | --------------------------------------------------- |\n| c    | 访问次数                                            |\n| i    | 锁定时间                                                    |\n| r    | 返回记录                                                    |\n| t    | 查询时间                                                    |\n| al   | 平均锁定时间                                                    |\n| ar   | 平均返回记录数                                                    |\n| at   | 平均查询时间                                                    |\n\n- t：即为返回前面多少条的数据\n- g：后边搭配一个正则匹配模式，大小写不敏感的\n\n## 3. 常用分析语法\n\n查找返回记录做多的10条SQL\n\n`mysqldumpslow -s r -t 10 日志路径`\n\n查找使用频率最高的10条SQL\n\n`mysqldumpslow -s c -t 10 日志路径`\n\n查找按照时间排序的前10条里包含左连接的SQL\n\n`mysqldumpslow -s t -t 10 -g \"left join\" 日志路径`\n\n\n通过more查看日志，防止爆屏\n\n`mysqldumpslow -s r -t 10 日志路径 | more`\n\n\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/databases/sql/垃圾SQL.md b/docs/learn/databases/sql/垃圾SQL.md
--- a/docs/learn/databases/sql/垃圾SQL.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/databases/sql/垃圾SQL.md	(date 1655373430352)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
Index: docs/learn/databases/nosql/redis/README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: Redis\n---\n\n![](https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png)\n\n**作者**: 西魏陶渊明\n**博客**: [https://blog.springlearn.cn/](https://blog.springlearn.cn/)\n\n::: tip 西魏陶渊明\n莫笑少年江湖梦，谁不少年梦江湖\n:::
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/databases/nosql/redis/README.md b/docs/learn/databases/nosql/redis/README.md
--- a/docs/learn/databases/nosql/redis/README.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/databases/nosql/redis/README.md	(date 1655373430070)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
@@ -21,4 +21,4 @@
 
 ::: tip 西魏陶渊明
 莫笑少年江湖梦，谁不少年梦江湖
-:::
\ No newline at end of file
+:::
Index: docs/learn/databases/nosql/redis/Redis缓存穿透雪崩问题.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\nbreadcrumb: false\nnavbar: true\nsidebar: true\npageInfo: false\ncontributor: true\neditLink: true\nupdateTime: true\nprev: true\nnext: true\ncomment: false\nfooter: true\nbacktotop: true\ntitle: Redis缓存穿透雪崩问题\n---\n\n![](https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png)\n\n**作者**: 西魏陶渊明\n**博客**: [https://blog.springlearn.cn/](https://blog.springlearn.cn/)\n\n::: tip 西魏陶渊明\n莫笑少年江湖梦，谁不少年梦江湖\n:::\n\n\n## 一、缓存穿透\n\n**数据层没有,导致查询一直都是穿透了缓存去查db。**\n\n缓存穿透的概念很简单，用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中，于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。\n\n\n\n### 解决方案\n\n#### （1）布隆过滤器\n\n布隆过滤器是一种数据结构，垃圾网站和正常网站加起来全世界据统计也有几十亿个。网警要过滤这些垃圾网站，总不能到数据库里面一个一个去比较吧，这就可以使用布隆过滤器。假设我们存储一亿个垃圾网站地址。将者一亿个都放到布隆过滤器中。\n\n原理: 将User中的指定的字段进行hash计算到某一个位置上,比如在本案例中name和age是两个字段分别映射到了。1和4。\n\n![](https://img.springlearn.cn/blog/learn_1596446105000.png)\n\n当用xiaoming去查询发现，1和4都已经被标记成1了,说明就有这个值了。\n而用xiaozhang去查询,发现小张对应的位置上都还是0说明就不存在这个值。\n\n但是这也存在一个问题,假如说xiaozhang也被hash映射到了1和4,不存在xiaozhang但是布隆判断缺存在。\n\n\n```\npublic class BloomFilterTest {\n\n    private static class User {\n\n        private String name;\n\n        private int age;\n\n        public User(String name, int age) {\n            this.name = name;\n            this.age = age;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public int getAge() {\n            return age;\n        }\n\n        public void setName(String name) {\n            this.name = name;\n        }\n\n        public void setAge(int age) {\n            this.age = age;\n        }\n    }\n\n    public static void main(String[] args) {\n        BloomFilter<User> bloomFilter = BloomFilter.create((Funnel<User>) (user, primitiveSink) -> primitiveSink.putString(user.getName(), Charset.defaultCharset())\n                .putInt(user.getAge()), 10, 0.01);\n        User xiaoming = new User(\"xiaoming\", 1);\n        bloomFilter.put(xiaoming);\n\n        System.out.println(bloomFilter.mightContain(xiaoming));\n        System.out.println(bloomFilter.mightContain(new User(\"xiaozhang\", 2)));\n    }\n}\n```\n\n#### （2） 设置空对象\n\n当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源；\n\n当数据层也没有发现就放一个空对象,空对象设置一个过期时间\n\n## 二、缓存击穿\n\n这种数据正常情况。就是给了一个说法名字而已\n\n**缓存中本来存在,但是某一个顺序缓存过期失效了,就被击穿访问到db层。**\n\n缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。\n\n\n\n## 三、缓存雪崩\n\n\n缓存雪崩是指，缓存层出现了错误，不能正常工作了。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。\n\n### 解决方案\n\n#### （1）redis高可用\n\n这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群。\n\n#### （2）限流降级\n\n这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。\n\n#### （3）数据预热\n\n数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。\n\n\n最后求关注,求订阅,谢谢你的阅读!\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/docs/learn/databases/nosql/redis/Redis缓存穿透雪崩问题.md b/docs/learn/databases/nosql/redis/Redis缓存穿透雪崩问题.md
--- a/docs/learn/databases/nosql/redis/Redis缓存穿透雪崩问题.md	(revision 1954418c7a0c7fab3203a61785f399ad8441bc8a)
+++ b/docs/learn/databases/nosql/redis/Redis缓存穿透雪崩问题.md	(date 1655373430234)
@@ -2,7 +2,7 @@
 breadcrumb: false
 navbar: true
 sidebar: true
-pageInfo: false
+pageInfo: true
 contributor: true
 editLink: true
 updateTime: true
