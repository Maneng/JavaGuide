(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{583:function(s,a,n){"use strict";n.r(a);var t=n(1),e=Object(t.a)({},(function(){var s=this,a=s.$createElement,n=s._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("p",[n("img",{attrs:{src:"https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png",alt:"",loading:"lazy"}})]),s._v(" "),n("p",[n("strong",[s._v("作者")]),s._v(": 西魏陶渊明\n"),n("strong",[s._v("博客")]),s._v(": "),n("a",{attrs:{href:"https://blog.springlearn.cn/",target:"_blank",rel:"noopener noreferrer"}},[s._v("https://blog.springlearn.cn/"),n("OutboundLink")],1)]),s._v(" "),n("div",{staticClass:"custom-block tip"},[n("p",{staticClass:"custom-block-title"},[s._v("西魏陶渊明")]),s._v(" "),n("p",[s._v("莫笑少年江湖梦，谁不少年梦江湖")])]),s._v(" "),n("h2",{attrs:{id:"一、缓存穿透"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#一、缓存穿透"}},[s._v("#")]),s._v(" 一、缓存穿透")]),s._v(" "),n("p",[n("strong",[s._v("数据层没有,导致查询一直都是穿透了缓存去查db。")])]),s._v(" "),n("p",[s._v("缓存穿透的概念很简单，用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中，于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。")]),s._v(" "),n("h3",{attrs:{id:"解决方案"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#解决方案"}},[s._v("#")]),s._v(" 解决方案")]),s._v(" "),n("h4",{attrs:{id:"_1-布隆过滤器"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-布隆过滤器"}},[s._v("#")]),s._v(" （1）布隆过滤器")]),s._v(" "),n("p",[s._v("布隆过滤器是一种数据结构，垃圾网站和正常网站加起来全世界据统计也有几十亿个。网警要过滤这些垃圾网站，总不能到数据库里面一个一个去比较吧，这就可以使用布隆过滤器。假设我们存储一亿个垃圾网站地址。将者一亿个都放到布隆过滤器中。")]),s._v(" "),n("p",[s._v("原理: 将User中的指定的字段进行hash计算到某一个位置上,比如在本案例中name和age是两个字段分别映射到了。1和4。")]),s._v(" "),n("p",[n("img",{attrs:{src:"https://img.springlearn.cn/blog/learn_1596446105000.png",alt:"",loading:"lazy"}})]),s._v(" "),n("p",[s._v("当用xiaoming去查询发现，1和4都已经被标记成1了,说明就有这个值了。\n而用xiaozhang去查询,发现小张对应的位置上都还是0说明就不存在这个值。")]),s._v(" "),n("p",[s._v("但是这也存在一个问题,假如说xiaozhang也被hash映射到了1和4,不存在xiaozhang但是布隆判断缺存在。")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('public class BloomFilterTest {\n\n    private static class User {\n\n        private String name;\n\n        private int age;\n\n        public User(String name, int age) {\n            this.name = name;\n            this.age = age;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public int getAge() {\n            return age;\n        }\n\n        public void setName(String name) {\n            this.name = name;\n        }\n\n        public void setAge(int age) {\n            this.age = age;\n        }\n    }\n\n    public static void main(String[] args) {\n        BloomFilter<User> bloomFilter = BloomFilter.create((Funnel<User>) (user, primitiveSink) -> primitiveSink.putString(user.getName(), Charset.defaultCharset())\n                .putInt(user.getAge()), 10, 0.01);\n        User xiaoming = new User("xiaoming", 1);\n        bloomFilter.put(xiaoming);\n\n        System.out.println(bloomFilter.mightContain(xiaoming));\n        System.out.println(bloomFilter.mightContain(new User("xiaozhang", 2)));\n    }\n}\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br"),n("span",{staticClass:"line-number"},[s._v("31")]),n("br"),n("span",{staticClass:"line-number"},[s._v("32")]),n("br"),n("span",{staticClass:"line-number"},[s._v("33")]),n("br"),n("span",{staticClass:"line-number"},[s._v("34")]),n("br"),n("span",{staticClass:"line-number"},[s._v("35")]),n("br"),n("span",{staticClass:"line-number"},[s._v("36")]),n("br"),n("span",{staticClass:"line-number"},[s._v("37")]),n("br"),n("span",{staticClass:"line-number"},[s._v("38")]),n("br"),n("span",{staticClass:"line-number"},[s._v("39")]),n("br"),n("span",{staticClass:"line-number"},[s._v("40")]),n("br")])]),n("h4",{attrs:{id:"_2-设置空对象"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-设置空对象"}},[s._v("#")]),s._v(" （2） 设置空对象")]),s._v(" "),n("p",[s._v("当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源；")]),s._v(" "),n("p",[s._v("当数据层也没有发现就放一个空对象,空对象设置一个过期时间")]),s._v(" "),n("h2",{attrs:{id:"二、缓存击穿"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二、缓存击穿"}},[s._v("#")]),s._v(" 二、缓存击穿")]),s._v(" "),n("p",[s._v("这种数据正常情况。就是给了一个说法名字而已")]),s._v(" "),n("p",[n("strong",[s._v("缓存中本来存在,但是某一个顺序缓存过期失效了,就被击穿访问到db层。")])]),s._v(" "),n("p",[s._v("缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。")]),s._v(" "),n("h2",{attrs:{id:"三、缓存雪崩"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#三、缓存雪崩"}},[s._v("#")]),s._v(" 三、缓存雪崩")]),s._v(" "),n("p",[s._v("缓存雪崩是指，缓存层出现了错误，不能正常工作了。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。")]),s._v(" "),n("h3",{attrs:{id:"解决方案-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#解决方案-2"}},[s._v("#")]),s._v(" 解决方案")]),s._v(" "),n("h4",{attrs:{id:"_1-redis高可用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-redis高可用"}},[s._v("#")]),s._v(" （1）redis高可用")]),s._v(" "),n("p",[s._v("这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群。")]),s._v(" "),n("h4",{attrs:{id:"_2-限流降级"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-限流降级"}},[s._v("#")]),s._v(" （2）限流降级")]),s._v(" "),n("p",[s._v("这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。")]),s._v(" "),n("h4",{attrs:{id:"_3-数据预热"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-数据预热"}},[s._v("#")]),s._v(" （3）数据预热")]),s._v(" "),n("p",[s._v("数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。")]),s._v(" "),n("p",[s._v("最后求关注,求订阅,谢谢你的阅读!")])])}),[],!1,null,null,null);a.default=e.exports}}]);