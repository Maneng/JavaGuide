{
  "version": "https://jsonfeed.org/version/1.1",
  "title": "西魏陶渊明",
  "home_page_url": "https://vuepress-theme-hope-demo.mrhope.site/",
  "feed_url": "https://vuepress-theme-hope-demo.mrhope.site/feed.json",
  "description": "桃花潭水深千尺",
  "author": {
    "name": "西魏陶渊明"
  },
  "items": [
    {
      "title": "博客主页",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/blog-readme/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/blog-readme/",
      "content_html": "<p>这是一个博客主页。</p>\n<p>要使用此布局，您应该在页面前端设置 <code>blog: true</code> 和 <code>home: true</code>。</p>\n<p>相关配置文档请见 <a href=\"https://vuepress-theme-hope.github.io/zh/guide/blog/home/\" target=\"_blank\" rel=\"noopener noreferrer\">博客主页</a></p>\n",
      "date_published": "2021-12-21T05:46:37.000Z",
      "date_modified": "2021-12-21T05:46:37.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Hexo",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/blog/hexo/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/blog/hexo/",
      "content_html": "<h2 id=\"一、hexo\"> 一、Hexo</h2>\n<p><code>Hexo</code> 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。\n<a href=\"https://hexo.io/zh-cn/\" target=\"_blank\" rel=\"noopener noreferrer\">hexo</a></p>\n<h2 id=\"二、安装\"> 二、安装</h2>\n<h3 id=\"_2-1-安装前提\"> 2.1 安装前提</h3>\n<p>安装 Hexo 相当简单，只需要先安装下列应用程序即可：</p>\n<ul>\n<li>Node.js (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)</li>\n<li>Git</li>\n<li>npm</li>\n</ul>\n<h3 id=\"_2-2-安装\"> 2.2 安装</h3>\n<p>首先利用 <code>npm</code> 下载</p>\n<div><pre><code><span>npm</span> <span>install</span> -g hexo-cli<span>;</span>\n\nmdkir myblog<span>;</span>\n\n<span>cd</span> myblog<span>;</span>\n\nhexo init<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id=\"三、使用\"> 三、使用</h2>\n<p><code>hexo</code> 的命令非常简单，小编用了很多年，基本上只有2个。你知道是哪两个吗?</p>\n<h3 id=\"_3-1-new-新建文章\"> 3.1 new 新建文章</h3>\n<p><code>$ hexo new [layout] &lt;title&gt;</code></p>\n<ul>\n<li>layout 是博客布局，基本不会用</li>\n<li>title 就是博客的名字</li>\n</ul>\n<h3 id=\"_3-2-generate-文章编译\"> 3.2 generate 文章编译</h3>\n<p>生成静态文件。</p>\n<p><code>$ hexo generate</code></p>\n<p>该命令可以简写为：</p>\n<p><code>$ hexo g</code></p>\n<h3 id=\"_3-3-server-本地运行\"> 3.3 server 本地运行</h3>\n<p>启动服务器,本地运行</p>\n<p><code>$ hexo server</code></p>\n<h3 id=\"_3-4-deploy-远程部署\"> 3.4 deploy 远程部署</h3>\n<p>部署远程</p>\n<p><code>$ hexo deploy</code></p>\n<p>该命令可以简写为：</p>\n<p><code>$ hexo d</code></p>\n<h3 id=\"_3-5-clean-清理缓存\"> 3.5 clean 清理缓存</h3>\n<p><code>$ hexo clean</code></p>\n<p>清除缓存文件 (db.json) 和已生成的静态文件 (public)。</p>\n<p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p>\n<h3 id=\"_3-6-version\"> 3.6 version</h3>\n<p><code>$ hexo version</code></p>\n<p>显示 Hexo 版本。</p>\n<h2 id=\"四、部署\"> 四、部署</h2>\n<p><code>hexo</code> 的配置文件都在根目录下的 <code>_config.yml</code> 文件下。如果要部署远程，非常简单。</p>\n<div><pre><code><span>deploy</span><span>:</span>\n    <span>type</span><span>:</span> git\n    <span>repo</span><span>:</span>\n<span>#      可以使用github    </span>\n<span>#      github: https://github.com/lxchinesszz/lxchinesszz.github.io.git</span>\n      <span>coding</span><span>:</span> https<span>:</span>//e.coding.net/lxchinesszz/lxchinesszz.git\n    <span>branch</span><span>:</span> master\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><ul>\n<li>\n<ol>\n<li>这里需要注意，如果使用github部署, 仓库的名字是有讲究的。名字要跟github的账户名前缀一直。\n<code>lxchinesszz.github.io</code></li>\n</ol>\n</li>\n<li>\n<ol start=\"2\">\n<li>打开设置要配置一下域名，如果不配置域名默认就是 <code>https://lxchinesszz.github.io/</code></li>\n</ol>\n</li>\n</ul>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1640502249000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_4-1-本地部署\"> 4.1 本地部署</h3>\n<p><code>hexo s</code></p>\n<h3 id=\"_4-2-远程部署\"> 4.2 远程部署</h3>\n<p><code>hexo g -d</code></p>\n<p>或者是</p>\n<p><code>hexo g</code>  + <code>hexo d</code></p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1640502249000.png",
      "date_published": "2022-01-04T14:58:20.000Z",
      "date_modified": "2022-01-04T14:58:20.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "MySQL",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/databases/sql/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/databases/sql/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n<h2 id=\"mysql-事务\"> MySQL 事务</h2>\n<p>MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你既需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！</p>\n<ul>\n<li>在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。</li>\n<li>事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。</li>\n<li>事务用来管理 insert,update,delete 语句</li>\n</ul>\n<p>一般来说，事务是必须满足4个条件（ACID）：：原子性（<strong>A</strong>tomicity，或称不可分割性）、一致性（<strong>C</strong>onsistency）、隔离性（<strong>I</strong>solation，又称独立性）、持久性（<strong>D</strong>urability）。</p>\n<ul>\n<li><strong>原子性</strong> 一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</li>\n<li><strong>一致性</strong>在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</li>\n<li><strong>隔离性</strong>数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li>\n<li><strong>持久性</strong>事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>\n</ul>\n<blockquote>\n<p>在 MySQL 命令行的默认设置下，事务都是自动提交的，即执行 SQL 语句后就会马上执行 COMMIT 操作。因此要显式地开启一个事务务须使用命令 BEGIN 或 START TRANSACTION，或者执行命令 SET AUTOCOMMIT=0，用来禁止使用当前会话的自动提交。</p>\n</blockquote>\n<h3 id=\"事务控制语句\"> 事务控制语句</h3>\n<ul>\n<li>BEGIN 或 START TRANSACTION 显式地开启一个事务；</li>\n<li>COMMIT 也可以使用 COMMIT WORK，不过二者是等价的。COMMIT 会提交事务，并使已对数据库进行的所有修改成为永久性的；</li>\n<li>ROLLBACK 也可以使用 ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；</li>\n<li>SAVEPOINT identifier，SAVEPOINT 允许在事务中创建一个保存点，一个事务中可以有多个 SAVEPOINT；</li>\n<li>RELEASE SAVEPOINT identifier 删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常；</li>\n<li>ROLLBACK TO identifier 把事务回滚到标记点；</li>\n<li>SET TRANSACTION 用来设置事务的隔离级别。InnoDB 存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ 和 SERIALIZABLE。</li>\n</ul>\n<h3 id=\"mysql-事务处理主要有两种方法\"> MYSQL 事务处理主要有两种方法</h3>\n<p>1、用 BEGIN, ROLLBACK, COMMIT来实现</p>\n<ul>\n<li><strong>BEGIN</strong> 开始一个事务</li>\n<li><strong>ROLLBACK</strong> 事务回滚</li>\n<li><strong>COMMIT</strong> 事务确认</li>\n</ul>\n<p>2、直接用 SET 来改变 MySQL 的自动提交模式:</p>\n<ul>\n<li><strong>SET AUTOCOMMIT=0</strong> 禁止自动提交</li>\n<li><strong>SET AUTOCOMMIT=1</strong> 开启自动提交</li>\n</ul>\n",
      "image": "https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png",
      "date_published": "2022-01-04T14:58:20.000Z",
      "date_modified": "2022-01-04T14:58:20.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Mysql优化示例",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/databases/sql/SQL%E4%BC%98%E5%8C%96%E7%A4%BA%E4%BE%8B/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/databases/sql/SQL%E4%BC%98%E5%8C%96%E7%A4%BA%E4%BE%8B/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n<h2 id=\"创建表\"> 创建表</h2>\n<div><pre><code><span>use</span> test<span>;</span>\n<span>create</span> <span>table</span> test03\n<span>(</span>\n a1 <span>int</span><span>(</span><span>4</span><span>)</span> <span>not</span> <span>null</span><span>,</span>\n a2 <span>int</span><span>(</span><span>4</span><span>)</span> <span>not</span> <span>null</span><span>,</span>\n a3 <span>int</span><span>(</span><span>4</span><span>)</span> <span>not</span> <span>null</span><span>,</span>\n a4 <span>int</span><span>(</span><span>4</span><span>)</span> <span>not</span> <span>null</span>\n<span>)</span><span>;</span>\n<span>alter</span> <span>table</span> test03 <span>add</span> <span>index</span> idx_a1_a2_a3_a4<span>(</span>a1<span>,</span>a2<span>,</span>a3<span>,</span>a4<span>)</span><span>;</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><hr>\n<h2 id=\"建议一、按照复合索引顺序查询\"> 建议一、按照复合索引顺序查询</h2>\n<p><strong>需知</strong></p>\n<ol>\n<li>如果(a,b,c,d)复合索引和查询使用的顺序全部一致,则复合索引全部使用,如果不部分一致或者跨列使用则就是部分使用.</li>\n<li>where和order by拼起来也不要跨列,参考反例2和3</li>\n</ol>\n<h3 id=\"_1-建议\"> 1. 建议</h3>\n<ul>\n<li>建议: 按照where后面按照顺序使用复合索引</li>\n<li>建议: where 和 order by不要跨列\n<code>explain select a1,a2,a3,a4 from test03 where a1=1 and a2=2 and a3=3 and a4=4;</code></li>\n</ul>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596388059000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_2-反例1\"> 2. 反例1</h3>\n<p><code>explain select a1,a2,a3,a4 from test03 where a4=1 and a3=2 and a2=3 and a1=4;</code></p>\n<p>可以看到还是一样的,索引都用了，原因是sql在执行时候被sql优化器进行了调整,最后被调整成了上面的顺序写法。\n这是最理想的情况,但是实际中建议开发按照顺序来进行查询。\n<img src=\"https://img.springlearn.cn/blog/learn_1596388250000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_3-反例2\"> 3. 反例2</h3>\n<p><code>explain select a1,a2,a3,a4 from test03 where a1=1 and a2=2 and a4=4 order by a3;</code></p>\n<ul>\n<li>因为查询条件中复合索引跨列了(跨了a3)，所以导致只能用a1 和a2索引。索引key_len变成8了</li>\n<li>索引中没有查询a3但是却用a3排序了,导致要回表查询a3\n<img src=\"https://img.springlearn.cn/blog/learn_1596388567000.png\" alt=\"\" loading=\"lazy\"></li>\n</ul>\n<h3 id=\"_4-反例3\"> 4. 反例3</h3>\n<p><code>explain select a1,a2,a3,a4 from test03 where a1=1 and a4=4 order by a3;</code></p>\n<ul>\n<li>跨了a2 a3 所以a4失效只能用a1 所以key_len只有一个\nwhere 和 order by拼接起来是否也满足复合顺序,如果不满足\n就会出现Using filesort</li>\n<li>反例2中where 生效的是a1和a2，但是order by是a3。满足复合索引顺序,所以不会出现Using filesort</li>\n</ul>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596389005000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><code>explain select a1,a2,a3,a4 from test03 where a1=1 and a4=4 order by a2,a3;</code></p>\n<ul>\n<li>where a1 order by a2 a3 所以不会出现上面Using fileSort\n<img src=\"https://img.springlearn.cn/blog/learn_1596389167000.png\" alt=\"\" loading=\"lazy\"></li>\n</ul>\n<h2 id=\"建议二、单表优化\"> 建议二、单表优化</h2>\n<h3 id=\"建表及需求sql\"> 建表及需求sql</h3>\n<div><pre><code>\ncreate table book\n(\n bid int(4) primary key,\n name varchar(20) not null,\n authorid int(4) not null,\n publicid int(4) not null,\n typeid int(4) not null\n);\n\ninsert into book values(1,&#39;tjava&#39;,1,1,2);\ninsert into book values(2,&#39;tjava&#39;,2,1,2);\ninsert into book values(3,&#39;tjava&#39;,3,2,1);\ninsert into book values(4,&#39;tjava&#39;,4,2,3);\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p><strong>查询authorid = 1 并且 typeid 等于2或者3 然后根据typeid 排序</strong></p>\n<p><code>explain select bid from book where typeid in (2,3) and authorid = 1 order by typeid desc;</code></p>\n<div><pre><code>mysql&gt; explain select bid from book where  typeid in (2,3) and authorid = 1  order by typeid desc;\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------------------+\n| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                       |\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------------------+\n|  1 | SIMPLE      | book  | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    4 |    25.00 | Using where; Using filesort |\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------------------+\n1 row in set, 1 warning (0.00 sec)\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>可以看出来未用到索引,type是all。就是全表查询了。</p>\n<h3 id=\"_1-优化1加索引\"> 1. 优化1加索引</h3>\n<p><code>alter table book add index idx_bta(bid,typeid,authorid);</code></p>\n<div><pre><code>mysql&gt; explain select bid from book where  typeid in (2,3) and authorid = 1  order by typeid desc;\n+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+------------------------------------------+\n| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra                                    |\n+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+------------------------------------------+\n|  1 | SIMPLE      | book  | NULL       | index | NULL          | idx_bta | 12      | NULL |    4 |    25.00 | Using where; Using index; Using filesort |\n+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+------------------------------------------+\n1 row in set, 1 warning (0.00 sec)\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>可以看到通过了加索引type由之前的all变成了index,说明有一点进步。但是我们看到还有一个<code>Using filesort</code>.前面我们说了出现这个\n是因为额外多了一次查询。根据sql的解析规则，第一个解析的是typeid,第二个是authorid。那么我们先对索引顺序做一个优化。</p>\n<h3 id=\"_2-优化索引顺序\"> 2. 优化索引顺序</h3>\n<p>复合索引一旦进行了升级优化，就要删除了，否则会进行干扰。<code>drop index idx_bta on book;</code></p>\n<p>按照sql执行顺序来创建索引。这里我们其实也可以不创建bid，但是如果不创建bid,就要回表去查询bid,所以也建议加上。\n<code>alter table book add index idx_tab(typeid,authorid,bid);</code></p>\n<div><pre><code>mysql&gt; explain select bid,typeid from book where  typeid in (2,3) and authorid = 1  order by typeid desc;\n+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-----------------------------------------------+\n| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra                                         |\n+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-----------------------------------------------+\n|  1 | SIMPLE      | book  | NULL       | range | idx_tab       | idx_tab | 8       | NULL |    2 |   100.00 | Using where; Backward index scan; Using index |\n+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-----------------------------------------------+\n1 row in set, 1 warning (0.00 sec)\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>可以看到已经没有了,Using filesort。</p>\n<h3 id=\"_3-总结\"> 3. 总结</h3>\n<ul>\n<li>索引优化不会一步到位,要多次优化。</li>\n<li>索引顺序会影响查询效率,如果不知道怎么优化,建议sql执行顺序,多尝试几次不同顺序。通过看type的级别来调整。</li>\n<li>type如果是range或者ref。其实就可以了。如果是index或者all就要考虑是否要进行优化。</li>\n<li>in会是索引失效</li>\n</ul>\n<h2 id=\"建议三、多表优化\"> 建议三、多表优化</h2>\n<h3 id=\"建表及需求sql-2\"> 建表及需求sql</h3>\n<div><pre><code>create table teacher2\n(\n    tid int(4) primary key,\n    cid int(4) not null\n);\n\ninsert into teacher2 values(1,2);\ninsert into teacher2 values(2,1);\ninsert into teacher2 values(3,3);\n\ncreate table course2\n(\n    cid int(4),\n    cname varchar(20)\n);\ninsert into course2 values(1,&#39;java&#39;);\ninsert into course2 values(2,&#39;python&#39;);\ninsert into course2 values(3,&#39;kotlin&#39;);\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p><strong>需求sql</strong></p>\n<p><code>select * from teacher2 t left outer join course2 c on t.cid=c.cid where c.cname = 'java';</code></p>\n<div><pre><code>mysql&gt; select * from teacher2 t left outer join course2 c on t.cid=c.cid where c.cname = &#39;java&#39;;\n+-----+-----+------+-------+\n| tid | cid | cid  | cname |\n+-----+-----+------+-------+\n|   2 |   1 |    1 | java  |\n+-----+-----+------+-------+\n1 row in set (0.00 sec)\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>执行计划分析</p>\n<div><pre><code>mysql&gt; explain select * from teacher2 t left outer join course2 c on t.cid=c.cid where c.cname = &#39;java&#39;;\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+\n| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                              |\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+\n|  1 | SIMPLE      | c     | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |    33.33 | Using where                                        |\n|  1 | SIMPLE      | t     | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |    33.33 | Using where; Using join buffer (Block Nested Loop) |\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+\n2 rows in set, 1 warning (0.00 sec)\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>可以看到有一个<code>Using join buffer</code>。 说明Sql写的太差了，mysql给你加了一个缓存。经过下面的索引优化会去掉。</p>\n<h3 id=\"优化1小表驱动大表\"> 优化1小表驱动大表</h3>\n<p>当编写语句时候,将数据量小的表放左边(假设此时t表小,on t.cid = c.cid);反之如果c表小(on c.cid = t.tic)</p>\n<h3 id=\"优化2加索引\"> 优化2加索引</h3>\n<p>索引建立在经常使用的字段上,本例中t.cid使用频繁。</p>\n<p><code>alter table teacher2 add index idx_teacher2_cid(cid);</code></p>\n<div><pre><code>mysql&gt; explain select * from teacher2 t left outer join course2 c on t.cid=c.cid where c.cname = &#39;java&#39;;\n+----+-------------+-------+------------+------+------------------+------------------+---------+------------+------+----------+-------------+\n| id | select_type | table | partitions | type | possible_keys    | key              | key_len | ref        | rows | filtered | Extra       |\n+----+-------------+-------+------------+------+------------------+------------------+---------+------------+------+----------+-------------+\n|  1 | SIMPLE      | c     | NULL       | ALL  | NULL             | NULL             | NULL    | NULL       |    3 |    33.33 | Using where |\n|  1 | SIMPLE      | t     | NULL       | ref  | idx_teacher2_cid | idx_teacher2_cid | 4       | test.c.cid |    1 |   100.00 | Using index |\n+----+-------------+-------+------------+------+------------------+------------------+---------+------------+------+----------+-------------+\n2 rows in set, 1 warning (0.00 sec)\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>给name也加索引</p>\n<p><code>alter table course2 add index idx_course2_name(cname);</code></p>\n<div><pre><code>mysql&gt; explain select * from teacher2 t left outer join course2 c on t.cid=c.cid where c.cname = &#39;java&#39;;\n+----+-------------+-------+------------+------+------------------+------------------+---------+------------+------+----------+-------------+\n| id | select_type | table | partitions | type | possible_keys    | key              | key_len | ref        | rows | filtered | Extra       |\n+----+-------------+-------+------------+------+------------------+------------------+---------+------------+------+----------+-------------+\n|  1 | SIMPLE      | c     | NULL       | ref  | idx_course2_name | idx_course2_name | 83      | const      |    1 |   100.00 | Using where |\n|  1 | SIMPLE      | t     | NULL       | ref  | idx_teacher2_cid | idx_teacher2_cid | 4       | test.c.cid |    1 |   100.00 | Using index |\n+----+-------------+-------+------------+------+------------------+------------------+---------+------------+------+----------+-------------+\n2 rows in set, 1 warning (0.00 sec)\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>这样两个查询就都用到了索引。</p>\n<h2 id=\"建议四、sql优化\"> 建议四、sql优化</h2>\n<h3 id=\"_1-exist和in\"> 1. exist和in</h3>\n<p>如果主查询的数据集大用 <code>in</code> ,如果子查询数据量大使用 <code>exist</code></p>\n<h3 id=\"_2-order-by优化\"> 2. order by优化</h3>\n<p>Using filesort 有两种算法: 双路排序、单路排序(根据IO的次数,即访问磁盘的顺序)</p>\n<ul>\n<li>MySQL4.1前默认使用双路排序,即扫描两次磁盘(1. 从磁盘读取排序字段,2. 扫描其他字段)</li>\n<li>MySQL4.1后默认使用单路排序,即访问一次磁盘(1. 只读取一次字段,然后在buffer中进行排序)</li>\n</ul>\n<p>但是单路排序有隐患就是不一定是只访问一次磁盘,因为加入数据量特别大,则无法将所有字段的\n数据都放到buffer中,要多次分片读取。此时可以考虑调大buffer容量大小。</p>\n<p><code>set max_length_for_sort_data = 1024</code> (单位/字节)</p>\n<p>如果缓存区大小太小,mysql会自动从单路调整到双路。</p>\n<p><strong>建议</strong></p>\n<ul>\n<li>避免使用<code>select *</code></li>\n<li>复合索引不要跨列使用,如果where和order尽量也按照顺序使用</li>\n<li>order by 如果是多个字段,建议都是升序或者都是降序</li>\n</ul>\n<h3 id=\"_3-慢查询日志\"> 3. 慢查询日志</h3>\n<p><a href=\"https://blog.springlearn.cn/posts/3935/\" target=\"_blank\" rel=\"noopener noreferrer\">如何找到垃圾SQL语句,你知道这些方式吗？</a></p>\n<p>慢sql就是mysql提供的一种日志记录,用于记录响应的时间超过阀值得语句;</p>\n<p><strong>查询是否开启慢查询</strong></p>\n<p><code>show variables like '%slow_query_log%';</code></p>\n<div><pre><code>mysql&gt; show variables like &#39;%slow_query_log%&#39;;\n+---------------------+-----------------------------------------+\n| Variable_name       | Value                                   |\n+---------------------+-----------------------------------------+\n| slow_query_log      | OFF                                     |\n| slow_query_log_file | /usr/local/var/mysql/localhost-slow.log |\n+---------------------+-----------------------------------------+\n2 rows in set (0.06 sec)\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><strong>临时开启:</strong></p>\n<div><pre><code>set global slow_query_log = 1;\nexit;\nservices mysql restart\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>查询慢查询日志阀值</strong></p>\n<p><code>show variables like '%long_query_time%';</code></p>\n<div><pre><code>mysql&gt; show variables like &#39;%long_query_time%&#39;;\n+-----------------+-----------+\n| Variable_name   | Value     |\n+-----------------+-----------+\n| long_query_time | 10.000000 |\n+-----------------+-----------+\n1 row in set (0.00 sec)\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><strong>临时设置阀值</strong></p>\n<p>修改完成之后要重新登录生效</p>\n<div><pre><code>set global long_query_time = 5;\n</code></pre>\n<div><span>1</span><br></div></div><div><pre><code>mysql&gt; show variables like &#39;%long_query_time%&#39;;\n+-----------------+-----------+\n| Variable_name   | Value     |\n+-----------------+-----------+\n| long_query_time | 10.000000 |\n+-----------------+-----------+\n1 row in set (0.00 sec)\n\nmysql&gt; set global long_query_time = 5;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; show variables like &#39;%long_query_time%&#39;;\n+-----------------+-----------+\n| Variable_name   | Value     |\n+-----------------+-----------+\n| long_query_time | 10.000000 |\n+-----------------+-----------+\n1 row in set (0.00 sec)\n\nmysql&gt; exit\nBye\n liuxin@localhost  ~  mysql -u root -p\nEnter password:\nWelcome to the MySQL monitor.  Commands end with ; or \\g.\nYour MySQL connection id is 9\nServer version: 8.0.16 Homebrew\n\nCopyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.\n\nOracle is a registered trademark of Oracle Corporation and/or its\naffiliates. Other names may be trademarks of their respective\nowners.\n\nType &#39;help;&#39; or &#39;\\h&#39; for help. Type &#39;\\c&#39; to clear the current input statement.\n\nmysql&gt; show variables like &#39;%long_query_time%&#39;;\n+-----------------+----------+\n| Variable_name   | Value    |\n+-----------------+----------+\n| long_query_time | 5.000000 |\n+-----------------+----------+\n1 row in set (0.00 sec)\n\nmysql&gt;\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br></div></div><h4 id=\"超过阀值得数量\"> 超过阀值得数量</h4>\n<p><code>show global status like '%slow_queries%';</code></p>\n<div><pre><code>mysql&gt; show global status like &#39;%slow_queries%&#39;;\n+---------------+-------+\n| Variable_name | Value |\n+---------------+-------+\n| Slow_queries  | 0     |\n+---------------+-------+\n1 row in set (0.01 sec)\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id=\"总结\"> 总结</h2>\n<ol>\n<li>复合索引,不要跨列或无序使用</li>\n<li>复合索引,尽量使用全索引匹配</li>\n<li>不要在索引上进行计算、函数、类型转换</li>\n<li>复合索引不能使用 != 、 &lt;&gt; 、 is null</li>\n<li>like尽量以&quot;常量&quot;开头,不要以&quot;%&quot;开头,否则索引失效</li>\n<li>尽量不要使用类型转换（显式、隐式）,否则索引失效。where name = 'lx' 可以。where name\n<img src=\"https://img.springlearn.cn/blog/learn_1596447963000.png\" alt=\"\" loading=\"lazy\"></li>\n<li>尽量不要用or,否则左右索引都可能失效\n<img src=\"https://img.springlearn.cn/blog/learn_1596448080000.png\" alt=\"\" loading=\"lazy\"></li>\n</ol>\n<p>最后求关注,求订阅,谢谢你的阅读!</p>\n",
      "image": "https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png",
      "date_published": "2022-01-04T14:58:20.000Z",
      "date_modified": "2022-01-04T14:58:20.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Redis",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/databases/nosql/redis/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/databases/nosql/redis/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n",
      "image": "https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png",
      "date_published": "2022-01-04T14:58:20.000Z",
      "date_modified": "2022-01-04T14:58:20.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "SQL索引性能优化",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/databases/sql/SQL%E7%B4%A2%E5%BC%95%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/databases/sql/SQL%E7%B4%A2%E5%BC%95%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n<h1 id=\"建表\"> 建表</h1>\n<div><pre><code>// 建表\nCREATE TABLE IF NOT EXISTS staffs(\n    id INT PRIMARY KEY AUTO_INCREMENT,\n    name VARCHAR(24) NOT NULL DEFAULT &quot;&quot; COMMENT&#39;姓名&#39;,\n    age INT NOT NULL DEFAULT 0 COMMENT&#39;年龄&#39;,\n    pos VARCHAR(20) NOT NULL DEFAULT &quot;&quot; COMMENT&#39;职位&#39;,\n    add_time TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT&#39;入职事件&#39;\n) CHARSET utf8 COMMENT&#39;员工记录表&#39;;\n\n// 插入数据\nINSERT INTO `test`.`staffs` (`name`, `age`, `pos`, `add_time`) VALUES (&#39;z3&#39;, 22, &#39;manager&#39;, now());\nINSERT INTO `test`.`staffs` (`name`, `age`, `pos`, `add_time`) VALUES (&#39;July&#39;, 23, &#39;dev&#39;, now());\nINSERT INTO `test`.`staffs` (`name`, `age`, `pos`, `add_time`) VALUES (&#39;2000&#39;, 23, &#39;dev&#39;, now());\n\n// 建立复合索引（即一个索引包含多个字段）\nALTER TABLE staffs ADD INDEX idx_staffs_nameAgePos(name, age, pos);\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><hr>\n<h2 id=\"优化一、全部用到索引\"> 优化一、全部用到索引</h2>\n<h3 id=\"_1-介绍\"> 1. 介绍</h3>\n<p>建立的复合索引包含了几个字段，查询的时候最好能全部用到，而且严格按照索引顺序，这样查询效率是最高的。（最理想情况，具体情况具体分析）</p>\n<h3 id=\"_2-sql案例\"> 2. SQL案例</h3>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596353647000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"优化二、最左前缀法则\"> 优化二、最左前缀法则</h2>\n<h3 id=\"_1-介绍-2\"> 1. 介绍</h3>\n<p>如果建立的是复合索引，索引的顺序要按照建立时的顺序，即从左到右，如：a-&gt;b-&gt;c（和 B+树的数据结构有关）</p>\n<h3 id=\"_2-无效索引举例\"> 2. 无效索引举例</h3>\n<p>如果用了a和c,那么a索引有效,c无效,因为中间跳过了b</p>\n<p>如果用了b和c,那么b索引和c索引都无效,因为跳过了a</p>\n<p>如果只用了c,那么也会无效,因为跳过了a和b</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596354258000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"优化三、不要对索引做以下处理\"> 优化三、不要对索引做以下处理</h2>\n<h3 id=\"_1-以下用法会导致索引失效\"> 1. 以下用法会导致索引失效</h3>\n<ul>\n<li>计算，如：+、-、*、/、!=、&lt;&gt;、is null、is not null、or</li>\n<li>函数，如：sum()、round()等等</li>\n<li>手动/自动类型转换，如：id = &quot;1&quot;，本来是数字，给写成字符串了</li>\n</ul>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596354578000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"优化四、索引不要放在范围查询右边\"> 优化四、索引不要放在范围查询右边</h2>\n<h3 id=\"_1-举例\"> 1. 举例</h3>\n<p>比如复合索引：a-&gt;b-&gt;c，当 where a=&quot;&quot; and b&gt;10 and 3=&quot;&quot;，这时候只能用到 a 和 b，c 用不到索引，因为在范围之后索引都失效（和 B+树结构有关）</p>\n<p>因为b使用了范围,所以右边的索引c就失效了</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596355600000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"优化五、减少-select-的使用\"> 优化五、减少 select * 的使用</h2>\n<h3 id=\"_1-使用覆盖索引\"> 1. 使用覆盖索引</h3>\n<p>即：select 查询字段和 where 中使用的索引字段一致。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596355952000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"优化六、like-模糊搜索\"> 优化六、like 模糊搜索</h2>\n<h3 id=\"_1-失效情况\"> 1. 失效情况</h3>\n<p>like &quot;%张三%&quot;\nlike &quot;%张三&quot;</p>\n<h3 id=\"_2-解决方案\"> 2. 解决方案</h3>\n<ul>\n<li>\n<p>使用复合索引，即 like 字段是 select 的查询字段，如：select name from table where name like &quot;%张三%&quot;\n使用 like &quot;张三%&quot;</p>\n</li>\n<li>\n<p>使用 like &quot;张三%&quot;</p>\n</li>\n</ul>\n<h2 id=\"优化七、order-by-优化\"> 优化七、order by 优化</h2>\n<p>当查询语句中使用 order by 进行排序时，如果没有使用索引进行排序，会出现 filesort 文件内排序，这种情况在数据量大或者并发高的时候，会有性能问题，需要优化。</p>\n<h3 id=\"_1-filesort-出现的情况举例\"> 1. filesort 出现的情况举例</h3>\n<ul>\n<li>order by 字段不是索引字段</li>\n<li>order by 字段是索引字段，但是 select 中没有使用覆盖索引，如：<code>select * from staffs order by age asc;</code></li>\n<li>order by 中同时存在 ASC 升序排序和 DESC 降序排序，如：<code>select a, b from staffs order by a desc, b asc;</code></li>\n<li>order by 多个字段排序时，不是按照索引顺序进行 order by，即不是按照最左前缀法则，如：<code>select a, b from staffs order by b asc, a asc;</code></li>\n</ul>\n<h3 id=\"_2-索引层面解决方法\"> 2. 索引层面解决方法</h3>\n<ul>\n<li>使用主键索引排序</li>\n<li>按照最左前缀法则，并且使用覆盖索引排序，多个字段排序时，保持排序方向一致</li>\n<li>在 SQL 语句中强制指定使用某索引，force index(索引名字)</li>\n<li>不在数据库中排序，在代码层面排序</li>\n</ul>\n<h3 id=\"_3-order-by-排序算法\"> 3. order by 排序算法</h3>\n<p><strong>双路排序</strong></p>\n<p><em>Mysql4.1 之前是使用双路排序，字面的意思就是两次扫描磁盘，最终得到数据，读取行指针和 ORDER BY 列，对他们进行排序，然后扫描已经排好序的列表，按照列表中的值重新从列表中读取对数据输出。也就是从磁盘读取排序字段，在 buffer 进行排序，再从磁盘读取其他字段。</em></p>\n<p>文件的磁盘 IO 非常耗时的，所以在 Mysql4.1 之后，出现了第二种算法，就是单路排序。</p>\n<p><em>从磁盘读取查询需要的所有列，按照 orderby 列在 buffer 对它们进行排序，然后扫描排序后的列表进行输出， 它的效率更快一些，避免了第二次读取数据，并且把随机 IO 变成顺序 IO，但是它会使用更多的空间， 因为它把每一行都保存在内存中了。</em></p>\n<p>当我们无可避免要使用排序时，索引层面没法在优化的时候又该怎么办呢？尽可能让 MySQL 选择使用第二种单路算法来进行排序。这样可以减少大量的随机 IO 操作,很大幅度地提高排序工作的效率。下面看看单路排序优化需要注意的点</p>\n<p><strong>单路排序优化点</strong></p>\n<p>增大 max_length_for_sort_data</p>\n<p><em>在 MySQL 中,决定使用&quot;双路排序&quot;算法还是&quot;单路排序&quot;算法是通过参数 maxlength_for sort_data 来决定的。当所有返回字段的最大长度小于这个参数值时,MySQL 就会选择&quot;单路排序&quot;算法,反之,则选择&quot;多路排序&quot;算法。所以,如果有充足的内存让 MySQL 存放须要返回的非排序字段,就可以加大这个参数的值来让 MySQL 选择使用&quot;单路排序&quot;算法。</em></p>\n<p>去掉不必要的返回字段，避免select *</p>\n<p><em>当内存不是很充裕时,不能简单地通过强行加大上面的参数来强迫 MySQL 去使用&quot;单路排序&quot;算法,否则可能会造成 MySQL 不得不将数据分成很多段,然后进行排序,这样可能会得不偿失。此时就须要去掉不必要的返回字段,让返回结果长度适应 max_length_for_sort_data 参数的限制。</em></p>\n<p>增大 sort_buffer_size 参数设置</p>\n<p><em>这个值如果过小的话,再加上你一次返回的条数过多,那么很可能就会分很多次进行排序,然后最后将每次的排序结果再串联起来,这样就会更慢,增大 sort_buffer_size 并不是为了让 MySQL 选择&quot;单路排序&quot;算法,而是为了让 MySQL 尽量减少在排序过程中对须要排序的数据进行分段,因为分段会造成 MySQL 不得不使用临时表来进行交换排序。</em></p>\n<p>但是sort_buffer_size 不是越大越好：</p>\n<ul>\n<li>Sort_Buffer_Size 是一个 connection 级参数,在每个 connection 第一次需要使用这个 buffer 的时候,一次性分配设置的内存。</li>\n<li>Sort_Buffer_Size 并不是越大越好,由于是 connection 级的参数,过大的设置和高并发可能会耗尽系统内存资源。</li>\n<li>据说 Sort_Buffer_Size 超过 2M 的时候,就会使用 mmap() 而不是 malloc() 来进行内存分配,导致效率降低。</li>\n</ul>\n<h2 id=\"优化八、group-by\"> 优化八、group by</h2>\n<p>其原理也是先排序后分组，其优化方式可参考order by。where高于having,能写在where限定的条件就不要去having限定了。</p>\n",
      "image": "https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png",
      "date_published": "2022-01-04T14:58:20.000Z",
      "date_modified": "2022-01-04T14:58:20.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Redis缓存穿透雪崩问题",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/databases/nosql/redis/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E9%9B%AA%E5%B4%A9%E9%97%AE%E9%A2%98/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/databases/nosql/redis/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E9%9B%AA%E5%B4%A9%E9%97%AE%E9%A2%98/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n<h2 id=\"一、缓存穿透\"> 一、缓存穿透</h2>\n<p><strong>数据层没有,导致查询一直都是穿透了缓存去查db。</strong></p>\n<p>缓存穿透的概念很简单，用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中，于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。</p>\n<h3 id=\"解决方案\"> 解决方案</h3>\n<h4 id=\"_1-布隆过滤器\"> （1）布隆过滤器</h4>\n<p>布隆过滤器是一种数据结构，垃圾网站和正常网站加起来全世界据统计也有几十亿个。网警要过滤这些垃圾网站，总不能到数据库里面一个一个去比较吧，这就可以使用布隆过滤器。假设我们存储一亿个垃圾网站地址。将者一亿个都放到布隆过滤器中。</p>\n<p>原理: 将User中的指定的字段进行hash计算到某一个位置上,比如在本案例中name和age是两个字段分别映射到了。1和4。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596446105000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>当用xiaoming去查询发现，1和4都已经被标记成1了,说明就有这个值了。\n而用xiaozhang去查询,发现小张对应的位置上都还是0说明就不存在这个值。</p>\n<p>但是这也存在一个问题,假如说xiaozhang也被hash映射到了1和4,不存在xiaozhang但是布隆判断缺存在。</p>\n<div><pre><code>public class BloomFilterTest {\n\n    private static class User {\n\n        private String name;\n\n        private int age;\n\n        public User(String name, int age) {\n            this.name = name;\n            this.age = age;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public int getAge() {\n            return age;\n        }\n\n        public void setName(String name) {\n            this.name = name;\n        }\n\n        public void setAge(int age) {\n            this.age = age;\n        }\n    }\n\n    public static void main(String[] args) {\n        BloomFilter&lt;User&gt; bloomFilter = BloomFilter.create((Funnel&lt;User&gt;) (user, primitiveSink) -&gt; primitiveSink.putString(user.getName(), Charset.defaultCharset())\n                .putInt(user.getAge()), 10, 0.01);\n        User xiaoming = new User(&quot;xiaoming&quot;, 1);\n        bloomFilter.put(xiaoming);\n\n        System.out.println(bloomFilter.mightContain(xiaoming));\n        System.out.println(bloomFilter.mightContain(new User(&quot;xiaozhang&quot;, 2)));\n    }\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><h4 id=\"_2-设置空对象\"> （2） 设置空对象</h4>\n<p>当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源；</p>\n<p>当数据层也没有发现就放一个空对象,空对象设置一个过期时间</p>\n<h2 id=\"二、缓存击穿\"> 二、缓存击穿</h2>\n<p>这种数据正常情况。就是给了一个说法名字而已</p>\n<p><strong>缓存中本来存在,但是某一个顺序缓存过期失效了,就被击穿访问到db层。</strong></p>\n<p>缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。</p>\n<h2 id=\"三、缓存雪崩\"> 三、缓存雪崩</h2>\n<p>缓存雪崩是指，缓存层出现了错误，不能正常工作了。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。</p>\n<h3 id=\"解决方案-2\"> 解决方案</h3>\n<h4 id=\"_1-redis高可用\"> （1）redis高可用</h4>\n<p>这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群。</p>\n<h4 id=\"_2-限流降级\"> （2）限流降级</h4>\n<p>这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p>\n<h4 id=\"_3-数据预热\"> （3）数据预热</h4>\n<p>数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p>\n<p>最后求关注,求订阅,谢谢你的阅读!</p>\n",
      "image": "https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png",
      "date_published": "2022-01-04T14:58:20.000Z",
      "date_modified": "2022-01-04T14:58:20.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "explain调优",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/databases/sql/explain/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/databases/sql/explain/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n<blockquote>\n<p>这篇文章主要讲 explain 如何使用，还有 explain 各种参数概念，之后会讲优化</p>\n</blockquote>\n<h1 id=\"一、explain-用法\"> 一、Explain 用法</h1>\n<p>explain模拟Mysql优化器是如何执行SQL查询语句的，从而知道Mysql是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈。</p>\n<p><strong>语法</strong>：<code>Explain + SQL 语句;</code></p>\n<p>如：<code>Explain select * from user;</code> 会生成如下 SQL 分析结果，下面详细对每个字段进行详解</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596351159000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_1-id\"> 1. id</h2>\n<p>是一组数字，代表多个表之间的查询顺序，或者包含子句查询语句中的顺序，id 总共分为三种情况，依次详解</p>\n<h3 id=\"id相同\"> id相同</h3>\n<p>id相同，执行顺序由上至下\n<img src=\"https://img.springlearn.cn/blog/learn_1596351240000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"id不同\"> id不同</h3>\n<p>id 不同，如果是子查询，id 号会递增，id 值越大优先级越高，越先被执行</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596351303000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"id相同和不同\"> id相同和不同</h3>\n<p>id 相同和不同的情况同时存在</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596351331000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_2-select-type\"> 2. select_type</h2>\n<p>select_type 包含以下几种值</p>\n<p><code>simple</code>、<code>primary</code>、<code>subquery</code>、<code>derived</code>、<code>union</code>、<code>union result</code></p>\n<h3 id=\"simple\"> simple</h3>\n<p>简单的 <code>select</code> 查询，查询中不包含子查询或者 <code>union</code> 查询</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596351522000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"primary\"> primary</h3>\n<p>如果 SQL 语句中包含任何子查询，那么子查询的最外层会被标记为 <code>primary</code></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596351575000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"subquery\"> subquery</h3>\n<p>在 <code>select</code> 或者 <code>where</code> 里包含了子查询，那么子查询就会被标记为 <code>subQquery</code>，同三.二同时出现</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596351651000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"derived\"> derived</h3>\n<p>在 <code>from</code> 中包含的一个子查询，会被标记为衍生查询，会把查询结果放到一个临时表中</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596351720000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"union-union-result\"> union / union result</h3>\n<p>如果有两个 <code>select</code> 查询语句，他们之间用 <code>union</code> 连起来查询，那么第二个 <code>select</code> 会被标记为 <code>union</code>，<code>union</code> 的结果被标记为 <code>union result</code>。它的 id 是为 null 的</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596351779000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_3-table\"> 3. table</h2>\n<p>表示这一行的数据是哪张表的数据</p>\n<h2 id=\"_4-type\"> 4. type</h2>\n<p>type 是代表 MySQL 使用了哪种索引类型，不同的索引类型的查询效率也是不一样的，type 大致有以下种类。\n越往上性能越高。</p>\n<table>\n<thead>\n<tr>\n<th>Type类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>system</td>\n<td>表中只有一行记录，system 是 const 的特例，几乎不会出现这种情况，可以忽略不计</td>\n</tr>\n<tr>\n<td>const</td>\n<td>必须是用主键索引或者唯一索引放到 where 条件中查询</td>\n</tr>\n<tr>\n<td>eq_ref</td>\n<td>多表查询中,索引查出来的数据都是唯一的（不能是多个,也不能是0个），常见于唯一索引和主键索引</td>\n</tr>\n<tr>\n<td>ref</td>\n<td>不是主键索引，也不是唯一索引，就是普通的索引，可能会返回多个符合条件的行。</td>\n</tr>\n<tr>\n<td>range</td>\n<td>体现在对某个索引进行区间范围检索，一般出现在 where 条件中的 between、and、&lt;、&gt;、in 等范围查找中。</td>\n</tr>\n<tr>\n<td>index</td>\n<td>将所有的索引树都遍历一遍，查找到符合条件的行。索引文件比数据文件还是要小很多，所以比不用索引全表扫描还是要快很多。</td>\n</tr>\n<tr>\n<td>all</td>\n<td>没用到索引，单纯的将表数据全部都遍历一遍，查找到符合条件的数据</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"_5-possible-keys\"> 5. possible_keys</h2>\n<p>此次查询中涉及字段上若存在索引，则会被列出来，表示可能会用到的索引，但并不是实际上一定会用到的索引</p>\n<h2 id=\"_6-key\"> 6. key</h2>\n<p>此次查询中实际上用到的索引</p>\n<h2 id=\"_7-key-len\"> 7. key_len</h2>\n<p>表示索引中使用的字节数，通过该属性可以知道在查询中使用的索引长度，注意：这个长度是最大可能长度，并非实际使用长度，在不损失精确性的情况下，长度越短查询效率越高</p>\n<h2 id=\"_8-ref\"> 8. ref</h2>\n<p>显示关联的字段。如果使用常数等值查询，则显示 const，如果是连接查询，则会显示关联的字段。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596352252000.png\" alt=\"\" loading=\"lazy\"></p>\n<ul>\n<li>tb_emp 表为非唯一性索引扫描，实际使用的索引列为 idx_name，由于 tb_emp.name='rose'为一个常量，所以 ref=const。</li>\n<li>tb_dept 为唯一索引扫描，从 sql 语句可以看出，实际使用了 PRIMARY 主键索引，ref=db01.tb_emp.deptid 表示关联了 db01 数据库中 tb_emp 表的 deptid 字段。</li>\n</ul>\n<h2 id=\"_9-rows\"> 9. rows</h2>\n<p>根据表信息统计以及索引的使用情况，大致估算说要找到所需记录需要读取的行数，rows 越小越好</p>\n<h2 id=\"_10-extra\"> 10. extra</h2>\n<p>不适合在其他列显示出来，但在优化时十分重要的信息</p>\n<h3 id=\"using-filesort-重点优化\"> using  fileSort（重点优化）</h3>\n<p>俗称 &quot; 文件排序 &quot; ，在数据量大的时候几乎是“九死一生”，在 order by 或者在 group by 排序的过程中，order by 的字段不是索引字段，或者 select 查询字段存在不是索引字段，或者 select 查询字段都是索引字段，但是 order by 字段和 select 索引字段的顺序不一致，都会导致 fileSort</p>\n<p>如果where后面的查询和order by的索引，不是一个值。就会出现fileSort。</p>\n<p>复合索引,夸界,也会出现fileSort。</p>\n<p>优化建议: where 什么就order by 什么。 或者 where和order by 按照复合索引顺序，不要跨列或者无序使用\n<img src=\"https://img.springlearn.cn/blog/learn_1596352476000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"using-temporary-重点优化\"> using temporary（重点优化）</h3>\n<p>使用了临时表保存中间结果，常见于 order by 和 group by 中。</p>\n<p>优化建议: 查询哪些列就用哪些列来order by。 能不用创建临时表就不要创建。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596352573000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"using-index-重点\"> USING index（重点）</h3>\n<p>索引覆盖,就是当前sql查询不用读取原文件,只用读取索引。因为查询的列就是索引列</p>\n<p>表示相应的 select 操作中使用了覆盖索引（Coveing Index）,避免访问了表的数据行，效率不错！如果同时出现 using where，表明索引被用来执行索引键值的查找；如果没有同时出现 using where，表面索引用来读取数据而非执行查找动作。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596352650000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"using-where\"> Using where</h3>\n<p>跟using index相反，要回表去查询。</p>\n<p>表明使用了 where 过滤</p>\n<h3 id=\"using-join-buffer\"> Using join buffer</h3>\n<p>使用了连接缓存</p>\n<h3 id=\"impossible-where\"> impossible where</h3>\n<p>where 子语句的值总是 false，不能用来获取任何数据。出现这个就要检查sql。</p>\n<p>eg: select a from test where a = 1 and a = 2。  a肯定不可能即1又是2</p>\n<h3 id=\"select-tables-optimized-away\"> select tables optimized away</h3>\n<p>在没有 GROUPBY 子句的情况下，基于索引优化 MIN/MAX 操作或者 对于 MyISAM 存储引擎优化 COUNT(*)操作，不必等到执行阶段再进行计算， 查询执行计划生成的阶段即完成优化。</p>\n<h3 id=\"distinct\"> distinct</h3>\n<p>优化 distinct，在找到第一匹配的元组后即停止找同样值的工作</p>\n",
      "image": "https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png",
      "date_published": "2022-01-04T14:58:20.000Z",
      "date_modified": "2022-01-04T14:58:20.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "如何找到垃圾SQL语句,你知道这些方式吗？",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/databases/sql/%E5%9E%83%E5%9C%BESQL/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/databases/sql/%E5%9E%83%E5%9C%BESQL/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n<blockquote>\n<p>这篇文章主要是讲如何找到需要优化的SQL语句，即找到查询速度非常慢的SQL语句。</p>\n</blockquote>\n<h1 id=\"一、慢查询日志\"> 一、慢查询日志</h1>\n<h2 id=\"_1-何为慢查询日志\"> 1. 何为慢查询日志</h2>\n<ul>\n<li>慢查询日志是MySQL提供的一种日志记录，它用来记录查询响应时间超过阀值的SQL语句</li>\n<li>这个时间阀值通过参数 <code>long_query_time</code> 设置，如果SQL语句查询时间大于这个值，则会被记录到慢查询日志中，这个值默认是10秒</li>\n<li>MySQL默认不开启慢查询日志，在需要调优的时候可以手动开启，但是多少会对数据库性能有点影响</li>\n</ul>\n<h2 id=\"_2-如何开启慢查询日志\"> 2. 如何开启慢查询日志</h2>\n<p>查看是否开启了慢查询日志</p>\n<p><code>SHOW VARIABLES LIKE '%slow_query_log%'</code></p>\n<p>用命令方式开启慢查询日志，但是重启MySQL后此设置会失效</p>\n<p><code>set global slow_query_log = 1</code></p>\n<p>永久生效开启方式可以在my.cnf里进行配置，在<code>mysqld</code>下新增以下两个参数，重启MySQL即可生效</p>\n<div><pre><code>slow_query_log=1\nslow_query_log_file=日志文件存储路径\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h2 id=\"_3-慢查询时间阀值\"> 3. 慢查询时间阀值</h2>\n<p>查看慢查询时间阀值</p>\n<p><code>SHOW VARIABLES LIKE 'long_query_time%';</code></p>\n<p>修改慢查询时间阀值</p>\n<p><code>set global long_query_time=3;</code></p>\n<p>修改后的时间阀值生效</p>\n<p><code>需要重新连接或者新开一个回话才能看到修改值。</code></p>\n<p>在MySQL配置文件中修改时间阀值</p>\n<div><pre><code>[mysqld]下配置\nslow_query_log=1\nslow_query_log_file=日志文件存储路径\nlong_query_time=3\nlog_output=FILE\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h1 id=\"二、慢查询日志分析工具\"> 二、慢查询日志分析工具</h1>\n<p>慢查询日志可能会数据量非常大，那么我们如何快速找到需要优化的SQL语句呢，这个神奇诞生了，它就是mysqldumpshow。</p>\n<h2 id=\"_1-mysqldumpslow-help语法\"> 1. mysqldumpslow --help语法</h2>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596350361000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>通过mysqldumpslow --help可知这个命令是由三部分组成：mysqldumpslow <code>[日志查找选项] [日志文件存储位置]</code>。</p>\n<h2 id=\"_2-日志查找选项\"> 2. 日志查找选项</h2>\n<ul>\n<li>s：是表示按何种方式排序</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>c</td>\n<td>访问次数</td>\n</tr>\n<tr>\n<td>i</td>\n<td>锁定时间</td>\n</tr>\n<tr>\n<td>r</td>\n<td>返回记录</td>\n</tr>\n<tr>\n<td>t</td>\n<td>查询时间</td>\n</tr>\n<tr>\n<td>al</td>\n<td>平均锁定时间</td>\n</tr>\n<tr>\n<td>ar</td>\n<td>平均返回记录数</td>\n</tr>\n<tr>\n<td>at</td>\n<td>平均查询时间</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>t：即为返回前面多少条的数据</li>\n<li>g：后边搭配一个正则匹配模式，大小写不敏感的</li>\n</ul>\n<h2 id=\"_3-常用分析语法\"> 3. 常用分析语法</h2>\n<p>查找返回记录做多的10条SQL</p>\n<p><code>mysqldumpslow -s r -t 10 日志路径</code></p>\n<p>查找使用频率最高的10条SQL</p>\n<p><code>mysqldumpslow -s c -t 10 日志路径</code></p>\n<p>查找按照时间排序的前10条里包含左连接的SQL</p>\n<p><code>mysqldumpslow -s t -t 10 -g &quot;left join&quot; 日志路径</code></p>\n<p>通过more查看日志，防止爆屏</p>\n<p><code>mysqldumpslow -s r -t 10 日志路径 | more</code></p>\n",
      "image": "https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png",
      "date_published": "2022-01-04T14:58:20.000Z",
      "date_modified": "2022-01-04T14:58:20.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "SQL锁机制",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/databases/sql/SQL%E9%94%81%E6%9C%BA%E5%88%B6/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/databases/sql/SQL%E9%94%81%E6%9C%BA%E5%88%B6/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n<h2 id=\"一、场景模拟\"> 一、场景模拟</h2>\n<div><pre><code><span>create</span> <span>table</span> shop\n<span>(</span>\n  id <span>int</span><span>(</span><span>4</span><span>)</span> <span>primary</span> <span>key</span> <span>default</span> <span>0</span><span>,</span>\n  name <span>varchar</span><span>(</span><span>20</span><span>)</span> <span>default</span> <span>'衣服'</span><span>,</span>\n  <span>status</span> <span>varchar</span><span>(</span><span>20</span><span>)</span> <span>default</span> <span>'可售'</span>\n<span>)</span><span>engine</span> <span>=</span> <span>innodb</span> <span>default</span> <span>charset</span><span>=</span>utf8<span>;</span>\n\n<span>insert</span> <span>into</span> shop  <span>values</span><span>(</span><span>1</span><span>,</span><span>'衣服'</span><span>,</span><span>'可售'</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><pre><code>mysql&gt; select * from shop;\n+----+--------+--------+\n| id | name   | status |\n+----+--------+--------+\n|  1 | 衣服   | 可售   |\n+----+--------+--------+\n1 row in set (0.00 sec)\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>有一个X姨夫,两个用户并发操作问题</p>\n<p>A先看到衣服: X加锁 -&gt; 试衣服 -&gt; 下单 -&gt; 付款 -&gt; 打包 -&gt; X解锁\nB也相对衣服: 发现X已经被A加锁了,等待X解锁。</p>\n<h2 id=\"二、锁知识\"> 二、锁知识</h2>\n<h3 id=\"锁类型\"> 锁类型</h3>\n<p>a. 读锁(共享锁):\nb. 写锁(互斥锁): 如果当前写操作没有完毕,则无法进行其他的写操作。</p>\n<h3 id=\"锁范围\"> 锁范围</h3>\n<ul>\n<li>innodb默认行锁(开销大,加锁慢,锁范围小,易死锁,不容器锁冲突,并发度高)</li>\n<li>MyISAM默认表锁(开销小,加锁块,无死锁,但是锁范围大容器锁冲突,并发度低)</li>\n</ul>\n<ol>\n<li>表锁(对一张表整体加锁)</li>\n<li>行锁(对一行数据进行加锁)</li>\n</ol>\n<hr>\n<h2 id=\"三、锁分析\"> 三、锁分析</h2>\n<h3 id=\"_1-查看加锁的表\"> 1. 查看加锁的表</h3>\n<p><code>show open tables;</code></p>\n<p>1代表加锁</p>\n<div><pre><code>mysql&gt; show open tables;\n+--------------------+---------------------------+--------+-------------+\n| Database           | Table                     | In_use | Name_locked |\n+--------------------+---------------------------+--------+-------------+\n| test               | emp                       |      0 |           0 |\n| test               | test_innodb_lock          |      0 |           0 |\n| test               | test03                    |      0 |           0 |\n| test               | teacher2                  |      0 |           0 |\n| test               | course2                   |      0 |           0 |\n| test               | book                      |      0 |           0 |\n| test               | shop                      |      1 |           0 |\n| test               | staffs                    |      0 |           0 |\n| test               | dept                      |      0 |           0 |\n+--------------------+---------------------------+--------+-------------+\n73 rows in set (0.00 sec)\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id=\"_2-查看锁的严重程度\"> 2. 查看锁的严重程度</h3>\n<p><code>show status like '%Table_locks%';</code></p>\n<div><pre><code>mysql&gt; show status like &#39;%Table_locks%&#39;;\n+-----------------------+-------+\n| Variable_name         | Value |\n+-----------------------+-------+\n| Table_locks_immediate | 79    |\n| Table_locks_waited    | 0     |\n+-----------------------+-------+\n2 rows in set (0.00 sec)\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><strong>Table_locks_immediate</strong> 能立马加锁\n<strong>Table_locks_waited</strong> 越大说明竞争越大</p>\n<p>建议:\nTable_locks_immediate/Table_locks_waited &gt; 5000,建议采用innodb,否则建议MyISAM。</p>\n<h2 id=\"四、模拟加表锁\"> 四、模拟加表锁</h2>\n<p><code>lock table 表1 read/write,表2 read/write</code></p>\n<div><pre><code>lock table shop write;\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"加表读锁\"> 加表读锁</h3>\n<p>如A会话,对shop表加了read锁,则该会话可以对shop表进行读操作,不能进行写操作。\n并且只能读自己加锁了的表,如下面列子最shop加锁,能读shop不能写shop,不能读test03</p>\n<p><strong>如果对shop表加了read锁,那么只能对shop进行读,其他任何操作都不行了</strong></p>\n<div><pre><code>mysql&gt; lock table shop read;\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql&gt; select * from shop\n    -&gt; ;\n+----+--------+-----------+\n| id | name   | status    |\n+----+--------+-----------+\n|  1 | 衣服   | 已占用    |\n+----+--------+-----------+\n1 row in set (0.00 sec)\n\nmysql&gt; update shop set status = &#39;可售&#39; where id = 1;\nERROR 1099 (HY000): Table &#39;shop&#39; was locked with a READ lock and can&#39;t be updated\nmysql&gt; select * from test03;\nERROR 1100 (HY000): Table &#39;test03&#39; was not locked with LOCK TABLES\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p><img src=\"https://img.springlearn.cn/blog/learn_1596460128000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>其他B会话中,对于shop表能读不能写,但是不影响操作其他表。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596460283000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"加表写锁\"> 加表写锁</h3>\n<ul>\n<li>会话A: lock table shop write;\n当前会话可以对加了锁的表进行任意操作;但是不能操作其他表。</li>\n<li>其他会话B:\n当会话A释放了锁,B才能对这个表进行增删改查;</li>\n</ul>\n<h2 id=\"五、模拟加行锁\"> 五、模拟加行锁</h2>\n<div><pre><code><span>create</span> <span>table</span> linelock\n<span>(</span>\n    id <span>int</span><span>(</span><span>5</span><span>)</span> <span>primary</span> <span>key</span> <span>auto_increment</span><span>,</span>\n    name <span>varchar</span><span>(</span><span>20</span><span>)</span>\n<span>)</span> <span>engine</span> <span>=</span> <span>innodb</span><span>;</span>\n\n<span>insert</span> <span>into</span> linelock<span>(</span>name<span>)</span> <span>values</span><span>(</span><span>'1'</span><span>)</span><span>;</span>\n<span>insert</span> <span>into</span> linelock<span>(</span>name<span>)</span> <span>values</span><span>(</span><span>'2'</span><span>)</span><span>;</span>\n<span>insert</span> <span>into</span> linelock<span>(</span>name<span>)</span> <span>values</span><span>(</span><span>'3'</span><span>)</span><span>;</span>\n<span>insert</span> <span>into</span> linelock<span>(</span>name<span>)</span> <span>values</span><span>(</span><span>'4'</span><span>)</span><span>;</span>\n<span>insert</span> <span>into</span> linelock<span>(</span>name<span>)</span> <span>values</span><span>(</span><span>'5'</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id=\"a窗口写操作\"> A窗口写操作</h3>\n<p><code>insert into linelock(name) values('6');</code></p>\n<p>此时B窗口执行update更新会被锁定。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596463371000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>当A会话commit之后B就能继续操作了。\n<img src=\"https://img.springlearn.cn/blog/learn_1596463461000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>行锁是通过事务进行解锁的。</p>\n<h3 id=\"行锁转表锁\"> 行锁转表锁</h3>\n<p>如果索引列进行了类型转换,则索引失效。</p>\n<p>A窗口执行\n<code>update linelock set name = 'ai' where name = 3;</code></p>\n<p>B窗口执行\n<code>update linelock set name = 'ax' where name = 4;</code></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596464724000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"间隙锁\"> 间隙锁</h3>\n<p>update linelock set name = 'x' where id &gt; 1 and id &lt; 8;</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596465102000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"行锁分析\"> 行锁分析</h3>\n<p><code>show status like '%innodb_row_lock%';</code></p>\n<div><pre><code>mysql&gt; show status like &#39;%innodb_row_lock%&#39;;\n+-------------------------------+--------+\n| Variable_name                 | Value  |\n+-------------------------------+--------+\n| Innodb_row_lock_current_waits | 1      |\n| Innodb_row_lock_time          | 207248 |\n| Innodb_row_lock_time_avg      | 34541  |\n| Innodb_row_lock_time_max      | 51605  |\n| Innodb_row_lock_waits         | 6      |\n+-------------------------------+--------+\n5 rows in set (0.00 sec)\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p><img src=\"https://img.springlearn.cn/blog/learn_1596465415000.png\" alt=\"\" loading=\"lazy\"></p>\n<table>\n<thead>\n<tr>\n<th>Variable_name</th>\n<th>Value</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Innodb_row_lock_current_waits</td>\n<td>当前正在等待的锁的数量</td>\n</tr>\n<tr>\n<td>Innodb_row_lock_time</td>\n<td>等待总时长,从系统启动到现在一共等待时间</td>\n</tr>\n<tr>\n<td>Innodb_row_lock_time_avg</td>\n<td>平均等待时长</td>\n</tr>\n<tr>\n<td>Innodb_row_lock_time_max</td>\n<td>最大等待时长</td>\n</tr>\n<tr>\n<td>Innodb_row_lock_waits</td>\n<td>等待的次数</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"查询语句加锁\"> 查询语句加锁</h3>\n<p><code>set autocommit=0;</code>\n<code>select * from linelock for update;</code></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596466172000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>最后求关注,求订阅,谢谢你的阅读!</p>\n",
      "image": "https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png",
      "date_published": "2022-01-04T14:58:20.000Z",
      "date_modified": "2022-01-04T14:58:20.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Java代码规范全部奉上",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/design/Java%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E5%85%A8%E9%83%A8%E5%A5%89%E4%B8%8A/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/design/Java%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E5%85%A8%E9%83%A8%E5%A5%89%E4%B8%8A/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/learn_1598165820000.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p>写代码就像写文章, 好的代码就像好的文章,结构严谨,构思清晰。写代码就像写文章, 一不留神就成流水账，为避免这种情况作为软件开发工程师，重要的是设计而不是实现。</p>\n</blockquote>\n<p><strong>在一个团队中,由于不同经验的开发导致编程风格可能会出现非常混乱的情况,从而导致开发成本上升。难以维护。所以代码规范就显得异常重要了。</strong></p>\n<p>本篇文章就是给出编程命名的建议,仅供参考,但是其目的是为了统一规范,提高编程能力,降低开发成本,减少代码维护成本。</p>\n<p>契约精神: 做到有法可依，有章可循。</p>\n<h2 id=\"一、类命名\"> 一、类命名</h2>\n<h3 id=\"_1-抽象类\"> 1. 抽象类</h3>\n<p>适用的设计模式为模板模式。抽象是自下往上的设计。由具体实现推断出抽象方法。建议以Abstract开头。</p>\n<table>\n<thead>\n<tr>\n<th>建议</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Abstract 或者 Base 开头</td>\n<td>BaseUserService、AbstractUserService</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_2-枚举类\"> 2. 枚举类</h3>\n<ul>\n<li>枚举是由JVM来保证的单例。可以用来做单例类。</li>\n<li>枚举类常用作值判断,不建议每次进行循环判断得到实例。建议由内部维护一个map类型,当做cache。此方法建议放在static静态代码块中实现</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>建议</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Enum 作为后缀</td>\n<td>GenderEnum</td>\n</tr>\n</tbody>\n</table>\n<div><pre><code>public enum ProtocolEnum {\n\n    /**\n     * ECHO协议\n     */\n    ECHO(1, null),\n\n    /**\n     * mojito协议\n     */\n    MOJITO(2, MojitoProtocol.class);\n\n    private byte type;\n\n    private Class&lt;? extends Protocol&gt; protocol;\n\n    private static Map&lt;Byte, ProtocolEnum&gt; cache = new HashMap&lt;&gt;();\n\n    static {\n        for (ProtocolEnum protocolEnum : values()) {\n            cache.put(protocolEnum.type, protocolEnum);\n        }\n    }\n\n    public static ProtocolEnum byType(byte type) {\n        return cache.get(type);\n    }\n}    \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><h3 id=\"_3-工具类\"> 3. 工具类</h3>\n<p>工具类常为无状态对象,无状态对象都是线程安全对象,建议使用 <code>final</code> 修饰。</p>\n<p>工具类中避免出现业务属性, 如果出现业务属性,抽象出领域层</p>\n<table>\n<thead>\n<tr>\n<th>建议</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Utils作为后缀</td>\n<td>StringUtils</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_4-异常类\"> 4. 异常类</h3>\n<p>建议保持异常链。</p>\n<table>\n<thead>\n<tr>\n<th>建议</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Exception结尾</td>\n<td>RuntimeException</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_5-接口实现类\"> 5. 接口实现类</h3>\n<p>众所周知</p>\n<table>\n<thead>\n<tr>\n<th>建议</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>接口名+ Impl</td>\n<td>UserServiceImpl</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_6-设计模式相关类\"> 6. 设计模式相关类</h3>\n<table>\n<thead>\n<tr>\n<th>建议</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Builder，Factory等</td>\n<td>当使用到设计模式时，需要使用对应的设计模式作为后缀，如ThreadFactory</td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"https://img.springlearn.cn/27c9d5187cd283f8d160ec1ed2b5ac89.jpg\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_7-处理特定功能的\"> 7. 处理特定功能的</h3>\n<p>其主要的目的是代码可重复使用。</p>\n<table>\n<thead>\n<tr>\n<th>建议</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Handler，Predicate, Validator</td>\n<td>表示处理器，校验器，断言，这些类工厂还有配套的方法名如handle，predicate，validate</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_8-测试类\"> 8. 测试类</h3>\n<table>\n<thead>\n<tr>\n<th>建议</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Test结尾</td>\n<td>UserServiceTest， 表示用来测试UserService类的</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_9-领域模型载体\"> 9. 领域模型载体</h3>\n<table>\n<thead>\n<tr>\n<th>建议</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>DTO/*Request</td>\n<td>数据传输对象</td>\n</tr>\n<tr>\n<td>BO</td>\n<td>业务对象</td>\n</tr>\n<tr>\n<td>VO</td>\n<td>数据展示对象,用于承载页面数据</td>\n</tr>\n<tr>\n<td>DO</td>\n<td>数据持久化对象</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"二、方法命名\"> 二、方法命名</h2>\n<p>参考于网络。</p>\n<h3 id=\"_1-布尔判断方法\"> 1. 布尔判断方法</h3>\n<p>注：Prefix-前缀，Suffix-后缀，Alone-单独使用</p>\n<table>\n<thead>\n<tr>\n<th><strong>位置</strong></th>\n<th><strong>单词</strong></th>\n<th><strong>意义</strong></th>\n<th><strong>例</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Prefix</td>\n<td>is</td>\n<td>对象是否符合期待的状态</td>\n<td>isValid</td>\n</tr>\n<tr>\n<td>Prefix</td>\n<td>can</td>\n<td>对象<strong>能否执行</strong>所期待的动作</td>\n<td>canRemove</td>\n</tr>\n<tr>\n<td>Prefix</td>\n<td>should</td>\n<td>调用方执行某个命令或方法是<strong>好还是不好</strong>,<strong>应不应该</strong>，或者说<strong>推荐还是不推荐</strong></td>\n<td>shouldMigrate</td>\n</tr>\n<tr>\n<td>Prefix</td>\n<td>has</td>\n<td>对象<strong>是否持有</strong>所期待的数据和属性</td>\n<td>hasObservers</td>\n</tr>\n<tr>\n<td>Prefix</td>\n<td>needs</td>\n<td>调用方<strong>是否需要</strong>执行某个命令或方法</td>\n<td>needsMigrate</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_2-检查的方法\"> 2. 检查的方法</h3>\n<p>注：Prefix-前缀，Suffix-后缀，Alone-单独使用</p>\n<table>\n<thead>\n<tr>\n<th><strong>单词</strong></th>\n<th><strong>意义</strong></th>\n<th><strong>例</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ensure</td>\n<td>检查是否为期待的状态，不是则抛出异常或返回error code</td>\n<td>ensureCapacity</td>\n</tr>\n<tr>\n<td>validate</td>\n<td>检查是否为正确的状态，不是则抛出异常或返回error code</td>\n<td>validateInputs</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_3-按需求才执行的方法\"> 3. 按需求才执行的方法</h3>\n<p>注：Prefix-前缀，Suffix-后缀，Alone-单独使用</p>\n<table>\n<thead>\n<tr>\n<th><strong>位置</strong></th>\n<th><strong>单词</strong></th>\n<th><strong>意义</strong></th>\n<th><strong>例</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Suffix</td>\n<td>IfNeeded</td>\n<td>需要的时候执行，不需要的时候什么都不做</td>\n<td>drawIfNeeded</td>\n</tr>\n<tr>\n<td>Prefix</td>\n<td>might</td>\n<td>同上</td>\n<td>mightCreate</td>\n</tr>\n<tr>\n<td>Prefix</td>\n<td>try</td>\n<td>尝试执行，失败时抛出异常或是返回errorcode</td>\n<td>tryCreate</td>\n</tr>\n<tr>\n<td>Suffix</td>\n<td>OrDefault</td>\n<td>尝试执行，失败时返回默认值</td>\n<td>getOrDefault</td>\n</tr>\n<tr>\n<td>Suffix</td>\n<td>OrElse</td>\n<td>尝试执行、失败时返回实际参数中指定的值</td>\n<td>getOrElse</td>\n</tr>\n<tr>\n<td>Prefix</td>\n<td>force</td>\n<td>强制尝试执行。error抛出异常或是返回值</td>\n<td>forceCreate, forceStop</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_4-异步相关方法\"> 4. 异步相关方法</h3>\n<p>注：Prefix-前缀，Suffix-后缀，Alone-单独使用</p>\n<table>\n<thead>\n<tr>\n<th><strong>位置</strong></th>\n<th><strong>单词</strong></th>\n<th><strong>意义</strong></th>\n<th><strong>例</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Prefix</td>\n<td>blocking</td>\n<td>线程阻塞方法</td>\n<td>blockingGetUser</td>\n</tr>\n<tr>\n<td>Suffix</td>\n<td>InBackground</td>\n<td>执行在后台的线程</td>\n<td>doInBackground</td>\n</tr>\n<tr>\n<td>Suffix</td>\n<td>Async</td>\n<td>异步方法</td>\n<td>sendAsync</td>\n</tr>\n<tr>\n<td>Suffix</td>\n<td>Sync</td>\n<td>对应已有异步方法的同步方法</td>\n<td>sendSync</td>\n</tr>\n<tr>\n<td>Prefix or Alone</td>\n<td>schedule</td>\n<td>Job和Task放入队列</td>\n<td>schedule, scheduleJob</td>\n</tr>\n<tr>\n<td>Prefix or Alone</td>\n<td>post</td>\n<td>同上</td>\n<td>postJob</td>\n</tr>\n<tr>\n<td>Prefix or Alone</td>\n<td>execute</td>\n<td>执行异步方法（注：我一般拿这个做同步方法名）</td>\n<td>execute, executeTask</td>\n</tr>\n<tr>\n<td>Prefix or Alone</td>\n<td>start</td>\n<td>同上</td>\n<td>start, startJob</td>\n</tr>\n<tr>\n<td>Prefix or Alone</td>\n<td>cancel</td>\n<td>停止异步方法</td>\n<td>cancel, cancelJob</td>\n</tr>\n<tr>\n<td>Prefix or Alone</td>\n<td>stop</td>\n<td>同上</td>\n<td>stop, stopJob</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_5-回调方法\"> 5. 回调方法</h3>\n<p>注：Prefix-前缀，Suffix-后缀，Alone-单独使用</p>\n<table>\n<thead>\n<tr>\n<th><strong>位置</strong></th>\n<th><strong>单词</strong></th>\n<th><strong>意义</strong></th>\n<th><strong>例</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Prefix</td>\n<td>on</td>\n<td>事件发生时执行</td>\n<td>onCompleted</td>\n</tr>\n<tr>\n<td>Prefix</td>\n<td>before</td>\n<td>事件发生前执行</td>\n<td>beforeUpdate</td>\n</tr>\n<tr>\n<td>Prefix</td>\n<td>pre</td>\n<td>同上</td>\n<td>preUpdate</td>\n</tr>\n<tr>\n<td>Prefix</td>\n<td>will</td>\n<td>同上</td>\n<td>willUpdate</td>\n</tr>\n<tr>\n<td>Prefix</td>\n<td>after</td>\n<td>事件发生后执行</td>\n<td>afterUpdate</td>\n</tr>\n<tr>\n<td>Prefix</td>\n<td>post</td>\n<td>同上</td>\n<td>postUpdate</td>\n</tr>\n<tr>\n<td>Prefix</td>\n<td>did</td>\n<td>同上</td>\n<td>didUpdate</td>\n</tr>\n<tr>\n<td>Prefix</td>\n<td>should</td>\n<td>确认事件是否可以发生时执行</td>\n<td>shouldUpdate</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_6-操作对象生命周期的方法\"> 6. 操作对象生命周期的方法</h3>\n<p>注：Prefix-前缀，Suffix-后缀，Alone-单独使用</p>\n<table>\n<thead>\n<tr>\n<th><strong>单词</strong></th>\n<th><strong>意义</strong></th>\n<th><strong>例</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>initialize</td>\n<td>初始化。也可作为延迟初始化使用</td>\n<td>initialize</td>\n</tr>\n<tr>\n<td>pause</td>\n<td>暂停</td>\n<td>onPause ，pause</td>\n</tr>\n<tr>\n<td>stop</td>\n<td>停止</td>\n<td>onStop，stop</td>\n</tr>\n<tr>\n<td>abandon</td>\n<td>销毁的替代</td>\n<td>abandon</td>\n</tr>\n<tr>\n<td>destroy</td>\n<td>同上</td>\n<td>destroy</td>\n</tr>\n<tr>\n<td>dispose</td>\n<td>同上</td>\n<td>dispose</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_7-与集合操作相关的方法\"> 7. 与集合操作相关的方法</h3>\n<p>注：Prefix-前缀，Suffix-后缀，Alone-单独使用</p>\n<table>\n<thead>\n<tr>\n<th><strong>单词</strong></th>\n<th><strong>意义</strong></th>\n<th><strong>例</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>contains</td>\n<td>是否持有与指定对象相同的对象</td>\n<td>contains</td>\n</tr>\n<tr>\n<td>add</td>\n<td>添加</td>\n<td>addJob</td>\n</tr>\n<tr>\n<td>append</td>\n<td>添加</td>\n<td>appendJob</td>\n</tr>\n<tr>\n<td>insert</td>\n<td>插入到下标n</td>\n<td>insertJob</td>\n</tr>\n<tr>\n<td>put</td>\n<td>添加与key对应的元素</td>\n<td>putJob</td>\n</tr>\n<tr>\n<td>remove</td>\n<td>移除元素</td>\n<td>removeJob</td>\n</tr>\n<tr>\n<td>enqueue</td>\n<td>添加到队列的最末位</td>\n<td>enqueueJob</td>\n</tr>\n<tr>\n<td>dequeue</td>\n<td>从队列中头部取出并移除</td>\n<td>dequeueJob</td>\n</tr>\n<tr>\n<td>push</td>\n<td>添加到栈头</td>\n<td>pushJob</td>\n</tr>\n<tr>\n<td>pop</td>\n<td>从栈头取出并移除</td>\n<td>popJob</td>\n</tr>\n<tr>\n<td>peek</td>\n<td>从栈头取出但不移除</td>\n<td>peekJob</td>\n</tr>\n<tr>\n<td>find</td>\n<td>寻找符合条件的某物</td>\n<td>findById</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_8-数据增删改查相关的方法\"> 8. 数据增删改查相关的方法</h3>\n<p>注：Prefix-前缀，Suffix-后缀，Alone-单独使用</p>\n<table>\n<thead>\n<tr>\n<th><strong>单词</strong></th>\n<th><strong>意义</strong></th>\n<th><strong>例</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>create</td>\n<td>新创建</td>\n<td>createAccount</td>\n</tr>\n<tr>\n<td>new</td>\n<td>新创建</td>\n<td>newAccount</td>\n</tr>\n<tr>\n<td>from</td>\n<td>从既有的某物新建，或是从其他的数据新建</td>\n<td>fromConfig</td>\n</tr>\n<tr>\n<td>to</td>\n<td>转换</td>\n<td>toString</td>\n</tr>\n<tr>\n<td>update</td>\n<td>更新既有某物</td>\n<td>updateAccount</td>\n</tr>\n<tr>\n<td>load</td>\n<td>读取</td>\n<td>loadAccount</td>\n</tr>\n<tr>\n<td>fetch</td>\n<td>远程读取</td>\n<td>fetchAccount</td>\n</tr>\n<tr>\n<td>delete</td>\n<td>删除</td>\n<td>deleteAccount</td>\n</tr>\n<tr>\n<td>remove</td>\n<td>删除</td>\n<td>removeAccount</td>\n</tr>\n<tr>\n<td>save</td>\n<td>保存</td>\n<td>saveAccount</td>\n</tr>\n<tr>\n<td>store</td>\n<td>保存</td>\n<td>storeAccount</td>\n</tr>\n<tr>\n<td>commit</td>\n<td>保存</td>\n<td>commitChange</td>\n</tr>\n<tr>\n<td>apply</td>\n<td>保存或应用</td>\n<td>applyChange</td>\n</tr>\n<tr>\n<td>clear</td>\n<td>清除数据或是恢复到初始状态</td>\n<td>clearAll</td>\n</tr>\n<tr>\n<td>reset</td>\n<td>清除数据或是恢复到初始状态</td>\n<td>resetAll</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_9-成对出现的动词\"> 9. 成对出现的动词</h3>\n<p>注：Prefix-前缀，Suffix-后缀，Alone-单独使用</p>\n<table>\n<thead>\n<tr>\n<th><strong>单词</strong></th>\n<th><strong>意义</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>get获取</td>\n<td>set 设置</td>\n</tr>\n<tr>\n<td>add 增加</td>\n<td>remove 删除</td>\n</tr>\n<tr>\n<td>create 创建</td>\n<td>destory 移除</td>\n</tr>\n<tr>\n<td>start 启动</td>\n<td>stop 停止</td>\n</tr>\n<tr>\n<td>open 打开</td>\n<td>close 关闭</td>\n</tr>\n<tr>\n<td>read 读取</td>\n<td>write 写入</td>\n</tr>\n<tr>\n<td>load 载入</td>\n<td>save 保存</td>\n</tr>\n<tr>\n<td>create 创建</td>\n<td>destroy 销毁</td>\n</tr>\n<tr>\n<td>begin 开始</td>\n<td>end 结束</td>\n</tr>\n<tr>\n<td>backup 备份</td>\n<td>restore 恢复</td>\n</tr>\n<tr>\n<td>import 导入</td>\n<td>export 导出</td>\n</tr>\n<tr>\n<td>split 分割</td>\n<td>merge 合并</td>\n</tr>\n<tr>\n<td>inject 注入</td>\n<td>extract 提取</td>\n</tr>\n<tr>\n<td>attach 附着</td>\n<td>detach 脱离</td>\n</tr>\n<tr>\n<td>bind 绑定</td>\n<td>separate 分离</td>\n</tr>\n<tr>\n<td>view 查看</td>\n<td>browse 浏览</td>\n</tr>\n<tr>\n<td>edit 编辑</td>\n<td>modify 修改</td>\n</tr>\n<tr>\n<td>select 选取</td>\n<td>mark 标记</td>\n</tr>\n<tr>\n<td>copy 复制</td>\n<td>paste 粘贴</td>\n</tr>\n<tr>\n<td>undo 撤销</td>\n<td>redo 重做</td>\n</tr>\n<tr>\n<td>insert 插入</td>\n<td>delete 移除</td>\n</tr>\n<tr>\n<td>add 加入</td>\n<td>append 添加</td>\n</tr>\n<tr>\n<td>clean 清理</td>\n<td>clear 清除</td>\n</tr>\n<tr>\n<td>index 索引</td>\n<td>sort 排序</td>\n</tr>\n<tr>\n<td>find 查找</td>\n<td>search 搜索</td>\n</tr>\n<tr>\n<td>increase 增加</td>\n<td>decrease 减少</td>\n</tr>\n<tr>\n<td>play 播放</td>\n<td>pause 暂停</td>\n</tr>\n<tr>\n<td>launch 启动</td>\n<td>run 运行</td>\n</tr>\n<tr>\n<td>compile 编译</td>\n<td>execute 执行</td>\n</tr>\n<tr>\n<td>debug 调试</td>\n<td>trace 跟踪</td>\n</tr>\n<tr>\n<td>observe 观察</td>\n<td>listen 监听</td>\n</tr>\n<tr>\n<td>build 构建</td>\n<td>publish 发布</td>\n</tr>\n<tr>\n<td>input 输入</td>\n<td>output 输出</td>\n</tr>\n<tr>\n<td>encode 编码</td>\n<td>decode 解码</td>\n</tr>\n<tr>\n<td>encrypt 加密</td>\n<td>decrypt 解密</td>\n</tr>\n<tr>\n<td>compress 压缩</td>\n<td>decompress 解压缩</td>\n</tr>\n<tr>\n<td>pack 打包</td>\n<td>unpack 解包</td>\n</tr>\n<tr>\n<td>parse 解析</td>\n<td>emit 生成</td>\n</tr>\n<tr>\n<td>connect 连接</td>\n<td>disconnect 断开</td>\n</tr>\n<tr>\n<td>send 发送</td>\n<td>receive 接收</td>\n</tr>\n<tr>\n<td>download 下载</td>\n<td>upload 上传</td>\n</tr>\n<tr>\n<td>refresh 刷新</td>\n<td>synchronize 同步</td>\n</tr>\n<tr>\n<td>update 更新</td>\n<td>revert 复原</td>\n</tr>\n<tr>\n<td>lock 锁定</td>\n<td>unlock 解锁</td>\n</tr>\n<tr>\n<td>check out 签出</td>\n<td>check in 签入</td>\n</tr>\n<tr>\n<td>submit 提交</td>\n<td>commit 交付</td>\n</tr>\n<tr>\n<td>push 推</td>\n<td>pull 拉</td>\n</tr>\n<tr>\n<td>expand 展开</td>\n<td>collapse 折叠</td>\n</tr>\n<tr>\n<td>begin 起始</td>\n<td>end 结束</td>\n</tr>\n<tr>\n<td>start 开始</td>\n<td>finish 完成</td>\n</tr>\n<tr>\n<td>enter 进入</td>\n<td>exit 退出</td>\n</tr>\n<tr>\n<td>abort 放弃</td>\n<td>quit 离开</td>\n</tr>\n<tr>\n<td>obsolete 废弃</td>\n<td>depreciate 废旧</td>\n</tr>\n<tr>\n<td>collect 收集</td>\n<td>aggregate 聚集</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_10-获取必须的参数\"> 10. 获取必须的参数</h3>\n<table>\n<thead>\n<tr>\n<th>getRequiredProperty</th>\n<th>获取必须的参数,否则报错,该方法一般都要抛出异常</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>getProperty</td>\n<td>非必须参数,可以返回null，不报错，调用方自行判断处理逻辑</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_11-获取数据并对数据进行某种处理\"> 11. 获取数据并对数据进行某种处理</h3>\n<p>注：Prefix-前缀，Suffix-后缀，Alone-单独使用</p>\n<table>\n<thead>\n<tr>\n<th>位置</th>\n<th>单词</th>\n<th>意义</th>\n<th>例子</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Prefix</td>\n<td>resolve</td>\n<td>解决某些问题,比如对文本占位符进行填充,并获取到填充后的值</td>\n<td>resolvePlaceholders</td>\n</tr>\n<tr>\n<td>Suffix</td>\n<td>Placeholders</td>\n<td>占位符相关命名</td>\n<td>resolvePlaceholders</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"三、方法编程建议\"> 三、方法编程建议</h2>\n<h3 id=\"_1-方法复杂度\"> 1. 方法复杂度</h3>\n<p>凡是逻辑判断语句均为复杂度。当一个方法中出现了大于等于10个复杂度。建议根据</p>\n<p>方法实现进行业务抽离。两个建议点(1. 方法单一职责 2. 方法可重复利用 3. 是否能用策略模式或者命令模式)</p>\n<h3 id=\"_2-方法长度及宽度\"> 2.方法长度及宽度</h3>\n<p>长度: 方法的长度建议控制在80-120行以内。满足一屏可以放下。\n宽度: 当方法超过3个及以上入参,建议使用对象封装(对象容易后期扩展,且不会出现眼花缭乱现象)</p>\n<h3 id=\"_3-关注方法优化编辑器提示\"> 3.关注方法优化编辑器提示</h3>\n<p>减少出现黄色警告⚠️, 最好不要出现警告。编辑器的警告都是优化点,需要在编程时候考虑进去。</p>\n<p>eg: 性能优化、命名不规范、重复代码</p>\n<p><img src=\"https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/a/21643544635/2678603850/7fbfc8ab-22ca-4f92-be04-31c4d1b704e3.png\" alt=\"img\" loading=\"lazy\"></p>\n<h3 id=\"_4-方法重复代码\"> 4.方法重复代码</h3>\n<p>贫血模型的标志性问题</p>\n<p>重复代码编辑器会提出警告,此种现象,强烈建议不要出现</p>\n<h3 id=\"_5-方法注释\"> 5. 方法注释</h3>\n<p>注释是必须要做的(先写注释在做实现)，重在设计。</p>\n<p>代码是公司财产, 要对自己对公司对后人负责,先写注释再做实现。</p>\n<h2 id=\"四、项目依赖模型\"> 四、项目依赖模型</h2>\n<h3 id=\"_1-领域设计的认识\"> 1. 领域设计的认识</h3>\n<p>领域划分,用另外一个词形容也非常的合适,就是业务模块化。所有能力都进行能力化抽象,形成模块,形成领域。 当遇到新的业务逻辑,底层的数据结构和数据关系肯定也是一样的。那么就可以像堆积木一样,根据这些模块快速的组装成新的业务逻辑。快速的实现业务的迭代和升级。</p>\n<p>关于这个问题,需要结合自己的业务系统来进行抽象和设计。</p>\n<p>设计核心: 用面向对象的设计思想对业务进行解耦来做到领域划分。</p>\n<h3 id=\"_2-层次划分\"> 2. 层次划分</h3>\n<h4 id=\"基础层-外部调用-db操作\"> 基础层(外部调用,db操作)</h4>\n<p>注意: 基础层只做适配不做业务</p>\n<ul>\n<li>db操作以dao结尾</li>\n<li>外部调用以Client(Http协议)/Instruction(Rpc协议)\n<ul>\n<li>改层仅仅做数据适配,不做业务处理。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"领域层-偏向领域的业务逻辑\"> 领域层(偏向领域的业务逻辑)</h4>\n<p>以Manager</p>\n<h4 id=\"业务层-对领域层的业务编排\"> 业务层(对领域层的业务编排)</h4>\n<p>以Service结尾</p>\n<h4 id=\"外观层-可以提供能力-可以提供视图-。\"> 外观层(可以提供能力,可以提供视图)。</h4>\n<p>以Resource、Facade结尾</p>\n<p>有一个完善的领域层,可以方便快速便捷的对业务进行扩展。与其对立的就是贫血模型。没有领域层只有业务层,业务逻辑都堆积在业务层。典型的面向过程设计。</p>\n<p><img src=\"https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/a/21643544635/2678603850/8be6e99c-f5e9-4a8a-bce4-85f5aa3717e7.png\" alt=\"img\" loading=\"lazy\"></p>\n<h3 id=\"_3-层次依赖模型\"> 3. 层次依赖模型</h3>\n<p>maven多模块应用和单模块应用通用。</p>\n<p>一定要控制项目的依赖情况。</p>\n<p>①service只能出现领域层的依赖, 领域层只能存在dao层和第三方服务层。</p>\n<p>②各个层代码不能平行调用(出现平行调用逻辑,要抽象出领域层来封装)。</p>\n<p><img src=\"https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/a/21643544635/2678603850/c08a058d-8c81-45c4-bdc4-82d666a304f7.png\" alt=\"img\" loading=\"lazy\"></p>\n<p>具体代码体现就是</p>\n<ul>\n<li>以Service命名的类,里面只能存在Manager</li>\n<li>以Manager命名的类,里面只能存在Dao和Client(Http协议)/Instruction(Rpc协议)封装的第三方调用</li>\n<li>以Dao命名的类是对数据库的操作</li>\n<li>以Client(Http协议)/Instruction(Rpc协议)命名的类,作为适配层与第三方API进行交互封装</li>\n</ul>\n<h2 id=\"五、设计模式六大原则\"> 五、设计模式六大原则</h2>\n<p>代码编程时候要向以下这6大原则,进行向其靠拢。</p>\n<h3 id=\"_1-开闭原则\"> 1. 开闭原则</h3>\n<p>一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</p>\n<p><strong>代码设计建议</strong></p>\n<p>用抽象构建框架，用实现扩展细节因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。</p>\n<h3 id=\"_2-单一职责\"> 2. 单一职责</h3>\n<p>不要存在多于一个导致类变更的原因通俗的说，即一个类只负责一项职责。</p>\n<p><strong>代码设计建议</strong></p>\n<p>在具体方法编写或者类编写时候,类编写时候业务要单一,方法编写时候实现要单一</p>\n<p>反例:</p>\n<p>UserService 类中提供了获取商品信息的接口</p>\n<p>setUserName(String name)方法的时候,对name的值进行了二次处理。</p>\n<h3 id=\"_3-里氏替换原则\"> 3. <strong>里氏替换原则</strong></h3>\n<p>所有引用基类的地方必须能透明地使用其子类的对象。</p>\n<p><strong>代码设计建议</strong></p>\n<p>面向接口编程, 子类能透明替换父类。</p>\n<h3 id=\"_4-依赖倒置原则\"> 4. <strong>依赖倒置原则</strong></h3>\n<p>高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。</p>\n<p><strong>代码设计建议</strong></p>\n<p>要根据接口或者抽象去设计,不要依赖于细节,eg.项目中要换数据库,不用重新写底层的数据库代码. 就是使用了hibernate一样,替换方言就好了,因为hibernate是根据接口设计的,不同数据库有不同的实现,可以直接使用. eg2: 我生病了要去买药,如果A药铺,没有我就用B药铺买. 因为他们都是药铺,都有一样的功能,可以友好的替换</p>\n<h3 id=\"_5-接口隔离原则\"> <strong>5. 接口隔离原则</strong></h3>\n<p>客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。</p>\n<p><strong>代码设计建议</strong></p>\n<p>保持最小的责任。</p>\n<p>eg: 接口ConfigurableApplicationContext实现了Lifecycle和Closeable接口。他们其中每个里面定义的接口都很少,为什么不定义到一起呢?</p>\n<p>首先第一责任清晰单一,第二做到接口隔离。</p>\n<p>当某一个方法只用到生命周期的方法,那么方法就可以写成。</p>\n<p>public void stop(Lifecycle lifecycle); 调用时候用-&gt;public void stop(new ConfigurableApplicationContext());</p>\n<p>public void close(Closeable closeable); 调用时候用-&gt;public void close(new ConfigurableApplicationContext());</p>\n<p>stop里面的实现就只能调用Lifecycle里面的方法,而不能调用ConfigurableApplicationContext里面的方法。从而来达到接口隔离原则</p>\n<h3 id=\"_6-迪米特法则\"> 6. <strong>迪米特法则</strong></h3>\n<p>一个对象应该对其他对象保持最少的了解。</p>\n<p><strong>代码设计建议</strong></p>\n<p>减少类与类之间的关系,接口隔离也可以做到。</p>\n<h2 id=\"六、版本迭代\"> 六、版本迭代</h2>\n<p>master分支版本后缀 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.6833em;\"></span><span><span>大版本号</span></span><span>.</span></span></span></span>{0进位}.${迭代版本号}.RELEASE</p>\n<p>test分支版本号 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.6833em;\"></span><span><span>大版本号</span></span><span>.</span></span></span></span>{0进位}.${迭代版本号}.SNAPSHOP</p>\n<p>迭代版本可追踪，避免出现jar包覆盖无法追踪</p>\n<p>迭代版本升级,必须升级迭代版本号。避免出现jar包覆盖无法追踪</p>\n<h3 id=\"_1-大版本定义\"> 1. 大版本定义</h3>\n<p>APP1.0  APP2.0 APP3.0</p>\n<h3 id=\"_2-迭代版本号\"> 2. 迭代版本号</h3>\n<p>APP1.0.1  APP1.0版本的第一个迭代</p>\n<p>APP1.1.0  APP1.0版本的第十个迭代</p>\n<p>APP2.0.2  APP2.0版本的第二个迭代</p>\n<p>APP2.1.0  APP2.0版本的第十个迭代</p>\n<h2 id=\"七、代码格式化\"> 七、代码格式化</h2>\n<p>统一格式化模板,解决多人共同开发场景,代码格式化导致的git提交冲突问题</p>\n<p>最后求关注,求订阅,谢谢你的阅读!</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589360371000.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1598165820000.png",
      "date_published": "2021-12-21T05:46:37.000Z",
      "date_modified": "2021-12-21T05:46:37.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Join大法",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/databases/sql/join/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/databases/sql/join/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/learn_1648086269000.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1648086269000.png",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-03-24T14:34:44.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "中文文档写作规范",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/design/%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3%E5%86%99%E4%BD%9C%E8%A7%84%E8%8C%83/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/design/%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3%E5%86%99%E4%BD%9C%E8%A7%84%E8%8C%83/",
      "content_html": "<div><p>中文技术文档的写作规范。</p>\n<p>本篇文章参考与阮一峰大佬的网络日志, 总结比较细致。非常具有借鉴意义, 欢迎大家进行学习。</p>\n<ul>\n<li>文章参考地址: <a href=\"https://github.com/ruanyf/document-style-guide\" target=\"_blank\" rel=\"noopener noreferrer\">阮一峰的网络日志</a></li>\n</ul>\n</div>\n<h1 id=\"目录\"> 目录</h1>\n<ol>\n<li></li>\n<li></li>\n<li></li>\n<li></li>\n<li></li>\n<li></li>\n<li></li>\n</ol>\n<h2 id=\"一、标题\"> 一、标题</h2>\n<h3 id=\"层级\"> 层级</h3>\n<p>标题分为四级。</p>\n<ul>\n<li>一级标题：文章的标题</li>\n<li>二级标题：文章主要部分的大标题</li>\n<li>三级标题：二级标题下面一级的小标题</li>\n<li>四级标题：三级标题下面某一方面的小标题</li>\n</ul>\n<p>下面是示例。</p>\n<div><pre><code><span><span>#</span> 一级标题</span>\n\n<span><span>##</span> 二级标题</span>\n\n<span><span>###</span> 三级标题</span>\n\n<span><span>####</span> 四级标题</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id=\"原则\"> 原则</h3>\n<p>（1）一级标题下，不能直接出现三级标题。</p>\n<p>示例：下面的文章结构，缺少二级标题。</p>\n<div><pre><code><span><span>#</span> 一级标题</span>\n\n<span><span>###</span> 三级标题</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>（2）标题要避免孤立编号（即同级标题只有一个）。</p>\n<p>示例：下面的文章结构，<code>二级标题 A</code>只包含一个三级标题，完全可以省略<code>三级标题 A</code>。</p>\n<div><pre><code><span><span>##</span> 二级标题 A</span>\n\n<span><span>###</span> 三级标题 A</span>\n\n<span><span>##</span> 二级标题 B</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>（3）下级标题不重复上一级标题的名字。</p>\n<p>示例：下面的文章结构，二级标题与下属的三级标题同名，建议避免。</p>\n<div><pre><code><span><span>##</span> 概述</span>\n\n<span><span>###</span> 概述</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>（4）谨慎使用四级标题，尽量避免出现，保持层级的简单，防止出现过于复杂的章节。</p>\n<p>如果三级标题下有并列性的内容，建议只使用项目列表（Item list）。</p>\n<p>示例：下面的结构二要好于结构一。后者适用的场景，主要是较长篇幅的内容。</p>\n<div><pre><code>结构一\n\n<span><span>###</span> 三级标题</span>\n\n<span><span>####</span> 四级标题 A</span>\n\n<span><span>####</span> 四级标题 B</span>\n\n<span><span>####</span> 四级标题 C</span>\n\n结构二\n\n<span><span>###</span> 三级标题</span>\n\n<span><span>**</span><span>（1）A</span><span>**</span></span>\n\n<span><span>**</span><span>（2）B</span><span>**</span></span>\n\n<span><span>**</span><span>（3）C</span><span>**</span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h2 id=\"二、文本\"> 二、文本</h2>\n<h3 id=\"字间距\"> 字间距</h3>\n<p>（1）全角中文字符与半角英文字符之间，应有一个半角空格。</p>\n<div><pre><code>错误：本文介绍如何快速启动Windows系统。\n\n正确：本文介绍如何快速启动 Windows 系统。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>（2）全角中文字符与半角阿拉伯数字之间，有没有半角空格都可，但必须保证风格统一，不能两种风格混杂。</p>\n<div><pre><code>正确：2011年5月15日，我订购了5台笔记本电脑与10台平板电脑。\n\n正确：2011 年 5 月 15 日，我订购了 5 台笔记本电脑与 10 台平板电脑。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>半角的百分号，视同阿拉伯数字。</p>\n<div><pre><code>正确：今年我国经济增长率是6.5%。\n\n正确：今年我国经济增长率是 6.5%。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>（3）英文单位若不翻译，单位前的阿拉伯数字与单位间不留空格。</p>\n<div><pre><code>错误：一部容量为 16 GB 的智能手机\n\n正确：一部容量为 16GB 的智能手机\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>（4）半角英文字符和半角阿拉伯数字，与全角标点符号之间不留空格。</p>\n<div><pre><code>错误：他的电脑是 MacBook Air 。\n\n正确：他的电脑是 MacBook Air。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"句子\"> 句子</h3>\n<p>（1）避免使用长句。</p>\n<p>不包含任何标点符号的单个句子，或者以逗号分隔的句子构件，长度尽量保持在 20 个字以内；20～29 个字的句子，可以接受；30～39 个字的句子，语义必须明确，才能接受；多于 40 个字的句子，任何情况下都不能接受。</p>\n<div><pre><code>错误：本产品适用于从由一台服务器进行动作控制的单一节点结构到由多台服务器进行动作控制的并行处理程序结构等多种体系结构。\n\n正确：本产品适用于多种体系结构。无论是由一台服务器（单一节点结构），还是由多台服务器（并行处理结构）进行动作控制，均可以使用本产品。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>逗号分割的长句，总长度不应该超过 100 字或者正文的 3 行。</p>\n<p>（2）尽量使用简单句和并列句，避免使用复合句。</p>\n<div><pre><code>并列句：他昨天生病了，没有参加会议。\n\n复合句：那个昨天生病的人没有参加会议。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>（3）同样一个意思，尽量使用肯定句表达，不使用否定句表达。</p>\n<div><pre><code>错误：请确认没有接通装置的电源。\n\n正确：请确认装置的电源已关闭。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>（4）避免使用双重否定句。</p>\n<div><pre><code>错误：没有删除权限的用户，不能删除此文件。\n\n正确：用户必须拥有删除权限，才能删除此文件。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"写作风格\"> 写作风格</h3>\n<p>（1）尽量不使用被动语态，改为使用主动语态。</p>\n<div><pre><code>错误：假如此软件尚未被安装，\n\n正确：假如尚未安装这个软件，\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>（2）不使用非正式的语言风格。</p>\n<div><pre><code>错误：Lady Gaga 的演唱会真是酷毙了，从没看过这么给力的表演！！！\n\n正确：无法参加本次活动，我深感遗憾。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>（3）不使用冷僻、生造或者文言文的词语，而要使用现代汉语的常用表达方式。</p>\n<div><pre><code>错误：这是唯二的快速启动的方法。\n\n正确：这是仅有的两种快速启动的方法。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>（4）用对“的”、“地”、“得”。</p>\n<div><pre><code>她露出了开心的笑容。\n（形容词＋的＋名词）\n\n她开心地笑了。\n（副词＋地＋动词）\n\n她笑得很开心。\n（动词＋得＋副词）\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>（5）使用代词时（比如“其”、“该”、“此”、“这”等词），必须明确指代的内容，保证只有一个含义。</p>\n<div><pre><code>错误：从管理系统可以监视中继系统和受其直接控制的分配系统。\n\n正确：从管理系统可以监视两个系统：中继系统和受中继系统直接控制的分配系统。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>（6）名词前不要使用过多的形容词。</p>\n<div><pre><code>错误：此设备的使用必须在接受过本公司举办的正式的设备培训的技师的指导下进行。\n\n正确：此设备必须在技师的指导下使用，且指导技师必须接受过由本公司举办的正式设备培训。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"英文处理\"> 英文处理</h3>\n<p>（1）英文原文如果使用了复数形式，翻译成中文时，应该将其还原为单数形式。</p>\n<div><pre><code>英文：⋯information stored in random access memory (RAMs)⋯\n\n中文：……存储在随机存取存储器（RAM）里的信息……\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>（2）外文缩写可以使用半角圆点(<code>.</code>)表示缩写。</p>\n<div><pre><code>U.S.A.\nApple, Inc.\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>（3）表示中文时，英文省略号（<code>⋯</code>）应改为中文省略号（<code>……</code>）。</p>\n<div><pre><code>英文：5 minutes later⋯\n\n中文：5 分钟过去了……\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>（4）英文书名或电影名改用中文表达时，双引号应改为书名号。</p>\n<div><pre><code>英文：He published an article entitled &quot;The Future of the Aviation&quot;.\n\n中文：他发表了一篇名为《航空业的未来》的文章。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>（5）第一次出现英文词汇时，在括号中给出中文标注。此后再次出现时，直接使用英文缩写即可。</p>\n<div><pre><code>IOC（International Olympic Committee，国际奥林匹克委员会）。这样定义后，便可以直接使用“IOC”了。\n</code></pre>\n<div><span>1</span><br></div></div><p>（6）专有名词中每个词第一个字母均应大写，非专有名词则不需要大写。</p>\n<div><pre><code>“American Association of Physicists in Medicine”（美国医学物理学家协会）是专有名词，需要大写。\n\n“online transaction processing”（在线事务处理）不是专有名词，不应大写。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"三、段落\"> 三、段落</h2>\n<h3 id=\"原则-2\"> 原则</h3>\n<ul>\n<li>一个段落只能有一个主题，或一个中心句子。</li>\n<li>段落的中心句子放在段首，对全段内容进行概述。后面陈述的句子为核心句服务。</li>\n<li>一个段落的长度不能超过七行，最佳段落长度小于等于四行。</li>\n<li>段落的句子语气要使用陈述和肯定语气，避免使用感叹语气。</li>\n<li>段落之间使用一个空行隔开。</li>\n<li>段落开头不要留出空白字符。</li>\n</ul>\n<h3 id=\"引用\"> 引用</h3>\n<p>引用第三方内容时，应注明出处。</p>\n<div><pre><code>One man’s constant is another man’s variable. — Alan Perlis\n</code></pre>\n<div><span>1</span><br></div></div><p>如果是全篇转载，请在全文开头显著位置注明作者和出处，并链接至原文。</p>\n<div><pre><code>本文转载自 WikiQuote\n</code></pre>\n<div><span>1</span><br></div></div><p>使用外部图片时，必须在图片下方或文末标明来源。</p>\n<div><pre><code>本文部分图片来自 Wikipedia\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"四、数值\"> 四、数值</h2>\n<h3 id=\"半角数字\"> 半角数字</h3>\n<p>阿拉伯数字一律使用半角形式，不得使用全角形式。</p>\n<div><pre><code>错误： 这件商品的价格是１０００元。\n\n正确： 这件商品的价格是 1000 元。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"千分号\"> 千分号</h3>\n<p>数值为千位以上，应添加千分号（半角逗号）。</p>\n<div><pre><code>XXX 公司的实收资本为 ￥1,258,000 人民币。\n</code></pre>\n<div><span>1</span><br></div></div><p>对于 4 位以下的数值，千分号是选用的，比如<code>1000</code>和<code>1,000</code>都可以接受。对于 4 位以上的数值，千分号是必须的。</p>\n<h3 id=\"货币\"> 货币</h3>\n<p>货币应为阿拉伯数字，并在数字前写出货币符号，或在数字后写出货币中文名称。</p>\n<div><pre><code>$1,000\n1,000 美元\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>英文的货币名称，建议参考国际标准 <a href=\"https://en.wikipedia.org/wiki/ISO_4217\" target=\"_blank\" rel=\"noopener noreferrer\">ISO 4217</a>。</p>\n<h3 id=\"数值范围\"> 数值范围</h3>\n<p>表示数值范围时，用<code>～</code>或<code>——</code>连接。参见《标点符号》一节的“连接号”部分。</p>\n<p>带有单位或百分号时，两个数字建议都要加上单位或百分号。</p>\n<div><pre><code>132kg～234kg\n\n67%～89%\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"变化程度的表示法\"> 变化程度的表示法</h3>\n<p>数字的增加要使用“增加了”、“增加到”。“了”表示增量，“到”表示定量。</p>\n<div><pre><code>增加到过去的两倍\n（过去为一，现在为二）\n\n增加了两倍\n（过去为一，现在为三）\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>数字的减少要使用“降低了”、“降低到”。“了”表示增量，“到”表示定量。</p>\n<div><pre><code>降低到百分之八十\n（定额是一百，现在是八十）\n\n降低了百分之八十\n（原来是一百，现在是二十）\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>不能用“降低 N 倍”或“减少 N 倍”的表示法，要用“降低百分之几”或“减少百分之几”。因为减少（或降低）一倍表示数值原来为一百，现在等于零。</p>\n<h2 id=\"五、标点符号\"> 五、标点符号</h2>\n<h3 id=\"原则-3\"> 原则</h3>\n<p>（1）中文语句的标点符号，均应该采取全角符号，这样可以与全角文字保持视觉的一致。</p>\n<p>（2）如果整句为英文，则该句使用英文/半角标点。</p>\n<p>（3）句号、问号、叹号、逗号、顿号、分号和冒号不得出现在一行之首。</p>\n<h3 id=\"句号\"> 句号</h3>\n<p>（1）中文语句的结尾处应该用全角句号（<code>。</code>）。</p>\n<p>（2）句子末尾用括号加注时，句号应在括号之外。</p>\n<div><pre><code>错误：关于文件的输出，请参照第 1.3 节（见第 26 页。）\n\n正确：关于文件的输出，请参照第 1.3 节（见第 26 页）。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"逗号\"> 逗号</h3>\n<p>（1）逗号（<code>，</code>）表示句子内部的一般性停顿。</p>\n<p>（2）注意避免“一逗到底”，即整个段落除了结尾，全部停顿都使用逗号。</p>\n<h3 id=\"顿号\"> 顿号</h3>\n<p>（1）句子内部的并列词，应该用全角顿号(<code>、</code>) 分隔，而不用逗号，即使并列词是英语也是如此。</p>\n<div><pre><code>错误：我最欣赏的科技公司有 Google, Facebook, 腾讯, 阿里和百度等。\n\n正确：我最欣赏的科技公司有 Google、Facebook、腾讯、阿里和百度等。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>（2）英文句子中，并列词语之间使用半角逗号（<code>,</code>）分隔。</p>\n<div><pre><code>例句：Microsoft Office includes Word, Excel, PowerPoint, Outlook and other components.\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"分号\"> 分号</h3>\n<p>（1）分号（<code>；</code>）表示复句内部并列分句之间的停顿。</p>\n<h3 id=\"引号\"> 引号</h3>\n<p>（1）引用时，应该使用全角双引号（<code>“ ”</code>），注意前后双引号不同。</p>\n<div><pre><code>例句：许多人都认为客户服务的核心是“友好”和“专业”。\n</code></pre>\n<div><span>1</span><br></div></div><p>（2）引号里面还要用引号时，外面一层用双引号，里面一层用单引号（<code>‘ ’</code>），注意前后单引号不同。</p>\n<div><pre><code>例句：鲍勃解释道：“我要放音乐，可萨利说，‘不行！’。”\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"括号\"> 括号</h3>\n<p>（1）补充说明时，使用全角圆括号（<code>（）</code>），括号前后不加空格。</p>\n<div><pre><code>例句：请确认所有的连接（电缆和接插件）均安装牢固。\n</code></pre>\n<div><span>1</span><br></div></div><p>（2）几种括号的中英文名称。</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th style=\"text-align:center\">英文</th>\n<th style=\"text-align:right\">中文</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>{ }</code></td>\n<td style=\"text-align:center\">braces 或 curly brackets</td>\n<td style=\"text-align:right\">大括号</td>\n</tr>\n<tr>\n<td><code>[ ]</code></td>\n<td style=\"text-align:center\">square brackets 或 brackets</td>\n<td style=\"text-align:right\">方括号</td>\n</tr>\n<tr>\n<td><code>&lt; &gt;</code></td>\n<td style=\"text-align:center\">angled brackets</td>\n<td style=\"text-align:right\">尖括号</td>\n</tr>\n<tr>\n<td><code>( )</code></td>\n<td style=\"text-align:center\">parentheses</td>\n<td style=\"text-align:right\">圆括号</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"冒号\"> 冒号</h3>\n<p>（1）全角冒号（<code>：</code>）常用在需要解释的词语后边，引出解释和说明。</p>\n<div><pre><code>例句：请确认以下几项内容：时间、地点、活动名称，以及来宾数量。\n</code></pre>\n<div><span>1</span><br></div></div><p>（2）表示时间时，应使用半角冒号（<code>:</code>）。</p>\n<div><pre><code>例句：早上 8:00\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"省略号\"> 省略号</h3>\n<p>（1）省略号（<code>……</code>）表示语句未完、或者语气的不连续。</p>\n<p>（2）省略号占两个汉字空间、包含六个省略点，不要使用<code>。。。</code>或<code>...</code>等非标准形式。</p>\n<p>（3）省略号不应与“等”这个词一起使用。</p>\n<div><pre><code>错误：我们为会餐准备了香蕉、苹果、梨…等各色水果。\n\n正确：我们为会餐准备了各色水果，有香蕉、苹果、梨……\n\n正确：我们为会餐准备了香蕉、苹果、梨等各色水果。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"感叹号\"> 感叹号</h3>\n<p>（1）应该使用平静的语气叙述，尽量避免使用感叹号（<code>！</code>）。</p>\n<p>（2）不得多个感叹号连用，比如<code>！！</code>和<code>!!!</code>。</p>\n<h3 id=\"破折号\"> 破折号</h3>\n<p>（1）破折号<code>————</code>一般用于进一步解释。</p>\n<p>（2）破折号应占两个汉字的位置。如果破折号本身只占一个汉字的位置，那么前后应该留出一个半角空格。</p>\n<div><pre><code>例句：直觉————尽管它并不总是可靠的————告诉我，这事可能出了些问题。\n\n例句：直觉 —— 尽管它并不总是可靠的 —— 告诉我，这事可能出了些问题。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"连接号\"> 连接号</h3>\n<p>（1）连接号用于连接两个类似的词。</p>\n<p>（2）以下场合应该使用直线连接号（<code>-</code>），占一个半角字符的位置。</p>\n<ul>\n<li>两个名词的复合</li>\n<li>图表编号</li>\n</ul>\n<div><pre><code>例句：氧化-还原反应\n\n例句：图 1-1\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>（3）数值范围（例如日期、时间或数字）应该使用波浪连接号（<code>～</code>），占一个全角字符的位置。</p>\n<div><pre><code>例句：2009 年～2011 年\n</code></pre>\n<div><span>1</span><br></div></div><p>注意，波浪连接号前后两个值都应该加上单位。</p>\n<p>（4）波浪连接号也可以用汉字“至”代替。</p>\n<div><pre><code>例句：周围温度：-20°C 至 -10°C\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"六、文档体系\"> 六、文档体系</h2>\n<h3 id=\"结构\"> 结构</h3>\n<p>软件手册是一部完整的书，建议采用下面的结构。</p>\n<ul>\n<li><strong>简介</strong>（Introduction）： [必备] [文件] 提供对产品和文档本身的总体的、扼要的说明</li>\n<li><strong>快速上手</strong>（Getting Started）：[可选] [文件] 如何最快速地使用产品</li>\n<li><strong>入门篇</strong>（Basics）： [必备] [目录] 又称”使用篇“，提供初级的使用教程\n<ul>\n<li><strong>环境准备</strong>（Prerequisite）：[必备] [文件] 软件使用需要满足的前置条件</li>\n<li><strong>安装</strong>（Installation）：[可选] [文件] 软件的安装方法</li>\n<li><strong>设置</strong>（Configuration）：[必备] [文件] 软件的设置</li>\n</ul>\n</li>\n<li><strong>进阶篇</strong>（Advanced)：[可选] [目录] 又称”开发篇“，提供中高级的开发教程</li>\n<li><strong>API</strong>（Reference）：[可选] [目录|文件] 软件 API 的逐一介绍</li>\n<li><strong>FAQ</strong>：[可选] [文件] 常见问题解答</li>\n<li><strong>附录</strong>（Appendix）：[可选] [目录] 不属于教程本身、但对阅读教程有帮助的内容\n<ul>\n<li><strong>Glossary</strong>：[可选] [文件] 名词解释</li>\n<li><strong>Recipes</strong>：[可选] [文件] 最佳实践</li>\n<li><strong>Troubleshooting</strong>：[可选] [文件] 故障处理</li>\n<li><strong>ChangeLog</strong>：[可选] [文件] 版本说明</li>\n<li><strong>Feedback</strong>：[可选] [文件] 反馈方式</li>\n</ul>\n</li>\n</ul>\n<p>下面是两个真实范例，可参考。</p>\n<ul>\n<li><a href=\"http://redux.js.org/index.html\" target=\"_blank\" rel=\"noopener noreferrer\">Redux 手册</a></li>\n<li><a href=\"http://flight-manual.atom.io/\" target=\"_blank\" rel=\"noopener noreferrer\">Atom 手册</a></li>\n</ul>\n<h3 id=\"文件名\"> 文件名</h3>\n<p>文档的文件名不得含有空格。</p>\n<p>文件名必须使用半角字符，不得使用全角字符。这也意味着，中文不能用于文件名。</p>\n<div><pre><code>错误： 名词解释.md\n\n正确： glossary.md\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>文件名建议只使用小写字母，不使用大写字母。</p>\n<div><pre><code>错误：TroubleShooting.md\n\n正确：troubleshooting.md \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>为了醒目，某些说明文件的文件名，可以使用大写字母，比如<code>README</code>、<code>LICENSE</code>。</p>\n<p>文件名包含多个单词时，单词之间建议使用半角的连词线（<code>-</code>）分隔。</p>\n<div><pre><code>不佳：advanced_usage.md\n\n正确：advanced-usage.md\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"七、参考链接\"> 七、参考链接</h2>\n<ul>\n<li><a href=\"http://wenku.baidu.com/view/23cc1a6527d3240c8447efbf.html\" target=\"_blank\" rel=\"noopener noreferrer\">产品手册中文写作规范</a>, by 华为</li>\n<li><a href=\"http://guide.daocloud.io/dcs/%E5%86%99%E4%BD%9C%E8%A7%84%E8%8C%83%E5%92%8C%E6%A0%BC%E5%BC%8F%E8%A7%84%E8%8C%83-9153803.html\" target=\"_blank\" rel=\"noopener noreferrer\">写作规范和格式规范</a>, by DaoCloud</li>\n<li><a href=\"http://www.hitachi-tc.co.jp/company/thesis/thesis.pdf\" target=\"_blank\" rel=\"noopener noreferrer\">技术写作技巧在日汉翻译中的应用</a>, by 刘方</li>\n<li><a href=\"https://www.lengoo.de/documents/styleguides/lengoo_styleguide_ZH.pdf\" target=\"_blank\" rel=\"noopener noreferrer\">简体中文规范指南</a>, by lengoo</li>\n<li><a href=\"https://open.leancloud.cn/copywriting-style-guide.html\" target=\"_blank\" rel=\"noopener noreferrer\">文档风格指南</a>, by LeanCloud</li>\n<li><a href=\"https://docs.google.com/document/d/1R8lMCPf6zCD5KEA8ekZ5knK77iw9J-vJ6vEopPemqZM/edit\" target=\"_blank\" rel=\"noopener noreferrer\">豌豆荚文案风格指南</a>, by 豌豆荚</li>\n<li><a href=\"https://github.com/sparanoid/chinese-copywriting-guidelines\" target=\"_blank\" rel=\"noopener noreferrer\">中文文案排版指北</a>, by sparanoid</li>\n<li><a href=\"http://w3c.github.io/clreq/\" target=\"_blank\" rel=\"noopener noreferrer\">中文排版需求</a>, by W3C</li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2017/02/filename-should-be-lowercase.html\" target=\"_blank\" rel=\"noopener noreferrer\">为什么文件名要小写？</a>, by 阮一峰</li>\n<li><a href=\"https://developers.google.com/style/\" target=\"_blank\" rel=\"noopener noreferrer\">Google Developer Documentation Style Guide</a>, by Google</li>\n<li><a href=\"http://www.moe.gov.cn/ewebeditor/uploadfile/2015/01/13/20150113091154536.pdf\" target=\"_blank\" rel=\"noopener noreferrer\">出版物上数字用法的规定（国家标准GBT15835－2011）</a></li>\n<li><a href=\"https://baike.baidu.com/item/%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E5%9B%BD%E5%AE%B6%E6%A0%87%E5%87%86%E5%87%BA%E7%89%88%E7%89%A9%E6%95%B0%E5%AD%97%E7%94%A8%E6%B3%95\" target=\"_blank\" rel=\"noopener noreferrer\">中华人民共和国国家标准出版物数字用法</a></li>\n</ul>\n",
      "date_published": "2021-12-25T09:26:08.000Z",
      "date_modified": "2021-12-25T09:26:08.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "年终总结汇报大纲",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/design/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%E6%B1%87%E6%8A%A5%E5%A4%A7%E7%BA%B2/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/design/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%E6%B1%87%E6%8A%A5%E5%A4%A7%E7%BA%B2/",
      "content_html": "<p>工作总结框架如下：</p>\n<h2 id=\"一、工作开展情况\"> 一、工作开展情况</h2>\n<p>1.一年来取得的成绩。</p>\n<p>2.在单位主要做了哪些工作。</p>\n<p>3.目前正在开展的主要工作。</p>\n<p>4.下一步要做的工作。</p>\n<h2 id=\"二、工作中的创新点、亮点以及经验技巧。\"> 二、工作中的创新点、亮点以及经验技巧。</h2>\n<p>1.哪些环节提高了工作效率。</p>\n<p>2.精简和优化了哪些工作流程。</p>\n<p>3.为单位节约了哪些成本。</p>\n<h2 id=\"三、存在不足和问题分析\"> 三、存在不足和问题分析</h2>\n<p>1.工作中遇到了哪些困难。</p>\n<p>2.出现困难的原因。</p>\n<p>3.是如何解决这些困难的。</p>\n<h2 id=\"四、来年的打算\"> 四、来年的打算</h2>\n<p>1.工作思路计划</p>\n<p>2.需要单位给予的哪些支持。#职场加油站# #冬日</p>\n",
      "date_published": "2022-01-04T14:58:20.000Z",
      "date_modified": "2022-01-04T14:58:20.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "领域驱动模型的思考与认知",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/design/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%80%9D%E8%80%83%E4%B8%8E%E8%AE%A4%E7%9F%A5/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/design/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%80%9D%E8%80%83%E4%B8%8E%E8%AE%A4%E7%9F%A5/",
      "content_html": "<blockquote>\n<p>本项目是基于小编的开发经验与心得,分享小编关于领域模型的理解, 个人愚见仅供参考,希望能为渴望进步的你提供帮助。如果你感到有用对你有帮助,请不要吝啬你的关注,求关注,求转发。\n文章有三个议题，什么是领域模型,为什么需要领域模型设计,以及领域驱动的项目结构是什么样的?</p>\n</blockquote>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1594392162000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"一、领域驱动模型是什么\"> 一、领域驱动模型是什么？</h2>\n<p>如果你是第一次听到这个词,嗯,多么恐怖的一件事情呀! 什么是领域模型,一种新的技术吗? 领域模型到底有什么用呢?\n为什么那么多大佬都在讲领域模型。网络上充斥着着各种高端的解释,各种高大上的名字,各种复杂的系统设计图。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1595078884000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>fuck !\n身边总是有这样一群人的出现。总喜欢中文里加载者英文,英文中夹杂着中文,仿佛这样能使他们更加自信一样。把你讲懵了,他就自信了。 very fuck !</p>\n<p>身为技术人,尽量想把一种事情给将清楚,说明白。而不是用各种抽象的晦涩难懂但看上去高大上的名词给解释。千万不要怕,下面我们通过先做一点小小的铺垫。最后在总结领域模型的理解。</p>\n<h3 id=\"_1-贫血模型\"> 1. 贫血模型</h3>\n<p>在讲清楚领域模型之前我们先来看引入一个词汇 <strong>“贫血模型”</strong> ，读到这里不要怕。只是一个词汇而已。是对我们平时的项目代码结构的一个形容词。相信无论面前的你\n是一个大牛，还是一个刚入行的小菜鸟。你都一定写过这样的代码:</p>\n<ul>\n<li>dao层: 负责持久化</li>\n<li>model层: 数据模型</li>\n<li>service层: 服务层</li>\n<li>web层: 提供对UI层的访问</li>\n</ul>\n<p>嗯。这就是一个典型的贫血模型, 哇,真的好形象,这是谁想出来的词汇,真想给他说一句 fuck you!  但是，但是，你还有更好的词汇来形容这种项目结构吗?\n所谓贫血模型是指使用的领域对象中只有 <code>setter</code> 和 <code>getter</code> 方法（POJO），所有的业务逻辑都不包含在领域对象中而是放在业务逻辑层。</p>\n<p>往往我们入行的初期我们都是在这样的项目结构中进行编程的,那个时候我们的业务往往都是简单的,对于那个时候的我们来说,这样的代码结构真是太好用了。清晰易懂。甚至想说一声 i love code !!!</p>\n<p>这个时期,我们的关注点往往不是业务的复杂度,而是技术的使用,语法的使用。以及代码是否能编译通过。所以下面我们来总结一下贫血模型的优点。</p>\n<h3 id=\"_2-贫血模型优点\"> 2. 贫血模型优点</h3>\n<ol>\n<li>被许多程序员所掌握，对于刚入行的同学来说，这种模型很自然很舒服，典型的MVC结构</li>\n<li>它非常简单，对于并不复杂的业务，它工作得很好，开发起来非常迅速。它似乎也不需要对领域的充分了解，只要给出要实现功能的每一个步骤，就能实现它。</li>\n<li>事务边界相当清楚，一般来说service的每个方法都可以看成一个事务。</li>\n</ol>\n<h3 id=\"_3-贫血模型缺点\"> 3. 贫血模型缺点</h3>\n<p>随着发际线推移,随着历史的变迁,随着候鸟的迁徙。不知不觉我们的业务越来越复杂了。万恶的资本家,总想让我们一夜之间开发一个淘宝,一夜之间开发一个百度,一夜之间开发一个QQ。于是我们的service层,不断的\n不断的增加。代码量从100行,200行,300行,10000行刹不住车了。终于小张忍不住了,辞职走了。留下了孤独的你独自承受这忧伤。\n<img src=\"https://img.springlearn.cn/blog/learn_1594392402000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>这样代码是什么意思？ 这样代码能不能删？这行代码怎么没有走？这样代码能不能拆出去? 这样改万一项目上线崩溃了怎么办? 想一想老婆,望一望孩子。哎,算了吧。于是乎service复杂度指数般的递增。这就是贫血模型的缺点。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1594392441000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>缺点</strong></p>\n<ol>\n<li>所有的业务都在service中处理，当业越来越复杂时，service会变得越来越庞大，最终难以理解和维护，轻则项目组解散，重则妻离子散。</li>\n<li>将所有的业务放在无状态的service中实际上是一个过程化的设计,这与面向对象的编程风格,相向而行。(你转身离开分手说不出来,海鸟跟鱼相爱只是一场意外)</li>\n<li>项目代码写的不少,重用的不多。(fuck and fuck = double kill)</li>\n</ol>\n<h3 id=\"_4-充血模型\"> 4. 充血模型</h3>\n<p>前面说我说了贫血模型,这里顺便提一下充血模型,也不要怕,也只是一个吓人的词汇。前面我们理解了贫血模型，那么充血模型，很容易就能理解。\n前面我们说贫血模型实体类只有SET GET方法，逻辑基本在服务层实现。而**充血模型它的实体类里不但有状态，还有行为，即属性和方法都有。它的Service层很薄。**显然者不符合MVC的思想,因为充血模型中model中不仅有数据,还有状态。维护起来非常麻烦。</p>\n<h3 id=\"_5-领域驱动总结\"> 5. 领域驱动总结</h3>\n<p>针对贫血模型的service层非常复杂臃肿的缺点,领域模型的概念越来越流行起来,至少在一些很多的大公司中,非常盛行。领域模型的概念不仅可以重新去设计service,同时也在微服务设计中有重要的意义。\n所以说领域模型其实就是要解决service越来越臃肿的一种设计思想。主要就是对service中的复杂的业务逻辑进行拆分,根据领域来进行拆分。用面向对象的思想去重新设计service。\n有人给他起了一个高大上的词汇: 领域模型。</p>\n<p>所以最后小编想用一大白话来总结一下领域模型。</p>\n<p><strong>领域模型就是要用面向对象的思想去重新设计充斥着复杂业务逻辑的service层。</strong></p>\n<h2 id=\"二、为什么要进行领域模型设计\"> 二、为什么要进行领域模型设计?</h2>\n<p>相信看到这里的你,一定对领域模型有一个自己的认识。为什么要进行领域模型设计? 相信自己心里一定有一个自己的判断了。贫血模型的项目结构, service层无可避免的非常的臃肿，臃肿到一个方法可能深不见底。对于业务老油条，可能还凑合能看成，<br>\n假如你是一个新的同学,当你看到这样的代码一定是崩溃的，假如说注释也没有,那你内心更是崩溃的。假如说这是一个很庞大的系统,很复杂的业务流程,这就更不用说了。\n<img src=\"https://img.springlearn.cn/blog/learn_1594478376000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>如果读到这里,你还是对领域驱动设计感到迷茫，那么就其实这个标题也可以这样讲: <strong>我们如何对臃肿的service进行面向对象的设计。设计的过程就是对service层的代码进行领域设计。</strong><br>\n而我们之所以这样做的目的。</p>\n<ol>\n<li>为了快乐的coding</li>\n<li>为了业务系统的稳定</li>\n<li>为了业务更快的迭代升级。</li>\n</ol>\n<p>当然这一切的前提是你对业务有一个全局的认识,有一个前瞻性的判断,否则也设计不出来,真正适合自身系统的领域驱动模型。</p>\n<h2 id=\"三、领域驱动的项目结构是什么样的\"> 三、领域驱动的项目结构是什么样的?</h2>\n<p>**一千个人眼里有一千个哈姆雷特,没有最好的项目结构,只有最适合自己的业务系统。**本文只是小编对领域驱动的模块的思考和认识。\n仅供参考,希望对你有所启示和引导。</p>\n<h3 id=\"_1-领域划分-模块化建造\"> 1. 领域划分|模块化建造</h3>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1594574191000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>领域划分,小编感觉用另外一个词形容也非常的合适,就是业务模块化。所有能力都进行能力化抽象,形成模块,形成领域。 当遇到新的业务逻辑,底层的数据结构和数据关系肯定也是一样的。那么就可以像堆积木一样,根据这些模块快速的组装成新的业务逻辑。快速的实现业务的迭代和升级。\n关于这个问题,需要结合自己的业务系统来进行抽象和设计。而小编的能做的就是,提醒你<strong>模块化设计,领域化设计的重要意义。</strong></p>\n<h3 id=\"_2-项目结构\"> 2. 项目结构</h3>\n<p>基础层(外部调用,db操作) + 领域层(偏向领域的业务逻辑) + 业务层(对领域层的业务编排) + 外观层(可以提供能力,可以提供视图)。\n有一个完善的领域层,可以方便快速便捷的对业务进行扩展。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1595074590000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>领域层就是模块化设计的积木。丰富的模块化有助于业务扩展。</p>\n<p>一定要控制项目的依赖情况。service只能出现领域层的依赖, 领域层只能存在dao层和第三方服务层。各个层代码不能平行调用。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1595069641000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_3-编程规范\"> 3. 编程规范</h3>\n<p>关于项目提出6个注意的点。如果把做项目比作是前线打仗,那么打仗最重要的是战斗成员目标要一致。在目标不一致的情况下一定要进行\n充分讨论(项目负责人要做的),说明情况互相妥协指定出统一的项目编程规范。去进行执行。一旦指定不能违背。否则项目质量不保。</p>\n<p><strong>项目固然重要,但是作为软件开发工程师,首先要对代码质量做保障。</strong></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1595078292000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_4-日志设计\"> 4. 日志设计</h3>\n<p>天下没有完美的项目,任何系统不存在bug是不可能的。想要发现bug并快速定位问题,日志系统的不能缺少的。</p>\n<p>日志系统是非常重要的系统, 对系统的监控, 在设计日志系统中,我们需要关注的点</p>\n<ol>\n<li>日志结构(目的是按照结构解析到日志引擎中)\n如果想做日志的搜索平台,一定要进行日志结构化设计,方便被搜索平台的解析。如ELK日志搜索系统。</li>\n<li>日志打印降级能力\n在遇到大促时候,可以减少不必要的日志打印,要对日志打印做降级的设计</li>\n<li>异步输入日志</li>\n<li>日志归档</li>\n</ol>\n<div><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;configuration&gt;\n    &lt;!-- 系统日志打印 --&gt;\n    &lt;appender name=&quot;logfile&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;\n        &lt;File&gt;${logger.logback.logpath}mbp-game-service.log&lt;/File&gt;\n        &lt;encoder&gt;\n            &lt;Pattern&gt;[%date] [%-5level] %c{40} %line --%mdc{client} [%X{TRACE_LOG_ID}] [%X{dstTraceId}] %msg%n&lt;/Pattern&gt;\n            &lt;charset&gt;UTF-8&lt;/charset&gt;\n        &lt;/encoder&gt;\n        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;\n            &lt;fileNamePattern&gt;${logger.logback.logpath}mbp-game-service.%d{yyyy-MM-dd}.%i.log&lt;/fileNamePattern&gt;\n            &lt;maxHistory&gt;30&lt;/maxHistory&gt;\n            &lt;TimeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt;\n                &lt;maxFileSize&gt;512MB&lt;/maxFileSize&gt;\n            &lt;/TimeBasedFileNamingAndTriggeringPolicy&gt;\n        &lt;/rollingPolicy&gt;\n    &lt;/appender&gt;\n\n    &lt;!-- 异步输出 --&gt;\n    &lt;appender name=&quot;asyncAppender&quot; class=&quot;ch.qos.logback.classic.AsyncAppender&quot;&gt;\n        &lt;!-- 不丢失日志.默认的,如果队列的80%已满,则会丢弃TRACT、DEBUG、INFO级别的日志 --&gt;\n        &lt;discardingThreshold&gt;0&lt;/discardingThreshold&gt;\n        &lt;!-- 更改默认的队列的深度,该值会影响性能.默认值为256 --&gt;\n        &lt;queueSize&gt;1024&lt;/queueSize&gt;\n        &lt;!-- 添加附加的appender,最多只能添加一个 --&gt;\n        &lt;appender-ref ref=&quot;logfile&quot;/&gt;\n    &lt;/appender&gt;\n\n\n    &lt;!-- 外部jar包 日志级别设置 --&gt;\n    &lt;logger level=&quot;${logger.outside.logLevel}&quot; name=&quot;com.ibatis&quot;/&gt;\n    &lt;logger level=&quot;${logger.outside.logLevel}&quot; name=&quot;org.springframework&quot;/&gt;\n    &lt;logger level=&quot;${logger.outside.logLevel}&quot; name=&quot;java.sql&quot;/&gt;\n    &lt;logger level=&quot;${logger.outside.logLevel}&quot; name=&quot;org.apache&quot;/&gt;\n    &lt;logger level=&quot;${logger.outside.logLevel}&quot; name=&quot;com.alibaba.dubbo&quot;/&gt;\n    &lt;logger level=&quot;${logger.outside.logLevel}&quot; name=&quot;org.I0Itec&quot;/&gt;\n    &lt;logger level=&quot;${logger.outside.logLevel}&quot; name=&quot;org.dozer&quot;/&gt;\n    &lt;logger level=&quot;${logger.outside.logLevel}&quot; name=&quot;kafka.producer.SyncProducer&quot;/&gt;\n    &lt;logger level=&quot;${logger.kafka.outside.logLevel}&quot; name=&quot;org.apache.kafka&quot;/&gt;\n    &lt;logger level=&quot;${logger.kafka.outside.logLevel}&quot; name=&quot;org.springframework.kafka&quot;/&gt;\n\n    &lt;!-- 输出到文件，可定义更多的 Appender --&gt;\n    &lt;root level=&quot;${logger.logLevel}&quot;&gt;\n        &lt;appender-ref ref=&quot;asyncAppender&quot;/&gt;\n    &lt;/root&gt;\n\n&lt;/configuration&gt;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br></div></div><p>最后求关注,求订阅,谢谢你的阅读!</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589360371000.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1594392162000.png",
      "date_published": "2021-12-21T05:46:37.000Z",
      "date_modified": "2021-12-21T05:46:37.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "海量数据模拟",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/databases/sql/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E6%A8%A1%E6%8B%9F/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/databases/sql/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E6%A8%A1%E6%8B%9F/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n<h2 id=\"一、创建表\"> 一、创建表</h2>\n<div><pre><code><span>create</span> <span>table</span> dept\n<span>(</span>\n dno <span>int</span><span>(</span><span>5</span><span>)</span> <span>primary</span> <span>key</span> <span>default</span> <span>0</span><span>,</span>\n dname <span>varchar</span><span>(</span><span>20</span><span>)</span> <span>not</span> <span>null</span> <span>default</span> <span>''</span><span>,</span>\n loc <span>varchar</span><span>(</span><span>30</span><span>)</span> <span>default</span> <span>''</span>\n<span>)</span> <span>engine</span> <span>=</span><span>innodb</span> <span>default</span> <span>charset</span><span>=</span>utf8<span>;</span>\n\n<span>create</span> <span>table</span> emp\n<span>(</span>\n eid <span>int</span><span>(</span><span>5</span><span>)</span> <span>primary</span> <span>key</span><span>,</span>\n ename <span>varchar</span><span>(</span><span>20</span><span>)</span> <span>not</span> <span>null</span> <span>default</span> <span>''</span><span>,</span>\n job <span>varchar</span><span>(</span><span>20</span><span>)</span> <span>not</span> <span>null</span> <span>default</span> <span>''</span><span>,</span>\n deptno <span>int</span><span>(</span><span>5</span><span>)</span> <span>not</span> <span>null</span> <span>default</span> <span>0</span>\n<span>)</span> <span>engine</span> <span>=</span><span>innodb</span> <span>default</span>  <span>charset</span><span>=</span>utf8<span>;</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h2 id=\"二、存储函数插入海量数量\"> 二、存储函数插入海量数量</h2>\n<p>存储过程无return,存储函数有。</p>\n<h3 id=\"_1-创建存储函数生成id和name\"> 1. 创建存储函数生成id和name</h3>\n<p>name随机字符串</p>\n<div><pre><code>delimiter $\ncreate function randstring(n int) returns varchar(255)\nbegin \n    declare all_str varchar(100) default &#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;;\n    declare return_str varchar(255) default &#39;&#39;;\n    declare i int default 0;\n    while i &lt;n\n    do\n        set return_str = concat(return_str,substring(all_str,rand()*52,1));\n        set i = i+1;\n    end while;    \n    return return_str;\nend $\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p><code>ERROR 1418 (HY000): This function has none of DETERMINISTIC, NO SQL, or READS SQL DATA in its declaration and binary logging is enabled (you *might* want to use the less safe log_bin_trust_function_creators variable)</code></p>\n<p>如果开启了慢慢查询日志,在开启存储函数就会冲突,解决办法1就是管理慢日志查询。</p>\n<p>解决办法2:</p>\n<p><code>show variables like '%log_bin_trust_function_creators%';</code></p>\n<p><code>set global log_bin_trust_function_creators=1;</code></p>\n<p>id随机数</p>\n<div><pre><code>delimiter $\ncreate function rand_num()returns int(5)\nbegin\n    declare i int default 0;\n    set i = floor(rand() * 100);\n    return i;\nend $;    \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id=\"_2-通过存储过程插入海量数据emp\"> 2. 通过存储过程插入海量数据emp</h3>\n<div><pre><code>create procedure insert_emp(in eid_start int(10),in data_times int(10))\nbegin\n    declare i int default 0;\n    set autocommit = 0;\n    repeat\n        insert into emp values(eid_start + i,randstring(5),&#39;other&#39;,rand_num());\n        set i = i + 1;\n        until i = data_times\n    end repeat;   \n    commit;\nend $;    \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id=\"_2-通过存储过程插入海量数据dept\"> 2. 通过存储过程插入海量数据dept</h3>\n<div><pre><code>create procedure insert_dept(in dno_start int(10),in data_times int(10))\nbegin\n    declare i int default 0;\n    set autocommit = 0;\n    repeat\n        insert into dept values(dno_start+i,randstring(6),randstring(8));\n        set i = i + 1;\n        until i = data_times\n    end repeat;\ncommit;\nend$    \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id=\"_3-插入海量数据\"> 3. 插入海量数据</h3>\n<p><code>delimiter ;</code>分割符改回原来</p>\n<p>员工表插入80w条数据\n<code>call insert_emp(1000,800000);</code>\n部门表插入30条数据\n<code>call insert_dept(10,30);</code></p>\n<div><pre><code>mysql&gt; select count(1) from emp;\n+----------+\n| count(1) |\n+----------+\n|   800000 |\n+----------+\n1 row in set (0.05 sec)\n\nmysql&gt; select count(1) from dept;\n+----------+\n| count(1) |\n+----------+\n|       30 |\n+----------+\n1 row in set (0.00 sec)\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id=\"三、利用profiles分析海量数据\"> 三、利用profiles分析海量数据</h2>\n<h3 id=\"_1-打开profiles\"> 1. 打开profiles</h3>\n<div><pre><code>set profiling = on;\nshow variables like &#39;%profiling%&#39;;\n\nmysql&gt; set profiling = on;\nQuery OK, 0 rows affected, 1 warning (0.00 sec)\n\nmysql&gt; show variables like &#39;%profiling%&#39;;\n+------------------------+-------+\n| Variable_name          | Value |\n+------------------------+-------+\n| have_profiling         | YES   |\n| profiling              | ON    |\n| profiling_history_size | 15    |\n+------------------------+-------+\n3 rows in set (0.00 sec)\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p><img src=\"https://img.springlearn.cn/blog/learn_1596455359000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_2-查询每条耗时\"> 2. 查询每条耗时</h3>\n<p>profiles会记录每个sql的耗时</p>\n<div><pre><code>mysql&gt; show profiles;\n+----------+------------+-----------------------------------+\n| Query_ID | Duration   | Query                             |\n+----------+------------+-----------------------------------+\n|        1 | 0.00164000 | show variables like &#39;%profiling%&#39; |\n|        2 | 0.04513900 | select count(1) from emp          |\n|        3 | 0.00056200 | select count(1) from dept         |\n+----------+------------+-----------------------------------+\n3 rows in set, 1 warning (0.00 sec)\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>但是这样不能精确匹配到耗时在哪里。此时可以使用profile精确来分析sql</p>\n<h3 id=\"_3-精确查询耗时\"> 3. 精确查询耗时</h3>\n<p><strong>精确</strong>\n根据上面的Query_ID来精确查找\n<code>show profile all for query 2;</code></p>\n<div><pre><code>+--------------------------------+----------+----------+------------+-------------------+---------------------+--------------+---------------+---------------+-------------------+-------------------+-------------------+-------+-------------------------+----------------------+-------------+\n| Status                         | Duration | CPU_user | CPU_system | Context_voluntary | Context_involuntary | Block_ops_in | Block_ops_out | Messages_sent | Messages_received | Page_faults_major | Page_faults_minor | Swaps | Source_function         | Source_file          | Source_line |\n+--------------------------------+----------+----------+------------+-------------------+---------------------+--------------+---------------+---------------+-------------------+-------------------+-------------------+-------+-------------------------+----------------------+-------------+\n| starting                       | 0.000106 | 0.000094 |   0.000012 |                 0 |                   0 |            0 |             0 |             0 |                 0 |                 0 |                 0 |     0 | NULL                    | NULL                 |        NULL |\n| Executing hook on transaction  | 0.000008 | 0.000004 |   0.000004 |                 0 |                   0 |            0 |             0 |             0 |                 0 |                 0 |                 0 |     0 | launch_hook_trans_begin | rpl_handler.cc       |        1106 |\n| starting                       | 0.000013 | 0.000010 |   0.000002 |                 0 |                   0 |            0 |             0 |             0 |                 0 |                 0 |                 0 |     0 | launch_hook_trans_begin | rpl_handler.cc       |        1108 |\n| checking permissions           | 0.000009 | 0.000007 |   0.000003 |                 0 |                   0 |            0 |             0 |             0 |                 0 |                 0 |                 0 |     0 | check_access            | sql_authorization.cc |        2202 |\n| Opening tables                 | 0.000047 | 0.000045 |   0.000002 |                 0 |                   0 |            0 |             0 |             0 |                 0 |                 0 |                 0 |     0 | open_tables             | sql_base.cc          |        5587 |\n| init                           | 0.000012 | 0.000008 |   0.000003 |                 0 |                   0 |            0 |             0 |             0 |                 0 |                 0 |                 0 |     0 | execute                 | sql_select.cc        |         661 |\n| System lock                    | 0.000014 | 0.000012 |   0.000003 |                 0 |                   0 |            0 |             0 |             0 |                 0 |                 0 |                 0 |     0 | mysql_lock_tables       | lock.cc              |         332 |\n| optimizing                     | 0.000010 | 0.000007 |   0.000002 |                 0 |                   0 |            0 |             0 |             0 |                 0 |                 0 |                 0 |     0 | optimize                | sql_optimizer.cc     |         213 |\n| statistics                     | 0.000037 | 0.000023 |   0.000014 |                 0 |                   0 |            0 |             0 |             0 |                 0 |                 0 |                 1 |     0 | optimize                | sql_optimizer.cc     |         423 |\n| preparing                      | 0.000025 | 0.000023 |   0.000003 |                 0 |                   0 |            0 |             0 |             0 |                 0 |                 0 |                 0 |     0 | optimize                | sql_optimizer.cc     |         497 |\n| executing                      | 0.000007 | 0.000004 |   0.000003 |                 0 |                   0 |            0 |             0 |             0 |                 0 |                 0 |                 0 |     0 | exec                    | sql_executor.cc      |         228 |\n| Sending data                   | 0.044768 | 0.072019 |   0.003191 |                 0 |                 810 |            0 |             0 |             0 |                 0 |                 0 |                 9 |     0 | exec                    | sql_executor.cc      |         304 |\n| end                            | 0.000018 | 0.000009 |   0.000010 |                 0 |                   0 |            0 |             0 |             0 |                 0 |                 0 |                 0 |     0 | execute                 | sql_select.cc        |         714 |\n| query end                      | 0.000006 | 0.000004 |   0.000002 |                 0 |                   0 |            0 |             0 |             0 |                 0 |                 0 |                 0 |     0 | mysql_execute_command   | sql_parse.cc         |        4520 |\n| waiting for handler commit     | 0.000013 | 0.000011 |   0.000001 |                 0 |                   0 |            0 |             0 |             0 |                 0 |                 0 |                 0 |     0 | ha_commit_trans         | handler.cc           |        1533 |\n| closing tables                 | 0.000009 | 0.000008 |   0.000002 |                 0 |                   0 |            0 |             0 |             0 |                 0 |                 0 |                 0 |     0 | mysql_execute_command   | sql_parse.cc         |        4566 |\n| freeing items                  | 0.000026 | 0.000012 |   0.000013 |                 0 |                   0 |            0 |             0 |             1 |                 0 |                 0 |                 0 |     0 | mysql_parse             | sql_parse.cc         |        5237 |\n| cleaning up                    | 0.000011 | 0.000009 |   0.000002 |                 0 |                   0 |            0 |             0 |             0 |                 0 |                 0 |                 0 |     0 | dispatch_command        | sql_parse.cc         |        2147 |\n+--------------------------------+----------+----------+------------+-------------------+---------------------+--------------+---------------+---------------+-------------------+-------------------+-------------------+-------+-------------------------+----------------------+-------------+\n18 rows in set, 1 warning (0.00 sec)\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>我们可以看到信息太多了,我们其实只用关系几列的数据就行了。</p>\n<div><pre><code>mysql&gt; show profile cpu,block io for query 2;\n+--------------------------------+----------+----------+------------+--------------+---------------+\n| Status                         | Duration | CPU_user | CPU_system | Block_ops_in | Block_ops_out |\n+--------------------------------+----------+----------+------------+--------------+---------------+\n| starting                       | 0.000106 | 0.000094 |   0.000012 |            0 |             0 |\n| Executing hook on transaction  | 0.000008 | 0.000004 |   0.000004 |            0 |             0 |\n| starting                       | 0.000013 | 0.000010 |   0.000002 |            0 |             0 |\n| checking permissions           | 0.000009 | 0.000007 |   0.000003 |            0 |             0 |\n| Opening tables                 | 0.000047 | 0.000045 |   0.000002 |            0 |             0 |\n| init                           | 0.000012 | 0.000008 |   0.000003 |            0 |             0 |\n| System lock                    | 0.000014 | 0.000012 |   0.000003 |            0 |             0 |\n| optimizing                     | 0.000010 | 0.000007 |   0.000002 |            0 |             0 |\n| statistics                     | 0.000037 | 0.000023 |   0.000014 |            0 |             0 |\n| preparing                      | 0.000025 | 0.000023 |   0.000003 |            0 |             0 |\n| executing                      | 0.000007 | 0.000004 |   0.000003 |            0 |             0 |\n| Sending data                   | 0.044768 | 0.072019 |   0.003191 |            0 |             0 |\n| end                            | 0.000018 | 0.000009 |   0.000010 |            0 |             0 |\n| query end                      | 0.000006 | 0.000004 |   0.000002 |            0 |             0 |\n| waiting for handler commit     | 0.000013 | 0.000011 |   0.000001 |            0 |             0 |\n| closing tables                 | 0.000009 | 0.000008 |   0.000002 |            0 |             0 |\n| freeing items                  | 0.000026 | 0.000012 |   0.000013 |            0 |             0 |\n| cleaning up                    | 0.000011 | 0.000009 |   0.000002 |            0 |             0 |\n+--------------------------------+----------+----------+------------+--------------+---------------+\n18 rows in set, 1 warning (0.01 sec)\n\nmysql&gt;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><h3 id=\"_4-全局查询日志\"> 4. 全局查询日志</h3>\n<p>仅仅在调优和开发中使用,生产要关闭</p>\n<p><code>show variables like '%general_log%';</code></p>\n<p>开启全局日志记录并将sql都写入到表中</p>\n<div><pre><code>set global general_log = 1;\nset global log_output = &#39;table&#39;;\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><div><pre><code>mysql&gt; show variables like &#39;%general_log%&#39;;\n+------------------+------------------------------------+\n| Variable_name    | Value                              |\n+------------------+------------------------------------+\n| general_log      | OFF                                |\n| general_log_file | /usr/local/var/mysql/localhost.log |\n+------------------+------------------------------------+\n2 rows in set (0.01 sec)\n\nmysql&gt; set global general_log = 1;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; show variables like &#39;%general_log%&#39;;\n+------------------+------------------------------------+\n| Variable_name    | Value                              |\n+------------------+------------------------------------+\n| general_log      | ON                                 |\n| general_log_file | /usr/local/var/mysql/localhost.log |\n+------------------+------------------------------------+\n2 rows in set (0.01 sec)\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>开启之后就可以在mysql库中的general_log表中进行查询</p>\n<p><code>select * from mysql.general_log;</code>\n<img src=\"https://img.springlearn.cn/blog/learn_1596457337000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>将sql设置到文件中</p>\n<div><pre><code>set global general_log = 1;\nset global log_output = &#39;file&#39;;\nset global general_log_file=&#39;/Users/liuxin/general.log&#39;;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><img src=\"https://img.springlearn.cn/blog/learn_1596457737000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>最后求关注,求订阅,谢谢你的阅读!</p>\n",
      "image": "https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png",
      "date_published": "2022-01-04T14:58:20.000Z",
      "date_modified": "2022-01-04T14:58:20.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "组件禁用",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/guide/disable/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/guide/disable/",
      "summary": "<p>你可以通过设置页面的 Frontmatter，在页面禁用一些功能。</p>\n",
      "content_html": "<p>你可以通过设置页面的 Frontmatter，在页面禁用一些功能。</p>\n\n<p>本页面应当禁用了:</p>\n<ul>\n<li>导航栏</li>\n<li>侧边栏</li>\n<li>路径导航</li>\n<li>页面信息</li>\n<li>贡献者</li>\n<li>编辑此页链接</li>\n<li>更新时间</li>\n<li>上一篇/下一篇 链接</li>\n<li>评论</li>\n<li>页脚</li>\n<li>返回顶部按钮</li>\n</ul>\n",
      "date_published": "2021-12-21T05:46:37.000Z",
      "date_modified": "2021-12-21T05:46:37.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "使用指南"
      ]
    },
    {
      "title": "密码加密的文章",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/guide/encrypt/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/guide/encrypt/",
      "content_html": "<h1 id=\"密码加密的文章\"> 密码加密的文章</h1>\n<p>实际的文章内容。</p>\n<p>段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字。</p>\n<p>段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字。</p>\n",
      "date_published": "2021-12-21T05:46:37.000Z",
      "date_modified": "2021-12-21T05:46:37.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "使用指南"
      ]
    },
    {
      "title": "主要功能与配置演示",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/guide/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/guide/",
      "content_html": "<h1 id=\"主要功能与配置演示\"> 主要功能与配置演示</h1>\n<ul>\n<li>\n<p><a href=\"./page.html\">页面展示</a></p>\n</li>\n<li>\n<p><a href=\"./markdown.html\">Markdown 展示</a></p>\n</li>\n<li>\n<p><a href=\"./disable.html\">禁用展示</a></p>\n</li>\n<li>\n<p><a href=\"./encrypt.html\">加密展示</a></p>\n</li>\n</ul>\n",
      "date_published": "2021-12-21T05:46:37.000Z",
      "date_modified": "2021-12-21T05:46:37.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "使用指南"
      ]
    },
    {
      "title": "Markdown 增强",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/guide/markdown/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/guide/markdown/",
      "summary": "<p><code>vuepress-theme-hope</code> 通过内置 <a href=\"https://vuepress-theme-hope.github.io/md-enhance\" target=\"_blank\" rel=\"noopener noreferrer\">md-enhance</a>，在 Markdown 中启用了更多的语法与新功能。</p>\n",
      "content_html": "<p><code>vuepress-theme-hope</code> 通过内置 <a href=\"https://vuepress-theme-hope.github.io/md-enhance\" target=\"_blank\" rel=\"noopener noreferrer\">md-enhance</a>，在 Markdown 中启用了更多的语法与新功能。</p>\n\n<h2 id=\"一键启用\"> 一键启用</h2>\n<p>你可以设置 <code>themeconfig.mdEnhance.enableAll</code> 启用 <a href=\"https://vuepress-theme-hope.github.io/md-enhance\" target=\"_blank\" rel=\"noopener noreferrer\">md-enhance</a> 插件的所有功能。</p>\n<div><div><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br></div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>\n  <span>themeConfig</span><span>:</span> <span>{</span>\n    <span>mdEnhance</span><span>:</span> <span>{</span>\n      <span>enableAll</span><span>:</span> <span>true</span><span>,</span>\n    <span>}</span><span>,</span>\n  <span>}</span><span>,</span>\n<span>}</span><span>;</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id=\"新增的更多语法\"> 新增的更多语法</h2>\n<h3 id=\"上下角标\"> 上下角标</h3>\n<p>19<sup>th</sup> H<sub>2</sub>O</p>\n<details><summary>代码</summary>\n<div><pre><code>19^th^ H<span><span>~</span><span>2</span><span>~</span></span>O\n</code></pre>\n<div><span>1</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/zh/guide/markdown/sup-sub/\" target=\"_blank\" rel=\"noopener noreferrer\">点击查看</a></li>\n</ul>\n<h3 id=\"自定义对齐\"> 自定义对齐</h3>\n<div>\n<p>我是居中的</p>\n</div>\n<div>\n<p>我在右对齐</p>\n</div>\n<details><summary>代码</summary>\n<div><pre><code>::: center\n\n我是居中的\n\n:::\n\n::: right\n\n我在右对齐\n\n:::\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/zh/guide/markdown/align/\" target=\"_blank\" rel=\"noopener noreferrer\">点击查看</a></li>\n</ul>\n<h3 id=\"脚注\"> 脚注</h3>\n<p>此文字有脚注<sup></sup>.</p>\n<details><summary>代码</summary>\n<div><pre><code>此文字有脚注[^first].\n\n<span><span>[</span><span>^first</span><span>]</span><span>:</span> 这是脚注内容</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/zh/guide/markdown/footnote/\" target=\"_blank\" rel=\"noopener noreferrer\">点击查看</a></li>\n</ul>\n<h3 id=\"标记\"> 标记</h3>\n<p>你可以标记 <mark>重要的内容</mark> 。</p>\n<details><summary>代码</summary>\n<div><pre><code>你可以标记 ==重要的内容== 。\n</code></pre>\n<div><span>1</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/zh/guide/markdown/mark/\" target=\"_blank\" rel=\"noopener noreferrer\">点击查看</a></li>\n</ul>\n<h3 id=\"任务列表\"> 任务列表</h3>\n<ul>\n<li><input type=\"checkbox\" checked=\"checked\" disabled=\"disabled\" id=\"task-item-0\"><label for=\"task-item-0\"> 计划 1</label></li>\n<li><input type=\"checkbox\"  disabled=\"disabled\" id=\"task-item-1\"><label for=\"task-item-1\"> 计划 2</label></li>\n</ul>\n<details><summary>Code</summary>\n<div><pre><code><span>-</span> [x] 计划 1\n<span>-</span> [ ] 计划 2\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/guide/markdown/tasklist/\" target=\"_blank\" rel=\"noopener noreferrer\">点击查看</a></li>\n</ul>\n<h3 id=\"流程图\"> 流程图</h3>\n<i>Not supported content</i><details><summary>代码</summary>\n<div><pre><code><span><span>```</span><span>flow</span>\n<span>cond=>condition: Process?\nprocess=>operation: Process\ne=>end: End\n\ncond(yes)->process->e\ncond(no)->e</span>\n<span>```</span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/zh/guide/markdown/flowchart/\" target=\"_blank\" rel=\"noopener noreferrer\">点击查看</a></li>\n</ul>\n<h2 id=\"mermaid\"> Mermaid</h2>\n<Mermaid id=\"mermaid-64a57060\" data-code=\"graph%20TD%3B%0A%20%20%20%20A--%3EB%3B%0A%20%20%20%20A--%3EC%3B%0A%20%20%20%20B--%3ED%3B%0A%20%20%20%20C--%3ED%3B%0A\"></Mermaid><details><summary>代码</summary>\n<div><pre><code><span><span>```</span><span>mermaid</span>\n<span>graph TD;\n    A-->B;\n    A-->C;\n    B-->D;\n    C-->D;</span>\n<span>```</span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/zh/guide/markdown/mermaid/\" target=\"_blank\" rel=\"noopener noreferrer\">点击查看</a></li>\n</ul>\n<h3 id=\"tex-语法\"> Tex 语法</h3>\n<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:2.4em;vertical-align:-0.95em;\"></span><span><span></span><span><span><span><span style=\"height:1.3714em;\"><span style=\"top:-2.314em;\"><span style=\"height:3em;\"></span><span><span style=\"margin-right:0.05556em;\">∂</span><span><span style=\"margin-right:0.03588em;\">ω</span><span><span><span><span style=\"height:0.5904em;\"><span style=\"top:-2.989em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span style=\"margin-right:0.02778em;\">r</span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span style=\"height:3em;\"></span><span style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span style=\"height:3em;\"></span><span><span><span style=\"margin-right:0.05556em;\">∂</span><span><span><span><span style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span style=\"margin-right:0.02778em;\">r</span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style=\"height:0.686em;\"><span></span></span></span></span></span><span></span></span><span style=\"margin-right:0.1667em;\"></span><span><span style=\"top:0em;\"><span>(</span></span><span><span></span><span><span><span><span style=\"height:1.3414em;\"><span style=\"top:-2.314em;\"><span style=\"height:3em;\"></span><span><span style=\"margin-right:0.03588em;\">ω</span></span></span><span style=\"top:-3.23em;\"><span style=\"height:3em;\"></span><span style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span style=\"height:3em;\"></span><span><span><span style=\"margin-right:0.03588em;\">y</span><span><span><span><span style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span style=\"margin-right:0.03588em;\">ω</span></span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style=\"height:0.686em;\"><span></span></span></span></span></span><span></span></span><span style=\"top:0em;\"><span>)</span></span></span><span style=\"margin-right:0.2778em;\"></span><span>=</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:3.0277em;vertical-align:-1.2777em;\"></span><span><span style=\"top:0em;\"><span>(</span></span><span><span></span><span><span><span><span style=\"height:1.3414em;\"><span style=\"top:-2.314em;\"><span style=\"height:3em;\"></span><span><span style=\"margin-right:0.03588em;\">ω</span></span></span><span style=\"top:-3.23em;\"><span style=\"height:3em;\"></span><span style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span style=\"height:3em;\"></span><span><span><span style=\"margin-right:0.03588em;\">y</span><span><span><span><span style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span style=\"margin-right:0.03588em;\">ω</span></span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style=\"height:0.686em;\"><span></span></span></span></span></span><span></span></span><span style=\"top:0em;\"><span>)</span></span></span><span style=\"margin-right:0.1667em;\"></span><span><span style=\"top:0em;\"><span>{</span></span><span>(</span><span>lo<span style=\"margin-right:0.01389em;\">g</span></span><span style=\"margin-right:0.1667em;\"></span><span style=\"margin-right:0.03588em;\">y</span><span><span>)</span><span><span><span><span style=\"height:0.7144em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span style=\"margin-right:0.02778em;\">r</span></span></span></span></span></span></span></span><span style=\"margin-right:0.2222em;\"></span><span>+</span><span style=\"margin-right:0.2222em;\"></span><span><span><span><span style=\"height:1.6514em;\"><span style=\"top:-1.8723em;margin-left:0em;\"><span style=\"height:3.05em;\"></span><span><span><span>i</span><span>=</span><span>1</span></span></span></span><span style=\"top:-3.05em;\"><span style=\"height:3.05em;\"></span><span><span>∑</span></span></span><span style=\"top:-4.3em;margin-left:0em;\"><span style=\"height:3.05em;\"></span><span><span style=\"margin-right:0.02778em;\">r</span></span></span></span><span>​</span></span><span><span style=\"height:1.2777em;\"><span></span></span></span></span></span><span style=\"margin-right:0.1667em;\"></span><span><span></span><span><span><span><span style=\"height:1.5017em;\"><span style=\"top:-2.314em;\"><span style=\"height:3em;\"></span><span><span><span style=\"margin-right:0.03588em;\">ω</span><span><span><span><span style=\"height:0.7507em;\"><span style=\"top:-2.989em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>i</span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span style=\"height:3em;\"></span><span style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span style=\"height:3em;\"></span><span><span>(</span><span>−</span><span>1</span><span><span>)</span><span><span><span><span style=\"height:0.8247em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>i</span></span></span></span></span></span></span></span><span style=\"margin-right:0.02778em;\">r</span><span style=\"margin-right:0.1667em;\"></span><span>⋯</span><span style=\"margin-right:0.1667em;\"></span><span>(</span><span style=\"margin-right:0.02778em;\">r</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span><span>i</span><span style=\"margin-right:0.2222em;\"></span><span>+</span><span style=\"margin-right:0.2222em;\"></span><span>1</span><span>)</span><span>(</span><span>lo<span style=\"margin-right:0.01389em;\">g</span></span><span style=\"margin-right:0.1667em;\"></span><span style=\"margin-right:0.03588em;\">y</span><span><span>)</span><span><span><span><span style=\"height:0.8247em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span style=\"margin-right:0.02778em;\">r</span><span>−</span><span>i</span></span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style=\"height:0.686em;\"><span></span></span></span></span></span><span></span></span><span style=\"top:0em;\"><span>}</span></span></span></span></span></span></span></p>\n<details><summary>代码</summary>\n<div><pre><code>$$\n\\frac {\\partial^r} {\\partial \\omega^r} \\left(\\frac {y^{\\omega}} {\\omega}\\right)\n= \\left(\\frac {y^{\\omega}} {\\omega}\\right) \\left\\{(\\log y)^r + \\sum_{i=1}^r \\frac {(-1)^i r \\cdots (r-i+1) (\\log y)^{r-i}} {\\omega^i} \\right\\}\n$$\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/zh/guide/markdown/tex/\" target=\"_blank\" rel=\"noopener noreferrer\">点击查看</a></li>\n</ul>\n<h3 id=\"代码案例\"> 代码案例</h3>\n\n          <div\n            id=\"code-demo-5ac6bc9f\"\n           \n  \n data-title=\"%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%20Demo\"\n\n            data-code=\"%7B%22html%22%3A%22%3Ch1%3EMr.Hope%3C%2Fh1%3E%5Cn%3Cp%3E%3Cspan%20id%3D%5C%22very%5C%22%3E%E5%8D%81%E5%88%86%3C%2Fspan%3E%20%E5%B8%85%3C%2Fp%3E%5Cn%22%2C%22js%22%3A%22document.querySelector(%5C%22%23very%5C%22).addEventListener(%5C%22click%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20alert(%5C%22%E5%8D%81%E5%88%86%E5%B8%85%5C%22)%3B%5Cn%7D)%3B%5Cn%22%2C%22css%22%3A%22span%20%7B%5Cn%20%20color%3A%20red%3B%5Cn%7D%5Cn%22%7D\"\n          >\n              \n              <div>\n                <div>\n<div><pre><code><span><span><span>&lt;</span>h1</span><span>></span></span>Mr.Hope<span><span><span>&lt;/</span>h1</span><span>></span></span>\n<span><span><span>&lt;</span>p</span><span>></span></span><span><span><span>&lt;</span>span</span> <span>id</span><span><span>=</span><span>\"</span>very<span>\"</span></span><span>></span></span>十分<span><span><span>&lt;/</span>span</span><span>></span></span> 帅<span><span><span>&lt;/</span>p</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><div><pre><code>document<span>.</span><span>querySelector</span><span>(</span><span>\"#very\"</span><span>)</span><span>.</span><span>addEventListener</span><span>(</span><span>\"click\"</span><span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>\n  <span>alert</span><span>(</span><span>\"十分帅\"</span><span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code><span>span</span> <span>{</span>\n  <span>color</span><span>:</span> red<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div>\n            </div>\n          </div>\n          \n        </div>\n<details><summary>代码</summary>\n<div><pre><code>::: demo 一个普通 Demo\n\n<span><span>```</span><span>html</span>\n<span><span><span><span>&lt;</span>h1</span><span>></span></span>Mr.Hope<span><span><span>&lt;/</span>h1</span><span>></span></span>\n<span><span><span>&lt;</span>p</span><span>></span></span><span><span><span>&lt;</span>span</span> <span>id</span><span><span>=</span><span>\"</span>very<span>\"</span></span><span>></span></span>十分<span><span><span>&lt;/</span>span</span><span>></span></span> 帅<span><span><span>&lt;/</span>p</span><span>></span></span></span>\n<span>```</span></span>\n\n<span><span>```</span><span>js</span>\n<span>document<span>.</span><span>querySelector</span><span>(</span><span>\"#very\"</span><span>)</span><span>.</span><span>addEventListener</span><span>(</span><span>\"click\"</span><span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>\n  <span>alert</span><span>(</span><span>\"十分帅\"</span><span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span></span>\n<span>```</span></span>\n\n<span><span>```</span><span>css</span>\n<span><span>span</span> <span>{</span>\n  <span>color</span><span>:</span> red<span>;</span>\n<span>}</span></span>\n<span>```</span></span>\n\n:::\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div></details>\n\n          <div\n            id=\"code-demo-693e1878\"\n           \n  data-type=\"react\"\n data-title=\"%E4%B8%80%E4%B8%AA%20React%20Demo\"\n\n            data-code=\"%7B%22js%22%3A%22export%20default%20class%20App%20extends%20React.Component%20%7B%5Cn%20%20constructor(props)%20%7B%5Cn%20%20%20%20super(props)%3B%5Cn%20%20%20%20this.state%20%3D%20%7B%20message%3A%20%5C%22%E5%8D%81%E5%88%86%E5%B8%85%5C%22%20%7D%3B%5Cn%20%20%7D%5Cn%20%20render()%20%7B%5Cn%20%20%20%20return%20(%5Cn%20%20%20%20%20%20%3Cdiv%20className%3D%5C%22box-react%5C%22%3E%5Cn%20%20%20%20%20%20%20%20Mr.Hope%20%3Cspan%3E%7Bthis.state.message%7D%3C%2Fspan%3E%5Cn%20%20%20%20%20%20%3C%2Fdiv%3E%5Cn%20%20%20%20)%3B%5Cn%20%20%7D%5Cn%7D%5Cn%22%2C%22css%22%3A%22.box-react%20span%20%7B%5Cn%20%20color%3A%20red%3B%5Cn%7D%5Cn%22%7D\"\n          >\n              \n              <div>\n                <div>\n<div><pre><code><span>export</span> <span>default</span> <span>class</span> <span>App</span> <span>extends</span> <span>React<span>.</span>Component</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>props</span><span>)</span> <span>{</span>\n    <span>super</span><span>(</span>props<span>)</span><span>;</span>\n    <span>this</span><span>.</span>state <span>=</span> <span>{</span> <span>message</span><span>:</span> <span>\"十分帅\"</span> <span>}</span><span>;</span>\n  <span>}</span>\n  <span>render</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>(</span>\n      <span>&lt;</span>div className<span>=</span><span>\"box-react\"</span><span>></span>\n        Mr<span>.</span>Hope <span>&lt;</span>span<span>></span><span>{</span><span>this</span><span>.</span>state<span>.</span>message<span>}</span><span>&lt;</span><span>/</span>span<span>></span>\n      <span>&lt;</span><span>/</span>div<span>></span>\n    <span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><div><pre><code><span>.box-react span</span> <span>{</span>\n  <span>color</span><span>:</span> red<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div>\n            </div>\n          </div>\n          \n        </div>\n<details><summary>代码</summary>\n<div><pre><code>::: demo [react] 一个 React Demo\n\n<span><span>```</span><span>js</span>\n<span><span>export</span> <span>default</span> <span>class</span> <span>App</span> <span>extends</span> <span>React<span>.</span>Component</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>props</span><span>)</span> <span>{</span>\n    <span>super</span><span>(</span>props<span>)</span><span>;</span>\n    <span>this</span><span>.</span>state <span>=</span> <span>{</span> <span>message</span><span>:</span> <span>\"十分帅\"</span> <span>}</span><span>;</span>\n  <span>}</span>\n  <span>render</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>(</span>\n      <span>&lt;</span>div className<span>=</span><span>\"box-react\"</span><span>></span>\n        Mr<span>.</span>Hope <span>&lt;</span>span<span>></span><span>{</span><span>this</span><span>.</span>state<span>.</span>message<span>}</span><span>&lt;</span><span>/</span>span<span>></span>\n      <span>&lt;</span><span>/</span>div<span>></span>\n    <span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span></span>\n<span>```</span></span>\n\n<span><span>```</span><span>css</span>\n<span><span>.box-react span</span> <span>{</span>\n  <span>color</span><span>:</span> red<span>;</span>\n<span>}</span></span>\n<span>```</span></span>\n\n:::\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div></details>\n\n          <div\n            id=\"code-demo-2c0b9cdb\"\n           \n  data-type=\"vue\"\n data-title=\"%E4%B8%80%E4%B8%AA%20Vue%20Demo\"\n\n            data-code=\"%7B%22vue%22%3A%22%3Ctemplate%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%5C%22%3E%5Cn%20%20%20%20Mr.Hope%20%3Cspan%3E%7B%7B%20message%20%7D%7D%3C%2Fspan%3E%5Cn%20%20%3C%2Fdiv%3E%5Cn%3C%2Ftemplate%3E%5Cn%3Cscript%3E%5Cnexport%20default%20%7B%5Cn%20%20data%3A%20()%20%3D%3E%20(%7B%20message%3A%20%5C%22%E5%8D%81%E5%88%86%E5%B8%85%5C%22%20%7D)%2C%5Cn%7D%3B%5Cn%3C%2Fscript%3E%5Cn%3Cstyle%3E%5Cn.box%20span%20%7B%5Cn%20%20color%3A%20red%3B%5Cn%7D%5Cn%3C%2Fstyle%3E%5Cn%22%7D\"\n          >\n              \n              <div>\n                <div>\n<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>box<span>\"</span></span><span>></span></span>\n    Mr.Hope <span><span><span>&lt;</span>span</span><span>></span></span>{{ message }}<span><span><span>&lt;/</span>span</span><span>></span></span>\n  <span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;/</span>template</span><span>></span></span>\n<span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n<span>export</span> <span>default</span> <span>{</span>\n  <span>data</span><span>:</span> <span>(</span><span>)</span> <span>=></span> <span>(</span><span>{</span> <span>message</span><span>:</span> <span>\"十分帅\"</span> <span>}</span><span>)</span><span>,</span>\n<span>}</span><span>;</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n<span><span><span>&lt;</span>style</span><span>></span></span><span><span>\n<span>.box span</span> <span>{</span>\n  <span>color</span><span>:</span> red<span>;</span>\n<span>}</span>\n</span></span><span><span><span>&lt;/</span>style</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div>\n            </div>\n          </div>\n          \n        </div>\n<details><summary>代码</summary>\n<div><pre><code>::: demo [vue] 一个 Vue Demo\n\n<span><span>```</span><span>vue</span>\n<span>&lt;template>\n  &lt;div>\n    Mr.Hope &lt;span>{{ message }}&lt;/span>\n  &lt;/div>\n&lt;/template>\n&lt;script>\nexport default {\n  data: () => ({ message: \"十分帅\" }),\n};\n&lt;/script>\n&lt;style>\n.box span {\n  color: red;\n}\n&lt;/style></span>\n<span>```</span></span>\n\n:::\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div></details>\n\n          <div\n            id=\"code-demo-2869b0e2\"\n           \n  \n data-title=\"%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%20Demo\"\n\n            data-code=\"%7B%22md%22%3A%22%23%20%E6%A0%87%E9%A2%98%5Cn%5Cn%E5%8D%81%E5%88%86%E5%B8%85%5Cn%22%2C%22ts%22%3A%22const%20message%3A%20string%20%3D%20%5C%22Mr.Hope%5C%22%3B%5Cn%5Cndocument.querySelector(%5C%22h1%5C%22).innerHTML%20%3D%20message%3B%5Cn%22%2C%22scss%22%3A%22h1%20%7B%5Cn%20%20font-style%3A%20italic%3B%5Cn%5Cn%20%20%2B%20p%20%7B%5Cn%20%20%20%20color%3A%20red%3B%5Cn%20%20%7D%5Cn%7D%5Cn%22%7D\"\n          >\n              \n              <div>\n                <div>\n<div><pre><code><span><span>#</span> 标题</span>\n\n十分帅\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code><span>const</span> message<span>:</span> <span>string</span> <span>=</span> <span>\"Mr.Hope\"</span><span>;</span>\n\ndocument<span>.</span><span>querySelector</span><span>(</span><span>\"h1\"</span><span>)</span><span>.</span>innerHTML <span>=</span> message<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code><span>h1 </span><span>{</span>\n  <span>font-style</span><span>:</span> italic<span>;</span>\n\n  <span>+ p </span><span>{</span>\n    <span>color</span><span>:</span> red<span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div>\n            </div>\n          </div>\n          \n        </div>\n<details><summary>代码</summary>\n<div><pre><code>::: demo 一个普通 Demo\n\n<span><span>```</span><span>md</span>\n<span><span><span>#</span> 标题</span>\n\n十分帅</span>\n<span>```</span></span>\n\n<span><span>```</span><span>ts</span>\n<span><span>const</span> message<span>:</span> <span>string</span> <span>=</span> <span>\"Mr.Hope\"</span><span>;</span>\n\ndocument<span>.</span><span>querySelector</span><span>(</span><span>\"h1\"</span><span>)</span><span>.</span>innerHTML <span>=</span> message<span>;</span></span>\n<span>```</span></span>\n\n<span><span>```</span><span>scss</span>\n<span><span>h1 </span><span>{</span>\n  <span>font-style</span><span>:</span> italic<span>;</span>\n\n  <span>+ p </span><span>{</span>\n    <span>color</span><span>:</span> red<span>;</span>\n  <span>}</span>\n<span>}</span></span>\n<span>```</span></span>\n\n:::\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/zh/guide/markdown/demo/\" target=\"_blank\" rel=\"noopener noreferrer\">点击查看</a></li>\n</ul>\n<h3 id=\"幻灯片\"> 幻灯片</h3>\n<i>Not supported content</i><details><summary>代码</summary>\n<div><pre><code>@slidestart\n\n<span><span>##</span> 幻灯片 1</span>\n\n一个有文字和 <span>[<span>链接</span>](<span>https://mrhope.site</span>)</span> 的段落\n\n<span>---</span>\n\n<span><span>##</span> 幻灯片 2</span>\n\n<span>-</span> 列表 1\n<span>-</span> 列表 2\n\n<span>---</span>\n\n<span><span>##</span> 幻灯片 3.1</span>\n\n<span><span>```</span><span>js</span>\n<span><span>const</span> a <span>=</span> <span>1</span><span>;</span></span>\n<span>```</span></span>\n\n--\n\n<span><span>##</span> 幻灯片 3.2</span>\n\n$$\nJ(\\theta_0,\\theta_1) = \\sum_{i=0}\n$$\n\n@slideend\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/zh/guide/markdown/presentation/\" target=\"_blank\" rel=\"noopener noreferrer\">点击查看</a></li>\n</ul>\n<h2 id=\"其他语法\"> 其他语法</h2>\n<div><p>自定义标题</p>\n<p>信息容器</p>\n</div>\n<div><p>自定义标题</p>\n<p>提示容器</p>\n</div>\n<div><p>自定义标题</p>\n<p>警告容器</p>\n</div>\n<div><p>自定义标题</p>\n<p>危险容器</p>\n</div>\n<details><summary>自定义标题</summary>\n<p>详情容器</p>\n</details>\n<details><summary>代码</summary>\n<div><pre><code>::: info 自定义标题\n\n信息容器\n\n:::\n\n::: tip 自定义标题\n\n提示容器\n\n:::\n\n::: warning 自定义标题\n\n警告容器\n\n:::\n\n::: danger 自定义标题\n\n危险容器\n\n:::\n\n::: details 自定义标题\n\n详情容器\n\n:::\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div></details>\n<hr>\n<section>\n<ol>\n<li id=\"footnote1\"><p>这是脚注内容 </p>\n</li>\n</ol>\n</section>\n",
      "date_published": "2021-12-21T05:46:37.000Z",
      "date_modified": "2021-12-21T05:46:37.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "使用指南"
      ]
    },
    {
      "title": "页面配置",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/guide/page/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/guide/page/",
      "content_html": "<h2 id=\"页面信息\"> 页面信息</h2>\n<p>你可以在 Markdown 的 Frontmatter 中设置页面信息。</p>\n<ul>\n<li>\n<p>作者设置为 Ms.Hope。</p>\n</li>\n<li>\n<p>写作时间应为 2020 年 1 月 1 日</p>\n</li>\n<li>\n<p>分类为 “使用指南”</p>\n</li>\n<li>\n<p>标签为 “页面配置” 和 “使用指南”</p>\n</li>\n</ul>\n<h2 id=\"页面内容\"> 页面内容</h2>\n<p>你可以自由在这里书写你的 Markdown。</p>\n<div><p>提示</p>\n<ul>\n<li>\n<p>Markdown 文件夹的图片请使用相对链接 <code>./</code> 进行引用。</p>\n</li>\n<li>\n<p><code>.vuepress/public</code> 文件夹的图片，请使用绝对链接 <code>/</code> 进行引用</p>\n</li>\n</ul>\n</div>\n<p>主题包含了一个自定义徽章章可以使用:</p>\n<blockquote>\n<p>文字结尾应该有深蓝色的 徽章文字 徽章。 <i>Not supported content</i></p>\n</blockquote>\n<h2 id=\"页面结构\"> 页面结构</h2>\n<p>此页面应当包含：</p>\n<ul>\n<li>返回顶部按钮</li>\n<li>路径导航</li>\n<li>评论</li>\n<li>页脚</li>\n</ul>\n",
      "date_published": "2020-01-01T00:00:00.000Z",
      "date_modified": "2021-12-21T05:46:37.000Z",
      "authors": [
        {
          "name": "Ms.Hope"
        }
      ],
      "tags": [
        "使用指南"
      ]
    },
    {
      "title": "指南",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/guide/test/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/guide/test/",
      "content_html": "<p>不是使用自动生成侧边栏，而是使用。自定以侧边栏。</p>\n<p>https://vuepress-theme-hope.github.io/zh/guide/layout/sidebar/#%E4%BE%A7%E8%BE%B9%E6%A0%8F%E5%88%86%E7%BB%84</p>\n<h2 id=\"一、本站知识阅览\"> 一、本站知识阅览</h2>\n<h3 id=\"_1-多撒多\"> 1. 多撒多</h3>\n<h3 id=\"_2-fdsa\"> 2. fdsa</h3>\n<h2 id=\"二、学习路线参\"> 二、学习路线参</h2>\n<p>考\n范德萨</p>\n<h2 id=\"三、java\"> 三、Java</h2>\n<p>德萨</p>\n",
      "date_published": "2021-12-21T05:46:37.000Z",
      "date_modified": "2021-12-21T05:46:37.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "没有条件创造条件Condition",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/java/Condition/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/java/Condition/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n<p>https://blog.csdn.net/a1439775520/article/details/98471610</p>\n<p>Condition 是为了调换 Object 中的 wait()\n和notify().</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">API</th>\n<th style=\"text-align:center\">Object</th>\n<th style=\"text-align:center\">Condition</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">等待</td>\n<td style=\"text-align:center\">wait()</td>\n<td style=\"text-align:center\">wait()</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">通知</td>\n<td style=\"text-align:center\">notify()</td>\n<td style=\"text-align:center\">signal()</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">通知所有</td>\n<td style=\"text-align:center\">notifyAll()</td>\n<td style=\"text-align:center\">signalAll()</td>\n</tr>\n</tbody>\n</table>\n<p><strong>wait是会释放锁</strong></p>\n<h2 id=\"相同点\"> 相同点</h2>\n<ul>\n<li>都必须被包裹在同步代码块中，即加锁</li>\n<li>当调用wait都会释放锁</li>\n</ul>\n<h2 id=\"不同点\"> 不同点</h2>\n<ul>\n<li>Object 依赖 synchronized 锁</li>\n<li>Condition 依赖 Lock 锁</li>\n</ul>\n<h2 id=\"objectwait\"> ObjectWait</h2>\n<div><p>运行结果</p>\n<ul>\n<li>当前线程进入线程一</li>\n<li>当前线程进入线程二</li>\n<li>当前线程释放main</li>\n<li>当前线程释放main</li>\n<li>当前线程退出线程一</li>\n<li>当前线程退出线程二</li>\n</ul>\n</div>\n<div><pre><code><span>/**\n * @author liuxin\n * 2022/1/5 12:24 上午\n */</span>\n<span>public</span> <span>class</span> <span>ObjectWait</span> <span>{</span>\n\n    <span>public</span> <span>synchronized</span> <span>void</span> <span>objWait</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"当前线程进入\"</span> <span>+</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>wait</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"当前线程退出\"</span> <span>+</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>synchronized</span> <span>void</span> <span>objNotify</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"当前线程释放\"</span> <span>+</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>notify</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>ObjectWait</span> objectWait <span>=</span> <span>new</span> <span>ObjectWait</span><span>(</span><span>)</span><span>;</span>\n        <span>// 使用synchronized修饰方法，就是锁的是当前这个示例synchronized(this)</span>\n        <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>\n            <span>try</span> <span>{</span>\n                <span>// 当前进入等待，然后释放锁。wait会释放锁</span>\n                objectWait<span>.</span><span>objWait</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n                e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>,</span><span>\"线程一\"</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n\n        <span>// 使用synchronized修饰方法，就是锁的是当前这个示例synchronized(this)</span>\n        <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>\n            <span>try</span> <span>{</span>\n                <span>// 当前进入等待，然后释放锁。wait会释放锁</span>\n                objectWait<span>.</span><span>objWait</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n                e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>,</span><span>\"线程二\"</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>1000L</span><span>)</span><span>;</span>\n        <span>// 释放锁后才会放行</span>\n        objectWait<span>.</span><span>objNotify</span><span>(</span><span>)</span><span>;</span>\n        <span>// 释放锁后才会放行</span>\n        objectWait<span>.</span><span>objNotify</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><h2 id=\"lockwait\"> LockWait</h2>\n<div><p>运行结果</p>\n<ul>\n<li>当前线程进入线程一</li>\n<li>当前线程进入线程二</li>\n<li>当前线程释放main</li>\n<li>当前线程释放main</li>\n<li>当前线程退出线程一</li>\n<li>当前线程退出线程二</li>\n</ul>\n</div>\n<div><pre><code><span>/**\n * @author liuxin\n * 2022/1/5 24:24 上午\n */</span>\n<span>public</span> <span>class</span> <span>LockWait</span> <span>{</span>\n\n    <span>private</span> <span>ReentrantLock</span> lock <span>=</span> <span>new</span> <span>ReentrantLock</span><span>(</span><span>)</span><span>;</span>\n\n    <span>private</span> <span>Condition</span> condition <span>=</span> lock<span>.</span><span>newCondition</span><span>(</span><span>)</span><span>;</span>\n\n    <span>public</span> <span>void</span> <span>lockWait</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        lock<span>.</span><span>lock</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"当前线程进入\"</span> <span>+</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        condition<span>.</span><span>await</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"当前线程退出\"</span> <span>+</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        lock<span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>lockNotify</span><span>(</span><span>)</span> <span>{</span>\n        lock<span>.</span><span>lock</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"当前线程释放\"</span> <span>+</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        condition<span>.</span><span>signal</span><span>(</span><span>)</span><span>;</span>\n        lock<span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>LockWait</span> lockWait <span>=</span> <span>new</span> <span>LockWait</span><span>(</span><span>)</span><span>;</span>\n        <span>// lock.lock()  线程一: 获取锁,然后wait之后，进入释放锁,然后进入到等待队列</span>\n        <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>\n            <span>try</span> <span>{</span>\n                <span>// 当前进入等待，然后释放锁。</span>\n                lockWait<span>.</span><span>lockWait</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n                e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>,</span> <span>\"线程一\"</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        <span>// lock.lock()  当前线程二获取锁,然后wait之后，进入释放锁,然后进入到等待队列</span>\n        <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>\n            <span>try</span> <span>{</span>\n                <span>// 当前进入等待，然后释放锁。</span>\n                lockWait<span>.</span><span>lockWait</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n                e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>,</span><span>\"线程二\"</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n\n        <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>1000L</span><span>)</span><span>;</span>\n        <span>// 调用第一次，会唤醒线程一，继续向下执行</span>\n        lockWait<span>.</span><span>lockNotify</span><span>(</span><span>)</span><span>;</span>\n        <span>// 调用第二次，会唤醒线程二，继续向下执行</span>\n        lockWait<span>.</span><span>lockNotify</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br></div></div>",
      "image": "https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png",
      "date_published": "2022-01-04T14:58:20.000Z",
      "date_modified": "2022-01-04T17:14:21.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "循环锁屏障 CyclicBarrier",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/java/CyclicBarrier/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/java/CyclicBarrier/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n<p>举个例子,五个人开黑,少一个人就开不了。</p>\n<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>Throwable</span> <span>{</span>\n        <span>CyclicBarrier</span> cb <span>=</span> <span>new</span> <span>CyclicBarrier</span><span>(</span><span>5</span><span>,</span> <span>new</span> <span>Runnable</span><span>(</span><span>)</span> <span>{</span>\n            <span>@Override</span>\n            <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"人都到齐了,游戏开始进入峡谷\"</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n        <span>Runnable</span> player <span>=</span> <span>new</span> <span>Runnable</span><span>(</span><span>)</span> <span>{</span>\n            <span>@Override</span>\n            <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\"已经进来了\"</span><span>)</span><span>;</span>\n                <span>try</span> <span>{</span>\n                    cb<span>.</span><span>await</span><span>(</span><span>)</span><span>;</span>\n                <span>}</span> <span>catch</span> <span>(</span><span>Throwable</span> e<span>)</span> <span>{</span>\n                    e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span><span>;</span>\n        <span>new</span> <span>Thread</span><span>(</span>player<span>,</span> <span>\"上路程咬金\"</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        <span>new</span> <span>Thread</span><span>(</span>player<span>,</span> <span>\"中路安琪拉\"</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        <span>new</span> <span>Thread</span><span>(</span>player<span>,</span> <span>\"下路小鲁班\"</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        <span>new</span> <span>Thread</span><span>(</span>player<span>,</span> <span>\"辅助李元芳\"</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        <span>new</span> <span>Thread</span><span>(</span>player<span>,</span> <span>\"打野孙悟空\"</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div>",
      "image": "https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png",
      "date_published": "2021-12-25T09:26:08.000Z",
      "date_modified": "2022-01-04T14:58:20.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "倒计锁 CountDownLatch",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/java/CountDownLatch/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/java/CountDownLatch/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n<p>上文我们知道了 <code>Semaphore</code> 信号量的用法，那么这一篇基本不用学了。因为原理基本上是一样的。\n但是用法不太一样。</p>\n<p><code>Semaphore</code> 是获取到资源就执行，获取不到资源就等待。\n<code>CountDownLatch</code> 跟 <code>Semaphore</code> 正好相反。</p>\n<p>CountDownLatch#await() 可以理解为获取不到资源，就等待。这么说不太好理解，直接看源码吧。</p>\n<div><pre><code><span>private</span> <span>static</span> <span>final</span> <span>class</span> <span>Sync</span> <span>extends</span> <span>AbstractQueuedSynchronizer</span> <span>{</span>\n        <span>private</span> <span>static</span> <span>final</span> <span>long</span> serialVersionUID <span>=</span> <span>4982264981922014374L</span><span>;</span>\n\n        <span>Sync</span><span>(</span><span>int</span> count<span>)</span> <span>{</span>\n            <span>setState</span><span>(</span>count<span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>int</span> <span>getCount</span><span>(</span><span>)</span> <span>{</span>\n            <span>return</span> <span>getState</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>protected</span> <span>int</span> <span>tryAcquireShared</span><span>(</span><span>int</span> acquires<span>)</span> <span>{</span>\n            <span>// 获取资源,await就是调用这个方法。当tryReleaseShared没有进行扣减之前。</span>\n            <span>// 这里一直都是-1。而-1就是获取不到资源进行等待</span>\n            <span>return</span> <span>(</span><span>getState</span><span>(</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span>?</span> <span>1</span> <span>:</span> <span>-</span><span>1</span><span>;</span>\n        <span>}</span>\n\n        <span>protected</span> <span>boolean</span> <span>tryReleaseShared</span><span>(</span><span>int</span> releases<span>)</span> <span>{</span>\n            <span>// countDown就调用这个方法,进行扣减1</span>\n            <span>for</span> <span>(</span><span>;</span><span>;</span><span>)</span> <span>{</span>\n                <span>int</span> c <span>=</span> <span>getState</span><span>(</span><span>)</span><span>;</span>\n                <span>if</span> <span>(</span>c <span>==</span> <span>0</span><span>)</span>\n                    <span>return</span> <span>false</span><span>;</span>\n                <span>int</span> nextc <span>=</span> c<span>-</span><span>1</span><span>;</span>\n                <span>if</span> <span>(</span><span>compareAndSetState</span><span>(</span>c<span>,</span> nextc<span>)</span><span>)</span>\n                    <span>return</span> nextc <span>==</span> <span>0</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><h2 id=\"常用用法\"> 常用用法</h2>\n<p><strong>注意:</strong>\n<mark>CountDownLatch不可重复使用，当计数器减少到0之后，就废了，无法继续使用了。</mark></p>\n<p>CountDownLatch是在java1.5被引入的，跟它一起被引入的并发工具类还有CyclicBarrier、Semaphore、ConcurrentHashMap和BlockingQueue，它们都存在于java.util.concurrent包下。CountDownLatch这个类能够使一个线程等待其他线程完成各自的工作后再执行。例如，应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行。</p>\n<p>CountDownLatch是通过一个计数器来实现的，计数器的初始值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就会减1。当计数器值到达0时，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务。</p>\n<p><img src=\"http://incdn1.b0.upaiyun.com/2015/04/f65cc83b7b4664916fad5d1398a36005.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"countdownlatch-存在的意义\"> CountDownLatch 存在的意义</h2>\n<p>让主线程阻塞，等待线程结束后在运行</p>\n<p>直译过来就是倒计数(CountDown)门闩(Latch)。倒计数不用说，门闩的意思顾名思义就是阻止前进。在这里就是指 CountDownLatch.await() 方法在倒计数为0之前会阻塞当前线程。</p>\n<p><strong>实现</strong></p>\n<p>CountDownLatch内部维护一个最大线程数，当每个线程执行结束，就调用\n<code>latch.countDown();</code> 将数量减 1 ,当数量为0的时候，就放弃阻塞主线程，也就是放弃 <code>countDownLatch.await()</code>阻塞的线程</p>\n<h2 id=\"代码解释\"> 代码解释</h2>\n<div><pre><code> <span>public</span> <span>void</span> <span>test</span><span>(</span><span>)</span><span>throws</span> <span>Exception</span><span>{</span>\n        <span>int</span> pagecount<span>=</span><span>3</span><span>;</span>\n        <span>ExecutorService</span> executors <span>=</span> <span>Executors</span><span>.</span><span>newFixedThreadPool</span><span>(</span>pagecount<span>)</span><span>;</span>\n        <span>CountDownLatch</span> countDownLatch <span>=</span> <span>new</span> <span>CountDownLatch</span><span>(</span>pagecount<span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> pagecount<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            <span>// 启动线程抓取</span>\n            executors\n                    <span>.</span><span>execute</span><span>(</span><span>new</span> <span>Runnable</span><span>(</span><span>)</span> <span>{</span>\n                        <span>@Override</span>\n                        <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n                            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n                            countDownLatch<span>.</span><span>countDown</span><span>(</span><span>)</span><span>;</span>\n                        <span>}</span>\n                    <span>}</span><span>)</span><span>;</span>\n        <span>}</span>\n        countDownLatch<span>.</span><span>await</span><span>(</span><span>)</span><span>;</span><span>//主线程阻塞在这里，等到线程结束,</span>\n        <span>//然后关闭线程池</span>\n        executors<span>.</span><span>shutdown</span><span>(</span><span>)</span><span>;</span>\n\n    <span>}</span>\n\n\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h2 id=\"最大缺点\"> 最大缺点</h2>\n<p>通过前面源码我们发现, <code>CountDownLatch</code> 只有减没有加，所以导致了一个最大的缺点就是\n只能使用一次,当扣减为0的时候,那么就不能在继续使用了。所以就要引入 <code>CyclicBarrier</code>了。</p>\n",
      "image": "https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png",
      "date_published": "2021-12-25T09:26:08.000Z",
      "date_modified": "2022-01-04T14:58:20.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "没有规矩不成方圆",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/design/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/design/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/learn_1598165820000.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1598165820000.png",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-03-24T14:34:44.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "再也不怕被HashMap欺负了",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/java/HashMap/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/java/HashMap/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/learn_1596467333000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n<blockquote>\n<p>HashMap是我们在日常开发中经常使用的一个结合类型,同时也是面试时候最好提问的集合类型,在这里进行整理\n一起学习,进步。</p>\n</blockquote>\n<h2 id=\"一、数据结构\"> 一、数据结构</h2>\n<p>先说两种数据结构, 不用怕, 如果要对付面试只要了解就行了。不用手写实现, 同时也因为已经有人帮我写好,所以开发中我们只要用就行。</p>\n<h3 id=\"_1-二叉树\"> 1. 二叉树</h3>\n<p><a href=\"https://www.cs.usfca.edu/~galles/visualization/BST.html\" target=\"_blank\" rel=\"noopener noreferrer\">动画展示二叉树</a></p>\n<p>本来是一个相对平衡的二叉树(当前数据 &gt; 根节点 ？ 从右边插入 : 从左边插入)。\n<img src=\"https://img.springlearn.cn/blog/learn_1596522740000.png\" alt=\"\" loading=\"lazy\">\n但是由于在使用的过程中的删除,慢慢的变成了一个瘸腿。此时树的高度越高,数据越多,导致查询叶子\n的耗时越长。\n<img src=\"https://img.springlearn.cn/blog/learn_1596522608000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>于是乎人们在这个数据结构的基础上,研究出新的结构,就是下面的红黑树。</p>\n<h3 id=\"_2-红黑树\"> 2. 红黑树</h3>\n<p><a href=\"https://www.cs.usfca.edu/~galles/visualization/RedBlack.html\" target=\"_blank\" rel=\"noopener noreferrer\">动画展示红黑树</a></p>\n<p>依次插入7 5 3 2 4 6 8 9 12 11 17 13 14 16</p>\n<p>很明显我们可以看出红黑树比二叉树相对比较平衡。\n<img src=\"https://img.springlearn.cn/blog/learn_1596523217000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>在对比一下二叉树</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596523318000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>好了关于数据结构的知识就说这么多,可以通过图就能知道这两种数据结构情况了。因为数据结构不是我们本篇研究的点。\n所以就提这么多。</p>\n<h2 id=\"二、源码分析\"> 二、源码分析</h2>\n<p>HashMap 实现了 Map 接口,JDK1.7由 数组 + 链表实现， 1.8后由 数组 + 链表 + 红黑树实现</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596527068000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_1-put的源码分析\"> 1. put的源码分析</h3>\n<p>HashMap中声明的常量信息,注意看。下面源码中会提到。</p>\n<table>\n<thead>\n<tr>\n<th>变量</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>DEFAULT_INITIAL_CAPACITY</td>\n<td>默认的初始容量</td>\n</tr>\n<tr>\n<td>MAXIMUM_CAPACITY</td>\n<td>最大的容量2^30</td>\n</tr>\n<tr>\n<td>DEFAULT_LOAD_FACTOR</td>\n<td>容器个数 size &gt; 负载因子 * 数组长度  就需要进行扩容</td>\n</tr>\n<tr>\n<td>TREEIFY_THRESHOLD</td>\n<td>如果数组中某一个链表 &gt;= 8 需要转化为红黑树</td>\n</tr>\n<tr>\n<td>UNTREEIFY_THRESHOLD</td>\n<td>如果数组中某一个链表转化为红黑树后的节点 &lt; 6 的时候 继续转为 链表</td>\n</tr>\n</tbody>\n</table>\n<div><pre><code> final V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;\n        if ((tab = table) == null || (n = tab.length) == 0)\n            n = (tab = resize()).length;\n        if ((p = tab[i = (n - 1) &amp; hash]) == null)\n            tab[i] = newNode(hash, key, value, null);\n        else {\n            Node&lt;K,V&gt; e; K k;\n            if (p.hash == hash &amp;&amp;\n                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))\n                e = p;\n            //判断是否是树    \n            else if (p instanceof TreeNode)\n                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);\n            //继续用链表    \n            else {\n                // 循环链表\n                for (int binCount = 0; ; ++binCount) {\n                    if ((e = p.next) == null) {\n                        // 新建节点存储\n                        p.next = newNode(hash, key, value, null);\n                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                            //大于树的阀值,就转换为树结构\n                            treeifyBin(tab, hash);\n                        break;\n                    }\n                    if (e.hash == hash &amp;&amp;\n                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))\n                        break;\n                    p = e;\n                }\n            }\n            if (e != null) { // existing mapping for key\n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value;\n                afterNodeAccess(e);\n                return oldValue;\n            }\n        }\n        ++modCount;\n        if (++size &gt; threshold)\n            resize();\n        afterNodeInsertion(evict);\n        return null;\n    }\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br></div></div><p>从上面源码中我们可以看到在put时候会判断是链表结构还是红黑树。如果是树就用树put\n<code>((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</code>。</p>\n<p>如果是链表就循环列表插入数据,如果发现列表长度大于树的阀值就讲链表转换为树</p>\n<h3 id=\"_2-put流程赘述\"> 2. put流程赘述</h3>\n<ol>\n<li>判断 table 是否为 null。为 null 则新建一个 table 数组</li>\n<li>调用 hash 获取 该 key 的 hash 值\n<img src=\"https://img.springlearn.cn/blog/learn_1596528441000.png\" alt=\"\" loading=\"lazy\"></li>\n<li>如果发现有数据,且还是树结构就调用树的put方法</li>\n<li>如果发现有数据,是链表的结构就循环插入尾部,如果发现达到了要转换树的长度,就转成红黑树</li>\n<li>发现key冲突直接新值替换旧值,并且break;\n<img src=\"https://img.springlearn.cn/blog/learn_1596528854000.png\" alt=\"\" loading=\"lazy\"></li>\n</ol>\n<h2 id=\"三、面试知识扩展\"> 三、面试知识扩展</h2>\n<p>前面我们知道了HashMap在1.8之后的优化。这里我们最后再说一个面试题。\n问: 1.7时候hashmap在扩容时候回出现死链的问题。问题原因是什么?  已经出现的场景是什么?</p>\n<p>首先看下扩容方法 <code>resize</code>\n<img src=\"https://img.springlearn.cn/blog/learn_1596530770000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_1-优化1\"> 1. 优化1</h3>\n<p>jdk1.8在对链表进行扩容时候时候不是直接都去hash了。而是\n<code>(e.hash &amp; oldCap) == 0</code> 下标不变\n<code>(e.hash &amp; oldCap) != 0</code> 下标 = 原下标 + oldCap</p>\n<h3 id=\"_2-出现的场景\"> 2. 出现的场景</h3>\n<p>多线程操作扩容</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596531864000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>最后求关注,求订阅,谢谢你的阅读!</p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1596467333000.png",
      "date_published": "2022-01-04T14:58:20.000Z",
      "date_modified": "2022-01-04T14:58:20.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "项目主页",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/home/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/home/",
      "content_html": "<p>这是普通主页的案例。你可以在这里放置你的主体内容。</p>\n<p>想要使用此布局，你需要在页面 front matter 中设置 <code>home: true</code>。</p>\n<p>配置项的相关说明详见 <a href=\"https://vuepress-theme-hope.github.io/zh/guide/layout/home/\" target=\"_blank\" rel=\"noopener noreferrer\">项目主页配置</a>。</p>\n",
      "date_published": "2021-12-21T05:46:37.000Z",
      "date_modified": "2021-12-21T05:46:37.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Java异常体系",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/java/Java%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/java/Java%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/learn_1589293715000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n<p>知己知彼方能百战不殆,在小编初学Java时候特别怕程序报异常,经常会因为异常不知所措,相信这个问题应该是所有\n初学者都会有的心理感受;如果你也有这种感受,那么只有一种解决方法:\n迎难而上,攻克Java异常体系,长痛不如短痛,只要清楚了Java的异常体系,就不会再有这种感受了。下面跟着小编来窥探Java的异常体系吧。</p>\n<h1 id=\"一、java异常体系其实很简单\"> 一、Java异常体系其实很简单</h1>\n<p>其实Java的异常体系是非常简单的,简单到只要你看过本文就能明白百分之八九十的样子。当你清楚了Java的异常体系\n那么在遇到项目执行异常的时候,基本看报错的异常就大概明白问题出在哪里,遇到的错误多了,就成长了,处理的问题就是\n你未来在技术路上所积累的财富。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589294764000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>在Java的异常体系中 <code>Throwable</code> 我们可以理解为是一个根异常,即所有的异常都是它的子类</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589295509000.png\" alt=\"\" loading=\"lazy\"></p>\n<h1 id=\"二、error\"> 二、Error</h1>\n<p>前面我们说了Java的异常体系中 <code>Throwable</code> 可以理解是一个根异常,那么 <code>Error</code> 就是这个根节点的一个子节点。\n<code>Error</code> 类对象由 <code>Java</code> 虚拟机生成并抛出，大多数错误与代码编写者所执行的操作无关。程序无法处理的异常，一般伴随者jvm虚拟机停止，或者断电之类\n这种问题，是无法通过程序来解决的。</p>\n<p><strong>这种异常基本很少,如果遇到也不要慌,跟你的业务逻辑没有关系,顶多是Java代码写的有问题,只要不是业务问题其实大多都能先通过重启解决;\n但是假如项目还未上线,只是在开发过程中出现这种问题一定要弄清楚原因,是那一部分代码编写异常导致的,否则上线可能有重大隐患</strong></p>\n<p><strong>经验教学:</strong></p>\n<ol>\n<li>如果是在项目系统过程中遇到这种问题,可能是因为Jar包冲突导致的。</li>\n<li>如果是在项目运行过程中遇到这种问题,可能是因为对象创建过多没有释放,导致堆栈溢出。这个时候就要看GC是否频繁,然后对堆栈日志进行分析,看存在最多的对象是哪一个,然后分析代码解决。</li>\n</ol>\n<h1 id=\"三、exception\"> 三、Exception</h1>\n<p><code>Exception</code> 异常时我们平时在开发中遇到最多，其实 <code>Exception</code> 也分为两种即:</p>\n<ol>\n<li><code>checkException</code> 编译异常，这种异常，是哪些没有遵守java语言规则，容易看出和解决的</li>\n<li><code>uncheckException</code> 运行异常，运行异常，具有不确定性，往往难以排查，包括处理逻辑问题。</li>\n</ol>\n<p>然而 <code>checkException</code> 和 <code>uncheckException</code> 其实只是一个概念,并没有对应的 <code>Java异常类</code>。我们基本可以忽略\n<code>checkException</code> 因为这种异常基本现在的编译器都会给我们做了，我们在写代码时候就会实时的给我提示错误了。我们\n只用关心 <code>uncheckException</code>即可。</p>\n<p><strong>uncheckException</strong></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589297073000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><code>RuntimeException</code> + <code>Error</code> 和其子类都是属于 <code>uncheckException</code></p>\n<p>前面我们已经对 <code>Error</code> 做了说明，现在就主要来看下 <code>RuntimeException</code>。 <code>RuntimeException</code> 从名字来看就是\n运行异常,所谓运行异常就是可能在程序运行过程中发生的异常,这种异常一般是可以通过代码逻辑进行处理的。\n我们举例一个例子,我们都知道0不能作为除数。但是假如在下面这个代码中</p>\n<div><pre><code>public class Tester {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        System.out.print(&quot;请输入被除数a:&quot;);\n        int a = sc.nextInt();\n        System.out.print(&quot;请输入除数b:&quot;);\n        int b = sc.nextInt();\n        System.out.println(&quot;a/b=&quot; + a / b);\n    }\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>当输入a=8,b=2,那么结果就是4。</p>\n<p><img src=\"https://i02piccdn.sogoucdn.com/8206a4441e0386c3\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>假如我们输入b=0呢?</strong></p>\n<p>学过数学都知道0不能做除数,程序也不运行你这么输入,但是却不能阻止你,只能通过报错的方式来告诉你。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589298143000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>那么我们就要对这个异常进行处理,当发现有这个异常就在控制台来提醒用户。那么代码就会变成这样</p>\n<div><pre><code>public class Tester {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        System.out.print(&quot;请输入被除数a:&quot;);\n        int a = sc.nextInt();\n        System.out.print(&quot;请输入除数b:&quot;);\n        int b = sc.nextInt();\n        try {\n            System.out.println(&quot;a/b=&quot; + a / b);\n        } catch (ArithmeticException ate) {\n            //对算术异常进行捕捉\n            System.err.println(&quot;0不能作为除数,请输入不为0的任意数&quot;);\n        }\n    }\n}\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>当出现算术异常直接提示: &quot;0不能作为除数,请输入不为0的任意数&quot;\n<img src=\"https://img.springlearn.cn/blog/learn_1589298261000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>那么像这种程序中无可避免会出现,且又能通过逻辑来处理的异常就是运行异常。运行异常一般都可以正常运行,只是在特定情况下会导致异常发生。\n像这面这个例子,我们只要看到 <code>ArithmeticException</code> 就知道是算术异常。所以只要我们对运行异常类有一个认识，其实就能解决大多数的程序问题了。\n下面我们来看下运行异常都要有哪些类把。</p>\n<p><img src=\"https://i03piccdn.sogoucdn.com/f960e6a461d218d2\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>只要对下面运行异常类进行熟悉了,基本就清楚掌握了Java的异常体系了</strong></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589299119000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589299523000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>以上就是常见的运行异常类,当然Java中还有很多不常见的异常类。剩下的我们就可以在日常工作中去学习了。</p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1589293715000.png",
      "date_published": "2021-12-25T09:26:08.000Z",
      "date_modified": "2021-12-25T09:26:08.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "读写锁 ReadWriteLock",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/java/ReadWriteLock/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/java/ReadWriteLock/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n",
      "image": "https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png",
      "date_published": "2021-12-25T09:26:08.000Z",
      "date_modified": "2022-01-04T14:58:20.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "重入锁 ReentrantLock",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/java/ReentrantLock/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/java/ReentrantLock/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n",
      "image": "https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png",
      "date_published": "2021-12-25T09:26:08.000Z",
      "date_modified": "2022-01-04T14:58:20.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Java管理扩展",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/java/JMX/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/java/JMX/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/learn_1590919227000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n<p><strong>JMX（Java Management Extensions，即Java管理扩展）是一个为应用程序、设备、系统等植入管理功能的框架。JMX可以跨越一系列异构操作系统平台、系统体系结构和网络传输协议，灵活的开发无缝集成的系统、网络和服务管理应用。</strong></p>\n<p>前面是对JMX的介绍，那么JMX在我们日常的开发过程中，有什么实际的意义呢? 相信很多做Java开发的同学都使用过JDK自带的 jconsole 或者 jvisualvm 监控过JVM的运行情况，但不知道有没有留意过它们会有一个MBean的功能/标签，通过MBean可以看到在JVM中运行的组件的一些属性和操作。下面小编就通过一个SpringBoot应用来一探究竟。并教会你如何自定义扩展。</p>\n<h2 id=\"一、实际意义\"> 一、实际意义</h2>\n<h3 id=\"_1-启动一个springboot应用\"> 1. 启动一个SpringBoot应用</h3>\n<p>下面我们以SpringBoot应用为例子，启动一个SpringBoot项目。端口是 <code>8080</code></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1590921574000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_2-命令行打开jconsole\"> 2. 命令行打开Jconsole</h3>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1590921682000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_3-连接前面的应用\"> 3. 连接前面的应用</h3>\n<p><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlly1gfbtkkzi1bj30p00ku761.jpg\" alt=\"image-20200531184151871\" loading=\"lazy\"></p>\n<p>选中MBean标签,然后可以看到一个SpringApplication的类。shutdown是服务下线。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1590921783000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>当我们点击了shutdown方法后,应用就会自动的关闭了。导致Jconsole连接丢失\n<img src=\"https://tva1.sinaimg.cn/large/007S8ZIlly1gfbtpwfbbqj30oy0i2gof.jpg\" alt=\"image-20200531184702204\" loading=\"lazy\"></p>\n<p>getProperty方法是获取应用中的配置信息。如图我们获取redis的相关信息。可以看到返回值是Spring应用中我们定义的值\n6379</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1590921918000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlly1gfbtoo8x1yj30lc07imy6.jpg\" alt=\"image-20200531184553346\" loading=\"lazy\"></p>\n<p>那么其实这个能力就是利用JMX提供的接口来实现的。下面我们通过分析SpringBoot中的源码来看他是如何实现的。</p>\n<hr>\n<h2 id=\"二、源码追踪看springboot应用如何实现\"> 二、源码追踪看SpringBoot应用如何实现?</h2>\n<p>我们通过看Jconsole工具,可以看到工具里面的类名叫SpringApplication，目录是admin，于是我们就根据这个推测SpringBoot中的命名,果然我们找到两个实现类。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1590922192000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>1. SpringApplicationAdminMXBean</strong></p>\n<p>这个类就是JMX中的MBean，我们可以简单理解这个里面的方法都是可以通过Jconsole来调用的。\n通过将这个类注册给JMX管理器就能实现在Jconsole中的数据展示。</p>\n<p>首先看<strong>SpringApplicationAdminMXBean</strong></p>\n<div><pre><code><span>public</span> <span>interface</span> <span>SpringApplicationAdminMXBean</span> <span>{</span>\n   <span>//是否可读</span>\n   <span>boolean</span> <span>isReady</span><span>(</span><span>)</span><span>;</span>\n   <span>//是否web应用</span>\n   <span>boolean</span> <span>isEmbeddedWebApplication</span><span>(</span><span>)</span><span>;</span>\n   <span>//获取配置信息</span>\n   <span>String</span> <span>getProperty</span><span>(</span><span>String</span> key<span>)</span><span>;</span>\n   <span>//下线应用</span>\n   <span>void</span> <span>shutdown</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>实现类<strong>SpringApplicationAdmin</strong>,是SpringApplicationAdminMXBeanRegistrar的内部类</p>\n<div><pre><code><span>private</span> <span>class</span> <span>SpringApplicationAdmin</span> <span>implements</span> <span>SpringApplicationAdminMXBean</span> <span>{</span>\n    <span>// 是否可读，当应用还没起来时候这个值是false</span>\n      <span>@Override</span>\n      <span>public</span> <span>boolean</span> <span>isReady</span><span>(</span><span>)</span> <span>{</span>\n         <span>return</span> <span>SpringApplicationAdminMXBeanRegistrar</span><span>.</span><span>this</span><span>.</span>ready<span>;</span>\n      <span>}</span>\n      <span>// 是否是web应用</span>\n      <span>@Override</span>\n      <span>public</span> <span>boolean</span> <span>isEmbeddedWebApplication</span><span>(</span><span>)</span> <span>{</span>\n         <span>return</span> <span>SpringApplicationAdminMXBeanRegistrar</span><span>.</span><span>this</span><span>.</span>embeddedWebApplication<span>;</span>\n      <span>}</span>\n    <span>// 从Spring的配置信息中实时读取值</span>\n      <span>@Override</span>\n      <span>public</span> <span>String</span> <span>getProperty</span><span>(</span><span>String</span> key<span>)</span> <span>{</span>\n         <span>return</span> <span>SpringApplicationAdminMXBeanRegistrar</span><span>.</span><span>this</span><span>.</span>environment<span>.</span><span>getProperty</span><span>(</span>key<span>)</span><span>;</span>\n      <span>}</span>\n    <span>// 关闭Spring应用</span>\n      <span>@Override</span>\n      <span>public</span> <span>void</span> <span>shutdown</span><span>(</span><span>)</span> <span>{</span>\n         logger<span>.</span><span>info</span><span>(</span><span>\"Application shutdown requested.\"</span><span>)</span><span>;</span>\n         <span>SpringApplicationAdminMXBeanRegistrar</span><span>.</span><span>this</span><span>.</span>applicationContext<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n      <span>}</span>\n\n   <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p><strong>2. SpringApplicationAdminMXBeanRegistrar</strong></p>\n<p>提供注册能力。这个类中我们可以知道如何注册JMX以及如何取消注册。下面我看这个类如何利用Spring提供的接口能力,来实现应用下线。及注册到JMX上的吧。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1590922871000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>自动化配置将SpringApplicationAdminMXBeanRegistrar声明成一个Spring中的Bean对象。并配置JMX中的命名及目录。\n<img src=\"https://img.springlearn.cn/blog/learn_1590923451000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_1-applicationcontextaware\"> 1. ApplicationContextAware</h3>\n<p>获得读取上下文能力。在Spring容器中一个bean如何实现了该方法则就可以获取上下文对象。</p>\n<div><pre><code>   @Override\n   public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n      Assert.state(applicationContext instanceof ConfigurableApplicationContext,\n            &quot;ApplicationContext does not implement ConfigurableApplicationContext&quot;);\n      this.applicationContext = (ConfigurableApplicationContext) applicationContext;\n   }\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id=\"_2-genericapplicationlistener\"> 2. GenericApplicationListener</h3>\n<p>获取处理事件的能力,同样在Spring中只要实现该接口,就获取了事件监听的能力,不过具体监听什么事件要自己去判断。大家可以根据例子\n来理解。</p>\n<div><pre><code>  // 根据事件泛型判断是否需要处理，这里判断如果是ApplicationReadyEvent和WebServerInitializedEvent\n  // 事件就处理\n  @Override\n   public boolean supportsEventType(ResolvableType eventType) {\n      Class&lt;?&gt; type = eventType.getRawClass();\n      if (type == null) {\n         return false;\n      }\n      return ApplicationReadyEvent.class.isAssignableFrom(type)\n            || WebServerInitializedEvent.class.isAssignableFrom(type);\n   }\n\n   @Override\n   public boolean supportsSourceType(Class&lt;?&gt; sourceType) {\n      return true;\n   }\n\n   @Override\n   public void onApplicationEvent(ApplicationEvent event) {\n    // 如果Spring已经准备好了,就将this.ready = true;\n      if (event instanceof ApplicationReadyEvent) {\n         onApplicationReadyEvent((ApplicationReadyEvent) event);\n      }\n    // 如果是Web应用,this.embeddedWebApplication = true\n      if (event instanceof WebServerInitializedEvent) {\n         onWebServerInitializedEvent((WebServerInitializedEvent) event);\n      }\n   }\n   //优先级\n   @Override\n   public int getOrder() {\n      return Ordered.HIGHEST_PRECEDENCE;\n   }\n\n   void onApplicationReadyEvent(ApplicationReadyEvent event) {\n      if (this.applicationContext.equals(event.getApplicationContext())) {\n         this.ready = true;\n      }\n   }\n\n   void onWebServerInitializedEvent(WebServerInitializedEvent event) {\n      if (this.applicationContext.equals(event.getApplicationContext())) {\n         this.embeddedWebApplication = true;\n      }\n   }\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br></div></div><h3 id=\"_3-environmentaware\"> 3. EnvironmentAware</h3>\n<p>获取应用配置信息, 和上面一样实现了Aware结尾的接口,都能获取对象的Spring内容的对象实例，然后我们就可以根据该实例,来进行功能扩展。</p>\n<div><pre><code>@Override\n   public void setEnvironment(Environment environment) {\n      this.environment = environment;\n   }\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"_4-initializingbean\"> 4. InitializingBean</h3>\n<p>这里就要着重看了，在初始化时候将MBean注册到JMX上。当然我们可以通过 @PostConstruct注解来声明初始化方法。</p>\n<div><pre><code>@Override\n   public void afterPropertiesSet() throws Exception {\n      MBeanServer server = ManagementFactory.getPlatformMBeanServer();\n      server.registerMBean(new SpringApplicationAdmin(), this.objectName);\n      if (logger.isDebugEnabled()) {\n         logger.debug(&quot;Application Admin MBean registered with name &#39;&quot; + this.objectName + &quot;&#39;&quot;);\n      }\n   }\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id=\"_5-disposablebean\"> 5. DisposableBean</h3>\n<p>应用销毁时候,取消注册。同样我们也可以用@PreDestroy注解来实现</p>\n<div><pre><code>@Override\n   public void destroy() throws Exception {\n      ManagementFactory.getPlatformMBeanServer().unregisterMBean(this.objectName);\n   }\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>通过对SpringBoot应用源码的追踪，我们大概已经明白JMX的实际意义了，并且能自定义一个能提供类似能力的MBean了吧，但是JMX能做的远远不止如此。</p>\n<h2 id=\"三、自定义mbean\"> 三、自定义MBean</h2>\n<p>注意接口名必须是MBean结尾，实现类必须去掉MBean</p>\n<p>如CustomMBean接口对应的实现类必须是Custom。</p>\n<h3 id=\"_1-代码实现\"> 1. 代码实现</h3>\n<div><pre><code><span>@Component</span>\n<span>public</span> <span>class</span> <span>CustomMbeanRegistrar</span> <span>implements</span> <span>ApplicationContextAware</span><span>,</span> <span>InitializingBean</span><span>,</span> <span>DisposableBean</span> <span>{</span>\n    <span>private</span> <span>ConfigurableApplicationContext</span> applicationContext<span>;</span>\n    <span>private</span> <span>ObjectName</span> objectName <span>=</span> <span>new</span> <span>ObjectName</span><span>(</span><span>\"com.example.demo:type=CustomAdmin,name=CustomMXBean\"</span><span>)</span><span>;</span>\n\n    <span>public</span> <span>CustomMbeanRegistrar</span><span>(</span><span>)</span> <span>throws</span> <span>MalformedObjectNameException</span> <span>{</span>\n    <span>}</span>\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>destroy</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>ManagementFactory</span><span>.</span><span>getPlatformMBeanServer</span><span>(</span><span>)</span><span>.</span><span>unregisterMBean</span><span>(</span><span>this</span><span>.</span>objectName<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>afterPropertiesSet</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>MBeanServer</span> server <span>=</span> <span>ManagementFactory</span><span>.</span><span>getPlatformMBeanServer</span><span>(</span><span>)</span><span>;</span>\n        server<span>.</span><span>registerMBean</span><span>(</span><span>new</span> <span>Custom</span><span>(</span><span>)</span><span>,</span> <span>this</span><span>.</span>objectName<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>setApplicationContext</span><span>(</span><span>ApplicationContext</span> applicationContext<span>)</span> <span>throws</span> <span>BeansException</span> <span>{</span>\n        <span>this</span><span>.</span>applicationContext <span>=</span> <span>(</span><span>ConfigurableApplicationContext</span><span>)</span> applicationContext<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>interface</span> <span>CustomMBean</span> <span>{</span>\n        <span>int</span> <span>getDatabaseConnectionPoolSize</span><span>(</span><span>)</span><span>;</span>\n        <span>void</span> <span>customShutdown</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>private</span> <span>class</span> <span>Custom</span> <span>implements</span> <span>CustomMBean</span> <span>{</span>\n\n        <span>/**\n         * 获取数据库连接池大小\n         *\n         * @return 模拟\n         */</span>\n        <span>@Override</span>\n        <span>public</span> <span>int</span> <span>getDatabaseConnectionPoolSize</span><span>(</span><span>)</span> <span>{</span>\n            <span>return</span> <span>new</span> <span>Random</span><span>(</span><span>)</span><span>.</span><span>nextInt</span><span>(</span><span>100</span><span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>/**\n         * 自定义一个销毁方法\n         */</span>\n        <span>public</span> <span>void</span> <span>customShutdown</span><span>(</span><span>)</span> <span>{</span>\n            <span>CustomMbeanRegistrar</span><span>.</span><span>this</span><span>.</span>applicationContext<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br></div></div><h3 id=\"_2-演示\"> 2. 演示</h3>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1590924584000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"四、总结\"> 四、总结</h2>\n<p>通过前面的演示,大概我们对JMX在实际中的用处有一个大概的了解了吧。根据这个特性,我们就可以根据我们的需求来定制属于自己的能力。</p>\n<p>最后求关注,求订阅,谢谢你的阅读!</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589360371000.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1590919227000.png",
      "date_published": "2021-12-25T09:26:08.000Z",
      "date_modified": "2021-12-25T09:26:08.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "SPI服务发现机制",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/java/SPI/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/java/SPI/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/learn_1590160192000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n<h2 id=\"一、什么是spi\"> 一、什么是SPI</h2>\n<p>SPI ，全称为 Service Provider Interface，是一种服务发现机制。JDK中的SPI是通过在ClassPath路径下的META-INF/services文件夹查找扩展文件,自动加载文件里所定义的类。</p>\n<p>在小编的理解来,觉得它更是一种思想。即找到服务的接口, 美其名曰: 服务发现机制思想。很多开源框架都有借用这种思想，比如dubbo、jdbc。</p>\n<h2 id=\"二、spi在jdk中如何使用\"> 二、SPI在JDK中如何使用</h2>\n<p>SPI在JDK中,我们可以使用 <code>ServiceLoader</code> 类进行使用。\n<img src=\"https://img.springlearn.cn/blog/learn_1590225886000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_1-前提准备\"> 1. 前提准备</h3>\n<div><pre><code>public interface SpiService {\n    String say();\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>两个实现类</p>\n<div><pre><code>public class ASpiServiceImpl implements SpiService {\n    static {\n        System.out.println(&quot;static init a&quot;);\n    }\n\n    {\n        System.out.println(&quot;init a&quot;);\n    }\n\n    @Override\n    public String say() {\n        return &quot;A&quot;;\n    }\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><div><pre><code>public class BSpiServiceImpl implements SpiService {\n    static {\n        System.out.println(&quot;static init b&quot;);\n    }\n\n    {\n        System.out.println(&quot;init b&quot;);\n    }\n    @Override\n    public String say() {\n        return &quot;B&quot;;\n    }\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id=\"_2-进行配置\"> 2. 进行配置</h3>\n<p>在resources中创建META-INF/services目录</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1590225980000.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>│  └── resources\n│      └── META-INF\n│          └── services\n│              └── com.github.easylog.spi.SpiService\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>com.github.easylog.spi.SpiService文件内容</p>\n<div><pre><code>com.github.easylog.spi.impl.ASpiServiceImpl\ncom.github.easylog.spi.impl.BSpiServiceImpl\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"_3-使用\"> 3. 使用</h3>\n<p>通过ServiceLoader类我们可以加载到所有配置的实现类,并对实现类进行处理。需要注意一点的是，看4使用注意。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1590226089000.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>public class SpiTester {\n    public static void main(String[] args) {\n        ServiceLoader&lt;SpiService&gt; spiServices = ServiceLoader.load(SpiService.class);\n        Iterator&lt;SpiService&gt; iterator = spiServices.iterator();\n        while (iterator.hasNext()) {\n            SpiService next = iterator.next();\n            System.out.println(next.say());\n        }\n    }\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id=\"_4-使用注意\"> 4. 使用注意</h3>\n<p>可以看下小编前面声明的两个实现类,都定义了静态代码块和非静态代码块。正常情况当这个字节码被加载,就会执行静态代码块里面的内容，但是实际运行时候却没有执行, 其实是有原因的。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1590223793000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>可以看到第二个参数是false。即加载时候不进行初始化。</p>\n<h2 id=\"三、dubbo中服务发现思想\"> 三、Dubbo中服务发现思想</h2>\n<p>服务发现这种思想的特点是: 代码不是硬编码的方式,而是可配置的。只要将要支持的实现类放到指定配置文件下面,就会自动被加载起来了。然后代码中只关心使用即可。我们可以利用这种思想来实现, 框架的扩展,比如前面说了。Dubbo会利用SPI的思想进行，加载用户自定义的过滤器。</p>\n<p>这种思想特别适合做服务扩展。现在大多数开源框架中都会使用到这种思想。</p>\n<h3 id=\"_1-定义过滤器\"> 1. 定义过滤器</h3>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1590226192000.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>@Activate(group = { Constants.PROVIDER })\npublic class ProviderHelloFilter implements Filter {\n  \n    @Override\n    public Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException {\n        System.out.pringln(&quot;hello ok!&quot;);\n        return invoker.invoke(invocation);\n    }\n\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id=\"_2-添加配置文件\"> 2. 添加配置文件</h3>\n<p><code>META-INF/dubbo/Interal/com.alibaba.dubbo.rpc.Filter</code></p>\n<p>默认支持的过滤器</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1590224576000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>利用SPI原理,我们自定义一个过滤器</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1590224824000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_3-使用-2\"> 3. 使用</h3>\n<p>其实API跟JDK中使用ServiceLoader的方式,非常类同。唯一不同的是Dubbo中是使用ExtensionLoader。因为dubbo中做了一些特殊的增强处理。比如在配置文件中支持自定义一个别名key。如上图hello就是key。通过getExtension(&quot;hello&quot;)就能获取指定的实现类。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1590226285000.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>public class SpiTester {\n    public static void main(String[] args) throws Exception{\n        ExtensionLoader&lt;Filter&gt; filterExtensionLoader = ExtensionLoader.getExtensionLoader(Filter.class);\n        Set&lt;String&gt; supportedExtensions = filterExtensionLoader.getSupportedExtensions();\n        System.out.println(supportedExtensions);\n        //[accesslog, activelimit, cache...]\n        Filter hello = filterExtensionLoader.getExtension(&quot;hello&quot;);\n        //com.github.easylog.spi.ProviderHelloFilter@299a06ac\n        System.out.println(hello);\n    }\n    \n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>**那么这种思想你学会了吗? **</p>\n<p><img src=\"https://i04piccdn.sogoucdn.com/96a6f7554ee28b9c\" alt=\"\" loading=\"lazy\"></p>\n<p>最后求关注,求订阅,谢谢你的阅读!</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589360371000.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1590160192000.png",
      "date_published": "2021-12-25T09:26:08.000Z",
      "date_modified": "2021-12-25T09:26:08.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Java编程",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/java/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/java/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/learn_1648126927000.png\" alt=\"\" loading=\"lazy\"></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n",
      "image": "https://img.springlearn.cn/blog/learn_1648126927000.png",
      "date_published": "2021-12-25T09:26:08.000Z",
      "date_modified": "2021-12-25T09:26:08.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "JVM钩子hooks函数",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/java/hooks%E5%87%BD%E6%95%B0/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/java/hooks%E5%87%BD%E6%95%B0/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/learn_1589383784000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n<p>什么是钩子函数,在学习钩子函数之前,小编先提一个问题。</p>\n<p><strong>请问在Spring中,如果JVM异常终止,Spring是如何保证会释放掉占用的资源,比如说数据库连接等资源呢?</strong></p>\n<p>钩子函数非常简单,简单到小编只用摘抄一段Spring代码即可。走你,现在开始。</p>\n<h1 id=\"问题\"> 问题</h1>\n<p><code>Spring</code> 容器中 <code>Bean</code> 在什么时候执行销毁方法?</p>\n<p>我们知道在Spring中定义销毁方法有两种方式</p>\n<ol>\n<li>实现 <code>DisposableBean</code> 的 <code>destroy</code> 方法。</li>\n<li>使用 <code>@PreDestroy</code> 注解修饰方法</li>\n</ol>\n<div><pre><code>@Component\npublic class DataCollectBean implements DisposableBean {\n\n    /**\n     * 第一种方法实现 DisposableBean#destroy方法\n     *\n     * @throws Exception 异常\n     */\n    @Override\n    public void destroy() throws Exception {\n        System.err.println(&quot;执行销毁方法&quot;);\n    }\n\n    /**\n     * 第二种方法使用PreDestroy注解声明销毁方法\n     */\n    @PreDestroy\n    public void customerDestroy() {\n        System.err.println(&quot;执行自定义销毁方法&quot;);\n    }\n\n\n}\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h2 id=\"那么在什么时候执行销毁方法\"> 那么在什么时候执行销毁方法?</h2>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589471346000.png\" alt=\"\" loading=\"lazy\"></p>\n<ol>\n<li>主动执行销毁bean</li>\n</ol>\n<div><pre><code>    public static void main(String[] args) {\n        ConfigurableApplicationContext run = SpringApplication.run(DemoApplication.class, args);\n        DataCollectBean bean = run.getBean(DataCollectBean.class);\n        //1. 主动销毁bean\n        run.getBeanFactory().destroyBean(bean);\n    }\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ol start=\"2\">\n<li>JVM关闭时候自动执行销毁方法。</li>\n</ol>\n<p>这里就要用到钩子函数了, <code>Spring</code> 的钩子函数在 <code>AbstractApplicationContext#shutdownHook属性</code></p>\n<p>如果我们是SpringBoot项目我们看到在SpringApplication启动时候会注册一个钩子函数</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589473259000.png\" alt=\"\" loading=\"lazy\"></p>\n<h1 id=\"如何定义钩子函数\"> 如何定义钩子函数?</h1>\n<p>简直太简单了，没有任何学习成本。一行代码就能搞定。</p>\n<div><pre><code>public class HooksTester {\n    public static void main(String[] args) {\n        Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(&quot;钩子函数执行&quot;);\n            }\n        }));\n        //当主动关闭应用\n        while (true);\n    }\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p><img src=\"https://img.springlearn.cn/blog/learn_1589471574000.png\" alt=\"\" loading=\"lazy\"></p>\n<h1 id=\"触发钩子函数的场景\"> 触发钩子函数的场景</h1>\n<p>只要不是机器断电，强制kill -9 强制杀进程，都会触发。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589473502000.png\" alt=\"\" loading=\"lazy\"></p>\n<h1 id=\"钩子函数能做什么\"> 钩子函数能做什么？</h1>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589383970000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>正如上图所示优雅停机,在项目将要关闭时候,主动释放程序占用的资源信息,释放db连接池的连接等其他占用的资源信息。\n如果我们是 <code>Spring</code> 项目其实我们不用自己定义钩子函数,我们只要使用Spring提供给我们的销毁方法即可。因为\nSpring定义的钩子函数中会去执行, <code>DisposableBean.destory()</code> 和被 <code>PreDestroy</code> 修饰的方法。</p>\n<p>我们看下源码</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589472185000.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>protected void doClose() {\n\t\t// Check whether an actual close attempt is necessary...\n\t\tif (this.active.get() &amp;&amp; this.closed.compareAndSet(false, true)) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(&quot;Closing &quot; + this);\n\t\t\t}\n\n\t\t\tLiveBeansView.unregisterApplicationContext(this);\n\n\t\t\ttry {\n\t\t\t\t// Publish shutdown event.\n\t\t\t\tpublishEvent(new ContextClosedEvent(this));\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tlogger.warn(&quot;Exception thrown from ApplicationListener handling ContextClosedEvent&quot;, ex);\n\t\t\t}\n\n\t\t\t// Stop all Lifecycle beans, to avoid delays during individual destruction.\n\t\t\tif (this.lifecycleProcessor != null) {\n\t\t\t\ttry {\n\t\t\t\t\tthis.lifecycleProcessor.onClose();\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tlogger.warn(&quot;Exception thrown from LifecycleProcessor on context close&quot;, ex);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Destroy all cached singletons in the context&#39;s BeanFactory.\n\t\t\tdestroyBeans();\n\n\t\t\t// Close the state of this context itself.\n\t\t\tcloseBeanFactory();\n\n\t\t\t// Let subclasses do some final clean-up if they wish...\n\t\t\tonClose();\n\n\t\t\t// Reset local application listeners to pre-refresh state.\n\t\t\tif (this.earlyApplicationListeners != null) {\n\t\t\t\tthis.applicationListeners.clear();\n\t\t\t\tthis.applicationListeners.addAll(this.earlyApplicationListeners);\n\t\t\t}\n\n\t\t\t// Switch to inactive.\n\t\t\tthis.active.set(false);\n\t\t}\n\t}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><p>可以看到：doClose()方法会执行bean的destroy()，也会执行SmartLifeCycle的stop()方法，我们就可以通过重写这些方法来实现对象的关闭，生命周期的管理，实现平滑shutdown</p>\n<p><img src=\"https://i03piccdn.sogoucdn.com/7eac32473373b70a\" alt=\"\" loading=\"lazy\"></p>\n<p>最后求关注,求订阅,谢谢你的阅读!</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589360371000.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1589383784000.png",
      "date_published": "2021-12-25T09:26:08.000Z",
      "date_modified": "2021-12-25T09:26:08.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "synchronized锁升级",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/java/synchronized/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/java/synchronized/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/learn_1596467333000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n<h2 id=\"一、重量级锁\"> 一、重量级锁</h2>\n<p>什么叫重量级锁？</p>\n<p>就是申请资源必须经过kernel(内核也叫操作系统)，调用。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596467437000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"二、轻量级锁\"> 二、轻量级锁</h2>\n<p>轻量级锁,是不经过操作系统。轻量级锁是相对于重量级锁来叫的,也可以叫乐观锁。</p>\n<p>在Java中乐观锁就是cas操作(compare and swap)根据英文翻译就是比较和交换。\n底层都是调用的Unsafe里面的方法,可以看到这些方法是native方法。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596467628000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>通过看jvm源码,看到c++的代码有一个汇编语言支持cas</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596467784000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>但是，这条cmpchg1不具有原子性，点进lock_if_mp(%4)里</p>\n<p>最终实现是lock cmpxchg 指令：表示在硬件在执行后面的指令会锁定一个北桥总线。（相当于锁定总线，但是比锁总线要轻量级）解决了下面的问题</p>\n<h2 id=\"三、偏向锁\"> 三、偏向锁</h2>\n<p>顾名思义，它会偏向于第一个访问锁的线程，如果在运行过程中，同步锁只有一个线程访问，不存在多线程争用的情况，则线程是不需要触发同步的，这种情况下，就会给线程加一个偏向锁。\n说白了,没有竞争,还叫啥锁呀。就是加了一个标记。认为没有人给你竞争。</p>\n<h2 id=\"四、锁升级步骤\"> 四、锁升级步骤</h2>\n<p>偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁</p>\n<p>在jdk1.6之前synchronized直接就是一个重量级锁,一了百了。\njdk优化后出现了,锁升级的概念。</p>\n<p>那么其实synchronized的执行过程:</p>\n<ol>\n<li>检测Mark Word里面是不是当前线程的ID，如果是，表示当前线程处于偏向锁</li>\n<li>如果不是，则使用CAS将当前线程的ID替换Mard Word，如果成功则表示当前线程获得偏向锁，置偏向标志位1(前面一个线程刚好释放的情况下,这个才能成功,否则看3)</li>\n<li>如果失败，则说明发生竞争，撤销偏向锁，进而升级为轻量级锁。</li>\n<li>当前线程使用CAS将对象头的Mark Word替换为锁记录指针，如果成功，当前线程获得锁</li>\n<li>如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</li>\n<li>如果自旋成功则依然处于轻量级状态。</li>\n<li>如果自旋失败，则升级为重量级锁。</li>\n</ol>\n<p>翻译成白话问:</p>\n<ol>\n<li>\n<p>当没有人跟你竞争就是一个偏向锁,当cas失败了,说明有人跟你竞争了,这个时候锁就从偏向锁升级成了轻量级锁。</p>\n</li>\n<li>\n<p>轻量级锁的状态下,仍然还有很多线程来竞争,那么此时cas就会比较严重从而浪费cpu执行。就升级为重量级锁。\n其次其他等待线程就进入了阻塞状态。</p>\n</li>\n</ol>\n<p>最后求关注,求订阅,谢谢你的阅读!</p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1596467333000.png",
      "date_published": "2022-01-04T14:58:20.000Z",
      "date_modified": "2022-01-04T14:58:20.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "信号量 Semaphore",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/java/Semaphore/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/java/Semaphore/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n<h2 id=\"🚀-知识快读\"> 🚀 知识快读</h2>\n<p><code>Semaphore</code> 翻译过来就是信号量, 其根本原理就是基于 <code>CAS</code> 共享锁的一种实现。举一个例子。\n假设停车场只有三个车位，一开始三个车位都是空的。这时如果同时来了五辆车，看门人允许其中三辆不受阻碍的进入，然后放下车拦，剩下的车则必须在入口等待，此后来的车也都不得不在入口处等待。这时，有一辆车离开停车场，看门人得知后，打开车拦，放入一辆，如果又离开两辆，则又可以放入两辆，如此往复。</p>\n<p>那么上面的这个例子可以这样理解，资源一共有3个, 即三个车位。如何来控制这5辆汽车，来合理的使用这3个资源呢?\n<code>Semaphore</code> 可以这样来定义。</p>\n<div><pre><code><span>// 1. 定一个信号量,声明有3个资源。使用公平模式线程将会按到达的顺序（FIFO）执行(也就是等待时间最长的先执行),如果是非公平，则可以后请求的有可能排在队列的头部。</span>\n<span>Semaphore</span> semp <span>=</span> <span>new</span> <span>Semaphore</span><span>(</span><span>3</span><span>)</span><span>;</span>\n<span>// 2. 获取1个许可 - 最大允许3个进入，一但超过就让其等待,除非已经释放</span>\nsemp<span>.</span><span>acquire</span><span>(</span><span>)</span><span>;</span>  \n<span>// 3. 释放1个许可 </span>\nsemp<span>.</span><span>release</span><span>(</span><span>)</span><span>;</span> \n<span>// 4. 获取1许可,失败就返回,不等待</span>\nsemp<span>.</span><span>tryAcquire</span><span>(</span><span>)</span><span>;</span>  \n<span>// 5. 获取2许可,失败就返回,不等待</span>\nsemp<span>.</span><span>tryAcquire</span><span>(</span><span>2</span><span>)</span><span>;</span>  \n<span>// 6. 不允许被中断</span>\nsemp<span>.</span><span>acquireUninterruptibly</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id=\"知识点1-fair-nofair\"> 知识点1: Fair &amp; NoFair</h2>\n<p><code>Semaphore</code> 的模式配置,只是构造来定义。</p>\n<ul>\n<li>默认构造不公平模式, 谁来申请资源,就先尝试获取资源。排队的要等到没有资源进来申请才能继续申请</li>\n</ul>\n<div><pre><code>    <span>public</span> <span>Semaphore</span><span>(</span><span>int</span> <span>permits</span><span>)</span> <span>{</span>\n        sync <span>=</span> <span>new</span> <span>NonfairSync</span><span>(</span><span>permits</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>Semaphore</span><span>(</span><span>int</span> <span>permits</span><span>,</span> <span>boolean</span> fair<span>)</span> <span>{</span>\n        sync <span>=</span> fair <span>?</span> <span>new</span> <span>FairSync</span><span>(</span><span>permits</span><span>)</span> <span>:</span> <span>new</span> <span>NonfairSync</span><span>(</span><span>permits</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><img src=\"https://img.springlearn.cn/blog/learn_1640531082000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"知识点2-申请资源\"> 知识点2: 申请资源</h2>\n<ul>\n<li>acquire() 获取1个资源,获取不到就等待,如果线程中断,会直接中断。</li>\n<li>acquire(2) 获取2个资源,获取不到就等待,如果线程中断,会直接中断。</li>\n<li>tryAcquire() 获取1个资源,获取不到就返回 <code>false</code>,如果线程中断,会直接中断。</li>\n<li>acquireUninterruptibly() 获取1个资源,获取不到就等待,不会关心线程中断。</li>\n</ul>\n<h2 id=\"知识点3-释放资源\"> 知识点3: 释放资源</h2>\n<ul>\n<li>release() 释放一个资源</li>\n<li>release(2) 释放两个资源</li>\n</ul>\n<h2 id=\"知识点4-其他api\"> 知识点4: 其他API</h2>\n<ul>\n<li>availablePermits() 当前资源数量</li>\n<li>drainPermits() 获取当前资源数量，并将剩余资源清零，直接赋值0</li>\n<li>reducePermits(2) 将资源数量，扣减2个</li>\n<li>isFair() 是否公平</li>\n<li>hasQueuedThreads() 是否还有线程等待</li>\n<li>getQueueLength() 还有多少线程等待</li>\n<li>getQueuedThreads() 获取所有的线程集合</li>\n</ul>\n",
      "image": "https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png",
      "date_published": "2021-12-25T09:26:08.000Z",
      "date_modified": "2022-01-04T14:58:20.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Lambda函数式编程",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/java/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/java/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n<blockquote>\n<p>Java8所有的新特性基本基于函数式编程的思想，函数式编程给Java带来了注入了新鲜的活力。\n函数式编程其实并不是很难，小编在学习函数式编程时候刚开始一头雾水，最后仔细观察就发现了其中的小窍门，读了本篇文章如果还没有掌握，就算我输了</p>\n</blockquote>\n<h1 id=\"函数式编程\"> 函数式编程</h1>\n<h2 id=\"一、lambda表达式\"> 一、Lambda表达式</h2>\n<p><strong>注意</strong>: 以下方法都可以使用表达式来进行缩写</p>\n<p>我们来看Java中如何来定义一个方法</p>\n<h3 id=\"_1-语法\"> 1. 语法</h3>\n<p><code>()-&gt;{}</code></p>\n<p>其中小括号里面可以放入参，大括号就是方法体，里面也允许有返回值。</p>\n<p><strong>当方法体中只有返回值而没有其他语句时候，大括号和 <code>return</code> 关键字都可以省略不写。</strong></p>\n<h3 id=\"_2-方法引用\"> 2. 方法引用</h3>\n<p><em>只要用.引用不报错的，都可以将.换成:</em></p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>语法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1、引用静态方法</td>\n<td>ClassName::staticMethodName</td>\n</tr>\n<tr>\n<td>2、引用构造函数</td>\n<td>ClassName::new</td>\n</tr>\n<tr>\n<td>3、引用特定类型的实例方法</td>\n<td>ClassName::instanceMethodName</td>\n</tr>\n<tr>\n<td>4、引用特定对象的实例方法</td>\n<td>objectName::instanceMethodName</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"二、java8新增函数式接口\"> 二、Java8新增函数式接口</h2>\n<h3 id=\"_1-predicate接口\"> 1. Predicate接口</h3>\n<p>Predicate 接口只有一个参数，返回boolean类型。该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）</p>\n<div><pre><code>Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; 0;\n</code></pre>\n<div><span>1</span><br></div></div><p>根据前面的语法我们知道小括号里面可以放入参，大括号里面放出参，当大括号里面只有返回值时候，大括号和 <code>return</code> 关键字也可以省略。如上。</p>\n<h3 id=\"_2-function-接口\"> 2. Function 接口</h3>\n<p>Function 接口有一个参数并且返回一个结果，并附带了一些可以和其他函数组合的默认方法（compose, andThen）：</p>\n<div><pre><code>Function&lt;Integer, Integer&gt; function = (x) -&gt; 2 * x;\n</code></pre>\n<div><span>1</span><br></div></div><p>同理，这个接口有一个入参和出参，如果返回体重不包含其他逻辑，只有一个返回值，大括号和 <code>return</code> 关键字也可以省略。如上。</p>\n<h3 id=\"_3-supplier-接口\"> 3. Supplier 接口</h3>\n<p>Supplier 接口返回一个任意范型的值，和Function接口不同的是该接口没有任何参数</p>\n<div><pre><code>public class Main{\n    public static void main(String[] args) {\n        //构造方法\n        Supplier&lt;Main&gt; supplier = () -&gt; new Main();\n        Supplier&lt;Main&gt; mainSupplier = Main::new;\n        Supplier&lt;Main&gt; mainSupplier1 = Main::staticMethod;\n    }\n    private static Main staticMethod() {\n        return new Main();\n    }\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>因为没有入参，所以小括号里面什么都不用写。当遇到这种情况，同样可以用上面其他两种来替换</p>\n<h3 id=\"_4-consumer-接口\"> 4. Consumer 接口</h3>\n<p>Consumer 是一个只有入参，但是无出参的接口。</p>\n<div><pre><code>public class Main {\n    public static void main(String[] args) {\n        List&lt;String&gt; dataList = Arrays.asList(&quot;1&quot;, &quot;2&quot;);\n\n        //特定类的静态方法\n        dataList.forEach(Main::staticMethod);\n        dataList.forEach((x) -&gt; System.out.println(x));\n        dataList.forEach(System.out::println);\n\n    }\n    private static void staticMethod(String name) {\n        System.out.println(&quot;对象静态方法引用:&quot; + name);\n    }\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h2 id=\"三、快速记忆\"> 三、快速记忆</h2>\n<p>虽然新增的函数式接口并不多，但是想要一次性死记住，还是有一点点的难度。小编的学习方式是\n理解这记忆。</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>简记</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1、Predicate</td>\n<td>条件类型</td>\n</tr>\n<tr>\n<td>2、Supplier</td>\n<td>无入参，有出参</td>\n</tr>\n<tr>\n<td>3、Function</td>\n<td>有入参，有出参</td>\n</tr>\n<tr>\n<td>4、Consumer</td>\n<td>有入参，无出参</td>\n</tr>\n</tbody>\n</table>\n<p>最后求关注,求订阅,谢谢你的阅读!</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589360371000.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png",
      "date_published": "2021-12-25T09:26:08.000Z",
      "date_modified": "2021-12-25T09:26:08.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Java四大引用",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/java/%E5%9B%9B%E5%A4%A7%E5%BC%95%E7%94%A8/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/java/%E5%9B%9B%E5%A4%A7%E5%BC%95%E7%94%A8/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n<h1 id=\"一、概念\"> 一、概念</h1>\n<h2 id=\"_1-强引用\"> 1. 强引用</h2>\n<p>new 对象并指向引用变量的都是强引用,开发中大部分都是强引用。对于强引用,JVM宁愿报错<code>OutOfMemoryError</code>错误,是程序异常终止,\n也不会回收强引用来解决内存, 对这类情况,可以通过赋值强引用对象=null,从而被JVM回收。\n但是一般我们在方法中定义的强引用,会存在方法栈中,当方法运行完,退出,此时方法中的强引用也会因为引用数为0,从而被回收。</p>\n<h2 id=\"_2-软引用\"> 2. 软引用</h2>\n<p>在内存充足情况下,GC不会回收软引用对象,如果内存空间不足了,才会回收这些对象的内存。也正因为这个特性,所以软引用经常用作缓存对象使用。</p>\n<h2 id=\"_3-弱引用\"> 3. 弱引用</h2>\n<p>任意GC都会清理掉软引用对象,弱引用是最容易记的,任何的GC动作都会将弱引用对象给回收掉。</p>\n<h2 id=\"_4-虚引用\"> 4. 虚引用</h2>\n<p>和其他三个不一样,这个不对生命周期,有影响,而是当要回收时候,加入到Queue队列中</p>\n<h1 id=\"二、在jdk中的体现\"> 二、在JDK中的体现</h1>\n<table>\n<thead>\n<tr>\n<th>类</th>\n<th>引用说明</th>\n<th>用途</th>\n<th>生存时间</th>\n<th>被垃圾回收时间</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Object</td>\n<td>默认new出来的都是强引用</td>\n<td>对象正常状态</td>\n<td>JVM停止或者无引用被回收</td>\n<td>无任务对象使用</td>\n</tr>\n<tr>\n<td>SoftReference</td>\n<td>软引用</td>\n<td>常用作缓存</td>\n<td>当内存不足时候终止</td>\n<td>内存不足时候回收</td>\n</tr>\n<tr>\n<td>WeakReference</td>\n<td>弱引用</td>\n<td>常用作缓存</td>\n<td>垃圾回收后终止</td>\n<td>任何垃圾回收时</td>\n</tr>\n<tr>\n<td>PhantomReference</td>\n<td>虚引用</td>\n<td>用于跟踪对象是否被回收</td>\n<td>垃圾回收后终止</td>\n<td>任何垃圾回收时</td>\n</tr>\n</tbody>\n</table>\n<p>最后求关注,求订阅,谢谢你的阅读!</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589360371000.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png",
      "date_published": "2021-12-25T09:26:08.000Z",
      "date_modified": "2021-12-25T09:26:08.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "分布式锁",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/java/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/java/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/learn_1596467333000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>在单机环境下多线程操作共享数据时候回用到锁的概念,因为是单机可以直接使用jdk提供的锁机制就可以满足。\n但是在微服务场景下,因为是多服务共享数据,此时jdk提供的锁就不能再使用了。于是乎就有了分布式锁。\n本文介绍常见的几种可以使用的生产的分布式锁</p>\n</div>\n<p><strong>本文面向有开发经验的同学,所以场景就不赘述,直接上干货</strong></p>\n<h2 id=\"一、分布式锁具有的品格\"> 一、分布式锁具有的品格</h2>\n<ul>\n<li>基本的加锁和释放锁</li>\n<li>具备锁失效机制,防止死锁</li>\n<li>非阻塞机制</li>\n<li>高性能和高可用</li>\n</ul>\n<h2 id=\"二、思考一下如何自己实现\"> 二、思考一下如何自己实现?</h2>\n<h3 id=\"_1-db\"> 1. db</h3>\n<p>根据上面提出的要求,发现只要能满足多服务之前通信就能实现。\n比如我们可以用mysql就能实现,比如A服务对一个表加锁和释放锁。B服务就会发现表加了锁。此时B就阻塞了。</p>\n<p>当然这明显不满足,非阻塞的机制。另外如果要用一个数据库来做锁的场景也太浪费性能了。</p>\n<h3 id=\"_2-redis\"> 2. redis</h3>\n<p>利用redis命令来实现,如果返回ok说明获取锁。返回nil说明没有获取到锁。</p>\n<p>不阻塞,防止死锁,高性能,都满足</p>\n<div><pre><code>set key value [EX seconds] [PX milliseconds] [NX|XX]\nEX seconds：设置失效时长，单位秒\nPX milliseconds：设置失效时长，单位毫秒\nNX：key不存在时设置value，成功返回OK，失败返回(nil)\nXX：key存在时设置value，成功返回OK，失败返回(nil)\n//对资源加一个锁 key为资源名 value可以为任意 ex为秒 1为过期时间 nx为\n127.0.0.1:6379&gt; set ziyuanming 1 ex 1 nx\nOK\n127.0.0.1:6379&gt; set ziyuanming 1 ex 1 nx\n(nil)\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id=\"_3-zookeeper\"> 3. zookeeper</h3>\n<h4 id=\"获取锁\"> 获取锁</h4>\n<ol>\n<li>在Zookeeper当中创建一个持久节点ParentLock。当第一个客户端想要获得锁时，需要在ParentLock这个节点下面创建一个临时顺序节点 Lock1。</li>\n<li>Client1查找ParentLock下面所有的临时顺序节点并排序，判断自己所创建的节点Lock1是不是顺序最靠前的一个。如果是第一个节点，则成功获得锁。</li>\n<li>如果再有一个客户端 Client2 前来获取锁，则在ParentLock下载再创建一个临时顺序节点Lock2。\n此时Client2发现自己并不是最靠前的就像Lock1注册了一个Watcher,用于监听Lock1节点释放。此时Client2就进入等待状态</li>\n<li>Client3,4以此类推</li>\n</ol>\n<h4 id=\"释放锁\"> 释放锁</h4>\n<ol>\n<li>Client1释放了锁,此时Zookeeper就讲Lock1移出,并触发了Lock1的Watcher。</li>\n<li>Client2一直在监听Lock1的状态,当Lock1节点被删除,Client2里面收到通知获得了锁。</li>\n</ol>\n<h2 id=\"三、现成的解决方案\"> 三、现成的解决方案</h2>\n<h3 id=\"_1-db的方式就不考虑了\"> 1. db的方式就不考虑了</h3>\n<p>实现简单,但是不划算,性能也不是最好的。</p>\n<h3 id=\"_2-redis-2\"> 2. redis</h3>\n<div><pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.redisson&lt;/groupId&gt;\n    &lt;artifactId&gt;redisson&lt;/artifactId&gt;\n    &lt;version&gt;3.11.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code>\npublic class RedLockTester {\n    public static void main(String[] args) {\n        //连接redis\n        Config config = new Config();\n        config.useSingleServer().setAddress(&quot;redis://127.0.0.1:6379&quot;);\n        RedissonClient redisson = Redisson.create(config);\n        log.info(&quot;连接Redis&quot;);\n\n        //1.定义锁\n        RLock lock = redisson.getLock(&quot;myTest001&quot;);\n\n        try {\n            //尝试加锁的超时时间\n            Long timeout = 300L;\n            //锁过期时间\n            Long expire = 30L;\n            //2.获取锁\n            if (lock.tryLock(timeout, expire, TimeUnit.MILLISECONDS)) {\n                //2.1.获取锁成功的处理\n                log.info(&quot;加锁成功&quot;);\n                //...do something\n                log.info(&quot;使用完毕&quot;);\n            } else {\n                //2.2.获取锁失败的处理\n                log.info(&quot;加锁失败&quot;);\n                log.info(&quot;其他处理&quot;);\n            }\n        } catch (InterruptedException e) {\n            log.error(&quot;尝试获取分布式锁失败&quot;, e);\n        } finally {\n            //3.释放锁\n            try {\n                lock.unlock();\n                log.info(&quot;锁释放成功&quot;);\n            } catch (Exception e) {\n                //do nothing...\n            }\n        }\n\n        //关闭连接\n        redisson.shutdown();\n        log.info(&quot;关闭redis连接&quot;);\n    }\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br></div></div><p>通过官方文档能找到实现第三方工具</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596471713000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><a href=\"https://www.cnblogs.com/rgcLOVEyaya/p/RGC_LOVE_YAYA_1003days.html\" target=\"_blank\" rel=\"noopener noreferrer\">参考文章</a></p>\n<h3 id=\"_3-zookeeper-2\"> 3. zookeeper</h3>\n<p><a href=\"https://curator.apache.org/\" target=\"_blank\" rel=\"noopener noreferrer\">Curator</a></p>\n<div><pre><code>&lt;!-- 对zookeeper的底层api的一些封装 --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;\n            &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;\n            &lt;version&gt;2.12.0&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!-- 封装了一些高级特性，如：Cache事件监听、选举、分布式锁、分布式Barrier --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;\n            &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;\n            &lt;version&gt;2.12.0&lt;/version&gt;\n        &lt;/dependency&gt;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>几乎对所有的JDK锁都实现了,基于Zookeeper的分布式锁。具体使用方法可以自行百度。</p>\n<ul>\n<li>InterProcessMutex：分布式可重入排它锁</li>\n<li>InterProcessSemaphoreMutex：分布式排它锁</li>\n<li>InterProcessReadWriteLock：分布式读写锁</li>\n<li>InterProcessMultiLock：将多个锁作为单个实体管理的容器</li>\n<li>InterProcessSemaphoreV2 信号量</li>\n<li>DistributedBarrier 分布式栅栏</li>\n<li>DistributedDoubleBarrier 分布式栅栏</li>\n</ul>\n<p>最后求关注,求订阅,谢谢你的阅读!</p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1596467333000.png",
      "date_published": "2022-01-04T14:58:20.000Z",
      "date_modified": "2022-01-04T14:58:20.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "委派双亲之类加载器",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/java/%E5%A7%94%E6%B4%BE%E5%8F%8C%E4%BA%B2%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/java/%E5%A7%94%E6%B4%BE%E5%8F%8C%E4%BA%B2%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/learn_1589811713000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n<ul>\n<li>BootStrap ClassLoader：称为启动类加载器，是Java类加载层次中最顶层的类加载器，负责加载JDK中的核心类库，如：rt.jar、resources.jar、charsets.jar等，可通过如下程序获得该类加载器从哪些地方加载了相关的jar或class文件：</li>\n<li>Extension ClassLoader：称为扩展类加载器，负责加载Java的扩展类库，默认加载JAVA_HOME/jre/lib/ext/目下的所有jar。</li>\n<li>App ClassLoader：称为系统类加载器，负责加载应用程序classpath目录下的所有jar和class文件。</li>\n</ul>\n<h2 id=\"一、类加载器\"> 一、类加载器</h2>\n<p>类的加载在JVM的外部实现。对于任意的一个类，都必须由加载它的类加载器和这个类本身共同确立其在Java虚拟机中的唯一性。JVM提供中类加载器。</p>\n<h2 id=\"二、启动类加载器-bootstrap-classloader\"> 二、启动类加载器（Bootstrap ClassLoader）</h2>\n<p>负责加载 JAVA_HOME\\lib 目录中的，或通过-Xbootclasspath 参数指定路径中的，且被 虚拟机认可（按文件名识别，如 rt.jar）的类。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589811324000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"三、扩展类加载器-extension-classloader\"> 三、扩展类加载器(Extension ClassLoader)</h2>\n<p>负责加载 JAVA_HOME\\lib\\ext 目录中的，或通过 java.ext.dirs 系统变量指定路径中的类 库。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589811366000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"四、应用程序类加载器-application-classloader\"> 四、应用程序类加载器(Application ClassLoader)</h2>\n<p>负责加载用户路径（classpath）上的类库。 JVM 通过双亲委派模型进行类的加载，当然我们也可以通过继承 java.lang.ClassLoader 实现自定义的类加载器。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589811400000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"五、原理解释\"> 五、原理解释</h2>\n<p>ClassLoader使用的是双亲委托模型来搜索类的，每个ClassLoader实例都有一个父类加载器的引用（不是继承的关系，是一个包含的关系），虚拟机内置的类加载器（Bootstrap ClassLoader）本身没有父类加载器，但可以用作其它ClassLoader实例的的父类加载器。当一个ClassLoader实例需要加载某个类时，它会试图亲自搜索某个类之前，先把这个任务委托给它的父类加载器，这个过程是由上至下依次检查的，首先由最顶层的类加载器Bootstrap ClassLoader试图加载，如果没加载到，则把任务转交给Extension ClassLoader试图加载，如果也没加载到，则转交给App ClassLoader 进行加载，如果它也没有加载得到的话，则返回给委托的发起者，由它到指定的文件系统或网络等URL中加载该类。如果它们都没有加载到这个类时，则抛出ClassNotFoundException异常。否则将这个找到的类生成一个类的定义，并将它加载到内存当中，最后返回这个类在内存中的Class实例对象。</p>\n<h2 id=\"六、为什么要使用双亲委托这种模型呢\"> 六、为什么要使用双亲委托这种模型呢？</h2>\n<p>因为这样可以避免重复加载，当父亲已经加载了该类的时候，就没有必要子ClassLoader再加载一次。考虑到安全因素，我们试想一下，如果不使用这种委托模式，那我们就可以随时使用自定义的String来动态替代java核心api中定义的类型，这样会存在非常大的安全隐患，而双亲委托的方式，就可以避免这种情况，因为String已经在启动时就被引导类加载器（Bootstrcp ClassLoader）加载，所以用户自定义的ClassLoader永远也无法加载一个自己写的String，除非你改变JDK中ClassLoader搜索类的默认算法。</p>\n<h2 id=\"七、但是jvm在搜索类的时候-又是如何判定两个class是相同的呢\"> 七、但是JVM在搜索类的时候，又是如何判定两个class是相同的呢？</h2>\n<p>JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。只有两者同时满足的情况下，JVM才认为这两个class是相同的。就算两个class是同一份class字节码，如果被两个不同的ClassLoader实例所加载，JVM也会认为它们是两个不同class。</p>\n<div><pre><code> /**\n         * rt目录:\n         * 加载rt.jar的类加载器\n         */\n        ClassLoader rtClassLoader = StringBuffer.class.getClassLoader();\n        System.out.println(rtClassLoader);\n\n        /**\n         * lib/ext扩展包\n         * sun.misc.Launcher$ExtClassLoader@67b6d4ae\n         */\n        ClassLoader extClassLoader = EventID.class.getClassLoader();\n        System.out.println(extClassLoader);\n\n        /**\n         * 当前应用加载器\n         * sun.misc.Launcher$AppClassLoader@33909752\n         */\n        ClassLoader classLoader = BaseSyntaxTest.class.getClassLoader();\n        System.out.println(classLoader);\n\n        /**\n         * sun.misc.Launcher$AppClassLoader@33909752\n         */\n        ClassLoader currentClassLoader = Thread.currentThread().getContextClassLoader();\n        System.out.println(currentClassLoader);\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>最后求关注,求订阅,谢谢你的阅读!</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589360371000.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1589811713000.png",
      "date_published": "2021-12-25T09:26:08.000Z",
      "date_modified": "2021-12-25T09:26:08.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "成熟的线程要懂得拒绝",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/java/%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/java/%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n<h1 id=\"拒绝策略\"> 拒绝策略</h1>\n<p><strong>拒绝策略就是任务实在是已经执行不了，那么就需要你告诉程序，怎么样去拒绝在执行其他任务</strong></p>\n<p>在实际开发场景中，基本使用JDK自带的策略就可以完成日常开发，但是作为程序员必须要知道。下面说一下JDK自带有哪些线程策略</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>RejectedExecutionHandler</span> <span>{</span>\n    <span>void</span> <span>rejectedExecution</span><span>(</span><span>Runnable</span> r<span>,</span> <span>ThreadPoolExecutor</span> executor<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h1 id=\"四种拒绝策略\"> 四种拒绝策略</h1>\n<blockquote>\n<p>ThreadPoolExecutor类里面是内置了4中拒绝策略，我们一个一个来分析</p>\n</blockquote>\n<h2 id=\"_1-callerrunspolicy\"> 1. CallerRunsPolicy</h2>\n<p>直接执行该任务，如果线程池已经关闭，就不运行</p>\n<div><pre><code>    <span>public</span> <span>static</span> <span>class</span> <span>CallerRunsPolicy</span> <span>implements</span> <span>RejectedExecutionHandler</span> <span>{</span>\n        <span>public</span> <span>CallerRunsPolicy</span><span>(</span><span>)</span> <span>{</span> <span>}</span>\n        <span>public</span> <span>void</span> <span>rejectedExecution</span><span>(</span><span>Runnable</span> r<span>,</span> <span>ThreadPoolExecutor</span> e<span>)</span> <span>{</span>\n            <span>if</span> <span>(</span><span>!</span>e<span>.</span><span>isShutdown</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n                r<span>.</span><span>run</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id=\"_2-abortpolicy-【默认策略】\"> 2. AbortPolicy 【默认策略】</h2>\n<p>直接报异常，简单粗暴</p>\n<div><pre><code><span>public</span> <span>static</span> <span>class</span> <span>AbortPolicy</span> <span>implements</span> <span>RejectedExecutionHandler</span> <span>{</span>\n        <span>public</span> <span>AbortPolicy</span><span>(</span><span>)</span> <span>{</span> <span>}</span>\n        <span>public</span> <span>void</span> <span>rejectedExecution</span><span>(</span><span>Runnable</span> r<span>,</span> <span>ThreadPoolExecutor</span> e<span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>RejectedExecutionException</span><span>(</span><span>\"Task \"</span> <span>+</span> r<span>.</span><span>toString</span><span>(</span><span>)</span> <span>+</span>\n                                                 <span>\" rejected from \"</span> <span>+</span>\n                                                 e<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id=\"_3-discardpolicy\"> 3. DiscardPolicy</h2>\n<p>直接丢弃，不记录任何信息</p>\n<div><pre><code> <span>public</span> <span>static</span> <span>class</span> <span>DiscardPolicy</span> <span>implements</span> <span>RejectedExecutionHandler</span> <span>{</span>\n        <span>public</span> <span>DiscardPolicy</span><span>(</span><span>)</span> <span>{</span> <span>}</span>\n        <span>public</span> <span>void</span> <span>rejectedExecution</span><span>(</span><span>Runnable</span> r<span>,</span> <span>ThreadPoolExecutor</span> e<span>)</span> <span>{</span>\n        <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"_4-discardoldestpolicy\"> 4. DiscardOldestPolicy</h2>\n<p>丢弃一个老任务，然后执行当前任务</p>\n<div><pre><code><span>public</span> <span>static</span> <span>class</span> <span>DiscardOldestPolicy</span> <span>implements</span> <span>RejectedExecutionHandler</span> <span>{</span>\n        <span>public</span> <span>DiscardOldestPolicy</span><span>(</span><span>)</span> <span>{</span> <span>}</span>\n        <span>public</span> <span>void</span> <span>rejectedExecution</span><span>(</span><span>Runnable</span> r<span>,</span> <span>ThreadPoolExecutor</span> e<span>)</span> <span>{</span>\n            <span>if</span> <span>(</span><span>!</span>e<span>.</span><span>isShutdown</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n\t\t\t\t<span>// Retrieves and removes the head of this queue 移出最头任务，也就是老任务</span>\n                e<span>.</span><span>getQueue</span><span>(</span><span>)</span><span>.</span><span>poll</span><span>(</span><span>)</span><span>;</span>\n                e<span>.</span><span>execute</span><span>(</span>r<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h1 id=\"分析\"> 分析</h1>\n<p>拒绝策略其实很简单，知己知彼百战百胜，在多线程多任务编程场景下，我们可以根据业务特性定义拒绝策略。\n比如，在任务满的情况将，任务放到数据库中，或者打印到特殊的日志中，用来恢复任务。</p>\n<p>最后求关注,求订阅,谢谢你的阅读!</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589360371000.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png",
      "date_published": "2021-12-25T09:26:08.000Z",
      "date_modified": "2022-01-04T14:58:20.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "线程安全感",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/java/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/java/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/learn_1608963968000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n<h1 id=\"线程安全\"> 线程安全</h1>\n<blockquote>\n<p>所谓发生线程安全其实是有一个前提条件,即当有多线程时候才会设计到线程安全,单线程是不存在线程安全的问题的。且只有在有状态对象中才会发生。</p>\n</blockquote>\n<h2 id=\"_1-什么叫有状态对象\"> 1. 什么叫有状态对象?</h2>\n<h3 id=\"_1-1-无状态对象\"> 1.1 无状态对象</h3>\n<div><pre><code><span>public</span> <span>class</span> <span>Home</span><span>{</span>\n    <span>public</span> <span>String</span> <span>say</span><span>(</span><span>String</span> message<span>)</span><span>{</span>\n        <span>return</span> message<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"_1-2-有状态对象\"> 1.2 有状态对象</h3>\n<div><pre><code><span>public</span> <span>class</span> <span>Home</span><span>{</span>\n    <span>//实例变量</span>\n    <span>public</span> <span>int</span> age <span>=</span> <span>0</span><span>;</span>\n    <span>public</span> <span>String</span> <span>say</span><span>(</span><span>String</span> message<span>)</span><span>{</span>\n        <span>return</span> message <span>+</span> <span>(</span>age<span>++</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>为什么说无状态对象不会发生线程安全,线程对公共变量（实例变量，类变量）进行操作才会发生线程安全问题，而方法中变量是保存在每个线程的私有栈中的,所以不存在线程安全问题</p>\n<h2 id=\"_2-什么时候要保证线程安全\"> 2. 什么时候要保证线程安全？</h2>\n<ol>\n<li>当变量属于实例,该实例被多线程操作</li>\n<li>当多线程会影响到执行结果时候,需要保证线程安全</li>\n<li>当变量属于共享属性时候需要保证线程安全,而方法内变量属于每个\n线程的空间,则不需要。</li>\n</ol>\n<h2 id=\"_3-如何保证线程安全\"> 3. 如何保证线程安全？</h2>\n<ol>\n<li>原子性 lock操作,Syn...</li>\n<li>可见性 volatile</li>\n<li>顺序性 防止被重排序</li>\n</ol>\n<h2 id=\"_3-1-原子性\"> 3.1 原子性</h2>\n<p>原子是世界上的最小单位，具有不可分割性。比如 a=0；（a非long和double类型） 这个操作是不可分割的，那么我们说这个操作时原子操作。再比如：a++； 这个操作实际是a = a + 1；是可分割的，所以他不是一个原子操作。非原子操作都会存在线程安全问题，需要我们使用同步技术（sychronized）来让它变成一个原子操作。</p>\n<h2 id=\"_3-2-可见性\"> 3.2 可见性</h2>\n<p>可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个线程修改的结果。另一个线程马上就能看到。比如：用volatile修饰的变量，就会具有可见性。volatile修饰的变量不允许线程内部缓存和重排序，即直接修改内存。所以对其他线程是可见的。</p>\n<ul>\n<li>volatile 本质是在告诉jvm当前变量在寄存器中的值是不确定的,需要从主存中读取,</li>\n<li>synchronized 则是锁定当前变量,只有当前线程可以访问该变量,其他线程被阻塞住.</li>\n</ul>\n<h2 id=\"_3-3-那么什么时候用可见性\"> 3.3 那么什么时候用可见性？</h2>\n<p>当多线程并不直接进行原子性操作的时候，可以用 volatile 修饰,这样可以保证每个线程读取的都是最新的</p>\n<h2 id=\"_3-4-什么时候用原子性\"> 3.4 什么时候用原子性?</h2>\n<p>当涉及到多个线程对同一个数据进行操作的时候，为了保证在同一刻只有一个操作，就用 synchronized 修饰加锁🔐</p>\n<h2 id=\"_4-servlet线程安全问题思考\"> 4. Servlet线程安全问题思考</h2>\n<p>Servlet本身是无状态的，一个无状态的Servlet是绝对线程安全的，无状态对象设计也是解决线程安全问题的一种有效手段。</p>\n<p>所以，servlet是否线程安全是由它的实现来决定的，如果它内部的属性或方法会被多个线程改变，它就是线程不安全的，反之，就是线程安全的。</p>\n<p>在一个无状态的情况下，是不存在线程安全问题的，即使存在那也是跟它的实现类相关</p>\n<p>在Servlet中避免使用实例变量是保证Servlet线程安全的最佳选择。</p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1608963968000.png",
      "date_published": "2021-12-25T09:26:08.000Z",
      "date_modified": "2022-01-04T14:58:20.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "开个工厂造线程",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/java/%E7%BA%BF%E7%A8%8B%E5%B7%A5%E5%8E%82/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/java/%E7%BA%BF%E7%A8%8B%E5%B7%A5%E5%8E%82/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n<h1 id=\"线程工厂\"> 线程工厂</h1>\n<p>线程是Java里面很重要的一个概念，具体体现就是Thread这个类。我们平时最常用的创建线程就是在用Executors来创建线程池。在前面的章节\n也可以看到，创建线程池时候有一个入参就是线程工厂，ThreadFactory这个类。那么这个类具体有什么用呢? 其实就是为了统一在创建线程时设置一些参数，\n如是否守护线程。线程一些特性等，如优先级，名称。</p>\n<div><pre><code>\t<span>/**\n\t * @param threadFactory 线程工厂\n     */</span>\n      <span>public</span> <span>ThreadPoolExecutor</span><span>(</span><span>int</span> corePoolSize<span>,</span>\n                                 <span>int</span> maximumPoolSize<span>,</span>\n                                 <span>long</span> keepAliveTime<span>,</span>\n                                 <span>TimeUnit</span> unit<span>,</span>\n                                 <span>BlockingQueue</span><span><span>&lt;</span><span>Runnable</span><span>></span></span> workQueue<span>,</span>\n                                 <span>ThreadFactory</span> threadFactory<span>)</span> <span>{</span>\n           <span>this</span><span>(</span>corePoolSize<span>,</span> maximumPoolSize<span>,</span> keepAliveTime<span>,</span> unit<span>,</span> workQueue<span>,</span>\n                threadFactory<span>,</span> defaultHandler<span>)</span><span>;</span>\n       <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h1 id=\"自定义\"> 自定义</h1>\n<p>所谓线程工厂其实就是创建线程使用的。正常情况下我们创建线程是下面这样的。</p>\n<div><pre><code>  <span>Thread</span> ret <span>=</span> <span>new</span> <span>Thread</span><span>(</span>runnable<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>但是线程的构造其实并不是只有一个,它有一个线程组的概念,另外也可以给每个线程去设置一个名字。这样的目的是可以通过名字就能辨认是什么线程在执行。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1599299678000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>那么我们就看下这里面怎么实现的,其实非常简单。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>NamedThreadFactory</span> <span>implements</span> <span>ThreadFactory</span> <span>{</span>\n\n  <span>protected</span> <span>static</span> <span>final</span> <span>AtomicInteger</span> POOL_SEQ <span>=</span> <span>new</span> <span>AtomicInteger</span><span>(</span><span>1</span><span>)</span><span>;</span>\n\n  <span>protected</span> <span>final</span> <span>AtomicInteger</span> mThreadNum <span>=</span> <span>new</span> <span>AtomicInteger</span><span>(</span><span>1</span><span>)</span><span>;</span>\n\n  <span>protected</span> <span>final</span> <span>String</span> mPrefix<span>;</span>\n\n  <span>protected</span> <span>final</span> <span>boolean</span> mDaemon<span>;</span>\n\n  <span>protected</span> <span>final</span> <span>ThreadGroup</span> mGroup<span>;</span>\n\n  <span>public</span> <span>NamedThreadFactory</span><span>(</span><span>)</span> <span>{</span>\n    <span>this</span><span>(</span><span>\"pool-\"</span> <span>+</span> POOL_SEQ<span>.</span><span>getAndIncrement</span><span>(</span><span>)</span><span>,</span> <span>false</span><span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>public</span> <span>NamedThreadFactory</span><span>(</span><span>String</span> prefix<span>)</span> <span>{</span>\n    <span>this</span><span>(</span>prefix<span>,</span> <span>false</span><span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>public</span> <span>NamedThreadFactory</span><span>(</span><span>String</span> prefix<span>,</span> <span>boolean</span> daemon<span>)</span> <span>{</span>\n    mPrefix <span>=</span> prefix <span>+</span> <span>\"-thread-\"</span><span>;</span>\n    mDaemon <span>=</span> daemon<span>;</span>\n    <span>SecurityManager</span> s <span>=</span> <span>System</span><span>.</span><span>getSecurityManager</span><span>(</span><span>)</span><span>;</span>\n    mGroup <span>=</span> <span>(</span>s <span>==</span> <span>null</span><span>)</span> <span>?</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getThreadGroup</span><span>(</span><span>)</span> <span>:</span> s<span>.</span><span>getThreadGroup</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>@Override</span>\n  <span>public</span> <span>Thread</span> <span>newThread</span><span>(</span><span>Runnable</span> runnable<span>)</span> <span>{</span>\n    <span>//就是给线程创建了一个名字和指定了一个线程组</span>\n    <span>String</span> name <span>=</span> mPrefix <span>+</span> mThreadNum<span>.</span><span>getAndIncrement</span><span>(</span><span>)</span><span>;</span>\n    <span>Thread</span> ret <span>=</span> <span>new</span> <span>Thread</span><span>(</span>mGroup<span>,</span> runnable<span>,</span> name<span>,</span> <span>0</span><span>)</span><span>;</span>\n    ret<span>.</span><span>setDaemon</span><span>(</span>mDaemon<span>)</span><span>;</span>\n    <span>return</span> ret<span>;</span>\n  <span>}</span>\n\n  <span>public</span> <span>ThreadGroup</span> <span>getThreadGroup</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> mGroup<span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><p>如此而已,线程工厂就是这样。</p>\n",
      "image": "https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png",
      "date_published": "2021-12-25T09:26:08.000Z",
      "date_modified": "2022-01-04T14:58:20.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "给线程归归类",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/java/%E7%BA%BF%E7%A8%8B%E7%BB%84/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/java/%E7%BA%BF%E7%A8%8B%E7%BB%84/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n<h1 id=\"线程组\"> 线程组</h1>\n<p>可以把线程归属到某一个线程组中，线程组中可以有线程对象，也可以有线程组，组中还可以有线程，这样的组织结构有点类似于树的形式，如图所示.</p>\n<p>线程组的作用是：可以批量管理线程或线程组对象，有效地对线程或线程组对象进行组织\n<img src=\"https://img.springlearn.cn/blog/learn_1599301362000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>线程组提供对组内的线程的管理能力,如我们可以用一个线程组里面的线程去执行任务,任何一个任务失败,就把所有组内的线程都给中断。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>MThreadGroup</span> <span>extends</span> <span>ThreadGroup</span> <span>{</span>\n    <span>public</span> <span>MThreadGroup</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>\n        <span>super</span><span>(</span>s<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>MThreadGroup</span><span>(</span><span>ThreadGroup</span> threadGroup<span>,</span> <span>String</span> s<span>)</span> <span>{</span>\n        <span>super</span><span>(</span>threadGroup<span>,</span> s<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>uncaughtException</span><span>(</span><span>Thread</span> thread<span>,</span> <span>Throwable</span> throwable<span>)</span> <span>{</span>\n        <span>//任何一个线程异常就讲所有组内的线程中断</span>\n        thread<span>.</span><span>getThreadGroup</span><span>(</span><span>)</span><span>.</span><span>interrupt</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div>",
      "image": "https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png",
      "date_published": "2021-12-25T09:26:08.000Z",
      "date_modified": "2022-01-04T14:58:20.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "线程池扫盲",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/java/%E7%BA%BF%E7%A8%8B%E6%B1%A0/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/java/%E7%BA%BF%E7%A8%8B%E6%B1%A0/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n<blockquote>\n<p>[!TIP]\n本篇文章通读时间大概3分钟,希望在三分钟内的讲解，对你有所帮助，\n一定要认真看并思考，好了。废话不多数，直接上干货,本节内容我们讲\n的是Java的线程池,在讲之前我们首先看一下有哪些线程池，这些线程池\n我们不过多讲解,因为我们的关注点是他们是如何实现的,和其运行的原理。</p>\n</blockquote>\n<h1 id=\"一、常用线程池列表\"> 一、常用线程池列表</h1>\n<p>这部分内容,只是帮助你回顾一下线程池的知识，大家重点看方法内的实现</p>\n<p>1、构造一个固定线程数目的线程池，配置的corePoolSize与maximumPoolSize大小相同，同时使用了一个无界LinkedBlockingQueue存放阻塞任务，因此多余的任务将存在再阻塞队列，不会由RejectedExecutionHandler处理</p>\n<div><pre><code>    <span>public</span> <span>static</span> <span>ExecutorService</span> <span>newFixedThreadPool</span><span>(</span><span>int</span> nThreads<span>)</span> <span>{</span>\n        <span>return</span> <span>new</span> <span>ThreadPoolExecutor</span><span>(</span>nThreads<span>,</span> nThreads<span>,</span>\n                                      <span>0L</span><span>,</span> <span>TimeUnit</span><span>.</span>MILLISECONDS<span>,</span>\n                                      <span>new</span> <span>LinkedBlockingQueue</span><span><span>&lt;</span><span>Runnable</span><span>></span></span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>2、构造一个缓冲功能的线程池，配置corePoolSize=0，maximumPoolSize=Integer.MAX_VALUE，keepAliveTime=60s,以及一个无容量的阻塞队列 SynchronousQueue，因此任务提交之后，将会创建新的线程执行；线程空闲超过60s将会销毁</p>\n<div><pre><code>    <span>public</span> <span>static</span> <span>ExecutorService</span> <span>newCachedThreadPool</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>new</span> <span>ThreadPoolExecutor</span><span>(</span><span>0</span><span>,</span> <span>Integer</span><span>.</span>MAX_VALUE<span>,</span>\n                                      <span>60L</span><span>,</span> <span>TimeUnit</span><span>.</span>SECONDS<span>,</span>\n                                      <span>new</span> <span>SynchronousQueue</span><span><span>&lt;</span><span>Runnable</span><span>></span></span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>3、构造一个只支持一个线程的线程池，配置corePoolSize=maximumPoolSize=1，无界阻塞队列LinkedBlockingQueue；保证任务由一个线程串行执行</p>\n<div><pre><code>    <span>public</span> <span>static</span> <span>ExecutorService</span> <span>newSingleThreadExecutor</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>new</span> <span>FinalizableDelegatedExecutorService</span>\n            <span>(</span><span>new</span> <span>ThreadPoolExecutor</span><span>(</span><span>1</span><span>,</span> <span>1</span><span>,</span>\n                                    <span>0L</span><span>,</span> <span>TimeUnit</span><span>.</span>MILLISECONDS<span>,</span>\n                                    <span>new</span> <span>LinkedBlockingQueue</span><span><span>&lt;</span><span>Runnable</span><span>></span></span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>4、构造有定时功能的线程池，配置corePoolSize，无界延迟阻塞队列DelayedWorkQueue；有意思的是：maximumPoolSize=Integer.MAX_VALUE，由于DelayedWorkQueue是无界队列，所以这个值是没有意义的</p>\n<div><pre><code>    <span>/**\n     * Creates a thread pool that can schedule commands to run after a\n     * given delay, or to execute periodically.\n     * @param corePoolSize the number of threads to keep in the pool,\n     * even if they are idle\n     * @return a newly created scheduled thread pool\n     * @throws IllegalArgumentException if {@code corePoolSize &lt; 0}\n     */</span>\n    <span>public</span> <span>static</span> <span>ScheduledExecutorService</span> <span>newScheduledThreadPool</span><span>(</span><span>int</span> corePoolSize<span>)</span> <span>{</span>\n        <span>return</span> <span>new</span> <span>ScheduledThreadPoolExecutor</span><span>(</span>corePoolSize<span>)</span><span>;</span>\n    <span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h1 id=\"二、threadpoolexecutor\"> 二、ThreadPoolExecutor</h1>\n<p>相信大家从上面的众多线程池中都已经看到了这个类,因为上面的线程池底层的构造都是由这个类创建的,</p>\n<p>那么我们就开始研究这个类</p>\n<div><pre><code><span>/**\n * @since 1.5\n * @author Doug Lea\n */</span>\n<span>public</span> <span>class</span> <span>ThreadPoolExecutor</span> <span>extends</span> <span>AbstractExecutorService</span> <span>{</span>\n\t<span>.</span><span>.</span><span>.</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>首先看一下构造方法，关于注释一定要好好看，每个参数都理解了，那么你就弄懂了</p>\n<div><pre><code>\n<span>/**\n     *\n     * @param corePoolSize 核心线程池大小\n     * @param maximumPoolSize 线程池最大容量\n     * @param keepAliveTime 线程池空闲时，线程存活时间\n     * @param unit 时间单位\n     * @param workQueue 工作队列\n\t * @param threadFactory 线程工厂\n     * @throws IllegalArgumentException if one of the following holds:&lt;br>\n     *         {@code corePoolSize &lt; 0}&lt;br>\n     *         {@code keepAliveTime &lt; 0}&lt;br>\n     *         {@code maximumPoolSize &lt;= 0}&lt;br>\n     *         {@code maximumPoolSize &lt; corePoolSize}\n     * @throws NullPointerException if {@code workQueue} is null\n     */</span>\n      <span>public</span> <span>ThreadPoolExecutor</span><span>(</span><span>int</span> corePoolSize<span>,</span>\n                                 <span>int</span> maximumPoolSize<span>,</span>\n                                 <span>long</span> keepAliveTime<span>,</span>\n                                 <span>TimeUnit</span> unit<span>,</span>\n                                 <span>BlockingQueue</span><span><span>&lt;</span><span>Runnable</span><span>></span></span> workQueue<span>,</span>\n                                 <span>ThreadFactory</span> threadFactory<span>)</span> <span>{</span>\n           <span>this</span><span>(</span>corePoolSize<span>,</span> maximumPoolSize<span>,</span> keepAliveTime<span>,</span> unit<span>,</span> workQueue<span>,</span>\n                threadFactory<span>,</span> defaultHandler<span>)</span><span>;</span>\n       <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h1 id=\"三、构造参数详解\"> 三、构造参数详解</h1>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>corePoolSize</td>\n<td>核心的线程数</td>\n</tr>\n<tr>\n<td>maximumPoolSize</td>\n<td>最大线程池就是说你定义的线程池运行创建的最大线程数量</td>\n</tr>\n<tr>\n<td>keepAliveTime</td>\n<td>空闲时间回收，当这个时间后还没有任务执行就将线程回收</td>\n</tr>\n<tr>\n<td>unit</td>\n<td>单位,控制上面时间的单位，可以为秒，或者分钟</td>\n</tr>\n<tr>\n<td>workQueue</td>\n<td>核心线程都已经去执行任务但是，任务还有，那么久先放到这个队列里，就相当于集合</td>\n</tr>\n<tr>\n<td>threadFactory</td>\n<td>创建线程用户的线程工厂,里面只有一个方法就是newThread，你可以自定义线程名</td>\n</tr>\n</tbody>\n</table>\n<p><font color=red>上面的文字可能你看的不太明白，小编这里画了一个图，大家仔细看看 </font></p>\n<p>这张图是小编之前画的，但是头条压缩了，导致图不太清楚，大家看到字就行了</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1640316132000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_1-执行顺序\"> 1. 执行顺序</h2>\n<ol>\n<li>首先交给核心线程数来执行corePoolSize</li>\n<li>如果核心都用完了，就放到workQueue队列里面</li>\n<li>当队列和核心线程数都满了，就继续创建线程，直到等于maximumPoolSize为止</li>\n<li>当任务已经塞不下了，就开始执行拒绝策略(下一篇讲)</li>\n</ol>\n",
      "image": "https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png",
      "date_published": "2021-12-25T09:26:08.000Z",
      "date_modified": "2022-01-04T14:58:20.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Java异常体系",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/java2/Java%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/java2/Java%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/learn_1589293715000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>知己知彼方能百战不殆,在小编初学Java时候特别怕程序报异常,经常会因为异常不知所措,相信这个问题应该是所有\n初学者都会有的心理感受;如果你也有这种感受,那么只有一种解决方法:\n迎难而上,攻克Java异常体系,长痛不如短痛,只要清楚了Java的异常体系,就不会再有这种感受了。下面跟着小编来窥探Java的异常体系吧。</p>\n<h1 id=\"一、java异常体系其实很简单\"> 一、Java异常体系其实很简单</h1>\n<p>其实Java的异常体系是非常简单的,简单到只要你看过本文就能明白百分之八九十的样子。当你清楚了Java的异常体系\n那么在遇到项目执行异常的时候,基本看报错的异常就大概明白问题出在哪里,遇到的错误多了,就成长了,处理的问题就是\n你未来在技术路上所积累的财富。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589294764000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>在Java的异常体系中 <code>Throwable</code> 我们可以理解为是一个根异常,即所有的异常都是它的子类</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589295509000.png\" alt=\"\" loading=\"lazy\"></p>\n<h1 id=\"二、error\"> 二、Error</h1>\n<p>前面我们说了Java的异常体系中 <code>Throwable</code> 可以理解是一个根异常,那么 <code>Error</code> 就是这个根节点的一个子节点。\n<code>Error</code> 类对象由 <code>Java</code> 虚拟机生成并抛出，大多数错误与代码编写者所执行的操作无关。程序无法处理的异常，一般伴随者jvm虚拟机停止，或者断电之类\n这种问题，是无法通过程序来解决的。</p>\n<p><strong>这种异常基本很少,如果遇到也不要慌,跟你的业务逻辑没有关系,顶多是Java代码写的有问题,只要不是业务问题其实大多都能先通过重启解决;\n但是假如项目还未上线,只是在开发过程中出现这种问题一定要弄清楚原因,是那一部分代码编写异常导致的,否则上线可能有重大隐患</strong></p>\n<p><strong>经验教学:</strong></p>\n<ol>\n<li>如果是在项目系统过程中遇到这种问题,可能是因为Jar包冲突导致的。</li>\n<li>如果是在项目运行过程中遇到这种问题,可能是因为对象创建过多没有释放,导致堆栈溢出。这个时候就要看GC是否频繁,然后对堆栈日志进行分析,看存在最多的对象是哪一个,然后分析代码解决。</li>\n</ol>\n<h1 id=\"三、exception\"> 三、Exception</h1>\n<p><code>Exception</code> 异常时我们平时在开发中遇到最多，其实 <code>Exception</code> 也分为两种即:</p>\n<ol>\n<li><code>checkException</code> 编译异常，这种异常，是哪些没有遵守java语言规则，容易看出和解决的</li>\n<li><code>uncheckException</code> 运行异常，运行异常，具有不确定性，往往难以排查，包括处理逻辑问题。</li>\n</ol>\n<p>然而 <code>checkException</code> 和 <code>uncheckException</code> 其实只是一个概念,并没有对应的 <code>Java异常类</code>。我们基本可以忽略\n<code>checkException</code> 因为这种异常基本现在的编译器都会给我们做了，我们在写代码时候就会实时的给我提示错误了。我们\n只用关心 <code>uncheckException</code>即可。</p>\n<p><strong>uncheckException</strong></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589297073000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><code>RuntimeException</code> + <code>Error</code> 和其子类都是属于 <code>uncheckException</code></p>\n<p>前面我们已经对 <code>Error</code> 做了说明，现在就主要来看下 <code>RuntimeException</code>。 <code>RuntimeException</code> 从名字来看就是\n运行异常,所谓运行异常就是可能在程序运行过程中发生的异常,这种异常一般是可以通过代码逻辑进行处理的。\n我们举例一个例子,我们都知道0不能作为除数。但是假如在下面这个代码中</p>\n<div><pre><code>public class Tester {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        System.out.print(&quot;请输入被除数a:&quot;);\n        int a = sc.nextInt();\n        System.out.print(&quot;请输入除数b:&quot;);\n        int b = sc.nextInt();\n        System.out.println(&quot;a/b=&quot; + a / b);\n    }\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>当输入a=8,b=2,那么结果就是4。</p>\n<p><img src=\"https://i02piccdn.sogoucdn.com/8206a4441e0386c3\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>假如我们输入b=0呢?</strong></p>\n<p>学过数学都知道0不能做除数,程序也不运行你这么输入,但是却不能阻止你,只能通过报错的方式来告诉你。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589298143000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>那么我们就要对这个异常进行处理,当发现有这个异常就在控制台来提醒用户。那么代码就会变成这样</p>\n<div><pre><code>public class Tester {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        System.out.print(&quot;请输入被除数a:&quot;);\n        int a = sc.nextInt();\n        System.out.print(&quot;请输入除数b:&quot;);\n        int b = sc.nextInt();\n        try {\n            System.out.println(&quot;a/b=&quot; + a / b);\n        } catch (ArithmeticException ate) {\n            //对算术异常进行捕捉\n            System.err.println(&quot;0不能作为除数,请输入不为0的任意数&quot;);\n        }\n    }\n}\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>当出现算术异常直接提示: &quot;0不能作为除数,请输入不为0的任意数&quot;\n<img src=\"https://img.springlearn.cn/blog/learn_1589298261000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>那么像这种程序中无可避免会出现,且又能通过逻辑来处理的异常就是运行异常。运行异常一般都可以正常运行,只是在特定情况下会导致异常发生。\n像这面这个例子,我们只要看到 <code>ArithmeticException</code> 就知道是算术异常。所以只要我们对运行异常类有一个认识，其实就能解决大多数的程序问题了。\n下面我们来看下运行异常都要有哪些类把。</p>\n<p><img src=\"https://i03piccdn.sogoucdn.com/f960e6a461d218d2\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>只要对下面运行异常类进行熟悉了,基本就清楚掌握了Java的异常体系了</strong></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589299119000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589299523000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>以上就是常见的运行异常类,当然Java中还有很多不常见的异常类。剩下的我们就可以在日常工作中去学习了。</p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1589293715000.png",
      "date_published": "2021-12-25T09:26:08.000Z",
      "date_modified": "2021-12-25T09:26:08.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "hehe",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/java2/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/java2/",
      "content_html": "<h1 id=\"hehe\"> hehe</h1>\n",
      "date_published": "2021-12-25T09:26:08.000Z",
      "date_modified": "2021-12-25T09:26:08.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "函数式编程",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/java2/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/java2/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/",
      "content_html": "<div><p>提示</p>\n<p>Java8所有的新特性基本基于函数式编程的思想，函数式编程给Java带来了注入了新鲜的活力。\n函数式编程其实并不是很难，小编在学习函数式编程时候刚开始一头雾水，最后仔细观察就发现了其中的小窍门，读了本篇文章如果还没有掌握，就算我输了\n加我微信: lxchinesszz 找我一对一教学</p>\n</div>\n<h1 id=\"函数式编程\"> 函数式编程</h1>\n<h2 id=\"一、lambda表达式\"> 一、Lambda表达式</h2>\n<p><strong>注意</strong>: 以下方法都可以使用表达式来进行缩写</p>\n<p>我们来看Java中如何来定义一个方法</p>\n<h3 id=\"_1-语法\"> 1. 语法</h3>\n<p><code>()-&gt;{}</code></p>\n<p>其中小括号里面可以放入参，大括号就是方法体，里面也允许有返回值。</p>\n<p><strong>当方法体中只有返回值而没有其他语句时候，大括号和 <code>return</code> 关键字都可以省略不写。</strong></p>\n<h3 id=\"_2-方法引用\"> 2. 方法引用</h3>\n<p><em>只要用.引用不报错的，都可以将.换成:</em></p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>语法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1、引用静态方法</td>\n<td>ClassName::staticMethodName</td>\n</tr>\n<tr>\n<td>2、引用构造函数</td>\n<td>ClassName::new</td>\n</tr>\n<tr>\n<td>3、引用特定类型的实例方法</td>\n<td>ClassName::instanceMethodName</td>\n</tr>\n<tr>\n<td>4、引用特定对象的实例方法</td>\n<td>objectName::instanceMethodName</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"二、java8新增函数式接口\"> 二、Java8新增函数式接口</h2>\n<h3 id=\"_1-predicate接口\"> 1. Predicate接口</h3>\n<p>Predicate 接口只有一个参数，返回boolean类型。该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）</p>\n<div><pre><code>Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; 0;\n</code></pre>\n<div><span>1</span><br></div></div><p>根据前面的语法我们知道小括号里面可以放入参，大括号里面放出参，当大括号里面只有返回值时候，大括号和 <code>return</code> 关键字也可以省略。如上。</p>\n<h3 id=\"_2-function-接口\"> 2. Function 接口</h3>\n<p>Function 接口有一个参数并且返回一个结果，并附带了一些可以和其他函数组合的默认方法（compose, andThen）：</p>\n<div><pre><code>Function&lt;Integer, Integer&gt; function = (x) -&gt; 2 * x;\n</code></pre>\n<div><span>1</span><br></div></div><p>同理，这个接口有一个入参和出参，如果返回体重不包含其他逻辑，只有一个返回值，大括号和 <code>return</code> 关键字也可以省略。如上。</p>\n<h3 id=\"_3-supplier-接口\"> 3. Supplier 接口</h3>\n<p>Supplier 接口返回一个任意范型的值，和Function接口不同的是该接口没有任何参数</p>\n<div><pre><code>public class Main{\n    public static void main(String[] args) {\n        //构造方法\n        Supplier&lt;Main&gt; supplier = () -&gt; new Main();\n        Supplier&lt;Main&gt; mainSupplier = Main::new;\n        Supplier&lt;Main&gt; mainSupplier1 = Main::staticMethod;\n    }\n    private static Main staticMethod() {\n        return new Main();\n    }\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>因为没有入参，所以小括号里面什么都不用写。当遇到这种情况，同样可以用上面其他两种来替换</p>\n<h3 id=\"_4-consumer-接口\"> 4. Consumer 接口</h3>\n<p>Consumer 是一个只有入参，但是无出参的接口。</p>\n<div><pre><code>public class Main {\n    public static void main(String[] args) {\n        List&lt;String&gt; dataList = Arrays.asList(&quot;1&quot;, &quot;2&quot;);\n\n        //特定类的静态方法\n        dataList.forEach(Main::staticMethod);\n        dataList.forEach((x) -&gt; System.out.println(x));\n        dataList.forEach(System.out::println);\n\n    }\n    private static void staticMethod(String name) {\n        System.out.println(&quot;对象静态方法引用:&quot; + name);\n    }\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h2 id=\"三、快速记忆\"> 三、快速记忆</h2>\n<p>虽然新增的函数式接口并不多，但是想要一次性死记住，还是有一点点的难度。小编的学习方式是\n理解这记忆。</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>简记</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1、Predicate</td>\n<td>条件类型</td>\n</tr>\n<tr>\n<td>2、Supplier</td>\n<td>无入参，有出参</td>\n</tr>\n<tr>\n<td>3、Function</td>\n<td>有入参，有出参</td>\n</tr>\n<tr>\n<td>4、Consumer</td>\n<td>有入参，无出参</td>\n</tr>\n</tbody>\n</table>\n<p>最后求关注,求订阅,谢谢你的阅读!</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589360371000.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1589360371000.png",
      "date_published": "2021-12-25T09:26:08.000Z",
      "date_modified": "2021-12-25T09:26:08.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "线程安全之原子操作",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/java/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/java/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/learn_1589361031000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n<p><strong>原子特性: 原子是最小的粒子,不可再分</strong></p>\n<p>这并不是一个化学课,而是巧妙的借用了化学上的一个概念,即原子是最小的粒子,不可再分;原子操作也是不能再分的操作;\n为了能把这个讲明白,下文基本都是大白话,其实Java本来并不是很难,而是总有一些人喜欢把简单的概念给复杂化。小编不喜欢\n那种说辞,所以尽量简单易懂。如有问题,欢迎提出问题。共同交流进步,最后谢谢你的阅读。</p>\n<hr>\n<h1 id=\"举例说明原子操作重要性\"> 举例说明原子操作重要性</h1>\n<p>在很多场景中我们需要我们的操作是原子特性的,如果我们写的程序都是单线程的,其实我们没必要考虑原子操作。但是假如\n我们写多线程操作,或者是在Web服务中来更新对象属性,那么就必须要来考虑原子操作问题了。</p>\n<p>举一个🌰例子A:</p>\n<div><pre><code>int a = 1;\n</code></pre>\n<div><span>1</span><br></div></div><p>可以看到程序对变量 <code>a</code> 操作,其实是有多个步骤进行的。在单线程环境下基本不会发生任何问题\n<img src=\"https://img.springlearn.cn/blog/learn_1589372995000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>举一个🌰例子B(单线程操作):</p>\n<div><pre><code>public class Tester {\n\n    private static Integer a = 1;\n\n    private static AtomicInteger aa = new AtomicInteger(1);\n\n    private static void restore() {\n        a = 1;\n        aa = new AtomicInteger(1);\n    }\n\n    public static void main(String[] args) {\n        for (int i = 0; i &lt; 10; i++) {\n            test(&quot;第&quot; + i + &quot;次&quot;);\n            restore();\n        }\n    }\n\n    private static void test(String str) {\n        for (int i = 1; i &lt;= 1000; i++) {\n            new Thread(() -&gt; a = a + 1).start();\n            new Thread(() -&gt; aa.addAndGet(1)).start();\n        }\n        System.out.print(str + &quot;常规操作a=&quot; + a);\n        System.out.println(&quot; &lt;===&gt; &quot;+str+&quot;原子操作操作aa=&quot; + aa);\n    }\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>规律:</p>\n<div><pre><code>        /**\n         * i              i+1\n         * 1: a = 1 + 1 = 2\n         * 2: a = 2 + 1 = 3\n         * 3: a = 3 + 1 = 4\n         * 4: a = 4 + 1 = 5\n         * 5: a = 5 + 1 = 6\n         * 6: a = 6 + 1 = 7\n         * 7: a = 7 + 1 = 8\n         * 8: a = 8 + 1 = 9\n         * 9: a = 9 + 1 = 10\n         * 10:a = 10 + 1 = 11\n         */\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>如上面代码变量a是基本类型,变量aa是原子类型,正常情况对a或者aa进行1000次操作结果都应该是\n<code>1001</code>。正常情况我们可以理解是单线程操作。结果也是没有问题的。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589380382000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>举一个🌰例子C(多线程操作):</p>\n<div><pre><code>public class Tester {\n\n    private static Integer a = 1;\n\n    private static AtomicInteger aa = new AtomicInteger(1);\n\n    private static void restore() {\n        a = 1;\n        aa = new AtomicInteger(1);\n    }\n\n    public static void main(String[] args) throws Exception {\n        for (int i = 0; i &lt; 10; i++) {\n            test(&quot;第&quot; + i + &quot;次&quot;);\n            restore();\n        }\n    }\n\n    private static void test(String str) throws Exception {\n        for (int i = 1; i &lt;= 100; i++) {\n            new Thread(() -&gt; a = a + 1).start();\n            new Thread(() -&gt; a = a + 1).start();\n\n            new Thread(() -&gt; aa.addAndGet(1)).start();\n            new Thread(() -&gt; aa.addAndGet(1)).start();\n            Thread.sleep(1);\n        }\n        System.out.print(str + &quot;常规操作a=&quot; + a);\n        System.out.println(&quot; &lt;===&gt; &quot; + str + &quot;原子操作操作aa=&quot; + aa);\n    }\n    \n}\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><p>规律:</p>\n<div><pre><code>    /**\n     * i          2 * i + 1\n     * 1: a = 1 + 1 + 1 = 3\n     * 2: a = 3 + 1 + 1 = 5\n     * 3: a = 5 + 1 + 1 = 7\n     * 4: a = 7 + 1 + 1 = 9\n     * 5:                 11\n     * 6:                 13\n     * 7:                 15\n     * 8:                 17\n     * 9:                 19\n     * 10:                21\n     */\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>多线程环境下操作会不会有问题呢? 出现了问题。我们看到使用常规操作的a变量出现了数据不一致情况。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589375176000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>实际上当循环的次数越多,出现错误的几率就越大,如下我们循环了1000次。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589375386000.png\" alt=\"\" loading=\"lazy\"></p>\n<h1 id=\"问题分析\"> 问题分析</h1>\n<p>我们思考为什么基本类型进行多线程操作时候会出现这种情况呢? 其实问题答案最开始已经说了。 我们通过这张图\n就可以找到原因。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589372995000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>对变量的每次操作其实都有3个步骤</p>\n<ol>\n<li>读取变量值</li>\n<li>变量值操作</li>\n<li>变量重新赋值。</li>\n</ol>\n<p>我们模拟一下错误的原因。</p>\n<p>当A线程读取a=1,并对1+1。但是还未对变量重新赋值a=2的时候，\nB线程也读取了A还未赋值的变量,此时变量还是1,那么B线程因为读取了还未更新的数据,所以也做1+1的操作。然后B对a\n重新赋值了此时a=2,是B赋值的。这个时候A因为已经执行完了前两个步骤,最后也重新赋值了a=2。</p>\n<p>这样数据就更新丢了。这就是因为数据更新不是原子性从而导致的问题。</p>\n<p>因为数据更新丢了,所以出现了。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589380830000.png\" alt=\"\" loading=\"lazy\"></p>\n<h1 id=\"如何解决这种问题\"> 如何解决这种问题</h1>\n<p>如何解决这种问题,其实很简单只要我们保证我们的操作是原子操作即可,简单来说就是将更新的三个步骤合并成一个步骤即可,在Java中JDK已经为我们提供了很多的\n原子操作每一个基本类型都对应一个原子操作。</p>\n<h2 id=\"原子基础类\"> 原子基础类</h2>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589378016000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>原子基础类API</strong></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589378409000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"原子数组类\"> 原子数组类</h2>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589378718000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>原子更新数组API</strong></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589378583000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"原子引用类\"> 原子引用类</h2>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589379304000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>注意:</strong></p>\n<p>想要原子的更新字段，需要两个步骤：</p>\n<p>1.每次使用的时候必须使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类和属性</p>\n<p>2.更新类的字段（属性）必须使用public volatile修饰符</p>\n<h1 id=\"最后我们看一下原子操作的原理\"> 最后我们看一下原子操作的原理</h1>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589379629000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>最后求关注,求订阅,谢谢你的阅读!</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589360371000.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1589361031000.png",
      "date_published": "2021-12-25T09:26:08.000Z",
      "date_modified": "2022-01-04T14:58:20.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "maven-resources-plugin",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/maven/maven-resources-plugin/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/maven/maven-resources-plugin/",
      "content_html": "<blockquote>\n<p>maven-resources-plugin</p>\n</blockquote>\n<p>资源插件处理将项目资源复制到输出目录。有两种不同的资源：主要资源和测试资源。区别在于主要资源是与主要源代码相关联的资源，而测试资源与测试源代码相关联。</p>\n<p>因此，这允许主要源代码及其单元测试的资源分离。</p>\n<p>从 2.3 版开始，这个插件使用Maven Filtering共享组件来过滤资源。</p>\n<p><img src=\"https://maven.apache.org/images/maventxt_logo_200.gif\" alt=\"\" loading=\"lazy\"></p>\n<p><a href=\"https://maven.apache.org/plugins/maven-resources-plugin/\" target=\"_blank\" rel=\"noopener noreferrer\">maven-resources-plugin官网</a></p>\n<h2 id=\"主要功能\"> 主要功能</h2>\n<ul>\n<li>\n<p>resources:resources\n将主源代码的资源复制到主输出目录。\n这个目标通常会自动执行，因为它默认绑定到流程资源生命周期阶段。它总是使用 project.build.resources 元素来指定资源，并且默认使用 project.build.outputDirectory 来指定复制目标。</p>\n</li>\n<li>\n<p>resources:testResources\n将测试源代码的资源复制到测试输出目录。\n这个目标通常会自动执行，因为它默认绑定到 process-test-resources 生命周期阶段。它总是使用 project.build.testResources 元素来指定资源，并且默认使用 project.build.testOutputDirectory 来指定复制目标。</p>\n</li>\n<li>\n<p>resources:copy-resources\n将资源复制到输出目录。此目标要求您配置要复制的资源，并指定 outputDirectory。</p>\n</li>\n</ul>\n",
      "image": "https://maven.apache.org/images/maventxt_logo_200.gif",
      "date_published": "2021-12-21T05:46:37.000Z",
      "date_modified": "2022-03-24T14:34:44.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "自定义布局",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/layout/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/layout/",
      "content_html": "<p>您可以使用带有 Markdown 支持的插槽来自定义页面布局。</p>\n<div><p>注意</p>\n<p>此处仅仅是一个演示，你应该自行根据需求添加样式。</p>\n\n\n</div>\n<template #page-top><p>页面顶部内容</p>\n</template><template #page-bottom><p>页面底部内容</p>\n</template><template #content-top><p>内容顶部内容</p>\n</template><template #content-bottom><p>内容底部内容</p>\n</template><template #navbar-start><p>导航栏起始内容</p>\n</template><template #navbar-center><p>导航栏中部内容</p>\n</template><template #navbar-end><p>导航栏末尾内容</p>\n</template><template #sidebar-top><p>侧边栏顶部内容</p>\n</template><template #sidebar-center><p>侧边栏中部内容</p>\n</template><template #sidebar-bottom><p>侧边栏底部内容</p>\n</template><p>更多详情，详见 <a href=\"https://vuepress-theme-hope.github.io/zh/guide/layout/custom/\" target=\"_blank\" rel=\"noopener noreferrer\">自定义布局</a>.</p>\n",
      "date_published": "2021-12-21T05:46:37.000Z",
      "date_modified": "2021-12-21T05:46:37.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "spring-boot-maven-plugin",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/maven/spring-boot-maven-plugin/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/maven/spring-boot-maven-plugin/",
      "content_html": "<blockquote>\n<p>spring-boot-maven-plugin</p>\n</blockquote>\n",
      "date_published": "2021-12-21T05:46:37.000Z",
      "date_modified": "2021-12-21T05:46:37.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "八阿哥的剑",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/other/bug/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/other/bug/",
      "content_html": "<p><strong>作者: 八阿哥的剑</strong></p>\n<p><em>博客: https://springlearn.cn</em></p>\n<div><p>一日一句毒鸡汤</p>\n<p>问世间钱为何物，只叫人生死相许。！😄</p>\n</div>\n<h2 id=\"java原生版本监控\"> Java原生版本监控</h2>\n<div><pre><code><span>public</span> <span>class</span> <span>JavaWatchAPI</span> <span>{</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>//第一步：取得WatchService</span>\n        <span>WatchService</span> watchService <span>=</span> <span>FileSystems</span><span>.</span><span>getDefault</span><span>(</span><span>)</span><span>.</span><span>newWatchService</span><span>(</span><span>)</span><span>;</span>\n        <span>//第二步：确定要监控的路径</span>\n        <span>Path</span> path <span>=</span> <span>Paths</span><span>.</span><span>get</span><span>(</span><span>\"/Users/liuxin/Github/nobug-learn-project/nobug-learn-01/src/main/java\"</span><span>)</span><span>;</span>\n\n        <span>//第三步：为本路径绑定WatchService，并确定监控的事件</span>\n        path<span>.</span><span>register</span><span>(</span>\n                watchService<span>,</span>\n                <span>// StandardWatchEventKinds.ENTRY_CREATE—当有新文件时触发。可能是创建了一个新文件</span>\n                <span>StandardWatchEventKinds</span><span>.</span>ENTRY_CREATE<span>,</span>\n                <span>// StandardWatchEventKinds.ENTRY_DELETE—当文件被删除、移动或重命名时触发</span>\n                <span>StandardWatchEventKinds</span><span>.</span>ENTRY_DELETE<span>,</span>\n                <span>// StandardWatchEventKinds.ENTRY_MODIFY—当文件被修改时触发。</span>\n                <span>StandardWatchEventKinds</span><span>.</span>ENTRY_MODIFY<span>)</span><span>;</span>\n        <span>// StandardWatchEventKinds.OVERFLOW—触发表示丢失或丢弃的事件。</span>\n        <span>WatchKey</span> key <span>=</span> <span>null</span><span>;</span>\n        <span>while</span> <span>(</span><span>(</span>key <span>=</span> watchService<span>.</span><span>take</span><span>(</span><span>)</span><span>)</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n            <span>for</span> <span>(</span><span>WatchEvent</span><span><span>&lt;</span><span>?</span><span>></span></span> event <span>:</span> key<span>.</span><span>pollEvents</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"事件\"</span> <span>+</span> event<span>.</span><span>kind</span><span>(</span><span>)</span> <span>+</span> <span>\"发生了，文件是：\"</span> <span>+</span> event<span>.</span><span>context</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>}</span>\n            key<span>.</span><span>reset</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><h2 id=\"common-io-工具包监控\"> Common IO 工具包监控</h2>\n<div><pre><code><span>package</span> <span>cn<span>.</span>github<span>.</span>chinesszz</span><span>;</span>\n\n<span>import</span> <span>org<span>.</span>apache<span>.</span>commons<span>.</span>io<span>.</span>filefilter<span>.</span></span><span>FileFilterUtils</span><span>;</span>\n<span>import</span> <span>org<span>.</span>apache<span>.</span>commons<span>.</span>io<span>.</span>monitor<span>.</span></span><span>FileAlterationListener</span><span>;</span>\n<span>import</span> <span>org<span>.</span>apache<span>.</span>commons<span>.</span>io<span>.</span>monitor<span>.</span></span><span>FileAlterationMonitor</span><span>;</span>\n<span>import</span> <span>org<span>.</span>apache<span>.</span>commons<span>.</span>io<span>.</span>monitor<span>.</span></span><span>FileAlterationObserver</span><span>;</span>\n<span>import</span> <span>org<span>.</span>junit<span>.</span></span><span>Test</span><span>;</span>\n\n<span>import</span> <span>java<span>.</span>io<span>.</span></span><span>File</span><span>;</span>\n<span>import</span> <span>java<span>.</span>util<span>.</span>concurrent<span>.</span></span><span>TimeUnit</span><span>;</span>\n\n<span>/**\n * @author liuxin\n * 2021/11/9 8:55 下午\n */</span>\n<span>public</span> <span>class</span> <span>CommonIOAPI</span> <span>{</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>File</span> directory <span>=</span> <span>new</span> <span>File</span><span>(</span><span>\"/Users/liuxin/Github/nobug-learn-project/nobug-learn-01/src/main/java\"</span><span>)</span><span>;</span>\n        <span>// 轮询间隔 5 秒</span>\n        <span>long</span> interval <span>=</span> <span>TimeUnit</span><span>.</span>SECONDS<span>.</span><span>toMillis</span><span>(</span><span>5</span><span>)</span><span>;</span>\n        <span>// 创建一个文件观察器用于处理文件的格式</span>\n        <span>FileAlterationObserver</span> observer <span>=</span> <span>new</span> <span>FileAlterationObserver</span><span>(</span>directory<span>,</span> <span>FileFilterUtils</span><span>.</span><span>and</span><span>(</span>\n                <span>FileFilterUtils</span><span>.</span><span>fileFileFilter</span><span>(</span><span>)</span><span>,</span> <span>FileFilterUtils</span><span>.</span><span>suffixFileFilter</span><span>(</span><span>\".txt\"</span><span>)</span><span>,</span>\n                <span>FileFilterUtils</span><span>.</span><span>prefixFileFilter</span><span>(</span><span>\"lx\"</span><span>)</span><span>)</span><span>)</span><span>;</span>\n        <span>// 设置文件变化监听器</span>\n        observer<span>.</span><span>addListener</span><span>(</span><span>new</span> <span>MyFileListener</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>FileAlterationMonitor</span> monitor <span>=</span> <span>new</span> <span>FileAlterationMonitor</span><span>(</span>interval<span>,</span> observer<span>)</span><span>;</span>\n        monitor<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>1</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>watchDir</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>File</span> directory <span>=</span> <span>new</span> <span>File</span><span>(</span><span>\"/Users/liuxin/Github/nobug-learn-project/nobug-learn-01/src/main/java\"</span><span>)</span><span>;</span>\n        <span>FileAlterationObserver</span> fileAlterationObserver <span>=</span> <span>new</span> <span>FileAlterationObserver</span><span>(</span>directory<span>,</span> <span>FileFilterUtils</span><span>.</span><span>and</span><span>(</span>\n                <span>FileFilterUtils</span><span>.</span><span>directoryFileFilter</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>\n        <span>long</span> interval <span>=</span> <span>TimeUnit</span><span>.</span>SECONDS<span>.</span><span>toMillis</span><span>(</span><span>5</span><span>)</span><span>;</span>\n        <span>// 设置文件变化监听器</span>\n        fileAlterationObserver<span>.</span><span>addListener</span><span>(</span><span>new</span> <span>MyFileListener</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>FileAlterationMonitor</span> monitor <span>=</span> <span>new</span> <span>FileAlterationMonitor</span><span>(</span>interval<span>,</span> fileAlterationObserver<span>)</span><span>;</span>\n        monitor<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        <span>while</span> <span>(</span><span>true</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>static</span> <span>final</span> <span>class</span> <span>MyFileListener</span> <span>implements</span> <span>FileAlterationListener</span> <span>{</span>\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>onStart</span><span>(</span><span>FileAlterationObserver</span> fileAlterationObserver<span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"monitor start scan files..\"</span><span>)</span><span>;</span>\n        <span>}</span>\n\n\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>onDirectoryCreate</span><span>(</span><span>File</span> file<span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>file<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\" director created.\"</span><span>)</span><span>;</span>\n        <span>}</span>\n\n\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>onDirectoryChange</span><span>(</span><span>File</span> file<span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>file<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\" director changed.\"</span><span>)</span><span>;</span>\n        <span>}</span>\n\n\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>onDirectoryDelete</span><span>(</span><span>File</span> file<span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>file<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\" director deleted.\"</span><span>)</span><span>;</span>\n        <span>}</span>\n\n\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>onFileCreate</span><span>(</span><span>File</span> file<span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>file<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\" created.\"</span><span>)</span><span>;</span>\n        <span>}</span>\n\n\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>onFileChange</span><span>(</span><span>File</span> file<span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>file<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\" changed.\"</span><span>)</span><span>;</span>\n        <span>}</span>\n\n\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>onFileDelete</span><span>(</span><span>File</span> file<span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>file<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\" deleted.\"</span><span>)</span><span>;</span>\n        <span>}</span>\n\n\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>onStop</span><span>(</span><span>FileAlterationObserver</span> fileAlterationObserver<span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"monitor stop scanning..\"</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br></div></div>",
      "date_published": "2021-12-21T05:46:37.000Z",
      "date_modified": "2022-01-04T14:58:20.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Maven基础入门",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/maven/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/maven/",
      "content_html": "<blockquote>\n<p>Maven 翻译为&quot;专家&quot;、&quot;内行&quot;，是 Apache 下的一个纯 Java 开发的开源项目。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。\nMaven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。\nMaven 也可被用于构建和管理各种项目，例如 C#，Ruby，Scala 和其他语言编写的项目。Maven 曾是 Jakarta 项目的子项目，现为由 Apache 软件基金会主持的独立 Apache 项目。</p>\n</blockquote>\n<h2 id=\"maven-默认插件\"> Maven 默认插件</h2>\n<p>已知 Maven 使用 plugin 来执行实际操作的，在默认情况下，Maven 会绑定以下几个插件来完成基本操作。</p>\n<table>\n<thead>\n<tr>\n<th>plugin</th>\n<th>function</th>\n<th>life cycle phase</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>maven-clean-plugin</td>\n<td>清理上一次执行创建的目标文件</td>\n<td>clean</td>\n</tr>\n<tr>\n<td>maven-resources-plugin</td>\n<td>处理源资源文件和测试资源文件</td>\n<td>resources,testResources</td>\n</tr>\n<tr>\n<td>maven-compiler-plugin</td>\n<td>编译源文件和测试源文件</td>\n<td>compile,testCompile</td>\n</tr>\n<tr>\n<td>maven-surefire-plugin</td>\n<td>执行测试文件</td>\n<td>test</td>\n</tr>\n<tr>\n<td>maven-jar-plugin</td>\n<td>创建 jar</td>\n<td>jar</td>\n</tr>\n<tr>\n<td>maven-install-plugin</td>\n<td>安装 jar，将创建生成的 jar 拷贝到 .m2/repository 下面</td>\n<td>install</td>\n</tr>\n<tr>\n<td>maven-deploy-plugin</td>\n<td>发布 jar</td>\n<td>deploy</td>\n</tr>\n</tbody>\n</table>\n<p>如果针对各个 plugin 有特殊配置的话，需要显示指定 plugin 和 属性配置。</p>\n<h2 id=\"maven-生命周期\"> Maven 生命周期</h2>\n<blockquote>\n<p>官网地址: http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html</p>\n</blockquote>\n<p>下面列出了default,clean和site生命周期的所有构建阶段，它们按照指定的时间点之前的顺序执行。</p>\n<p><code>mvn test -X</code> 查看debug日志</p>\n<div><pre><code>[DEBUG] Lifecycle clean -&gt; [pre-clean, clean, post-clean]\n[DEBUG] Lifecycle site -&gt; [pre-site, site, post-site, site-deploy]\n[DEBUG] Lifecycle default -&gt; [validate, initialize, generate-sources, process-sources, generate-resources, process-resources, compile, process-classes, generate-test-sources, process-test-sources, generate-test-resources, process-test-resources, test-compile, process-test-classes, test, prepare-package, package, pre-integration-test, integration-test, post-integration-test, verify, install, deploy]\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"default生命周期\"> default生命周期</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">阶段</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>validate</code></td>\n<td style=\"text-align:left\">验证项目是否正确并且所有必要的信息都可用。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>initialize</code></td>\n<td style=\"text-align:left\">初始化构建状态，例如设置属性或创建目录。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>generate-sources</code></td>\n<td style=\"text-align:left\">生成包含在编译中的任何源代码。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>process-sources</code></td>\n<td style=\"text-align:left\">处理源代码，例如过滤任何值。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>generate-resources</code></td>\n<td style=\"text-align:left\">生成包含在包中的资源。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>process-resources</code></td>\n<td style=\"text-align:left\">将资源复制并处理到目标目录中，准备打包。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>compile</code></td>\n<td style=\"text-align:left\">编译项目的源代码。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>process-classes</code></td>\n<td style=\"text-align:left\">对编译生成的文件进行后处理，例如对 Java 类进行字节码增强。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>generate-test-sources</code></td>\n<td style=\"text-align:left\">生成任何测试源代码以包含在编译中。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>process-test-sources</code></td>\n<td style=\"text-align:left\">处理测试源代码，例如过滤任何值。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>generate-test-resources</code></td>\n<td style=\"text-align:left\">创建用于测试的资源。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>process-test-resources</code></td>\n<td style=\"text-align:left\">将资源复制并处理到测试目标目录中。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>test-compile</code></td>\n<td style=\"text-align:left\">将测试源代码编译到测试目标目录中</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>process-test-classes</code></td>\n<td style=\"text-align:left\">对测试编译生成的文件进行后处理，例如对 Java 类进行字节码增强。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>test</code></td>\n<td style=\"text-align:left\">使用合适的单元测试框架运行测试。这些测试不应该要求打包或部署代码。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>prepare-package</code></td>\n<td style=\"text-align:left\">在实际包装之前执行准备包装所需的任何操作。这通常会导致包的解压缩、处理版本。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>package</code></td>\n<td style=\"text-align:left\">获取编译后的代码并将其打包为其可分发格式，例如 JAR。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>pre-integration-test</code></td>\n<td style=\"text-align:left\">在执行集成测试之前执行所需的操作。这可能涉及诸如设置所需环境之类的事情。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>integration-test</code></td>\n<td style=\"text-align:left\">如有必要，处理并部署包到可以运行集成测试的环境中。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>post-integration-test</code></td>\n<td style=\"text-align:left\">执行集成测试后执行所需的操作。这可能包括清理环境。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>verify</code></td>\n<td style=\"text-align:left\">运行任何检查以验证包裹是否有效并符合质量标准。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>install</code></td>\n<td style=\"text-align:left\">将包安装到本地存储库中，用作本地其他项目的依赖项。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>deploy</code></td>\n<td style=\"text-align:left\">在集成或发布环境中完成，将最终包复制到远程存储库以与其他开发人员和项目共享。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"site生命周期\"> site生命周期</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">阶段</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>pre-site</code></td>\n<td style=\"text-align:left\">在实际项目现场生成之前执行所需的流程</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>site</code></td>\n<td style=\"text-align:left\">生成项目的站点文档</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>post-site</code></td>\n<td style=\"text-align:left\">执行完成站点生成和准备站点部署所需的流程</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>site-deploy</code></td>\n<td style=\"text-align:left\">将生成的站点文档部署到指定的 Web 服务器</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"clean生命周期\"> clean生命周期</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">阶段</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>pre-clean</code></td>\n<td style=\"text-align:left\">在实际项目清理之前执行所需的流程</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>clean</code></td>\n<td style=\"text-align:left\">删除先前构建生成的所有文件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>post-clean</code></td>\n<td style=\"text-align:left\">执行完成项目清理所需的流程</td>\n</tr>\n</tbody>\n</table>\n",
      "date_published": "2021-12-21T05:46:37.000Z",
      "date_modified": "2021-12-21T05:46:37.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Get新技能,Java实现文件监控",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/other/java-watch-file/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/other/java-watch-file/",
      "content_html": "<p><strong>作者: 八阿哥的剑</strong></p>\n<p><em>博客: https://springlearn.cn</em></p>\n<div><p>一日一句毒鸡汤</p>\n<p>问世间钱为何物，只叫人生死相许。！😄</p>\n</div>\n<h2 id=\"java原生版本监控\"> Java原生版本监控</h2>\n<div><pre><code><span>public</span> <span>class</span> <span>JavaWatchAPI</span> <span>{</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>//第一步：取得WatchService</span>\n        <span>WatchService</span> watchService <span>=</span> <span>FileSystems</span><span>.</span><span>getDefault</span><span>(</span><span>)</span><span>.</span><span>newWatchService</span><span>(</span><span>)</span><span>;</span>\n        <span>//第二步：确定要监控的路径</span>\n        <span>Path</span> path <span>=</span> <span>Paths</span><span>.</span><span>get</span><span>(</span><span>\"/Users/liuxin/Github/nobug-learn-project/nobug-learn-01/src/main/java\"</span><span>)</span><span>;</span>\n\n        <span>//第三步：为本路径绑定WatchService，并确定监控的事件</span>\n        path<span>.</span><span>register</span><span>(</span>\n                watchService<span>,</span>\n                <span>// StandardWatchEventKinds.ENTRY_CREATE—当有新文件时触发。可能是创建了一个新文件</span>\n                <span>StandardWatchEventKinds</span><span>.</span>ENTRY_CREATE<span>,</span>\n                <span>// StandardWatchEventKinds.ENTRY_DELETE—当文件被删除、移动或重命名时触发</span>\n                <span>StandardWatchEventKinds</span><span>.</span>ENTRY_DELETE<span>,</span>\n                <span>// StandardWatchEventKinds.ENTRY_MODIFY—当文件被修改时触发。</span>\n                <span>StandardWatchEventKinds</span><span>.</span>ENTRY_MODIFY<span>)</span><span>;</span>\n        <span>// StandardWatchEventKinds.OVERFLOW—触发表示丢失或丢弃的事件。</span>\n        <span>WatchKey</span> key <span>=</span> <span>null</span><span>;</span>\n        <span>while</span> <span>(</span><span>(</span>key <span>=</span> watchService<span>.</span><span>take</span><span>(</span><span>)</span><span>)</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n            <span>for</span> <span>(</span><span>WatchEvent</span><span><span>&lt;</span><span>?</span><span>></span></span> event <span>:</span> key<span>.</span><span>pollEvents</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"事件\"</span> <span>+</span> event<span>.</span><span>kind</span><span>(</span><span>)</span> <span>+</span> <span>\"发生了，文件是：\"</span> <span>+</span> event<span>.</span><span>context</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>}</span>\n            key<span>.</span><span>reset</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><h2 id=\"common-io-工具包监控\"> Common IO 工具包监控</h2>\n<div><pre><code><span>package</span> <span>cn<span>.</span>github<span>.</span>chinesszz</span><span>;</span>\n\n<span>import</span> <span>org<span>.</span>apache<span>.</span>commons<span>.</span>io<span>.</span>filefilter<span>.</span></span><span>FileFilterUtils</span><span>;</span>\n<span>import</span> <span>org<span>.</span>apache<span>.</span>commons<span>.</span>io<span>.</span>monitor<span>.</span></span><span>FileAlterationListener</span><span>;</span>\n<span>import</span> <span>org<span>.</span>apache<span>.</span>commons<span>.</span>io<span>.</span>monitor<span>.</span></span><span>FileAlterationMonitor</span><span>;</span>\n<span>import</span> <span>org<span>.</span>apache<span>.</span>commons<span>.</span>io<span>.</span>monitor<span>.</span></span><span>FileAlterationObserver</span><span>;</span>\n<span>import</span> <span>org<span>.</span>junit<span>.</span></span><span>Test</span><span>;</span>\n\n<span>import</span> <span>java<span>.</span>io<span>.</span></span><span>File</span><span>;</span>\n<span>import</span> <span>java<span>.</span>util<span>.</span>concurrent<span>.</span></span><span>TimeUnit</span><span>;</span>\n\n<span>/**\n * @author liuxin\n * 2021/11/9 8:55 下午\n */</span>\n<span>public</span> <span>class</span> <span>CommonIOAPI</span> <span>{</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>File</span> directory <span>=</span> <span>new</span> <span>File</span><span>(</span><span>\"/Users/liuxin/Github/nobug-learn-project/nobug-learn-01/src/main/java\"</span><span>)</span><span>;</span>\n        <span>// 轮询间隔 5 秒</span>\n        <span>long</span> interval <span>=</span> <span>TimeUnit</span><span>.</span>SECONDS<span>.</span><span>toMillis</span><span>(</span><span>5</span><span>)</span><span>;</span>\n        <span>// 创建一个文件观察器用于处理文件的格式</span>\n        <span>FileAlterationObserver</span> observer <span>=</span> <span>new</span> <span>FileAlterationObserver</span><span>(</span>directory<span>,</span> <span>FileFilterUtils</span><span>.</span><span>and</span><span>(</span>\n                <span>FileFilterUtils</span><span>.</span><span>fileFileFilter</span><span>(</span><span>)</span><span>,</span> <span>FileFilterUtils</span><span>.</span><span>suffixFileFilter</span><span>(</span><span>\".txt\"</span><span>)</span><span>,</span>\n                <span>FileFilterUtils</span><span>.</span><span>prefixFileFilter</span><span>(</span><span>\"lx\"</span><span>)</span><span>)</span><span>)</span><span>;</span>\n        <span>// 设置文件变化监听器</span>\n        observer<span>.</span><span>addListener</span><span>(</span><span>new</span> <span>MyFileListener</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>FileAlterationMonitor</span> monitor <span>=</span> <span>new</span> <span>FileAlterationMonitor</span><span>(</span>interval<span>,</span> observer<span>)</span><span>;</span>\n        monitor<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>1</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>watchDir</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>File</span> directory <span>=</span> <span>new</span> <span>File</span><span>(</span><span>\"/Users/liuxin/Github/nobug-learn-project/nobug-learn-01/src/main/java\"</span><span>)</span><span>;</span>\n        <span>FileAlterationObserver</span> fileAlterationObserver <span>=</span> <span>new</span> <span>FileAlterationObserver</span><span>(</span>directory<span>,</span> <span>FileFilterUtils</span><span>.</span><span>and</span><span>(</span>\n                <span>FileFilterUtils</span><span>.</span><span>directoryFileFilter</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>\n        <span>long</span> interval <span>=</span> <span>TimeUnit</span><span>.</span>SECONDS<span>.</span><span>toMillis</span><span>(</span><span>5</span><span>)</span><span>;</span>\n        <span>// 设置文件变化监听器</span>\n        fileAlterationObserver<span>.</span><span>addListener</span><span>(</span><span>new</span> <span>MyFileListener</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>FileAlterationMonitor</span> monitor <span>=</span> <span>new</span> <span>FileAlterationMonitor</span><span>(</span>interval<span>,</span> fileAlterationObserver<span>)</span><span>;</span>\n        monitor<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        <span>while</span> <span>(</span><span>true</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>static</span> <span>final</span> <span>class</span> <span>MyFileListener</span> <span>implements</span> <span>FileAlterationListener</span> <span>{</span>\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>onStart</span><span>(</span><span>FileAlterationObserver</span> fileAlterationObserver<span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"monitor start scan files..\"</span><span>)</span><span>;</span>\n        <span>}</span>\n\n\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>onDirectoryCreate</span><span>(</span><span>File</span> file<span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>file<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\" director created.\"</span><span>)</span><span>;</span>\n        <span>}</span>\n\n\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>onDirectoryChange</span><span>(</span><span>File</span> file<span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>file<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\" director changed.\"</span><span>)</span><span>;</span>\n        <span>}</span>\n\n\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>onDirectoryDelete</span><span>(</span><span>File</span> file<span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>file<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\" director deleted.\"</span><span>)</span><span>;</span>\n        <span>}</span>\n\n\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>onFileCreate</span><span>(</span><span>File</span> file<span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>file<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\" created.\"</span><span>)</span><span>;</span>\n        <span>}</span>\n\n\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>onFileChange</span><span>(</span><span>File</span> file<span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>file<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\" changed.\"</span><span>)</span><span>;</span>\n        <span>}</span>\n\n\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>onFileDelete</span><span>(</span><span>File</span> file<span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>file<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\" deleted.\"</span><span>)</span><span>;</span>\n        <span>}</span>\n\n\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>onStop</span><span>(</span><span>FileAlterationObserver</span> fileAlterationObserver<span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"monitor stop scanning..\"</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br></div></div>",
      "date_published": "2021-12-21T05:46:37.000Z",
      "date_modified": "2022-01-04T14:58:20.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "如何学会复盘",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/other/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%BC%9A%E5%A4%8D%E7%9B%98/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/other/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%BC%9A%E5%A4%8D%E7%9B%98/",
      "content_html": "<p><a href=\"https://mp.weixin.qq.com/s/skP5pXvjsepvoOTMRmGEFw\" target=\"_blank\" rel=\"noopener noreferrer\">不懂复盘，再努力都是低水平重复</a></p>\n<h2 id=\"一、复盘三角\"> 一、复盘三角</h2>\n<p>“复盘三角”，也就是记录、反思、提炼这三个动作。</p>\n<h3 id=\"_1-1-记录\"> 1.1 记录</h3>\n<p>一天过完以后，把你当天或者过往一天的主要发生记录下来，遇到了什么人，谈了什么话，做了什么事，情绪怎么样……</p>\n<p>刚开始的时候，最好老老实实把一整天能记录的都记录下来，作为一种刻意练习，作为一种基本功的修炼。</p>\n<p>有很多人会怀疑，说记录会不会是在浪费时间，其背后的意思，实际上是想有一个取巧的办法，能不花时间也有反思的成果，我目前的看法是，别想多了，还是老老实实、扎硬寨打呆仗。</p>\n<p>为什么要如实记录？因为我们的大脑不一定靠谱，大脑自己会编造事实，事后就变成了“我以为”，实际上不是真相。记忆有时候是会骗人的。</p>\n<p>当我们有一些我们无法接受的情况发生时，如果我们很痛苦的话，大脑就倾向于抹掉那一部分或者掩盖、改写一部分，好让自己变得舒服一点。</p>\n<h3 id=\"_1-2-反思\"> 1.2 反思</h3>\n<p>就某个点、某件事慢慢进行剖析，比如为什么有这种情绪？为什么不愉快，发生了什么？为什么发生？我的判断是什么？我为什么会有这种判断？这种判断是一时的还是一种固有的模式？怎么做，才能避免？</p>\n<h3 id=\"_1-3-提炼\"> 1.3 提炼</h3>\n<p>复盘到最后，提炼形成行动指南，用以指导自己的行动。</p>\n<p>提炼很简单，就是形成一句话，复盘到最后，你要找到一句话，用这句话作为你的行动指南，作为你的方法论，作为你的原则和价值观，然后再去践行出来。</p>\n<p>提炼也不简单，这句话要求有触发效应，能够在一个场景当中有效的指引自己，当你一想到这句话，就会让自己的行为有所改变。</p>\n<p>我们的行为处事要有一套指引体系，要有一套指南。我们要用这些东西去逐渐规范、干预、调整自己的行为，用这些东西去重塑一个不同的自己。</p>\n<p>这些指南、指引，实际上就是一些所谓的原则。史蒂芬·柯维的7个习惯就是7个原则，稻盛和夫的六项精进也是6个原则。</p>\n<p>但这些原则是史蒂芬·柯维、稻盛和夫的，不是你的，虽然你很认同，但是它不一定能指导你的实践，你需要转化成自己的，拥有自己的原则。</p>\n<p>就像达利欧在《原则》当中所指出的，“最重要的事情是总结出你自己的原则，最好将其写下来，尤其是在你与其他人共事的情况下。”</p>\n<p>提炼这个步骤就是直接指向原则，这一步就是为了生产我们工作和生活的原则的。提炼的标准最好是：自己的语言，够具体，一句话，记得住，用得上。</p>\n<h2 id=\"二、好的复盘长什么样\"> 二、好的复盘长什么样？</h2>\n<h3 id=\"_2-1-好的复盘首先都是-过电影\"> 2.1 好的复盘首先都是“过电影”</h3>\n<p>所谓“过电影”，就是对过去发生的事情一幕幕进行回顾。一天结束以后，先把一天的主要经历过一遍，今天到底发生了什么，今天到底过得怎么样，需要做到心里有数，掌握一定的素材，搞清事实状况，然后才能梳理出个所以然。</p>\n<h3 id=\"_2-2-复自己的盘\"> 2.2 复自己的盘</h3>\n<p>复盘需要指向自己，如果复盘来复盘去，找到的都是别人的问题，看到的都是别人的毛病，那就不叫复盘，那叫批评大会、抱怨大会、吐槽大会。</p>\n<p>所以还差一个东西，就是自我批评。有一个词叫反求诸己，这才是真正意义上的复盘。</p>\n<h3 id=\"_2-3-复盘给自己看\"> 2.3 复盘给自己看</h3>\n<p>当你写复盘的时候，不要想着写给别人看，本着这样的心态去写，自己面对自己。</p>\n<h3 id=\"_2-4-复盘自己的痛苦\"> 2.4 复盘自己的痛苦</h3>\n<p>《原则》的作者达利欧有一个公式：痛苦+反思=进步。没有经历足够的痛苦，没有痛彻心扉，反思通常也会停留于表面，不会那么深刻。\n所以，当你经历痛苦的时候，最好把痛苦记录下来。当然，这种时候还不是反思的最佳时刻，因为你很难保持头脑清醒。最好是在痛苦之后，进行回顾和反思。</p>\n<h3 id=\"_2-5-好的复盘会指向并加速行动\"> 2.5 好的复盘会指向并加速行动</h3>\n<p>我们判断一个复盘好不好，不是看你的复盘的文字写得好不好，而是看复盘之后，你有没有采取相应的行动，有没有取得相应的成果。复盘不是目的，而是达成目的的一种手段。</p>\n<h3 id=\"_2-6-好的复盘需要不断质疑\"> 2.6 好的复盘需要不断质疑</h3>\n<p>复盘也需要更多的质疑。质疑什么？质疑自己的基本假设，自己的判断标准。</p>\n<p>这一点是最难的，首先，你要能看到自己行为处事背后的原则和标准，其次，你要能够对这些原则和标准进行自我质疑。这不是一日之功，这才是复盘中最难突破的地方。</p>\n<h2 id=\"三、复盘的三个标准\"> 三、复盘的三个标准</h2>\n<h3 id=\"_3-1-能反观\"> 3.1 能反观</h3>\n<p>很多人在参加一项培训之后会要求自己进行复盘，但他们更多所做的动作其实叫复习，把学到的东西再过一遍，看看老师讲了什么、做了什么练习或者最触动自己的是什么。</p>\n<p>他们更多所做的是记忆或者说强化记忆的行为，从复盘的角度来看，只是完成了反观的一部分工作——反回头去看。</p>\n<p>不过，这还不彻底，还要去看看所学的内容如何和自己的工作相结合，如何去落地和应用，从而让自己的工作效率和成果有所改变。还要对照学习的内容，看自己有哪些优势和不足，找出差距，然后才能有机会弥补差距。</p>\n<p>这就是“能反观”。</p>\n<h3 id=\"_3-2-会反思\"> 3.2 会反思</h3>\n<p>“能反观”之外，还要做到“会反思”。根据史蒂芬·柯维的“观为得”模型，想法决定行为，行为决定结果。也就是所谓的“观”决定“为”，“为”决定“得”。</p>\n<p>反思就是从结果倒推，去看看我们当初到底都做了什么，有哪些行为，然后再去看我们所有行为背后的想法，为什么要这样去做，为什么有这些行为，原因是什么，背后的信念假设、思维模式是什么。</p>\n<div><pre><code>比如家里来了客人，作为家长，你希望自己的女儿将玩具和客人的孩子分享，但是你的孩子的表现令你非常失望，她把玩具据为己有，一点也不愿意分享。你刚开始还好言相劝，慢慢变成了言语威胁，最后竟演变成了打骂，家里立刻变得乌烟瘴气。\n\n\n\n从结果倒推，家里气氛不好，发生了什么呢？原来是你打了孩子。你为什么要打孩子呢？因为她不愿意分享，你觉得非常没有礼貌。\n\n\n\n再去倒推“观”的层面，你会发现孩子不配合，让自己在客人面前失了面子。要把玩具跟别人分享，这是你的需求，不是孩子的需求。\n\n\n\n再倒推，你可能会发现自己很虚伪，孩子却很真实；你可能会发现，孩子只有先学会拥有，才能学会分享；你可能会发现，自己之前对待孩子的方式有问题，你让孩子养成了吃独食的习惯，没有学会分享；你可能会发现，自己一直也是这样，跟人交往不愿多付出，只是一味索取，所以孩子也不知道什么叫付出和分享，等等等等。\n\n\n\n最后你一定会在自己身上发现很多问题，这个过程，就是反思，我们用的是“得-为-观”倒推的方法。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h3 id=\"_3-3-有反省\"> 3.3 有反省</h3>\n<p>一般的复盘，最多到这里就截止了，实际上，更高层面的复盘，还要有反省。</p>\n<p>有了反省，自己反观、反思出来的问题，才能得到真正的解决，你的固有模式才有可能被调整，你的“木马程序”才有可能被清除。</p>\n<p>反省是从事上，回到心上，去看自己的起心动念，去除恶念、保持善念。</p>\n",
      "date_published": "2022-01-04T17:14:21.000Z",
      "date_modified": "2022-01-04T17:14:21.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "自定义插件教程",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/maven/%E8%87%AA%E5%AE%9A%E4%B9%89maven%E6%8F%92%E4%BB%B6/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/maven/%E8%87%AA%E5%AE%9A%E4%B9%89maven%E6%8F%92%E4%BB%B6/",
      "content_html": "<blockquote>\n<p>Maven插件官网: https://maven.apache.org/guides/plugin/guide-java-plugin-development.html</p>\n</blockquote>\n<div><p>前言介绍</p>\n<p>前面我们大概了解了Maven的生命周期,本篇主要是学习如何在Maven的生命周期内指定一些插件的执行。主要分为3个步骤。<br>\n<i>Not supported content</i> 第一个步骤先了解学习下Maven官方的命名规则建议。<br>\n<i>Not supported content</i> 第二个步骤根据命名规则,我们自定义一个插件 Mojo。<br>\n<i>Not supported content</i> 第三个部分学习如何向插件内 Mojo 注入一些，Maven的配置和自定义的配置信息。<br></p>\n</div>\n<h2 id=\"一、命名规范\"> 一、命名规范</h2>\n<ul>\n<li>官方的命名规则: <code>maven-&lt;yourplugin&gt;-plugin</code>（注意“Maven”位于插件名称的开头)</li>\n<li>个人自定义建议: <code>&lt;yourplugin&gt;-maven-plugin</code>（注意“Maven”位于插件名称的中间)</li>\n</ul>\n<p>个人不得使用官方命名规则,因为它是 Apache Maven 团队使用的插件保留命名模式。\n如果个人使用这种命名模式是会侵犯了 Apache Maven 商标。<code>org.apache.maven.plugins</code></p>\n<h2 id=\"二、自定义mojo\"> 二、自定义Mojo</h2>\n<p>当我们使用idea创建一个maven插件,里面已经为我们创建了一个Mojo。定义Mojo首先要集成\n<code>AbstractMojo</code> 抽象类。另外要声明这个Mojo的名字和Maven执行阶段。有两种方法声明</p>\n<h3 id=\"_2-1-使用javadoc的方式声明\"> 2.1 使用javadoc的方式声明</h3>\n<p>因为maven诞生比较早,当时没有注解。所以使用了javadoc。</p>\n<div><pre><code><span>/**\n* Goal which touches a timestamp file.\n*\n* @goal touch\n* @phase process-sources\n*/</span>\n<span>public</span> <span>class</span> <span>MyMojo</span> <span>extends</span> <span>AbstractMojo</span> <span>{</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>execute</span><span>(</span><span>)</span>\n    <span>throws</span> <span>MojoExecutionException</span> <span>{</span>\n    <span>getLog</span><span>(</span><span>)</span><span>.</span><span>info</span><span>(</span><span>\"我是一个Maven插件: FirstDemo\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>指定mvn install 安装到本地仓库,然后找个项目执行一下。</p>\n<div><pre><code>[INFO] Scanning for projects...\n[INFO]\n[INFO] ---------------------&lt; org.example:nobug-learn-01 &gt;---------------------\n[INFO] Building nobug-learn-01 1.0-SNAPSHOT\n[INFO] --------------------------------[ jar ]---------------------------------\n[INFO]\n[INFO] --- firstdemo-maven-plugin:1.0-SNAPSHOT:touch (default-cli) @ nobug-learn-01 ---\n[INFO] 我是一个Maven插件: FirstDemo\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time:  0.296 s\n[INFO] Finished at: 2021-11-26T17:00:32+08:00\n[INFO] ------------------------------------------------------------------------\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id=\"_2-2-使用注解的方式\"> 2.2 使用注解的方式</h3>\n<p>首先引入注解包</p>\n<div><pre><code>    <span><span><span>&lt;</span>properties</span><span>></span></span>\n        <span><span><span>&lt;</span>dep.maven-api.version</span><span>></span></span>3.5.2<span><span><span>&lt;/</span>dep.maven-api.version</span><span>></span></span>\n    <span><span><span>&lt;/</span>properties</span><span>></span></span>\n    <span><span><span>&lt;</span>dependencies</span><span>></span></span>\n        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>org.apache.maven<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>maven-plugin-api<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n            <span><span><span>&lt;</span>version</span><span>></span></span>${dep.maven-api.version}<span><span><span>&lt;/</span>version</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>org.apache.maven<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>maven-model<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n            <span><span><span>&lt;</span>version</span><span>></span></span>${dep.maven-api.version}<span><span><span>&lt;/</span>version</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>org.apache.maven.plugin-tools<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>maven-plugin-annotations<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n            <span><span><span>&lt;</span>version</span><span>></span></span>${dep.maven-api.version}<span><span><span>&lt;/</span>version</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>org.apache.maven.plugins<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>maven-plugin-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n            <span><span><span>&lt;</span>version</span><span>></span></span>3.5<span><span><span>&lt;/</span>version</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>junit<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>junit<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n            <span><span><span>&lt;</span>version</span><span>></span></span>3.8.1<span><span><span>&lt;/</span>version</span><span>></span></span>\n            <span><span><span>&lt;</span>scope</span><span>></span></span>test<span><span><span>&lt;/</span>scope</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n    <span><span><span>&lt;/</span>dependencies</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p>Mojo类</p>\n<div><pre><code><span>@Mojo</span><span>(</span>name <span>=</span> <span>\"myMojo\"</span><span>,</span> defaultPhase <span>=</span> <span>LifecyclePhase</span><span>.</span>VALIDATE<span>,</span> threadSafe <span>=</span> <span>true</span><span>)</span>\n<span>@Execute</span><span>(</span>phase <span>=</span> <span>LifecyclePhase</span><span>.</span>VALIDATE<span>)</span>\n<span>public</span> <span>class</span> <span>MyMojo</span>\n        <span>extends</span> <span>AbstractMojo</span> <span>{</span>\n\n    <span>public</span> <span>void</span> <span>execute</span><span>(</span><span>)</span>\n            <span>throws</span> <span>MojoExecutionException</span> <span>{</span>\n        <span>getLog</span><span>(</span><span>)</span><span>.</span><span>info</span><span>(</span><span>\"我是一个Maven插件: FirstDemo\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>注意: 自定义的maven插件是没办法指定在maven声明周期执行的。</p>\n<div><pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;org.example&lt;/groupId&gt;\n    &lt;artifactId&gt;firstdemo-maven-plugin&lt;/artifactId&gt;\n    &lt;version&gt;1.2-SNAPSHOT&lt;/version&gt;\n    &lt;executions&gt;\n        &lt;execution&gt;\n        &lt;!--                        如果插件中没有生命周期,这里要进行声明。如果插件中声明了就不用写这个--&gt;\n         &lt;phase&gt;clean&lt;/phase&gt;\n         &lt;goals&gt;\n         &lt;!--                            自定义的插件,不会自动执行,要在这里进行声明--&gt;\n            &lt;goal&gt;myMojo&lt;/goal&gt;\n        &lt;/goals&gt;\n        &lt;/execution&gt;\n    &lt;/executions&gt;\n&lt;/plugin&gt;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h2 id=\"三、mojo数据介绍\"> 三、Mojo数据介绍</h2>\n<div><p>官方支持的文档</p>\n<p>maven插件中是可以自定以参数的,通过配置然后传递到Mojo类中。\n主要使用 <code>@Parameter</code> 注解完成，下面是详细介绍。</p>\n</div>\n<p>主要使用<code>@Parameter</code>进行定义。</p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>name</td>\n<td>声明参数的名字</td>\n</tr>\n<tr>\n<td>alias</td>\n<td>声明一个别名</td>\n</tr>\n<tr>\n<td>property</td>\n<td>从pom的propertys标签中读取,或是-Dtest=123 使用-D添加到命令行</td>\n</tr>\n<tr>\n<td>defaultValue</td>\n<td>字段的默认值</td>\n</tr>\n<tr>\n<td>required</td>\n<td>是否必须</td>\n</tr>\n<tr>\n<td>readonly</td>\n<td>是否只读</td>\n</tr>\n</tbody>\n</table>\n<p>字段的类型可以是多样的。</p>\n<h3 id=\"_3-1-boolean类型\"> 3.1 boolean类型</h3>\n<p>这包括类型为 boolean 和 Boolean 的变量。 读取配置时，文本“true”会导致参数设置为 true，所有其他文本都会导致参数设置为 false。 例子：</p>\n<div><pre><code>    /**\n     * My boolean.\n     */\n    @Parameter\n    private boolean myBoolean;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><code>&lt;myBoolean&gt;true&lt;/myBoolean&gt;</code></p>\n<h3 id=\"_3-2-integer类型\"> 3.2 Integer类型</h3>\n<p>这包括类型为 byte、Byte、int、Integer、long、Long、short 和 Short 的变量。 读取配置时，使用 Integer.parseInt() 或相应类的 valueOf() 方法将 XML 文件中的文本转换为整数值。 这意味着字符串必须是有效的十进制整数值，仅由数字 0 到 9 组成，前面有一个可选的 - 表示负值。 例子：</p>\n<div><pre><code>    /**\n     * My Integer.\n     */\n    @Parameter\n    private Integer myInteger;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><code>&lt;myInteger&gt;10&lt;/myInteger&gt;</code></p>\n<h3 id=\"_3-3-double类型\"> 3.3 Double类型</h3>\n<p>这包括类型为 double、Double、float 和 Float 的变量。 读取配置时，XML 文件中的文本使用相应类的 valueOf() 方法转换为二进制形式。</p>\n<div><pre><code>    /**\n     * My Double.\n     */\n    @Parameter\n    private Double myDouble;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><code>&lt;myDouble&gt;1.0&lt;/myDouble&gt;</code></p>\n<h3 id=\"_3-4-date类型\"> 3.4 Date类型</h3>\n<p>这包括类型为日期的变量。 读取配置时，XML 文件中的文本使用以下日期格式之一进行转换：“yyyy-MM-dd HH:mm:ss.S a”（示例日期为“2005-10-06 2:22 :55.1 PM”）或“yyyy-MM-dd HH:mm:ssa”（示例日期为“2005-10-06 2:22:55PM”）。 请注意，解析是使用 DateFormat.parse() 完成的，它允许对格式进行一些宽容。 如果该方法可以解析指定的日期和时间，即使它与上面的模式不完全匹配，它也会这样做。 例子：</p>\n<div><pre><code>    /**\n     * My Date.\n     */\n    @Parameter\n    private Date myDate;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><code>&lt;myDate&gt;2005-10-06 2:22:55.1 PM&lt;/myDate&gt;</code></p>\n<h3 id=\"_3-5-file类型\"> 3.5 File类型</h3>\n<p>这包括类型为 File 的变量。 读取配置时，XML 文件中的文本用作所需文件或目录的路径。 如果路径是相对的（不以 / 或 C: 之类的驱动器号开头），则该路径是相对于包含 POM 的目录。 例子：</p>\n<div><pre><code>    /**\n     * My File.\n     */\n    @Parameter\n    private File myFile;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><code>&lt;myFile&gt;c:\\temp&lt;/myFile&gt;</code></p>\n<h3 id=\"_3-6-url\"> 3.6 URL</h3>\n<p>这包括变量类型的 URL。 读取配置时，使用 XML 文件中的文本作为 URL。 格式必须遵循 RFC 2396 准则，并且看起来像任何 Web 浏览器 URL (scheme://host:port/path/to/file)。 转换 URL 时，对 URL 任何部分的内容都没有限制。</p>\n<div><pre><code>    /**\n     * My URL.\n     */\n    @Parameter\n    private URL myURL;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><code>&lt;myURL&gt;http://maven.apache.org&lt;/myURL&gt;</code></p>\n<h3 id=\"_3-7-枚举\"> 3.7 枚举</h3>\n<p>也可以使用枚举类型参数。 首先你需要定义你的枚举类型，然后你可以在参数定义中使用枚举类型：</p>\n<div><pre><code>    public enum Color {\n      GREEN,\n      RED,\n      BLUE\n    }\n\n    /**\n     * My Enum\n     */\n    @Parameter\n    private Color myColor;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p><code>&lt;myColor&gt;GREEN&lt;/myColor&gt;</code></p>\n<h3 id=\"_3-8-arrays\"> 3.8 Arrays</h3>\n<div><pre><code>    /**\n     * My Array.\n     */\n    @Parameter\n    private String[] myArray;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code>&lt;myArray&gt;\n  &lt;param&gt;value1&lt;/param&gt;\n  &lt;param&gt;value2&lt;/param&gt;\n&lt;/myArray&gt;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"_3-9-collections\"> 3.9 Collections</h3>\n<p>此类别涵盖任何实现 java.util.Collection 的类，例如 ArrayList 或 HashSet。 这些参数是通过多次指定参数来配置的，就像数组一样。 例子：</p>\n<div><pre><code>   /**\n     * My List.\n     */\n    @Parameter\n    private List myList;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code>&lt;myList&gt;\n  &lt;param&gt;value1&lt;/param&gt;\n  &lt;param&gt;value2&lt;/param&gt;\n&lt;/myList&gt;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"_3-10-maps\"> 3.10 Maps</h3>\n<p>此类别涵盖任何实现 java.util.Map（例如 HashMap）但未实现 java.util.Properties 的类。 这些参数是通过在参数配置中以 <key>value</key> 形式包含 XML 标签来配置的。 例子：</p>\n<div><pre><code>    /**\n     * My Map.\n     */\n    @Parameter\n    private Map myMap;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code>&lt;myMap&gt;\n  &lt;key1&gt;value1&lt;/key1&gt;\n  &lt;key2&gt;value2&lt;/key2&gt;\n&lt;/myMap&gt;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"_3-11-properties\"> 3.11 Properties</h3>\n<p>此类别涵盖实现 java.util.Properties 的任何地图。 这些参数是通过在参数配置中以 <property><name>myName</name> <value>myValue</value> </property> 形式包含 XML 标记来配置的。 例子：</p>\n<div><pre><code>    /**\n     * My Properties.\n     */\n    @Parameter\n    private Properties myProperties;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code>&lt;myProperties&gt;\n  &lt;property&gt;\n    &lt;name&gt;propertyName1&lt;/name&gt;\n    &lt;value&gt;propertyValue1&lt;/value&gt;\n  &lt;property&gt;\n  &lt;property&gt;\n    &lt;name&gt;propertyName2&lt;/name&gt;\n    &lt;value&gt;propertyValue2&lt;/value&gt;\n  &lt;property&gt;\n&lt;/myProperties&gt;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id=\"_12-object\"> 12. Object</h3>\n<div><pre><code>    /**\n     * My Object.\n     */\n    @Parameter\n    private MyObject myObject;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code>&lt;myObject&gt;\n  &lt;myField&gt;test&lt;/myField&gt;\n&lt;/myObject&gt;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"_13-mavensession\"> 13. MavenSession</h3>\n<div><pre><code>    @Parameter(defaultValue = &quot;${session}&quot;, readonly = true)\n    private MavenSession session;\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"_14-mavenproject\"> 14. MavenProject</h3>\n<div><pre><code>    @Parameter(defaultValue = &quot;${project}&quot;, readonly = true)\n    private MavenProject project;\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"_15-mojoexecution\"> 15. MojoExecution</h3>\n<div><pre><code>    @Parameter(defaultValue = &quot;${mojoExecution}&quot;, readonly = true)\n    private MojoExecution mojo;\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"_16-plugindescriptor\"> 16. PluginDescriptor</h3>\n<div><pre><code>    @Parameter(defaultValue = &quot;${plugin}&quot;, readonly = true)\n    private PluginDescriptor plugin;\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"_17-settings\"> 17. Settings</h3>\n<div><pre><code>    /**\n     * maven的配置信息\n     */\n    @Parameter(defaultValue = &quot;${settings}&quot;, readonly = true)\n    private Settings settings;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"_18-项目路径\"> 18. 项目路径</h3>\n<div><pre><code>    /**\n     * 项目路径\n     */\n    @Parameter(defaultValue = &quot;${project.basedir}&quot;, readonly = true)\n    private File basedir;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"_19-编译后目录\"> 19. 编译后目录</h3>\n<div><pre><code>    /**\n     * 编译后目录\n     */\n    @Parameter(defaultValue = &quot;${project.build.directory}&quot;, readonly = true)\n    private File target;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"四、插件执行\"> 四、插件执行</h2>\n<blockquote>\n<p>类似问题: https://www.coder.work/article/3592058</p>\n</blockquote>\n<div><p>注意</p>\n<p>我们自己开发的插件,要想执行必须要在项目的pom文件中来指定,插件不会默认来进行执行的。如下。</p>\n</div>\n<div><pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;org.example&lt;/groupId&gt;\n    &lt;artifactId&gt;firstdemo-maven-plugin&lt;/artifactId&gt;\n    &lt;version&gt;1.2-SNAPSHOT&lt;/version&gt;\n    &lt;executions&gt;\n        &lt;execution&gt;\n        &lt;!--                        如果插件中没有生命周期,这里要进行声明。如果插件中声明了就不用写这个--&gt;\n         &lt;phase&gt;clean&lt;/phase&gt;\n         &lt;goals&gt;\n         &lt;!--                            自定义的插件,不会自动执行,要在这里进行声明--&gt;\n            &lt;goal&gt;myMojo&lt;/goal&gt;\n        &lt;/goals&gt;\n        &lt;/execution&gt;\n    &lt;/executions&gt;\n&lt;/plugin&gt;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><ul>\n<li><input type=\"checkbox\" checked=\"checked\" disabled=\"disabled\" id=\"task-item-0\"><label for=\"task-item-0\"> phase 如果插件中没有生命周期,这里要进行声明。如果插件中声明了就不用写这个</label></li>\n<li><input type=\"checkbox\" checked=\"checked\" disabled=\"disabled\" id=\"task-item-1\"><label for=\"task-item-1\"> goal  自定义的插件,不会自动执行,要在这里进行声明</label></li>\n</ul>\n<h3 id=\"命令行执行\"> 命令行执行</h3>\n<ul>\n<li>\n<p><code>mvn org.example:firstdemo-maven-plugin:1.4-SNAPSHOT:myMojo</code></p>\n</li>\n<li>\n<p><code>mvn ${groupId}:${artifactId}:${version}:${mojoName}</code></p>\n</li>\n</ul>\n",
      "date_published": "2021-12-21T05:46:37.000Z",
      "date_modified": "2022-03-24T14:34:44.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "重剑无锋大巧不工",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/other/%E9%87%8D%E5%89%91%E6%97%A0%E9%94%8B%E5%A4%A7%E5%B7%A7%E4%B8%8D%E5%B7%A5/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/other/%E9%87%8D%E5%89%91%E6%97%A0%E9%94%8B%E5%A4%A7%E5%B7%A7%E4%B8%8D%E5%B7%A5/",
      "content_html": "",
      "date_published": "2021-12-21T05:46:37.000Z",
      "date_modified": "2022-01-04T14:58:20.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "程序猿到底有没有必要买一台阿里云服务器",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/other/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E5%88%B0%E5%BA%95%E6%9C%89%E6%B2%A1%E6%9C%89%E5%BF%85%E8%A6%81%E4%B9%B0%E4%B8%80%E5%8F%B0%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/other/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E5%88%B0%E5%BA%95%E6%9C%89%E6%B2%A1%E6%9C%89%E5%BF%85%E8%A6%81%E4%B9%B0%E4%B8%80%E5%8F%B0%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/",
      "content_html": "<p><img src=\"https://img-blog.csdnimg.cn/2019122518192512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" loading=\"lazy\"></p>\n<p><strong>做为一名程序猿多多少少每天都在跟服务器打交道,尤其是后端的小伙伴,那么你是否也有这样的想法呢 ?</strong></p>\n<h3 id=\"一、个人服务器究竟能做什么\"> 一、个人服务器究竟能做什么?</h3>\n<h4 id=\"_1-搭建个人博客\"> 1. 搭建个人博客</h4>\n<p>软件开发这个行业,知识技术日新月异,作为一名合格专注的程序猿每天都会浏览各种各样的技术网站,在这里我们排出一些大的技术博客网站,我们也经常会看到很多个人的技术博主。一般拥有个人博客网站的都是在某一个领域有很深认识的大牛,会经常把自己的学到的知识积累下来,分享给大家。那么如果要搭建自己的个人博客就必须要有一台个人服务器啦。 但是排出一种情况就是有些个人博主会把自己的博客部署在 <code>gitlab</code> 或者<code>github</code>、<code>coding</code> 的静态Pages上,然后通过域名<code>CNAME</code> 的方式访问, 像小编我自己之前也是用后面这种情况,可以免费部署自己的个人博客。但是唯一缺点就是访问太慢了。</p>\n<p><strong>下面就是小编我自己的个人网站,主要做Java后端的知识分享(非营利性哦)</strong>\n<a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://img-blog.csdnimg.cn/20191225183752474.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" loading=\"lazy\"></a></p>\n<h4 id=\"_2-搭建个人知识库\"> 2. 搭建个人知识库</h4>\n<p>做为技术人,我们每天都要处理各种各样的数据,有公司数据、有个人数据、或者碎片的知识点、API信息、备忘录信息等。相信每个开发者都会有这个需求吧，一般我们可以使用 <code>有道云笔记</code> 、 <code>印象笔记</code>。 小编使用的是前者，但是突然有一段时间不能用了,原因当然不是有道云挂了, 而是很多公司为了信息安全禁止员工登陆这种网站,\n比如云盘类网站, 当然就包括上面的。这个时候当我们访问上面的网站时候就会被公司后台记录，或者是直接就访问不到。这个时候我们就要考虑搭建一个人知识库了。小编现在用的是 <code>showdoc</code>。 非常简单。</p>\n<p>登陆服务器安装 <code>docker</code> 运行下面命令即可</p>\n<div><pre><code><span>docker</span> pull xd2idwf5.mirror.aliyuncs.com/star7th/showdoc<span>;</span>\n<span>docker</span> tag xd2idwf5.mirror.aliyuncs.com/star7th/showdoc:latest star7th/showdoc:latest<span>;</span>\n<span>mkdir</span> showdoc_data<span>;</span>\n<span>mkdir</span> showdoc_data/html<span>;</span>\n<span>chmod</span>  -R <span>777</span> showdoc_data<span>;</span>\n<span>docker</span> run -d --name showdoc -p <span>6666</span>:80 -v /root/showdoc_data/html:/var/www/html/      star7th/showdoc\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><strong>下面是小编的个人知识库</strong></p>\n<p><a href=\"http://doc.springlearn.cn\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://img-blog.csdnimg.cn/20191225184550675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" loading=\"lazy\"></a></p>\n<h4 id=\"_3-搭建个人网盘\"> 3. 搭建个人网盘</h4>\n<p>网盘的用处只有一个就是存储文件,市面上的产品之前有很多但是近两年很多都倒闭了,不过现在还有 <code>百度网盘</code>依然坚挺。但是(太...慢了)。 那么我们就自己来搭建一个吧。小编使用的网盘是 <code>Seafile</code></p>\n<p>Seafile是一个开源、专业、可靠的云存储平台；解决文件集中存储、共享和跨平台访问等问题，除了一般网盘所提供的云存储以及共享功能外，Seafile还提供消息通信。 具体安装也不难。\n<img src=\"https://img-blog.csdnimg.cn/20191225185205331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" loading=\"lazy\"></p>\n<h4 id=\"_4-部署个人应用\"> 4. 部署个人应用</h4>\n<p>这个需求应该是购买服务器的最终目的，就是部署自己的服务, 小编就是部署的自己的博客应用。 使用nginx作为方向代理。不得不说使用自己服务器就是比免费的速度快。</p>\n<p>http://blog.springlearn.cn/ 响应在5毫秒内\nhttp://www.hanframework.com/ 免费的响应在400毫秒内</p>\n<p>虽然都不到1秒,但是具体使用时候用户体验差距还是很大的。可以自己体验下。\n<img src=\"https://img-blog.csdnimg.cn/20191225185514458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" loading=\"lazy\"></p>\n<h3 id=\"二、购买了服务器你还需要哪些知识储备\"> 二、购买了服务器你还需要哪些知识储备</h3>\n<h4 id=\"_1-服务器ssh登录\"> 1. 服务器ssh登录</h4>\n<p>当我们购买了服务器我们有两种登陆方式</p>\n<ol>\n<li>用户名和密码登陆</li>\n<li>秘钥登陆\n这两种登陆都离不开 <code>ssh</code> 命令</li>\n</ol>\n<p><strong>第一种</strong>\n<code>ssh root@127.32.32.122</code> 然后输入用户密码</p>\n<p><strong>第二种</strong>\n<code>ssh aliyun</code>  直接就访问</p>\n<p>对于如何配置小编就不说了,百度搜索就很多答案,如果不想搜索或者有问题，可以给小编私信。小编给你解决。</p>\n<h4 id=\"_2-服务器器安全组配置\"> 2. 服务器器安全组配置</h4>\n<p>安全组这个概念,如果没有购买过服务器的应该不是很清楚,其实就是防火墙的意思。当我们购买了阿里/百度/腾讯/华为/七牛之类的服务器，在后台都有一个安全组管理的。一个入站,一个出站端端口配置。 这个要注意,如果不配置的话，你是访问不到你的端口的\n<img src=\"https://img-blog.csdnimg.cn/20191225190257549.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" loading=\"lazy\"></p>\n<h4 id=\"_3-域名配置\"> 3. 域名配置</h4>\n<p>我们可以选择一个自己心仪的域名, 一般域名很便宜一年<code>三十</code> 左右。但是别钻牛角尖, 天价的域名也很多。</p>\n<p>域名配置主要是域名转发之类的。</p>\n<ol>\n<li>第一种情况: 如果要将域名配置到一台服务器上使用，那么这种情况域名必须要备案，备案一般服务商会帮我们备案，我们只要提供认证信息,一般一周内可以下来。</li>\n<li>第二种情况: 如果我们没有服务器我们也可以购买一个域名,我们在配置域名转发的时候,可以不指定服务器,而是转发到一个CNAEM别名上也可以使用。</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/20191225191224799.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" loading=\"lazy\"></p>\n<h4 id=\"_4-部署应用\"> 4. 部署应用</h4>\n<p>不会做饭的老司机不是好的厨师,同样只会写代码,不会部署的程序猿不是合格的程序猿。😸。</p>\n<p>部署应用我们可以使用 <code>docker</code> + <code>nginx或apache</code> 。 具体 <code>nginx</code> 和 <code>docker</code> 的使用网上很多就不细说了，如果你要购买服务器这些都是你要储备的知识点。</p>\n<h3 id=\"三、购买服务器要注意什么\"> 三、购买服务器要注意什么</h3>\n<h4 id=\"_1-价格\"> 1. 价格</h4>\n<p>作为软件开发者,能免费的东西绝对不花钱, 上面的各种场景,其实我们都可以使用免费的来替代。 除了部署应用。那么我们就研究下价格。 一般运营商的套路都是年底大甩卖。所以年中和年头不是购买服务器的时间, 一般都在 <code>双十一</code> 、<code>双十二</code>期间会大降价。\n关于价格对比的我们就以<code>2核4G</code>的服务器作为对比, 因为这个配置就能满足我们的需求。 那么我们就看看运营商的价格，因为是双十二期间,所以阿里云最近在搞活动,所以阿里云目前我看是最低的，新用户3年只要799。【如果不是新用户可以用其他人账号买,小编就是用自己家人账号买的】</p>\n<ol>\n<li>七牛云2核4g三年 ￥1767.61</li>\n<li>腾讯云2核4g三年 ￥3897</li>\n<li>华为云2核4g三年 ￥6,440.70</li>\n<li>阿里云2核4g三年 ￥1807.2(常规价) ￥799(活动价格)</li>\n</ol>\n<p><a href=\"https://www.aliyun.com/minisite/goods?userCode=oab21mxz\" target=\"_blank\" rel=\"noopener noreferrer\">活动优惠券领取</a>\n<img src=\"https://img-blog.csdnimg.cn/20191225192246879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" loading=\"lazy\">\n<img src=\"https://img-blog.csdnimg.cn/20191225192305678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" loading=\"lazy\">\n<img src=\"https://img-blog.csdnimg.cn/20191225192332835.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" loading=\"lazy\">\n<img src=\"https://img-blog.csdnimg.cn/2019122519235837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" loading=\"lazy\"></p>\n<h4 id=\"_2-售后-本人真实体验不是喷子-不是职业黑\"> 2. 售后(本人真实体验不是喷子,不是职业黑)</h4>\n<p>服务器一般什么情况下会有售后呢?\n当出现服务器 <code>cpu</code> 飙高, 流量异常被恶意攻击的时候,就考验售后了。我们就看服务商的工单回复速度。因为小编就用过阿里云和七牛云所以就对比下两家的工单体验吧。</p>\n<ol>\n<li>阿里云无论回复速度还是质量都满意。</li>\n<li>七牛云回复慢就算了，一个问题给我转几个人,每次让我重新再问一遍(没地方吐槽,就在这里吧)</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/20191225192754639.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" loading=\"lazy\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20191225192935155.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" loading=\"lazy\"></p>\n<p><strong>时间到,下班了... 喜欢小编的可以关注一下,持续为你分享干货知识</strong></p>\n",
      "image": "https://img-blog.csdnimg.cn/2019122518192512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70",
      "date_published": "2021-12-21T05:46:37.000Z",
      "date_modified": "2022-01-04T14:58:20.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Home",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/",
      "content_html": "<h3 id=\"badge\"> Badge</h3>\n<ul>\n<li>\n<i>Not supported content</i>\n</li>\n<li>\n<i>Not supported content</i>\n</li>\n</ul>\n<CodeGroup>\n<CodeGroupItem title=\"yarn\">\n<div><pre><code><span>yarn</span> <span>add</span> -D vuepress-theme-hope\n</code></pre>\n<div><span>1</span><br></div></div></CodeGroupItem>\n<CodeGroupItem title=\"npm\" active>\n<div><pre><code><span>npm</span> i -D vuepress-theme-hope\n</code></pre>\n<div><span>1</span><br></div></div></CodeGroupItem>\n</CodeGroup>\n<div><div><br><div>&nbsp;</div><br><br><br><br><br></div><pre><code><span>public</span> <span>class</span> <span>Person</span><span>{</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span>args<span>)</span><span>{</span>\n\n    <span>}</span>\n<span>}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div>",
      "date_published": "2021-12-21T05:46:37.000Z",
      "date_modified": "2022-03-24T14:34:44.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "maven-surefire-plugin",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/maven/maven-surefire-plugin/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/maven/maven-surefire-plugin/",
      "content_html": "<blockquote>\n<p>maven-surefire-plugin Surefire 插件在test构建生命周期阶段用于执行应用程序的单元测试。</p>\n</blockquote>\n<p><img src=\"https://maven.apache.org/images/maventxt_logo_200.gif\" alt=\"\" loading=\"lazy\"></p>\n<p><a href=\"https://maven.apache.org/surefire/maven-surefire-plugin/index.html\" target=\"_blank\" rel=\"noopener noreferrer\">maven-surefire-plugin官网</a></p>\n<h2 id=\"一、介绍\"> 一、介绍</h2>\n<p>如果你执行过mvn test或者执行其他maven命令时跑了测试用例，你就已经用过maven-surefire-plugin了。\nmaven-surefire-plugin是maven里执行测试用例的插件，不显示配置就会用默认配置。\n这个插件的surefire:test命令会默认绑定maven执行的test阶段。</p>\n<p>如果你自己声明了，那么可以指定自己的版本，并且可以配置自定义的参数。</p>\n<h2 id=\"二、实践\"> 二、实践</h2>\n<h3 id=\"_2-1-用法\"> 2.1 用法</h3>\n<div><pre><code> &lt;build&gt;\n    &lt;pluginManagement&gt;\n      &lt;plugins&gt;\n        &lt;plugin&gt;\n          &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n          &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;\n          &lt;version&gt;3.0.0-M5&lt;/version&gt;\n        &lt;/plugin&gt;\n      &lt;/plugins&gt;\n    &lt;/pluginManagement&gt;\n  &lt;/build&gt;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id=\"_2-2-使用方法\"> 2.2 使用方法</h3>\n<p><code>mvn test</code></p>\n<h2 id=\"三、源码分析\"> 三、源码分析</h2>\n<h3 id=\"_3-1-学习目标\"> 3.1 学习目标</h3>\n<div><p>相关信息</p>\n<p>框架整体比较复杂，但是对于我们有学习价值的东西不多，我们没必要太深入研究。在此只提几个关键的知识点学习。</p>\n</div>\n<ol>\n<li>maven-surefire-plugin的常用参数及作用</li>\n<li>maven-surefire-plugin实现单测的原理</li>\n</ol>\n<h3 id=\"_3-2-学习搭建环境\"> 3.2 学习搭建环境</h3>\n<div><pre><code>    <span>&lt;!-- 先声明插件版本 --></span>\n    <span><span><span>&lt;</span>build</span><span>></span></span>\n        <span><span><span>&lt;</span>plugins</span><span>></span></span>\n            <span><span><span>&lt;</span>plugin</span><span>></span></span>\n                <span><span><span>&lt;</span>groupId</span><span>></span></span>org.apache.maven.plugins<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n                <span><span><span>&lt;</span>artifactId</span><span>></span></span>maven-surefire-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n                <span>&lt;!-- JUnit 5 requires Surefire version 2.22.0 or higher --></span>\n                <span><span><span>&lt;</span>version</span><span>></span></span>2.22.0<span><span><span>&lt;/</span>version</span><span>></span></span>\n            <span><span><span>&lt;/</span>plugin</span><span>></span></span>\n        <span><span><span>&lt;/</span>plugins</span><span>></span></span>\n    <span><span><span>&lt;/</span>build</span><span>></span></span>\n    <span>&lt;!-- 然后引入依赖,方便debug跟进源码--></span>\n      <span><span><span>&lt;</span>dependency</span><span>></span></span>\n          <span><span><span>&lt;</span>groupId</span><span>></span></span>junit<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n          <span><span><span>&lt;</span>artifactId</span><span>></span></span>junit<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n          <span><span><span>&lt;</span>version</span><span>></span></span>4.13.2<span><span><span>&lt;/</span>version</span><span>></span></span>\n          <span><span><span>&lt;</span>scope</span><span>></span></span>test<span><span><span>&lt;/</span>scope</span><span>></span></span>\n      <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n      <span><span><span>&lt;</span>dependency</span><span>></span></span>\n          <span><span><span>&lt;</span>groupId</span><span>></span></span>org.apache.maven.plugins<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n          <span><span><span>&lt;</span>artifactId</span><span>></span></span>maven-surefire-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n          <span><span><span>&lt;</span>version</span><span>></span></span>3.0.0-M5<span><span><span>&lt;/</span>version</span><span>></span></span>\n      <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n      <span><span><span>&lt;</span>dependency</span><span>></span></span>\n          <span><span><span>&lt;</span>groupId</span><span>></span></span>org.apache.maven<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n          <span><span><span>&lt;</span>artifactId</span><span>></span></span>maven-core<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n          <span><span><span>&lt;</span>version</span><span>></span></span>3.8.4<span><span><span>&lt;/</span>version</span><span>></span></span>\n      <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n      <span><span><span>&lt;</span>dependency</span><span>></span></span>\n          <span><span><span>&lt;</span>groupId</span><span>></span></span>org.apache.maven.surefire<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n          <span><span><span>&lt;</span>artifactId</span><span>></span></span>surefire-junit4<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n          <span><span><span>&lt;</span>version</span><span>></span></span>3.0.0-M5<span><span><span>&lt;/</span>version</span><span>></span></span>\n      <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n      <span><span><span>&lt;</span>dependency</span><span>></span></span>\n          <span><span><span>&lt;</span>groupId</span><span>></span></span>org.apache.maven<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n          <span><span><span>&lt;</span>artifactId</span><span>></span></span>maven-plugin-api<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n          <span><span><span>&lt;</span>version</span><span>></span></span>${dep.maven-api.version}<span><span><span>&lt;/</span>version</span><span>></span></span>\n      <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n      <span><span><span>&lt;</span>dependency</span><span>></span></span>\n          <span><span><span>&lt;</span>groupId</span><span>></span></span>org.apache.maven<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n          <span><span><span>&lt;</span>artifactId</span><span>></span></span>maven-model<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n          <span><span><span>&lt;</span>version</span><span>></span></span>${dep.maven-api.version}<span><span><span>&lt;/</span>version</span><span>></span></span>\n      <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n      <span><span><span>&lt;</span>dependency</span><span>></span></span>\n          <span><span><span>&lt;</span>groupId</span><span>></span></span>org.apache.maven.plugin-tools<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n          <span><span><span>&lt;</span>artifactId</span><span>></span></span>maven-plugin-annotations<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n          <span><span><span>&lt;</span>version</span><span>></span></span>${dep.maven-api.version}<span><span><span>&lt;/</span>version</span><span>></span></span>\n      <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n      <span><span><span>&lt;</span>dependency</span><span>></span></span>\n          <span><span><span>&lt;</span>groupId</span><span>></span></span>org.apache.maven.plugins<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n          <span><span><span>&lt;</span>artifactId</span><span>></span></span>maven-plugin-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n          <span><span><span>&lt;</span>version</span><span>></span></span>${dep.maven-api.version}<span><span><span>&lt;/</span>version</span><span>></span></span>\n      <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br></div></div><h3 id=\"_3-3-找到插件入口\"> 3.3 找到插件入口</h3>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1645113430000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>前面通过学习知道Mojo是运行的核心类,而SurefirePlugin就是Mojo的子类。\n由此可知,如果要学习这个 <code>maven-surefire-plugin</code>，入口就是在SurefirePlugin类。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1644857307000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1645114616000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"四、-带着问题来学习\"> 四、 带着问题来学习</h2>\n<h3 id=\"_4-1-常用的参数都有那些\"> 4.1 常用的参数都有那些</h3>\n<p>大多数为不常用的</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">是否常用</th>\n<th style=\"text-align:left\">参数名</th>\n<th style=\"text-align:center\">使用方法</th>\n<th style=\"text-align:center\">解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">常用</td>\n<td style=\"text-align:left\">skipTests</td>\n<td style=\"text-align:center\">-D,或者xml配置标签</td>\n<td style=\"text-align:center\">用于跳过单测</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">常用</td>\n<td style=\"text-align:left\">maven.test.skip.exec</td>\n<td style=\"text-align:center\">-D,或者xml配置标签</td>\n<td style=\"text-align:center\">用于跳过单测</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">常用</td>\n<td style=\"text-align:left\">maven.test.skip</td>\n<td style=\"text-align:center\">-D,或者xml配置标签</td>\n<td style=\"text-align:center\">用于跳过单测</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">不常用</td>\n<td style=\"text-align:left\">testClassesDirectory</td>\n<td style=\"text-align:center\">xml配置标签</td>\n<td style=\"text-align:center\">指定测试模块目录编译后目录</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">不常用</td>\n<td style=\"text-align:left\">maven.test.dependency.excludes</td>\n<td style=\"text-align:center\">-D,或者xml配置标签</td>\n<td style=\"text-align:center\">要排除的依赖,格式:groupId:artifactId</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">不常用</td>\n<td style=\"text-align:left\">maven.test.additionalClasspath</td>\n<td style=\"text-align:center\">-D,或者xml配置标签</td>\n<td style=\"text-align:center\">追加classpath</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">不常用</td>\n<td style=\"text-align:left\">project.build.testSourceDirectory</td>\n<td style=\"text-align:center\">xml配置标签</td>\n<td style=\"text-align:center\">指定测试模块目录源码目录</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">不常用</td>\n<td style=\"text-align:left\">excludes</td>\n<td style=\"text-align:center\">xml配置</td>\n<td style=\"text-align:center\">指定规则的类不需要被单测，eg: **/*Test.java</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">不常用</td>\n<td style=\"text-align:left\">surefire.reportNameSuffix</td>\n<td style=\"text-align:center\">-D,或者xml配置标签</td>\n<td style=\"text-align:center\">test报表后缀</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">不常用</td>\n<td style=\"text-align:left\">maven.test.redirectTestOutputToFile</td>\n<td style=\"text-align:center\">-D,或者xml配置标签</td>\n<td style=\"text-align:center\">运行的单侧输出重定向到report目录中</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">不常用</td>\n<td style=\"text-align:left\">failIfNoTests</td>\n<td style=\"text-align:center\">-D,或者xml配置标签</td>\n<td style=\"text-align:center\">如果没有单测就报错</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">不常用</td>\n<td style=\"text-align:left\">forkMode</td>\n<td style=\"text-align:center\">-D,或者xml配置标签</td>\n<td style=\"text-align:center\">运行模式</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">不常用</td>\n<td style=\"text-align:left\">jvm</td>\n<td style=\"text-align:center\">-D,或者xml配置标签</td>\n<td style=\"text-align:center\">指定jvm目录,如果不指定会读取系统</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">不常用</td>\n<td style=\"text-align:left\">argLine</td>\n<td style=\"text-align:center\">-D,或者xml配置标签</td>\n<td style=\"text-align:center\">Jvm运行参数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">不常用</td>\n<td style=\"text-align:left\">threadCount</td>\n<td style=\"text-align:center\">-D,或者xml配置标签</td>\n<td style=\"text-align:center\">线程数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">不常用</td>\n<td style=\"text-align:left\">forkCount</td>\n<td style=\"text-align:center\">-D,或者xml配置标签</td>\n<td style=\"text-align:center\">指定启用多少个vm,1.5C 以数字结尾,数字乘以cpu核心数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">不常用</td>\n<td style=\"text-align:left\">reuseForks</td>\n<td style=\"text-align:center\">-D,或者xml配置标签</td>\n<td style=\"text-align:center\">是否可重新使用forks进程</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">不常用</td>\n<td style=\"text-align:left\">disableXmlReport</td>\n<td style=\"text-align:center\">-D,或者xml配置标签</td>\n<td style=\"text-align:center\">禁用xml报告</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">不常用</td>\n<td style=\"text-align:left\">enableassertions</td>\n<td style=\"text-align:center\">-D,或者xml配置标签</td>\n<td style=\"text-align:center\">启用断言assert语句</td>\n</tr>\n</tbody>\n</table>\n<p><strong>forkMode 可设置值有 “never”， “once”， “always” 和 “pertest”。</strong></p>\n<ul>\n<li>pretest： 每一个测试创建一个新进程，为每个测试创建新的JVM是单独测试的最彻底方式，但也是最慢的，不适合hudson上持续回归。</li>\n<li>once：在一个进程中进行所有测试。once为默认设置，在Hudson上持续回归时建议使用默认设置。</li>\n<li>always：在一个进程中并行的运行脚本，Junit4.7以上版本才可以使用，surefire的版本要在2.6以上提供这个功能，</li>\n</ul>\n<h3 id=\"_4-2-知识点\"> 4.2 知识点</h3>\n<div><pre><code>// 大于等于2.0.0，小于2.1.2\nVersionRange range = VersionRange.createFromVersionSpec(&quot;[2.0.0,2.1.2)&quot;);\nSystem.out.println(range.containsVersion(new DefaultArtifactVersion(&quot;1.0&quot;)));\nSystem.out.println(range.containsVersion(new DefaultArtifactVersion(&quot;2.0.0&quot;)));\nSystem.out.println(range.containsVersion(new DefaultArtifactVersion(&quot;2.1.1&quot;)));\nSystem.out.println(range.containsVersion(new DefaultArtifactVersion(&quot;2.1.2&quot;)));\nSystem.out.println(&quot;------------&quot;);\nVersionRange range2 = VersionRange.createFromVersionSpec(&quot;[2.0.0-M1SN,2.1.2)&quot;);\nSystem.out.println(range2.containsVersion(new DefaultArtifactVersion(&quot;2.1.1-M2&quot;)));\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div>",
      "image": "https://maven.apache.org/images/maventxt_logo_200.gif",
      "date_published": "2021-12-21T05:46:37.000Z",
      "date_modified": "2022-03-24T14:34:44.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "匆匆那年",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/school/students/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/school/students/",
      "content_html": "<ol>\n<li>介绍下自己的学习情况</li>\n<li>大学生的迷茫不是问题，问题要如何正确面对</li>\n<li>大学生要知道学习</li>\n</ol>\n",
      "date_published": "2021-12-21T05:46:37.000Z",
      "date_modified": "2021-12-21T05:46:37.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Spring",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/spring/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/spring/",
      "content_html": "<div><p>为什么是春天？</p>\n<p>Spring 让每个人都可以更快、更轻松、更安全地编写 Java。Spring 对速度、简单性和生产力的关注使其成为世界上最受欢迎的Java 框架。</p>\n</div>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1647175180000.png\" alt=\"\" loading=\"lazy\"></p>\n<ul>\n<li>Spring</li>\n<li>SpringBoot</li>\n<li>SpringCloud</li>\n</ul>\n",
      "image": "https://img.springlearn.cn/blog/learn_1647175180000.png",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-03-24T14:34:44.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "幻灯片页",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/slides/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/slides/",
      "content_html": "\n<i>Not supported content</i>",
      "image": "https://vuepress-theme-hope-demo.mrhope.site/logo.svg",
      "date_published": "2021-12-21T05:46:37.000Z",
      "date_modified": "2021-12-21T05:46:37.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "MockData API",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/test/MockDataAPI/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/test/MockDataAPI/",
      "content_html": "<p><code>JMockData</code> 是一款国人开发用来生成模拟数据的工具</p>\n<h2 id=\"基础类型\"> 基础类型</h2>\n<table>\n<thead>\n<tr>\n<th>描述</th>\n<th>类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>基础类型</td>\n<td><code>byte</code> <code>boolean</code> <code>char</code> <code>short</code> <code>int</code> <code>long</code> <code>float</code> <code>double</code></td>\n</tr>\n<tr>\n<td>包装类型包装</td>\n<td><code>Byte</code> <code>Boolean</code> <code>Character</code> <code>Short</code> <code>Integer</code> <code>Long</code> <code>Float</code> <code>Double</code></td>\n</tr>\n<tr>\n<td>常用类型</td>\n<td><code>BigDecimal</code> <code>BigInteger</code> <code>Date</code> <code>LocalDateTime</code> <code>LocalDate</code> <code>LocalTime</code> <code>java.sql.Timestamp</code> <code>String</code> <code>Enum</code></td>\n</tr>\n<tr>\n<td>多维数组</td>\n<td>以上所有类型的多维数组 如：<code>int[]</code> <code>int[][]</code> <code>int[][][]</code> .... etc.</td>\n</tr>\n</tbody>\n</table>\n<div><pre><code><span>//基本类型模拟</span>\n<span>int</span> intNum <span>=</span> <span>JMockData</span><span>.</span><span>mock</span><span>(</span><span>int</span><span>.</span><span>class</span><span>)</span><span>;</span>\n<span>int</span><span>[</span><span>]</span> intArray <span>=</span> <span>JMockData</span><span>.</span><span>mock</span><span>(</span><span>int</span><span>[</span><span>]</span><span>.</span><span>class</span><span>)</span><span>;</span>\n<span>Integer</span> integer <span>=</span> <span>JMockData</span><span>.</span><span>mock</span><span>(</span><span>Integer</span><span>.</span><span>class</span><span>)</span><span>;</span>\n<span>Integer</span><span>[</span><span>]</span> integerArray <span>=</span> <span>JMockData</span><span>.</span><span>mock</span><span>(</span><span>Integer</span><span>[</span><span>]</span><span>.</span><span>class</span><span>)</span><span>;</span>\n<span>//常用类型模拟</span>\n<span>BigDecimal</span> bigDecimal <span>=</span> <span>JMockData</span><span>.</span><span>mock</span><span>(</span><span>BigDecimal</span><span>.</span><span>class</span><span>)</span><span>;</span>\n<span>BigInteger</span> bigInteger <span>=</span> <span>JMockData</span><span>.</span><span>mock</span><span>(</span><span>BigInteger</span><span>.</span><span>class</span><span>)</span><span>;</span>\n<span>Date</span> date <span>=</span> <span>JMockData</span><span>.</span><span>mock</span><span>(</span><span>Date</span><span>.</span><span>class</span><span>)</span><span>;</span>\n<span>String</span> str <span>=</span> <span>JMockData</span><span>.</span><span>mock</span><span>(</span><span>String</span><span>.</span><span>class</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id=\"java对象\"> JAVA对象</h2>\n<p>模拟bean，被模拟的数据最好是plain bean，通过反射给属性赋值。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>User</span> <span>{</span>\n\n    <span>private</span> <span>String</span> name<span>;</span>\n\n    <span>private</span> <span>int</span> age<span>;</span>\n\n    <span>private</span> <span>long</span> cardId<span>;</span>\n    \n<span>}</span>  \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>test</span><span>(</span><span>)</span> <span>{</span>\n        <span>User</span> mock <span>=</span> <span>JMockData</span><span>.</span><span>mock</span><span>(</span><span>User</span><span>.</span><span>class</span><span>)</span><span>;</span>\n        <span>// User{name='jrq2b', age=9338, cardId=2850}</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>mock<span>)</span><span>;</span>\n    <span>}</span>  \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id=\"容器类型\"> 容器类型</h2>\n<div><pre><code><span>@Test</span>\n<span>//******注意TypeReference要加{}才能模拟******</span>\n<span>public</span> <span>void</span> <span>testTypeRefrence</span><span>(</span><span>)</span> <span>{</span>\n  <span>//模拟基础类型，不建议使用这种方式，参考基础类型章节直接模拟。</span>\n  <span>Integer</span> integerNum <span>=</span> <span>JMockData</span><span>.</span><span>mock</span><span>(</span><span>new</span> <span>TypeReference</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>(</span><span>)</span><span>{</span><span>}</span><span>)</span><span>;</span>\n  <span>Integer</span><span>[</span><span>]</span> integerArray <span>=</span> <span>JMockData</span><span>.</span><span>mock</span><span>(</span><span>new</span> <span>TypeReference</span><span>&lt;</span><span>Integer</span><span>[</span><span>]</span><span>></span><span>(</span><span>)</span><span>{</span><span>}</span><span>)</span><span>;</span>\n  <span>//模拟集合</span>\n  <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> integerList <span>=</span> <span>JMockData</span><span>.</span><span>mock</span><span>(</span><span>new</span> <span>TypeReference</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span><span>(</span><span>)</span><span>{</span><span>}</span><span>)</span><span>;</span>\n  <span>//模拟数组集合</span>\n  <span>List</span><span>&lt;</span><span>Integer</span><span>[</span><span>]</span><span>></span> integerArrayList <span>=</span> <span>JMockData</span><span>.</span><span>mock</span><span>(</span><span>new</span> <span>TypeReference</span><span>&lt;</span><span>List</span><span>&lt;</span><span>Integer</span><span>[</span><span>]</span><span>>></span><span>(</span><span>)</span><span>{</span><span>}</span><span>)</span><span>;</span>\n  <span>//模拟集合数组</span>\n  <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>[</span><span>]</span> integerListArray <span>=</span> <span>JMockData</span><span>.</span><span>mock</span><span>(</span><span>new</span> <span>TypeReference</span><span>&lt;</span><span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>[</span><span>]</span><span>></span><span>(</span><span>)</span><span>{</span><span>}</span><span>)</span><span>;</span>\n  <span>//模拟集合实体</span>\n  <span>List</span><span><span>&lt;</span><span>BasicBean</span><span>></span></span> basicBeanList <span>=</span> <span>JMockData</span><span>.</span><span>mock</span><span>(</span><span>new</span> <span>TypeReference</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>BasicBean</span><span>></span><span>></span></span><span>(</span><span>)</span><span>{</span><span>}</span><span>)</span><span>;</span>\n  <span>//各种组合忽略。。。。map同理。下面模拟一个不知道什么类型的map</span>\n  <span>Map</span><span>&lt;</span><span>List</span><span>&lt;</span><span>Map</span><span>&lt;</span><span>Integer</span><span>,</span> <span>String</span><span>[</span><span>]</span><span>[</span><span>]</span><span>>></span><span>,</span> <span>Map</span><span>&lt;</span><span>Set</span><span><span>&lt;</span><span>String</span><span>></span></span><span>,</span> <span>Double</span><span>[</span><span>]</span><span>>></span> some <span>=</span> <span>JMockData</span><span>.</span><span>mock</span><span>(</span><span>new</span> <span>TypeReference</span><span>&lt;</span><span>Map</span><span>&lt;</span><span>List</span><span>&lt;</span><span>Map</span><span>&lt;</span><span>Integer</span><span>,</span> <span>String</span><span>[</span><span>]</span><span>[</span><span>]</span><span>>></span><span>,</span> <span>Map</span><span>&lt;</span><span>Set</span><span><span>&lt;</span><span>String</span><span>></span></span><span>,</span> <span>Double</span><span>[</span><span>]</span><span>>>></span><span>(</span><span>)</span><span>{</span><span>}</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h2 id=\"范围配置\"> 范围配置</h2>\n<p>前面说了可以模拟各种数据,不同类型的数据都允许指定一个范围。\n如下</p>\n<div><pre><code><span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>\n<span>JMockData</span><span>.</span><span>mock</span><span>(</span><span>Date</span><span>.</span><span>class</span><span>,</span><span>MockConfig</span><span>.</span><span>newInstance</span><span>(</span><span>)</span>\n<span>.</span><span>dateRange</span><span>(</span><span>\"2018-11-20\"</span><span>,</span> <span>\"2018-11-30\"</span><span>)</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div允许指定模拟数据的范围或者是排除\" line-numbers-mode\"><pre><code>        <span>MockConfig</span> mockConfig <span>=</span> <span>new</span> <span>MockConfig</span><span>(</span><span>)</span>\n                <span>// 全局配置</span>\n                <span>.</span><span>globalConfig</span><span>(</span><span>)</span>\n                <span>.</span><span>setEnabledStatic</span><span>(</span><span>false</span><span>)</span>\n                <span>.</span><span>setEnabledPrivate</span><span>(</span><span>false</span><span>)</span>\n                <span>.</span><span>setEnabledPublic</span><span>(</span><span>false</span><span>)</span>\n                <span>.</span><span>setEnabledProtected</span><span>(</span><span>false</span><span>)</span>\n                <span>.</span><span>sizeRange</span><span>(</span><span>1</span><span>,</span> <span>1</span><span>)</span>\n                <span>.</span><span>charSeed</span><span>(</span><span>(</span><span>char</span><span>)</span> <span>97</span><span>,</span> <span>(</span><span>char</span><span>)</span> <span>98</span><span>)</span>\n                <span>.</span><span>byteRange</span><span>(</span><span>(</span><span>byte</span><span>)</span> <span>0</span><span>,</span> <span>Byte</span><span>.</span>MAX_VALUE<span>)</span>\n                <span>.</span><span>shortRange</span><span>(</span><span>(</span><span>short</span><span>)</span> <span>0</span><span>,</span> <span>Short</span><span>.</span>MAX_VALUE<span>)</span>\n                <span>// 某些字段（名等于integerNum的字段、包含float的字段、double开头的字段）配置</span>\n                <span>.</span><span>subConfig</span><span>(</span><span>\"integerNum\"</span><span>,</span> <span>\"*float*\"</span><span>,</span> <span>\"double*\"</span><span>)</span>\n                <span>.</span><span>intRange</span><span>(</span><span>10</span><span>,</span> <span>11</span><span>)</span>\n                <span>.</span><span>floatRange</span><span>(</span><span>1.22f</span><span>,</span> <span>1.50f</span><span>)</span>\n                <span>.</span><span>doubleRange</span><span>(</span><span>1.50</span><span>,</span> <span>1.99</span><span>)</span>\n                <span>.</span><span>longRange</span><span>(</span><span>12</span><span>,</span> <span>13</span><span>)</span>\n                <span>.</span><span>dateRange</span><span>(</span><span>\"2018-11-20\"</span><span>,</span> <span>\"2018-11-30\"</span><span>)</span>\n                <span>.</span><span>stringSeed</span><span>(</span><span>\"SAVED\"</span><span>,</span> <span>\"REJECT\"</span><span>,</span> <span>\"APPROVED\"</span><span>)</span>\n                <span>.</span><span>sizeRange</span><span>(</span><span>1</span><span>,</span> <span>1</span><span>)</span>\n                <span>// 全局配置</span>\n                <span>.</span><span>globalConfig</span><span>(</span><span>)</span>\n                <span>// 排除所有包含list/set/map字符的字段。表达式不区分大小写。</span>\n                <span>.</span><span>excludes</span><span>(</span><span>\"*List*\"</span><span>,</span> <span>\"*Set*\"</span><span>,</span> <span>\"*Map*\"</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div>",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-03-24T14:34:44.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "单元测试专题",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/test/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/test/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/learn_1617880083000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>沉淀、分享、成长、让自己和他人都有所收货。</p>\n<h2 id=\"一、前言\"> 一、前言</h2>\n<p>本系列文章主要的目的是提高大家对代码的单测意识, 其中文章主要会分享单测过程中,常见的测试场景及这些场景的解决方案和处理思路。\n为了能使大家更好的了解单元测试,作为程序员首先从源码入手,分享JUnit的运行原理。在先了解了JUnit的原理后,再来回顾我们的问题场景, 就自然而然的从根源深处解决大家的测单痛点以及大家对单测框架不熟悉的情况。</p>\n<h2 id=\"二、单测的意义\"> 二、单测的意义</h2>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1617886822000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>很多人说单测没有意义, 这是完全不正确的思想。相信随着码龄增加你会越发的认同这句话。据国外研究统计软件系统中最大的成本是\n维护成本,所以你能看到凡是开源的框架单测一定是非常丰富的,因为它要去迭代升级,要去向下兼容版本。如果没有单测那就是完全的黑盒。\n是好是坏听从天意,这是没有质量保证的。这点是软件系统都具有的所以说就这一点,就证明了单测的必须性。下面谈几个不写单元测试的说法。</p>\n<h3 id=\"_2-1-压缩开发时间-任务延期\"> 2.1 压缩开发时间,任务延期</h3>\n<p>或许说中国的国情跟国外的不一样,中国的系统或者说是业务系统更新的快,单测用完就失效。写单测会压缩开发时间,导致任务延期。从眼下看是压缩了开发的时间,但是它提高了开发的质量,一定程度上减少了系统的维护成本。其次单测并不是说要对你所有的方法进行测试, 这个要针对业务系统情况,把系统的核心业务中使用到的核心方法进行详细的单测维护即可。系统的核心逻辑是不会经常变动的,\n所以这部分的单测就是你整个单测的核心。</p>\n<h3 id=\"_2-2-公司性质\"> 2.2 公司性质</h3>\n<p>像一般政府的项目基本都会给到外部的公司来竞争,部分的外包公司只注重交付,不注重质量。或者说这个项目就是一个xx工程, 没有实用价值。\n只要上线就行。也不用维护。对于这种的确实现状是都不会写单元测试。(因为整个项目就是没有任何实用价值)</p>\n<h3 id=\"_2-3-别人都不写-我为啥要写\"> 2.3 别人都不写,我为啥要写</h3>\n<p>代码是有温度的,养成好的习惯从自己做起。好习惯会传染,需要一个<Highlight color='green'>好的带头人</Highlight>。团队内部成员每个人都有自己负责的功能区域。\n只要每个人针对自己的功能区域的核心计算逻辑写好单测,那么一定是好处大于坏处的。另外要写在平时,不要专门找时间来写代码。那样就容易把单测当做是任务去完成,就失去了写单测的意义。</p>\n<Highlight color=\"red\">相信你所认为虽然很正确,但是做起来很傻逼的事情,一定有人在默默的坚持着。努力做一个优秀的人。</Highlight>\n<h3 id=\"_2-4-代码都测完了-要测试干嘛\"> 2.4 代码都测完了,要测试干嘛</h3>\n<p>自己测完了,要测试干嘛。首先如果你有这样的想法,那么一定是因为你不了解测试的工作。测试是开发的补充,他一定不是开发的保姆。测试\n是对应用或系统的整体场景或者说功能的验证, 他不能对你代码的最小单元进行验证。所谓代码的最小单元一定是开发同学最了解的,代码的最小单元\n就是你定义的代码块,方法,技术框架。这部分测试同学是无法帮你验证的。我们这里举一个例子。</p>\n<p>软件工程师好比是盖大楼的,具体每一堵墙砖头如何摆放,房间如何设计,是否关注采光这是你设计师要干的事情,而测试好比质量验收,会看你整栋\n大楼是否有倾斜,水电煤气是否可以使用。测试同学并不了解所有的细节。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1618206722000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>开发和测试看到的东西不是完全一样的,越往上测试的黑盒越大。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1618051810000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_2-5-应付覆盖率指标\"> 2.5 应付覆盖率指标</h3>\n<p>当然如果公司对这个有要求,一定会有应付的办法。最差的情况就是全部都是为了应付而写代码。从价值观上来看,这是不对的。从实用性上来看这是没有任何价值的。那么如何解决这个办法呢? 价值观来保证咯。那么就需要一个指标了(非硬性指标), 把数据量化展示出来,作为应用质量的一个参考的因素。\n就算你全是应付而写,也一定有一定的价值。</p>\n<p>另外要说一点的是<Highlight color=\"red\">单测行覆盖率高不代表应用的质量就一定高,</Highlight>但是单测行覆盖率低一定代表着这个应用出现质量问题的可能性就越大。\n这无疑增加了业务风险和测试成本。为了减少业务风险和测试成本,希望大家提高对单测的意识。</p>\n<p><strong>那么我们在上升一点总结下如何提高应用的质量呢? 请看下文</strong></p>\n<h2 id=\"三、应用质量的看法\"> 三、应用质量的看法</h2>\n<p>应用质量如何来衡量, 这是一个完全可以通过指标来进行衡量的。那么究竟如何指标化呢? 这里首先对应用质量进行一个拆分。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1617889750000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>可以将应用质量分为两种:</p>\n<ol>\n<li>代码编程质量(编程风格)</li>\n<li>业务编程质量(业务是否清晰,异常场景的考虑)</li>\n</ol>\n<h3 id=\"_3-1-代码编程质量\"> 3.1 代码编程质量</h3>\n<p>代码编程质量往往只的是开发人员的编程风格,基于团队成员风格的相似度。\n也可以说是代码的可读性,可维护性,方法的复杂度,方法的执行效率。这个是最容易指标化处理的。\n基于规则引擎,进行静态代码扫描就可以扫描出。Sonar 或者 阿里规约都可以完成。\n他们都会把问题分为四个等级Blocker, Critical, Major, Minor/Trivial。</p>\n<h4 id=\"_3-1-1-blocker\"> 3.1.1  Blocker</h4>\n<p>即系统无法执行、崩溃或严重资源不足、应用模块无法启动或异常退出、无法测试、造成系统不稳定。</p>\n<h4 id=\"_3-1-2-critical\"> 3.1.2 Critical</h4>\n<p>即影响系统功能或操作，主要功能存在严重缺陷，但不会影响到系统稳定性。</p>\n<h4 id=\"_3-1-3-major\"> 3.1.3 Major</h4>\n<p>即界面、性能缺陷、兼容性。</p>\n<h4 id=\"_3-1-4-minor-trivial\"> 3.1.4 Minor/Trivial</h4>\n<p>即易用性及建议性问题。</p>\n<Highlight color=\"red\">质量分计算</Highlight>\n<div><p>质量分计算</p>\n<p>100-(Blocker<em>100+Critical</em>10+Major*1)/(代码数/100)</p>\n<ul>\n<li>Blocker 占比100%,因为是比较严重的问题</li>\n<li>Critical 低于Blocker占比10%</li>\n<li>Major 性能缺陷占比1%</li>\n</ul>\n</div>\n<h3 id=\"_2-2-业务编程质量\"> 2.2 业务编程质量</h3>\n<ul>\n<li>对软件设计的最小单位进行正确性检测，如函数或一个类的方法。</li>\n<li>系统集成测试</li>\n</ul>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1618206722000.png\" alt=\"\" loading=\"lazy\"></p>\n<h4 id=\"_2-2-1-ut由开发同学保证\"> 2.2.1 UT由开发同学保证</h4>\n<p>开发同学进行最小单元测试, 数据如何进行衡量呢?</p>\n<p>基于Jenkins的 <code>Jcoco</code> 插件,会统计行覆盖率，类覆盖率，复杂方法覆盖率等。输出一个\n可视化的图表。</p>\n<h4 id=\"_2-2-2-it由自动化测试同学编写\"> 2.2.2 IT由自动化测试同学编写</h4>\n<h2 id=\"四、代码编程质量例子\"> 四、代码编程质量例子</h2>\n<p>面向对象的思想写入复用性高的代码</p>\n<div><pre><code>\n<span>// 姓名，家乡，大学，专业，兴趣爱好，单位职称 </span>\n<span>public</span> <span>interface</span> <span>Introduce</span><span>{</span>\n     <span>// 这是一个介绍类,负责介绍自己</span>\n     <span>public</span> <span>void</span> <span>introduce</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>public</span> <span>class</span> <span>XiaoMing</span> <span>implements</span> <span>Introduce</span><span>{</span>\n\n     <span>public</span> <span>void</span> <span>introduce</span><span>(</span><span>)</span><span>{</span>\n         <span>sout</span><span>(</span><span>\"我叫小明\"</span><span>)</span>\n         <span>sout</span><span>(</span><span>\"我的老家是河南南阳\"</span><span>)</span>\n         <span>sout</span><span>(</span><span>\"我的家乡就坐落在河南南阳邓州市\"</span><span>)</span>\n         <span>sout</span><span>(</span><span>\"邓州市一个美丽的城市,是中国邓姓的发源地\"</span><span>)</span>\n         <span>sout</span><span>(</span><span>\"邓州也是河南境内人口最多的一个县级城市\"</span><span>)</span>\n         <span>sout</span><span>(</span><span>\"我大学是在河南大学\"</span><span>)</span>\n         <span>sout</span><span>(</span>\"河南大学简称河大，是一所位于中国河南省开封市涵盖文、史、哲、经、管、\n         法、理、工、医、农、教育、艺术等<span>12</span>个学科门类的省部共建型综合性公立大学。\"<span>)</span>\n         <span>sout</span><span>(</span><span>\"我的专业是计算机与信息工程\"</span><span>)</span>\n         <span>sout</span><span>(</span><span>\"我的个人爱好是写博客、打游戏、做美食、偶会也会跑跑步\"</span><span>)</span>\n         <span>sout</span><span>(</span><span>\"从业xx年,目前在公司的职称是xxx\"</span><span>)</span>\n     <span>}</span>\n<span>}</span>\n\n<span>public</span> <span>class</span> <span>XiaoMing</span> <span>implements</span> <span>Introduce</span><span>{</span>\n\n     <span>private</span> <span>void</span> <span>introduceHometown</span><span>(</span><span>)</span><span>{</span>\n         <span>sout</span><span>(</span><span>\"我的老家是河南南阳\"</span><span>)</span>\n         <span>sout</span><span>(</span><span>\"我的家乡就坐落在河南南阳邓州市\"</span><span>)</span>\n         <span>sout</span><span>(</span><span>\"邓州市一个美丽的城市,是中国邓姓的发源地\"</span><span>)</span>\n         <span>sout</span><span>(</span><span>\"邓州也是河南境内人口最多的一个县级城市\"</span><span>)</span>\n     <span>}</span>\n     \n     <span>private</span> <span>void</span> <span>introduceSchool</span><span>(</span><span>)</span><span>{</span>\n         <span>sout</span><span>(</span><span>\"我大学是在河南大学\"</span><span>)</span>\n         <span>sout</span><span>(</span>\"河南大学简称河大，是一所位于中国河南省开封市涵盖文、史、哲、经、管、\n         法、理、工、医、农、教育、艺术等<span>12</span>个学科门类的省部共建型综合性公立大学。\"<span>)</span>\n     <span>}</span>\n     \n     <span>private</span> <span>void</span> <span>introduceMajor</span><span>(</span><span>)</span><span>{</span>\n         <span>sout</span><span>(</span><span>\"我的专业是计算机与信息工程\"</span><span>)</span>\n     <span>}</span>\n     \n     <span>private</span> <span>void</span> <span>introduceInterest</span><span>(</span><span>)</span><span>{</span>\n         <span>sout</span><span>(</span><span>\"我的个人爱好是写博客、打游戏、做美食、偶会也会跑跑步\"</span><span>)</span>\n     <span>}</span>\n     \n     <span>// 将任务进行拆分,拆分的维度是逻辑顺序,然后抽离出方法,抽离的维度是单一职责。</span>\n     <span>// 这样的好处是工能化,模块化,便于复用。</span>\n     <span>public</span> <span>void</span> <span>introduce</span><span>(</span><span>)</span><span>{</span>\n         <span>sout</span><span>(</span><span>\"我叫小明\"</span><span>)</span><span>;</span>\n         <span>introduceHometown</span><span>(</span><span>)</span><span>;</span>\n         <span>introduceSchool</span><span>(</span><span>)</span><span>;</span>\n         <span>introduceMajor</span><span>(</span><span>)</span><span>;</span>\n         <span>introduceInterest</span><span>(</span><span>)</span><span>;</span>\n         <span>sout</span><span>(</span><span>\"从业xx年,目前在公司的职称是xxx\"</span><span>)</span><span>;</span>\n     <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br></div></div><p>有人会说了,明明很简单就搞定了,为啥多写了这么多方法。这是因为你的思维没有转变过来,简单来说就是要\n学会用面向对象的方法去写代码,不要写面向过程的代码了。如果高级点说就是代码层面上的领域驱动。\n领域驱动和面向过程最大的相同就是思想上都是要对问题进行拆分成最小粒度,已解决代码冗余重复,以方便重复组装利用\n,以达到快速简单维护的目的。</p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1617880083000.png",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-03-24T14:34:44.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "JUnit单测类属性注入",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/test/JUnit%E5%8D%95%E6%B5%8B%E7%B1%BB%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/test/JUnit%E5%8D%95%E6%B5%8B%E7%B1%BB%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5/",
      "content_html": "<p>通过前面的阅读我们已经能拿到了所有的容器启动参数。那么我们可以思考下。我们自己的\n单测类其实并没有交给容器来管理,那么我们的单测类中的属性都是什么时候注入的呢?</p>\n<p>答案就在 <code>TestExecutionListener</code></p>\n<div><pre><code><span>public</span> <span>interface</span> <span>TestExecutionListener</span> <span>{</span>\n\n\t<span>default</span> <span>void</span> <span>beforeTestClass</span><span>(</span><span>TestContext</span> testContext<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n\t<span>}</span>\n\n\t<span>default</span> <span>void</span> <span>prepareTestInstance</span><span>(</span><span>TestContext</span> testContext<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n\t<span>}</span>\n\n\t<span>default</span> <span>void</span> <span>beforeTestMethod</span><span>(</span><span>TestContext</span> testContext<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n\t<span>}</span>\n\n\t<span>default</span> <span>void</span> <span>beforeTestExecution</span><span>(</span><span>TestContext</span> testContext<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n\t<span>}</span>\n\n\t<span>default</span> <span>void</span> <span>afterTestExecution</span><span>(</span><span>TestContext</span> testContext<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n\t<span>}</span>\n\n\t<span>default</span> <span>void</span> <span>afterTestMethod</span><span>(</span><span>TestContext</span> testContext<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n\t<span>}</span>\n\n\t<span>default</span> <span>void</span> <span>afterTestClass</span><span>(</span><span>TestContext</span> testContext<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n\t<span>}</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p><img src=\"https://img.springlearn.cn/blog/learn_1617795655000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>通过名字我们发现了貌似一个可以进行依赖注入的类。没错就是在这里,在单侧方法执行前。通过</p>\n<div><pre><code><span>public</span> <span>class</span> <span>DependencyInjectionTestExecutionListener</span> <span>extends</span> <span>AbstractTestExecutionListener</span> <span>{</span>\n\t<span>@Override</span>\n\t<span>public</span> <span>void</span> <span>beforeTestMethod</span><span>(</span><span>TestContext</span> testContext<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n\t\t<span>if</span> <span>(</span><span>Boolean</span><span>.</span>TRUE<span>.</span><span>equals</span><span>(</span>testContext<span>.</span><span>getAttribute</span><span>(</span>REINJECT_DEPENDENCIES_ATTRIBUTE<span>)</span><span>)</span><span>)</span> <span>{</span>\n\t\t\t<span>if</span> <span>(</span>logger<span>.</span><span>isDebugEnabled</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n\t\t\t\tlogger<span>.</span><span>debug</span><span>(</span><span>\"Reinjecting dependencies for test context [\"</span> <span>+</span> testContext <span>+</span> <span>\"].\"</span><span>)</span><span>;</span>\n\t\t\t<span>}</span>\n\t\t\t<span>injectDependencies</span><span>(</span>testContext<span>)</span><span>;</span>\n\t\t<span>}</span>\n\t<span>}</span>\n\n\t<span>protected</span> <span>void</span> <span>injectDependencies</span><span>(</span><span>TestContext</span> testContext<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n\t\t<span>Object</span> bean <span>=</span> testContext<span>.</span><span>getTestInstance</span><span>(</span><span>)</span><span>;</span>\n\t\t<span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> clazz <span>=</span> testContext<span>.</span><span>getTestClass</span><span>(</span><span>)</span><span>;</span>\n\t\t<span>AutowireCapableBeanFactory</span> beanFactory <span>=</span> testContext<span>.</span><span>getApplicationContext</span><span>(</span><span>)</span><span>.</span><span>getAutowireCapableBeanFactory</span><span>(</span><span>)</span><span>;</span>\n\t\tbeanFactory<span>.</span><span>autowireBeanProperties</span><span>(</span>bean<span>,</span> <span>AutowireCapableBeanFactory</span><span>.</span>AUTOWIRE_NO<span>,</span> <span>false</span><span>)</span><span>;</span>\n\t\tbeanFactory<span>.</span><span>initializeBean</span><span>(</span>bean<span>,</span> clazz<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>AutowireCapableBeanFactory</span><span>.</span>ORIGINAL_INSTANCE_SUFFIX<span>)</span><span>;</span>\n\t\ttestContext<span>.</span><span>removeAttribute</span><span>(</span>REINJECT_DEPENDENCIES_ATTRIBUTE<span>)</span><span>;</span>\n\t<span>}</span>\n<span>}</span>\t\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div>",
      "image": "https://img.springlearn.cn/blog/learn_1617795655000.png",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-03-24T14:34:44.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "SpringBoot Testing",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/test/SpringBootTesting/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/test/SpringBootTesting/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/learn_1618140868000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>前面我们对Mockito的用法有了一个了解,这里告诉大家一个好消息,SpringBoot已经帮我们继承了\n这些框架,而且提供了更加简单好用的API。</p>\n<h2 id=\"一、mockito加载方式\"> 一、Mockito加载方式</h2>\n<p>前面我们说了两种加载方式 <code>MockitoJUnitRunner</code> 和 <code>MockitoAnnotations.initMocks(this);</code>\n这些在SpringBoot中都不需要了。</p>\n<p>所以这一段就是废话, 不用在看了。但是相信你已经看完了。</p>\n<h2 id=\"二、mockito必知概念\"> 二、Mockito必知概念</h2>\n<p>这些概念,参考Mockito章节,概念统统保留。</p>\n<h3 id=\"_2-1-完全模拟-mockbean\"> 2.1 完全模拟 MockBean</h3>\n<p>只需要将@Mock 换成 @MockBean即可</p>\n<h3 id=\"_2-2-部分模拟-spybean\"> 2.2 部分模拟 SpyBean</h3>\n<p>只需要将@Spy 换成 @MockBean即可。主要这里有一个小坑。\n如果是Feign接口,使用@SpyBean会报错。提示final class不能被代理。</p>\n<p>原因是SpringBoot依赖的Mockito版本太古老了,是2.23.4。从Mockito2.7.6\n开始已经解决了这个问题, 我们可以通过引入下面依赖解决。</p>\n<div><pre><code> <span><span><span>&lt;</span>dependency</span><span>></span></span>\n    <span><span><span>&lt;</span>groupId</span><span>></span></span>org.mockito<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n    <span><span><span>&lt;</span>artifactId</span><span>></span></span>mockito-inline<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n    <span><span><span>&lt;</span>version</span><span>></span></span>3.3.3<span><span><span>&lt;/</span>version</span><span>></span></span>\n<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>解决方案就是帮我们新增了一个配置,启动Mockit的插件来生成代理。\n大概原理就是及不实用JDK代理,也不是Cglib代理。\n<code>DefaultMockitoPlugins</code> &amp; <code>InlineByteBuddyMockMaker</code>\n<img src=\"https://img.springlearn.cn/blog/learn_1617877205000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"三、代码实例\"> 三、代码实例</h2>\n<h3 id=\"_3-1-mockbean-完全模拟\"> 3.1 @MockBean 完全模拟</h3>\n<p>没有被声明的方法返回值,对象类型返回null,基本类型是返回默认类型。</p>\n<p>@MockBean完全模拟</p>\n<div><pre><code>\n\n<span>public</span> <span>class</span> <span>TradeShopIntegrationImplTest</span> <span>extends</span> <span>BaseApplicationTest</span> <span>{</span>\n\n    <span>@Autowired</span>\n    <span>private</span> <span>TradeShopIntegration</span> shopBrandIntegration<span>;</span>\n\n    <span>@MockBean</span>\n    <span>private</span> <span>BrandServiceApi</span> brandService<span>;</span>\n    \n    <span>@MockBean</span>\n    <span>private</span> <span>GoodsStockApi</span> goodsStockApi<span>;</span>\n    \n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>testGetAllBrands</span><span>(</span><span>)</span> <span>{</span>\n        <span>Mockito</span><span>.</span><span>doReturn</span><span>(</span><span>JsonResult</span><span>.</span><span>failure</span><span>(</span><span>\"fail\"</span><span>)</span><span>)</span><span>.</span><span>when</span><span>(</span>goodsStockApi<span>)</span><span>.</span><span>getSkuList</span><span>(</span><span>Mockito</span><span>.</span><span>any</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// 底层调用的是goodsStockApi.getSkuList()</span>\n        <span>List</span><span><span>&lt;</span><span>GoodsBaseMsgDTO</span><span>></span></span> goodsBaseMsgDTOS <span>=</span> shopBrandIntegration<span>.</span><span>queryAllSku</span><span>(</span><span>)</span><span>;</span>\n        <span>// 因为前面声明了返回fail。所以这里没有数据返回。</span>\n        <span>JsonConsoleUtils</span><span>.</span><span>println</span><span>(</span>goodsBaseMsgDTOS<span>)</span><span>;</span>\n        <span>// 这里因为使用的是Mock完全模拟,所以尽管前面没有声明返回值,就默认返回null</span>\n        <span>List</span><span><span>&lt;</span><span>OutBrandDTO</span><span>></span></span> allBrands <span>=</span> shopBrandIntegration<span>.</span><span>getAllBrands</span><span>(</span><span>)</span><span>;</span>\n        <span>JsonConsoleUtils</span><span>.</span><span>println</span><span>(</span>allBrands<span>)</span><span>;</span>\n    <span>}</span>\n    \n<span>}</span>    \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><h3 id=\"_3-1-spybean-部分模拟\"> 3.1 @SpyBean 部分模拟</h3>\n<p>没有被声明的方法返回值,走原来逻辑。</p>\n<p>@SpyBean部分模拟</p>\n<div><div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br></div><pre><code>\n\n<span>public</span> <span>class</span> <span>TradeShopIntegrationImplTest</span> <span>extends</span> <span>BaseApplicationTest</span> <span>{</span>\n\n    <span>@Autowired</span>\n    <span>private</span> <span>TradeShopIntegration</span> shopBrandIntegration<span>;</span>\n\n    <span>@MockBean</span>\n    <span>private</span> <span>BrandServiceApi</span> brandService<span>;</span>\n    \n    <span>@MockBean</span>\n    <span>private</span> <span>GoodsStockApi</span> goodsStockApi<span>;</span>\n    \n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>testGetAllBrands</span><span>(</span><span>)</span> <span>{</span>\n        <span>Mockito</span><span>.</span><span>doReturn</span><span>(</span><span>JsonResult</span><span>.</span><span>failure</span><span>(</span><span>\"fail\"</span><span>)</span><span>)</span><span>.</span><span>when</span><span>(</span>goodsStockApi<span>)</span><span>.</span><span>getSkuList</span><span>(</span><span>Mockito</span><span>.</span><span>any</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// 底层调用的是goodsStockApi.getSkuList()</span>\n        <span>List</span><span><span>&lt;</span><span>GoodsBaseMsgDTO</span><span>></span></span> goodsBaseMsgDTOS <span>=</span> shopBrandIntegration<span>.</span><span>queryAllSku</span><span>(</span><span>)</span><span>;</span>\n        <span>// 因为前面声明了返回fail。所以这里没有数据返回。</span>\n        <span>JsonConsoleUtils</span><span>.</span><span>println</span><span>(</span>goodsBaseMsgDTOS<span>)</span><span>;</span>\n        <span>// 这里跟上面的区别就是,如果没有声明返回值,就走原来的方法。</span>\n        <span>List</span><span><span>&lt;</span><span>OutBrandDTO</span><span>></span></span> allBrands <span>=</span> shopBrandIntegration<span>.</span><span>getAllBrands</span><span>(</span><span>)</span><span>;</span>\n        <span>JsonConsoleUtils</span><span>.</span><span>println</span><span>(</span>allBrands<span>)</span><span>;</span>\n    <span>}</span>\n    \n<span>}</span>    \n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div>",
      "image": "https://img.springlearn.cn/blog/learn_1618140868000.png",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-03-24T14:34:44.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Mockito API",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/test/MockitoAPI/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/test/MockitoAPI/",
      "content_html": "<div><p>注意</p>\n<p>这里只是介绍原生的Mockito的API,针对SpringBoot应用有更简单的调用方式</p>\n</div>\n<h2 id=\"一、mockito加载方式\"> 一、Mockito加载方式</h2>\n<p>Mockito可以配合JUnit使用,也可以单独使用。有两种方式来引入Mockito</p>\n<h3 id=\"_1-1-方式-1-不依赖spring容器\"> 1.1 方式:1 不依赖Spring容器</h3>\n<p>如果你的单测不依赖容器,那么使用这种方式是比较方便和简介的。但是如果\n依赖容器,我们是到JUnit的原理是只要发现有一个Runner就会返回,如果这里指定了\nMockitoJUnitRunner那么SpringRunner就不会被使用。</p>\n<p>指定MockitoJUnitRunner</p>\n<div><pre><code>   <span>@RunWith</span><span>(</span><span>MockitoJUnitRunner</span><span>.</span><span>class</span><span>)</span>\n   <span>public</span> <span>class</span> <span>ExampleTest</span> <span>{</span>\n   \n       <span>@Mock</span>\n       <span>private</span> <span>List</span> list<span>;</span>\n   \n       <span>@Test</span>\n       <span>public</span> <span>void</span> <span>shouldDoSomething</span><span>(</span><span>)</span> <span>{</span>\n           list<span>.</span><span>add</span><span>(</span><span>100</span><span>)</span><span>;</span>\n       <span>}</span>\n   <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id=\"_1-2-方式-2-依赖容器\"> 1.2 方式:2 依赖容器</h3>\n<p>方式2是依赖于Spring容器的,所以要求我们在单测方法执行前来通知Mockito来处理\n他的逻辑,处理他说使用的注解。JUnit4的@Before注解就是做好的加载时机,因为我们\n可以这样写。</p>\n<div><pre><code>   <span>/**\n     * 将单测类中依赖Mockito的属性,进行处理。\n     * 帮我们实现 Mockito.mock()\n     */</span>\n    <span>@Before</span>\n    <span>public</span> <span>void</span> <span>setUp</span><span>(</span><span>)</span> <span>{</span>\n        <span>MockitoAnnotations</span><span>.</span><span>initMocks</span><span>(</span><span>this</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id=\"二、mockito必知概念\"> 二、Mockito必知概念</h2>\n<h3 id=\"_2-1-完全模拟-mock\"> 2.1 完全模拟 Mock</h3>\n<p>什么是完全模拟,使用的注解就是@Mock。被Mock的对象,所有的方法都不会被\n真正的执行。</p>\n<h3 id=\"_2-2-部分模拟-spy\"> 2.2 部分模拟 Spy</h3>\n<p>部分模拟,使用的注解就是@Spy(间谍一样)。被声明的方法走Mock,没有声明的方法\n还是由实例进行执行和反馈。</p>\n<h2 id=\"三、代码实例\"> 三、代码实例</h2>\n<p>这里的例子我们为了启动快速,不依赖Spring容器。直接new出来对象。\n另外多说一句,其实就算依赖Spring容器,当@Before方法执行前所有的示例其实也都是已经注入好的了。</p>\n<p>下面所有的演示围绕这个类进行</p>\n<div><pre><code><span>public</span> <span>class</span> <span>MockitoEmp</span> <span>{</span>\n        <span>public</span> <span>String</span> <span>getName</span><span>(</span><span>)</span> <span>{</span>\n            <span>return</span> <span>\"真实的MockitoTest\"</span><span>;</span>\n        <span>}</span>\n\n        <span>public</span> <span>Integer</span> <span>getAge</span><span>(</span><span>)</span> <span>{</span>\n            <span>return</span> <span>23</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"_3-1-mock\"> 3.1 @Mock</h3>\n<p>手动声明</p>\n<div><pre><code><span>MockitoEmp</span> mock <span>=</span> <span>Mockito</span><span>.</span><span>mock</span><span>(</span><span>MockitoEmp</span><span>.</span><span>class</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><div><p>说明</p>\n<p>前面说了这个是完全模拟,所有的动作都是模拟的。看下面代码颜色\n标记的地方,我们只声明了getName使用Mock返回。但是当我们\n调用getAge() 的时候竟然也是假数据。</p>\n</div>\n<p>基于注解和@Before自动声明</p>\n<div><div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br></div><pre><code>\n<span>public</span> <span>class</span> <span>MockitoTest</span> <span>{</span>\n\n    <span>// 整个对象都是Mock的</span>\n    <span>@Mock</span>\n    <span>private</span> <span>MockitoEmp</span> mock <span>=</span> <span>new</span> <span>MockitoEmp</span><span>(</span><span>)</span><span>;</span>\n\n    <span>/**\n     * 将单测类中依赖Mockito的属性,进行处理。\n     * 帮我们实现 Mockito.mock()\n     */</span>\n    <span>@Before</span>\n    <span>public</span> <span>void</span> <span>setUp</span><span>(</span><span>)</span> <span>{</span>\n        <span>MockitoAnnotations</span><span>.</span><span>initMocks</span><span>(</span><span>this</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>testMock</span><span>(</span><span>)</span> <span>{</span>\n        <span>Mockito</span><span>.</span><span>doReturn</span><span>(</span><span>\"Mock数据\"</span><span>)</span><span>.</span><span>when</span><span>(</span>mock<span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>;</span>\n        <span>//等价于Mockito.when(mock.getName()).thenReturn(\"Mock数据\");</span>\n        <span>// Mock数据</span>\n        <span>Assert</span><span>.</span><span>assertSame</span><span>(</span><span>\"Mock数据\"</span><span>,</span> mock<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// getAge() 方法没有用Mockito声明动作, 应该是多少呢?</span>\n        <span>Assert</span><span>.</span><span>assertSame</span><span>(</span><span>0</span><span>,</span> mock<span>.</span><span>getAge</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// 0</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>mock<span>.</span><span>getAge</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><h3 id=\"_3-2-spy\"> 3.2 @Spy</h3>\n<p>手动声明</p>\n<div><pre><code><span>MockitoEmp</span> spy <span>=</span> <span>Mockito</span><span>.</span><span>spy</span><span>(</span><span>MockitoEmp</span><span>.</span><span>class</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><div><p>说明</p>\n<p>Spy部分模拟,下面的例子和上面基本一样,唯一不一样的是我们吧 @Mock换成了@Spy。\n此时getAge() 方法就不是模拟的了。</p>\n</div>\n<p>基于注解和@Before自动声明</p>\n<div><div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><div>&nbsp;</div><br><br><br><br><br><br></div><pre><code>\n<span>public</span> <span>class</span> <span>MockitoTest</span> <span>{</span>\n\n    <span>// 整个对象都是Mock的</span>\n    <span>@Mock</span>\n    <span>private</span> <span>MockitoEmp</span> mock <span>=</span> <span>new</span> <span>MockitoEmp</span><span>(</span><span>)</span><span>;</span>\n\n    <span>/**\n     * 将单测类中依赖Mockito的属性,进行处理。\n     * 帮我们实现 Mockito.mock()\n     */</span>\n    <span>@Before</span>\n    <span>public</span> <span>void</span> <span>setUp</span><span>(</span><span>)</span> <span>{</span>\n        <span>MockitoAnnotations</span><span>.</span><span>initMocks</span><span>(</span><span>this</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>testSpy</span><span>(</span><span>)</span> <span>{</span>\n        <span>Mockito</span><span>.</span><span>doReturn</span><span>(</span><span>\"Mock数据\"</span><span>)</span><span>.</span><span>when</span><span>(</span>spy<span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>;</span>\n        <span>// Mock数据</span>\n        <span>Assert</span><span>.</span><span>assertSame</span><span>(</span><span>\"Mock数据\"</span><span>,</span> spy<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// getAge() 方法没有用Mockito声明动作, 应该是多少呢?</span>\n        <span>Assert</span><span>.</span><span>assertSame</span><span>(</span><span>23</span><span>,</span> spy<span>.</span><span>getAge</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// 23</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>spy<span>.</span><span>getAge</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div>",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-03-24T14:34:44.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "事务回滚原理",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/test/%E4%BA%8B%E5%8A%A1%E5%9B%9E%E6%BB%9A%E5%8E%9F%E7%90%86/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/test/%E4%BA%8B%E5%8A%A1%E5%9B%9E%E6%BB%9A%E5%8E%9F%E7%90%86/",
      "content_html": "<p>在前文单测类注入中我们知道.JUnit提供了一些监听器,允许\n当单测方法执行时候去对单测上下文进行调整。所以呢事务回滚也是基于\n这里的特性完成的。<Version>基于SpringBoot 2.1.x版本分析</Version></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1617795655000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"源码分析\"> 源码分析</h3>\n<p>Spring中为了适配不通的数据库,提供了事务平台的概念。 <code>PlatformTransactionManager</code> 只要实现了该接口\n就允许对事务进行控制。具体事务的控制是通过工具类来处理的。 <code>TransactionContextHolder</code> 可以获取当前线程\n执行的事务上下文。JUnit通过该工具拿到事务的上下文,然后对此做响应的修改。具体的\n修改逻辑见下文注释。两句话解释清楚。</p>\n<p><code>TransactionalTestExecutionListener</code></p>\n<p>伪代码分析</p>\n<div><div><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><pre><code>    <span>// 单测方法执行前,移除容器原来的事务管理器,然后开启一个新的事务</span>\n    <span>@Override</span>\n\t<span>public</span> <span>void</span> <span>beforeTestMethod</span><span>(</span><span>final</span> <span>TestContext</span> testContext<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n\t\t<span>Method</span> testMethod <span>=</span> testContext<span>.</span><span>getTestMethod</span><span>(</span><span>)</span><span>;</span>\n\t\t<span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> testClass <span>=</span> testContext<span>.</span><span>getTestClass</span><span>(</span><span>)</span><span>;</span>\n\t\t<span>Assert</span><span>.</span><span>notNull</span><span>(</span>testMethod<span>,</span> <span>\"Test method of supplied TestContext must not be null\"</span><span>)</span><span>;</span>\n\n\t\t<span>TransactionContext</span> txContext <span>=</span> <span>TransactionContextHolder</span><span>.</span><span>removeCurrentTransactionContext</span><span>(</span><span>)</span><span>;</span>\n\t\t<span>Assert</span><span>.</span><span>state</span><span>(</span>txContext <span>==</span> <span>null</span><span>,</span> <span>\"Cannot start new transaction without ending existing transaction\"</span><span>)</span><span>;</span>\n\n\t\t<span>PlatformTransactionManager</span> tm <span>=</span> <span>null</span><span>;</span>\n\t\t<span>TransactionAttribute</span> transactionAttribute <span>=</span> <span>this</span><span>.</span>attributeSource<span>.</span><span>getTransactionAttribute</span><span>(</span>testMethod<span>,</span> testClass<span>)</span><span>;</span>\n\n\t\t<span>if</span> <span>(</span>transactionAttribute <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n\t\t\ttransactionAttribute <span>=</span> <span>TestContextTransactionUtils</span><span>.</span><span>createDelegatingTransactionAttribute</span><span>(</span>testContext<span>,</span>\n\t\t\t\ttransactionAttribute<span>)</span><span>;</span>\n\n\t\t\t<span>if</span> <span>(</span>logger<span>.</span><span>isDebugEnabled</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n\t\t\t\tlogger<span>.</span><span>debug</span><span>(</span><span>\"Explicit transaction definition [\"</span> <span>+</span> transactionAttribute <span>+</span>\n\t\t\t\t\t\t<span>\"] found for test context \"</span> <span>+</span> testContext<span>)</span><span>;</span>\n\t\t\t<span>}</span>\n\n\t\t\t<span>if</span> <span>(</span>transactionAttribute<span>.</span><span>getPropagationBehavior</span><span>(</span><span>)</span> <span>==</span> <span>TransactionDefinition</span><span>.</span>PROPAGATION_NOT_SUPPORTED<span>)</span> <span>{</span>\n\t\t\t\t<span>return</span><span>;</span>\n\t\t\t<span>}</span>\n\n\t\t\ttm <span>=</span> <span>getTransactionManager</span><span>(</span>testContext<span>,</span> transactionAttribute<span>.</span><span>getQualifier</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\t\t\t<span>Assert</span><span>.</span><span>state</span><span>(</span>tm <span>!=</span> <span>null</span><span>,</span>\n\t\t\t\t\t<span>(</span><span>)</span> <span>-></span> <span>\"Failed to retrieve PlatformTransactionManager for @Transactional test: \"</span> <span>+</span> testContext<span>)</span><span>;</span>\n\t\t<span>}</span>\n\n\t\t<span>if</span> <span>(</span>tm <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n\t\t\ttxContext <span>=</span> <span>new</span> <span>TransactionContext</span><span>(</span>testContext<span>,</span> tm<span>,</span> transactionAttribute<span>,</span> <span>isRollback</span><span>(</span>testContext<span>)</span><span>)</span><span>;</span>\n\t\t\t<span>runBeforeTransactionMethods</span><span>(</span>testContext<span>)</span><span>;</span>\n\t\t\ttxContext<span>.</span><span>startTransaction</span><span>(</span><span>)</span><span>;</span>\n\t\t\t<span>TransactionContextHolder</span><span>.</span><span>setCurrentTransactionContext</span><span>(</span>txContext<span>)</span><span>;</span>\n\t\t<span>}</span>\n\t<span>}</span>\n\t\n\t<span>// 单测方法执行结束后,结束事务然后回滚或提交</span>\n\t<span>@Override</span>\n\t<span>public</span> <span>void</span> <span>afterTestMethod</span><span>(</span><span>TestContext</span> testContext<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n\t\t<span>Method</span> testMethod <span>=</span> testContext<span>.</span><span>getTestMethod</span><span>(</span><span>)</span><span>;</span>\n\t\t<span>Assert</span><span>.</span><span>notNull</span><span>(</span>testMethod<span>,</span> <span>\"The test method of the supplied TestContext must not be null\"</span><span>)</span><span>;</span>\n\n\t\t<span>TransactionContext</span> txContext <span>=</span> <span>TransactionContextHolder</span><span>.</span><span>removeCurrentTransactionContext</span><span>(</span><span>)</span><span>;</span>\n\t\t<span>// If there was (or perhaps still is) a transaction...</span>\n\t\t<span>if</span> <span>(</span>txContext <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n\t\t\t<span>TransactionStatus</span> transactionStatus <span>=</span> txContext<span>.</span><span>getTransactionStatus</span><span>(</span><span>)</span><span>;</span>\n\t\t\t<span>try</span> <span>{</span>\n\t\t\t\t<span>// If the transaction is still active...</span>\n\t\t\t\t<span>if</span> <span>(</span>transactionStatus <span>!=</span> <span>null</span> <span>&amp;&amp;</span> <span>!</span>transactionStatus<span>.</span><span>isCompleted</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n\t\t\t\t\ttxContext<span>.</span><span>endTransaction</span><span>(</span><span>)</span><span>;</span>\n\t\t\t\t<span>}</span>\n\t\t\t<span>}</span>\n\t\t\t<span>finally</span> <span>{</span>\n\t\t\t\t<span>runAfterTransactionMethods</span><span>(</span>testContext<span>)</span><span>;</span>\n\t\t\t<span>}</span>\n\t\t<span>}</span>\n\t<span>}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br></div></div>",
      "image": "https://img.springlearn.cn/blog/learn_1617795655000.png",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-03-24T14:34:44.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "单测维护",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/test/%E5%8D%95%E6%B5%8B%E7%BB%B4%E6%8A%A4/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/test/%E5%8D%95%E6%B5%8B%E7%BB%B4%E6%8A%A4/",
      "content_html": "<div><p>单测维护</p>\n</div>\n<h2 id=\"一、考虑不要跳过单测\"> 一、考虑不要跳过单测</h2>\n<p>目前我们都是跳过单测的,测试都是每次改造完成后,手工去进行验证。\n验证没有问题就提测了。这样的单测是没有维护性的。</p>\n<p>当我们建立起单测体系后,真正重视单测维护后,就可以考虑不要跳过单元测试\n这样,每次编译时候都可以执行一遍单测用例,观察失败的单测试服是这次改造的bug导致。</p>\n<h2 id=\"二、后期维护单测\"> 二、后期维护单测</h2>\n<p>开发时间紧张,没有进行单测就提测了,测试也通过了。对于这类代码后期可以补充上单测。方便后面进行业务调整时候,进行单测验证。</p>\n<p>只有这样开发人员才更有底气。</p>\n<h2 id=\"三、售后服务\"> 三、售后服务</h2>\n<p>应用Owner要督促,应用成员要重视。做好应用质量把控。</p>\n",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-03-24T14:34:44.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "启动缓慢",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/test/%E5%90%AF%E5%8A%A8%E7%BC%93%E6%85%A2/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/test/%E5%90%AF%E5%8A%A8%E7%BC%93%E6%85%A2/",
      "content_html": "<div><p>启动缓慢分析</p>\n<p>当应用中拥有大对象,可能会导致单侧启动比较慢,针对这种问题有不同的解决方案</p>\n</div>\n<h3 id=\"springboot-2-2-解决方案\"> SpringBoot 2.2 解决方案</h3>\n<div><pre><code>spring.main.lazy-initialization = true\n</code></pre>\n<div><span>1</span><br></div></div><p>SpringApplication 会自动添加一个叫 <code>LazyInitializationBeanFactoryPostProcessor</code>的处理器\n<img src=\"https://img.springlearn.cn/blog/learn_1617787733000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"springboot-2-2-以前\"> SpringBoot 2.2 以前</h3>\n<p>给应用上下文提前装载一个类似的处理器,然后通过 <code>BeanFactoryPostProcessor</code> 在容器刷新前循环将 <code>BeanDefinition</code> 声明懒加载</p>\n<div><pre><code><span>public</span> <span>class</span> <span>BeanLazyApplicationContextInitializer</span> <span>implements</span> <span>ApplicationContextInitializer</span><span><span>&lt;</span><span>ConfigurableApplicationContext</span><span>></span></span> <span>{</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>initialize</span><span>(</span><span>ConfigurableApplicationContext</span> applicationContext<span>)</span> <span>{</span>\n        applicationContext<span>.</span><span>addBeanFactoryPostProcessor</span><span>(</span><span>new</span> <span>LazyBeanDefinitionPostProcessor</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>class</span> <span>LazyBeanDefinitionPostProcessor</span> <span>implements</span> <span>BeanFactoryPostProcessor</span><span>,</span> <span>Ordered</span> <span>{</span>\n\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>postProcessBeanFactory</span><span>(</span><span>ConfigurableListableBeanFactory</span> beanFactory<span>)</span> <span>throws</span> <span>BeansException</span> <span>{</span>\n            <span>for</span> <span>(</span><span>String</span> beanName <span>:</span> beanFactory<span>.</span><span>getBeanDefinitionNames</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n                <span>BeanDefinition</span> beanDefinition <span>=</span> beanFactory<span>.</span><span>getBeanDefinition</span><span>(</span>beanName<span>)</span><span>;</span>\n                <span>if</span> <span>(</span>beanDefinition <span>instanceof</span> <span>AbstractBeanDefinition</span><span>)</span> <span>{</span>\n                    beanDefinition<span>.</span><span>setLazyInit</span><span>(</span><span>true</span><span>)</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n\n        <span>@Override</span>\n        <span>public</span> <span>int</span> <span>getOrder</span><span>(</span><span>)</span> <span>{</span>\n            <span>return</span> <span>Ordered</span><span>.</span>HIGHEST_PRECEDENCE<span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><div><p>测试引导类配置变更</p>\n<ul>\n<li>@ContextConfiguration 通过容器初始化去新增处理器</li>\n<li>@ActiveProfiles       指定测试环境激活的配置是local</li>\n</ul>\n</div>\n<p>@ContextConfiguration添加处理器</p>\n<div><pre><code><span>@Slf4j</span>\n<span>@ActiveProfiles</span><span>(</span><span>{</span><span>\"local\"</span><span>}</span><span>)</span>\n<span>@ContextConfiguration</span><span>(</span>initializers <span>=</span> <span>{</span><span>BeanLazyApplicationContextInitializer</span><span>.</span><span>class</span><span>}</span><span>)</span>\n<span>// 使用Spring容器引导</span>\n<span>@RunWith</span><span>(</span><span>SpringRunner</span><span>.</span><span>class</span><span>)</span>\n<span>@SpringBootTest</span><span>(</span>classes <span>=</span> <span>{</span><span>CenterProviderApplication</span><span>.</span><span>class</span><span>}</span><span>)</span> <span>// 指定启动类</span>\n<span>public</span> <span>class</span> <span>BaseApplicationTest</span> <span>{</span>\n    \n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"如何确定版本\"> 如何确定版本?</h3>\n<p><code>Idea</code> 中搜索 <code>@SpringApplication</code> 查看所在的包\n<img src=\"https://img.springlearn.cn/blog/learn_1617787113000.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1617787733000.png",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-03-24T14:34:44.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Feign Mock注意事项",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/test/FeignMock/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/test/FeignMock/",
      "content_html": "<h2 id=\"一、feign接口模拟\"> 一、Feign接口模拟</h2>\n<p>以下两种API的用法会导致你Feign类型推断不出来,建议使用最后一种</p>\n<div建议使用最后一种\" line-numbers-mode\"><pre><code>        <span>Mockito</span><span>.</span><span>when</span><span>(</span>arrivalOrderFeignClient<span>.</span><span>listArrivalNoticeBatch</span><span>(</span><span>new</span> <span>PmsArrivalNoticeBatchQueryDTO</span><span>(</span><span>)</span><span>)</span><span>)</span><span>.</span><span>thenReturn</span><span>(</span><span>JsonResult</span><span>.</span><span>success</span><span>(</span>result<span>)</span><span>)</span><span>;</span>\n        <span>Mockito</span><span>.</span><span>doReturn</span><span>(</span><span>JsonResult</span><span>.</span><span>success</span><span>(</span>result<span>)</span><span>)</span><span>.</span><span>when</span><span>(</span>arrivalOrderFeignClient<span>)</span><span>.</span><span>listArrivalNoticeBatch</span><span>(</span><span>Mockito</span><span>.</span><span>any</span><span>(</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h2 id=\"二、mapper接口要使用mock\"> 二、Mapper接口要使用Mock</h2>\n<p>对于Service层的数据测试,Mapper类使用@MockBean。保证数据都是模拟的。</p>\n<p>对于Dal层数据测试,Mapper使用真实的示例信息。</p>\n",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-03-24T14:34:44.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "命名规则",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/test/%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/test/%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/",
      "content_html": "<div><p>命名规则</p>\n<p>单测类: 类名 + <code>Test</code> 整体大驼峰</p>\n<p>单测方法: <code>test</code> + 方法名 整体小驼峰</p>\n</div>\n<h3 id=\"保证目录结构是一致的\"> 保证目录结构是一致的</h3>\n<p>在这里有个误区,发现很多同学都是随意去创建测试类,其实这不是一个好的习惯,在Maven项目中,\n要尽量保证测试类与被测类的目录结构是一致的。如下图一样。这样的好处是,我们可以快速在\n这两个类中进行快捷键跳转,也方便我们去新增测试方法。<Highlight color=\"green\">跳转快捷键和创建快捷键保持一致,见下文.</Highlight></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1618123124000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>其实Idea已经为我们提供了快捷操作,如下图。</p>\n<p><img src=\"/junit.gif\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"快捷键\"> 快捷键</h3>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1618036976000.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1618123124000.png",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-03-24T14:34:44.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Spring循环依赖",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/spring/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/spring/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/learn_1647108921000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者: 八阿哥的剑</strong></p>\n<p><em>博客: https://springlearn.cn</em></p>\n<div><p>一日一句毒鸡汤</p>\n<p>问世间钱为何物，只叫人生死相许。！😄</p>\n</div>\n<p>写文章不容易，如果感觉还行，请点个关注，点关注不迷路。</p>\n<h2 id=\"一、什么是循环依赖\"> 一、什么是循环依赖</h2>\n<p>这种简单的问题，直接伪代码吧。</p>\n<div><pre><code><span>@Service</span>\n<span>public</span> <span>class</span> <span>A</span> <span>{</span>\n    <span>@Autowired</span>\n    <span>private</span> <span>B</span> b<span>;</span>\n<span>}</span>\n\n<span>@Service</span>\n<span>public</span> <span>class</span> <span>B</span> <span>{</span>\n    <span>@Autowired</span>\n    <span>private</span> <span>A</span> a<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>我中有你，你中有我。</p>\n<h2 id=\"二、解决循环依赖思路\"> 二、解决循环依赖思路</h2>\n<p>思路其实非常简单还是用伪代码来说明</p>\n<div><pre><code><span>A</span> a <span>=</span> <span>new</span> <span>A</span><span>(</span><span>)</span><span>;</span>\n<span>B</span> b <span>=</span> <span>new</span> <span>B</span><span>(</span><span>)</span><span>;</span>\na<span>.</span><span>setB</span><span>(</span>b<span>)</span><span>;</span>\nb<span>.</span><span>setA</span><span>(</span>a<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>思路就是这么简单，先分别把A和B给实例化。\n这时候实例化的A和B仅仅是完成了实例化,内部的属性其实都没有。\n只有当执行了3、4行才算正常完成。</p>\n<div><div><br><br><div>&nbsp;</div><div>&nbsp;</div><br></div><pre><code><span>A</span> a <span>=</span> <span>new</span> <span>A</span><span>(</span><span>)</span><span>;</span>\n<span>B</span> b <span>=</span> <span>new</span> <span>B</span><span>(</span><span>)</span><span>;</span>\na<span>.</span><span>setB</span><span>(</span>b<span>)</span><span>;</span>\nb<span>.</span><span>setA</span><span>(</span>a<span>)</span><span>;</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>通过上面的代码我们总结下，要想实现循环注入。首先要满足第一个条件。</p>\n<ol>\n<li><strong>能被实例化</strong></li>\n</ol>\n<ul>\n<li>有空构造</li>\n<li>或有构造且构造参数满足能被实例化。</li>\n</ul>\n<p>好了，知道这点就成了，相信让你来实现循环注入，应该也可以了吧。其实就这么简单 ?</p>\n<p>那我们来看Spring如何来实现的。相信看完你就头大了。但是没关系，基本原理你已经知道了。\n带着这个思路来看Spring的源码就简单了。</p>\n<h2 id=\"三、spring如何解决循环依赖\"> 三、Spring如何解决循环依赖</h2>\n<p>首先我们要知道Spring中的bean, 有两种形式。</p>\n<ul>\n<li>第一种是单例。所谓单例就是容器中这个类，只会存在一个实例。不管你调用了多少次 <code>getBean(String beanName)</code> 返回的都是一个实例(因为每次都从缓存中获取的实例)。</li>\n<li>第二种是原型。所谓原型就是容器中这个类，没有缓存。每次都是新建一个Bean。</li>\n</ul>\n<p>在这里我们思考下，如果要你来实现循环注入，以上两种模式。你能用那一个?\n要想实现循环注入，即这个Bean必须要有一个缓存的地方。不然每次都是创建，虽然能完成实例化，但是实例化后，需要注入的 <code>bean</code> 无法实现注入，就会陷入死循环。</p>\n<p>这里第二个必要因素就出来了。</p>\n<p><mark>2. 必须要是单例</mark></p>\n<p>好了，知道这么多我们开始看源码吧。</p>\n<h3 id=\"_3-1-spring中创建bean的步骤\"> 3.1 Spring中创建Bean的步骤</h3>\n<ul>\n<li>实例化，createBeanInstance，就是new了个对象。</li>\n<li>属性注入，populateBean， 就是 set 一些属性值。</li>\n<li>初始化，initializeBean，执行一些 aware 接口中的方法，initMethod，AOP代理等</li>\n</ul>\n<h3 id=\"_3-2-循环依赖三层缓存\"> 3.2 循环依赖三层缓存</h3>\n<p>注意看细节，每个缓存的数据类型是什么? 后面要考。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1647104251000.png\" alt=\"\" loading=\"lazy\"></p>\n<ul>\n<li>一级缓存 <code>Map&lt;String, Object&gt; singletonObjects</code>\n<ul>\n<li>如果等于空，或者当前单例正在创建中(即只完成了实例化)。就从二级缓存中获取。</li>\n</ul>\n</li>\n<li>二级缓存 <code>Map&lt;String, Object&gt; earlySingletonObjects</code>\n<ul>\n<li>如果等于空，就从三级缓存中获取。</li>\n</ul>\n</li>\n<li>三级缓存 <code>Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories</code>\n<ul>\n<li>创建Bean的一个工厂，允许容器中定义特殊的，生成Bean的方法。使用 <code>addSingletonFactory</code></li>\n</ul>\n</li>\n</ul>\n<p>其实要想实现循环依赖只用2个缓存就行。三级缓存的意义是为了完成某些功能。至于什么功能呢? 这里先不说后面看流程。</p>\n<div><div><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><pre><code><span>protected</span> <span>Object</span> <span>getSingleton</span><span>(</span><span>String</span> beanName<span>,</span> <span>boolean</span> allowEarlyReference<span>)</span> <span>{</span>\n\t\t<span>Object</span> singletonObject <span>=</span> <span>this</span><span>.</span>singletonObjects<span>.</span><span>get</span><span>(</span>beanName<span>)</span><span>;</span>\n\t\t<span>if</span> <span>(</span>singletonObject <span>==</span> <span>null</span> <span>&amp;&amp;</span> <span>isSingletonCurrentlyInCreation</span><span>(</span>beanName<span>)</span><span>)</span> <span>{</span>\n\t\t\t<span>synchronized</span> <span>(</span><span>this</span><span>.</span>singletonObjects<span>)</span> <span>{</span>\n\t\t\t\tsingletonObject <span>=</span> <span>this</span><span>.</span>earlySingletonObjects<span>.</span><span>get</span><span>(</span>beanName<span>)</span><span>;</span>\n\t\t\t\t<span>if</span> <span>(</span>singletonObject <span>==</span> <span>null</span> <span>&amp;&amp;</span> allowEarlyReference<span>)</span> <span>{</span>\n\t\t\t\t\t<span>ObjectFactory</span><span><span>&lt;</span><span>?</span><span>></span></span> singletonFactory <span>=</span> <span>this</span><span>.</span>singletonFactories<span>.</span><span>get</span><span>(</span>beanName<span>)</span><span>;</span>\n\t\t\t\t\t<span>if</span> <span>(</span>singletonFactory <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n\t\t\t\t\t\tsingletonObject <span>=</span> singletonFactory<span>.</span><span>getObject</span><span>(</span><span>)</span><span>;</span>\n\t\t\t\t\t\t<span>this</span><span>.</span>earlySingletonObjects<span>.</span><span>put</span><span>(</span>beanName<span>,</span> singletonObject<span>)</span><span>;</span>\n\t\t\t\t\t\t<span>this</span><span>.</span>singletonFactories<span>.</span><span>remove</span><span>(</span>beanName<span>)</span><span>;</span>\n\t\t\t\t\t<span>}</span>\n\t\t\t\t<span>}</span>\n\t\t\t<span>}</span>\n\t\t<span>}</span>\n\t\t<span>return</span> singletonObject<span>;</span>\n\t<span>}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>好我们知道有这两个缓存就继续往下看源码。当 <code>getSingleton</code> 是 <code>null</code>。继续往下走。其他源码就跳过了，不是本篇的主要内容，我们只看\n解决循环依赖的核心代码。</p>\n<ul>\n<li>doCreateBean#createBeanInstance 先实现实例化。</li>\n<li>当前bean是单例,不会添加到二级缓存，直接就添加到三级缓存中,注意这里不是添加的Bean，而是生成Bean的工厂方法 <code>ObjectFactory(#getEarlyBeanReference)</code>。</li>\n</ul>\n<div><div><br><br><br><br><br><br><br><div>&nbsp;</div><br><br></div><pre><code>\t   <span>boolean</span> earlySingletonExposure <span>=</span> <span>(</span>mbd<span>.</span><span>isSingleton</span><span>(</span><span>)</span> <span>&amp;&amp;</span> <span>this</span><span>.</span>allowCircularReferences <span>&amp;&amp;</span>\n\t\t\t\t<span>isSingletonCurrentlyInCreation</span><span>(</span>beanName<span>)</span><span>)</span><span>;</span>\n\t\t<span>if</span> <span>(</span>earlySingletonExposure<span>)</span> <span>{</span>\n\t\t\t<span>if</span> <span>(</span>logger<span>.</span><span>isTraceEnabled</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n\t\t\t\tlogger<span>.</span><span>trace</span><span>(</span><span>\"Eagerly caching bean '\"</span> <span>+</span> beanName <span>+</span>\n\t\t\t\t\t\t<span>\"' to allow for resolving potential circular references\"</span><span>)</span><span>;</span>\n\t\t\t<span>}</span>\n\t\t\t<span>addSingletonFactory</span><span>(</span>beanName<span>,</span> <span>(</span><span>)</span> <span>-></span> <span>getEarlyBeanReference</span><span>(</span>beanName<span>,</span> mbd<span>,</span> bean<span>)</span><span>)</span><span>;</span>\n\t\t<span>}</span> \n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><ul>\n<li>doCreateBean#populateBean 实现属性注入</li>\n</ul>\n<p>以上面的代码的例子，A创建时候被加入到了三级缓存中，然后继续执行 <code>populateBean</code>。发现要依赖B。然后依次从缓存中\n来找这个A。最终在三级缓存中读取到了B。然后实现注入。这里三级缓存中的 <code>Bean</code>。 有可能只是完成了 <code>new</code>。但是容器\n不管，先完成循环注入。至于注入的东西是否是完全品还是半成品不关心，因为都是单例所以，后面在注入属性也没关系。\n这里我们知道单例的用处了吧。试想一下，如果不是单例模式，而是原型模式。那么bean就必须是完全品，不然就陷入了死循环。</p>\n<p>下面我们还用伪代码的方式再来说一篇实现思路。</p>\n<div><pre><code><span>// createBeanInstance先实例化，然后加入到三级缓存中</span>\n<span>A</span> a <span>=</span> <span>new</span> <span>A</span><span>(</span><span>)</span><span>;</span>\n<span>// a在执行populateBean的时候，发现要注入属性B，于是就使用getBean。</span>\n<span>// getBean(b) 执行createBeanInstance先实例化</span>\n<span>B</span> b <span>=</span> <span>new</span> <span>B</span><span>(</span><span>)</span><span>;</span>\n<span>// 然后加入到三级缓存中，b在执行populateBean注入属性值的时候。发现也依赖了A。</span>\n<span>// 然后从缓存中找到办成品A。于是乎B的注入就完成，然后再执行B的init方法。</span>\nb<span>.</span><span>setA</span><span>(</span>a<span>)</span><span>;</span>\n<span>// B完成后,则返回到A的populateBean也注入了B。然后在执行A的init方法</span>\na<span>.</span><span>setB</span><span>(</span>b<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>到这里就完成了循环注入，这里有点绕，小编画了一个图，大家跟着序号来看，然后好好理解下。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1647104949000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>通过这个图其实我们能发现一个问题。B此时从三级缓存中拿到的A是一个半成品的A。\n假如B在执行初始化方法的时候,依赖A的populateBean注入的属性。那么此时一定会拿不到的。\n下面写点伪代码，说一下这个问题。</p>\n<h3 id=\"_3-3-发现点问题\"> 3.3 发现点问题</h3>\n<h4 id=\"_3-3-1-半成品问题-1\"> 3.3.1 半成品问题-1</h4>\n<div><pre><code><span>@Component</span>\n<span>public</span> <span>class</span> <span>A</span> <span>implements</span> <span>InitializingBean</span> <span>{</span>\n\n    <span>@Autowired</span>\n    <span>private</span> <span>B</span> b<span>;</span>\n\n    <span>@Value</span><span>(</span><span>\"${a.name}\"</span><span>)</span>\n    <span>private</span> <span>String</span> name<span>;</span>\n\n    <span>public</span> <span>String</span> <span>getName</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> name<span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>afterPropertiesSet</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"A:\"</span> <span>+</span> b<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>@Component</span>\n<span>public</span> <span>class</span> <span>B</span> <span>implements</span> <span>InitializingBean</span> <span>{</span>\n\n    <span>@Autowired</span>\n    <span>private</span> <span>A</span> a<span>;</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>afterPropertiesSet</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"B:\"</span> <span>+</span> a<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p><img src=\"https://img.springlearn.cn/blog/learn_1647105136000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>通过上图我们知道B会先执行初始化，而这里B的初始化 <mark>(图例8)</mark> 会依赖A的参数注入 <mark>(图例4)</mark> 。而B在执行初始化的时候。A(图例4没有完全完成注入)并没有完成属性注入。\n那么我们此时在拿到A的getName一定是空的。</p>\n<p><strong>以上代码执行就是:</strong></p>\n<div><pre><code><span>B</span><span>:</span><span>null</span>\n<span>A</span><span>:</span><span><span>com<span>.</span>example<span>.</span>demo<span>.</span></span>B</span><span>@38aa816f</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h4 id=\"_3-3-2-半成品问题-2\"> 3.3.2 半成品问题-2</h4>\n<p>A的BeanPostProcessor没有执行,那么假如我们想要对A进行方法代理。B在执行初始化的时候,调用A的 <code>getName</code>。会成功代理上吗?</p>\n<div><pre><code><span>@Component</span>\n<span>public</span> <span>class</span> <span>A</span> <span>implements</span> <span>InitializingBean</span> <span>{</span>\n\n    <span>@Autowired</span>\n    <span>private</span> <span>B</span> b<span>;</span>\n\n    <span>private</span> <span>final</span> <span>String</span> name <span>=</span> <span>\"孙悟空\"</span><span>;</span>\n\n    <span>public</span> <span>String</span> <span>getName</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> name<span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>afterPropertiesSet</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"A:\"</span> <span>+</span> b<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n<span>@Component</span>\n<span>public</span> <span>class</span> <span>B</span> <span>implements</span> <span>InitializingBean</span> <span>{</span>\n\n    <span>@Autowired</span>\n    <span>private</span> <span>A</span> a<span>;</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>afterPropertiesSet</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"B:\"</span> <span>+</span> a<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n<span>@Aspect</span>\n<span>@Component</span>\n<span>public</span> <span>class</span> <span>AopConfig</span> <span>{</span>\n\n    <span>/**\n     * 精确匹配类名\n     */</span>\n    <span>@Pointcut</span><span>(</span><span>\"within(A)\"</span><span>)</span>\n    <span>private</span> <span>void</span> <span>matchClass</span><span>(</span><span>)</span> <span>{</span>\n    <span>}</span>\n\n    <span>@Before</span><span>(</span><span>\"matchClass()\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>beforeMatchClassName</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"--------精确匹配类名-------\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><p><strong>执行结果:</strong></p>\n<div><pre><code><span>--</span><span>--</span><span>--</span><span>--</span>精确匹配类名<span>--</span><span>--</span><span>--</span><span>-</span>\n<span>B</span><span>:</span>孙悟空\n<span>A</span><span>:</span><span><span>com<span>.</span>example<span>.</span>demo<span>.</span></span>B</span><span>@5e01a982</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>发现疑问了吗? 前面我们说了,在执行B图例8的时候(b的初始化方法)，A图例9并没有执行，那为什么这里会代理成功呢?\n<img src=\"https://img.springlearn.cn/blog/learn_1647105949000.png\" alt=\"\" loading=\"lazy\"></p>\n<div><p>答案揭晓</p>\n<p>这里在添加缓存的时候，并不是直接把实例添加到缓存中的。\n而是将图例9的逻辑，封装到\nObjectFactory的方式添加到缓存中的。\nObjectFactory#getObject时候执行了Bean\n的处理。(AOP代理等)</p>\n</div>\n<p><strong>注意: 这里并不是把所有的处理器都包装到ObjectFactory方法中,而是有选择的使用,只有实现了SmartInstantiationAwareBeanPostProcessor接口\n才会放到里面。</strong></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1647106252000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>答案就在这里，这里执行了。一些特殊逻辑的处理器。当实现了 <code>SmartInstantiationAwareBeanPostProcessor</code> 接口。\n就可以提前对那些半成品的Bean进行处理。</p>\n<div><div><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br></div><pre><code><span>protected</span> <span>Object</span> <span>getEarlyBeanReference</span><span>(</span><span>String</span> beanName<span>,</span> <span>RootBeanDefinition</span> mbd<span>,</span> <span>Object</span> bean<span>)</span> <span>{</span>\n\t\t<span>Object</span> exposedObject <span>=</span> bean<span>;</span>\n\t\t<span>if</span> <span>(</span><span>!</span>mbd<span>.</span><span>isSynthetic</span><span>(</span><span>)</span> <span>&amp;&amp;</span> <span>hasInstantiationAwareBeanPostProcessors</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n\t\t\t<span>for</span> <span>(</span><span>SmartInstantiationAwareBeanPostProcessor</span> bp <span>:</span> <span>getBeanPostProcessorCache</span><span>(</span><span>)</span><span>.</span>smartInstantiationAware<span>)</span> <span>{</span>\n\t\t\t\texposedObject <span>=</span> bp<span>.</span><span>getEarlyBeanReference</span><span>(</span>exposedObject<span>,</span> beanName<span>)</span><span>;</span>\n\t\t\t<span>}</span>\n\t\t<span>}</span>\n\t\t<span>return</span> exposedObject<span>;</span>\n\t<span>}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>比如AOP的实现类。\n<img src=\"https://img.springlearn.cn/blog/learn_1647106893000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>这里我们在思考一个问题。A半成品的时候被AOP代理了一次，那么当A在执行Bean处理器的时候岂不是有要被代理一次吗?</p>\n<p>AbstractAutoProxyCreator#getEarlyBeanReference</p>\n<p>第一次代理时候会被加到缓存中。</p>\n<div><pre><code>    <span>public</span> <span>Object</span> <span>getEarlyBeanReference</span><span>(</span><span>Object</span> bean<span>,</span> <span>String</span> beanName<span>)</span> <span>{</span>\n        <span>Object</span> cacheKey <span>=</span> <span>this</span><span>.</span><span>getCacheKey</span><span>(</span>bean<span>.</span><span>getClass</span><span>(</span><span>)</span><span>,</span> beanName<span>)</span><span>;</span>\n        <span>this</span><span>.</span>earlyProxyReferences<span>.</span><span>put</span><span>(</span>cacheKey<span>,</span> bean<span>)</span><span>;</span>\n        <span>return</span> <span>this</span><span>.</span><span>wrapIfNecessary</span><span>(</span>bean<span>,</span> beanName<span>,</span> cacheKey<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>第二次时候在执行AOP后置处理器,会先判断缓存,如果缓存中存在就不在处理了。</p>\n<div><pre><code>   <span>public</span> <span>Object</span> <span>postProcessAfterInitialization</span><span>(</span><span>@Nullable</span> <span>Object</span> bean<span>,</span> <span>String</span> beanName<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>bean <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n            <span>Object</span> cacheKey <span>=</span> <span>this</span><span>.</span><span>getCacheKey</span><span>(</span>bean<span>.</span><span>getClass</span><span>(</span><span>)</span><span>,</span> beanName<span>)</span><span>;</span>\n            <span>if</span> <span>(</span><span>this</span><span>.</span>earlyProxyReferences<span>.</span><span>remove</span><span>(</span>cacheKey<span>)</span> <span>!=</span> bean<span>)</span> <span>{</span>\n                <span>return</span> <span>this</span><span>.</span><span>wrapIfNecessary</span><span>(</span>bean<span>,</span> beanName<span>,</span> cacheKey<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n\n        <span>return</span> bean<span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id=\"四、知识点总结\"> 四、知识点总结</h2>\n<h3 id=\"_4-1-满足循环依赖的条件是什么\"> 4.1 满足循环依赖的条件是什么?</h3>\n<ol>\n<li>必须是单例模式</li>\n<li>循环依赖类,必须能实例化(空构造,或构造参数满足循环依赖条件)</li>\n</ol>\n<h3 id=\"_4-2-循环依赖可能导致什么问题\"> 4.2 循环依赖可能导致什么问题?</h3>\n<p>在执行初始化的时候，如果初始化方法，依赖循环来的属性注入参数，可能导致获取不到数据信息的情况</p>\n<p>如上面问题1。</p>\n<h3 id=\"_4-3-为什么要用三级缓存而不是二级缓存\"> 4.3 为什么要用三级缓存而不是二级缓存?</h3>\n<p>为了满足Spring声明周期方法,即对半成品的B进行提前生命周期处理。如实现AOP。</p>\n<h2 id=\"五、开放性问题\"> 五、开放性问题</h2>\n<p>只使用一级缓存，和三级缓存是否就能解决循环依赖，并且满足bean一些特殊逻辑处理呢（eg:aop）?</p>\n<div><div><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><pre><code><span>protected</span> <span>Object</span> <span>getSingleton</span><span>(</span><span>String</span> beanName<span>,</span> <span>boolean</span> allowEarlyReference<span>)</span> <span>{</span>\n\t\t<span>// Quick check for existing instance without full singleton lock</span>\n\t\t<span>Object</span> singletonObject <span>=</span> <span>this</span><span>.</span>singletonObjects<span>.</span><span>get</span><span>(</span>beanName<span>)</span><span>;</span>\n\t\t<span>if</span> <span>(</span>singletonObject <span>==</span> <span>null</span> <span>&amp;&amp;</span> <span>isSingletonCurrentlyInCreation</span><span>(</span>beanName<span>)</span><span>)</span> <span>{</span>\n\t\t\tsingletonObject <span>=</span> <span>this</span><span>.</span>earlySingletonObjects<span>.</span><span>get</span><span>(</span>beanName<span>)</span><span>;</span>\n\t\t\t<span>if</span> <span>(</span>singletonObject <span>==</span> <span>null</span> <span>&amp;&amp;</span> allowEarlyReference<span>)</span> <span>{</span>\n\t\t\t\t<span>synchronized</span> <span>(</span><span>this</span><span>.</span>singletonObjects<span>)</span> <span>{</span>\n\t\t\t\t\t<span>// Consistent creation of early reference within full singleton lock</span>\n\t\t\t\t\tsingletonObject <span>=</span> <span>this</span><span>.</span>singletonObjects<span>.</span><span>get</span><span>(</span>beanName<span>)</span><span>;</span>\n\t\t\t\t\t<span>if</span> <span>(</span>singletonObject <span>==</span> <span>null</span><span>)</span> <span>{</span>\n\t\t\t\t\t\tsingletonObject <span>=</span> <span>this</span><span>.</span>earlySingletonObjects<span>.</span><span>get</span><span>(</span>beanName<span>)</span><span>;</span>\n\t\t\t\t\t\t<span>if</span> <span>(</span>singletonObject <span>==</span> <span>null</span><span>)</span> <span>{</span>\n\t\t\t\t\t\t\t<span>ObjectFactory</span><span><span>&lt;</span><span>?</span><span>></span></span> singletonFactory <span>=</span> <span>this</span><span>.</span>singletonFactories<span>.</span><span>get</span><span>(</span>beanName<span>)</span><span>;</span>\n\t\t\t\t\t\t\t<span>if</span> <span>(</span>singletonFactory <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n\t\t\t\t\t\t\t\tsingletonObject <span>=</span> singletonFactory<span>.</span><span>getObject</span><span>(</span><span>)</span><span>;</span>\n\t\t\t\t\t\t\t\t<span>this</span><span>.</span>earlySingletonObjects<span>.</span><span>put</span><span>(</span>beanName<span>,</span> singletonObject<span>)</span><span>;</span>\n\t\t\t\t\t\t\t\t<span>this</span><span>.</span>singletonFactories<span>.</span><span>remove</span><span>(</span>beanName<span>)</span><span>;</span>\n\t\t\t\t\t\t\t<span>}</span>\n\t\t\t\t\t\t<span>}</span>\n\t\t\t\t\t<span>}</span>\n\t\t\t\t<span>}</span>\n\t\t\t<span>}</span>\n\t\t<span>}</span>\n\t\t<span>return</span> singletonObject<span>;</span>\n\t<span>}</span>\n\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>小编回答:  仅仅使用1级缓存和3级缓存完全可以的。</p>\n<p>之所以使用2级缓存是因为三级缓存是ObjectFactory#getObject()。是每次都从工厂里面去拿。而使用了2级缓存，仅仅是为了提高性能。\n而设计的。所以一单这个单例Bean完成后。会里面把二级和三级缓存给移除掉。</p>\n<div><pre><code><span>protected</span> <span>void</span> <span>addSingleton</span><span>(</span><span>String</span> beanName<span>,</span> <span>Object</span> singletonObject<span>)</span> <span>{</span>\n\t\t<span>synchronized</span> <span>(</span><span>this</span><span>.</span>singletonObjects<span>)</span> <span>{</span>\n\t\t\t<span>this</span><span>.</span>singletonObjects<span>.</span><span>put</span><span>(</span>beanName<span>,</span> singletonObject<span>)</span><span>;</span>\n\t\t\t<span>this</span><span>.</span>singletonFactories<span>.</span><span>remove</span><span>(</span>beanName<span>)</span><span>;</span>\n\t\t\t<span>this</span><span>.</span>earlySingletonObjects<span>.</span><span>remove</span><span>(</span>beanName<span>)</span><span>;</span>\n\t\t\t<span>this</span><span>.</span>registeredSingletons<span>.</span><span>add</span><span>(</span>beanName<span>)</span><span>;</span>\n\t\t<span>}</span>\n\t<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div>",
      "image": "https://img.springlearn.cn/blog/learn_1647108921000.png",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-03-24T14:34:44.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "②如何知道是否依赖Spring容器",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/test/%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E6%98%AF%E5%90%A6%E4%BE%9D%E8%B5%96Spring%E5%AE%B9%E5%99%A8/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/test/%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E6%98%AF%E5%90%A6%E4%BE%9D%E8%B5%96Spring%E5%AE%B9%E5%99%A8/",
      "content_html": "<p>默认使用 <code>BlockJUnit4ClassRunner</code> 来进行运行。即不依赖容器。\n假如说如果需要容器怎么办呢 ? <Version>基于SpringBoot 2.1.x版本分析</Version></p>\n<div><pre><code><span>@RunWith</span><span>(</span><span>SpringRunner</span><span>.</span><span>class</span><span>)</span>\n<span>@SpringBootTest</span><span>(</span>classes <span>=</span> <span>{</span><span>Application</span><span>.</span><span>class</span><span>}</span><span>)</span> <span>// 指定启动类</span>\n<span>public</span> <span>class</span> <span>BaseApplicationTest</span> <span>{</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ul>\n<li>SpringRunner告诉JUnit要使用Spring容器</li>\n<li>SpringBootTest告诉JUnit容器的引导类是这个</li>\n</ul>\n<p>JUnit是如何实现的呢?</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1617791013000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>前面启动类中我们使用的注解是 <code>@RunWith</code> 和 <code>@SpringBootTest</code> 那么哪里来解析这个的呢?</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1617791209000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>由此 <code>JUnit</code> 知道要使用 <code>SpringRunner</code> 进行引导。</p>\n<p>由上图我们知道 <code>SpringRunner</code> 实例化的入参就是当前的测试类。那么后续所有的奥妙就在这里了。\n我们跟进构造往下追究。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1617795279000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><code>BootstrapUtils#resolveTestContextBootstrapper</code>\n拿到SpringBoot的测试引导类 <code>SpringBootTestContextBootstrapper</code></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1617795346000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>拿到SpringBoot容器的启动 <code>Main</code> 函数。</p>\n<p>到此已经拿到了所有的SpringBoot容器启动参数了。</p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1617791013000.png",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-03-24T14:34:44.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "异步验证",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/test/%E5%BC%82%E6%AD%A5%E9%AA%8C%E8%AF%81/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/test/%E5%BC%82%E6%AD%A5%E9%AA%8C%E8%AF%81/",
      "content_html": "<div><p>请听题</p>\n<p>对于下面这段代码你觉得单测能通过吗?</p>\n</div>\n<p>异步场景</p>\n<div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>test</span><span>(</span><span>)</span> <span>{</span>\n        <span>ExecutorService</span> executorService <span>=</span> <span>Executors</span><span>.</span><span>newFixedThreadPool</span><span>(</span><span>3</span><span>)</span><span>;</span>\n        executorService<span>.</span><span>submit</span><span>(</span><span>new</span> <span>Runnable</span><span>(</span><span>)</span> <span>{</span>\n            <span>@SneakyThrows</span>\n            <span>@Override</span>\n            <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n                <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>5000</span><span>)</span><span>;</span>\n                <span>Object</span> obj <span>=</span> <span>null</span><span>;</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>obj<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"单侧结束\"</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h2 id=\"一、常用解决方案\"> 一、常用解决方案</h2>\n<h3 id=\"_1-1-white解决简单暴力\"> 1.1 white解决简单暴力</h3>\n<p>white解决</p>\n<div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>test</span><span>(</span><span>)</span> <span>{</span>\n        <span>ExecutorService</span> executorService <span>=</span> <span>Executors</span><span>.</span><span>newFixedThreadPool</span><span>(</span><span>3</span><span>)</span><span>;</span>\n        executorService<span>.</span><span>submit</span><span>(</span><span>new</span> <span>Runnable</span><span>(</span><span>)</span> <span>{</span>\n            <span>@SneakyThrows</span>\n            <span>@Override</span>\n            <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n                <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>5000</span><span>)</span><span>;</span>\n                <span>Object</span> obj <span>=</span> <span>null</span><span>;</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>obj<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"单侧结束\"</span><span>)</span><span>;</span>\n        <span>white</span><span>(</span><span>true</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id=\"_1-2-locksupport最大时间限制\"> 1.2 LockSupport最大时间限制</h3>\n<p>LockSupport.parkNanos()线程挂起</p>\n<div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>test</span><span>(</span><span>)</span> <span>{</span>\n        <span>ExecutorService</span> executorService <span>=</span> <span>Executors</span><span>.</span><span>newFixedThreadPool</span><span>(</span><span>3</span><span>)</span><span>;</span>\n        executorService<span>.</span><span>submit</span><span>(</span><span>new</span> <span>Runnable</span><span>(</span><span>)</span> <span>{</span>\n            <span>@SneakyThrows</span>\n            <span>@Override</span>\n            <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n                <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>5000</span><span>)</span><span>;</span>\n                <span>Object</span> obj <span>=</span> <span>null</span><span>;</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>obj<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"单侧结束\"</span><span>)</span><span>;</span>\n         <span>// 挂起指定时间</span>\n        <span>LockSupport</span><span>.</span><span>parkNanos</span><span>(</span><span>TimeUnit</span><span>.</span>SECONDS<span>.</span><span>toNanos</span><span>(</span><span>6</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id=\"二、基于上面两种配合junit定制\"> 二、基于上面两种配合JUnit定制</h2>\n<h3 id=\"_2-1-使用演示\"> 2.1 使用演示</h3>\n<p>📢 注意这里的 @Timed 原生是不具备这个能力的,要基于JUnit进行扩展。</p>\n<p>@Timed 灵活控制时间</p>\n<div><div><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br></div><pre><code>    <span>@Test</span>\n    <span>@Timed</span><span>(</span>millis <span>=</span> <span>5000</span><span>)</span>\n    <span>public</span> <span>void</span> <span>test</span><span>(</span><span>)</span> <span>{</span>\n        <span>ExecutorService</span> executorService <span>=</span> <span>Executors</span><span>.</span><span>newFixedThreadPool</span><span>(</span><span>3</span><span>)</span><span>;</span>\n        executorService<span>.</span><span>submit</span><span>(</span><span>new</span> <span>Runnable</span><span>(</span><span>)</span> <span>{</span>\n            <span>@SneakyThrows</span>\n            <span>@Override</span>\n            <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n                <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>5000</span><span>)</span><span>;</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"任务执行结束\"</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"单侧结束\"</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id=\"_2-2-扩展实现\"> 2.2 扩展实现</h3>\n<p>同样是基于LockSupport线程挂起方案,类似于切面解决。</p>\n<p>扩展TestExecutionListener</p>\n<div><div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br></div><pre><code>\n    <span>private</span> <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Long</span><span>></span></span> timedMap <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n\n    <span>private</span> <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Long</span><span>></span></span> beforeTestCostMap <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n    \n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>beforeTestMethod</span><span>(</span><span>TestContext</span> testContext<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>String</span> key <span>=</span> testContext<span>.</span><span>getTestMethod</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>;</span>\n        beforeTestCostMap<span>.</span><span>put</span><span>(</span>key<span>,</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>Timed</span> timedA <span>=</span> <span>AnnotationUtils</span><span>.</span><span>getAnnotation</span><span>(</span>testContext<span>.</span><span>getTestMethod</span><span>(</span><span>)</span><span>,</span> <span>Timed</span><span>.</span><span>class</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span><span>Objects</span><span>.</span><span>nonNull</span><span>(</span>timedA<span>)</span><span>)</span> <span>{</span>\n            timedMap<span>.</span><span>put</span><span>(</span>testContext<span>.</span><span>getTestMethod</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>,</span> timedA<span>.</span><span>millis</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>Method</span> testMethod <span>=</span> testContext<span>.</span><span>getTestMethod</span><span>(</span><span>)</span><span>;</span>\n        <span>printActiveProfile</span><span>(</span>testContext<span>)</span><span>;</span>\n        <span>checkTransactional</span><span>(</span>testContext<span>)</span><span>;</span>\n        <span>TestConsole</span><span>.</span><span>colorPrintln</span><span>(</span><span>AnsiColor</span><span>.</span>BLUE<span>,</span> <span>\"西魏陶渊明发起了一个单侧用例: {}#{}\"</span><span>,</span> testContext<span>.</span><span>getTestClass</span><span>(</span><span>)</span><span>,</span> testMethod<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>afterTestMethod</span><span>(</span><span>TestContext</span> testContext<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>String</span> key <span>=</span> testContext<span>.</span><span>getTestMethod</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>;</span>\n        <span>Long</span> afterTestCost <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>\n        <span>Long</span> beforeTestCost <span>=</span> beforeTestCostMap<span>.</span><span>get</span><span>(</span>key<span>)</span><span>;</span>\n        <span>long</span> timed <span>=</span> timedMap<span>.</span><span>get</span><span>(</span>key<span>)</span><span>;</span>\n        <span>// 如果耗时已经大于指定的时间了,就直接过</span>\n        <span>if</span> <span>(</span><span>(</span>timed <span>&lt;=</span> <span>0</span><span>)</span> <span>||</span> afterTestCost <span>-</span> beforeTestCost <span>></span> timed<span>)</span> <span>{</span>\n            <span>Throwable</span> testException <span>=</span> testContext<span>.</span><span>getTestException</span><span>(</span><span>)</span><span>;</span>\n            <span>if</span> <span>(</span><span>Objects</span><span>.</span><span>nonNull</span><span>(</span>testException<span>)</span><span>)</span> <span>{</span>\n                <span>TestConsole</span><span>.</span><span>colorPrintln</span><span>(</span><span>AnsiColor</span><span>.</span>BRIGHT_RED<span>,</span> <span>\"测试用例执行失败了,快检查检查吧。🚒\"</span><span>)</span><span>;</span>\n            <span>}</span> <span>else</span> <span>{</span>\n                <span>TestConsole</span><span>.</span><span>colorPrintln</span><span>(</span><span>\"用例执行成功。💪\"</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            <span>// 如果不够,就要挂起指定时间。（减去1000毫秒,给Timed预留的时间）</span>\n            <span>long</span> nanos <span>=</span> <span>TimeUnit</span><span>.</span>MILLISECONDS<span>.</span><span>toNanos</span><span>(</span>timed <span>-</span> <span>(</span>afterTestCost <span>-</span> beforeTestCost<span>)</span> <span>-</span> <span>1000</span><span>)</span><span>;</span>\n            <span>// 主线程挂起,等待异步执行</span>\n            <span>System</span><span>.</span>err<span>.</span><span>printf</span><span>(</span><span>\"Timed任务挂起通知: 主线程挂起%d s,等待异步执行%n\"</span><span>,</span> <span>TimeUnit</span><span>.</span>NANOSECONDS<span>.</span><span>toSeconds</span><span>(</span>nanos<span>)</span><span>)</span><span>;</span>\n            <span>LockSupport</span><span>.</span><span>parkNanos</span><span>(</span>nanos<span>)</span><span>;</span>\n        <span>}</span>\n\n    <span>}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><h3 id=\"_2-3-引导类配置\"> 2.3 引导类配置</h3>\n<ul>\n<li>@TestExecutionListeners 注意声明添加模式是合并(默认是替换)</li>\n</ul>\n<div><div><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br></div><pre><code><span>@Slf4j</span>\n<span>@ActiveProfiles</span><span>(</span><span>{</span><span>\"local\"</span><span>}</span><span>)</span>\n<span>@ContextConfiguration</span><span>(</span>initializers <span>=</span> <span>{</span><span>BeanLazyApplicationContextInitializer</span><span>.</span><span>class</span><span>}</span><span>)</span>\n<span>// 使用Spring容器引导</span>\n<span>@RunWith</span><span>(</span><span>SpringRunner</span><span>.</span><span>class</span><span>)</span>\n<span>// 合并模式下,增加测试执行监听器</span>\n<span>@TestExecutionListeners</span><span>(</span>value <span>=</span> <span>PmsSentryTestExecutionListener</span><span>.</span><span>class</span><span>,</span> mergeMode <span>=</span> <span>TestExecutionListeners<span>.</span>MergeMode</span><span>.</span>MERGE_WITH_DEFAULTS<span>)</span>\n<span>// 默认就是回滚,不用加@Rollback,如果全局不想回滚就在这个吧@Rollback(false),如果某个单测不想回滚,就放到单侧类上</span>\n<span>@Transactional</span>\n<span>@SpringBootTest</span><span>(</span>classes <span>=</span> <span>{</span><span>CenterProviderApplication</span><span>.</span><span>class</span><span>}</span><span>)</span> <span>// 指定启动类</span>\n<span>public</span> <span>class</span> <span>BaseApplicationTest</span> <span>{</span>\n<span>}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div>",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-03-24T14:34:44.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "使用断言",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/test/%E4%BD%BF%E7%94%A8%E6%96%AD%E8%A8%80/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/test/%E4%BD%BF%E7%94%A8%E6%96%AD%E8%A8%80/",
      "content_html": "<div><p>断言</p>\n<p>单测方法尽可能去使用断言,明确方法的执行结果</p>\n</div>\n<h2 id=\"一、单测的目的\"> 一、单测的目的</h2>\n<p>我们单测的目的就是为了确定,被测试的方法或者是接口是否符合业务要求。\n其中一些方法是只要跑成功就算成功了,但是其实大部分方法还是要看其中的返回值是否符合预期。</p>\n<p>在平时的开发中发现许多同学只是喜欢把结果打印出来,人工去验证数据。这其实就跟JUnit的口号相违背了。\nJUnit的口号: <Highlight color=\"green\">keep the bar green to keep the code clean。</Highlight></p>\n<p><img src=\"/junit-success.gif\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_1-1-正确的单测一定是有断言的\"> 1.1 正确的单测一定是有断言的</h3>\n<p>断言明确执行结果,如果你要看数据也可以把结果打印出来。但是断言也要加上。\n<code>JUnit</code> 为我们提供了一些辅助的函数，就是用来帮助我们来判断被测试的方法是否如我们预期的效果一样正常执行。</p>\n<h2 id=\"二、断言api\"> 二、断言API</h2>\n<h3 id=\"_2-1-assertequals\"> 2.1 assertEquals</h3>\n<ul>\n<li>assertEquals(Object expected, Object actual)</li>\n<li>assertEquals(String message, Object expected, Object actual)</li>\n</ul>\n<p>String message： 可选参数，将在发生错误时报告这个消息\nObject expected： 期望值，一般为用户指定的内容\nObject actual： 被测试的代码实际返回的结果</p>\n<h3 id=\"_2-2-asserttrue-与-assertfalse\"> 2.2 assertTrue 与 assertFalse</h3>\n<ul>\n<li>assertTrue(boolean condition)</li>\n<li>assertTrue(String message, boolean condition)</li>\n</ul>\n<p>String message： 可选参数，将在发生错误时报告这个消息\nboolean condition：待验证的 Boolean 类型值</p>\n<p>assertTrue 该断言用来验证给定的布尔型值是否为真，如果结果为假，则验证失败；\n相反，assertFalse 用来验证给定的布尔型值是否为假，如果结果为真，则验证失败。</p>\n<h3 id=\"_2-3-assertnull-与-assertnotnull\"> 2.3 assertNull 与 assertNotNull</h3>\n<ul>\n<li>assertNull(Object object)</li>\n<li>assertNull(String message, Object object)</li>\n</ul>\n<p>String message： 可选参数，将会在发生错误时报告这个消息\nObject object： 待验证是否为 Null 的对象</p>\n<p>assertNull 该断言用来验证给定的对象是否为 Null ,如果给定对象为 非Null，则验证失败。\n相反，assertNotNull 用来验证给定的对象是否为 非Null，如果为 Null，则验证失败。</p>\n<h3 id=\"_2-4-assertsame-与-assertnotsame\"> 2.4 assertSame 与 assertNotSame</h3>\n<ul>\n<li>assertSame(Object expected, Object actual)</li>\n<li>assertSame(String message, Object expected, Object actual)</li>\n</ul>\n<p>String message： 可选参数，将会在发生错误时报告这个消息\nObject expected：期望值\nObject actual：被测试代码返回的实际值</p>\n<p>assertSame 该断言用来验证 expected 和 actual 的引用是否为同一个对象的引用，如果不是同一引用，则验证失败。\n相反，assertNotSame 用来验证 expected 和 actual 的引用是否为不同对象的引用，如果为同一对象引用，则验证失败。</p>\n<h3 id=\"_2-5-fail\"> 2.5 Fail</h3>\n<ul>\n<li>Fail()</li>\n<li>Fail(String message)</li>\n</ul>\n<p>String message是个可选参数，假如提供，将会在发生错误时报告这个消息。</p>\n<p>该断言会使测试立即失败，通常用在测试不能达到的分支上（如异常）。</p>\n<h2 id=\"三、断言匹配\"> 三、断言匹配</h2>\n<p>依赖包</p>\n<div><pre><code><span>import</span> <span>org<span>.</span>hamcrest<span>.</span></span><span>Matchers</span><span>;</span>\n<span>import</span> <span>org<span>.</span>hamcrest<span>.</span>core<span>.</span></span><span>AllOf</span><span>;</span>\n<span>import</span> <span>org<span>.</span>hamcrest<span>.</span>core<span>.</span></span><span>AnyOf</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"_3-1-matchers匹配器\"> 3.1 Matchers匹配器</h3>\n<div><pre><code>        <span>// 是否相等</span>\n        <span>Assert</span><span>.</span><span>assertThat</span><span>(</span><span>2</span><span>,</span> <span>Matchers</span><span>.</span><span>is</span><span>(</span><span>2</span><span>)</span><span>)</span><span>;</span>\n        <span>// 2 小于等于2</span>\n        <span>Assert</span><span>.</span><span>assertThat</span><span>(</span><span>2</span><span>,</span><span>Matchers</span><span>.</span><span>lessThanOrEqualTo</span><span>(</span><span>2</span><span>)</span><span>)</span><span>;</span>\n        <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span><span>String</span><span>></span></span> map <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        map<span>.</span><span>put</span><span>(</span><span>\"name\"</span><span>,</span><span>\"jay\"</span><span>)</span><span>;</span>\n        <span>// map 中是否包含key为name的元素</span>\n        <span>Assert</span><span>.</span><span>assertThat</span><span>(</span>map<span>,</span><span>Matchers</span><span>.</span><span>hasKey</span><span>(</span><span>\"name\"</span><span>)</span><span>)</span><span>;</span>\n        <span>// map 中是否包含value为jay的元素</span>\n        <span>Assert</span><span>.</span><span>assertThat</span><span>(</span>map<span>,</span><span>Matchers</span><span>.</span><span>hasValue</span><span>(</span><span>\"jay\"</span><span>)</span><span>)</span><span>;</span>\n        <span>// map 中是否包含name等于jay的元素</span>\n        <span>Assert</span><span>.</span><span>assertThat</span><span>(</span>map<span>,</span><span>Matchers</span><span>.</span><span>hasEntry</span><span>(</span><span>\"name\"</span><span>,</span><span>\"jay\"</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id=\"_3-2-allof\"> 3.2 AllOf</h3>\n<div><pre><code>   <span>// 2 小于4同时也小于3</span>\n   <span>Assert</span><span>.</span><span>assertThat</span><span>(</span><span>2</span><span>,</span> <span>AllOf</span><span>.</span><span>allOf</span><span>(</span><span>Matchers</span><span>.</span><span>lessThan</span><span>(</span><span>4</span><span>)</span><span>,</span> <span>Matchers</span><span>.</span><span>lessThan</span><span>(</span><span>3</span><span>)</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"_3-3-anyof\"> 3.3 AnyOf</h3>\n<div><pre><code>   <span>// 2 大于1小于3</span>\n   <span>Assert</span><span>.</span><span>assertThat</span><span>(</span><span>2</span><span>,</span> <span>AnyOf</span><span>.</span><span>anyOf</span><span>(</span><span>Matchers</span><span>.</span><span>greaterThan</span><span>(</span><span>1</span><span>)</span><span>,</span> <span>Matchers</span><span>.</span><span>lessThan</span><span>(</span><span>3</span><span>)</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div>",
      "image": "https://vuepress-theme-hope-demo.mrhope.site/junit-success.gif",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-03-24T14:34:44.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "JUnit API",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/test/JUnitAPI/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/test/JUnitAPI/",
      "content_html": "<div><p>提示</p>\n<p>只打印的单测是没有意义的,正确使用单测工具, 提高单测质量。</p>\n</div>\n<h2 id=\"一、常用注解\"> 一、常用注解</h2>\n<h3 id=\"_1-1-before-after\"> 1.1 @Before &amp; @After</h3>\n<p>单测类中每个单测方法执行都会触发这两个方法</p>\n<div><pre><code>    <span>@Before</span>\n    <span>public</span> <span>void</span> <span>before</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"before\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@After</span>\n    <span>public</span> <span>void</span> <span>after</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"after\"</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"_1-2-beforeclass-afterclass\"> 1.2 @BeforeClass &amp; @AfterClass</h3>\n<p>区别与上一个,不管单测类中有几个单测方法,都只会执行一次</p>\n<p>要用静态修饰</p>\n<div><pre><code>    <span>@BeforeClass</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>beforeClass</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"beforeClass\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@AfterClass</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>afterClass</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"afterClass\"</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><div><p>代码实例</p>\n<p>针对上面说的两个注解演示一下</p>\n<ul>\n<li>beforeClass</li>\n<li>before</li>\n<li>testOne</li>\n<li>after</li>\n<li>before</li>\n<li>testTwo</li>\n<li>after</li>\n<li>afterClass</li>\n</ul>\n</div>\n<hr>\n<div><pre><code><span>public</span> <span>class</span> <span>JUnitTest</span> <span>{</span>\n\n    <span>@BeforeClass</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>beforeClass</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"beforeClass\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Before</span>\n    <span>public</span> <span>void</span> <span>before</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"before\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>testOne</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"testOne\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>testTwo</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"testTwo\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@AfterClass</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>afterClass</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"afterClass\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@After</span>\n    <span>public</span> <span>void</span> <span>after</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"after\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><h3 id=\"_1-3-timed\"> 1.3 @Timed</h3>\n<p>被修饰的方法会加上一个时间限制,如果超过了指定的时间范围,就算单侧代码执行成功\n了也被认为是失败。(注意该方法依赖于SpringBoot容器)</p>\n<p>@Timed</p>\n<div><pre><code>    <span>@Test</span>\n    <span>@Timed</span><span>(</span>millis <span>=</span> <span>2000</span><span>)</span>\n    <span>public</span> <span>void</span> <span>testTimeout</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"testOne\"</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"_1-4-repeat\"> 1.4 @Repeat</h3>\n<p>指定当前单测方法被执行的次数,如果被该注解修饰\n将会被重复执行。(注意该方法依赖于SpringBoot容器)</p>\n<p>@Repeat</p>\n<div><pre><code>    <span>@Test</span>\n    <span>@Repeat</span><span>(</span><span>3</span><span>)</span>\n    <span>public</span> <span>void</span> <span>testOne</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"testOne\"</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"二、断言api\"> 二、断言API</h2>\n<p>断言的好处在于程序帮忙判断单测结果。不需要人工在接入验证数据。JUnit的口号就是</p>\n<p><code>keep the bar green to keep the code clean。</code></p>\n<p>一个不用观察输出就知道代码有没有问题的高效单元测试工具。</p>\n<div><pre><code>import org.hamcrest.Matchers;\nimport org.hamcrest.core.AllOf;\nimport org.hamcrest.core.AnyOf;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"_2-1-matchers\"> 2.1 Matchers</h3>\n<p>Matchers</p>\n<div><pre><code>        <span>// 是否相等</span>\n        <span>Assert</span><span>.</span><span>assertThat</span><span>(</span><span>2</span><span>,</span> <span>Matchers</span><span>.</span><span>is</span><span>(</span><span>2</span><span>)</span><span>)</span><span>;</span>\n        <span>// 2 小于等于2</span>\n        <span>Assert</span><span>.</span><span>assertThat</span><span>(</span><span>2</span><span>,</span><span>Matchers</span><span>.</span><span>lessThanOrEqualTo</span><span>(</span><span>2</span><span>)</span><span>)</span><span>;</span>\n        <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span><span>String</span><span>></span></span> map <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        map<span>.</span><span>put</span><span>(</span><span>\"name\"</span><span>,</span><span>\"jay\"</span><span>)</span><span>;</span>\n        <span>// map 中是否包含key为name的元素</span>\n        <span>Assert</span><span>.</span><span>assertThat</span><span>(</span>map<span>,</span><span>Matchers</span><span>.</span><span>hasKey</span><span>(</span><span>\"name\"</span><span>)</span><span>)</span><span>;</span>\n        <span>// map 中是否包含value为jay的元素</span>\n        <span>Assert</span><span>.</span><span>assertThat</span><span>(</span>map<span>,</span><span>Matchers</span><span>.</span><span>hasValue</span><span>(</span><span>\"jay\"</span><span>)</span><span>)</span><span>;</span>\n        <span>// map 中是否包含name等于jay的元素</span>\n        <span>Assert</span><span>.</span><span>assertThat</span><span>(</span>map<span>,</span><span>Matchers</span><span>.</span><span>hasEntry</span><span>(</span><span>\"name\"</span><span>,</span><span>\"jay\"</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id=\"_2-2-allof\"> 2.2 AllOf</h3>\n<p>全部满足</p>\n<div><pre><code>   <span>// 2 小于4同时也小于3</span>\n   <span>Assert</span><span>.</span><span>assertThat</span><span>(</span><span>2</span><span>,</span> <span>AllOf</span><span>.</span><span>allOf</span><span>(</span><span>Matchers</span><span>.</span><span>lessThan</span><span>(</span><span>4</span><span>)</span><span>,</span> <span>Matchers</span><span>.</span><span>lessThan</span><span>(</span><span>3</span><span>)</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"_2-3-anyof\"> 2.3 AnyOf</h3>\n<p>任意满足</p>\n<div><pre><code>   <span>// 2 大于1小于3</span>\n   <span>Assert</span><span>.</span><span>assertThat</span><span>(</span><span>2</span><span>,</span> <span>AnyOf</span><span>.</span><span>anyOf</span><span>(</span><span>Matchers</span><span>.</span><span>greaterThan</span><span>(</span><span>1</span><span>)</span><span>,</span> <span>Matchers</span><span>.</span><span>lessThan</span><span>(</span><span>3</span><span>)</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h2 id=\"三、结果验证\"> 三、结果验证</h2>\n<h3 id=\"_3-1-空值验证\"> 3.1 空值验证</h3>\n<div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>test</span><span>(</span><span>)</span> <span>{</span>\n        <span>Object</span> o <span>=</span> <span>new</span> <span>Object</span><span>(</span><span>)</span><span>;</span>\n        <span>// 非空验证</span>\n        <span>Assert</span><span>.</span><span>assertNotNull</span><span>(</span>o<span>)</span><span>;</span>\n        <span>// 空值验证</span>\n        <span>Assert</span><span>.</span><span>assertNull</span><span>(</span><span>null</span><span>)</span><span>;</span>\n    <span>}</span>    \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id=\"_3-2-逻辑验证\"> 3.2 逻辑验证</h3>\n<div><pre><code>    <span>import</span> <span>static</span> <span>org<span>.</span>hamcrest<span>.</span></span><span>MatcherAssert</span><span>.</span>*<span>;</span>\n    <span>import</span> <span>static</span> <span>org<span>.</span>hamcrest<span>.</span></span><span>CoreMatchers</span><span>.</span>*<span>;</span>\n    <span>public</span> calss <span>Test</span><span>{</span>\n        <span>@Test</span>\n        <span>public</span> <span>void</span> <span>test</span><span>(</span><span>)</span> <span>{</span>\n            <span>//测试变量是否大于指定值</span>\n            <span>ArrivalNoticeOrderDO</span> ao <span>=</span> <span>new</span> <span>ArrivalNoticeOrderDO</span><span>(</span><span>)</span><span>;</span>\n            ao<span>.</span><span>setId</span><span>(</span><span>12L</span><span>)</span><span>;</span>\n            <span>//测试所有条件必须成立</span>\n            <span>assertThat</span><span>(</span>ao<span>.</span><span>getId</span><span>(</span><span>)</span><span>,</span> <span>allOf</span><span>(</span><span>is</span><span>(</span><span>12L</span><span>)</span><span>)</span><span>)</span><span>;</span>\n            <span>//测试只要有一个条件成立</span>\n            <span>assertThat</span><span>(</span>ao<span>.</span><span>getId</span><span>(</span><span>)</span><span>,</span> <span>anyOf</span><span>(</span><span>is</span><span>(</span><span>50</span><span>)</span><span>,</span> <span>is</span><span>(</span><span>12L</span><span>)</span><span>)</span><span>)</span><span>;</span>\n            <span>//测试变量值等于指定值</span>\n            <span>assertThat</span><span>(</span>ao<span>.</span><span>getId</span><span>(</span><span>)</span><span>,</span> <span>is</span><span>(</span><span>12L</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id=\"_3-3-异常验证\"> 3.3 异常验证</h3>\n<div><pre><code>    <span>/**\n     * 预期异常\n     */</span>\n    <span>@Test</span><span>(</span>expected <span>=</span> <span>NullPointerException</span><span>.</span><span>class</span><span>)</span>\n    <span>public</span> <span>void</span> <span>testError</span><span>(</span><span>)</span><span>{</span>\n        <span>Object</span> o <span>=</span> <span>null</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>o<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id=\"四、快速创建\"> 四、快速创建</h2>\n<p>建议使用 <code>Idea</code> 自动创建, 不要手动创建。</p>\n",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-03-24T14:34:44.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "技术选型",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/test/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/test/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/",
      "content_html": "<h2 id=\"一、junit\"> 一、JUnit</h2>\n<p><a href=\"https://junit.org/junit5/\" target=\"_blank\" rel=\"noopener noreferrer\">JUnit</a>目标是为JVM上的开发人员端测试创建最新的基础。这包括关注Java 8及更高版本，以及启用许多不同的测试样式。</p>\n<p>强制使用 <code>Junit3</code> 以上版本, 目前最新的版本是 <code>Junit5</code>, 常用的是 <code>JUnit4</code>,建议使用<Highlight color=\"#25c2a0\">JUnit4</Highlight>\n或者使用<Highlight color=\"#25c2a0\">JUnit5</Highlight>。</p>\n<p>这里有一个小坑。如果SpringBoot2.1.x版本依赖的Junit4。SpringBoot应用要通过 @RunWith + @SpringBootTest。\n在SpringBoot后续的版本依赖JUnit5,直接使用@SpringBootTest即可。</p>\n<div><pre><code>\n<span><span><span>&lt;</span>dependency</span><span>></span></span>\n    <span><span><span>&lt;</span>groupId</span><span>></span></span>junit<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n    <span><span><span>&lt;</span>artifactId</span><span>></span></span>junit<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n    <span><span><span>&lt;</span>version</span><span>></span></span>4.12<span><span><span>&lt;/</span>version</span><span>></span></span>\n    <span><span><span>&lt;</span>scope</span><span>></span></span>test<span><span><span>&lt;/</span>scope</span><span>></span></span>\n<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id=\"二、mockito\"> 二、Mockito</h2>\n<p><a href=\"https://site.mockito.org/\" target=\"_blank\" rel=\"noopener noreferrer\">Mockito</a> 是一个非常不错的模拟框架。它使您可以使用干净简单的API编写漂亮的测试。Mockito不会给您带来麻烦，因为这些测试的可读性很强，并且会产生清晰的验证错误。</p>\n<p><img src=\"https://github.com/mockito/mockito.github.io/raw/master/img/logo%402x.png\" alt=\"\" loading=\"lazy\"></p>\n<p>mockito-core只包含mockito类，而mockito-all包含mockito类以及一些依赖项，其中一个是hamcrest。</p>\n<p>实际上mockito-all已停产according to the mockito website</p>\n<div><pre><code><span>&lt;!-- https://mvnrepository.com/artifact/org.mockito/mockito-core --></span>\n<span><span><span>&lt;</span>dependency</span><span>></span></span>\n    <span><span><span>&lt;</span>groupId</span><span>></span></span>org.mockito<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n    <span><span><span>&lt;</span>artifactId</span><span>></span></span>mockito-core<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n    <span><span><span>&lt;</span>version</span><span>></span></span>3.8.0<span><span><span>&lt;/</span>version</span><span>></span></span>\n    <span><span><span>&lt;</span>scope</span><span>></span></span>test<span><span><span>&lt;/</span>scope</span><span>></span></span>\n<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>代码实例</p>\n<div><pre><code>    \n    <span>// 根据这个原理,我们可以mock所有未实现的功能,比如三方的接口</span>\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>test</span><span>(</span><span>)</span><span>{</span>\n        <span>List</span> mockList <span>=</span> <span>Mockito</span><span>.</span><span>mock</span><span>(</span><span>List</span><span>.</span><span>class</span><span>)</span><span>;</span>\n        <span>Mockito</span><span>.</span><span>doReturn</span><span>(</span><span>12</span><span>)</span><span>.</span><span>when</span><span>(</span>mockList<span>)</span><span>.</span><span>get</span><span>(</span><span>0</span><span>)</span><span>;</span>\n        <span>// 12</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>mockList<span>.</span><span>get</span><span>(</span><span>0</span><span>)</span><span>)</span><span>;</span>\n        <span>Assert</span><span>.</span><span>assertSame</span><span>(</span><span>12</span><span>,</span>mockList<span>.</span><span>get</span><span>(</span><span>0</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id=\"三、jmockdata\"> 三、JMockData</h2>\n<p><code>JMockData</code> 是一款国人开发用来生成模拟数据的工具,对象太复杂,模拟数据复制太难? 一行代码搞定。</p>\n<div><pre><code>   <span><span><span>&lt;</span>dependency</span><span>></span></span>\n       <span><span><span>&lt;</span>groupId</span><span>></span></span>com.github.jsonzou<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n       <span><span><span>&lt;</span>artifactId</span><span>></span></span>jmockdata<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n       <span><span><span>&lt;</span>version</span><span>></span></span>4.3.0<span><span><span>&lt;/</span>version</span><span>></span></span>\n       <span><span><span>&lt;</span>scope</span><span>></span></span>test<span><span><span>&lt;/</span>scope</span><span>></span></span>\n   <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div>",
      "image": "https://github.com/mockito/mockito.github.io/raw/master/img/logo%402x.png",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-03-24T14:34:44.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "数据隔离",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/test/%E6%95%B0%E6%8D%AE%E9%9A%94%E7%A6%BB/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/test/%E6%95%B0%E6%8D%AE%E9%9A%94%E7%A6%BB/",
      "content_html": "<div><p>数据隔离</p>\n<p>数据隔离一直是一个测试的痛点，测试数据可能是 <code>mock</code> 的数据,所以单测过程中,难免会造成脏数据\n这种场景,有通用的解决方案。<code>JUnit</code> 已经帮我们做好了。这里我们只讲实操和用法。\n如果有兴趣的话可以研究下 <Highlight>TransactionalTestExecutionListener</Highlight></p>\n</div>\n<h2 id=\"解决方案\"> 解决方案</h2>\n<div><p>单测引导类配置说明</p>\n<ul>\n<li>@Transactional 如果加上这个注解,就代表全局的单测,事务执行完都会自动回滚</li>\n<li>@Rollback(false) 如果想某个方法事务不回滚,可以单独在方法上设置。<Highlight color=\"#25c2a0\">【方法级别&gt;全局】</Highlight></li>\n</ul>\n</div>\n<p>下面这两个方法</p>\n<ul>\n<li>第一个方法因为是使用测试全局事务配置,所以默认是回滚。</li>\n<li>第二个方法因为使用了方法事务配置,所以会忽略全局配置,然后提交事务。</li>\n</ul>\n<p>单测引导类配置</p>\n<div><pre><code><span>@Slf4j</span>\n<span>@ActiveProfiles</span><span>(</span><span>{</span><span>\"local\"</span><span>}</span><span>)</span>\n<span>// 使用Spring容器引导</span>\n<span>@RunWith</span><span>(</span><span>SpringRunner</span><span>.</span><span>class</span><span>)</span>\n<span>// 默认就是回滚,不用加@Rollback,如果全局不想回滚就在这个吧@Rollback(false),如果某个单测不想回滚,就放到单侧类上</span>\n<span>@Transactional</span>\n<span>@SpringBootTest</span><span>(</span>classes <span>=</span> <span>{</span><span>CenterProviderApplication</span><span>.</span><span>class</span><span>}</span><span>)</span> <span>// 指定启动类</span>\n<span>public</span> <span>class</span> <span>BaseApplicationTest</span> <span>{</span>\n\n    <span>// 全局事务,默认自动回滚</span>\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>testInsert</span><span>(</span><span>)</span> <span>{</span>\n        <span>String</span> json <span>=</span> <span>\"{\\n\"</span> <span>+</span>\n                <span>\"  \\\"id\\\": 1344215264312557570,\\n\"</span> <span>+</span>\n                <span>\"  \\\"arrivalOrderId\\\": 1344215264287391745,\\n\"</span> <span>+</span>\n                <span>\"  \\\"goodsDeployId\\\": 1344170561282879489,\\n\"</span> <span>+</span>\n                <span>\"  \\\"expectedReceiveNum\\\": 150,\\n\"</span> <span>+</span>\n                <span>\"}\"</span><span>;</span>\n        <span>OrderDetailDO</span> orderDetail <span>=</span> <span>TestConsole</span><span>.</span><span>toObject</span><span>(</span>json<span>,</span> <span>ArrivalNoticeOrderDetailDO</span><span>.</span><span>class</span><span>)</span><span>;</span>\n        orderDetail<span>.</span><span>setId</span><span>(</span><span>null</span><span>)</span><span>;</span>\n        orderDetail<span>.</span><span>setCreaterId</span><span>(</span><span>888888L</span><span>)</span><span>;</span>\n        <span>// true</span>\n        <span>Assert</span><span>.</span><span>assertTrue</span><span>(</span>DB<span>.</span><span>insert</span><span>(</span>orderDetail<span>)</span> <span>></span> <span>0</span><span>)</span><span>;</span>\n        <span>// notNull</span>\n        <span>Assert</span><span>.</span><span>assertNotNull</span><span>(</span>DB<span>.</span><span>selectById</span><span>(</span>orderDetail<span>.</span><span>getId</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n    \n    <span>// 方法事务>全局事务, 这里声明了不自动回滚</span>\n    <span>@Test</span>\n    <span>@Rollback</span><span>(</span>value <span>=</span> <span>false</span><span>)</span>\n    <span>public</span> <span>void</span> <span>testInsert</span><span>(</span><span>)</span> <span>{</span>\n        <span>String</span> json <span>=</span> <span>\"{\\n\"</span> <span>+</span>\n                <span>\"  \\\"id\\\": 1344215264312557570,\\n\"</span> <span>+</span>\n                <span>\"  \\\"arrivalOrderId\\\": 1344215264287391745,\\n\"</span> <span>+</span>\n                <span>\"  \\\"goodsDeployId\\\": 1344170561282879489,\\n\"</span> <span>+</span>\n                <span>\"  \\\"expectedReceiveNum\\\": 150,\\n\"</span> <span>+</span>\n                <span>\"}\"</span><span>;</span>\n        <span>OrderDetailDO</span> orderDetail <span>=</span> <span>TestConsole</span><span>.</span><span>toObject</span><span>(</span>json<span>,</span> <span>ArrivalNoticeOrderDetailDO</span><span>.</span><span>class</span><span>)</span><span>;</span>\n        orderDetail<span>.</span><span>setId</span><span>(</span><span>null</span><span>)</span><span>;</span>\n        orderDetail<span>.</span><span>setCreaterId</span><span>(</span><span>888888L</span><span>)</span><span>;</span>\n        <span>// true</span>\n        <span>Assert</span><span>.</span><span>assertTrue</span><span>(</span>DB<span>.</span><span>insert</span><span>(</span>orderDetail<span>)</span> <span>></span> <span>0</span><span>)</span><span>;</span>\n        <span>// notNull</span>\n        <span>Assert</span><span>.</span><span>assertNotNull</span><span>(</span>DB<span>.</span><span>selectById</span><span>(</span>orderDetail<span>.</span><span>getId</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div>",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-03-24T14:34:44.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "测试成本",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/test/%E6%B5%8B%E8%AF%95%E6%88%90%E6%9C%AC/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/test/%E6%B5%8B%E8%AF%95%E6%88%90%E6%9C%AC/",
      "content_html": "<div><p>相关信息</p>\n<p>测试成本到底有多大? 你认为你写的代码需不需要测试? 为了引出成本的话题, 我们先从实际工作中出发\n看看你能否经受住这些灵魂的考验吧。</p>\n</div>\n<h2 id=\"一、灵魂深处的拷问\"> 一、灵魂深处的拷问</h2>\n<ul>\n<li>你的代码质量如何度量？</li>\n<li>你是如何保证代码质量？</li>\n<li>你敢随时重构代码吗？</li>\n<li>你是如何确保重构的代码依然保持正确性？</li>\n<li>你是否有足够信心在没有测试的情况下随时发布你的代码？</li>\n</ul>\n<p>📢 如果答案都比较犹豫，那么就证明我们非常需要单元测试。(ps: 不会有人心里想的是我们需要测试同学吧 😏)</p>\n<p><mark>它能带给我们很多保障：</mark></p>\n<hr>\n<ul>\n<li>代码质量持续有保障</li>\n<li>重构正确性保障</li>\n<li>增强自信心</li>\n<li>自动化运行</li>\n</ul>\n<hr>\n<p>Web 应用中的单元测试更加重要，在 Web 产品快速迭代的时期，每个测试用例都给应用的稳定性提供了一层保障。 API 升级，测试用例可以很好地检查代码是否向下兼容。 对于各种可能的输入，一旦测试覆盖，都能明确它的输出。 代码改动后，可以通过测试结果判断代码的改动是否影响已确定的结果。</p>\n<p>所以，应用的 Controller、Service、Common、Manager 等代码，都必须有对应的单元测试保证代码质量。 当然，框架和插件的每个功能改动和重构都需要有相应的单元测试，并且要求尽量做到修改的代码能被 100% 覆盖到。</p>\n<p>特别是中大型项目，经过多年的代码迭代，业务逻辑复杂，代码改动很容易牵一发动全身，\n单元测试就能给应用的稳定性提供了一层保障。不用面对qa的灵魂拷问：</p>\n<Highlight color=\"#ff603f\">为什么老是你的bug最多！</Highlight>\n<h2 id=\"二、单测是手段不是目的\"> 二、单测是手段不是目的</h2>\n<blockquote>\n<p>单测行覆盖率高不代表应用的质量就一定高,但是单测行覆盖率低一定代表着这个应用出现质量问题的可能性就越大</p>\n</blockquote>\n<p>还是引用前面话,我们不要为了单测而写单测,如果是把单测当做是目的来做,那么就偏离了单测的意义,自然而然你就认为\n这个单测的成本是高的。... ... ... ... ... ... ... <Highlight color=\"#ff603f\">你品你细品</Highlight></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1618049846000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"三、软件的质量不是测试出来的-而是设计和维护出来的\"> 三、软件的质量不是测试出来的，而是设计和维护出来的</h2>\n<Highlight color=\"#ff603f\">你品你细品</Highlight>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1618206722000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>作为底层开发人员, 我们清晰每一行代码, 也就是最小执行单元。哪里容易出现错误，这次改造涉及到了那些代码。一线开发人员一定是最清楚的人,没有之一。</p>\n<p>从这个角度来了, 这就不是成本的问题了, 是职责范围内的事情。</p>\n<p>如果单元测试都不做,就好比我去街上买鸡蛋, 我问老板鸡蛋是好是坏, 老板说我不知道, 然后说坏了拿来可以换。\n你认为那个成本更大呢? 那个代价更大呢? 玩意坏鸡蛋把人吃坏了，这老板岂不是赔了夫人又折兵,还要受到法律的制裁?</p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1618049846000.png",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-03-24T14:34:44.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "测试范围",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/test/%E6%B5%8B%E8%AF%95%E8%8C%83%E5%9B%B4/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/test/%E6%B5%8B%E8%AF%95%E8%8C%83%E5%9B%B4/",
      "content_html": "<div><p>相关信息</p>\n<p>项目中拿些类需要进行单元测试呢?\n单测不是目的,是手段。目的都是保证质量</p>\n</div>\n<h2 id=\"一、从项目分层维度设计单测用例\"> 一、从项目分层维度设计单测用例</h2>\n<p>常见的项目分层有一下这些。</p>\n<ul>\n<li>Web层</li>\n<li>Service层</li>\n<li>domain层</li>\n<li>Integration层</li>\n<li>Common层 公用类必须要做</li>\n</ul>\n<h3 id=\"_1-1-web层-【忽略】\"> 1.1 Web层   【忽略】</h3>\n<p>一般web层已经上线不会发生改动,往往改动的是新增或者删除参数。可以忽略。</p>\n<h3 id=\"_1-2-service层-【建议】\"> 1.2 Service层   【建议】</h3>\n<p>Service层往往是程序的接口层,接受来自Web或者Message、Job的调用。Service的逻辑会覆盖大部分的下游分层。Service是我们的业务入口\n接口往往不会改变,改变最多的是它的实现。这一层我们要做好单元测试。</p>\n<p>但是这一层的单元测试可能会涉及数据的读写和外部的数据读写。可以使用Mockito数据进行替换外部数据的返回。\n内部数据的读写可以通过事务回滚的方式处理,主要验证自己代码中对这些数据的结算逻辑是否有问题。</p>\n<p>这一层入参的数据往往会很多,对系统也有相关的依赖,自行评估方案。\n这里提供两个曲线救国的方案:</p>\n<ol>\n<li>如果不好测试可以对程序的最小单元进行测试,曲线救国。</li>\n<li>对某个方法中,不满足测试场景的接口,进行Mockito,以跳过这段逻辑。</li>\n</ol>\n<h3 id=\"_1-3-domain层-【建议】\"> 1.3 Domain层   【建议】</h3>\n<p>这一层和Service的业务是比较相像的,只不过不会有Service层一样那么复杂,参考上文。</p>\n<h3 id=\"_1-4-integration层-【建议】\"> 1.4 Integration层 【建议】</h3>\n<p>防腐层,主要逻辑就是对外部接口的调用,主要测试不要出现NPE。参数的输入值做好非空非null判断,对返回结果做好非空和非null。</p>\n<div><pre><code><span>public</span> <span>List</span><span><span>&lt;</span><span>GoodsBaseMsgDTO</span><span>></span></span> <span>querySkuList</span><span>(</span><span>Long</span> skuId<span>,</span> <span>Long</span> brandId<span>,</span> <span>String</span> goodsName<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span><span>Objects</span><span>.</span><span>isNull</span><span>(</span>skuId<span>)</span> <span>&amp;&amp;</span> <span>Objects</span><span>.</span><span>isNull</span><span>(</span>brandId<span>)</span> <span>&amp;&amp;</span> <span>StringUtils</span><span>.</span><span>isBlank</span><span>(</span>goodsName<span>)</span><span>)</span> <span>{</span>\n            <span>// 根据业务来判断是报错还是为空</span>\n            <span>return</span> <span>EnhanceStream</span><span>.</span><span>emptyList</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>GoodsMsgQueryParam</span> queryParam <span>=</span> <span>new</span> <span>GoodsMsgQueryParam</span><span>(</span><span>)</span><span>;</span>\n        queryParam<span>.</span><span>setBrandId</span><span>(</span>brandId<span>)</span><span>;</span>\n        queryParam<span>.</span><span>setSkuId</span><span>(</span>skuId<span>)</span><span>;</span>\n        queryParam<span>.</span><span>setGoodsName</span><span>(</span>goodsName<span>)</span><span>;</span>\n        <span>JsonResult</span><span><span>&lt;</span><span>PageData</span><span>&lt;</span><span>GoodsBaseMsgDTO</span><span>></span><span>></span></span> pageDataJsonResult <span>=</span> goodsStockApi<span>.</span><span>pageQuerySkuList</span><span>(</span>queryParam<span>)</span><span>;</span>\n        <span>PageData</span><span><span>&lt;</span><span>GoodsBaseMsgDTO</span><span>></span></span> pageData <span>=</span> <span>JsonResultUtils</span><span>.</span><span>orElseGetSafeData</span><span>(</span>pageDataJsonResult<span>,</span> <span>new</span> <span>PageData</span><span><span>&lt;</span><span>GoodsBaseMsgDTO</span><span>></span></span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span><span>Objects</span><span>.</span><span>isNull</span><span>(</span>pageData<span>)</span><span>)</span> <span>{</span>\n            <span>return</span> <span>EnhanceStream</span><span>.</span><span>emptyList</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> pageData<span>.</span><span>getRecords</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n    \n<span>public</span> <span>static</span> <span><span>&lt;</span><span>T</span><span>></span></span> <span>T</span> <span>orElseGetSafeData</span><span>(</span><span>JsonResult</span><span><span>&lt;</span><span>T</span><span>></span></span> result<span>,</span> <span>T</span> defaultValue<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span><span>null</span> <span>!=</span> result <span>&amp;&amp;</span> result<span>.</span><span>isSuccess</span><span>(</span><span>)</span> <span>&amp;&amp;</span> <span>Objects</span><span>.</span><span>nonNull</span><span>(</span>result<span>.</span><span>getData</span><span>(</span><span>)</span><span>)</span><span>)</span> <span>{</span>\n            <span>return</span> result<span>.</span><span>getData</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            <span>if</span> <span>(</span><span>Objects</span><span>.</span><span>nonNull</span><span>(</span>result<span>)</span><span>)</span><span>{</span>\n                log<span>.</span><span>error</span><span>(</span>result<span>.</span><span>getMsg</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>}</span>\n            <span>return</span> <span>Objects</span><span>.</span><span>nonNull</span><span>(</span>defaultValue<span>)</span> <span>?</span> defaultValue <span>:</span> <span>null</span><span>;</span>\n        <span>}</span>\n<span>}</span>    \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>外部提供的 <code>Feign</code> 接口, 在没有提供实现之前可以先使用 <code>Mockito</code>进行Mock\n帮助完成接口的测试。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>TradeShopIntegrationImplTest</span> <span>extends</span> <span>BaseApplicationTest</span> <span>{</span>\n\n    <span>@Autowired</span>\n    <span>private</span> <span>TradeShopIntegration</span> shopBrandIntegration<span>;</span>\n\n    <span>@MockBean</span>\n    <span>private</span> <span>BrandServiceApi</span> brandService<span>;</span>\n    \n    <span>@MockBean</span>\n    <span>private</span> <span>GoodsStockApi</span> goodsStockApi<span>;</span>\n    \n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>testGetAllBrands</span><span>(</span><span>)</span> <span>{</span>\n        <span>Mockito</span><span>.</span><span>doReturn</span><span>(</span><span>JsonResult</span><span>.</span><span>failure</span><span>(</span><span>\"fail\"</span><span>)</span><span>)</span><span>.</span><span>when</span><span>(</span>goodsStockApi<span>)</span><span>.</span><span>getSkuList</span><span>(</span><span>Mockito</span><span>.</span><span>any</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// 底层调用的是goodsStockApi.getSkuList()</span>\n        <span>List</span><span><span>&lt;</span><span>GoodsBaseMsgDTO</span><span>></span></span> goodsBaseMsgDTOS <span>=</span> shopBrandIntegration<span>.</span><span>queryAllSku</span><span>(</span><span>)</span><span>;</span>\n        <span>// 因为前面声明了返回fail。所以这里没有数据返回。</span>\n        <span>JsonConsoleUtils</span><span>.</span><span>println</span><span>(</span>goodsBaseMsgDTOS<span>)</span><span>;</span>\n        <span>// 这里跟上面的区别就是,如果没有声明返回值,就走原来的方法。</span>\n        <span>List</span><span><span>&lt;</span><span>OutBrandDTO</span><span>></span></span> allBrands <span>=</span> shopBrandIntegration<span>.</span><span>getAllBrands</span><span>(</span><span>)</span><span>;</span>\n        <span>JsonConsoleUtils</span><span>.</span><span>println</span><span>(</span>allBrands<span>)</span><span>;</span>\n    <span>}</span>\n    \n<span>}</span>    \n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h3 id=\"_1-5-common层-【必须-】\"> 1.5 Common层   【必须  】</h3>\n<p>这一层基本出现的都是工具类,主要是功能性代码,自己提供的工具类,一定要做好单元测试。主要是考虑\n异常情况和极限的情况。工具类因为变动的不会太频繁所以维护成本是也比较低的。</p>\n<p><a href=\"https://ddd.springlearn.cn/docs/test/spring-boot-testing\" target=\"_blank\" rel=\"noopener noreferrer\">Mockito学习跳转</a></p>\n<h2 id=\"二、针对核心计算逻辑设计单测用例\"> 二、针对核心计算逻辑设计单测用例</h2>\n<p>比较核心的计算逻辑进行测试。比如根据外部数据进行组装生成新的数据模型的方法。</p>\n<h2 id=\"三、忽略测试\"> 三、忽略测试</h2>\n<p>在实际开发中可能有些测试只是为了验证某些数据,每次执行要提前准备数据之类的。这种特殊的单测,只能人工指定运行的\n我们可以忽略它,使用<code>@Ignore</code> 忽略。这样在Maven运行单测时候,会只运行你没有进行忽略的单测。</p>\n",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-03-24T14:34:44.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "极限测试",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/test/%E6%9E%81%E9%99%90%E6%B5%8B%E8%AF%95/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/test/%E6%9E%81%E9%99%90%E6%B5%8B%E8%AF%95/",
      "content_html": "<div><p>极限测试</p>\n<ul>\n<li>最大值</li>\n<li>最小值</li>\n<li>null值</li>\n<li>空值</li>\n<li>异常</li>\n</ul>\n</div>\n<h3 id=\"这段代码会执行通过吗\"> 这段代码会执行通过吗?</h3>\n<div><pre><code>  <span>int</span> a <span>=</span> <span>24</span> <span>*</span> <span>24</span> <span>*</span> <span>60</span> <span>*</span> <span>60</span> <span>*</span> <span>1000</span><span>;</span>\n  <span>int</span> b <span>=</span> <span>25</span> <span>*</span> <span>24</span> <span>*</span> <span>60</span> <span>*</span> <span>60</span> <span>*</span> <span>1000</span><span>;</span>\n  <span>Assert</span><span>.</span><span>assertTrue</span><span>(</span>b <span>></span> a<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>关于测试用例的要思考下是否要使用极限值,验证。</p>\n",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-03-24T14:34:44.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "①谁在调用JUnit",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/test/%E8%B0%81%E5%9C%A8%E8%B0%83%E7%94%A8JUnit/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/test/%E8%B0%81%E5%9C%A8%E8%B0%83%E7%94%A8JUnit/",
      "content_html": "<p>当点击了执行单例,发生了什么事情? <Version>基于SpringBoot 2.1.x版本分析</Version></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1617790044000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>可以看到idea会将单侧的类和方法传递给JUnit。最终由</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1617790263000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>可以看到最终是由 <code>AllDefaultPossibilitiesBuilder</code> 来进行了承接 。所以到这里我们就找到了入口。后续所有的能力,都要从JUnit中去寻找了。</p>\n<div><pre><code>    <span>@Override</span>\n    <span>public</span> <span>Runner</span> <span>getRunner</span><span>(</span><span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>runner <span>==</span> <span>null</span><span>)</span> <span>{</span>\n            <span>synchronized</span> <span>(</span>runnerLock<span>)</span> <span>{</span>\n                <span>if</span> <span>(</span>runner <span>==</span> <span>null</span><span>)</span> <span>{</span>\n                    runner <span>=</span> <span>new</span> <span>AllDefaultPossibilitiesBuilder</span><span>(</span>canUseSuiteMethod<span>)</span><span>.</span><span>safeRunnerForClass</span><span>(</span>fTestClass<span>)</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> runner<span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div>",
      "image": "https://img.springlearn.cn/blog/learn_1617790044000.png",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-03-24T14:34:44.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "影响范围",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/test/%E5%BD%B1%E5%93%8D%E8%8C%83%E5%9B%B4/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/test/%E5%BD%B1%E5%93%8D%E8%8C%83%E5%9B%B4/",
      "content_html": "<div><p>注意影响</p>\n<p>所有的单测一定针对不是生产环境,一般线上发布我们会声明不运行单测。\n如何考虑环境因素呢?</p>\n<p>两个解决办法:</p>\n<ul>\n<li>应用维度环境分离 spring.profiles.active=test</li>\n<li>测试基类指定环境 @ActiveProfiles(&quot;test&quot;)</li>\n</ul>\n</div>\n<h2 id=\"一、影响范围考虑哪些因素\"> 一、影响范围考虑哪些因素?</h2>\n<h3 id=\"_1-1-是否影响测试环境\"> 1.1 是否影响测试环境?</h3>\n<p>可以设置单测事务不提交,保证对数据无影响。</p>\n<h3 id=\"_1-2-是否对业务无影响\"> 1.2 是否对业务无影响?</h3>\n<p>检查是否做了环境隔离。</p>\n<h3 id=\"_1-3-是否可重复跑\"> 1.3 是否可重复跑?</h3>\n<p>如果前两点都已经解决,那么就可以重复跑。\n重复跑可以模拟验证幂等或者重复提交的问题。</p>\n<h2 id=\"三、什么时候写单测\"> 三、什么时候写单测</h2>\n<p>后端开发进度: 开发50% + 单元测试30% + 联调20%</p>\n<ol>\n<li>自己代码开发完成后,就应该进行单测。</li>\n<li>自己代码开发完了,其他人没有开发完。可以进行Mockito单测,先确保自己的代码没问题。</li>\n<li>对自己负责的功能模块进行单测维护。</li>\n</ol>\n",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-03-24T14:34:44.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "案例分享",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/test/%E6%A1%88%E4%BE%8B%E5%88%86%E4%BA%AB/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/test/%E6%A1%88%E4%BE%8B%E5%88%86%E4%BA%AB/",
      "content_html": "<h2 id=\"前言\"> 前言</h2>\n<div><p>单测覆盖率为应用质量指标化提供解决方案</p>\n<p><strong>一口吃不了一个胖子, 由于每个人的认识不一样,要想达到理想的状态,显然是不可能的。此章节主要从实践出发,一步一步带领我们完成一个有效的可复用的单元测试的编写。</strong></p>\n</div>\n<h2 id=\"一、目标\"> 一、目标</h2>\n<h3 id=\"_1-1-质量保障\"> 1.1 质量保障</h3>\n<p><strong>单测是保证项目质量的手段,而不是目的。</strong></p>\n<p>通过 <code>mvn test</code> 在每次编译时候，对代码进行测试。以到达可持续集成的目的。这里的关键是在每次服务发布的时候,首先要运行测试用例。\n只有这样,我们的单测用例才有价值,才能提前发现问题。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1621248108000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_1-2-打扫屋子\"> 1.2 打扫屋子</h3>\n<p>要解决前面的这个问题,就要求我们编写正确的测试用例。因为大多数项目目前的编译脚本都是,跳过单元测试的.\n<code>mvn -Dmaven.test.skip=true</code>, 之所以这样是因为大多数的单测都是为 <code>debug</code> 写的,一旦在编译的时候执行单测用例,\n就会编译不通过。所以要想达到可持续集成的目的, 就要先把阻塞应用的单元测试用例给移除。</p>\n<p>我们可以通过 <code>@Ignore</code> 来。 当然这不是说不允许你写debug的单测,而是要我们<Highlight color=\"#ffffff\" bg=\"#117eed\"> 遵守一个约定</Highlight>, 对那种debug的单测, 必须人工执行的单测\n我们要通过 <code>@Ignore</code> 来标记, 避免我们执行单测时候失败。</p>\n<h3 id=\"_1-3-发挥价值\"> 1.3 发挥价值</h3>\n<p>如果做到了 1.1 和 1.2 那么单测的价值有会真正体现出来了。但是这一切的一切的前提是我们要编写出正确的符合规范的单测用例。</p>\n<p><img src=\"https://i0.hdslb.com/bfs/article/7698c4b6720896ccd93fffc15257b79122fe06df.gif\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"二、真实案例分享\"> 二、真实案例分享</h2>\n<p>首先这里我们使用到的技术,其实再前面的技术框架中都有列举了,所以这里就不详细说明了。这里就分享几个测试用例。</p>\n<h3 id=\"_2-1-查询接口测试用例-难度-⭐️\"> 2.1 查询接口测试用例 难度:⭐️</h3>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1620982729000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>对于上图这种仅仅涉及到读的接口,是比较简单的。我们的验证点其实只有两个。</p>\n<ol>\n<li>web接口是否可以调用</li>\n<li>接口查询条件是否有效</li>\n</ol>\n<h4 id=\"_2-1-1-启动web服务器\"> 2.1.1 启动web服务器</h4>\n<p>随机web端口,执行单测的时候启动一个web容器,用来模拟Web接口测试。</p>\n<div><pre><code><span>@RunWith</span><span>(</span><span>SpringRunner</span><span>.</span><span>class</span><span>)</span>\n<span>@SpringBootTest</span><span>(</span>classes <span>=</span> <span>CenterProviderApplication</span><span>.</span><span>class</span><span>,</span>\n                webEnvironment <span>=</span> <span>SpringBootTest<span>.</span>WebEnvironment</span><span>.</span>RANDOM_PORT<span>)</span>\n<span>// 指定启动类</span>\n<span>public</span> <span>class</span> <span>BaseApplicationTest</span> <span>{</span>\n\n    <span>protected</span> <span>URL</span> base<span>;</span>\n\n    <span>@LocalServerPort</span>\n    <span>private</span> <span>int</span> port<span>;</span>\n\n    <span>@Before</span>\n    <span>public</span> <span>void</span> <span>setUp</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>this</span><span>.</span>base <span>=</span> <span>new</span> <span>URL</span><span>(</span><span>\"http://localhost:\"</span> <span>+</span> port <span>+</span> <span>\"/pms/\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h4 id=\"_2-1-2-编写接口\"> 2.1.2 编写接口</h4>\n<p>这里就验证了Web的请求,同时可以进度查询条件的校验。当然这里也可以加上返回值类型的校验</p>\n<div><pre><code><span>public</span> <span>class</span> <span>CommonControllerTest</span> <span>extends</span> <span>BaseApplicationTest</span> <span>{</span>\n\n    <span>@Resource</span>\n    <span>private</span> <span>CommonController</span> commonController<span>;</span>\n\n    <span>/**\n     * 使用测试工具进行web端测试\n     *\n     */</span>\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>goodsList</span><span>(</span><span>)</span> <span>{</span>\n        <span>GoodsListDTO</span> dto <span>=</span> <span>new</span> <span>GoodsListDTO</span><span>(</span><span>)</span><span>;</span>\n        dto<span>.</span><span>setSize</span><span>(</span><span>5L</span><span>)</span><span>;</span>\n        dto<span>.</span><span>setCurrent</span><span>(</span><span>1L</span><span>)</span><span>;</span>\n        <span>// 使用该方法允许数据Mock</span>\n        <span>JsonResult</span><span><span>&lt;</span><span>DiyPage</span><span>&lt;</span><span>PmsGoodsVO</span><span>></span><span>></span></span> result <span>=</span> <span>TestWebUtils</span><span>.</span><span>web</span><span>(</span><span>this</span><span>.</span>base<span>)</span><span>.</span><span>mockWhen</span><span>(</span>commonController<span>)</span><span>.</span><span>goodsList</span><span>(</span>dto<span>)</span><span>;</span>\n        <span>// 非空判断</span>\n        <span>Assert</span><span>.</span><span>assertNotNull</span><span>(</span>result<span>)</span><span>;</span>\n        <span>// 接口响应值判断</span>\n        <span>Assert</span><span>.</span><span>assertTrue</span><span>(</span>result<span>.</span><span>getMsg</span><span>(</span><span>)</span><span>,</span> result<span>.</span><span>isSuccess</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// 接口数据输出</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>TestConsole</span><span>.</span><span>color</span><span>(</span><span>\"执行结果:\"</span><span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>TestConsole</span><span>.</span><span>colors</span><span>(</span>result<span>,</span> <span>AnsiColor</span><span>.</span>BRIGHT_BLUE<span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p>看到这里我们能亲身感受到,对于纯粹读的接口测试用例是比较容易编写的。一个项目只用维护一次就好了,开发同学也不会每次都去维护这个用例。\n虽然这个用例简单,但是我们能在每次发布完成后自动化的去执行校验。能帮助我们提前发现问题。</p>\n<h3 id=\"_2-2-读写测试用例-难度-⭐️⭐️\"> 2.2 读写测试用例 难度:⭐️⭐️</h3>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1620988529000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>像这种读写操作,且涉及到对外部数据调用的接口。我们要使用Mockito技术,对外部对象进行代理,并制定其中的行为。\n如下图这个测试用例,看下如何编写测试用例。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1620989004000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>首先分析下涉及到的接口。</p>\n<ul>\n<li>saveArrivalOrder 这个接口里面是包含了内部的业务逻辑和外部的数据调用,包含了下面两个外部的接口依赖。</li>\n</ul>\n<ol>\n<li>noticeTransportNodeNote 在保存到货通知单的时候,通知库存增加商品的在途库存数量的</li>\n<li>syncPurchaseOrder      在保存到货通知单的时候,是通知仓储做到货准备的</li>\n</ol>\n<p>这个业务中我们只需要验证我们内部的逻辑即可,涉及到外部的调用只需要验证代码即可,并不真的需要仓库和库存系统做\n真实的业务处理。所以我们就要针对这两个方法做数据mock我们使用到的技术就是Mockito做对象行为的mock。如下案例。</p>\n<p>主要看注释,我们在调用接口的时候,先通过给外部接口最Mockito代理,然后指定动作的出入参数。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>NoticeOrderControllerTest</span> <span>extends</span> <span>BaseApplicationTest</span> <span>{</span>\n\n    <span>@Autowired</span>\n    <span>NoticeOrderController</span> controller<span>;</span>\n\n    <span>/**\n     * 接口穿插在po单创建的单侧里面\n     */</span>\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>saveArrivalOrder</span><span>(</span><span>)</span> <span>{</span>\n        <span>// 1. 构建保存单据的参数(从浏览器中复制数据)</span>\n        <span>String</span> saveOrderJson <span>=</span>  <span>\"{}\"</span>\n        <span>NoticeOrderDTO</span> noticeOrder <span>=</span> <span>TestConsole</span><span>.</span><span>toObject</span><span>(</span>saveOrderJson<span>,</span> <span>ArrivalNoticeOrderDTO</span><span>.</span><span>class</span><span>)</span><span>;</span>\n\n        <span>// 2. mock库存中心返回 - inventoryTransportClient.noticeTransportNodeNote</span>\n        <span>JsonResult</span><span><span>&lt;</span><span>Boolean</span><span>></span></span> noticeResult <span>=</span> <span>JsonResult</span><span>.</span><span>success</span><span>(</span><span>true</span><span>)</span><span>;</span>\n        <span>Mockito</span><span>.</span><span>doReturn</span><span>(</span>noticeResult<span>)</span><span>.</span><span>when</span><span>(</span>inventoryTransportClient<span>)</span><span>.</span><span>noticeTransportNodeNote</span><span>(</span><span>Mockito</span><span>.</span><span>any</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// 3. mock同步中控台 - bookingOrderPmsFeignClient.syncPurchaseOrder(bookingOrderDetailDTO)</span>\n        <span>JsonResult</span><span><span>&lt;</span><span>Object</span><span>></span></span> syncResult <span>=</span> <span>JsonResult</span><span>.</span><span>success</span><span>(</span><span>)</span><span>;</span>\n        <span>Mockito</span><span>.</span><span>doReturn</span><span>(</span>syncResult<span>)</span><span>.</span><span>when</span><span>(</span>bookingOrderPmsFeignClient<span>)</span><span>.</span><span>syncPurchaseOrder</span><span>(</span><span>Mockito</span><span>.</span><span>any</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\n        <span>// 4. 执行保存+提交(走网络请求,事务不会自动回滚,如果想自动回滚直接调用,controller.saveArrivalOrder(arrivalNoticeOrder))</span>\n        arrivalNoticeOrder<span>.</span><span>setStatus</span><span>(</span><span>1</span><span>)</span><span>;</span>\n        <span>JsonResult</span><span><span>&lt;</span><span>Long</span><span>></span></span> longJsonResult <span>=</span> <span>TestWebUtils</span><span>.</span><span>web</span><span>(</span><span>this</span><span>.</span>base<span>)</span><span>.</span><span>when</span><span>(</span><span>ArrivalNoticeOrderController</span><span>.</span><span>class</span><span>)</span>\n                <span>.</span><span>saveArrivalOrder</span><span>(</span>arrivalNoticeOrder<span>)</span><span>;</span>\n        <span>PmsAssert</span><span>.</span><span>assertSuccess</span><span>(</span>longJsonResult<span>)</span><span>;</span>\n\n        <span>// 5. 验证关闭(这里因为我要验证关闭接口,所以不要自动会馆)</span>\n        <span>Mockito</span><span>.</span><span>doReturn</span><span>(</span>syncResult<span>)</span><span>.</span><span>when</span><span>(</span>bookingOrderPmsFeignClient<span>)</span><span>.</span><span>cancelPurchaseOrder</span><span>(</span><span>Mockito</span><span>.</span><span>any</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>Mockito</span><span>.</span><span>doReturn</span><span>(</span>noticeResult<span>)</span><span>.</span><span>when</span><span>(</span>inventoryTransportClient<span>)</span><span>.</span><span>cancelTransportNode</span><span>(</span><span>Mockito</span><span>.</span><span>any</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\n        <span>JsonResult</span><span><span>&lt;</span><span>Void</span><span>></span></span> jsonResult <span>=</span> <span>TestWebUtils</span><span>.</span><span>web</span><span>(</span><span>this</span><span>.</span>base<span>)</span><span>.</span><span>when</span><span>(</span><span>ArrivalNoticeOrderController</span><span>.</span><span>class</span><span>)</span>\n                <span>.</span><span>closeOrder</span><span>(</span><span>(</span>longJsonResult<span>.</span><span>getData</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>\n        <span>PmsAssert</span><span>.</span><span>assertSuccess</span><span>(</span>jsonResult<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><p>这个案例,我们可以学会如何使用Mockito做外部接口的代理,整体难度也不是很大。</p>\n<h3 id=\"_2-3-读写接口-复杂接口-难度-⭐️⭐️⭐️⭐️\"> 2.3 读写接口(复杂接口) 难度:⭐️⭐️⭐️⭐️</h3>\n<p>针对项目中核心流程, 可能并不仅仅是一个接口，而是有依赖关系的多个接口。</p>\n<p>针对系统核心链路流程，我们是有必要维护些自动化流程的测试用例。然后对每个接口中的出入参数进行校验。**当做到这一步的时候\n其实我们在发布时候就会更加有底气。敢于去重构代码了。**因为在项目迭代发布的过程中，我们会先跑一边单测。只要单测流程能通过，说明这个核心链路的流程问题就不会太大。</p>\n<p>当然这里不是说一定没有问题, 而是有问题的几率变小了。如果说出现问题了,我们的自动化流程没有提前发现，那么说明这些场景,我们的单测流程没有覆盖到, 那么这个时候我们再补充我们的自动化流程。</p>\n<p><strong>注意这里的自动化流程，跟测试同学的自动化流程是有区别的。开发的自动化流程的测试目标是自身项目的代码，所以我们关于外部接口都是通过Mock来模拟的。而测试同学的\n自动化流程，都是走真实的系统调用。</strong></p>\n<h4 id=\"_2-3-1-业务说明\"> 2.3.1 业务说明</h4>\n<ol>\n<li>\n<p>创建一个包含一个商品的，草稿状态的临时采购单【验证保存接口】</p>\n</li>\n<li>\n<p>模拟用户对采购单的商品进行二次修改【验证修改逻辑接口】</p>\n</li>\n<li>\n<p>模拟对已经审核的采购单,添加不同类型货通知单【验证不同单据到货通知单的校验接口】</p>\n</li>\n<li>\n<p>对已经创建的到货通知单进行人工关闭【验证关闭】</p>\n</li>\n<li>\n<p>关闭所有到货通知单【验证关闭】</p>\n</li>\n<li>\n<p>关闭采购单【验证采购关闭】</p>\n</li>\n</ol>\n<p>做到业务流程闭环</p>\n<div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>tempPurchaseOrderSave</span><span>(</span><span>)</span> <span>{</span>\n        <span>String</span> saveOrderJson <span>=</span> <span>\"{\\\"poOrderItemList\\\":[{\\\"id\\\":null,\\\"goodsId\\\":\\\"1\\\",\\\"skuId\\\":\\\"1001062\\\",\\\"goodsName\\\":\\\"ABM品牌招商手册包11112\\\",\\\"englishName\\\":\\\"1\\\",\\\"goodsCode\\\":\\\"9314807022860\\\",\\\"brandCode\\\":\\\"brand230\\\",\\\"brandName\\\":\\\"34 西班牙\\\",\\\"specificationModel\\\":\\\"12ml/瓶\\\",\\\"wmsItemList\\\":[{\\\"purchaseNum\\\":null,\\\"warehouseName\\\":\\\"DHL\\\",\\\"warehouseCode\\\":0},{\\\"purchaseNum\\\":null,\\\"warehouseName\\\":\\\"PCA\\\",\\\"warehouseCode\\\":1},{\\\"purchaseNum\\\":null,\\\"warehouseName\\\":\\\"EWE\\\",\\\"warehouseCode\\\":2},{\\\"purchaseNum\\\":null,\\\"warehouseName\\\":\\\"新西兰仓\\\",\\\"warehouseCode\\\":3}],\\\"purchaseNum\\\":30,\\\"goodProductNum\\\":30,\\\"purchasePrice\\\":\\\"10\\\",\\\"expectDeliveryDate\\\":\\\"2021-05-12\\\",\\\"actualPurchaseNum\\\":null}],\\\"tradeCompanyIdList\\\":[\\\"13\\\"],\\\"supplierId\\\":\\\"347\\\",\\\"businessLineId\\\":\\\"1\\\",\\\"sameChainId\\\":49,\\\"title\\\":\\\"mevan test自动跑验证流程\\\",\\\"companyId\\\":null,\\\"channelCode\\\":\\\"ABM\\\",\\\"brandCode\\\":\\\"brand230\\\",\\\"purchaseBrandId\\\":\\\"1374262965415165953\\\",\\\"currencyCode\\\":\\\"AUD\\\",\\\"tradeType\\\":20,\\\"deliveryWarehouseId\\\":null,\\\"transferWarehouseId\\\":\\\"542\\\",\\\"salesWarehouseId\\\":\\\"9\\\",\\\"giveawayOrderSign\\\":1,\\\"ids\\\":\\\"\\\"}\"</span><span>;</span>\n        <span>PurchaseOrderDTO</span> purchaseOrderDTO <span>=</span> <span>TestConsole</span><span>.</span><span>toObject</span><span>(</span>saveOrderJson<span>,</span> <span>PurchaseOrderDTO</span><span>.</span><span>class</span><span>)</span><span>;</span>\n        purchaseOrderDTO<span>.</span><span>setTitle</span><span>(</span><span>\"mvn test(临时订单自动化流程验证)\"</span><span>)</span><span>;</span>\n        <span>List</span><span><span>&lt;</span><span>PurchaseOrderDetailDTO</span><span>></span></span> poOrderItemList <span>=</span> purchaseOrderDTO<span>.</span><span>getPoOrderItemList</span><span>(</span><span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>PurchaseOrderDetailDTO</span> purchaseOrderDetailDTO <span>:</span> poOrderItemList<span>)</span> <span>{</span>\n            <span>// 赠品刚开始设置成1</span>\n            purchaseOrderDetailDTO<span>.</span><span>setGiveawayNum</span><span>(</span><span>1</span><span>)</span><span>;</span>\n            purchaseOrderDetailDTO<span>.</span><span>setExpectDeliveryDate</span><span>(</span><span>JodaTimeUtils</span><span>.</span><span>addDay</span><span>(</span><span>new</span> <span>Date</span><span>(</span><span>)</span><span>,</span> <span>1</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>// 1. 执行保存</span>\n        <span>Long</span> purchaseOrderId <span>=</span> <span>createPurchaseOrder</span><span>(</span>purchaseOrderDTO<span>)</span><span>;</span>\n\n        <span>// 2. 然后修改下商品明细</span>\n        <span>List</span><span><span>&lt;</span><span>PurchaseOrderDetailDTO</span><span>></span></span> updateOrderDetailList <span>=</span> purchaseOrderDTO<span>.</span><span>getPoOrderItemList</span><span>(</span><span>)</span><span>;</span>\n        <span>EnhanceStream</span><span>.</span><span>findAny</span><span>(</span>updateOrderDetailList<span>)</span>\n                <span>.</span><span>ifPresent</span><span>(</span>order <span>-></span> <span>{</span>\n                    order<span>.</span><span>setGiveawayNum</span><span>(</span><span>0</span><span>)</span><span>;</span>\n                <span>}</span><span>)</span><span>;</span>\n        purchaseOrderDTO<span>.</span><span>setId</span><span>(</span>purchaseOrderId<span>)</span><span>;</span><span>//第二次要修改要orderType</span>\n        purchaseOrderDTO<span>.</span><span>setOrderType</span><span>(</span><span>PurchaseOrderTypeEnum</span><span>.</span>TEMPORARY_ORDER<span>.</span><span>getKey</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>updatePurchaseOrder</span><span>(</span>purchaseOrderDTO<span>)</span><span>;</span>\n\n        <span>PurchaseOrderDTO</span> audit <span>=</span> <span>new</span> <span>PurchaseOrderDTO</span><span>(</span><span>)</span><span>;</span>\n        audit<span>.</span><span>setId</span><span>(</span>purchaseOrderId<span>)</span><span>;</span>\n        audit<span>.</span><span>setSameChainId</span><span>(</span>purchaseOrderDTO<span>.</span><span>getSameChainId</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        audit<span>.</span><span>setTradeCompanyIdList</span><span>(</span><span>(</span>purchaseOrderDTO<span>.</span><span>getTradeCompanyIdList</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>\n        audit<span>.</span><span>setSupplierId</span><span>(</span>purchaseOrderDTO<span>.</span><span>getSupplierId</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        audit<span>.</span><span>setCompanyId</span><span>(</span>purchaseOrderDTO<span>.</span><span>getCompanyId</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\n        <span>// 2. 执行审核</span>\n        <span>JsonResult</span><span><span>&lt;</span><span>Void</span><span>></span></span> auditJson <span>=</span> <span>TestWebUtils</span><span>.</span><span>web</span><span>(</span><span>this</span><span>.</span>base<span>)</span><span>.</span><span>when</span><span>(</span><span>PurchaseOrderController</span><span>.</span><span>class</span><span>)</span><span>.</span><span>audit</span><span>(</span>audit<span>)</span><span>;</span>\n        <span>PmsAssert</span><span>.</span><span>assertSuccess</span><span>(</span>auditJson<span>)</span><span>;</span>\n\n        <span>// 3. 订单查询</span>\n        <span>PurchaseOrderVO</span> purchaseOrderDetail <span>=</span> <span>queryPurchaseOrderDetail</span><span>(</span>purchaseOrderId<span>)</span><span>;</span>\n\n        <span>// 3.1 对po单主单里面的必填值</span>\n        <span>assertPo</span><span>(</span>purchaseOrderDetail<span>,</span> <span>false</span><span>,</span> purchaseOrderDetail<span>)</span><span>;</span>\n\n        <span>// 4. 生成三笔到货通知单,然后关闭</span>\n        <span>createArrivalOrderAndClose</span><span>(</span>purchaseOrderId<span>)</span><span>;</span>\n\n        <span>// 5. PO订单手动关闭</span>\n        <span>closePurchaseOrder</span><span>(</span>purchaseOrderId<span>,</span> <span>\"maven test 自动化脚本\"</span><span>)</span><span>;</span>\n\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br></div></div><p>当执行完上面的单测用例,就完成了采购核心链路的自动化流程,就会生成下面单据。</p>\n<p>采购单</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1621232807000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>到货通知单</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1621232854000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"三、可复用能力\"> 三、可复用能力</h2>\n<p>通过2我们知道如何使用Mockito做对象行为的mock。还有一个点要思考的,这里单独拿出来说。就是测试用例的可复用行。什么叫可复用性呢?\n就是说你这个单侧用例,在每次代码提交和编译时候执行，是否会有问题。如果是,且只能运行一次,那么这个就是不合格的。要做到可复用还要考虑两个地方。</p>\n<h3 id=\"_3-1-接口参数动态生成\"> 3.1 接口参数动态生成</h3>\n<p>为什么要动态生成呢? 因为比如我们指定了一个id去作为查询条件,那么当我们这个id被删除的时候,这个测试用例一定是失败的。\n这种场景下我们就应该动态去查询一个。如下，我们查询采购单的全链路数据。那么首先我先查询所有的有效的采购单,然后拿出任意一条\n作为测试用例的查询条件即可。</p>\n<div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>queryFullLinkData</span><span>(</span><span>)</span> <span>{</span>\n        <span>// 执行测试用例时候,动态获取一个采购单code</span>\n        <span>String</span> orderCode <span>=</span> testOrderUtils<span>.</span><span>purchaseOrderCode</span><span>(</span><span>)</span><span>;</span>\n        <span>TrackFullLinkDTO</span> trackFullLinkDTO <span>=</span> <span>new</span> <span>TrackFullLinkDTO</span><span>(</span><span>)</span><span>;</span>\n        trackFullLinkDTO<span>.</span><span>setCurrent</span><span>(</span><span>1L</span><span>)</span><span>;</span>\n        trackFullLinkDTO<span>.</span><span>setSize</span><span>(</span><span>10L</span><span>)</span><span>;</span>\n        trackFullLinkDTO<span>.</span><span>setPurchaseOrderCode</span><span>(</span>orderCode<span>)</span><span>;</span>\n        <span>JsonResult</span><span><span>&lt;</span><span>TrackFullLinkVO</span><span>></span></span> fullLinkData <span>=</span> <span>TestWebUtils</span><span>.</span><span>web</span><span>(</span><span>this</span><span>.</span>base<span>)</span><span>.</span><span>when</span><span>(</span><span>PurchaseOrderController</span><span>.</span><span>class</span><span>)</span><span>.</span><span>queryFullLinkData</span><span>(</span>trackFullLinkDTO<span>)</span><span>;</span>\n        <span>PmsAssert</span><span>.</span><span>assertSuccess</span><span>(</span>fullLinkData<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>上面这个用例只用声明一个测试的bean对象即可。在我们的 <code>src/test/java</code>包中。</p>\n<p>TestComponent</p>\n<div><pre><code><span>@TestComponent</span>\n<span>public</span> <span>class</span> <span>TestOrderUtils</span> <span>{</span>\n\n    <span>@Resource</span>\n    <span>private</span> <span>ArrivalNoticeOrderController</span> arrivalNoticeOrderController<span>;</span>\n\n    <span>public</span> <span>String</span> <span>purchaseOrderCode</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>purchaseOrder</span><span>(</span><span>)</span><span>.</span><span>getOrderCode</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"_3-2-业务流程要闭环\"> 3.2 业务流程要闭环</h3>\n<ol>\n<li>要么数据执行完成自动回滚</li>\n<li>要么数据不回滚,但是业务流程要闭环。</li>\n</ol>\n",
      "image": "https://img.springlearn.cn/blog/learn_1621248108000.png",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-03-24T14:34:44.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Arthas（阿尔萨斯） 能为你做什么",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/tools/arthas/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/tools/arthas/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/learn_1647177070000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>Arthas 是Alibaba开源的Java诊断工具，深受开发者喜爱。</p>\n<p>当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p>\n<ul>\n<li><input type=\"checkbox\" checked=\"checked\" disabled=\"disabled\" id=\"task-item-0\"><label for=\"task-item-0\"> 这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</label></li>\n<li><input type=\"checkbox\" checked=\"checked\" disabled=\"disabled\" id=\"task-item-1\"><label for=\"task-item-1\"> 我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</label></li>\n<li><input type=\"checkbox\" checked=\"checked\" disabled=\"disabled\" id=\"task-item-2\"><label for=\"task-item-2\"> 遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</label></li>\n<li><input type=\"checkbox\" checked=\"checked\" disabled=\"disabled\" id=\"task-item-3\"><label for=\"task-item-3\"> 线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</label></li>\n<li><input type=\"checkbox\" checked=\"checked\" disabled=\"disabled\" id=\"task-item-4\"><label for=\"task-item-4\"> 是否有一个全局视角来查看系统的运行状况？</label></li>\n<li><input type=\"checkbox\" checked=\"checked\" disabled=\"disabled\" id=\"task-item-5\"><label for=\"task-item-5\"> 有什么办法可以监控到JVM的实时运行状态？</label></li>\n<li><input type=\"checkbox\" checked=\"checked\" disabled=\"disabled\" id=\"task-item-6\"><label for=\"task-item-6\"> 怎么快速定位应用的热点，生成火焰图？</label></li>\n<li><input type=\"checkbox\" checked=\"checked\" disabled=\"disabled\" id=\"task-item-7\"><label for=\"task-item-7\"> 怎样直接从JVM内查找某个类的实例？</label></li>\n</ul>\n<p>Arthas支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。</p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1647177070000.png",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-03-24T14:34:44.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "基础命令",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/tools/arthas/base-cli/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/tools/arthas/base-cli/",
      "content_html": "<h2 id=\"一、启动arthas\"> 一、启动Arthas</h2>\n<div><pre><code>curl -O https://arthas.aliyun.com/arthas-boot.jar\njava -jar arthas-boot.jar\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>启动命令 <code>java -jar arthas-boot.jar</code></p>\n<h2 id=\"二、选择进程\"> 二、选择进程</h2>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1647178107000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>直接选择我们要监控的进程，输入3进入</p>\n<div><pre><code>[INFO] Attach process 28667 success.\n[INFO] arthas-client connect 127.0.0.1 3658\n  ,---.  ,------. ,--------.,--.  ,--.  ,---.   ,---.                           \n /  O  \\ |  .--. &#39;&#39;--.  .--&#39;|  &#39;--&#39;  | /  O  \\ &#39;   .-&#39;                          \n|  .-.  ||  &#39;--&#39;.&#39;   |  |   |  .--.  ||  .-.  |`.  `-.                          \n|  | |  ||  |\\  \\    |  |   |  |  |  ||  | |  |.-&#39;    |                         \n`--&#39; `--&#39;`--&#39; &#39;--&#39;   `--&#39;   `--&#39;  `--&#39;`--&#39; `--&#39;`-----&#39;                          \n\nwiki       https://arthas.aliyun.com/doc                                        \ntutorials  https://arthas.aliyun.com/doc/arthas-tutorials.html                  \nversion    3.5.6                                                                \nmain_class com.example.demo.DemoApplication                                     \npid        28667                                                                \ntime       2022-03-13 21:31:04   \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>提示已经连接上进程。</p>\n<h2 id=\"三、基础信息查询命令\"> 三、基础信息查询命令</h2>\n<h3 id=\"_3-1-dashboard-看板命令\"> 3.1 dashboard 看板命令</h3>\n<p>输入 <code>dashboard</code></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1647178404000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>会定时将应用信息输出到控制台上。</p>\n<h3 id=\"_3-2-jad-反向编译\"> 3.2 jad 反向编译</h3>\n<p><code>jad com.example.demo.DemoApplication</code></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1647178673000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_3-3-watch-监控指令\"> 3.3 watch 监控指令</h3>\n<p>这个命令是比较常用的命令,可以用来分析系统性能。</p>\n<div><pre><code><span>package</span> <span>com<span>.</span>example<span>.</span>demo</span><span>;</span>\n\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>web<span>.</span>bind<span>.</span>annotation<span>.</span></span><span>GetMapping</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>web<span>.</span>bind<span>.</span>annotation<span>.</span></span><span>ResponseBody</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>web<span>.</span>bind<span>.</span>annotation<span>.</span></span><span>RestController</span><span>;</span>\n<span>@RestController</span>\n<span>public</span> <span>class</span> <span>WebController</span> <span>{</span>\n\n    <span>@GetMapping</span><span>(</span><span>\"/get\"</span><span>)</span>\n    <span>@ResponseBody</span>\n    <span>public</span> <span>String</span> <span>get</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>\n        <span>return</span> name<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>监控这个类 <code>watch com.example.demo.WebController get returnObj</code></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数名</th>\n<th style=\"text-align:center\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">returnObj</td>\n<td style=\"text-align:center\">返回值</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">params</td>\n<td style=\"text-align:center\">入参</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">target</td>\n<td style=\"text-align:center\">方法调用方</td>\n</tr>\n</tbody>\n</table>\n<p><code>watch com.example.demo.WebController get {params,returnObj,target}</code></p>\n<div><pre><code>[arthas@32818]$ watch com.example.demo.WebController get returnObj\nPress Q or Ctrl+C to abort.\nAffect(class count: 1 , method count: 1) cost in 120 ms, listenerId: 1\nmethod=com.example.demo.WebController.get location=AtExit\nts=2022-03-13 21:41:56; [cost=1.317166ms] result=@String[123]\nmethod=com.example.demo.WebController.get location=AtExit\nts=2022-03-13 21:42:03; [cost=0.051875ms] result=@String[测试]\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h1 id=\"四、退出\"> 四、退出</h1>\n<p>输入 <code>q</code></p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1647178107000.png",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-03-24T14:34:44.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "class/classloader相关",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/tools/arthas/class-cli/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/tools/arthas/class-cli/",
      "content_html": "<h2 id=\"一、启动arthas\"> 一、启动Arthas</h2>\n<div><pre><code>curl -O https://arthas.aliyun.com/arthas-boot.jar\njava -jar arthas-boot.jar\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>启动命令 <code>java -jar arthas-boot.jar</code></p>\n<h2 id=\"二、选择进程\"> 二、选择进程</h2>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1647178107000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>直接选择我们要监控的进程，输入3进入</p>\n<div><pre><code>[INFO] Attach process 28667 success.\n[INFO] arthas-client connect 127.0.0.1 3658\n  ,---.  ,------. ,--------.,--.  ,--.  ,---.   ,---.                           \n /  O  \\ |  .--. &#39;&#39;--.  .--&#39;|  &#39;--&#39;  | /  O  \\ &#39;   .-&#39;                          \n|  .-.  ||  &#39;--&#39;.&#39;   |  |   |  .--.  ||  .-.  |`.  `-.                          \n|  | |  ||  |\\  \\    |  |   |  |  |  ||  | |  |.-&#39;    |                         \n`--&#39; `--&#39;`--&#39; &#39;--&#39;   `--&#39;   `--&#39;  `--&#39;`--&#39; `--&#39;`-----&#39;                          \n\nwiki       https://arthas.aliyun.com/doc                                        \ntutorials  https://arthas.aliyun.com/doc/arthas-tutorials.html                  \nversion    3.5.6                                                                \nmain_class com.example.demo.DemoApplication                                     \npid        28667                                                                \ntime       2022-03-13 21:31:04   \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>提示已经连接上进程。</p>\n<h2 id=\"三、基础信息查询命令\"> 三、基础信息查询命令</h2>\n<h3 id=\"_3-1-dashboard-看板命令\"> 3.1 dashboard 看板命令</h3>\n<p>输入 <code>dashboard</code></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1647178404000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>会定时将应用信息输出到控制台上。</p>\n<h3 id=\"_3-2-jad-反向编译\"> 3.2 jad 反向编译</h3>\n<p><code>jad com.example.demo.DemoApplication</code></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1647178673000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_3-3-watch-监控指令\"> 3.3 watch 监控指令</h3>\n<p>这个命令是比较常用的命令,可以用来分析系统性能。</p>\n<div><pre><code><span>package</span> <span>com<span>.</span>example<span>.</span>demo</span><span>;</span>\n\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>web<span>.</span>bind<span>.</span>annotation<span>.</span></span><span>GetMapping</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>web<span>.</span>bind<span>.</span>annotation<span>.</span></span><span>ResponseBody</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>web<span>.</span>bind<span>.</span>annotation<span>.</span></span><span>RestController</span><span>;</span>\n<span>@RestController</span>\n<span>public</span> <span>class</span> <span>WebController</span> <span>{</span>\n\n    <span>@GetMapping</span><span>(</span><span>\"/get\"</span><span>)</span>\n    <span>@ResponseBody</span>\n    <span>public</span> <span>String</span> <span>get</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>\n        <span>return</span> name<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>监控这个类 <code>watch com.example.demo.WebController get returnObj</code></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数名</th>\n<th style=\"text-align:center\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">returnObj</td>\n<td style=\"text-align:center\">返回值</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">params</td>\n<td style=\"text-align:center\">入参</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">target</td>\n<td style=\"text-align:center\">方法调用方</td>\n</tr>\n</tbody>\n</table>\n<p><code>watch com.example.demo.WebController get {params,returnObj,target}</code></p>\n<div><pre><code>[arthas@32818]$ watch com.example.demo.WebController get returnObj\nPress Q or Ctrl+C to abort.\nAffect(class count: 1 , method count: 1) cost in 120 ms, listenerId: 1\nmethod=com.example.demo.WebController.get location=AtExit\nts=2022-03-13 21:41:56; [cost=1.317166ms] result=@String[123]\nmethod=com.example.demo.WebController.get location=AtExit\nts=2022-03-13 21:42:03; [cost=0.051875ms] result=@String[测试]\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h1 id=\"四、退出\"> 四、退出</h1>\n<p>输入 <code>q</code></p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1647178107000.png",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-03-24T14:34:44.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "基础教程",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/tools/arthas/learn/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/tools/arthas/learn/",
      "content_html": "<h2 id=\"一、启动arthas\"> 一、启动Arthas</h2>\n<div><pre><code>curl -O https://arthas.aliyun.com/arthas-boot.jar\njava -jar arthas-boot.jar\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>启动命令 <code>java -jar arthas-boot.jar</code></p>\n<h2 id=\"二、选择进程\"> 二、选择进程</h2>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1647178107000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>直接选择我们要监控的进程，输入3进入</p>\n<div><pre><code>[INFO] Attach process 28667 success.\n[INFO] arthas-client connect 127.0.0.1 3658\n  ,---.  ,------. ,--------.,--.  ,--.  ,---.   ,---.                           \n /  O  \\ |  .--. &#39;&#39;--.  .--&#39;|  &#39;--&#39;  | /  O  \\ &#39;   .-&#39;                          \n|  .-.  ||  &#39;--&#39;.&#39;   |  |   |  .--.  ||  .-.  |`.  `-.                          \n|  | |  ||  |\\  \\    |  |   |  |  |  ||  | |  |.-&#39;    |                         \n`--&#39; `--&#39;`--&#39; &#39;--&#39;   `--&#39;   `--&#39;  `--&#39;`--&#39; `--&#39;`-----&#39;                          \n\nwiki       https://arthas.aliyun.com/doc                                        \ntutorials  https://arthas.aliyun.com/doc/arthas-tutorials.html                  \nversion    3.5.6                                                                \nmain_class com.example.demo.DemoApplication                                     \npid        28667                                                                \ntime       2022-03-13 21:31:04   \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>提示已经连接上进程。</p>\n<h2 id=\"三、基础信息查询命令\"> 三、基础信息查询命令</h2>\n<h3 id=\"_3-1-dashboard-看板命令\"> 3.1 dashboard 看板命令</h3>\n<p>输入 <code>dashboard</code></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1647178404000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>会定时将应用信息输出到控制台上。</p>\n<h3 id=\"_3-2-jad-反向编译\"> 3.2 jad 反向编译</h3>\n<p><code>jad com.example.demo.DemoApplication</code></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1647178673000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_3-3-watch-监控指令\"> 3.3 watch 监控指令</h3>\n<p>这个命令是比较常用的命令,可以用来分析系统性能。</p>\n<div><pre><code><span>package</span> <span>com<span>.</span>example<span>.</span>demo</span><span>;</span>\n\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>web<span>.</span>bind<span>.</span>annotation<span>.</span></span><span>GetMapping</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>web<span>.</span>bind<span>.</span>annotation<span>.</span></span><span>ResponseBody</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>web<span>.</span>bind<span>.</span>annotation<span>.</span></span><span>RestController</span><span>;</span>\n<span>@RestController</span>\n<span>public</span> <span>class</span> <span>WebController</span> <span>{</span>\n\n    <span>@GetMapping</span><span>(</span><span>\"/get\"</span><span>)</span>\n    <span>@ResponseBody</span>\n    <span>public</span> <span>String</span> <span>get</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>\n        <span>return</span> name<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>监控这个类 <code>watch com.example.demo.WebController get returnObj</code></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数名</th>\n<th style=\"text-align:center\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">returnObj</td>\n<td style=\"text-align:center\">返回值</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">params</td>\n<td style=\"text-align:center\">入参</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">target</td>\n<td style=\"text-align:center\">方法调用方</td>\n</tr>\n</tbody>\n</table>\n<p><code>watch com.example.demo.WebController get {params,returnObj,target}</code></p>\n<div><pre><code>[arthas@32818]$ watch com.example.demo.WebController get returnObj\nPress Q or Ctrl+C to abort.\nAffect(class count: 1 , method count: 1) cost in 120 ms, listenerId: 1\nmethod=com.example.demo.WebController.get location=AtExit\nts=2022-03-13 21:41:56; [cost=1.317166ms] result=@String[123]\nmethod=com.example.demo.WebController.get location=AtExit\nts=2022-03-13 21:42:03; [cost=0.051875ms] result=@String[测试]\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h1 id=\"四、退出\"> 四、退出</h1>\n<p>输入 <code>q</code></p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1647178107000.png",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-03-24T14:34:44.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "JVM相关命令",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/tools/arthas/jvm-cli/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/tools/arthas/jvm-cli/",
      "content_html": "<h2 id=\"一、启动arthas\"> 一、启动Arthas</h2>\n<div><pre><code>curl -O https://arthas.aliyun.com/arthas-boot.jar\njava -jar arthas-boot.jar\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>启动命令 <code>java -jar arthas-boot.jar</code></p>\n<h2 id=\"二、选择进程\"> 二、选择进程</h2>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1647178107000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>直接选择我们要监控的进程，输入3进入</p>\n<div><pre><code>[INFO] Attach process 28667 success.\n[INFO] arthas-client connect 127.0.0.1 3658\n  ,---.  ,------. ,--------.,--.  ,--.  ,---.   ,---.                           \n /  O  \\ |  .--. &#39;&#39;--.  .--&#39;|  &#39;--&#39;  | /  O  \\ &#39;   .-&#39;                          \n|  .-.  ||  &#39;--&#39;.&#39;   |  |   |  .--.  ||  .-.  |`.  `-.                          \n|  | |  ||  |\\  \\    |  |   |  |  |  ||  | |  |.-&#39;    |                         \n`--&#39; `--&#39;`--&#39; &#39;--&#39;   `--&#39;   `--&#39;  `--&#39;`--&#39; `--&#39;`-----&#39;                          \n\nwiki       https://arthas.aliyun.com/doc                                        \ntutorials  https://arthas.aliyun.com/doc/arthas-tutorials.html                  \nversion    3.5.6                                                                \nmain_class com.example.demo.DemoApplication                                     \npid        28667                                                                \ntime       2022-03-13 21:31:04   \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>提示已经连接上进程。</p>\n<h2 id=\"三、基础信息查询命令\"> 三、基础信息查询命令</h2>\n<h3 id=\"_3-1-dashboard-看板命令\"> 3.1 dashboard 看板命令</h3>\n<p>输入 <code>dashboard</code></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1647178404000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>会定时将应用信息输出到控制台上。</p>\n<h3 id=\"_3-2-jad-反向编译\"> 3.2 jad 反向编译</h3>\n<p><code>jad com.example.demo.DemoApplication</code></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1647178673000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_3-3-watch-监控指令\"> 3.3 watch 监控指令</h3>\n<p>这个命令是比较常用的命令,可以用来分析系统性能。</p>\n<div><pre><code><span>package</span> <span>com<span>.</span>example<span>.</span>demo</span><span>;</span>\n\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>web<span>.</span>bind<span>.</span>annotation<span>.</span></span><span>GetMapping</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>web<span>.</span>bind<span>.</span>annotation<span>.</span></span><span>ResponseBody</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>web<span>.</span>bind<span>.</span>annotation<span>.</span></span><span>RestController</span><span>;</span>\n<span>@RestController</span>\n<span>public</span> <span>class</span> <span>WebController</span> <span>{</span>\n\n    <span>@GetMapping</span><span>(</span><span>\"/get\"</span><span>)</span>\n    <span>@ResponseBody</span>\n    <span>public</span> <span>String</span> <span>get</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>\n        <span>return</span> name<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>监控这个类 <code>watch com.example.demo.WebController get returnObj</code></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数名</th>\n<th style=\"text-align:center\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">returnObj</td>\n<td style=\"text-align:center\">返回值</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">params</td>\n<td style=\"text-align:center\">入参</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">target</td>\n<td style=\"text-align:center\">方法调用方</td>\n</tr>\n</tbody>\n</table>\n<p><code>watch com.example.demo.WebController get {params,returnObj,target}</code></p>\n<div><pre><code>[arthas@32818]$ watch com.example.demo.WebController get returnObj\nPress Q or Ctrl+C to abort.\nAffect(class count: 1 , method count: 1) cost in 120 ms, listenerId: 1\nmethod=com.example.demo.WebController.get location=AtExit\nts=2022-03-13 21:41:56; [cost=1.317166ms] result=@String[123]\nmethod=com.example.demo.WebController.get location=AtExit\nts=2022-03-13 21:42:03; [cost=0.051875ms] result=@String[测试]\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h1 id=\"四、退出\"> 四、退出</h1>\n<p>输入 <code>q</code></p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1647178107000.png",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-03-24T14:34:44.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "monitor/watch/trace相关",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/tools/arthas/watch-cli/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/tools/arthas/watch-cli/",
      "content_html": "<h2 id=\"一、启动arthas\"> 一、启动Arthas</h2>\n<div><pre><code>curl -O https://arthas.aliyun.com/arthas-boot.jar\njava -jar arthas-boot.jar\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>启动命令 <code>java -jar arthas-boot.jar</code></p>\n<h2 id=\"二、选择进程\"> 二、选择进程</h2>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1647178107000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>直接选择我们要监控的进程，输入3进入</p>\n<div><pre><code>[INFO] Attach process 28667 success.\n[INFO] arthas-client connect 127.0.0.1 3658\n  ,---.  ,------. ,--------.,--.  ,--.  ,---.   ,---.                           \n /  O  \\ |  .--. &#39;&#39;--.  .--&#39;|  &#39;--&#39;  | /  O  \\ &#39;   .-&#39;                          \n|  .-.  ||  &#39;--&#39;.&#39;   |  |   |  .--.  ||  .-.  |`.  `-.                          \n|  | |  ||  |\\  \\    |  |   |  |  |  ||  | |  |.-&#39;    |                         \n`--&#39; `--&#39;`--&#39; &#39;--&#39;   `--&#39;   `--&#39;  `--&#39;`--&#39; `--&#39;`-----&#39;                          \n\nwiki       https://arthas.aliyun.com/doc                                        \ntutorials  https://arthas.aliyun.com/doc/arthas-tutorials.html                  \nversion    3.5.6                                                                \nmain_class com.example.demo.DemoApplication                                     \npid        28667                                                                \ntime       2022-03-13 21:31:04   \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>提示已经连接上进程。</p>\n<h2 id=\"三、基础信息查询命令\"> 三、基础信息查询命令</h2>\n<h3 id=\"_3-1-dashboard-看板命令\"> 3.1 dashboard 看板命令</h3>\n<p>输入 <code>dashboard</code></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1647178404000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>会定时将应用信息输出到控制台上。</p>\n<h3 id=\"_3-2-jad-反向编译\"> 3.2 jad 反向编译</h3>\n<p><code>jad com.example.demo.DemoApplication</code></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1647178673000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_3-3-watch-监控指令\"> 3.3 watch 监控指令</h3>\n<p>这个命令是比较常用的命令,可以用来分析系统性能。</p>\n<div><pre><code><span>package</span> <span>com<span>.</span>example<span>.</span>demo</span><span>;</span>\n\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>web<span>.</span>bind<span>.</span>annotation<span>.</span></span><span>GetMapping</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>web<span>.</span>bind<span>.</span>annotation<span>.</span></span><span>ResponseBody</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>web<span>.</span>bind<span>.</span>annotation<span>.</span></span><span>RestController</span><span>;</span>\n<span>@RestController</span>\n<span>public</span> <span>class</span> <span>WebController</span> <span>{</span>\n\n    <span>@GetMapping</span><span>(</span><span>\"/get\"</span><span>)</span>\n    <span>@ResponseBody</span>\n    <span>public</span> <span>String</span> <span>get</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>\n        <span>return</span> name<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>监控这个类 <code>watch com.example.demo.WebController get returnObj</code></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数名</th>\n<th style=\"text-align:center\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">returnObj</td>\n<td style=\"text-align:center\">返回值</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">params</td>\n<td style=\"text-align:center\">入参</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">target</td>\n<td style=\"text-align:center\">方法调用方</td>\n</tr>\n</tbody>\n</table>\n<p><code>watch com.example.demo.WebController get {params,returnObj,target}</code></p>\n<div><pre><code>[arthas@32818]$ watch com.example.demo.WebController get returnObj\nPress Q or Ctrl+C to abort.\nAffect(class count: 1 , method count: 1) cost in 120 ms, listenerId: 1\nmethod=com.example.demo.WebController.get location=AtExit\nts=2022-03-13 21:41:56; [cost=1.317166ms] result=@String[123]\nmethod=com.example.demo.WebController.get location=AtExit\nts=2022-03-13 21:42:03; [cost=0.051875ms] result=@String[测试]\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h1 id=\"四、退出\"> 四、退出</h1>\n<p>输入 <code>q</code></p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1647178107000.png",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-03-24T14:34:44.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Guava：用于 Java 的 Google 核心库",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/tools/guava/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/tools/guava/",
      "content_html": "<p><img src=\"https://camo.githubusercontent.com/45e5eb02492f9e3bf6345cfd7ca7ecb42dca2268fef7af35dfe3da82740b4000/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f72656c656173652f676f6f676c652f67756176612e737667\" alt=\"\" loading=\"lazy\">\n<img src=\"https://github.com/google/guava/workflows/CI/badge.svg?branch=master\" alt=\"\" loading=\"lazy\"></p>\n<p>Guava 是一组来自 Google 的核心 Java 库，其中包括新的集合类型（例如 multimap 和 multiset）、不可变集合、图形库以及用于并发、I/O、散列、缓存、原语、字符串等的实用程序！它广泛用于 Google 内部的大多数 Java 项目，也被许多其他公司广泛使用</p>\n<div><pre><code><span><span><span>&lt;</span>dependency</span><span>></span></span>\n    <span><span><span>&lt;</span>groupId</span><span>></span></span>com.google.guava<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n    <span><span><span>&lt;</span>artifactId</span><span>></span></span>guava<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n    <span><span><span>&lt;</span>version</span><span>></span></span>31.1-jre<span><span><span>&lt;/</span>version</span><span>></span></span>\n    <span>&lt;!-- or, for Android: --></span>\n    <span><span><span>&lt;</span>version</span><span>></span></span>31.1-android<span><span><span>&lt;/</span>version</span><span>></span></span>\n<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div>",
      "image": "https://camo.githubusercontent.com/45e5eb02492f9e3bf6345cfd7ca7ecb42dca2268fef7af35dfe3da82740b4000/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f72656c656173652f676f6f676c652f67756176612e737667",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-03-24T14:34:44.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "消息验证",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/test/%E6%B6%88%E6%81%AF%E9%AA%8C%E8%AF%81/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/test/%E6%B6%88%E6%81%AF%E9%AA%8C%E8%AF%81/",
      "content_html": "<div><p>相关信息</p>\n<p>这一是凑数的,想表达的内容只有一点: 消息入口不应该出现复杂的业务逻辑。\n对于消息的验证,我们只需要验证消息收发是否正常即可。处理方案就是将消息与\n业务分离测试。</p>\n</div>\n<p>eg:</p>\n<p>Message入口就类似于Web入口一样。我们复杂的业务逻辑一定不会再入口处直接写代码，\n如果是这样写的那么维护性和复用性一定是很差的。</p>\n",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-03-24T14:34:44.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Javassist",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/tools/bytecode/Javassist/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/tools/bytecode/Javassist/",
      "content_html": "<div><p>Javassist</p>\n<p>Javassist是一个开源的分析、编辑和创建Java字节码的类库，可以直接编辑和生成Java生成的字节码。\n相对于bcel, asm等这些工具，开发者不需要了解虚拟机指令，就能动态改变类的结构，或者动态生成类。javassist简单易用， 快速。</p>\n</div>\n<p><a href=\"https://github.com/lxchinesszz/bytecode-example\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://img.shields.io/badge/字节码编程-bytecode--example-green\" alt=\"\" loading=\"lazy\"></a></p>\n<h2 id=\"一、核心工具类\"> 一、核心工具类</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">核心类</th>\n<th style=\"text-align:left\">解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ClassPool</td>\n<td style=\"text-align:left\">javassist的类池，使用ClassPool 类可以跟踪和控制所操作的类，它的工作方式与 JVM 类装载器非常相似</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CtClass</td>\n<td style=\"text-align:left\">CtClass提供了类的操作，如在类中动态添加新字段、方法和构造函数、以及改变类、父类和接口的方法。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CtField</td>\n<td style=\"text-align:left\">类的属性，通过它可以给类创建新的属性，还可以修改已有的属性的类型，访问修饰符等</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CtMethod</td>\n<td style=\"text-align:left\">类中的方法，通过它可以给类创建新的方法，还可以修改返回类型，访问修饰符等， 甚至还可以修改方法体内容代码</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CtConstructor</td>\n<td style=\"text-align:left\">与CtMethod类似</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"二、api\"> 二、API</h2>\n<h3 id=\"_2-1-classpool\"> 2.1 ClassPool</h3>\n<div><pre><code>    <span>// 类库, jvm中所加载的class</span>\n \t<span>ClassPool</span> pool <span>=</span> <span>ClassPool</span><span>.</span><span>getDefault</span><span>(</span><span>)</span><span>;</span>\n\t<span>// 加载一个已知的类, 注：参数必须为全量类名</span>\n\t<span>CtClass</span> ctClass <span>=</span> pool<span>.</span><span>get</span><span>(</span><span>\"com.itheima.Student\"</span><span>)</span><span>;</span>\n\t<span>// 创建一个新的类, 类名必须为全量类名</span>\n\t<span>CtClass</span> tClass <span>=</span> pool<span>.</span><span>makeClass</span><span>(</span><span>\"com.itheima.Calculator\"</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id=\"_2-2-ctfield\"> 2.2 CtField</h3>\n<div><pre><code>\t<span>// 获取已知类的属性</span>\n\t<span>CtField</span> ctField <span>=</span> ctClass<span>.</span><span>getDeclaredField</span><span>(</span><span>\"name\"</span><span>)</span><span>;</span>\n\t<span>// 构建新的类的成员变量</span>\n\t<span>CtField</span> ctFieldNew <span>=</span> <span>new</span> <span>CtField</span><span>(</span><span>CtClass</span><span>.</span>intType<span>,</span><span>\"age\"</span><span>,</span>ctClass<span>)</span><span>;</span>\n\t<span>// 设置类的访问修饰符为public</span>\n\tctFieldNew<span>.</span><span>setModifiers</span><span>(</span><span>Modifier</span><span>.</span>PUBLIC<span>)</span><span>;</span>\n\t<span>// 将属性添加到类中</span>\n\tctClass<span>.</span><span>addField</span><span>(</span>ctFieldNew<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id=\"_2-3-ctmethod\"> 2.3 CtMethod</h3>\n<div><pre><code>\t<span>// 获取已有方法</span>\n\t<span>//创建新的方法, 参数1:方法的返回类型，参数2：名称，参数3：方法的参数，参数4：方法所属的类</span>\n\t<span>CtMethod</span> ctMethod <span>=</span> <span>new</span> <span>CtMethod</span><span>(</span><span>CtClass</span><span>.</span>intType<span>,</span> <span>\"calc\"</span><span>,</span> <span>new</span> <span>CtClass</span><span>[</span><span>]</span>\n<span>{</span><span>CtClass</span><span>.</span>intType<span>,</span><span>CtClass</span><span>.</span>intType<span>}</span><span>,</span> tClass<span>)</span><span>;</span>\n\t<span>// 设置方法的访问修饰</span>\n\tctMethod<span>.</span><span>setModifiers</span><span>(</span><span>Modifier</span><span>.</span>PUBLIC<span>)</span><span>;</span>\n\t<span>// 将新建的方法添加到类中</span>\n\tctClass<span>.</span><span>addMethod</span><span>(</span>ctMethod<span>)</span><span>;</span>\n\t<span>// 方法体内容代码 $1代表第一个参数，$2代表第二个参数</span>\n\tctMethod<span>.</span><span>setBody</span><span>(</span><span>\"return $1 + $2;\"</span><span>)</span><span>;</span> \n\n\t<span>CtMethod</span> ctMethod <span>=</span> ctClass<span>.</span><span>getDeclaredMethod</span><span>(</span><span>\"sayHello\"</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id=\"_2-4-ctconstructor\"> 2.4 CtConstructor</h3>\n<div><pre><code>    <span>// 获取已有的构造方法, 参数为构建方法的参数类型数组</span>\n    <span>CtConstructor</span> ctConstructor <span>=</span> ctClass<span>.</span><span>getDeclaredConstructor</span><span>(</span><span>new</span> <span>CtClass</span><span>[</span><span>]</span><span>{</span><span>}</span><span>)</span><span>;</span>\n    <span>// 创建新的构造方法</span>\n    <span>CtConstructor</span> ctConstructor <span>=</span> <span>new</span> <span>CtConstructor</span><span>(</span><span>new</span> <span>CtClass</span><span>[</span><span>]</span><span>{</span><span>CtClass</span><span>.</span>intType<span>}</span><span>,</span>ctClass<span>)</span><span>;</span> ctConstructor<span>.</span><span>setModifiers</span><span>(</span><span>Modifier</span><span>.</span>PUBLIC<span>)</span><span>;</span>\n    ctConstructor<span>.</span><span>setBody</span><span>(</span><span>\"this.age = $1;\"</span><span>)</span><span>;</span>\n    ctClass<span>.</span><span>addConstructor</span><span>(</span>ctConstructor<span>)</span><span>;</span>\n    <span>// 也可直接创建</span>\n    ctConstructor <span>=</span> <span>CtNewConstructor</span><span>.</span><span>make</span><span>(</span><span>\"public Student(int age){this.age=age;}\"</span><span>,</span> ctClass<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id=\"三、示例\"> 三、示例</h2>\n<div><pre><code><span>public</span> <span>class</span> <span>User</span> <span>{</span>\n\n    <span>private</span> <span>String</span> name<span>;</span>\n\n    <span>public</span> <span>User</span><span>(</span><span>)</span> <span>{</span>\n    <span>}</span>\n\n    <span>public</span> <span>User</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>String</span> <span>sayJavassist</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>\"Hello Javassist\"</span><span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>\"User{\"</span> <span>+</span>\n                <span>\"name='\"</span> <span>+</span> name <span>+</span> <span>'\\''</span> <span>+</span>\n                <span>'}'</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h3 id=\"_3-1-修改方法\"> 3.1 修改方法</h3>\n<div><pre><code>        <span>// 类库池, jvm中所加载的class</span>\n        <span>ClassPool</span> pool <span>=</span> <span>ClassPool</span><span>.</span><span>getDefault</span><span>(</span><span>)</span><span>;</span>\n        <span>// 获取指定的Student类</span>\n        <span>CtClass</span> ctClass <span>=</span> pool<span>.</span><span>get</span><span>(</span><span>\"com.example.test.User\"</span><span>)</span><span>;</span>\n        <span>// 获取sayHello方法</span>\n        <span>CtMethod</span> ctMethod <span>=</span> ctClass<span>.</span><span>getDeclaredMethod</span><span>(</span><span>\"sayJavassist\"</span><span>)</span><span>;</span>\n        <span>// 在方法的代码后追加 一段代码</span>\n        ctMethod<span>.</span><span>insertAfter</span><span>(</span><span>\"System.out.println(\\\"I'm Javassist.\\\");\"</span><span>)</span><span>;</span>\n        <span>// 使用当前的ClassLoader加载被修改后的类</span>\n        <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> newClass <span>=</span> ctClass<span>.</span><span>toClass</span><span>(</span><span>)</span><span>;</span>\n        <span>User</span> user <span>=</span> <span>(</span><span>User</span><span>)</span> newClass<span>.</span><span>newInstance</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>user<span>.</span><span>sayJavassist</span><span>(</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id=\"_3-2-动态添加方法\"> 3.2 动态添加方法</h3>\n<div><pre><code>        <span>// 类库池, jvm中所加载的class</span>\n        <span>ClassPool</span> pool <span>=</span> <span>ClassPool</span><span>.</span><span>getDefault</span><span>(</span><span>)</span><span>;</span>\n        <span>// 获取指定的Student类</span>\n        <span>CtClass</span> ctClass <span>=</span> pool<span>.</span><span>get</span><span>(</span><span>\"com.example.test.User\"</span><span>)</span><span>;</span>\n        <span>// 增加方法</span>\n        <span>CtMethod</span> ctMethod <span>=</span> <span>new</span> <span>CtMethod</span><span>(</span><span>CtClass</span><span>.</span>intType<span>,</span> <span>\"getAgeSum\"</span><span>,</span>\n                <span>new</span> <span>CtClass</span><span>[</span><span>]</span><span>{</span><span>CtClass</span><span>.</span>intType<span>,</span> <span>CtClass</span><span>.</span>intType<span>}</span><span>,</span> ctClass<span>)</span><span>;</span>\n        <span>// 设置方法的访问修饰</span>\n        ctMethod<span>.</span><span>setModifiers</span><span>(</span><span>Modifier</span><span>.</span>PUBLIC<span>)</span><span>;</span>\n        <span>// 设置方法体代码</span>\n        ctMethod<span>.</span><span>setBody</span><span>(</span><span>\"return $1 + $2;\"</span><span>)</span><span>;</span>\n        <span>// 添加新建的方法到原有的类中</span>\n        ctClass<span>.</span><span>addMethod</span><span>(</span>ctMethod<span>)</span><span>;</span>\n        <span>// 加载修改后的类</span>\n        ctClass<span>.</span><span>toClass</span><span>(</span><span>)</span><span>;</span>\n        <span>// 创建对象</span>\n        <span>User</span> stu <span>=</span> <span>new</span> <span>User</span><span>(</span><span>)</span><span>;</span>\n        <span>// 获取calc方法</span>\n        <span>Method</span> dMethod <span>=</span> <span>User</span><span>.</span><span>class</span><span>.</span><span>getDeclaredMethod</span><span>(</span><span>\"getAgeSum\"</span><span>,</span> <span>new</span> <span>Class</span><span>[</span><span>]</span>\n                <span>{</span><span>int</span><span>.</span><span>class</span><span>,</span> <span>int</span><span>.</span><span>class</span><span>}</span><span>)</span><span>;</span>\n        <span>// 反射调用 方法</span>\n        <span>Object</span> result <span>=</span> dMethod<span>.</span><span>invoke</span><span>(</span>stu<span>,</span> <span>10</span><span>,</span> <span>20</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>result<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h3 id=\"_3-3-动态创建类\"> 3.3 动态创建类</h3>\n<div><pre><code>        <span>// 类库池, jvm中所加载的class</span>\n        <span>ClassPool</span> pool <span>=</span> <span>ClassPool</span><span>.</span><span>getDefault</span><span>(</span><span>)</span><span>;</span>\n        <span>// 创建一个学校类</span>\n        <span>CtClass</span> schoolClass <span>=</span> pool<span>.</span><span>makeClass</span><span>(</span><span>\"com.example.test.School\"</span><span>)</span><span>;</span>\n        <span>// 设置为公有类</span>\n        schoolClass<span>.</span><span>setModifiers</span><span>(</span><span>Modifier</span><span>.</span>PUBLIC<span>)</span><span>;</span>\n        <span>// 获取String类型</span>\n        <span>CtClass</span> stringClass <span>=</span> pool<span>.</span><span>get</span><span>(</span><span>\"java.lang.String\"</span><span>)</span><span>;</span>\n        <span>// 获取list类型</span>\n        <span>CtClass</span> listClass <span>=</span> pool<span>.</span><span>get</span><span>(</span><span>\"java.util.List\"</span><span>)</span><span>;</span>\n        <span>// 获取学生的类型</span>\n        <span>CtClass</span> userClass <span>=</span> pool<span>.</span><span>get</span><span>(</span><span>\"com.example.test.User\"</span><span>)</span><span>;</span>\n        <span>// 给学校添加一个校名属性</span>\n        <span>CtField</span> nameField <span>=</span> <span>new</span> <span>CtField</span><span>(</span>stringClass<span>,</span> <span>\"schoolName\"</span><span>,</span> schoolClass<span>)</span><span>;</span>\n        nameField<span>.</span><span>setModifiers</span><span>(</span><span>Modifier</span><span>.</span>PUBLIC<span>)</span><span>;</span>\n        schoolClass<span>.</span><span>addField</span><span>(</span>nameField<span>)</span><span>;</span>\n        <span>// 给学校添加一个学生集合</span>\n        <span>CtField</span> studentList <span>=</span> <span>new</span> <span>CtField</span><span>(</span>listClass<span>,</span> <span>\"users\"</span><span>,</span> schoolClass<span>)</span><span>;</span>\n        studentList<span>.</span><span>setModifiers</span><span>(</span><span>Modifier</span><span>.</span>PUBLIC<span>)</span><span>;</span>\n        schoolClass<span>.</span><span>addField</span><span>(</span>studentList<span>)</span><span>;</span>\n        <span>// 给学校一个空构造</span>\n        <span>CtConstructor</span> ctConstructor <span>=</span> <span>CtNewConstructor</span><span>.</span><span>make</span><span>(</span><span>\"public School() \"</span> <span>+</span>\n                <span>\"{this.schoolName=\\\"湖畔小学\\\";this.users = new java.util.ArrayList();}\"</span><span>,</span> schoolClass<span>)</span><span>;</span>\n        schoolClass<span>.</span><span>addConstructor</span><span>(</span>ctConstructor<span>)</span><span>;</span>\n\n        <span>// 给学校一个addUser的方法</span>\n        <span>CtMethod</span> m <span>=</span> <span>new</span> <span>CtMethod</span><span>(</span><span>CtClass</span><span>.</span>voidType<span>,</span> <span>\"addUser\"</span><span>,</span> <span>new</span> <span>CtClass</span><span>[</span><span>]</span><span>{</span>userClass<span>}</span><span>,</span> schoolClass<span>)</span><span>;</span>\n        m<span>.</span><span>setModifiers</span><span>(</span><span>Modifier</span><span>.</span>PUBLIC<span>)</span><span>;</span>\n        <span>// 添加学生对象到students属性中, $1代表参数1</span>\n        m<span>.</span><span>setBody</span><span>(</span><span>\"this.users.add($1);\"</span><span>)</span><span>;</span>\n        schoolClass<span>.</span><span>addMethod</span><span>(</span>m<span>)</span><span>;</span>\n\n        <span>// 给学校添加一个介绍的方法</span>\n        <span>CtMethod</span> introduce <span>=</span> <span>new</span> <span>CtMethod</span><span>(</span><span>CtClass</span><span>.</span>voidType<span>,</span> <span>\"introduce\"</span><span>,</span> <span>new</span> <span>CtClass</span><span>[</span><span>]</span><span>{</span><span>}</span><span>,</span> schoolClass<span>)</span><span>;</span>\n        introduce<span>.</span><span>setBody</span><span>(</span><span>\"System.out.println(\\\"The School name is \\\" + this.schoolName);\"</span><span>)</span><span>;</span>\n        introduce<span>.</span><span>insertAfter</span><span>(</span><span>\"System.out.println(this.users);\"</span><span>)</span><span>;</span>\n        schoolClass<span>.</span><span>addMethod</span><span>(</span>introduce<span>)</span><span>;</span>\n\n        <span>// 加载修改后的学校</span>\n        <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> schoolLoadClass <span>=</span> schoolClass<span>.</span><span>toClass</span><span>(</span><span>)</span><span>;</span>\n        <span>// 构建一个学校(空构造)</span>\n        <span>Object</span> school <span>=</span> schoolLoadClass<span>.</span><span>newInstance</span><span>(</span><span>)</span><span>;</span>\n        <span>// 获取添加用户方法</span>\n        <span>Method</span> addUserMethod <span>=</span> schoolLoadClass<span>.</span><span>getDeclaredMethod</span><span>(</span><span>\"addUser\"</span><span>,</span> userClass<span>.</span><span>toClass</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        addUserMethod<span>.</span><span>invoke</span><span>(</span>school<span>,</span> <span>new</span> <span>User</span><span>(</span><span>\"小明\"</span><span>)</span><span>)</span><span>;</span>\n        addUserMethod<span>.</span><span>invoke</span><span>(</span>school<span>,</span> <span>new</span> <span>User</span><span>(</span><span>\"小张\"</span><span>)</span><span>)</span><span>;</span>\n        <span>// 获取介绍方法，把刚才的信息给打印处理</span>\n        <span>Method</span> introduceMethod <span>=</span> school<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getDeclaredMethod</span><span>(</span><span>\"introduce\"</span><span>)</span><span>;</span>\n        introduceMethod<span>.</span><span>invoke</span><span>(</span>school<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br></div></div><div><pre><code>The School name is 湖畔小学\n[User{name=&#39;小明&#39;}, User{name=&#39;小张&#39;}]\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div>",
      "image": "https://img.shields.io/badge/%E5%AD%97%E8%8A%82%E7%A0%81%E7%BC%96%E7%A8%8B-bytecode--example-green",
      "date_modified": "2022-03-24T17:05:14.669Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Guava-Map",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/tools/guava/guava-map/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/tools/guava/guava-map/",
      "content_html": "<h2 id=\"一、简介\"> 一、简介</h2>\n<p>Guava 是一组来自 Google 的核心 Java 库，其中包括新的集合类型（例如 multimap 和 multiset）、不可变集合、图形库以及用于并发、I/O、散列、缓存、原语、字符串等的实用程序！它广泛用于 Google\n内部的大多数 Java 项目，也被许多其他公司广泛使用。</p>\n<p>API 非常的简单，我们可以非常轻松的使用，来封装成我们业务中自己的组件。</p>\n<h2 id=\"二、依赖\"> 二、依赖</h2>\n<div><pre><code>    <span><span><span>&lt;</span>dependency</span><span>></span></span>\n        <span><span><span>&lt;</span>groupId</span><span>></span></span>com.google.guava<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n        <span><span><span>&lt;</span>artifactId</span><span>></span></span>guava<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n        <span><span><span>&lt;</span>version</span><span>></span></span>30.1.1-jre<span><span><span>&lt;/</span>version</span><span>></span></span>\n    <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"三、使用介绍\"> 三、使用介绍</h2>\n<h3 id=\"_3-1-table-双键-map\"> 3.1 Table 双键 Map</h3>\n<p>java中的Map只允许有一个key和一个value存在，但是guava中的Table允许一个value存在两个key。Table中的两个key分别被称为rowKey和columnKey，也就是行和列。</p>\n<div><pre><code><span>Table</span><span><span>&lt;</span><span>String</span><span>,</span><span>String</span><span>,</span><span>Integer</span><span>></span></span> table<span>=</span> <span>HashBasedTable</span><span>.</span><span>create</span><span>(</span><span>)</span><span>;</span>\n<span>//存放元素</span>\ntable<span>.</span><span>put</span><span>(</span><span>\"Hydra\"</span><span>,</span> <span>\"Jan\"</span><span>,</span> <span>20</span><span>)</span><span>;</span>\ntable<span>.</span><span>put</span><span>(</span><span>\"Hydra\"</span><span>,</span> <span>\"Feb\"</span><span>,</span> <span>28</span><span>)</span><span>;</span>\ntable<span>.</span><span>put</span><span>(</span><span>\"Trunks\"</span><span>,</span> <span>\"Jan\"</span><span>,</span> <span>28</span><span>)</span><span>;</span>\ntable<span>.</span><span>put</span><span>(</span><span>\"Trunks\"</span><span>,</span> <span>\"Feb\"</span><span>,</span> <span>16</span><span>)</span><span>;</span>\n<span>//取出元素</span>\n<span>Integer</span> dayCount <span>=</span> table<span>.</span><span>get</span><span>(</span><span>\"Hydra\"</span><span>,</span> <span>\"Feb\"</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id=\"_3-2-bimap-双向map\"> 3.2 BiMap 双向Map</h3>\n<p>在普通Map中，如果要想根据value查找对应的key，没什么简便的办法，无论是使用for循环还是迭代器，都需要遍历整个Map。\n而guava中的BiMap提供了一种key和value双向关联的数据结构。</p>\n<div><div><br><br><br><br><br><br><div>&nbsp;</div><br><br><br></div><pre><code><span>HashBiMap</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> biMap <span>=</span> <span>HashBiMap</span><span>.</span><span>create</span><span>(</span><span>)</span><span>;</span>\nbiMap<span>.</span><span>put</span><span>(</span><span>\"Hydra\"</span><span>,</span><span>\"Programmer\"</span><span>)</span><span>;</span>\nbiMap<span>.</span><span>put</span><span>(</span><span>\"Tony\"</span><span>,</span><span>\"IronMan\"</span><span>)</span><span>;</span>\nbiMap<span>.</span><span>put</span><span>(</span><span>\"Thanos\"</span><span>,</span><span>\"Titan\"</span><span>)</span><span>;</span>\n<span>//使用key获取value</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>biMap<span>.</span><span>get</span><span>(</span><span>\"Tony\"</span><span>)</span><span>)</span><span>;</span>\n<span>BiMap</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> inverse <span>=</span> biMap<span>.</span><span>inverse</span><span>(</span><span>)</span><span>;</span>\n<span>//使用value获取key</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>inverse<span>.</span><span>get</span><span>(</span><span>\"Titan\"</span><span>)</span><span>)</span><span>;</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>注意: 反转后的BiMap并不是一个新的对象，它实现了一种视图的关联，所以对反转后的BiMap执行的所有操作会作用于原先的BiMap上。</p>\n<div><pre><code><span>HashBiMap</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> biMap <span>=</span> <span>HashBiMap</span><span>.</span><span>create</span><span>(</span><span>)</span><span>;</span>\nbiMap<span>.</span><span>put</span><span>(</span><span>\"Hydra\"</span><span>,</span><span>\"Programmer\"</span><span>)</span><span>;</span>\nbiMap<span>.</span><span>put</span><span>(</span><span>\"Tony\"</span><span>,</span><span>\"IronMan\"</span><span>)</span><span>;</span>\nbiMap<span>.</span><span>put</span><span>(</span><span>\"Thanos\"</span><span>,</span><span>\"Titan\"</span><span>)</span><span>;</span>\n<span>BiMap</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> inverse <span>=</span> biMap<span>.</span><span>inverse</span><span>(</span><span>)</span><span>;</span>\ninverse<span>.</span><span>put</span><span>(</span><span>\"IronMan\"</span><span>,</span><span>\"Stark\"</span><span>)</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>biMap<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>对反转后的BiMap中的内容进行了修改后，再看一下原先BiMap中的内容：</p>\n<div><pre><code><span>{</span><span>Hydra</span><span>=</span><span>Programmer</span><span>,</span> <span>Thanos</span><span>=</span><span>Titan</span><span>,</span> <span>Stark</span><span>=</span><span>IronMan</span><span>}</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>可以看到，原先值为IronMan时对应的键是Tony，虽然没有直接修改，但是现在键变成了Stark。</p>\n<h3 id=\"_3-3-multimap-多值map\"> 3.3 Multimap 多值Map</h3>\n<p>java中的Map维护的是键值一对一的关系，如果要将一个键映射到多个值上，那么就只能把值的内容设为集合形式，而在guava中可以使用如下：</p>\n<div><pre><code><span>Multimap</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Integer</span><span>></span></span> multimap <span>=</span> <span>ArrayListMultimap</span><span>.</span><span>create</span><span>(</span><span>)</span><span>;</span>\nmultimap<span>.</span><span>put</span><span>(</span><span>\"day\"</span><span>,</span><span>1</span><span>)</span><span>;</span>\nmultimap<span>.</span><span>put</span><span>(</span><span>\"day\"</span><span>,</span><span>2</span><span>)</span><span>;</span>\nmultimap<span>.</span><span>put</span><span>(</span><span>\"day\"</span><span>,</span><span>8</span><span>)</span><span>;</span>\nmultimap<span>.</span><span>put</span><span>(</span><span>\"month\"</span><span>,</span><span>3</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>打印这个Multimap的内容，可以直观的看到每个key对应的都是一个集合：</p>\n<div><pre><code>{month=[3], day=[1, 2, 8]}\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"_3-4-rangemap-范围map\"> 3.4 RangeMap 范围Map</h3>\n<p>先看一个例子，假设我们要根据分数对考试成绩进行分类，那么代码中就会出现这样丑陋的if-else：</p>\n<div><pre><code><span>public</span> <span>static</span> <span>String</span> <span>getRank</span><span>(</span><span>int</span> score<span>)</span><span>{</span>\n    <span>if</span> <span>(</span><span>0</span><span>&lt;=</span>score <span>&amp;&amp;</span> score<span>&lt;</span><span>60</span><span>)</span>\n        <span>return</span> <span>\"fail\"</span><span>;</span>\n    <span>else</span> <span>if</span> <span>(</span><span>60</span><span>&lt;=</span>score <span>&amp;&amp;</span> score<span>&lt;=</span><span>90</span><span>)</span>\n        <span>return</span> <span>\"satisfactory\"</span><span>;</span>\n    <span>else</span> <span>if</span> <span>(</span><span>90</span><span>&lt;</span>score <span>&amp;&amp;</span> score<span>&lt;=</span><span>100</span><span>)</span>\n        <span>return</span> <span>\"excellent\"</span><span>;</span>\n    <span>return</span> <span>null</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>而guava中的RangeMap描述了一种从区间到特定值的映射关系，让我们能够以更为优雅的方法来书写代码。下面用RangeMap改造上面的代码并进行测试：</p>\n<div><pre><code><span>RangeMap</span><span><span>&lt;</span><span>Integer</span><span>,</span> <span>String</span><span>></span></span> rangeMap <span>=</span> <span>TreeRangeMap</span><span>.</span><span>create</span><span>(</span><span>)</span><span>;</span>\nrangeMap<span>.</span><span>put</span><span>(</span><span>Range</span><span>.</span><span>closedOpen</span><span>(</span><span>0</span><span>,</span><span>60</span><span>)</span><span>,</span><span>\"fail\"</span><span>)</span><span>;</span>\nrangeMap<span>.</span><span>put</span><span>(</span><span>Range</span><span>.</span><span>closed</span><span>(</span><span>60</span><span>,</span><span>90</span><span>)</span><span>,</span><span>\"satisfactory\"</span><span>)</span><span>;</span>\nrangeMap<span>.</span><span>put</span><span>(</span><span>Range</span><span>.</span><span>openClosed</span><span>(</span><span>90</span><span>,</span><span>100</span><span>)</span><span>,</span><span>\"excellent\"</span><span>)</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>rangeMap<span>.</span><span>get</span><span>(</span><span>59</span><span>)</span><span>)</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>rangeMap<span>.</span><span>get</span><span>(</span><span>60</span><span>)</span><span>)</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>rangeMap<span>.</span><span>get</span><span>(</span><span>90</span><span>)</span><span>)</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>rangeMap<span>.</span><span>get</span><span>(</span><span>91</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>在上面的代码中，先后创建了[0,60)的左闭右开区间、[60,90]的闭区间、(90,100]的左开右闭区间，并分别映射到某个值上。运行结果打印：</p>\n<div><pre><code>fail\nsatisfactory\nsatisfactory\nexcellent\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"_3-5-classtoinstancemap-实例map\"> 3.5 ClassToInstanceMap 实例Map</h3>\n<p>ClassToInstanceMap是一个比较特殊的Map，它的键是Class，而值是这个Class对应的实例对象。先看一个简单使用的例子，使用putInstance方法存入对象</p>\n<div><pre><code><span>ClassToInstanceMap</span><span><span>&lt;</span><span>Object</span><span>></span></span> instanceMap <span>=</span> <span>MutableClassToInstanceMap</span><span>.</span><span>create</span><span>(</span><span>)</span><span>;</span>\n<span>User</span> user<span>=</span><span>new</span> <span>User</span><span>(</span><span>\"Hydra\"</span><span>,</span><span>18</span><span>)</span><span>;</span>\n<span>Dept</span> dept<span>=</span><span>new</span> <span>Dept</span><span>(</span><span>\"develop\"</span><span>,</span><span>200</span><span>)</span><span>;</span>\ninstanceMap<span>.</span><span>putInstance</span><span>(</span><span>User</span><span>.</span><span>class</span><span>,</span>user<span>)</span><span>;</span>\ninstanceMap<span>.</span><span>putInstance</span><span>(</span><span>Dept</span><span>.</span><span>class</span><span>,</span>dept<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>那么，使用ClassToInstanceMap这种方式有什么好处呢?</p>\n<p>最明显的就是在取出对象时省去了复杂的强制类型转换，避免了手动进行类型转换的错误。\n所以，如果你想缓存对象，又不想做复杂的类型校验，那么使用方便的ClassToInstanceMap就可以了。</p>\n",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-03-24T14:34:44.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "反射框架Reflections",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/tools/reflections/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/tools/reflections/",
      "content_html": "<p><a href=\"https://github.com/ronmamo/reflections\" target=\"_blank\" rel=\"noopener noreferrer\">Github</a></p>\n<h2 id=\"一、简介\"> 一、简介</h2>\n<p>Reflections通过扫描classpath，索引元数据，并且允许在运行时查询这些元数据。</p>\n<p>使用Reflections可以很轻松的获取以下元数据信息：</p>\n<ul>\n<li><input type=\"checkbox\" checked=\"checked\" disabled=\"disabled\" id=\"task-item-0\"><label for=\"task-item-0\"> 获取某个类型的全部子类</label></li>\n<li><input type=\"checkbox\" checked=\"checked\" disabled=\"disabled\" id=\"task-item-1\"><label for=\"task-item-1\"> 只要类型、构造器、方法，字段上带有特定注解，便能获取带有这个注解的全部信息（类型、构造器、方法，字段）</label></li>\n<li><input type=\"checkbox\" checked=\"checked\" disabled=\"disabled\" id=\"task-item-2\"><label for=\"task-item-2\"> 获取所有能匹配某个正则表达式的资源</label></li>\n<li><input type=\"checkbox\" checked=\"checked\" disabled=\"disabled\" id=\"task-item-3\"><label for=\"task-item-3\"> 获取所有带有特定签名的方法，包括参数，参数注解，返回类型</label></li>\n<li><input type=\"checkbox\" checked=\"checked\" disabled=\"disabled\" id=\"task-item-4\"><label for=\"task-item-4\">  获取所有方法的名字</label></li>\n<li><input type=\"checkbox\" checked=\"checked\" disabled=\"disabled\" id=\"task-item-5\"><label for=\"task-item-5\"> 获取代码里所有字段、方法名、构造器的使用权</label></li>\n</ul>\n<h2 id=\"二、maven依赖\"> 二、Maven依赖</h2>\n<div><pre><code><span><span><span>&lt;</span>dependency</span><span>></span></span>\n    <span><span><span>&lt;</span>groupId</span><span>></span></span>org.reflections<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n    <span><span><span>&lt;</span>artifactId</span><span>></span></span>reflections<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n    <span><span><span>&lt;</span>version</span><span>></span></span>0.9.11<span><span><span>&lt;/</span>version</span><span>></span></span>\n<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"三、使用方法\"> 三、使用方法</h2>\n<h3 id=\"_3-1-实例化\"> 3.1 实例化</h3>\n<p>指定要扫描的包名</p>\n<div><pre><code><span>// 实例化Reflections，并指定要扫描的包名</span>\n<span>Reflections</span> reflections <span>=</span> <span>new</span> <span>Reflections</span><span>(</span><span>\"my.project\"</span><span>)</span><span>;</span>\n<span>// 获取某个类的所有子类</span>\n<span>Set</span><span><span>&lt;</span><span>Class</span><span>&lt;</span><span>?</span> <span>extends</span> <span>SomeType</span><span>></span><span>></span></span> subTypes <span>=</span> reflections<span>.</span><span>getSubTypesOf</span><span>(</span><span>SomeType</span><span>.</span><span>class</span><span>)</span><span>;</span>\n<span>// 获取包含某个注解的所有类</span>\n<span>Set</span><span><span>&lt;</span><span>Class</span><span>&lt;</span><span>?</span><span>></span><span>></span></span> annotated <span>=</span> reflections<span>.</span><span>getTypesAnnotatedWith</span><span>(</span><span>SomeAnnotation</span><span>.</span><span>class</span><span>)</span><span>;</span>\n  \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>指定要扫描的包名并添加过滤器</p>\n<p><a href=\"https://ronmamo.github.io/reflections/org/reflections/util/ConfigurationBuilder.html\" target=\"_blank\" rel=\"noopener noreferrer\">ConfigurationBuilder API</a></p>\n<div><pre><code><span>Reflections</span> reflections <span>=</span> <span>new</span> <span>Reflections</span><span>(</span>\n  <span>new</span> <span>ConfigurationBuilder</span><span>(</span><span>)</span>\n    <span>.</span><span>forPackage</span><span>(</span><span>\"com.my.project\"</span><span>)</span>\n    <span>.</span><span>filterInputsBy</span><span>(</span><span>new</span> <span>FilterBuilder</span><span>(</span><span>)</span><span>.</span><span>includePackage</span><span>(</span><span>\"com.my.project\"</span><span>)</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>添加扫描器</p>\n<p><a href=\"https://ronmamo.github.io/reflections/org/reflections/scanners/Scanners.html\" target=\"_blank\" rel=\"noopener noreferrer\">Scanners API</a></p>\n<div><pre><code><span>// scan package with specific scanners</span>\n<span>Reflections</span> reflections <span>=</span> <span>new</span> <span>Reflections</span><span>(</span>\n  <span>new</span> <span>ConfigurationBuilder</span><span>(</span><span>)</span>\n    <span>.</span><span>forPackage</span><span>(</span><span>\"com.my.project\"</span><span>)</span>\n    <span>.</span><span>filterInputsBy</span><span>(</span><span>new</span> <span>FilterBuilder</span><span>(</span><span>)</span><span>.</span><span>includePackage</span><span>(</span><span>\"com.my.project\"</span><span>)</span><span>.</span><span>excludePackage</span><span>(</span><span>\"com.my.project.exclude\"</span><span>)</span><span>)</span>\n    <span>.</span><span>setScanners</span><span>(</span><span>TypesAnnotated</span><span>,</span> <span>MethodsAnnotated</span><span>,</span> <span>MethodsReturn</span><span>)</span><span>)</span><span>;</span>\n\n<span>// scan package with all standard scanners</span>\n<span>Reflections</span> reflections <span>=</span> <span>new</span> <span>Reflections</span><span>(</span><span>\"com.my.project\"</span><span>,</span> <span>Scanners</span><span>.</span><span>values</span><span>(</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"_3-2-扫描子类\"> 3.2 扫描子类</h3>\n<div><pre><code><span>Set</span><span><span>&lt;</span><span>Class</span><span>&lt;</span><span>?</span> <span>extends</span> <span>Module</span><span>></span><span>></span></span> modules <span>=</span> \n    reflections<span>.</span><span>getSubTypesOf</span><span>(</span><span><span>com<span>.</span>google<span>.</span>inject<span>.</span></span>Module</span><span>.</span><span>class</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"_3-3-扫描注解\"> 3.3 扫描注解</h3>\n<div><pre><code><span>//TypeAnnotationsScanner </span>\n<span>Set</span><span><span>&lt;</span><span>Class</span><span>&lt;</span><span>?</span><span>></span><span>></span></span> singletons <span>=</span> \n    reflections<span>.</span><span>getTypesAnnotatedWith</span><span>(</span><span><span>javax<span>.</span>inject<span>.</span></span>Singleton</span><span>.</span><span>class</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"_3-4-扫描资源\"> 3.4 扫描资源</h3>\n<div><pre><code><span>//ResourcesScanner</span>\n<span>Set</span><span><span>&lt;</span><span>String</span><span>></span></span> properties <span>=</span> \n    reflections<span>.</span><span>getResources</span><span>(</span><span>Pattern</span><span>.</span><span>compile</span><span>(</span><span>\".*\\\\.properties\"</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"_3-5-扫描方法、构造注解\"> 3.5 扫描方法、构造注解</h3>\n<div><pre><code><span>//MethodAnnotationsScanner</span>\n<span>Set</span><span><span>&lt;</span><span>Method</span><span>></span></span> resources <span>=</span>\n    reflections<span>.</span><span>getMethodsAnnotatedWith</span><span>(</span><span><span>javax<span>.</span>ws<span>.</span>rs<span>.</span></span>Path</span><span>.</span><span>class</span><span>)</span><span>;</span>\n<span>Set</span><span><span>&lt;</span><span>Constructor</span><span>></span></span> injectables <span>=</span> \n    reflections<span>.</span><span>getConstructorsAnnotatedWith</span><span>(</span><span><span>javax<span>.</span>inject<span>.</span></span>Inject</span><span>.</span><span>class</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"_3-6-扫描字段注解\"> 3.6 扫描字段注解</h3>\n<div><pre><code><span>Set</span><span><span>&lt;</span><span>Field</span><span>></span></span> ids <span>=</span> \n    reflections<span>.</span><span>getFieldsAnnotatedWith</span><span>(</span><span><span>javax<span>.</span>persistence<span>.</span></span>Id</span><span>.</span><span>class</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"_3-7-扫描方法参数\"> 3.7 扫描方法参数</h3>\n<div><pre><code><span>//MethodParameterScanner</span>\n<span>Set</span><span><span>&lt;</span><span>Method</span><span>></span></span> someMethods <span>=</span>\n    reflections<span>.</span><span>getMethodsMatchParams</span><span>(</span><span>long</span><span>.</span><span>class</span><span>,</span> <span>int</span><span>.</span><span>class</span><span>)</span><span>;</span>\n<span>Set</span><span><span>&lt;</span><span>Method</span><span>></span></span> voidMethods <span>=</span>\n    reflections<span>.</span><span>getMethodsReturn</span><span>(</span><span>void</span><span>.</span><span>class</span><span>)</span><span>;</span>\n<span>Set</span><span><span>&lt;</span><span>Method</span><span>></span></span> pathParamMethods <span>=</span>\n    reflections<span>.</span><span>getMethodsWithAnyParamAnnotated</span><span>(</span><span>PathParam</span><span>.</span><span>class</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id=\"_3-8-扫描方法参数名\"> 3.8 扫描方法参数名</h3>\n<div><pre><code><span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> parameterNames <span>=</span> \n    reflections<span>.</span><span>getMethodParamNames</span><span>(</span><span>Method</span><span>.</span><span>class</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"_3-9-扫描方法调用情况\"> 3.9 扫描方法调用情况</h3>\n<div><pre><code><span>//MemberUsageScanner</span>\n<span>Set</span><span><span>&lt;</span><span>Member</span><span>></span></span> usages <span>=</span> \n    reflections<span>.</span><span>getMethodUsages</span><span>(</span><span>Method</span><span>.</span><span>class</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div>",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-03-24T14:34:44.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Guava-retry重试组件",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/tools/guava/guava-retry/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/tools/guava/guava-retry/",
      "content_html": "<h2 id=\"一、简介\"> 一、简介</h2>\n<div><p>Guava-retry</p>\n<p>Guava 是一组来自 Google 的核心 Java 库，其中包括新的集合类型（例如 multimap 和 multiset）、不可变集合、图形库以及用于并发、I/O、散列、缓存、原语、字符串等的实用程序！它广泛用于 Google\n内部的大多数 Java 项目，也被许多其他公司广泛使用。</p>\n<p>API 非常的简单，我们可以非常轻松的使用，来封装成我们业务中自己的组件。</p>\n</div>\n<h2 id=\"二、依赖\"> 二、依赖</h2>\n<div><pre><code>    <span><span><span>&lt;</span>dependency</span><span>></span></span>\n        <span><span><span>&lt;</span>groupId</span><span>></span></span>com.github.rholder<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n        <span><span><span>&lt;</span>artifactId</span><span>></span></span>guava-retrying<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n        <span><span><span>&lt;</span>version</span><span>></span></span>2.0.0<span><span><span>&lt;/</span>version</span><span>></span></span>\n    <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"三、使用\"> 三、使用</h2>\n<h3 id=\"_3-1-指定异常\"> 3.1 指定异常</h3>\n<p>配置如果发生了 <code>Exception</code> 异常进行重试</p>\n<div><div><br><br><div>&nbsp;</div><br><br><br><br><br></div><pre><code>    <span>Retryer</span><span><span>&lt;</span><span>User</span><span>></span></span> retry <span>=</span> <span>RetryerBuilder</span><span>.</span><span><span>&lt;</span><span>User</span><span>></span></span><span>newBuilder</span><span>(</span><span>)</span>\n                <span>//发生ConnectException异常时重试</span>\n                <span>.</span><span>retryIfExceptionOfType</span><span>(</span><span>Exception</span><span>.</span><span>class</span><span>)</span>\n                <span>//重试的等待策略 初始等待1s，每次递增1s。如：第一次1s，第二次2s，第三次3s，以此类推...</span>\n                <span>.</span><span>withWaitStrategy</span><span>(</span><span>WaitStrategies</span><span>.</span><span>incrementingWait</span><span>(</span><span>1</span><span>,</span> <span>TimeUnit</span><span>.</span>SECONDS<span>,</span> <span>1</span><span>,</span> <span>TimeUnit</span><span>.</span>SECONDS<span>)</span><span>)</span>\n                <span>//重试3次后停止</span>\n                <span>.</span><span>withStopStrategy</span><span>(</span><span>StopStrategies</span><span>.</span><span>stopAfterAttempt</span><span>(</span><span>3</span><span>)</span><span>)</span><span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id=\"_3-2-重试策略\"> 3.2 重试策略</h3>\n<p>WaitStrategy 重试策略</p>\n<div><div><br><br><br><br><div>&nbsp;</div><br><br><br></div><pre><code>    <span>Retryer</span><span><span>&lt;</span><span>User</span><span>></span></span> retry <span>=</span> <span>RetryerBuilder</span><span>.</span><span><span>&lt;</span><span>User</span><span>></span></span><span>newBuilder</span><span>(</span><span>)</span>\n                <span>//发生ConnectException异常时重试</span>\n                <span>.</span><span>retryIfExceptionOfType</span><span>(</span><span>Exception</span><span>.</span><span>class</span><span>)</span>\n                <span>//重试的等待策略 初始等待1s，每次递增1s。如：第一次1s，第二次2s，第三次3s，以此类推...</span>\n                <span>.</span><span>withWaitStrategy</span><span>(</span><span>WaitStrategies</span><span>.</span><span>incrementingWait</span><span>(</span><span>1</span><span>,</span> <span>TimeUnit</span><span>.</span>SECONDS<span>,</span> <span>1</span><span>,</span> <span>TimeUnit</span><span>.</span>SECONDS<span>)</span><span>)</span>\n                <span>//重试3次后停止</span>\n                <span>.</span><span>withStopStrategy</span><span>(</span><span>StopStrategies</span><span>.</span><span>stopAfterAttempt</span><span>(</span><span>3</span><span>)</span><span>)</span><span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><table>\n<thead>\n<tr>\n<th>策略</th>\n<th>使用方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>固定策略</td>\n<td>WaitStrategies.fixedWait(10,TimeUnit.SECONDS)</td>\n<td>每10秒执行一次</td>\n</tr>\n<tr>\n<td>随机策略</td>\n<td>WaitStrategies.randomWait(100,TimeUnit.SECONDS)</td>\n<td>0 到 100秒之间随机执行一次</td>\n</tr>\n<tr>\n<td>随机策略</td>\n<td>WaitStrategies.randomWait(10,TimeUnit.SECONDS,20,TimeUnit.SECONDS)</td>\n<td>10 到 20秒之间随机执行一次</td>\n</tr>\n<tr>\n<td>递增策略</td>\n<td>WaitStrategies.incrementingWait(1, TimeUnit.SECONDS, 1, TimeUnit.SECONDS)</td>\n<td>初始等待1s，每次递增1s。如：第一次1s，第二次2s，第三次3s，以此类推...</td>\n</tr>\n<tr>\n<td>异常策略</td>\n<td>WaitStrategies.exceptionWait(...)</td>\n<td>不同的异常返回不同的重试时间</td>\n</tr>\n<tr>\n<td>斐波那契数列策略</td>\n<td>WaitStrategies.fibonacciWait(...)</td>\n<td>1、1、2、3、5、8、13、21类推</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_3-3-重试监听器\"> 3.3 重试监听器</h3>\n<p>Attempt 代表每次执行动作，可以获取执行次数，打印执行日志</p>\n<div><div><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br></div><pre><code> <span>Retryer</span><span><span>&lt;</span><span>User</span><span>></span></span> retry <span>=</span> <span>RetryerBuilder</span><span>.</span><span><span>&lt;</span><span>User</span><span>></span></span><span>newBuilder</span><span>(</span><span>)</span>\n                <span>//发生ConnectException异常时重试</span>\n                <span>.</span><span>retryIfExceptionOfType</span><span>(</span><span>Exception</span><span>.</span><span>class</span><span>)</span>\n                <span>//重试的等待策略 初始等待1s，每次递增1s。如：第一次1s，第二次2s，第三次3s，以此类推...</span>\n                <span>.</span><span>withWaitStrategy</span><span>(</span><span>WaitStrategies</span><span>.</span><span>incrementingWait</span><span>(</span><span>1</span><span>,</span> <span>TimeUnit</span><span>.</span>SECONDS<span>,</span> <span>1</span><span>,</span> <span>TimeUnit</span><span>.</span>SECONDS<span>)</span><span>)</span>\n                <span>//重试监听器</span>\n                <span>.</span><span>withRetryListener</span><span>(</span><span>new</span> <span>RetryListener</span><span>(</span><span>)</span> <span>{</span>\n                    <span>@Override</span>\n                    <span>public</span> <span><span>&lt;</span><span>V</span><span>></span></span> <span>void</span> <span>onRetry</span><span>(</span><span>Attempt</span><span><span>&lt;</span><span>V</span><span>></span></span> attempt<span>)</span> <span>{</span>\n                        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"重试次数:\"</span> <span>+</span> attempt<span>.</span><span>getAttemptNumber</span><span>(</span><span>)</span><span>)</span><span>;</span>\n                        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"异常:\"</span> <span>+</span> attempt<span>.</span><span>getExceptionCause</span><span>(</span><span>)</span><span>)</span><span>;</span>\n                        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"返回值:\"</span><span>+</span>attempt<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span><span>;</span>\n                    <span>}</span>\n                <span>}</span><span>)</span>\n                <span>//重试3次后停止</span>\n                <span>.</span><span>withStopStrategy</span><span>(</span><span>StopStrategies</span><span>.</span><span>stopAfterAttempt</span><span>(</span><span>10</span><span>)</span><span>)</span><span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id=\"_3-4-停止策略\"> 3.4 停止策略</h3>\n<p>StopStrategy 一般常用的就是重试多少次</p>\n<div><div><br><br><br><br><br><br><div>&nbsp;</div><br></div><pre><code> <span>Retryer</span><span><span>&lt;</span><span>User</span><span>></span></span> retry <span>=</span> <span>RetryerBuilder</span><span>.</span><span><span>&lt;</span><span>User</span><span>></span></span><span>newBuilder</span><span>(</span><span>)</span>\n                <span>//发生ConnectException异常时重试</span>\n                <span>.</span><span>retryIfExceptionOfType</span><span>(</span><span>Exception</span><span>.</span><span>class</span><span>)</span>\n                <span>//重试的等待策略 初始等待1s，每次递增1s。如：第一次1s，第二次2s，第三次3s，以此类推...</span>\n                <span>.</span><span>withWaitStrategy</span><span>(</span><span>WaitStrategies</span><span>.</span><span>incrementingWait</span><span>(</span><span>1</span><span>,</span> <span>TimeUnit</span><span>.</span>SECONDS<span>,</span> <span>1</span><span>,</span> <span>TimeUnit</span><span>.</span>SECONDS<span>)</span><span>)</span>\n                <span>//重试3次后停止</span>\n                <span>.</span><span>withStopStrategy</span><span>(</span><span>StopStrategies</span><span>.</span><span>stopAfterAttempt</span><span>(</span><span>10</span><span>)</span><span>)</span><span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><ul>\n<li>StopAfterDelayStrategy ：设定一个最长允许的执行时间；比如设定最长执行10s，无论任务执行次数，只要重试的时候超出了最长时间，则任务终止，并返回重试异常RetryException；</li>\n<li>NeverStopStrategy ：不停止，用于需要一直轮训直到返回期望结果的情况；</li>\n<li>StopAfterAttemptStrategy ：设定最大重试次数，如果超出最大重试次数则停止重试，并返回重试异常；</li>\n</ul>\n",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-03-24T14:34:44.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Spring-retry重试组件",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/tools/guava/spring-retry/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/tools/guava/spring-retry/",
      "content_html": "<h2 id=\"一、简介\"> 一、简介</h2>\n<div><p>Spring-retry</p>\n<p>前面我们了解到了,Guava的重试组件,我们可以基于Guava的能力,来封装我们需要的能力来满足我们的业务。今天来分享Spring-Retry重试组件。当然Spring只是帮我们封装好了，如果你不想自定义\n重试组件，那么我们可以直接使用Spring的能力来实现。</p>\n<p>API 也是非常的简单，几个注解就可以搞定。</p>\n</div>\n<p><a href=\"https://github.com/lxchinesszz/spring-retry-example\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://img.shields.io/badge/仓库-spring--retry--example-green\" alt=\"\" loading=\"lazy\"></a></p>\n<h2 id=\"二、依赖\"> 二、依赖</h2>\n<div><pre><code>    <span>&lt;!--springboot项目都不用引入版本号--></span>\n    <span><span><span>&lt;</span>dependency</span><span>></span></span>\n      <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.retry<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n      <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-retry<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n    <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n    <span>&lt;!--还是需要aop的支持的(如果已经引入了aop就不用再添加这个依赖了)--></span>\n    <span><span><span>&lt;</span>dependency</span><span>></span></span>\n      <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n      <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-aspects<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n    <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id=\"三、使用\"> 三、使用</h2>\n<h3 id=\"_3-1-enableretry-开启重试\"> 3.1 @EnableRetry 开启重试</h3>\n<p>SpringBoot启动类上添加开启重试注解</p>\n<div><pre><code>    <span>@EnableRetry</span>\n    <span>@SpringBootApplication</span>\n    <span>public</span> <span>class</span> <span>Application</span> <span>{</span>\n        <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n            <span>ConfigurableApplicationContext</span> applicationContext <span>=</span> <span>SpringApplication</span><span>.</span><span>run</span><span>(</span><span>Application</span><span>.</span><span>class</span><span>,</span> args<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id=\"_3-2-retryable-重试策略\"> 3.2 @Retryable 重试策略</h3>\n<p>在需要重试的方法上加注解@Retryable</p>\n<div><pre><code>    <span>@Retryable</span><span>(</span>value <span>=</span> <span>RuntimeException</span><span>.</span><span>class</span><span>,</span> maxAttempts <span>=</span> <span>5</span><span>,</span> backoff <span>=</span> <span>@Backoff</span><span>(</span>delay <span>=</span> <span>100</span><span>)</span><span>)</span>\n    <span>public</span> <span>String</span> <span>say</span><span>(</span><span>String</span> param<span>)</span> <span>{</span>\n        <span>double</span> random <span>=</span> <span>Math</span><span>.</span><span>random</span><span>(</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span>random <span>></span> <span>0.1</span><span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>RuntimeException</span><span>(</span><span>\"超时\"</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> random <span>+</span> <span>\"\"</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><ul>\n<li><input type=\"checkbox\" checked=\"checked\" disabled=\"disabled\" id=\"task-item-0\"><label for=\"task-item-0\"> value = RuntimeException.class：是指方法抛出RuntimeException异常时，进行重试。这里可以指定你想要拦截的异常。</label></li>\n<li><input type=\"checkbox\" checked=\"checked\" disabled=\"disabled\" id=\"task-item-1\"><label for=\"task-item-1\"> maxAttempts：是最大重试次数。如果不写，则是默认3次。</label></li>\n<li><input type=\"checkbox\" checked=\"checked\" disabled=\"disabled\" id=\"task-item-2\"><label for=\"task-item-2\"> backoff = @Backoff(delay = 100)：是指重试间隔。delay=100意味着下一次的重试，要等100毫秒之后才能执行。</label></li>\n</ul>\n<h3 id=\"_3-3-recover-重试失败\"> 3.3 @Recover 重试失败</h3>\n<p>当@Retryable方法重试失败之后，最后就会调用@Recover方法。用于@Retryable失败时的“兜底”处理方法。 @Recover的方法必须要与@Retryable注解的方法保持一致，第一入参为要重试的异常，其他参数与@Retryable保持一致，返回值也要一样，否则无法执行！</p>\n<div><pre><code>    <span>@Retryable</span><span>(</span>value <span>=</span> <span>IllegalAccessException</span><span>.</span><span>class</span><span>)</span>\n    <span>public</span> <span>void</span> <span>say</span><span>(</span><span>)</span> <span>throws</span> <span>IllegalAccessException</span> <span>{</span>\n        log<span>.</span><span>info</span><span>(</span><span>\"do something... {}\"</span><span>,</span> <span>LocalDateTime</span><span>.</span><span>now</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>throw</span> <span>new</span> <span>IllegalAccessException</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n\n    <span>@Recover</span>\n    <span>public</span> <span>void</span> <span>sayBackup</span><span>(</span><span>IllegalAccessException</span> e<span>)</span> <span>{</span>\n        log<span>.</span><span>info</span><span>(</span><span>\"service retry after Recover => {}\"</span><span>,</span> e<span>.</span><span>getMessage</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id=\"_3-4-circuitbreaker-熔断策略\"> 3.4 @CircuitBreaker 熔断策略</h3>\n<p>规定时间内如果重试次数达到了最大次数,开启熔断策略。\n5秒内,这个方法重试了2次,就会断路。直接走@Recover修饰的方法。当超过10s后进行重置,继续走get方法。</p>\n<p>注意@Retryable和@CircuitBreaker不要修饰同一个方法。</p>\n<div><pre><code>    <span>@CircuitBreaker</span><span>(</span>openTimeout <span>=</span> <span>5000</span><span>,</span> maxAttempts <span>=</span> <span>2</span><span>,</span>resetTimeout <span>=</span> <span>10000</span><span>)</span>\n    <span>public</span> <span>String</span> <span>get</span><span>(</span><span>@PathVariable</span> <span>Integer</span> flag<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>flag <span>></span> <span>1</span><span>)</span> <span>{</span>\n            log<span>.</span><span>info</span><span>(</span><span>\"重试进入\"</span><span>)</span><span>;</span>\n            <span>throw</span> <span>new</span> <span>RuntimeException</span><span>(</span><span>\"自定义异常\"</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> <span>\"处理正常\"</span><span>;</span>\n    <span>}</span>\n    <span>@Recover</span>\n    <span>public</span> <span>String</span> <span>getBackup</span><span>(</span><span>RuntimeException</span> runtimeException<span>)</span> <span>{</span>\n        log<span>.</span><span>error</span><span>(</span><span>\"重试一直失败,进入备用方法:\"</span> <span>+</span> runtimeException<span>.</span><span>getMessage</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>return</span> <span>\"备用方法进去\"</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">属性</th>\n<th style=\"text-align:left\">意思</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">include</td>\n<td style=\"text-align:left\">指定处理的异常类。默认为空</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">exclude</td>\n<td style=\"text-align:left\">指定不需要处理的异常。默认为空</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">value</td>\n<td style=\"text-align:left\">指定要重试的异常。默认为空</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">maxAttempts</td>\n<td style=\"text-align:left\">最大重试次数。默认3次</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">openTimeout</td>\n<td style=\"text-align:left\">配置熔断器打开的超时时间，默认5s，当超过openTimeout之后熔断器电路变成半打开状态（只要有一次重试成功，则闭合电路）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">resetTimeout</td>\n<td style=\"text-align:left\">配置熔断器重新闭合的超时时间，默认20s，超过这个时间断路器关闭</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">include</td>\n<td style=\"text-align:left\">指定处理的异常类。默认为空</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_3-5-retrylistener-监听器\"> 3.5 RetryListener 监听器</h3>\n<p>spring-retry和guava-retry一样同样有监听器。我们可以自定义我们的监听器</p>\n<div><pre><code><span>@Slf4j</span>\n<span>public</span> <span>class</span> <span>DefaultListenerSupport</span> <span>extends</span> <span>RetryListenerSupport</span> <span>{</span>\n    <span>@Override</span>\n    <span>public</span> <span><span>&lt;</span><span>T</span><span>,</span> <span>E</span> <span>extends</span> <span>Throwable</span><span>></span></span> <span>void</span> <span>close</span><span>(</span><span>RetryContext</span> context<span>,</span>\n                                               <span>RetryCallback</span><span><span>&lt;</span><span>T</span><span>,</span> <span>E</span><span>></span></span> callback<span>,</span> <span>Throwable</span> throwable<span>)</span> <span>{</span>\n        log<span>.</span><span>info</span><span>(</span><span>\"onClose\"</span><span>)</span><span>;</span>\n        <span>super</span><span>.</span><span>close</span><span>(</span>context<span>,</span> callback<span>,</span> throwable<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span><span>&lt;</span><span>T</span><span>,</span> <span>E</span> <span>extends</span> <span>Throwable</span><span>></span></span> <span>void</span> <span>onError</span><span>(</span><span>RetryContext</span> context<span>,</span>\n                                                 <span>RetryCallback</span><span><span>&lt;</span><span>T</span><span>,</span> <span>E</span><span>></span></span> callback<span>,</span> <span>Throwable</span> throwable<span>)</span> <span>{</span>\n        log<span>.</span><span>info</span><span>(</span><span>\"onError\"</span><span>)</span><span>;</span>\n        <span>super</span><span>.</span><span>onError</span><span>(</span>context<span>,</span> callback<span>,</span> throwable<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span><span>&lt;</span><span>T</span><span>,</span> <span>E</span> <span>extends</span> <span>Throwable</span><span>></span></span> <span>boolean</span> <span>open</span><span>(</span><span>RetryContext</span> context<span>,</span>\n                                                 <span>RetryCallback</span><span><span>&lt;</span><span>T</span><span>,</span> <span>E</span><span>></span></span> callback<span>)</span> <span>{</span>\n        log<span>.</span><span>info</span><span>(</span><span>\"onOpen\"</span><span>)</span><span>;</span>\n        <span>return</span> <span>super</span><span>.</span><span>open</span><span>(</span>context<span>,</span> callback<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>@Configuration</span>\n<span>public</span> <span>class</span> <span>RetryConfig</span> <span>{</span>\n\n    <span>@Bean</span>\n    <span>public</span> <span>RetryTemplate</span> <span>retryTemplate</span><span>(</span><span>)</span> <span>{</span>\n        <span>RetryTemplate</span> retryTemplate <span>=</span> <span>new</span> <span>RetryTemplate</span><span>(</span><span>)</span><span>;</span>\n        <span>SimpleRetryPolicy</span> retryPolicy <span>=</span> <span>new</span> <span>SimpleRetryPolicy</span><span>(</span><span>)</span><span>;</span> <span>//设置重试策略</span>\n        retryPolicy<span>.</span><span>setMaxAttempts</span><span>(</span><span>2</span><span>)</span><span>;</span>\n        retryTemplate<span>.</span><span>setRetryPolicy</span><span>(</span>retryPolicy<span>)</span><span>;</span>\n\n        <span>FixedBackOffPolicy</span> fixedBackOffPolicy <span>=</span> <span>new</span> <span>FixedBackOffPolicy</span><span>(</span><span>)</span><span>;</span> <span>//设置退避策略</span>\n        fixedBackOffPolicy<span>.</span><span>setBackOffPeriod</span><span>(</span><span>2000L</span><span>)</span><span>;</span>\n        retryTemplate<span>.</span><span>setBackOffPolicy</span><span>(</span>fixedBackOffPolicy<span>)</span><span>;</span>\n        \n        retryTemplate<span>.</span><span>registerListener</span><span>(</span><span>new</span> <span>DefaultListenerSupport</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>//设置retryListener</span>\n        <span>return</span> retryTemplate<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><h3 id=\"_3-6-retrypolicy-重试策略\"> 3.6 RetryPolicy 重试策略</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">属性</th>\n<th style=\"text-align:left\">意思</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">NeverRetryPolicy</td>\n<td style=\"text-align:left\">只允许调用RetryCallback一次，不允许重试；</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">AlwaysRetryPolicy</td>\n<td style=\"text-align:left\">允许无限重试，直到成功，此方式逻辑不当会导致死循环；</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">SimpleRetryPolicy</td>\n<td style=\"text-align:left\">固定次数重试策略，默认重试最大次数为3次，RetryTemplate默认使用的策略；</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">TimeoutRetryPolicy</td>\n<td style=\"text-align:left\">超时时间重试策略，默认超时时间为1秒，在指定的超时时间内允许重试；</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CircuitBreakerRetryPolicy</td>\n<td style=\"text-align:left\">有熔断功能的重试策略，需设置3个参数openTimeout、resetTimeout和delegate</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CompositeRetryPolicy</td>\n<td style=\"text-align:left\">组合重试策略，有两种组合方式，乐观组合重试策略是指只要有一个策略允许重试即可以，悲观组合重试策略是指只要有一个策略不允许重试即可以，但不管哪种组合方式，组合中的每一个策略都会执行。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_3-7-backoffpolicy-退避策略\"> 3.7 BackOffPolicy 退避策略</h3>\n<p>下一次重试的策略。\n退避是指怎么去做下一次的重试，在这里其实就是等待多长时间。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">属性</th>\n<th style=\"text-align:left\">意思</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">FixedBackOffPolicy</td>\n<td style=\"text-align:left\">默认固定延迟1秒后执行下一次重试</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ExponentialBackOffPolicy</td>\n<td style=\"text-align:left\">指数递增延迟执行重试，默认初始0.1秒，系数是2，那么下次延迟0.2秒，再下次就是延迟0.4秒，如此类推，最大30秒。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ExponentialRandomBackOffPolicy</td>\n<td style=\"text-align:left\">在上面那个策略上增加随机性</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">UniformRandomBackOffPolicy</td>\n<td style=\"text-align:left\">这个跟上面的区别就是，上面的延迟会不停递增，这个只会在固定的区间随机</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">StatelessBackOffPolicy</td>\n<td style=\"text-align:left\">这个说明是无状态的，所谓无状态就是对上次的退避无感知，从它下面的子类也能看出来</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"四、总结\"> 四、总结</h2>\n<p>天下代码一大抄，看你会抄不会抄。发现无论是guava还是spring的重试，基本都是类似的思路。只是看谁的功能比较鉴权而已。\nguava提供了基础的能力，你任意封装。\nspring基于spring提供了已经完好的能力，直接使用就好。不过因为是spring给你封装的能力，所以你要先了解清楚才行。不然可能使用错误，造成故障。</p>\n<p>以上两款工具都挺好，不过他们都不支持分布式重试的能力。不过这已经满足我们的日常开发了，如果真遇到分布式的重试，就自己来实现咯。</p>\n",
      "image": "https://img.shields.io/badge/%E4%BB%93%E5%BA%93-spring--retry--example-green",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-03-24T14:34:44.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "重剑无锋大巧不工",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/learn/%E7%BD%91%E7%AB%99%E5%9C%B0%E5%9B%BE/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/learn/%E7%BD%91%E7%AB%99%E5%9C%B0%E5%9B%BE/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/learn_1648126927000.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1648126927000.png",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-03-24T14:34:44.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Home",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/play/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/play/",
      "content_html": "<h3 id=\"badge\"> Badge</h3>\n<ul>\n<li>\n<i>Not supported content</i>\n</li>\n<li>\n<i>Not supported content</i>\n</li>\n</ul>\n<CodeGroup>\n<CodeGroupItem title=\"yarn\">\n<div><pre><code><span>yarn</span> <span>add</span> -D vuepress-theme-hope\n</code></pre>\n<div><span>1</span><br></div></div></CodeGroupItem>\n<CodeGroupItem title=\"npm\" active>\n<div><pre><code><span>npm</span> i -D vuepress-theme-hope\n</code></pre>\n<div><span>1</span><br></div></div></CodeGroupItem>\n</CodeGroup>\n<div><div><br><div>&nbsp;</div><br><br><br><br><br></div><pre><code><span>public</span> <span>class</span> <span>Person</span><span>{</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span>args<span>)</span><span>{</span>\n\n    <span>}</span>\n<span>}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div>",
      "date_published": "2021-12-21T05:46:37.000Z",
      "date_modified": "2022-01-04T14:58:20.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Home",
      "url": "https://vuepress-theme-hope-demo.mrhope.site/",
      "id": "https://vuepress-theme-hope-demo.mrhope.site/",
      "content_html": "<div><p>相关信息</p>\n<p>想要逼死一个强迫症，那实在是太简了。</p>\n</div>\n",
      "date_published": "2021-12-21T05:46:37.000Z",
      "date_modified": "2022-03-24T14:34:44.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    }
  ]
}