{
  "version": "https://jsonfeed.org/version/1.1",
  "title": "西魏陶渊明",
  "home_page_url": "https://java.springlearn.cn/",
  "feed_url": "https://java.springlearn.cn/feed.json",
  "description": "桃花潭水深千尺",
  "author": {
    "name": "西魏陶渊明"
  },
  "items": [
    {
      "title": "Hexo",
      "url": "https://java.springlearn.cn/learn/blog/hexo/",
      "id": "https://java.springlearn.cn/learn/blog/hexo/",
      "content_html": "<div><p>相关信息</p>\n<p>Hexo的风格个人感觉类似于QQ空间,属于自己的私人领地。文章比较琐碎,不太适合专题类、系列类的文档,其次是对Markdown的支持比较一般,\n部分主体支持代码高亮等功能。\n好处是简单,小编的第一个博客空间就是基于Hexo。目前也在维护中。</p>\n</div>\n<p><a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<h2 id=\"一、hexo\"> 一、<a href=\"https://hexo.io/zh-cn/\" target=\"_blank\" rel=\"noopener noreferrer\">Hexo</a></h2>\n<p><a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://img.shields.io/badge/Hexo-示例-green\" alt=\"\" loading=\"lazy\"></a></p>\n<p><code>Hexo</code> 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>\n<h2 id=\"二、安装\"> 二、安装</h2>\n<h3 id=\"_2-1-安装前提\"> 2.1 安装前提</h3>\n<p>安装 Hexo 相当简单，只需要先安装下列应用程序即可：</p>\n<ul>\n<li>Node.js (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)</li>\n<li>Git</li>\n<li>npm</li>\n</ul>\n<h3 id=\"_2-2-安装\"> 2.2 安装</h3>\n<p>首先利用 <code>npm</code> 下载</p>\n<div><pre><code><span>npm</span> <span>install</span> -g hexo-cli<span>;</span>\n\nmdkir myblog<span>;</span>\n\n<span>cd</span> myblog<span>;</span>\n\nhexo init<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id=\"三、使用\"> 三、使用</h2>\n<p><code>hexo</code> 的命令非常简单，小编用了很多年，基本上只有2个。你知道是哪两个吗?</p>\n<h3 id=\"_3-1-new-新建文章\"> 3.1 new 新建文章</h3>\n<p><code>$ hexo new [layout] &lt;title&gt;</code></p>\n<ul>\n<li>layout 是博客布局，基本不会用</li>\n<li>title 就是博客的名字</li>\n</ul>\n<h3 id=\"_3-2-generate-文章编译\"> 3.2 generate 文章编译</h3>\n<p>生成静态文件。</p>\n<p><code>$ hexo generate</code></p>\n<p>该命令可以简写为：</p>\n<p><code>$ hexo g</code></p>\n<h3 id=\"_3-3-server-本地运行\"> 3.3 server 本地运行</h3>\n<p>启动服务器,本地运行</p>\n<p><code>$ hexo server</code></p>\n<h3 id=\"_3-4-deploy-远程部署\"> 3.4 deploy 远程部署</h3>\n<p>部署远程</p>\n<p><code>$ hexo deploy</code></p>\n<p>该命令可以简写为：</p>\n<p><code>$ hexo d</code></p>\n<h3 id=\"_3-5-clean-清理缓存\"> 3.5 clean 清理缓存</h3>\n<p><code>$ hexo clean</code></p>\n<p>清除缓存文件 (db.json) 和已生成的静态文件 (public)。</p>\n<p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p>\n<h3 id=\"_3-6-version\"> 3.6 version</h3>\n<p><code>$ hexo version</code></p>\n<p>显示 Hexo 版本。</p>\n<h2 id=\"四、部署\"> 四、部署</h2>\n<p><code>hexo</code> 的配置文件都在根目录下的 <code>_config.yml</code> 文件下。如果要部署远程，非常简单。</p>\n<div><pre><code><span>deploy</span><span>:</span>\n    <span>type</span><span>:</span> git\n    <span>repo</span><span>:</span>\n<span>#      可以使用github    </span>\n<span>#      github: https://github.com/lxchinesszz/lxchinesszz.github.io.git</span>\n      <span>coding</span><span>:</span> https<span>:</span>//e.coding.net/lxchinesszz/lxchinesszz.git\n    <span>branch</span><span>:</span> master\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><ul>\n<li>\n<ol>\n<li>这里需要注意，如果使用github部署, 仓库的名字是有讲究的。名字要跟github的账户名前缀一直。\n<code>lxchinesszz.github.io</code></li>\n</ol>\n</li>\n<li>\n<ol start=\"2\">\n<li>打开设置要配置一下域名，如果不配置域名默认就是 <code>https://lxchinesszz.github.io/</code></li>\n</ol>\n</li>\n</ul>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1640502249000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_4-1-本地部署\"> 4.1 本地部署</h3>\n<p><code>hexo s</code></p>\n<h3 id=\"_4-2-远程部署\"> 4.2 远程部署</h3>\n<p><code>hexo g -d</code></p>\n<p>或者是</p>\n<p><code>hexo g</code>  + <code>hexo d</code></p>\n",
      "image": "https://img.shields.io/badge/Hexo-%E7%A4%BA%E4%BE%8B-green",
      "date_published": "2022-01-04T14:58:20.000Z",
      "date_modified": "2022-07-09T04:36:00.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Docsify",
      "url": "https://java.springlearn.cn/learn/blog/docsify/",
      "id": "https://java.springlearn.cn/learn/blog/docsify/",
      "content_html": "<h2 id=\"一、docsify\"> 一、docsify</h2>\n<p><code>docsify</code> 可以快速帮你生成文档网站。不同于 GitBook、Hexo 的地方是它不会生成静态的 .html 文件，所有转换工作都是在运行时。如果你想要开始使用它，只需要创建一个 index.html 就可以开始编写文档并直接部署在 GitHub Pages。\n<a href=\"https://docsify.js.org/#/zh-cn/\" target=\"_blank\" rel=\"noopener noreferrer\">docsify</a></p>\n<p><a href=\"https://ddd.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://ddd.springlearn.cn/</a></p>\n<h2 id=\"二、安装\"> 二、安装</h2>\n<h3 id=\"_2-1-安装\"> 2.1 安装</h3>\n<p>首先利用 <code>npm</code> 下载</p>\n<div><pre><code><span>npm</span> i docsify-cli -g\n\n<span># 初始化项目</span>\ndocsify init ./docs\n\n<span># 本地预览</span>\ndocsify serve docs\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id=\"三、使用\"> 三、使用</h2>\n<p>大家可以参考我的项目实现</p>\n<h3 id=\"_3-1-导航栏配置\"> 3.1 导航栏配置</h3>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1656224450000.png\" alt=\"\" loading=\"lazy\"></p>\n<ul>\n<li><a href=\"https://github.com/lxchinesszz/ddd-website/blob/master/docusaurus.config.js\" target=\"_blank\" rel=\"noopener noreferrer\"><code>docusaurus.config.js</code></a></li>\n</ul>\n<h3 id=\"_3-2-编写文章\"> 3.2 编写文章</h3>\n<p>文章基于Markdown格式,只要会使用Markdown就可以了。</p>\n<p>就这么简单,搭建可以直接拉去我的项目,进行调整即可。更多的定制化可以直接参考官方文档。</p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1656224450000.png",
      "date_published": "2022-03-27T13:12:51.000Z",
      "date_modified": "2022-07-09T04:36:00.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Home",
      "url": "https://java.springlearn.cn/learn/blog-readme/",
      "id": "https://java.springlearn.cn/learn/blog-readme/",
      "content_html": "<div><p>相关信息</p>\n<p>想要逼死一个强迫症，那实在是太简了。</p>\n</div>\n",
      "date_published": "2021-12-21T05:46:37.000Z",
      "date_modified": "2022-04-26T15:44:59.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Vuepress",
      "url": "https://java.springlearn.cn/learn/blog/vuepress/",
      "id": "https://java.springlearn.cn/learn/blog/vuepress/",
      "content_html": "<div><p>Vuepress</p>\n<p>Vuepress 从名字上看就知道跟Vue关系不一般,是的它是基于Vue进行开发的。Vue的官网也是使用这个框架来做的。他的好处是比较适合\n专题类文章, 对Markdown语法完全支持,通知支持代码高亮,比较适合技术类文章, 但是稍微有些难度, 适合有点经验的开发同学。</p>\n</div>\n<p><a href=\"https://java.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://java.springlearn.cn/</a></p>\n<h2 id=\"一、vuepress\"> 一、Vuepress</h2>\n<p><code>Hexo</code> 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。\n<a href=\"https://hexo.io/zh-cn/\" target=\"_blank\" rel=\"noopener noreferrer\">hexo</a></p>\n<h2 id=\"二、像数-1-2-3-一样容易\"> 二、像数 1, 2, 3 一样容易</h2>\n<p>这里是Vuepress原生主题,比较简单。</p>\n<div><pre><code># 安装\nyarn global add vuepress # 或者：npm install -g vuepress\n\n# 新建一个 markdown 文件\necho &#39;# Hello VuePress!&#39; &gt; README.md\n\n# 开始写作\nvuepress dev .\n\n# 构建静态文件\nvuepress build .\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><p>注意</p>\n<p>注意\n请确保你的 Node.js 版本 &gt;= 8.6。</p>\n</div>\n<h2 id=\"三、主题安装\"> 三、主题安装</h2>\n<p>这里只推荐一个主题,本网站的主题也是使用的这个。</p>\n<h3 id=\"_3-1-vuepress-theme-hope\"> 3.1 <a href=\"https://vuepress-theme-hope.github.io/zh/guide/get-started/install/#\" target=\"_blank\" rel=\"noopener noreferrer\">vuepress-theme-hope</a></h3>\n<div><pre><code>npm init vuepress-theme-hope \n</code></pre>\n<div><span>1</span><br></div></div><p>注意目录一定要在.vuepress/config.js</p>\n<div><pre><code><span>// .vuepress/config.js</span>\n<span>const</span> <span>{</span> config <span>}</span> <span>=</span> <span>require</span><span>(</span><span>\"vuepress-theme-hope\"</span><span>)</span><span>;</span>\n\nmodule<span>.</span>exports <span>=</span> <span>config</span><span>(</span><span>{</span>\n  <span>// your config here</span>\n<span>}</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div>",
      "date_published": "2022-03-27T13:12:51.000Z",
      "date_modified": "2022-07-09T04:36:00.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Redis",
      "url": "https://java.springlearn.cn/learn/databases/nosql/redis/",
      "id": "https://java.springlearn.cn/learn/databases/nosql/redis/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n",
      "image": "https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png",
      "date_published": "2022-01-04T14:58:20.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "将博客搬至CSDN",
      "url": "https://java.springlearn.cn/learn/blog/%E5%B0%86%E5%8D%9A%E5%AE%A2%E6%90%AC%E8%87%B3CSDN/",
      "id": "https://java.springlearn.cn/learn/blog/%E5%B0%86%E5%8D%9A%E5%AE%A2%E6%90%AC%E8%87%B3CSDN/",
      "content_html": "<h1 id=\"将博客搬至csdn\"> 将博客搬至CSDN</h1>\n",
      "date_published": "2022-07-09T04:36:00.000Z",
      "date_modified": "2022-07-09T04:36:00.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Redis缓存穿透雪崩问题",
      "url": "https://java.springlearn.cn/learn/databases/nosql/redis/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E9%9B%AA%E5%B4%A9%E9%97%AE%E9%A2%98/",
      "id": "https://java.springlearn.cn/learn/databases/nosql/redis/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E9%9B%AA%E5%B4%A9%E9%97%AE%E9%A2%98/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n<h2 id=\"一、缓存穿透\"> 一、缓存穿透</h2>\n<p><strong>数据层没有,导致查询一直都是穿透了缓存去查db。</strong></p>\n<p>缓存穿透的概念很简单，用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中，于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。</p>\n<h3 id=\"解决方案\"> 解决方案</h3>\n<h4 id=\"_1-布隆过滤器\"> （1）布隆过滤器</h4>\n<p>布隆过滤器是一种数据结构，垃圾网站和正常网站加起来全世界据统计也有几十亿个。网警要过滤这些垃圾网站，总不能到数据库里面一个一个去比较吧，这就可以使用布隆过滤器。假设我们存储一亿个垃圾网站地址。将者一亿个都放到布隆过滤器中。</p>\n<p>原理: 将User中的指定的字段进行hash计算到某一个位置上,比如在本案例中name和age是两个字段分别映射到了。1和4。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596446105000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>当用xiaoming去查询发现，1和4都已经被标记成1了,说明就有这个值了。\n而用xiaozhang去查询,发现小张对应的位置上都还是0说明就不存在这个值。</p>\n<p>但是这也存在一个问题,假如说xiaozhang也被hash映射到了1和4,不存在xiaozhang但是布隆判断缺存在。</p>\n<div><pre><code>public class BloomFilterTest {\n\n    private static class User {\n\n        private String name;\n\n        private int age;\n\n        public User(String name, int age) {\n            this.name = name;\n            this.age = age;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public int getAge() {\n            return age;\n        }\n\n        public void setName(String name) {\n            this.name = name;\n        }\n\n        public void setAge(int age) {\n            this.age = age;\n        }\n    }\n\n    public static void main(String[] args) {\n        BloomFilter&lt;User&gt; bloomFilter = BloomFilter.create((Funnel&lt;User&gt;) (user, primitiveSink) -&gt; primitiveSink.putString(user.getName(), Charset.defaultCharset())\n                .putInt(user.getAge()), 10, 0.01);\n        User xiaoming = new User(&quot;xiaoming&quot;, 1);\n        bloomFilter.put(xiaoming);\n\n        System.out.println(bloomFilter.mightContain(xiaoming));\n        System.out.println(bloomFilter.mightContain(new User(&quot;xiaozhang&quot;, 2)));\n    }\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><h4 id=\"_2-设置空对象\"> （2） 设置空对象</h4>\n<p>当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源；</p>\n<p>当数据层也没有发现就放一个空对象,空对象设置一个过期时间</p>\n<h2 id=\"二、缓存击穿\"> 二、缓存击穿</h2>\n<p>这种数据正常情况。就是给了一个说法名字而已</p>\n<p><strong>缓存中本来存在,但是某一个顺序缓存过期失效了,就被击穿访问到db层。</strong></p>\n<p>缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。</p>\n<h2 id=\"三、缓存雪崩\"> 三、缓存雪崩</h2>\n<p>缓存雪崩是指，缓存层出现了错误，不能正常工作了。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。</p>\n<h3 id=\"解决方案-2\"> 解决方案</h3>\n<h4 id=\"_1-redis高可用\"> （1）redis高可用</h4>\n<p>这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群。</p>\n<h4 id=\"_2-限流降级\"> （2）限流降级</h4>\n<p>这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p>\n<h4 id=\"_3-数据预热\"> （3）数据预热</h4>\n<p>数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p>\n<p>最后求关注,求订阅,谢谢你的阅读!</p>\n",
      "image": "https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png",
      "date_published": "2022-01-04T14:58:20.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Mysql优化示例",
      "url": "https://java.springlearn.cn/learn/databases/sql/SQL%E4%BC%98%E5%8C%96%E7%A4%BA%E4%BE%8B/",
      "id": "https://java.springlearn.cn/learn/databases/sql/SQL%E4%BC%98%E5%8C%96%E7%A4%BA%E4%BE%8B/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n<h2 id=\"创建表\"> 创建表</h2>\n<div><pre><code><span>use</span> test<span>;</span>\n<span>create</span> <span>table</span> test03\n<span>(</span>\n a1 <span>int</span><span>(</span><span>4</span><span>)</span> <span>not</span> <span>null</span><span>,</span>\n a2 <span>int</span><span>(</span><span>4</span><span>)</span> <span>not</span> <span>null</span><span>,</span>\n a3 <span>int</span><span>(</span><span>4</span><span>)</span> <span>not</span> <span>null</span><span>,</span>\n a4 <span>int</span><span>(</span><span>4</span><span>)</span> <span>not</span> <span>null</span>\n<span>)</span><span>;</span>\n<span>alter</span> <span>table</span> test03 <span>add</span> <span>index</span> idx_a1_a2_a3_a4<span>(</span>a1<span>,</span>a2<span>,</span>a3<span>,</span>a4<span>)</span><span>;</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><hr>\n<h2 id=\"建议一、按照复合索引顺序查询\"> 建议一、按照复合索引顺序查询</h2>\n<p><strong>需知</strong></p>\n<ol>\n<li>如果(a,b,c,d)复合索引和查询使用的顺序全部一致,则复合索引全部使用,如果不部分一致或者跨列使用则就是部分使用.</li>\n<li>where和order by拼起来也不要跨列,参考反例2和3</li>\n</ol>\n<h3 id=\"_1-建议\"> 1. 建议</h3>\n<ul>\n<li>建议: 按照where后面按照顺序使用复合索引</li>\n<li>建议: where 和 order by不要跨列\n<code>explain select a1,a2,a3,a4 from test03 where a1=1 and a2=2 and a3=3 and a4=4;</code></li>\n</ul>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596388059000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_2-反例1\"> 2. 反例1</h3>\n<p><code>explain select a1,a2,a3,a4 from test03 where a4=1 and a3=2 and a2=3 and a1=4;</code></p>\n<p>可以看到还是一样的,索引都用了，原因是sql在执行时候被sql优化器进行了调整,最后被调整成了上面的顺序写法。\n这是最理想的情况,但是实际中建议开发按照顺序来进行查询。\n<img src=\"https://img.springlearn.cn/blog/learn_1596388250000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_3-反例2\"> 3. 反例2</h3>\n<p><code>explain select a1,a2,a3,a4 from test03 where a1=1 and a2=2 and a4=4 order by a3;</code></p>\n<ul>\n<li>因为查询条件中复合索引跨列了(跨了a3)，所以导致只能用a1 和a2索引。索引key_len变成8了</li>\n<li>索引中没有查询a3但是却用a3排序了,导致要回表查询a3\n<img src=\"https://img.springlearn.cn/blog/learn_1596388567000.png\" alt=\"\" loading=\"lazy\"></li>\n</ul>\n<h3 id=\"_4-反例3\"> 4. 反例3</h3>\n<p><code>explain select a1,a2,a3,a4 from test03 where a1=1 and a4=4 order by a3;</code></p>\n<ul>\n<li>跨了a2 a3 所以a4失效只能用a1 所以key_len只有一个\nwhere 和 order by拼接起来是否也满足复合顺序,如果不满足\n就会出现Using filesort</li>\n<li>反例2中where 生效的是a1和a2，但是order by是a3。满足复合索引顺序,所以不会出现Using filesort</li>\n</ul>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596389005000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><code>explain select a1,a2,a3,a4 from test03 where a1=1 and a4=4 order by a2,a3;</code></p>\n<ul>\n<li>where a1 order by a2 a3 所以不会出现上面Using fileSort\n<img src=\"https://img.springlearn.cn/blog/learn_1596389167000.png\" alt=\"\" loading=\"lazy\"></li>\n</ul>\n<h2 id=\"建议二、单表优化\"> 建议二、单表优化</h2>\n<h3 id=\"建表及需求sql\"> 建表及需求sql</h3>\n<div><pre><code>\ncreate table book\n(\n bid int(4) primary key,\n name varchar(20) not null,\n authorid int(4) not null,\n publicid int(4) not null,\n typeid int(4) not null\n);\n\ninsert into book values(1,&#39;tjava&#39;,1,1,2);\ninsert into book values(2,&#39;tjava&#39;,2,1,2);\ninsert into book values(3,&#39;tjava&#39;,3,2,1);\ninsert into book values(4,&#39;tjava&#39;,4,2,3);\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p><strong>查询authorid = 1 并且 typeid 等于2或者3 然后根据typeid 排序</strong></p>\n<p><code>explain select bid from book where typeid in (2,3) and authorid = 1 order by typeid desc;</code></p>\n<div><pre><code>mysql&gt; explain select bid from book where  typeid in (2,3) and authorid = 1  order by typeid desc;\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------------------+\n| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                       |\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------------------+\n|  1 | SIMPLE      | book  | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    4 |    25.00 | Using where; Using filesort |\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------------------+\n1 row in set, 1 warning (0.00 sec)\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>可以看出来未用到索引,type是all。就是全表查询了。</p>\n<h3 id=\"_1-优化1加索引\"> 1. 优化1加索引</h3>\n<p><code>alter table book add index idx_bta(bid,typeid,authorid);</code></p>\n<div><pre><code>mysql&gt; explain select bid from book where  typeid in (2,3) and authorid = 1  order by typeid desc;\n+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+------------------------------------------+\n| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra                                    |\n+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+------------------------------------------+\n|  1 | SIMPLE      | book  | NULL       | index | NULL          | idx_bta | 12      | NULL |    4 |    25.00 | Using where; Using index; Using filesort |\n+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+------------------------------------------+\n1 row in set, 1 warning (0.00 sec)\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>可以看到通过了加索引type由之前的all变成了index,说明有一点进步。但是我们看到还有一个<code>Using filesort</code>.前面我们说了出现这个\n是因为额外多了一次查询。根据sql的解析规则，第一个解析的是typeid,第二个是authorid。那么我们先对索引顺序做一个优化。</p>\n<h3 id=\"_2-优化索引顺序\"> 2. 优化索引顺序</h3>\n<p>复合索引一旦进行了升级优化，就要删除了，否则会进行干扰。<code>drop index idx_bta on book;</code></p>\n<p>按照sql执行顺序来创建索引。这里我们其实也可以不创建bid，但是如果不创建bid,就要回表去查询bid,所以也建议加上。\n<code>alter table book add index idx_tab(typeid,authorid,bid);</code></p>\n<div><pre><code>mysql&gt; explain select bid,typeid from book where  typeid in (2,3) and authorid = 1  order by typeid desc;\n+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-----------------------------------------------+\n| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra                                         |\n+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-----------------------------------------------+\n|  1 | SIMPLE      | book  | NULL       | range | idx_tab       | idx_tab | 8       | NULL |    2 |   100.00 | Using where; Backward index scan; Using index |\n+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-----------------------------------------------+\n1 row in set, 1 warning (0.00 sec)\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>可以看到已经没有了,Using filesort。</p>\n<h3 id=\"_3-总结\"> 3. 总结</h3>\n<ul>\n<li>索引优化不会一步到位,要多次优化。</li>\n<li>索引顺序会影响查询效率,如果不知道怎么优化,建议sql执行顺序,多尝试几次不同顺序。通过看type的级别来调整。</li>\n<li>type如果是range或者ref。其实就可以了。如果是index或者all就要考虑是否要进行优化。</li>\n<li>in会是索引失效</li>\n</ul>\n<h2 id=\"建议三、多表优化\"> 建议三、多表优化</h2>\n<h3 id=\"建表及需求sql-2\"> 建表及需求sql</h3>\n<div><pre><code>create table teacher2\n(\n    tid int(4) primary key,\n    cid int(4) not null\n);\n\ninsert into teacher2 values(1,2);\ninsert into teacher2 values(2,1);\ninsert into teacher2 values(3,3);\n\ncreate table course2\n(\n    cid int(4),\n    cname varchar(20)\n);\ninsert into course2 values(1,&#39;java&#39;);\ninsert into course2 values(2,&#39;python&#39;);\ninsert into course2 values(3,&#39;kotlin&#39;);\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p><strong>需求sql</strong></p>\n<p><code>select * from teacher2 t left outer join course2 c on t.cid=c.cid where c.cname = 'java';</code></p>\n<div><pre><code>mysql&gt; select * from teacher2 t left outer join course2 c on t.cid=c.cid where c.cname = &#39;java&#39;;\n+-----+-----+------+-------+\n| tid | cid | cid  | cname |\n+-----+-----+------+-------+\n|   2 |   1 |    1 | java  |\n+-----+-----+------+-------+\n1 row in set (0.00 sec)\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>执行计划分析</p>\n<div><pre><code>mysql&gt; explain select * from teacher2 t left outer join course2 c on t.cid=c.cid where c.cname = &#39;java&#39;;\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+\n| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                              |\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+\n|  1 | SIMPLE      | c     | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |    33.33 | Using where                                        |\n|  1 | SIMPLE      | t     | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |    33.33 | Using where; Using join buffer (Block Nested Loop) |\n+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+\n2 rows in set, 1 warning (0.00 sec)\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>可以看到有一个<code>Using join buffer</code>。 说明Sql写的太差了，mysql给你加了一个缓存。经过下面的索引优化会去掉。</p>\n<h3 id=\"优化1小表驱动大表\"> 优化1小表驱动大表</h3>\n<p>当编写语句时候,将数据量小的表放左边(假设此时t表小,on t.cid = c.cid);反之如果c表小(on c.cid = t.tic)</p>\n<h3 id=\"优化2加索引\"> 优化2加索引</h3>\n<p>索引建立在经常使用的字段上,本例中t.cid使用频繁。</p>\n<p><code>alter table teacher2 add index idx_teacher2_cid(cid);</code></p>\n<div><pre><code>mysql&gt; explain select * from teacher2 t left outer join course2 c on t.cid=c.cid where c.cname = &#39;java&#39;;\n+----+-------------+-------+------------+------+------------------+------------------+---------+------------+------+----------+-------------+\n| id | select_type | table | partitions | type | possible_keys    | key              | key_len | ref        | rows | filtered | Extra       |\n+----+-------------+-------+------------+------+------------------+------------------+---------+------------+------+----------+-------------+\n|  1 | SIMPLE      | c     | NULL       | ALL  | NULL             | NULL             | NULL    | NULL       |    3 |    33.33 | Using where |\n|  1 | SIMPLE      | t     | NULL       | ref  | idx_teacher2_cid | idx_teacher2_cid | 4       | test.c.cid |    1 |   100.00 | Using index |\n+----+-------------+-------+------------+------+------------------+------------------+---------+------------+------+----------+-------------+\n2 rows in set, 1 warning (0.00 sec)\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>给name也加索引</p>\n<p><code>alter table course2 add index idx_course2_name(cname);</code></p>\n<div><pre><code>mysql&gt; explain select * from teacher2 t left outer join course2 c on t.cid=c.cid where c.cname = &#39;java&#39;;\n+----+-------------+-------+------------+------+------------------+------------------+---------+------------+------+----------+-------------+\n| id | select_type | table | partitions | type | possible_keys    | key              | key_len | ref        | rows | filtered | Extra       |\n+----+-------------+-------+------------+------+------------------+------------------+---------+------------+------+----------+-------------+\n|  1 | SIMPLE      | c     | NULL       | ref  | idx_course2_name | idx_course2_name | 83      | const      |    1 |   100.00 | Using where |\n|  1 | SIMPLE      | t     | NULL       | ref  | idx_teacher2_cid | idx_teacher2_cid | 4       | test.c.cid |    1 |   100.00 | Using index |\n+----+-------------+-------+------------+------+------------------+------------------+---------+------------+------+----------+-------------+\n2 rows in set, 1 warning (0.00 sec)\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>这样两个查询就都用到了索引。</p>\n<h2 id=\"建议四、sql优化\"> 建议四、sql优化</h2>\n<h3 id=\"_1-exist和in\"> 1. exist和in</h3>\n<p>如果主查询的数据集大用 <code>in</code> ,如果子查询数据量大使用 <code>exist</code></p>\n<h3 id=\"_2-order-by优化\"> 2. order by优化</h3>\n<p>Using filesort 有两种算法: 双路排序、单路排序(根据IO的次数,即访问磁盘的顺序)</p>\n<ul>\n<li>MySQL4.1前默认使用双路排序,即扫描两次磁盘(1. 从磁盘读取排序字段,2. 扫描其他字段)</li>\n<li>MySQL4.1后默认使用单路排序,即访问一次磁盘(1. 只读取一次字段,然后在buffer中进行排序)</li>\n</ul>\n<p>但是单路排序有隐患就是不一定是只访问一次磁盘,因为加入数据量特别大,则无法将所有字段的\n数据都放到buffer中,要多次分片读取。此时可以考虑调大buffer容量大小。</p>\n<p><code>set max_length_for_sort_data = 1024</code> (单位/字节)</p>\n<p>如果缓存区大小太小,mysql会自动从单路调整到双路。</p>\n<p><strong>建议</strong></p>\n<ul>\n<li>避免使用<code>select *</code></li>\n<li>复合索引不要跨列使用,如果where和order尽量也按照顺序使用</li>\n<li>order by 如果是多个字段,建议都是升序或者都是降序</li>\n</ul>\n<h3 id=\"_3-慢查询日志\"> 3. 慢查询日志</h3>\n<p><a href=\"https://blog.springlearn.cn/posts/3935/\" target=\"_blank\" rel=\"noopener noreferrer\">如何找到垃圾SQL语句,你知道这些方式吗？</a></p>\n<p>慢sql就是mysql提供的一种日志记录,用于记录响应的时间超过阀值得语句;</p>\n<p><strong>查询是否开启慢查询</strong></p>\n<p><code>show variables like '%slow_query_log%';</code></p>\n<div><pre><code>mysql&gt; show variables like &#39;%slow_query_log%&#39;;\n+---------------------+-----------------------------------------+\n| Variable_name       | Value                                   |\n+---------------------+-----------------------------------------+\n| slow_query_log      | OFF                                     |\n| slow_query_log_file | /usr/local/var/mysql/localhost-slow.log |\n+---------------------+-----------------------------------------+\n2 rows in set (0.06 sec)\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><strong>临时开启:</strong></p>\n<div><pre><code>set global slow_query_log = 1;\nexit;\nservices mysql restart\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>查询慢查询日志阀值</strong></p>\n<p><code>show variables like '%long_query_time%';</code></p>\n<div><pre><code>mysql&gt; show variables like &#39;%long_query_time%&#39;;\n+-----------------+-----------+\n| Variable_name   | Value     |\n+-----------------+-----------+\n| long_query_time | 10.000000 |\n+-----------------+-----------+\n1 row in set (0.00 sec)\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><strong>临时设置阀值</strong></p>\n<p>修改完成之后要重新登录生效</p>\n<div><pre><code>set global long_query_time = 5;\n</code></pre>\n<div><span>1</span><br></div></div><div><pre><code>mysql&gt; show variables like &#39;%long_query_time%&#39;;\n+-----------------+-----------+\n| Variable_name   | Value     |\n+-----------------+-----------+\n| long_query_time | 10.000000 |\n+-----------------+-----------+\n1 row in set (0.00 sec)\n\nmysql&gt; set global long_query_time = 5;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; show variables like &#39;%long_query_time%&#39;;\n+-----------------+-----------+\n| Variable_name   | Value     |\n+-----------------+-----------+\n| long_query_time | 10.000000 |\n+-----------------+-----------+\n1 row in set (0.00 sec)\n\nmysql&gt; exit\nBye\n liuxin@localhost  ~  mysql -u root -p\nEnter password:\nWelcome to the MySQL monitor.  Commands end with ; or \\g.\nYour MySQL connection id is 9\nServer version: 8.0.16 Homebrew\n\nCopyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.\n\nOracle is a registered trademark of Oracle Corporation and/or its\naffiliates. Other names may be trademarks of their respective\nowners.\n\nType &#39;help;&#39; or &#39;\\h&#39; for help. Type &#39;\\c&#39; to clear the current input statement.\n\nmysql&gt; show variables like &#39;%long_query_time%&#39;;\n+-----------------+----------+\n| Variable_name   | Value    |\n+-----------------+----------+\n| long_query_time | 5.000000 |\n+-----------------+----------+\n1 row in set (0.00 sec)\n\nmysql&gt;\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br></div></div><h4 id=\"超过阀值得数量\"> 超过阀值得数量</h4>\n<p><code>show global status like '%slow_queries%';</code></p>\n<div><pre><code>mysql&gt; show global status like &#39;%slow_queries%&#39;;\n+---------------+-------+\n| Variable_name | Value |\n+---------------+-------+\n| Slow_queries  | 0     |\n+---------------+-------+\n1 row in set (0.01 sec)\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id=\"总结\"> 总结</h2>\n<ol>\n<li>复合索引,不要跨列或无序使用</li>\n<li>复合索引,尽量使用全索引匹配</li>\n<li>不要在索引上进行计算、函数、类型转换</li>\n<li>复合索引不能使用 != 、 &lt;&gt; 、 is null</li>\n<li>like尽量以&quot;常量&quot;开头,不要以&quot;%&quot;开头,否则索引失效</li>\n<li>尽量不要使用类型转换（显式、隐式）,否则索引失效。where name = 'lx' 可以。where name\n<img src=\"https://img.springlearn.cn/blog/learn_1596447963000.png\" alt=\"\" loading=\"lazy\"></li>\n<li>尽量不要用or,否则左右索引都可能失效\n<img src=\"https://img.springlearn.cn/blog/learn_1596448080000.png\" alt=\"\" loading=\"lazy\"></li>\n</ol>\n<p>最后求关注,求订阅,谢谢你的阅读!</p>\n",
      "image": "https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png",
      "date_published": "2022-01-04T14:58:20.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "MySQL",
      "url": "https://java.springlearn.cn/learn/databases/sql/",
      "id": "https://java.springlearn.cn/learn/databases/sql/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n<h2 id=\"mysql-事务\"> MySQL 事务</h2>\n<p>MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你既需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！</p>\n<ul>\n<li>在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。</li>\n<li>事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。</li>\n<li>事务用来管理 insert,update,delete 语句</li>\n</ul>\n<p>一般来说，事务是必须满足4个条件（ACID）：：原子性（<strong>A</strong>tomicity，或称不可分割性）、一致性（<strong>C</strong>onsistency）、隔离性（<strong>I</strong>solation，又称独立性）、持久性（<strong>D</strong>urability）。</p>\n<ul>\n<li><strong>原子性</strong> 一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</li>\n<li><strong>一致性</strong>在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</li>\n<li><strong>隔离性</strong>数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li>\n<li><strong>持久性</strong>事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>\n</ul>\n<blockquote>\n<p>在 MySQL 命令行的默认设置下，事务都是自动提交的，即执行 SQL 语句后就会马上执行 COMMIT 操作。因此要显式地开启一个事务务须使用命令 BEGIN 或 START TRANSACTION，或者执行命令 SET AUTOCOMMIT=0，用来禁止使用当前会话的自动提交。</p>\n</blockquote>\n<h3 id=\"事务控制语句\"> 事务控制语句</h3>\n<ul>\n<li>BEGIN 或 START TRANSACTION 显式地开启一个事务；</li>\n<li>COMMIT 也可以使用 COMMIT WORK，不过二者是等价的。COMMIT 会提交事务，并使已对数据库进行的所有修改成为永久性的；</li>\n<li>ROLLBACK 也可以使用 ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；</li>\n<li>SAVEPOINT identifier，SAVEPOINT 允许在事务中创建一个保存点，一个事务中可以有多个 SAVEPOINT；</li>\n<li>RELEASE SAVEPOINT identifier 删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常；</li>\n<li>ROLLBACK TO identifier 把事务回滚到标记点；</li>\n<li>SET TRANSACTION 用来设置事务的隔离级别。InnoDB 存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ 和 SERIALIZABLE。</li>\n</ul>\n<h3 id=\"mysql-事务处理主要有两种方法\"> MYSQL 事务处理主要有两种方法</h3>\n<p>1、用 BEGIN, ROLLBACK, COMMIT来实现</p>\n<ul>\n<li><strong>BEGIN</strong> 开始一个事务</li>\n<li><strong>ROLLBACK</strong> 事务回滚</li>\n<li><strong>COMMIT</strong> 事务确认</li>\n</ul>\n<p>2、直接用 SET 来改变 MySQL 的自动提交模式:</p>\n<ul>\n<li><strong>SET AUTOCOMMIT=0</strong> 禁止自动提交</li>\n<li><strong>SET AUTOCOMMIT=1</strong> 开启自动提交</li>\n</ul>\n",
      "image": "https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png",
      "date_published": "2022-01-04T14:58:20.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "SQL索引性能优化",
      "url": "https://java.springlearn.cn/learn/databases/sql/SQL%E7%B4%A2%E5%BC%95%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/",
      "id": "https://java.springlearn.cn/learn/databases/sql/SQL%E7%B4%A2%E5%BC%95%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n<h1 id=\"建表\"> 建表</h1>\n<div><pre><code>// 建表\nCREATE TABLE IF NOT EXISTS staffs(\n    id INT PRIMARY KEY AUTO_INCREMENT,\n    name VARCHAR(24) NOT NULL DEFAULT &quot;&quot; COMMENT&#39;姓名&#39;,\n    age INT NOT NULL DEFAULT 0 COMMENT&#39;年龄&#39;,\n    pos VARCHAR(20) NOT NULL DEFAULT &quot;&quot; COMMENT&#39;职位&#39;,\n    add_time TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT&#39;入职事件&#39;\n) CHARSET utf8 COMMENT&#39;员工记录表&#39;;\n\n// 插入数据\nINSERT INTO `test`.`staffs` (`name`, `age`, `pos`, `add_time`) VALUES (&#39;z3&#39;, 22, &#39;manager&#39;, now());\nINSERT INTO `test`.`staffs` (`name`, `age`, `pos`, `add_time`) VALUES (&#39;July&#39;, 23, &#39;dev&#39;, now());\nINSERT INTO `test`.`staffs` (`name`, `age`, `pos`, `add_time`) VALUES (&#39;2000&#39;, 23, &#39;dev&#39;, now());\n\n// 建立复合索引（即一个索引包含多个字段）\nALTER TABLE staffs ADD INDEX idx_staffs_nameAgePos(name, age, pos);\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><hr>\n<h2 id=\"优化一、全部用到索引\"> 优化一、全部用到索引</h2>\n<h3 id=\"_1-介绍\"> 1. 介绍</h3>\n<p>建立的复合索引包含了几个字段，查询的时候最好能全部用到，而且严格按照索引顺序，这样查询效率是最高的。（最理想情况，具体情况具体分析）</p>\n<h3 id=\"_2-sql案例\"> 2. SQL案例</h3>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596353647000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"优化二、最左前缀法则\"> 优化二、最左前缀法则</h2>\n<h3 id=\"_1-介绍-2\"> 1. 介绍</h3>\n<p>如果建立的是复合索引，索引的顺序要按照建立时的顺序，即从左到右，如：a-&gt;b-&gt;c（和 B+树的数据结构有关）</p>\n<h3 id=\"_2-无效索引举例\"> 2. 无效索引举例</h3>\n<p>如果用了a和c,那么a索引有效,c无效,因为中间跳过了b</p>\n<p>如果用了b和c,那么b索引和c索引都无效,因为跳过了a</p>\n<p>如果只用了c,那么也会无效,因为跳过了a和b</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596354258000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"优化三、不要对索引做以下处理\"> 优化三、不要对索引做以下处理</h2>\n<h3 id=\"_1-以下用法会导致索引失效\"> 1. 以下用法会导致索引失效</h3>\n<ul>\n<li>计算，如：+、-、*、/、!=、&lt;&gt;、is null、is not null、or</li>\n<li>函数，如：sum()、round()等等</li>\n<li>手动/自动类型转换，如：id = &quot;1&quot;，本来是数字，给写成字符串了</li>\n</ul>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596354578000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"优化四、索引不要放在范围查询右边\"> 优化四、索引不要放在范围查询右边</h2>\n<h3 id=\"_1-举例\"> 1. 举例</h3>\n<p>比如复合索引：a-&gt;b-&gt;c，当 where a=&quot;&quot; and b&gt;10 and 3=&quot;&quot;，这时候只能用到 a 和 b，c 用不到索引，因为在范围之后索引都失效（和 B+树结构有关）</p>\n<p>因为b使用了范围,所以右边的索引c就失效了</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596355600000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"优化五、减少-select-的使用\"> 优化五、减少 select * 的使用</h2>\n<h3 id=\"_1-使用覆盖索引\"> 1. 使用覆盖索引</h3>\n<p>即：select 查询字段和 where 中使用的索引字段一致。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596355952000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"优化六、like-模糊搜索\"> 优化六、like 模糊搜索</h2>\n<h3 id=\"_1-失效情况\"> 1. 失效情况</h3>\n<p>like &quot;%张三%&quot;\nlike &quot;%张三&quot;</p>\n<h3 id=\"_2-解决方案\"> 2. 解决方案</h3>\n<ul>\n<li>\n<p>使用复合索引，即 like 字段是 select 的查询字段，如：select name from table where name like &quot;%张三%&quot;\n使用 like &quot;张三%&quot;</p>\n</li>\n<li>\n<p>使用 like &quot;张三%&quot;</p>\n</li>\n</ul>\n<h2 id=\"优化七、order-by-优化\"> 优化七、order by 优化</h2>\n<p>当查询语句中使用 order by 进行排序时，如果没有使用索引进行排序，会出现 filesort 文件内排序，这种情况在数据量大或者并发高的时候，会有性能问题，需要优化。</p>\n<h3 id=\"_1-filesort-出现的情况举例\"> 1. filesort 出现的情况举例</h3>\n<ul>\n<li>order by 字段不是索引字段</li>\n<li>order by 字段是索引字段，但是 select 中没有使用覆盖索引，如：<code>select * from staffs order by age asc;</code></li>\n<li>order by 中同时存在 ASC 升序排序和 DESC 降序排序，如：<code>select a, b from staffs order by a desc, b asc;</code></li>\n<li>order by 多个字段排序时，不是按照索引顺序进行 order by，即不是按照最左前缀法则，如：<code>select a, b from staffs order by b asc, a asc;</code></li>\n</ul>\n<h3 id=\"_2-索引层面解决方法\"> 2. 索引层面解决方法</h3>\n<ul>\n<li>使用主键索引排序</li>\n<li>按照最左前缀法则，并且使用覆盖索引排序，多个字段排序时，保持排序方向一致</li>\n<li>在 SQL 语句中强制指定使用某索引，force index(索引名字)</li>\n<li>不在数据库中排序，在代码层面排序</li>\n</ul>\n<h3 id=\"_3-order-by-排序算法\"> 3. order by 排序算法</h3>\n<p><strong>双路排序</strong></p>\n<p><em>Mysql4.1 之前是使用双路排序，字面的意思就是两次扫描磁盘，最终得到数据，读取行指针和 ORDER BY 列，对他们进行排序，然后扫描已经排好序的列表，按照列表中的值重新从列表中读取对数据输出。也就是从磁盘读取排序字段，在 buffer 进行排序，再从磁盘读取其他字段。</em></p>\n<p>文件的磁盘 IO 非常耗时的，所以在 Mysql4.1 之后，出现了第二种算法，就是单路排序。</p>\n<p><em>从磁盘读取查询需要的所有列，按照 orderby 列在 buffer 对它们进行排序，然后扫描排序后的列表进行输出， 它的效率更快一些，避免了第二次读取数据，并且把随机 IO 变成顺序 IO，但是它会使用更多的空间， 因为它把每一行都保存在内存中了。</em></p>\n<p>当我们无可避免要使用排序时，索引层面没法在优化的时候又该怎么办呢？尽可能让 MySQL 选择使用第二种单路算法来进行排序。这样可以减少大量的随机 IO 操作,很大幅度地提高排序工作的效率。下面看看单路排序优化需要注意的点</p>\n<p><strong>单路排序优化点</strong></p>\n<p>增大 max_length_for_sort_data</p>\n<p><em>在 MySQL 中,决定使用&quot;双路排序&quot;算法还是&quot;单路排序&quot;算法是通过参数 maxlength_for sort_data 来决定的。当所有返回字段的最大长度小于这个参数值时,MySQL 就会选择&quot;单路排序&quot;算法,反之,则选择&quot;多路排序&quot;算法。所以,如果有充足的内存让 MySQL 存放须要返回的非排序字段,就可以加大这个参数的值来让 MySQL 选择使用&quot;单路排序&quot;算法。</em></p>\n<p>去掉不必要的返回字段，避免select *</p>\n<p><em>当内存不是很充裕时,不能简单地通过强行加大上面的参数来强迫 MySQL 去使用&quot;单路排序&quot;算法,否则可能会造成 MySQL 不得不将数据分成很多段,然后进行排序,这样可能会得不偿失。此时就须要去掉不必要的返回字段,让返回结果长度适应 max_length_for_sort_data 参数的限制。</em></p>\n<p>增大 sort_buffer_size 参数设置</p>\n<p><em>这个值如果过小的话,再加上你一次返回的条数过多,那么很可能就会分很多次进行排序,然后最后将每次的排序结果再串联起来,这样就会更慢,增大 sort_buffer_size 并不是为了让 MySQL 选择&quot;单路排序&quot;算法,而是为了让 MySQL 尽量减少在排序过程中对须要排序的数据进行分段,因为分段会造成 MySQL 不得不使用临时表来进行交换排序。</em></p>\n<p>但是sort_buffer_size 不是越大越好：</p>\n<ul>\n<li>Sort_Buffer_Size 是一个 connection 级参数,在每个 connection 第一次需要使用这个 buffer 的时候,一次性分配设置的内存。</li>\n<li>Sort_Buffer_Size 并不是越大越好,由于是 connection 级的参数,过大的设置和高并发可能会耗尽系统内存资源。</li>\n<li>据说 Sort_Buffer_Size 超过 2M 的时候,就会使用 mmap() 而不是 malloc() 来进行内存分配,导致效率降低。</li>\n</ul>\n<h2 id=\"优化八、group-by\"> 优化八、group by</h2>\n<p>其原理也是先排序后分组，其优化方式可参考order by。where高于having,能写在where限定的条件就不要去having限定了。</p>\n",
      "image": "https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png",
      "date_published": "2022-01-04T14:58:20.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "explain调优",
      "url": "https://java.springlearn.cn/learn/databases/sql/explain/",
      "id": "https://java.springlearn.cn/learn/databases/sql/explain/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n<blockquote>\n<p>这篇文章主要讲 explain 如何使用，还有 explain 各种参数概念，之后会讲优化</p>\n</blockquote>\n<h1 id=\"一、explain-用法\"> 一、Explain 用法</h1>\n<p>explain模拟Mysql优化器是如何执行SQL查询语句的，从而知道Mysql是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈。</p>\n<p><strong>语法</strong>：<code>Explain + SQL 语句;</code></p>\n<p>如：<code>Explain select * from user;</code> 会生成如下 SQL 分析结果，下面详细对每个字段进行详解</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596351159000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_1-id\"> 1. id</h2>\n<p>是一组数字，代表多个表之间的查询顺序，或者包含子句查询语句中的顺序，id 总共分为三种情况，依次详解</p>\n<h3 id=\"id相同\"> id相同</h3>\n<p>id相同，执行顺序由上至下\n<img src=\"https://img.springlearn.cn/blog/learn_1596351240000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"id不同\"> id不同</h3>\n<p>id 不同，如果是子查询，id 号会递增，id 值越大优先级越高，越先被执行</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596351303000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"id相同和不同\"> id相同和不同</h3>\n<p>id 相同和不同的情况同时存在</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596351331000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_2-select-type\"> 2. select_type</h2>\n<p>select_type 包含以下几种值</p>\n<p><code>simple</code>、<code>primary</code>、<code>subquery</code>、<code>derived</code>、<code>union</code>、<code>union result</code></p>\n<h3 id=\"simple\"> simple</h3>\n<p>简单的 <code>select</code> 查询，查询中不包含子查询或者 <code>union</code> 查询</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596351522000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"primary\"> primary</h3>\n<p>如果 SQL 语句中包含任何子查询，那么子查询的最外层会被标记为 <code>primary</code></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596351575000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"subquery\"> subquery</h3>\n<p>在 <code>select</code> 或者 <code>where</code> 里包含了子查询，那么子查询就会被标记为 <code>subQquery</code>，同三.二同时出现</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596351651000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"derived\"> derived</h3>\n<p>在 <code>from</code> 中包含的一个子查询，会被标记为衍生查询，会把查询结果放到一个临时表中</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596351720000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"union-union-result\"> union / union result</h3>\n<p>如果有两个 <code>select</code> 查询语句，他们之间用 <code>union</code> 连起来查询，那么第二个 <code>select</code> 会被标记为 <code>union</code>，<code>union</code> 的结果被标记为 <code>union result</code>。它的 id 是为 null 的</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596351779000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_3-table\"> 3. table</h2>\n<p>表示这一行的数据是哪张表的数据</p>\n<h2 id=\"_4-type\"> 4. type</h2>\n<p>type 是代表 MySQL 使用了哪种索引类型，不同的索引类型的查询效率也是不一样的，type 大致有以下种类。\n越往上性能越高。</p>\n<table>\n<thead>\n<tr>\n<th>Type类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>system</td>\n<td>表中只有一行记录，system 是 const 的特例，几乎不会出现这种情况，可以忽略不计</td>\n</tr>\n<tr>\n<td>const</td>\n<td>必须是用主键索引或者唯一索引放到 where 条件中查询</td>\n</tr>\n<tr>\n<td>eq_ref</td>\n<td>多表查询中,索引查出来的数据都是唯一的（不能是多个,也不能是0个），常见于唯一索引和主键索引</td>\n</tr>\n<tr>\n<td>ref</td>\n<td>不是主键索引，也不是唯一索引，就是普通的索引，可能会返回多个符合条件的行。</td>\n</tr>\n<tr>\n<td>range</td>\n<td>体现在对某个索引进行区间范围检索，一般出现在 where 条件中的 between、and、&lt;、&gt;、in 等范围查找中。</td>\n</tr>\n<tr>\n<td>index</td>\n<td>将所有的索引树都遍历一遍，查找到符合条件的行。索引文件比数据文件还是要小很多，所以比不用索引全表扫描还是要快很多。</td>\n</tr>\n<tr>\n<td>all</td>\n<td>没用到索引，单纯的将表数据全部都遍历一遍，查找到符合条件的数据</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"_5-possible-keys\"> 5. possible_keys</h2>\n<p>此次查询中涉及字段上若存在索引，则会被列出来，表示可能会用到的索引，但并不是实际上一定会用到的索引</p>\n<h2 id=\"_6-key\"> 6. key</h2>\n<p>此次查询中实际上用到的索引</p>\n<h2 id=\"_7-key-len\"> 7. key_len</h2>\n<p>表示索引中使用的字节数，通过该属性可以知道在查询中使用的索引长度，注意：这个长度是最大可能长度，并非实际使用长度，在不损失精确性的情况下，长度越短查询效率越高</p>\n<h2 id=\"_8-ref\"> 8. ref</h2>\n<p>显示关联的字段。如果使用常数等值查询，则显示 const，如果是连接查询，则会显示关联的字段。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596352252000.png\" alt=\"\" loading=\"lazy\"></p>\n<ul>\n<li>tb_emp 表为非唯一性索引扫描，实际使用的索引列为 idx_name，由于 tb_emp.name='rose'为一个常量，所以 ref=const。</li>\n<li>tb_dept 为唯一索引扫描，从 sql 语句可以看出，实际使用了 PRIMARY 主键索引，ref=db01.tb_emp.deptid 表示关联了 db01 数据库中 tb_emp 表的 deptid 字段。</li>\n</ul>\n<h2 id=\"_9-rows\"> 9. rows</h2>\n<p>根据表信息统计以及索引的使用情况，大致估算说要找到所需记录需要读取的行数，rows 越小越好</p>\n<h2 id=\"_10-extra\"> 10. extra</h2>\n<p>不适合在其他列显示出来，但在优化时十分重要的信息</p>\n<h3 id=\"using-filesort-重点优化\"> using  fileSort（重点优化）</h3>\n<p>俗称 &quot; 文件排序 &quot; ，在数据量大的时候几乎是“九死一生”，在 order by 或者在 group by 排序的过程中，order by 的字段不是索引字段，或者 select 查询字段存在不是索引字段，或者 select 查询字段都是索引字段，但是 order by 字段和 select 索引字段的顺序不一致，都会导致 fileSort</p>\n<p>如果where后面的查询和order by的索引，不是一个值。就会出现fileSort。</p>\n<p>复合索引,夸界,也会出现fileSort。</p>\n<p>优化建议: where 什么就order by 什么。 或者 where和order by 按照复合索引顺序，不要跨列或者无序使用\n<img src=\"https://img.springlearn.cn/blog/learn_1596352476000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"using-temporary-重点优化\"> using temporary（重点优化）</h3>\n<p>使用了临时表保存中间结果，常见于 order by 和 group by 中。</p>\n<p>优化建议: 查询哪些列就用哪些列来order by。 能不用创建临时表就不要创建。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596352573000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"using-index-重点\"> USING index（重点）</h3>\n<p>索引覆盖,就是当前sql查询不用读取原文件,只用读取索引。因为查询的列就是索引列</p>\n<p>表示相应的 select 操作中使用了覆盖索引（Coveing Index）,避免访问了表的数据行，效率不错！如果同时出现 using where，表明索引被用来执行索引键值的查找；如果没有同时出现 using where，表面索引用来读取数据而非执行查找动作。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596352650000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"using-where\"> Using where</h3>\n<p>跟using index相反，要回表去查询。</p>\n<p>表明使用了 where 过滤</p>\n<h3 id=\"using-join-buffer\"> Using join buffer</h3>\n<p>使用了连接缓存</p>\n<h3 id=\"impossible-where\"> impossible where</h3>\n<p>where 子语句的值总是 false，不能用来获取任何数据。出现这个就要检查sql。</p>\n<p>eg: select a from test where a = 1 and a = 2。  a肯定不可能即1又是2</p>\n<h3 id=\"select-tables-optimized-away\"> select tables optimized away</h3>\n<p>在没有 GROUPBY 子句的情况下，基于索引优化 MIN/MAX 操作或者 对于 MyISAM 存储引擎优化 COUNT(*)操作，不必等到执行阶段再进行计算， 查询执行计划生成的阶段即完成优化。</p>\n<h3 id=\"distinct\"> distinct</h3>\n<p>优化 distinct，在找到第一匹配的元组后即停止找同样值的工作</p>\n",
      "image": "https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png",
      "date_published": "2022-01-04T14:58:20.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "SQL锁机制",
      "url": "https://java.springlearn.cn/learn/databases/sql/SQL%E9%94%81%E6%9C%BA%E5%88%B6/",
      "id": "https://java.springlearn.cn/learn/databases/sql/SQL%E9%94%81%E6%9C%BA%E5%88%B6/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n<h2 id=\"一、场景模拟\"> 一、场景模拟</h2>\n<div><pre><code><span>create</span> <span>table</span> shop\n<span>(</span>\n  id <span>int</span><span>(</span><span>4</span><span>)</span> <span>primary</span> <span>key</span> <span>default</span> <span>0</span><span>,</span>\n  name <span>varchar</span><span>(</span><span>20</span><span>)</span> <span>default</span> <span>'衣服'</span><span>,</span>\n  <span>status</span> <span>varchar</span><span>(</span><span>20</span><span>)</span> <span>default</span> <span>'可售'</span>\n<span>)</span><span>engine</span> <span>=</span> <span>innodb</span> <span>default</span> <span>charset</span><span>=</span>utf8<span>;</span>\n\n<span>insert</span> <span>into</span> shop  <span>values</span><span>(</span><span>1</span><span>,</span><span>'衣服'</span><span>,</span><span>'可售'</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><pre><code>mysql&gt; select * from shop;\n+----+--------+--------+\n| id | name   | status |\n+----+--------+--------+\n|  1 | 衣服   | 可售   |\n+----+--------+--------+\n1 row in set (0.00 sec)\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>有一个X姨夫,两个用户并发操作问题</p>\n<p>A先看到衣服: X加锁 -&gt; 试衣服 -&gt; 下单 -&gt; 付款 -&gt; 打包 -&gt; X解锁\nB也相对衣服: 发现X已经被A加锁了,等待X解锁。</p>\n<h2 id=\"二、锁知识\"> 二、锁知识</h2>\n<h3 id=\"锁类型\"> 锁类型</h3>\n<p>a. 读锁(共享锁):\nb. 写锁(互斥锁): 如果当前写操作没有完毕,则无法进行其他的写操作。</p>\n<h3 id=\"锁范围\"> 锁范围</h3>\n<ul>\n<li>innodb默认行锁(开销大,加锁慢,锁范围小,易死锁,不容器锁冲突,并发度高)</li>\n<li>MyISAM默认表锁(开销小,加锁块,无死锁,但是锁范围大容器锁冲突,并发度低)</li>\n</ul>\n<ol>\n<li>表锁(对一张表整体加锁)</li>\n<li>行锁(对一行数据进行加锁)</li>\n</ol>\n<hr>\n<h2 id=\"三、锁分析\"> 三、锁分析</h2>\n<h3 id=\"_1-查看加锁的表\"> 1. 查看加锁的表</h3>\n<p><code>show open tables;</code></p>\n<p>1代表加锁</p>\n<div><pre><code>mysql&gt; show open tables;\n+--------------------+---------------------------+--------+-------------+\n| Database           | Table                     | In_use | Name_locked |\n+--------------------+---------------------------+--------+-------------+\n| test               | emp                       |      0 |           0 |\n| test               | test_innodb_lock          |      0 |           0 |\n| test               | test03                    |      0 |           0 |\n| test               | teacher2                  |      0 |           0 |\n| test               | course2                   |      0 |           0 |\n| test               | book                      |      0 |           0 |\n| test               | shop                      |      1 |           0 |\n| test               | staffs                    |      0 |           0 |\n| test               | dept                      |      0 |           0 |\n+--------------------+---------------------------+--------+-------------+\n73 rows in set (0.00 sec)\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id=\"_2-查看锁的严重程度\"> 2. 查看锁的严重程度</h3>\n<p><code>show status like '%Table_locks%';</code></p>\n<div><pre><code>mysql&gt; show status like &#39;%Table_locks%&#39;;\n+-----------------------+-------+\n| Variable_name         | Value |\n+-----------------------+-------+\n| Table_locks_immediate | 79    |\n| Table_locks_waited    | 0     |\n+-----------------------+-------+\n2 rows in set (0.00 sec)\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><strong>Table_locks_immediate</strong> 能立马加锁\n<strong>Table_locks_waited</strong> 越大说明竞争越大</p>\n<p>建议:\nTable_locks_immediate/Table_locks_waited &gt; 5000,建议采用innodb,否则建议MyISAM。</p>\n<h2 id=\"四、模拟加表锁\"> 四、模拟加表锁</h2>\n<p><code>lock table 表1 read/write,表2 read/write</code></p>\n<div><pre><code>lock table shop write;\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"加表读锁\"> 加表读锁</h3>\n<p>如A会话,对shop表加了read锁,则该会话可以对shop表进行读操作,不能进行写操作。\n并且只能读自己加锁了的表,如下面列子最shop加锁,能读shop不能写shop,不能读test03</p>\n<p><strong>如果对shop表加了read锁,那么只能对shop进行读,其他任何操作都不行了</strong></p>\n<div><pre><code>mysql&gt; lock table shop read;\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql&gt; select * from shop\n    -&gt; ;\n+----+--------+-----------+\n| id | name   | status    |\n+----+--------+-----------+\n|  1 | 衣服   | 已占用    |\n+----+--------+-----------+\n1 row in set (0.00 sec)\n\nmysql&gt; update shop set status = &#39;可售&#39; where id = 1;\nERROR 1099 (HY000): Table &#39;shop&#39; was locked with a READ lock and can&#39;t be updated\nmysql&gt; select * from test03;\nERROR 1100 (HY000): Table &#39;test03&#39; was not locked with LOCK TABLES\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p><img src=\"https://img.springlearn.cn/blog/learn_1596460128000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>其他B会话中,对于shop表能读不能写,但是不影响操作其他表。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596460283000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"加表写锁\"> 加表写锁</h3>\n<ul>\n<li>会话A: lock table shop write;\n当前会话可以对加了锁的表进行任意操作;但是不能操作其他表。</li>\n<li>其他会话B:\n当会话A释放了锁,B才能对这个表进行增删改查;</li>\n</ul>\n<h2 id=\"五、模拟加行锁\"> 五、模拟加行锁</h2>\n<div><pre><code><span>create</span> <span>table</span> linelock\n<span>(</span>\n    id <span>int</span><span>(</span><span>5</span><span>)</span> <span>primary</span> <span>key</span> <span>auto_increment</span><span>,</span>\n    name <span>varchar</span><span>(</span><span>20</span><span>)</span>\n<span>)</span> <span>engine</span> <span>=</span> <span>innodb</span><span>;</span>\n\n<span>insert</span> <span>into</span> linelock<span>(</span>name<span>)</span> <span>values</span><span>(</span><span>'1'</span><span>)</span><span>;</span>\n<span>insert</span> <span>into</span> linelock<span>(</span>name<span>)</span> <span>values</span><span>(</span><span>'2'</span><span>)</span><span>;</span>\n<span>insert</span> <span>into</span> linelock<span>(</span>name<span>)</span> <span>values</span><span>(</span><span>'3'</span><span>)</span><span>;</span>\n<span>insert</span> <span>into</span> linelock<span>(</span>name<span>)</span> <span>values</span><span>(</span><span>'4'</span><span>)</span><span>;</span>\n<span>insert</span> <span>into</span> linelock<span>(</span>name<span>)</span> <span>values</span><span>(</span><span>'5'</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id=\"a窗口写操作\"> A窗口写操作</h3>\n<p><code>insert into linelock(name) values('6');</code></p>\n<p>此时B窗口执行update更新会被锁定。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596463371000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>当A会话commit之后B就能继续操作了。\n<img src=\"https://img.springlearn.cn/blog/learn_1596463461000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>行锁是通过事务进行解锁的。</p>\n<h3 id=\"行锁转表锁\"> 行锁转表锁</h3>\n<p>如果索引列进行了类型转换,则索引失效。</p>\n<p>A窗口执行\n<code>update linelock set name = 'ai' where name = 3;</code></p>\n<p>B窗口执行\n<code>update linelock set name = 'ax' where name = 4;</code></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596464724000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"间隙锁\"> 间隙锁</h3>\n<p>update linelock set name = 'x' where id &gt; 1 and id &lt; 8;</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596465102000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"行锁分析\"> 行锁分析</h3>\n<p><code>show status like '%innodb_row_lock%';</code></p>\n<div><pre><code>mysql&gt; show status like &#39;%innodb_row_lock%&#39;;\n+-------------------------------+--------+\n| Variable_name                 | Value  |\n+-------------------------------+--------+\n| Innodb_row_lock_current_waits | 1      |\n| Innodb_row_lock_time          | 207248 |\n| Innodb_row_lock_time_avg      | 34541  |\n| Innodb_row_lock_time_max      | 51605  |\n| Innodb_row_lock_waits         | 6      |\n+-------------------------------+--------+\n5 rows in set (0.00 sec)\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p><img src=\"https://img.springlearn.cn/blog/learn_1596465415000.png\" alt=\"\" loading=\"lazy\"></p>\n<table>\n<thead>\n<tr>\n<th>Variable_name</th>\n<th>Value</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Innodb_row_lock_current_waits</td>\n<td>当前正在等待的锁的数量</td>\n</tr>\n<tr>\n<td>Innodb_row_lock_time</td>\n<td>等待总时长,从系统启动到现在一共等待时间</td>\n</tr>\n<tr>\n<td>Innodb_row_lock_time_avg</td>\n<td>平均等待时长</td>\n</tr>\n<tr>\n<td>Innodb_row_lock_time_max</td>\n<td>最大等待时长</td>\n</tr>\n<tr>\n<td>Innodb_row_lock_waits</td>\n<td>等待的次数</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"查询语句加锁\"> 查询语句加锁</h3>\n<p><code>set autocommit=0;</code>\n<code>select * from linelock for update;</code></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596466172000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>最后求关注,求订阅,谢谢你的阅读!</p>\n",
      "image": "https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png",
      "date_published": "2022-01-04T14:58:20.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "如何找到垃圾SQL语句,你知道这些方式吗？",
      "url": "https://java.springlearn.cn/learn/databases/sql/%E5%9E%83%E5%9C%BESQL/",
      "id": "https://java.springlearn.cn/learn/databases/sql/%E5%9E%83%E5%9C%BESQL/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n<blockquote>\n<p>这篇文章主要是讲如何找到需要优化的SQL语句，即找到查询速度非常慢的SQL语句。</p>\n</blockquote>\n<h1 id=\"一、慢查询日志\"> 一、慢查询日志</h1>\n<h2 id=\"_1-何为慢查询日志\"> 1. 何为慢查询日志</h2>\n<ul>\n<li>慢查询日志是MySQL提供的一种日志记录，它用来记录查询响应时间超过阀值的SQL语句</li>\n<li>这个时间阀值通过参数 <code>long_query_time</code> 设置，如果SQL语句查询时间大于这个值，则会被记录到慢查询日志中，这个值默认是10秒</li>\n<li>MySQL默认不开启慢查询日志，在需要调优的时候可以手动开启，但是多少会对数据库性能有点影响</li>\n</ul>\n<h2 id=\"_2-如何开启慢查询日志\"> 2. 如何开启慢查询日志</h2>\n<p>查看是否开启了慢查询日志</p>\n<p><code>SHOW VARIABLES LIKE '%slow_query_log%'</code></p>\n<p>用命令方式开启慢查询日志，但是重启MySQL后此设置会失效</p>\n<p><code>set global slow_query_log = 1</code></p>\n<p>永久生效开启方式可以在my.cnf里进行配置，在<code>mysqld</code>下新增以下两个参数，重启MySQL即可生效</p>\n<div><pre><code>slow_query_log=1\nslow_query_log_file=日志文件存储路径\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h2 id=\"_3-慢查询时间阀值\"> 3. 慢查询时间阀值</h2>\n<p>查看慢查询时间阀值</p>\n<p><code>SHOW VARIABLES LIKE 'long_query_time%';</code></p>\n<p>修改慢查询时间阀值</p>\n<p><code>set global long_query_time=3;</code></p>\n<p>修改后的时间阀值生效</p>\n<p><code>需要重新连接或者新开一个回话才能看到修改值。</code></p>\n<p>在MySQL配置文件中修改时间阀值</p>\n<div><pre><code>[mysqld]下配置\nslow_query_log=1\nslow_query_log_file=日志文件存储路径\nlong_query_time=3\nlog_output=FILE\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h1 id=\"二、慢查询日志分析工具\"> 二、慢查询日志分析工具</h1>\n<p>慢查询日志可能会数据量非常大，那么我们如何快速找到需要优化的SQL语句呢，这个神奇诞生了，它就是mysqldumpshow。</p>\n<h2 id=\"_1-mysqldumpslow-help语法\"> 1. mysqldumpslow --help语法</h2>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596350361000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>通过mysqldumpslow --help可知这个命令是由三部分组成：mysqldumpslow <code>[日志查找选项] [日志文件存储位置]</code>。</p>\n<h2 id=\"_2-日志查找选项\"> 2. 日志查找选项</h2>\n<ul>\n<li>s：是表示按何种方式排序</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>c</td>\n<td>访问次数</td>\n</tr>\n<tr>\n<td>i</td>\n<td>锁定时间</td>\n</tr>\n<tr>\n<td>r</td>\n<td>返回记录</td>\n</tr>\n<tr>\n<td>t</td>\n<td>查询时间</td>\n</tr>\n<tr>\n<td>al</td>\n<td>平均锁定时间</td>\n</tr>\n<tr>\n<td>ar</td>\n<td>平均返回记录数</td>\n</tr>\n<tr>\n<td>at</td>\n<td>平均查询时间</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>t：即为返回前面多少条的数据</li>\n<li>g：后边搭配一个正则匹配模式，大小写不敏感的</li>\n</ul>\n<h2 id=\"_3-常用分析语法\"> 3. 常用分析语法</h2>\n<p>查找返回记录做多的10条SQL</p>\n<p><code>mysqldumpslow -s r -t 10 日志路径</code></p>\n<p>查找使用频率最高的10条SQL</p>\n<p><code>mysqldumpslow -s c -t 10 日志路径</code></p>\n<p>查找按照时间排序的前10条里包含左连接的SQL</p>\n<p><code>mysqldumpslow -s t -t 10 -g &quot;left join&quot; 日志路径</code></p>\n<p>通过more查看日志，防止爆屏</p>\n<p><code>mysqldumpslow -s r -t 10 日志路径 | more</code></p>\n",
      "image": "https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png",
      "date_published": "2022-01-04T14:58:20.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "阿里云自建服务器",
      "url": "https://java.springlearn.cn/learn/blog/aliyun/",
      "id": "https://java.springlearn.cn/learn/blog/aliyun/",
      "content_html": "<p>作为程序员,怎么可能不尝试一下,自己搭建服务器呢? 那么如何用一个最划算的价格，同时又选一个好的服务商呢。这里小编\n对自己的经验进行一个总结。感兴趣的可以去看看。</p>\n<p><a href=\"/learn/other/程序猿到底有没有必要买一台阿里云服务器/#_1-价格\">购买服务器要注意什么</a></p>\n",
      "date_published": "2022-07-09T04:36:00.000Z",
      "date_modified": "2022-07-09T04:36:00.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "海量数据模拟",
      "url": "https://java.springlearn.cn/learn/databases/sql/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E6%A8%A1%E6%8B%9F/",
      "id": "https://java.springlearn.cn/learn/databases/sql/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E6%A8%A1%E6%8B%9F/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n<h2 id=\"一、创建表\"> 一、创建表</h2>\n<div><pre><code><span>create</span> <span>table</span> dept\n<span>(</span>\n dno <span>int</span><span>(</span><span>5</span><span>)</span> <span>primary</span> <span>key</span> <span>default</span> <span>0</span><span>,</span>\n dname <span>varchar</span><span>(</span><span>20</span><span>)</span> <span>not</span> <span>null</span> <span>default</span> <span>''</span><span>,</span>\n loc <span>varchar</span><span>(</span><span>30</span><span>)</span> <span>default</span> <span>''</span>\n<span>)</span> <span>engine</span> <span>=</span><span>innodb</span> <span>default</span> <span>charset</span><span>=</span>utf8<span>;</span>\n\n<span>create</span> <span>table</span> emp\n<span>(</span>\n eid <span>int</span><span>(</span><span>5</span><span>)</span> <span>primary</span> <span>key</span><span>,</span>\n ename <span>varchar</span><span>(</span><span>20</span><span>)</span> <span>not</span> <span>null</span> <span>default</span> <span>''</span><span>,</span>\n job <span>varchar</span><span>(</span><span>20</span><span>)</span> <span>not</span> <span>null</span> <span>default</span> <span>''</span><span>,</span>\n deptno <span>int</span><span>(</span><span>5</span><span>)</span> <span>not</span> <span>null</span> <span>default</span> <span>0</span>\n<span>)</span> <span>engine</span> <span>=</span><span>innodb</span> <span>default</span>  <span>charset</span><span>=</span>utf8<span>;</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h2 id=\"二、存储函数插入海量数量\"> 二、存储函数插入海量数量</h2>\n<p>存储过程无return,存储函数有。</p>\n<h3 id=\"_1-创建存储函数生成id和name\"> 1. 创建存储函数生成id和name</h3>\n<p>name随机字符串</p>\n<div><pre><code>delimiter $\ncreate function randstring(n int) returns varchar(255)\nbegin \n    declare all_str varchar(100) default &#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;;\n    declare return_str varchar(255) default &#39;&#39;;\n    declare i int default 0;\n    while i &lt;n\n    do\n        set return_str = concat(return_str,substring(all_str,rand()*52,1));\n        set i = i+1;\n    end while;    \n    return return_str;\nend $\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p><code>ERROR 1418 (HY000): This function has none of DETERMINISTIC, NO SQL, or READS SQL DATA in its declaration and binary logging is enabled (you *might* want to use the less safe log_bin_trust_function_creators variable)</code></p>\n<p>如果开启了慢慢查询日志,在开启存储函数就会冲突,解决办法1就是管理慢日志查询。</p>\n<p>解决办法2:</p>\n<p><code>show variables like '%log_bin_trust_function_creators%';</code></p>\n<p><code>set global log_bin_trust_function_creators=1;</code></p>\n<p>id随机数</p>\n<div><pre><code>delimiter $\ncreate function rand_num()returns int(5)\nbegin\n    declare i int default 0;\n    set i = floor(rand() * 100);\n    return i;\nend $;    \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id=\"_2-通过存储过程插入海量数据emp\"> 2. 通过存储过程插入海量数据emp</h3>\n<div><pre><code>create procedure insert_emp(in eid_start int(10),in data_times int(10))\nbegin\n    declare i int default 0;\n    set autocommit = 0;\n    repeat\n        insert into emp values(eid_start + i,randstring(5),&#39;other&#39;,rand_num());\n        set i = i + 1;\n        until i = data_times\n    end repeat;   \n    commit;\nend $;    \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id=\"_2-通过存储过程插入海量数据dept\"> 2. 通过存储过程插入海量数据dept</h3>\n<div><pre><code>create procedure insert_dept(in dno_start int(10),in data_times int(10))\nbegin\n    declare i int default 0;\n    set autocommit = 0;\n    repeat\n        insert into dept values(dno_start+i,randstring(6),randstring(8));\n        set i = i + 1;\n        until i = data_times\n    end repeat;\ncommit;\nend$    \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id=\"_3-插入海量数据\"> 3. 插入海量数据</h3>\n<p><code>delimiter ;</code>分割符改回原来</p>\n<p>员工表插入80w条数据\n<code>call insert_emp(1000,800000);</code>\n部门表插入30条数据\n<code>call insert_dept(10,30);</code></p>\n<div><pre><code>mysql&gt; select count(1) from emp;\n+----------+\n| count(1) |\n+----------+\n|   800000 |\n+----------+\n1 row in set (0.05 sec)\n\nmysql&gt; select count(1) from dept;\n+----------+\n| count(1) |\n+----------+\n|       30 |\n+----------+\n1 row in set (0.00 sec)\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id=\"三、利用profiles分析海量数据\"> 三、利用profiles分析海量数据</h2>\n<h3 id=\"_1-打开profiles\"> 1. 打开profiles</h3>\n<div><pre><code>set profiling = on;\nshow variables like &#39;%profiling%&#39;;\n\nmysql&gt; set profiling = on;\nQuery OK, 0 rows affected, 1 warning (0.00 sec)\n\nmysql&gt; show variables like &#39;%profiling%&#39;;\n+------------------------+-------+\n| Variable_name          | Value |\n+------------------------+-------+\n| have_profiling         | YES   |\n| profiling              | ON    |\n| profiling_history_size | 15    |\n+------------------------+-------+\n3 rows in set (0.00 sec)\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p><img src=\"https://img.springlearn.cn/blog/learn_1596455359000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_2-查询每条耗时\"> 2. 查询每条耗时</h3>\n<p>profiles会记录每个sql的耗时</p>\n<div><pre><code>mysql&gt; show profiles;\n+----------+------------+-----------------------------------+\n| Query_ID | Duration   | Query                             |\n+----------+------------+-----------------------------------+\n|        1 | 0.00164000 | show variables like &#39;%profiling%&#39; |\n|        2 | 0.04513900 | select count(1) from emp          |\n|        3 | 0.00056200 | select count(1) from dept         |\n+----------+------------+-----------------------------------+\n3 rows in set, 1 warning (0.00 sec)\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>但是这样不能精确匹配到耗时在哪里。此时可以使用profile精确来分析sql</p>\n<h3 id=\"_3-精确查询耗时\"> 3. 精确查询耗时</h3>\n<p><strong>精确</strong>\n根据上面的Query_ID来精确查找\n<code>show profile all for query 2;</code></p>\n<div><pre><code>+--------------------------------+----------+----------+------------+-------------------+---------------------+--------------+---------------+---------------+-------------------+-------------------+-------------------+-------+-------------------------+----------------------+-------------+\n| Status                         | Duration | CPU_user | CPU_system | Context_voluntary | Context_involuntary | Block_ops_in | Block_ops_out | Messages_sent | Messages_received | Page_faults_major | Page_faults_minor | Swaps | Source_function         | Source_file          | Source_line |\n+--------------------------------+----------+----------+------------+-------------------+---------------------+--------------+---------------+---------------+-------------------+-------------------+-------------------+-------+-------------------------+----------------------+-------------+\n| starting                       | 0.000106 | 0.000094 |   0.000012 |                 0 |                   0 |            0 |             0 |             0 |                 0 |                 0 |                 0 |     0 | NULL                    | NULL                 |        NULL |\n| Executing hook on transaction  | 0.000008 | 0.000004 |   0.000004 |                 0 |                   0 |            0 |             0 |             0 |                 0 |                 0 |                 0 |     0 | launch_hook_trans_begin | rpl_handler.cc       |        1106 |\n| starting                       | 0.000013 | 0.000010 |   0.000002 |                 0 |                   0 |            0 |             0 |             0 |                 0 |                 0 |                 0 |     0 | launch_hook_trans_begin | rpl_handler.cc       |        1108 |\n| checking permissions           | 0.000009 | 0.000007 |   0.000003 |                 0 |                   0 |            0 |             0 |             0 |                 0 |                 0 |                 0 |     0 | check_access            | sql_authorization.cc |        2202 |\n| Opening tables                 | 0.000047 | 0.000045 |   0.000002 |                 0 |                   0 |            0 |             0 |             0 |                 0 |                 0 |                 0 |     0 | open_tables             | sql_base.cc          |        5587 |\n| init                           | 0.000012 | 0.000008 |   0.000003 |                 0 |                   0 |            0 |             0 |             0 |                 0 |                 0 |                 0 |     0 | execute                 | sql_select.cc        |         661 |\n| System lock                    | 0.000014 | 0.000012 |   0.000003 |                 0 |                   0 |            0 |             0 |             0 |                 0 |                 0 |                 0 |     0 | mysql_lock_tables       | lock.cc              |         332 |\n| optimizing                     | 0.000010 | 0.000007 |   0.000002 |                 0 |                   0 |            0 |             0 |             0 |                 0 |                 0 |                 0 |     0 | optimize                | sql_optimizer.cc     |         213 |\n| statistics                     | 0.000037 | 0.000023 |   0.000014 |                 0 |                   0 |            0 |             0 |             0 |                 0 |                 0 |                 1 |     0 | optimize                | sql_optimizer.cc     |         423 |\n| preparing                      | 0.000025 | 0.000023 |   0.000003 |                 0 |                   0 |            0 |             0 |             0 |                 0 |                 0 |                 0 |     0 | optimize                | sql_optimizer.cc     |         497 |\n| executing                      | 0.000007 | 0.000004 |   0.000003 |                 0 |                   0 |            0 |             0 |             0 |                 0 |                 0 |                 0 |     0 | exec                    | sql_executor.cc      |         228 |\n| Sending data                   | 0.044768 | 0.072019 |   0.003191 |                 0 |                 810 |            0 |             0 |             0 |                 0 |                 0 |                 9 |     0 | exec                    | sql_executor.cc      |         304 |\n| end                            | 0.000018 | 0.000009 |   0.000010 |                 0 |                   0 |            0 |             0 |             0 |                 0 |                 0 |                 0 |     0 | execute                 | sql_select.cc        |         714 |\n| query end                      | 0.000006 | 0.000004 |   0.000002 |                 0 |                   0 |            0 |             0 |             0 |                 0 |                 0 |                 0 |     0 | mysql_execute_command   | sql_parse.cc         |        4520 |\n| waiting for handler commit     | 0.000013 | 0.000011 |   0.000001 |                 0 |                   0 |            0 |             0 |             0 |                 0 |                 0 |                 0 |     0 | ha_commit_trans         | handler.cc           |        1533 |\n| closing tables                 | 0.000009 | 0.000008 |   0.000002 |                 0 |                   0 |            0 |             0 |             0 |                 0 |                 0 |                 0 |     0 | mysql_execute_command   | sql_parse.cc         |        4566 |\n| freeing items                  | 0.000026 | 0.000012 |   0.000013 |                 0 |                   0 |            0 |             0 |             1 |                 0 |                 0 |                 0 |     0 | mysql_parse             | sql_parse.cc         |        5237 |\n| cleaning up                    | 0.000011 | 0.000009 |   0.000002 |                 0 |                   0 |            0 |             0 |             0 |                 0 |                 0 |                 0 |     0 | dispatch_command        | sql_parse.cc         |        2147 |\n+--------------------------------+----------+----------+------------+-------------------+---------------------+--------------+---------------+---------------+-------------------+-------------------+-------------------+-------+-------------------------+----------------------+-------------+\n18 rows in set, 1 warning (0.00 sec)\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>我们可以看到信息太多了,我们其实只用关系几列的数据就行了。</p>\n<div><pre><code>mysql&gt; show profile cpu,block io for query 2;\n+--------------------------------+----------+----------+------------+--------------+---------------+\n| Status                         | Duration | CPU_user | CPU_system | Block_ops_in | Block_ops_out |\n+--------------------------------+----------+----------+------------+--------------+---------------+\n| starting                       | 0.000106 | 0.000094 |   0.000012 |            0 |             0 |\n| Executing hook on transaction  | 0.000008 | 0.000004 |   0.000004 |            0 |             0 |\n| starting                       | 0.000013 | 0.000010 |   0.000002 |            0 |             0 |\n| checking permissions           | 0.000009 | 0.000007 |   0.000003 |            0 |             0 |\n| Opening tables                 | 0.000047 | 0.000045 |   0.000002 |            0 |             0 |\n| init                           | 0.000012 | 0.000008 |   0.000003 |            0 |             0 |\n| System lock                    | 0.000014 | 0.000012 |   0.000003 |            0 |             0 |\n| optimizing                     | 0.000010 | 0.000007 |   0.000002 |            0 |             0 |\n| statistics                     | 0.000037 | 0.000023 |   0.000014 |            0 |             0 |\n| preparing                      | 0.000025 | 0.000023 |   0.000003 |            0 |             0 |\n| executing                      | 0.000007 | 0.000004 |   0.000003 |            0 |             0 |\n| Sending data                   | 0.044768 | 0.072019 |   0.003191 |            0 |             0 |\n| end                            | 0.000018 | 0.000009 |   0.000010 |            0 |             0 |\n| query end                      | 0.000006 | 0.000004 |   0.000002 |            0 |             0 |\n| waiting for handler commit     | 0.000013 | 0.000011 |   0.000001 |            0 |             0 |\n| closing tables                 | 0.000009 | 0.000008 |   0.000002 |            0 |             0 |\n| freeing items                  | 0.000026 | 0.000012 |   0.000013 |            0 |             0 |\n| cleaning up                    | 0.000011 | 0.000009 |   0.000002 |            0 |             0 |\n+--------------------------------+----------+----------+------------+--------------+---------------+\n18 rows in set, 1 warning (0.01 sec)\n\nmysql&gt;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><h3 id=\"_4-全局查询日志\"> 4. 全局查询日志</h3>\n<p>仅仅在调优和开发中使用,生产要关闭</p>\n<p><code>show variables like '%general_log%';</code></p>\n<p>开启全局日志记录并将sql都写入到表中</p>\n<div><pre><code>set global general_log = 1;\nset global log_output = &#39;table&#39;;\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><div><pre><code>mysql&gt; show variables like &#39;%general_log%&#39;;\n+------------------+------------------------------------+\n| Variable_name    | Value                              |\n+------------------+------------------------------------+\n| general_log      | OFF                                |\n| general_log_file | /usr/local/var/mysql/localhost.log |\n+------------------+------------------------------------+\n2 rows in set (0.01 sec)\n\nmysql&gt; set global general_log = 1;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; show variables like &#39;%general_log%&#39;;\n+------------------+------------------------------------+\n| Variable_name    | Value                              |\n+------------------+------------------------------------+\n| general_log      | ON                                 |\n| general_log_file | /usr/local/var/mysql/localhost.log |\n+------------------+------------------------------------+\n2 rows in set (0.01 sec)\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>开启之后就可以在mysql库中的general_log表中进行查询</p>\n<p><code>select * from mysql.general_log;</code>\n<img src=\"https://img.springlearn.cn/blog/learn_1596457337000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>将sql设置到文件中</p>\n<div><pre><code>set global general_log = 1;\nset global log_output = &#39;file&#39;;\nset global general_log_file=&#39;/Users/liuxin/general.log&#39;;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><img src=\"https://img.springlearn.cn/blog/learn_1596457737000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>最后求关注,求订阅,谢谢你的阅读!</p>\n",
      "image": "https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png",
      "date_published": "2022-01-04T14:58:20.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Java代码规范全部奉上",
      "url": "https://java.springlearn.cn/learn/design/Java%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E5%85%A8%E9%83%A8%E5%A5%89%E4%B8%8A/",
      "id": "https://java.springlearn.cn/learn/design/Java%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E5%85%A8%E9%83%A8%E5%A5%89%E4%B8%8A/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/learn_1598165820000.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p>写代码就像写文章, 好的代码就像好的文章,结构严谨,构思清晰。写代码就像写文章, 一不留神就成流水账，为避免这种情况作为软件开发工程师，重要的是设计而不是实现。</p>\n</blockquote>\n<p><strong>在一个团队中,由于不同经验的开发导致编程风格可能会出现非常混乱的情况,从而导致开发成本上升。难以维护。所以代码规范就显得异常重要了。</strong></p>\n<p>本篇文章就是给出编程命名的建议,仅供参考,但是其目的是为了统一规范,提高编程能力,降低开发成本,减少代码维护成本。</p>\n<p>契约精神: 做到有法可依，有章可循。</p>\n<h2 id=\"一、类命名\"> 一、类命名</h2>\n<h3 id=\"_1-抽象类\"> 1. 抽象类</h3>\n<p>适用的设计模式为模板模式。抽象是自下往上的设计。由具体实现推断出抽象方法。建议以Abstract开头。</p>\n<table>\n<thead>\n<tr>\n<th>建议</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Abstract 或者 Base 开头</td>\n<td>BaseUserService、AbstractUserService</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_2-枚举类\"> 2. 枚举类</h3>\n<ul>\n<li>枚举是由JVM来保证的单例。可以用来做单例类。</li>\n<li>枚举类常用作值判断,不建议每次进行循环判断得到实例。建议由内部维护一个map类型,当做cache。此方法建议放在static静态代码块中实现</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>建议</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Enum 作为后缀</td>\n<td>GenderEnum</td>\n</tr>\n</tbody>\n</table>\n<div><pre><code>public enum ProtocolEnum {\n\n    /**\n     * ECHO协议\n     */\n    ECHO(1, null),\n\n    /**\n     * mojito协议\n     */\n    MOJITO(2, MojitoProtocol.class);\n\n    private byte type;\n\n    private Class&lt;? extends Protocol&gt; protocol;\n\n    private static Map&lt;Byte, ProtocolEnum&gt; cache = new HashMap&lt;&gt;();\n\n    static {\n        for (ProtocolEnum protocolEnum : values()) {\n            cache.put(protocolEnum.type, protocolEnum);\n        }\n    }\n\n    public static ProtocolEnum byType(byte type) {\n        return cache.get(type);\n    }\n}    \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><h3 id=\"_3-工具类\"> 3. 工具类</h3>\n<p>工具类常为无状态对象,无状态对象都是线程安全对象,建议使用 <code>final</code> 修饰。</p>\n<p>工具类中避免出现业务属性, 如果出现业务属性,抽象出领域层</p>\n<table>\n<thead>\n<tr>\n<th>建议</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Utils作为后缀</td>\n<td>StringUtils</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_4-异常类\"> 4. 异常类</h3>\n<p>建议保持异常链。</p>\n<table>\n<thead>\n<tr>\n<th>建议</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Exception结尾</td>\n<td>RuntimeException</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_5-接口实现类\"> 5. 接口实现类</h3>\n<p>众所周知</p>\n<table>\n<thead>\n<tr>\n<th>建议</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>接口名+ Impl</td>\n<td>UserServiceImpl</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_6-设计模式相关类\"> 6. 设计模式相关类</h3>\n<table>\n<thead>\n<tr>\n<th>建议</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Builder，Factory等</td>\n<td>当使用到设计模式时，需要使用对应的设计模式作为后缀，如ThreadFactory</td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"https://img.springlearn.cn/27c9d5187cd283f8d160ec1ed2b5ac89.jpg\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_7-处理特定功能的\"> 7. 处理特定功能的</h3>\n<p>其主要的目的是代码可重复使用。</p>\n<table>\n<thead>\n<tr>\n<th>建议</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Handler，Predicate, Validator</td>\n<td>表示处理器，校验器，断言，这些类工厂还有配套的方法名如handle，predicate，validate</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_8-测试类\"> 8. 测试类</h3>\n<table>\n<thead>\n<tr>\n<th>建议</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Test结尾</td>\n<td>UserServiceTest， 表示用来测试UserService类的</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_9-领域模型载体\"> 9. 领域模型载体</h3>\n<table>\n<thead>\n<tr>\n<th>建议</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>DTO/*Request</td>\n<td>数据传输对象</td>\n</tr>\n<tr>\n<td>BO</td>\n<td>业务对象</td>\n</tr>\n<tr>\n<td>VO</td>\n<td>数据展示对象,用于承载页面数据</td>\n</tr>\n<tr>\n<td>DO</td>\n<td>数据持久化对象</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"二、方法命名\"> 二、方法命名</h2>\n<p>参考于网络。</p>\n<h3 id=\"_1-布尔判断方法\"> 1. 布尔判断方法</h3>\n<p>注：Prefix-前缀，Suffix-后缀，Alone-单独使用</p>\n<table>\n<thead>\n<tr>\n<th><strong>位置</strong></th>\n<th><strong>单词</strong></th>\n<th><strong>意义</strong></th>\n<th><strong>例</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Prefix</td>\n<td>is</td>\n<td>对象是否符合期待的状态</td>\n<td>isValid</td>\n</tr>\n<tr>\n<td>Prefix</td>\n<td>can</td>\n<td>对象<strong>能否执行</strong>所期待的动作</td>\n<td>canRemove</td>\n</tr>\n<tr>\n<td>Prefix</td>\n<td>should</td>\n<td>调用方执行某个命令或方法是<strong>好还是不好</strong>,<strong>应不应该</strong>，或者说<strong>推荐还是不推荐</strong></td>\n<td>shouldMigrate</td>\n</tr>\n<tr>\n<td>Prefix</td>\n<td>has</td>\n<td>对象<strong>是否持有</strong>所期待的数据和属性</td>\n<td>hasObservers</td>\n</tr>\n<tr>\n<td>Prefix</td>\n<td>needs</td>\n<td>调用方<strong>是否需要</strong>执行某个命令或方法</td>\n<td>needsMigrate</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_2-检查的方法\"> 2. 检查的方法</h3>\n<p>注：Prefix-前缀，Suffix-后缀，Alone-单独使用</p>\n<table>\n<thead>\n<tr>\n<th><strong>单词</strong></th>\n<th><strong>意义</strong></th>\n<th><strong>例</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ensure</td>\n<td>检查是否为期待的状态，不是则抛出异常或返回error code</td>\n<td>ensureCapacity</td>\n</tr>\n<tr>\n<td>validate</td>\n<td>检查是否为正确的状态，不是则抛出异常或返回error code</td>\n<td>validateInputs</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_3-按需求才执行的方法\"> 3. 按需求才执行的方法</h3>\n<p>注：Prefix-前缀，Suffix-后缀，Alone-单独使用</p>\n<table>\n<thead>\n<tr>\n<th><strong>位置</strong></th>\n<th><strong>单词</strong></th>\n<th><strong>意义</strong></th>\n<th><strong>例</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Suffix</td>\n<td>IfNeeded</td>\n<td>需要的时候执行，不需要的时候什么都不做</td>\n<td>drawIfNeeded</td>\n</tr>\n<tr>\n<td>Prefix</td>\n<td>might</td>\n<td>同上</td>\n<td>mightCreate</td>\n</tr>\n<tr>\n<td>Prefix</td>\n<td>try</td>\n<td>尝试执行，失败时抛出异常或是返回errorcode</td>\n<td>tryCreate</td>\n</tr>\n<tr>\n<td>Suffix</td>\n<td>OrDefault</td>\n<td>尝试执行，失败时返回默认值</td>\n<td>getOrDefault</td>\n</tr>\n<tr>\n<td>Suffix</td>\n<td>OrElse</td>\n<td>尝试执行、失败时返回实际参数中指定的值</td>\n<td>getOrElse</td>\n</tr>\n<tr>\n<td>Prefix</td>\n<td>force</td>\n<td>强制尝试执行。error抛出异常或是返回值</td>\n<td>forceCreate, forceStop</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_4-异步相关方法\"> 4. 异步相关方法</h3>\n<p>注：Prefix-前缀，Suffix-后缀，Alone-单独使用</p>\n<table>\n<thead>\n<tr>\n<th><strong>位置</strong></th>\n<th><strong>单词</strong></th>\n<th><strong>意义</strong></th>\n<th><strong>例</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Prefix</td>\n<td>blocking</td>\n<td>线程阻塞方法</td>\n<td>blockingGetUser</td>\n</tr>\n<tr>\n<td>Suffix</td>\n<td>InBackground</td>\n<td>执行在后台的线程</td>\n<td>doInBackground</td>\n</tr>\n<tr>\n<td>Suffix</td>\n<td>Async</td>\n<td>异步方法</td>\n<td>sendAsync</td>\n</tr>\n<tr>\n<td>Suffix</td>\n<td>Sync</td>\n<td>对应已有异步方法的同步方法</td>\n<td>sendSync</td>\n</tr>\n<tr>\n<td>Prefix or Alone</td>\n<td>schedule</td>\n<td>Job和Task放入队列</td>\n<td>schedule, scheduleJob</td>\n</tr>\n<tr>\n<td>Prefix or Alone</td>\n<td>post</td>\n<td>同上</td>\n<td>postJob</td>\n</tr>\n<tr>\n<td>Prefix or Alone</td>\n<td>execute</td>\n<td>执行异步方法（注：我一般拿这个做同步方法名）</td>\n<td>execute, executeTask</td>\n</tr>\n<tr>\n<td>Prefix or Alone</td>\n<td>start</td>\n<td>同上</td>\n<td>start, startJob</td>\n</tr>\n<tr>\n<td>Prefix or Alone</td>\n<td>cancel</td>\n<td>停止异步方法</td>\n<td>cancel, cancelJob</td>\n</tr>\n<tr>\n<td>Prefix or Alone</td>\n<td>stop</td>\n<td>同上</td>\n<td>stop, stopJob</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_5-回调方法\"> 5. 回调方法</h3>\n<p>注：Prefix-前缀，Suffix-后缀，Alone-单独使用</p>\n<table>\n<thead>\n<tr>\n<th><strong>位置</strong></th>\n<th><strong>单词</strong></th>\n<th><strong>意义</strong></th>\n<th><strong>例</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Prefix</td>\n<td>on</td>\n<td>事件发生时执行</td>\n<td>onCompleted</td>\n</tr>\n<tr>\n<td>Prefix</td>\n<td>before</td>\n<td>事件发生前执行</td>\n<td>beforeUpdate</td>\n</tr>\n<tr>\n<td>Prefix</td>\n<td>pre</td>\n<td>同上</td>\n<td>preUpdate</td>\n</tr>\n<tr>\n<td>Prefix</td>\n<td>will</td>\n<td>同上</td>\n<td>willUpdate</td>\n</tr>\n<tr>\n<td>Prefix</td>\n<td>after</td>\n<td>事件发生后执行</td>\n<td>afterUpdate</td>\n</tr>\n<tr>\n<td>Prefix</td>\n<td>post</td>\n<td>同上</td>\n<td>postUpdate</td>\n</tr>\n<tr>\n<td>Prefix</td>\n<td>did</td>\n<td>同上</td>\n<td>didUpdate</td>\n</tr>\n<tr>\n<td>Prefix</td>\n<td>should</td>\n<td>确认事件是否可以发生时执行</td>\n<td>shouldUpdate</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_6-操作对象生命周期的方法\"> 6. 操作对象生命周期的方法</h3>\n<p>注：Prefix-前缀，Suffix-后缀，Alone-单独使用</p>\n<table>\n<thead>\n<tr>\n<th><strong>单词</strong></th>\n<th><strong>意义</strong></th>\n<th><strong>例</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>initialize</td>\n<td>初始化。也可作为延迟初始化使用</td>\n<td>initialize</td>\n</tr>\n<tr>\n<td>pause</td>\n<td>暂停</td>\n<td>onPause ，pause</td>\n</tr>\n<tr>\n<td>stop</td>\n<td>停止</td>\n<td>onStop，stop</td>\n</tr>\n<tr>\n<td>abandon</td>\n<td>销毁的替代</td>\n<td>abandon</td>\n</tr>\n<tr>\n<td>destroy</td>\n<td>同上</td>\n<td>destroy</td>\n</tr>\n<tr>\n<td>dispose</td>\n<td>同上</td>\n<td>dispose</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_7-与集合操作相关的方法\"> 7. 与集合操作相关的方法</h3>\n<p>注：Prefix-前缀，Suffix-后缀，Alone-单独使用</p>\n<table>\n<thead>\n<tr>\n<th><strong>单词</strong></th>\n<th><strong>意义</strong></th>\n<th><strong>例</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>contains</td>\n<td>是否持有与指定对象相同的对象</td>\n<td>contains</td>\n</tr>\n<tr>\n<td>add</td>\n<td>添加</td>\n<td>addJob</td>\n</tr>\n<tr>\n<td>append</td>\n<td>添加</td>\n<td>appendJob</td>\n</tr>\n<tr>\n<td>insert</td>\n<td>插入到下标n</td>\n<td>insertJob</td>\n</tr>\n<tr>\n<td>put</td>\n<td>添加与key对应的元素</td>\n<td>putJob</td>\n</tr>\n<tr>\n<td>remove</td>\n<td>移除元素</td>\n<td>removeJob</td>\n</tr>\n<tr>\n<td>enqueue</td>\n<td>添加到队列的最末位</td>\n<td>enqueueJob</td>\n</tr>\n<tr>\n<td>dequeue</td>\n<td>从队列中头部取出并移除</td>\n<td>dequeueJob</td>\n</tr>\n<tr>\n<td>push</td>\n<td>添加到栈头</td>\n<td>pushJob</td>\n</tr>\n<tr>\n<td>pop</td>\n<td>从栈头取出并移除</td>\n<td>popJob</td>\n</tr>\n<tr>\n<td>peek</td>\n<td>从栈头取出但不移除</td>\n<td>peekJob</td>\n</tr>\n<tr>\n<td>find</td>\n<td>寻找符合条件的某物</td>\n<td>findById</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_8-数据增删改查相关的方法\"> 8. 数据增删改查相关的方法</h3>\n<p>注：Prefix-前缀，Suffix-后缀，Alone-单独使用</p>\n<table>\n<thead>\n<tr>\n<th><strong>单词</strong></th>\n<th><strong>意义</strong></th>\n<th><strong>例</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>create</td>\n<td>新创建</td>\n<td>createAccount</td>\n</tr>\n<tr>\n<td>new</td>\n<td>新创建</td>\n<td>newAccount</td>\n</tr>\n<tr>\n<td>from</td>\n<td>从既有的某物新建，或是从其他的数据新建</td>\n<td>fromConfig</td>\n</tr>\n<tr>\n<td>to</td>\n<td>转换</td>\n<td>toString</td>\n</tr>\n<tr>\n<td>update</td>\n<td>更新既有某物</td>\n<td>updateAccount</td>\n</tr>\n<tr>\n<td>load</td>\n<td>读取</td>\n<td>loadAccount</td>\n</tr>\n<tr>\n<td>fetch</td>\n<td>远程读取</td>\n<td>fetchAccount</td>\n</tr>\n<tr>\n<td>delete</td>\n<td>删除</td>\n<td>deleteAccount</td>\n</tr>\n<tr>\n<td>remove</td>\n<td>删除</td>\n<td>removeAccount</td>\n</tr>\n<tr>\n<td>save</td>\n<td>保存</td>\n<td>saveAccount</td>\n</tr>\n<tr>\n<td>store</td>\n<td>保存</td>\n<td>storeAccount</td>\n</tr>\n<tr>\n<td>commit</td>\n<td>保存</td>\n<td>commitChange</td>\n</tr>\n<tr>\n<td>apply</td>\n<td>保存或应用</td>\n<td>applyChange</td>\n</tr>\n<tr>\n<td>clear</td>\n<td>清除数据或是恢复到初始状态</td>\n<td>clearAll</td>\n</tr>\n<tr>\n<td>reset</td>\n<td>清除数据或是恢复到初始状态</td>\n<td>resetAll</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_9-成对出现的动词\"> 9. 成对出现的动词</h3>\n<p>注：Prefix-前缀，Suffix-后缀，Alone-单独使用</p>\n<table>\n<thead>\n<tr>\n<th><strong>单词</strong></th>\n<th><strong>意义</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>get获取</td>\n<td>set 设置</td>\n</tr>\n<tr>\n<td>add 增加</td>\n<td>remove 删除</td>\n</tr>\n<tr>\n<td>create 创建</td>\n<td>destory 移除</td>\n</tr>\n<tr>\n<td>start 启动</td>\n<td>stop 停止</td>\n</tr>\n<tr>\n<td>open 打开</td>\n<td>close 关闭</td>\n</tr>\n<tr>\n<td>read 读取</td>\n<td>write 写入</td>\n</tr>\n<tr>\n<td>load 载入</td>\n<td>save 保存</td>\n</tr>\n<tr>\n<td>create 创建</td>\n<td>destroy 销毁</td>\n</tr>\n<tr>\n<td>begin 开始</td>\n<td>end 结束</td>\n</tr>\n<tr>\n<td>backup 备份</td>\n<td>restore 恢复</td>\n</tr>\n<tr>\n<td>import 导入</td>\n<td>export 导出</td>\n</tr>\n<tr>\n<td>split 分割</td>\n<td>merge 合并</td>\n</tr>\n<tr>\n<td>inject 注入</td>\n<td>extract 提取</td>\n</tr>\n<tr>\n<td>attach 附着</td>\n<td>detach 脱离</td>\n</tr>\n<tr>\n<td>bind 绑定</td>\n<td>separate 分离</td>\n</tr>\n<tr>\n<td>view 查看</td>\n<td>browse 浏览</td>\n</tr>\n<tr>\n<td>edit 编辑</td>\n<td>modify 修改</td>\n</tr>\n<tr>\n<td>select 选取</td>\n<td>mark 标记</td>\n</tr>\n<tr>\n<td>copy 复制</td>\n<td>paste 粘贴</td>\n</tr>\n<tr>\n<td>undo 撤销</td>\n<td>redo 重做</td>\n</tr>\n<tr>\n<td>insert 插入</td>\n<td>delete 移除</td>\n</tr>\n<tr>\n<td>add 加入</td>\n<td>append 添加</td>\n</tr>\n<tr>\n<td>clean 清理</td>\n<td>clear 清除</td>\n</tr>\n<tr>\n<td>index 索引</td>\n<td>sort 排序</td>\n</tr>\n<tr>\n<td>find 查找</td>\n<td>search 搜索</td>\n</tr>\n<tr>\n<td>increase 增加</td>\n<td>decrease 减少</td>\n</tr>\n<tr>\n<td>play 播放</td>\n<td>pause 暂停</td>\n</tr>\n<tr>\n<td>launch 启动</td>\n<td>run 运行</td>\n</tr>\n<tr>\n<td>compile 编译</td>\n<td>execute 执行</td>\n</tr>\n<tr>\n<td>debug 调试</td>\n<td>trace 跟踪</td>\n</tr>\n<tr>\n<td>observe 观察</td>\n<td>listen 监听</td>\n</tr>\n<tr>\n<td>build 构建</td>\n<td>publish 发布</td>\n</tr>\n<tr>\n<td>input 输入</td>\n<td>output 输出</td>\n</tr>\n<tr>\n<td>encode 编码</td>\n<td>decode 解码</td>\n</tr>\n<tr>\n<td>encrypt 加密</td>\n<td>decrypt 解密</td>\n</tr>\n<tr>\n<td>compress 压缩</td>\n<td>decompress 解压缩</td>\n</tr>\n<tr>\n<td>pack 打包</td>\n<td>unpack 解包</td>\n</tr>\n<tr>\n<td>parse 解析</td>\n<td>emit 生成</td>\n</tr>\n<tr>\n<td>connect 连接</td>\n<td>disconnect 断开</td>\n</tr>\n<tr>\n<td>send 发送</td>\n<td>receive 接收</td>\n</tr>\n<tr>\n<td>download 下载</td>\n<td>upload 上传</td>\n</tr>\n<tr>\n<td>refresh 刷新</td>\n<td>synchronize 同步</td>\n</tr>\n<tr>\n<td>update 更新</td>\n<td>revert 复原</td>\n</tr>\n<tr>\n<td>lock 锁定</td>\n<td>unlock 解锁</td>\n</tr>\n<tr>\n<td>check out 签出</td>\n<td>check in 签入</td>\n</tr>\n<tr>\n<td>submit 提交</td>\n<td>commit 交付</td>\n</tr>\n<tr>\n<td>push 推</td>\n<td>pull 拉</td>\n</tr>\n<tr>\n<td>expand 展开</td>\n<td>collapse 折叠</td>\n</tr>\n<tr>\n<td>begin 起始</td>\n<td>end 结束</td>\n</tr>\n<tr>\n<td>start 开始</td>\n<td>finish 完成</td>\n</tr>\n<tr>\n<td>enter 进入</td>\n<td>exit 退出</td>\n</tr>\n<tr>\n<td>abort 放弃</td>\n<td>quit 离开</td>\n</tr>\n<tr>\n<td>obsolete 废弃</td>\n<td>depreciate 废旧</td>\n</tr>\n<tr>\n<td>collect 收集</td>\n<td>aggregate 聚集</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_10-获取必须的参数\"> 10. 获取必须的参数</h3>\n<table>\n<thead>\n<tr>\n<th>getRequiredProperty</th>\n<th>获取必须的参数,否则报错,该方法一般都要抛出异常</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>getProperty</td>\n<td>非必须参数,可以返回null，不报错，调用方自行判断处理逻辑</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_11-获取数据并对数据进行某种处理\"> 11. 获取数据并对数据进行某种处理</h3>\n<p>注：Prefix-前缀，Suffix-后缀，Alone-单独使用</p>\n<table>\n<thead>\n<tr>\n<th>位置</th>\n<th>单词</th>\n<th>意义</th>\n<th>例子</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Prefix</td>\n<td>resolve</td>\n<td>解决某些问题,比如对文本占位符进行填充,并获取到填充后的值</td>\n<td>resolvePlaceholders</td>\n</tr>\n<tr>\n<td>Suffix</td>\n<td>Placeholders</td>\n<td>占位符相关命名</td>\n<td>resolvePlaceholders</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"三、方法编程建议\"> 三、方法编程建议</h2>\n<h3 id=\"_1-方法复杂度\"> 1. 方法复杂度</h3>\n<p>凡是逻辑判断语句均为复杂度。当一个方法中出现了大于等于10个复杂度。建议根据</p>\n<p>方法实现进行业务抽离。两个建议点(1. 方法单一职责 2. 方法可重复利用 3. 是否能用策略模式或者命令模式)</p>\n<h3 id=\"_2-方法长度及宽度\"> 2.方法长度及宽度</h3>\n<p>长度: 方法的长度建议控制在80-120行以内。满足一屏可以放下。\n宽度: 当方法超过3个及以上入参,建议使用对象封装(对象容易后期扩展,且不会出现眼花缭乱现象)</p>\n<h3 id=\"_3-关注方法优化编辑器提示\"> 3.关注方法优化编辑器提示</h3>\n<p>减少出现黄色警告⚠️, 最好不要出现警告。编辑器的警告都是优化点,需要在编程时候考虑进去。</p>\n<p>eg: 性能优化、命名不规范、重复代码</p>\n<p><img src=\"https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/a/21643544635/2678603850/7fbfc8ab-22ca-4f92-be04-31c4d1b704e3.png\" alt=\"img\" loading=\"lazy\"></p>\n<h3 id=\"_4-方法重复代码\"> 4.方法重复代码</h3>\n<p>贫血模型的标志性问题</p>\n<p>重复代码编辑器会提出警告,此种现象,强烈建议不要出现</p>\n<h3 id=\"_5-方法注释\"> 5. 方法注释</h3>\n<p>注释是必须要做的(先写注释在做实现)，重在设计。</p>\n<p>代码是公司财产, 要对自己对公司对后人负责,先写注释再做实现。</p>\n<h2 id=\"四、项目依赖模型\"> 四、项目依赖模型</h2>\n<h3 id=\"_1-领域设计的认识\"> 1. 领域设计的认识</h3>\n<p>领域划分,用另外一个词形容也非常的合适,就是业务模块化。所有能力都进行能力化抽象,形成模块,形成领域。 当遇到新的业务逻辑,底层的数据结构和数据关系肯定也是一样的。那么就可以像堆积木一样,根据这些模块快速的组装成新的业务逻辑。快速的实现业务的迭代和升级。</p>\n<p>关于这个问题,需要结合自己的业务系统来进行抽象和设计。</p>\n<p>设计核心: 用面向对象的设计思想对业务进行解耦来做到领域划分。</p>\n<h3 id=\"_2-层次划分\"> 2. 层次划分</h3>\n<h4 id=\"基础层-外部调用-db操作\"> 基础层(外部调用,db操作)</h4>\n<p>注意: 基础层只做适配不做业务</p>\n<ul>\n<li>db操作以dao结尾</li>\n<li>外部调用以Client(Http协议)/Instruction(Rpc协议)\n<ul>\n<li>改层仅仅做数据适配,不做业务处理。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"领域层-偏向领域的业务逻辑\"> 领域层(偏向领域的业务逻辑)</h4>\n<p>以Manager</p>\n<h4 id=\"业务层-对领域层的业务编排\"> 业务层(对领域层的业务编排)</h4>\n<p>以Service结尾</p>\n<h4 id=\"外观层-可以提供能力-可以提供视图-。\"> 外观层(可以提供能力,可以提供视图)。</h4>\n<p>以Resource、Facade结尾</p>\n<p>有一个完善的领域层,可以方便快速便捷的对业务进行扩展。与其对立的就是贫血模型。没有领域层只有业务层,业务逻辑都堆积在业务层。典型的面向过程设计。</p>\n<p><img src=\"https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/a/21643544635/2678603850/8be6e99c-f5e9-4a8a-bce4-85f5aa3717e7.png\" alt=\"img\" loading=\"lazy\"></p>\n<h3 id=\"_3-层次依赖模型\"> 3. 层次依赖模型</h3>\n<p>maven多模块应用和单模块应用通用。</p>\n<p>一定要控制项目的依赖情况。</p>\n<p>①service只能出现领域层的依赖, 领域层只能存在dao层和第三方服务层。</p>\n<p>②各个层代码不能平行调用(出现平行调用逻辑,要抽象出领域层来封装)。</p>\n<p><img src=\"https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/a/21643544635/2678603850/c08a058d-8c81-45c4-bdc4-82d666a304f7.png\" alt=\"img\" loading=\"lazy\"></p>\n<p>具体代码体现就是</p>\n<ul>\n<li>以Service命名的类,里面只能存在Manager</li>\n<li>以Manager命名的类,里面只能存在Dao和Client(Http协议)/Instruction(Rpc协议)封装的第三方调用</li>\n<li>以Dao命名的类是对数据库的操作</li>\n<li>以Client(Http协议)/Instruction(Rpc协议)命名的类,作为适配层与第三方API进行交互封装</li>\n</ul>\n<h2 id=\"五、设计模式六大原则\"> 五、设计模式六大原则</h2>\n<p>代码编程时候要向以下这6大原则,进行向其靠拢。</p>\n<h3 id=\"_1-开闭原则\"> 1. 开闭原则</h3>\n<p>一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</p>\n<p><strong>代码设计建议</strong></p>\n<p>用抽象构建框架，用实现扩展细节因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。</p>\n<h3 id=\"_2-单一职责\"> 2. 单一职责</h3>\n<p>不要存在多于一个导致类变更的原因通俗的说，即一个类只负责一项职责。</p>\n<p><strong>代码设计建议</strong></p>\n<p>在具体方法编写或者类编写时候,类编写时候业务要单一,方法编写时候实现要单一</p>\n<p>反例:</p>\n<p>UserService 类中提供了获取商品信息的接口</p>\n<p>setUserName(String name)方法的时候,对name的值进行了二次处理。</p>\n<h3 id=\"_3-里氏替换原则\"> 3. <strong>里氏替换原则</strong></h3>\n<p>所有引用基类的地方必须能透明地使用其子类的对象。</p>\n<p><strong>代码设计建议</strong></p>\n<p>面向接口编程, 子类能透明替换父类。</p>\n<h3 id=\"_4-依赖倒置原则\"> 4. <strong>依赖倒置原则</strong></h3>\n<p>高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。</p>\n<p><strong>代码设计建议</strong></p>\n<p>要根据接口或者抽象去设计,不要依赖于细节,eg.项目中要换数据库,不用重新写底层的数据库代码. 就是使用了hibernate一样,替换方言就好了,因为hibernate是根据接口设计的,不同数据库有不同的实现,可以直接使用. eg2: 我生病了要去买药,如果A药铺,没有我就用B药铺买. 因为他们都是药铺,都有一样的功能,可以友好的替换</p>\n<h3 id=\"_5-接口隔离原则\"> <strong>5. 接口隔离原则</strong></h3>\n<p>客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。</p>\n<p><strong>代码设计建议</strong></p>\n<p>保持最小的责任。</p>\n<p>eg: 接口ConfigurableApplicationContext实现了Lifecycle和Closeable接口。他们其中每个里面定义的接口都很少,为什么不定义到一起呢?</p>\n<p>首先第一责任清晰单一,第二做到接口隔离。</p>\n<p>当某一个方法只用到生命周期的方法,那么方法就可以写成。</p>\n<p>public void stop(Lifecycle lifecycle); 调用时候用-&gt;public void stop(new ConfigurableApplicationContext());</p>\n<p>public void close(Closeable closeable); 调用时候用-&gt;public void close(new ConfigurableApplicationContext());</p>\n<p>stop里面的实现就只能调用Lifecycle里面的方法,而不能调用ConfigurableApplicationContext里面的方法。从而来达到接口隔离原则</p>\n<h3 id=\"_6-迪米特法则\"> 6. <strong>迪米特法则</strong></h3>\n<p>一个对象应该对其他对象保持最少的了解。</p>\n<p><strong>代码设计建议</strong></p>\n<p>减少类与类之间的关系,接口隔离也可以做到。</p>\n<h2 id=\"六、版本迭代\"> 六、版本迭代</h2>\n<p>master分支版本后缀 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.6833em;\"></span><span><span>大版本号</span></span><span>.</span></span></span></span>{0进位}.${迭代版本号}.RELEASE</p>\n<p>test分支版本号 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.6833em;\"></span><span><span>大版本号</span></span><span>.</span></span></span></span>{0进位}.${迭代版本号}.SNAPSHOP</p>\n<p>迭代版本可追踪，避免出现jar包覆盖无法追踪</p>\n<p>迭代版本升级,必须升级迭代版本号。避免出现jar包覆盖无法追踪</p>\n<h3 id=\"_1-大版本定义\"> 1. 大版本定义</h3>\n<p>APP1.0  APP2.0 APP3.0</p>\n<h3 id=\"_2-迭代版本号\"> 2. 迭代版本号</h3>\n<p>APP1.0.1  APP1.0版本的第一个迭代</p>\n<p>APP1.1.0  APP1.0版本的第十个迭代</p>\n<p>APP2.0.2  APP2.0版本的第二个迭代</p>\n<p>APP2.1.0  APP2.0版本的第十个迭代</p>\n<h2 id=\"七、代码格式化\"> 七、代码格式化</h2>\n<p>统一格式化模板,解决多人共同开发场景,代码格式化导致的git提交冲突问题</p>\n<p>最后求关注,求订阅,谢谢你的阅读!</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589360371000.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1598165820000.png",
      "date_published": "2021-12-21T05:46:37.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Join大法",
      "url": "https://java.springlearn.cn/learn/databases/sql/join/",
      "id": "https://java.springlearn.cn/learn/databases/sql/join/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/learn_1648086269000.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1648086269000.png",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "年终总结汇报大纲",
      "url": "https://java.springlearn.cn/learn/design/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%E6%B1%87%E6%8A%A5%E5%A4%A7%E7%BA%B2/",
      "id": "https://java.springlearn.cn/learn/design/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%E6%B1%87%E6%8A%A5%E5%A4%A7%E7%BA%B2/",
      "content_html": "<p>工作总结框架如下：</p>\n<h2 id=\"一、工作开展情况\"> 一、工作开展情况</h2>\n<p>1.一年来取得的成绩。</p>\n<p>2.在单位主要做了哪些工作。</p>\n<p>3.目前正在开展的主要工作。</p>\n<p>4.下一步要做的工作。</p>\n<h2 id=\"二、工作中的创新点、亮点以及经验技巧。\"> 二、工作中的创新点、亮点以及经验技巧。</h2>\n<p>1.哪些环节提高了工作效率。</p>\n<p>2.精简和优化了哪些工作流程。</p>\n<p>3.为单位节约了哪些成本。</p>\n<h2 id=\"三、存在不足和问题分析\"> 三、存在不足和问题分析</h2>\n<p>1.工作中遇到了哪些困难。</p>\n<p>2.出现困难的原因。</p>\n<p>3.是如何解决这些困难的。</p>\n<h2 id=\"四、来年的打算\"> 四、来年的打算</h2>\n<p>1.工作思路计划</p>\n<p>2.需要单位给予的哪些支持。#职场加油站# #冬日</p>\n",
      "date_published": "2022-01-04T14:58:20.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "中文文档写作规范",
      "url": "https://java.springlearn.cn/learn/design/%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3%E5%86%99%E4%BD%9C%E8%A7%84%E8%8C%83/",
      "id": "https://java.springlearn.cn/learn/design/%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3%E5%86%99%E4%BD%9C%E8%A7%84%E8%8C%83/",
      "content_html": "<div><p>中文技术文档的写作规范。</p>\n<p>本篇文章参考与阮一峰大佬的网络日志, 总结比较细致。非常具有借鉴意义, 欢迎大家进行学习。</p>\n<ul>\n<li>文章参考地址: <a href=\"https://github.com/ruanyf/document-style-guide\" target=\"_blank\" rel=\"noopener noreferrer\">阮一峰的网络日志</a></li>\n</ul>\n</div>\n<h1 id=\"目录\"> 目录</h1>\n<ol>\n<li></li>\n<li></li>\n<li></li>\n<li></li>\n<li></li>\n<li></li>\n<li></li>\n</ol>\n<h2 id=\"一、标题\"> 一、标题</h2>\n<h3 id=\"层级\"> 层级</h3>\n<p>标题分为四级。</p>\n<ul>\n<li>一级标题：文章的标题</li>\n<li>二级标题：文章主要部分的大标题</li>\n<li>三级标题：二级标题下面一级的小标题</li>\n<li>四级标题：三级标题下面某一方面的小标题</li>\n</ul>\n<p>下面是示例。</p>\n<div><pre><code><span><span>#</span> 一级标题</span>\n\n<span><span>##</span> 二级标题</span>\n\n<span><span>###</span> 三级标题</span>\n\n<span><span>####</span> 四级标题</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id=\"原则\"> 原则</h3>\n<p>（1）一级标题下，不能直接出现三级标题。</p>\n<p>示例：下面的文章结构，缺少二级标题。</p>\n<div><pre><code><span><span>#</span> 一级标题</span>\n\n<span><span>###</span> 三级标题</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>（2）标题要避免孤立编号（即同级标题只有一个）。</p>\n<p>示例：下面的文章结构，<code>二级标题 A</code>只包含一个三级标题，完全可以省略<code>三级标题 A</code>。</p>\n<div><pre><code><span><span>##</span> 二级标题 A</span>\n\n<span><span>###</span> 三级标题 A</span>\n\n<span><span>##</span> 二级标题 B</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>（3）下级标题不重复上一级标题的名字。</p>\n<p>示例：下面的文章结构，二级标题与下属的三级标题同名，建议避免。</p>\n<div><pre><code><span><span>##</span> 概述</span>\n\n<span><span>###</span> 概述</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>（4）谨慎使用四级标题，尽量避免出现，保持层级的简单，防止出现过于复杂的章节。</p>\n<p>如果三级标题下有并列性的内容，建议只使用项目列表（Item list）。</p>\n<p>示例：下面的结构二要好于结构一。后者适用的场景，主要是较长篇幅的内容。</p>\n<div><pre><code>结构一\n\n<span><span>###</span> 三级标题</span>\n\n<span><span>####</span> 四级标题 A</span>\n\n<span><span>####</span> 四级标题 B</span>\n\n<span><span>####</span> 四级标题 C</span>\n\n结构二\n\n<span><span>###</span> 三级标题</span>\n\n<span><span>**</span><span>（1）A</span><span>**</span></span>\n\n<span><span>**</span><span>（2）B</span><span>**</span></span>\n\n<span><span>**</span><span>（3）C</span><span>**</span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h2 id=\"二、文本\"> 二、文本</h2>\n<h3 id=\"字间距\"> 字间距</h3>\n<p>（1）全角中文字符与半角英文字符之间，应有一个半角空格。</p>\n<div><pre><code>错误：本文介绍如何快速启动Windows系统。\n\n正确：本文介绍如何快速启动 Windows 系统。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>（2）全角中文字符与半角阿拉伯数字之间，有没有半角空格都可，但必须保证风格统一，不能两种风格混杂。</p>\n<div><pre><code>正确：2011年5月15日，我订购了5台笔记本电脑与10台平板电脑。\n\n正确：2011 年 5 月 15 日，我订购了 5 台笔记本电脑与 10 台平板电脑。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>半角的百分号，视同阿拉伯数字。</p>\n<div><pre><code>正确：今年我国经济增长率是6.5%。\n\n正确：今年我国经济增长率是 6.5%。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>（3）英文单位若不翻译，单位前的阿拉伯数字与单位间不留空格。</p>\n<div><pre><code>错误：一部容量为 16 GB 的智能手机\n\n正确：一部容量为 16GB 的智能手机\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>（4）半角英文字符和半角阿拉伯数字，与全角标点符号之间不留空格。</p>\n<div><pre><code>错误：他的电脑是 MacBook Air 。\n\n正确：他的电脑是 MacBook Air。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"句子\"> 句子</h3>\n<p>（1）避免使用长句。</p>\n<p>不包含任何标点符号的单个句子，或者以逗号分隔的句子构件，长度尽量保持在 20 个字以内；20～29 个字的句子，可以接受；30～39 个字的句子，语义必须明确，才能接受；多于 40 个字的句子，任何情况下都不能接受。</p>\n<div><pre><code>错误：本产品适用于从由一台服务器进行动作控制的单一节点结构到由多台服务器进行动作控制的并行处理程序结构等多种体系结构。\n\n正确：本产品适用于多种体系结构。无论是由一台服务器（单一节点结构），还是由多台服务器（并行处理结构）进行动作控制，均可以使用本产品。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>逗号分割的长句，总长度不应该超过 100 字或者正文的 3 行。</p>\n<p>（2）尽量使用简单句和并列句，避免使用复合句。</p>\n<div><pre><code>并列句：他昨天生病了，没有参加会议。\n\n复合句：那个昨天生病的人没有参加会议。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>（3）同样一个意思，尽量使用肯定句表达，不使用否定句表达。</p>\n<div><pre><code>错误：请确认没有接通装置的电源。\n\n正确：请确认装置的电源已关闭。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>（4）避免使用双重否定句。</p>\n<div><pre><code>错误：没有删除权限的用户，不能删除此文件。\n\n正确：用户必须拥有删除权限，才能删除此文件。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"写作风格\"> 写作风格</h3>\n<p>（1）尽量不使用被动语态，改为使用主动语态。</p>\n<div><pre><code>错误：假如此软件尚未被安装，\n\n正确：假如尚未安装这个软件，\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>（2）不使用非正式的语言风格。</p>\n<div><pre><code>错误：Lady Gaga 的演唱会真是酷毙了，从没看过这么给力的表演！！！\n\n正确：无法参加本次活动，我深感遗憾。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>（3）不使用冷僻、生造或者文言文的词语，而要使用现代汉语的常用表达方式。</p>\n<div><pre><code>错误：这是唯二的快速启动的方法。\n\n正确：这是仅有的两种快速启动的方法。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>（4）用对“的”、“地”、“得”。</p>\n<div><pre><code>她露出了开心的笑容。\n（形容词＋的＋名词）\n\n她开心地笑了。\n（副词＋地＋动词）\n\n她笑得很开心。\n（动词＋得＋副词）\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>（5）使用代词时（比如“其”、“该”、“此”、“这”等词），必须明确指代的内容，保证只有一个含义。</p>\n<div><pre><code>错误：从管理系统可以监视中继系统和受其直接控制的分配系统。\n\n正确：从管理系统可以监视两个系统：中继系统和受中继系统直接控制的分配系统。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>（6）名词前不要使用过多的形容词。</p>\n<div><pre><code>错误：此设备的使用必须在接受过本公司举办的正式的设备培训的技师的指导下进行。\n\n正确：此设备必须在技师的指导下使用，且指导技师必须接受过由本公司举办的正式设备培训。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"英文处理\"> 英文处理</h3>\n<p>（1）英文原文如果使用了复数形式，翻译成中文时，应该将其还原为单数形式。</p>\n<div><pre><code>英文：⋯information stored in random access memory (RAMs)⋯\n\n中文：……存储在随机存取存储器（RAM）里的信息……\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>（2）外文缩写可以使用半角圆点(<code>.</code>)表示缩写。</p>\n<div><pre><code>U.S.A.\nApple, Inc.\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>（3）表示中文时，英文省略号（<code>⋯</code>）应改为中文省略号（<code>……</code>）。</p>\n<div><pre><code>英文：5 minutes later⋯\n\n中文：5 分钟过去了……\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>（4）英文书名或电影名改用中文表达时，双引号应改为书名号。</p>\n<div><pre><code>英文：He published an article entitled &quot;The Future of the Aviation&quot;.\n\n中文：他发表了一篇名为《航空业的未来》的文章。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>（5）第一次出现英文词汇时，在括号中给出中文标注。此后再次出现时，直接使用英文缩写即可。</p>\n<div><pre><code>IOC（International Olympic Committee，国际奥林匹克委员会）。这样定义后，便可以直接使用“IOC”了。\n</code></pre>\n<div><span>1</span><br></div></div><p>（6）专有名词中每个词第一个字母均应大写，非专有名词则不需要大写。</p>\n<div><pre><code>“American Association of Physicists in Medicine”（美国医学物理学家协会）是专有名词，需要大写。\n\n“online transaction processing”（在线事务处理）不是专有名词，不应大写。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"三、段落\"> 三、段落</h2>\n<h3 id=\"原则-2\"> 原则</h3>\n<ul>\n<li>一个段落只能有一个主题，或一个中心句子。</li>\n<li>段落的中心句子放在段首，对全段内容进行概述。后面陈述的句子为核心句服务。</li>\n<li>一个段落的长度不能超过七行，最佳段落长度小于等于四行。</li>\n<li>段落的句子语气要使用陈述和肯定语气，避免使用感叹语气。</li>\n<li>段落之间使用一个空行隔开。</li>\n<li>段落开头不要留出空白字符。</li>\n</ul>\n<h3 id=\"引用\"> 引用</h3>\n<p>引用第三方内容时，应注明出处。</p>\n<div><pre><code>One man’s constant is another man’s variable. — Alan Perlis\n</code></pre>\n<div><span>1</span><br></div></div><p>如果是全篇转载，请在全文开头显著位置注明作者和出处，并链接至原文。</p>\n<div><pre><code>本文转载自 WikiQuote\n</code></pre>\n<div><span>1</span><br></div></div><p>使用外部图片时，必须在图片下方或文末标明来源。</p>\n<div><pre><code>本文部分图片来自 Wikipedia\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"四、数值\"> 四、数值</h2>\n<h3 id=\"半角数字\"> 半角数字</h3>\n<p>阿拉伯数字一律使用半角形式，不得使用全角形式。</p>\n<div><pre><code>错误： 这件商品的价格是１０００元。\n\n正确： 这件商品的价格是 1000 元。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"千分号\"> 千分号</h3>\n<p>数值为千位以上，应添加千分号（半角逗号）。</p>\n<div><pre><code>XXX 公司的实收资本为 ￥1,258,000 人民币。\n</code></pre>\n<div><span>1</span><br></div></div><p>对于 4 位以下的数值，千分号是选用的，比如<code>1000</code>和<code>1,000</code>都可以接受。对于 4 位以上的数值，千分号是必须的。</p>\n<h3 id=\"货币\"> 货币</h3>\n<p>货币应为阿拉伯数字，并在数字前写出货币符号，或在数字后写出货币中文名称。</p>\n<div><pre><code>$1,000\n1,000 美元\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>英文的货币名称，建议参考国际标准 <a href=\"https://en.wikipedia.org/wiki/ISO_4217\" target=\"_blank\" rel=\"noopener noreferrer\">ISO 4217</a>。</p>\n<h3 id=\"数值范围\"> 数值范围</h3>\n<p>表示数值范围时，用<code>～</code>或<code>——</code>连接。参见《标点符号》一节的“连接号”部分。</p>\n<p>带有单位或百分号时，两个数字建议都要加上单位或百分号。</p>\n<div><pre><code>132kg～234kg\n\n67%～89%\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"变化程度的表示法\"> 变化程度的表示法</h3>\n<p>数字的增加要使用“增加了”、“增加到”。“了”表示增量，“到”表示定量。</p>\n<div><pre><code>增加到过去的两倍\n（过去为一，现在为二）\n\n增加了两倍\n（过去为一，现在为三）\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>数字的减少要使用“降低了”、“降低到”。“了”表示增量，“到”表示定量。</p>\n<div><pre><code>降低到百分之八十\n（定额是一百，现在是八十）\n\n降低了百分之八十\n（原来是一百，现在是二十）\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>不能用“降低 N 倍”或“减少 N 倍”的表示法，要用“降低百分之几”或“减少百分之几”。因为减少（或降低）一倍表示数值原来为一百，现在等于零。</p>\n<h2 id=\"五、标点符号\"> 五、标点符号</h2>\n<h3 id=\"原则-3\"> 原则</h3>\n<p>（1）中文语句的标点符号，均应该采取全角符号，这样可以与全角文字保持视觉的一致。</p>\n<p>（2）如果整句为英文，则该句使用英文/半角标点。</p>\n<p>（3）句号、问号、叹号、逗号、顿号、分号和冒号不得出现在一行之首。</p>\n<h3 id=\"句号\"> 句号</h3>\n<p>（1）中文语句的结尾处应该用全角句号（<code>。</code>）。</p>\n<p>（2）句子末尾用括号加注时，句号应在括号之外。</p>\n<div><pre><code>错误：关于文件的输出，请参照第 1.3 节（见第 26 页。）\n\n正确：关于文件的输出，请参照第 1.3 节（见第 26 页）。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"逗号\"> 逗号</h3>\n<p>（1）逗号（<code>，</code>）表示句子内部的一般性停顿。</p>\n<p>（2）注意避免“一逗到底”，即整个段落除了结尾，全部停顿都使用逗号。</p>\n<h3 id=\"顿号\"> 顿号</h3>\n<p>（1）句子内部的并列词，应该用全角顿号(<code>、</code>) 分隔，而不用逗号，即使并列词是英语也是如此。</p>\n<div><pre><code>错误：我最欣赏的科技公司有 Google, Facebook, 腾讯, 阿里和百度等。\n\n正确：我最欣赏的科技公司有 Google、Facebook、腾讯、阿里和百度等。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>（2）英文句子中，并列词语之间使用半角逗号（<code>,</code>）分隔。</p>\n<div><pre><code>例句：Microsoft Office includes Word, Excel, PowerPoint, Outlook and other components.\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"分号\"> 分号</h3>\n<p>（1）分号（<code>；</code>）表示复句内部并列分句之间的停顿。</p>\n<h3 id=\"引号\"> 引号</h3>\n<p>（1）引用时，应该使用全角双引号（<code>“ ”</code>），注意前后双引号不同。</p>\n<div><pre><code>例句：许多人都认为客户服务的核心是“友好”和“专业”。\n</code></pre>\n<div><span>1</span><br></div></div><p>（2）引号里面还要用引号时，外面一层用双引号，里面一层用单引号（<code>‘ ’</code>），注意前后单引号不同。</p>\n<div><pre><code>例句：鲍勃解释道：“我要放音乐，可萨利说，‘不行！’。”\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"括号\"> 括号</h3>\n<p>（1）补充说明时，使用全角圆括号（<code>（）</code>），括号前后不加空格。</p>\n<div><pre><code>例句：请确认所有的连接（电缆和接插件）均安装牢固。\n</code></pre>\n<div><span>1</span><br></div></div><p>（2）几种括号的中英文名称。</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th style=\"text-align:center\">英文</th>\n<th style=\"text-align:right\">中文</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>{ }</code></td>\n<td style=\"text-align:center\">braces 或 curly brackets</td>\n<td style=\"text-align:right\">大括号</td>\n</tr>\n<tr>\n<td><code>[ ]</code></td>\n<td style=\"text-align:center\">square brackets 或 brackets</td>\n<td style=\"text-align:right\">方括号</td>\n</tr>\n<tr>\n<td><code>&lt; &gt;</code></td>\n<td style=\"text-align:center\">angled brackets</td>\n<td style=\"text-align:right\">尖括号</td>\n</tr>\n<tr>\n<td><code>( )</code></td>\n<td style=\"text-align:center\">parentheses</td>\n<td style=\"text-align:right\">圆括号</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"冒号\"> 冒号</h3>\n<p>（1）全角冒号（<code>：</code>）常用在需要解释的词语后边，引出解释和说明。</p>\n<div><pre><code>例句：请确认以下几项内容：时间、地点、活动名称，以及来宾数量。\n</code></pre>\n<div><span>1</span><br></div></div><p>（2）表示时间时，应使用半角冒号（<code>:</code>）。</p>\n<div><pre><code>例句：早上 8:00\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"省略号\"> 省略号</h3>\n<p>（1）省略号（<code>……</code>）表示语句未完、或者语气的不连续。</p>\n<p>（2）省略号占两个汉字空间、包含六个省略点，不要使用<code>。。。</code>或<code>...</code>等非标准形式。</p>\n<p>（3）省略号不应与“等”这个词一起使用。</p>\n<div><pre><code>错误：我们为会餐准备了香蕉、苹果、梨…等各色水果。\n\n正确：我们为会餐准备了各色水果，有香蕉、苹果、梨……\n\n正确：我们为会餐准备了香蕉、苹果、梨等各色水果。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"感叹号\"> 感叹号</h3>\n<p>（1）应该使用平静的语气叙述，尽量避免使用感叹号（<code>！</code>）。</p>\n<p>（2）不得多个感叹号连用，比如<code>！！</code>和<code>!!!</code>。</p>\n<h3 id=\"破折号\"> 破折号</h3>\n<p>（1）破折号<code>————</code>一般用于进一步解释。</p>\n<p>（2）破折号应占两个汉字的位置。如果破折号本身只占一个汉字的位置，那么前后应该留出一个半角空格。</p>\n<div><pre><code>例句：直觉————尽管它并不总是可靠的————告诉我，这事可能出了些问题。\n\n例句：直觉 —— 尽管它并不总是可靠的 —— 告诉我，这事可能出了些问题。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"连接号\"> 连接号</h3>\n<p>（1）连接号用于连接两个类似的词。</p>\n<p>（2）以下场合应该使用直线连接号（<code>-</code>），占一个半角字符的位置。</p>\n<ul>\n<li>两个名词的复合</li>\n<li>图表编号</li>\n</ul>\n<div><pre><code>例句：氧化-还原反应\n\n例句：图 1-1\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>（3）数值范围（例如日期、时间或数字）应该使用波浪连接号（<code>～</code>），占一个全角字符的位置。</p>\n<div><pre><code>例句：2009 年～2011 年\n</code></pre>\n<div><span>1</span><br></div></div><p>注意，波浪连接号前后两个值都应该加上单位。</p>\n<p>（4）波浪连接号也可以用汉字“至”代替。</p>\n<div><pre><code>例句：周围温度：-20°C 至 -10°C\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"六、文档体系\"> 六、文档体系</h2>\n<h3 id=\"结构\"> 结构</h3>\n<p>软件手册是一部完整的书，建议采用下面的结构。</p>\n<ul>\n<li><strong>简介</strong>（Introduction）： [必备] [文件] 提供对产品和文档本身的总体的、扼要的说明</li>\n<li><strong>快速上手</strong>（Getting Started）：[可选] [文件] 如何最快速地使用产品</li>\n<li><strong>入门篇</strong>（Basics）： [必备] [目录] 又称”使用篇“，提供初级的使用教程\n<ul>\n<li><strong>环境准备</strong>（Prerequisite）：[必备] [文件] 软件使用需要满足的前置条件</li>\n<li><strong>安装</strong>（Installation）：[可选] [文件] 软件的安装方法</li>\n<li><strong>设置</strong>（Configuration）：[必备] [文件] 软件的设置</li>\n</ul>\n</li>\n<li><strong>进阶篇</strong>（Advanced)：[可选] [目录] 又称”开发篇“，提供中高级的开发教程</li>\n<li><strong>API</strong>（Reference）：[可选] [目录|文件] 软件 API 的逐一介绍</li>\n<li><strong>FAQ</strong>：[可选] [文件] 常见问题解答</li>\n<li><strong>附录</strong>（Appendix）：[可选] [目录] 不属于教程本身、但对阅读教程有帮助的内容\n<ul>\n<li><strong>Glossary</strong>：[可选] [文件] 名词解释</li>\n<li><strong>Recipes</strong>：[可选] [文件] 最佳实践</li>\n<li><strong>Troubleshooting</strong>：[可选] [文件] 故障处理</li>\n<li><strong>ChangeLog</strong>：[可选] [文件] 版本说明</li>\n<li><strong>Feedback</strong>：[可选] [文件] 反馈方式</li>\n</ul>\n</li>\n</ul>\n<p>下面是两个真实范例，可参考。</p>\n<ul>\n<li><a href=\"http://redux.js.org/index.html\" target=\"_blank\" rel=\"noopener noreferrer\">Redux 手册</a></li>\n<li><a href=\"http://flight-manual.atom.io/\" target=\"_blank\" rel=\"noopener noreferrer\">Atom 手册</a></li>\n</ul>\n<h3 id=\"文件名\"> 文件名</h3>\n<p>文档的文件名不得含有空格。</p>\n<p>文件名必须使用半角字符，不得使用全角字符。这也意味着，中文不能用于文件名。</p>\n<div><pre><code>错误： 名词解释.md\n\n正确： glossary.md\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>文件名建议只使用小写字母，不使用大写字母。</p>\n<div><pre><code>错误：TroubleShooting.md\n\n正确：troubleshooting.md \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>为了醒目，某些说明文件的文件名，可以使用大写字母，比如<code>README</code>、<code>LICENSE</code>。</p>\n<p>文件名包含多个单词时，单词之间建议使用半角的连词线（<code>-</code>）分隔。</p>\n<div><pre><code>不佳：advanced_usage.md\n\n正确：advanced-usage.md\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"七、参考链接\"> 七、参考链接</h2>\n<ul>\n<li><a href=\"http://wenku.baidu.com/view/23cc1a6527d3240c8447efbf.html\" target=\"_blank\" rel=\"noopener noreferrer\">产品手册中文写作规范</a>, by 华为</li>\n<li><a href=\"http://guide.daocloud.io/dcs/%E5%86%99%E4%BD%9C%E8%A7%84%E8%8C%83%E5%92%8C%E6%A0%BC%E5%BC%8F%E8%A7%84%E8%8C%83-9153803.html\" target=\"_blank\" rel=\"noopener noreferrer\">写作规范和格式规范</a>, by DaoCloud</li>\n<li><a href=\"http://www.hitachi-tc.co.jp/company/thesis/thesis.pdf\" target=\"_blank\" rel=\"noopener noreferrer\">技术写作技巧在日汉翻译中的应用</a>, by 刘方</li>\n<li><a href=\"https://www.lengoo.de/documents/styleguides/lengoo_styleguide_ZH.pdf\" target=\"_blank\" rel=\"noopener noreferrer\">简体中文规范指南</a>, by lengoo</li>\n<li><a href=\"https://open.leancloud.cn/copywriting-style-guide.html\" target=\"_blank\" rel=\"noopener noreferrer\">文档风格指南</a>, by LeanCloud</li>\n<li><a href=\"https://docs.google.com/document/d/1R8lMCPf6zCD5KEA8ekZ5knK77iw9J-vJ6vEopPemqZM/edit\" target=\"_blank\" rel=\"noopener noreferrer\">豌豆荚文案风格指南</a>, by 豌豆荚</li>\n<li><a href=\"https://github.com/sparanoid/chinese-copywriting-guidelines\" target=\"_blank\" rel=\"noopener noreferrer\">中文文案排版指北</a>, by sparanoid</li>\n<li><a href=\"http://w3c.github.io/clreq/\" target=\"_blank\" rel=\"noopener noreferrer\">中文排版需求</a>, by W3C</li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2017/02/filename-should-be-lowercase.html\" target=\"_blank\" rel=\"noopener noreferrer\">为什么文件名要小写？</a>, by 阮一峰</li>\n<li><a href=\"https://developers.google.com/style/\" target=\"_blank\" rel=\"noopener noreferrer\">Google Developer Documentation Style Guide</a>, by Google</li>\n<li><a href=\"http://www.moe.gov.cn/ewebeditor/uploadfile/2015/01/13/20150113091154536.pdf\" target=\"_blank\" rel=\"noopener noreferrer\">出版物上数字用法的规定（国家标准GBT15835－2011）</a></li>\n<li><a href=\"https://baike.baidu.com/item/%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E5%9B%BD%E5%AE%B6%E6%A0%87%E5%87%86%E5%87%BA%E7%89%88%E7%89%A9%E6%95%B0%E5%AD%97%E7%94%A8%E6%B3%95\" target=\"_blank\" rel=\"noopener noreferrer\">中华人民共和国国家标准出版物数字用法</a></li>\n</ul>\n",
      "date_published": "2021-12-25T09:26:08.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "领域驱动模型的思考与认知",
      "url": "https://java.springlearn.cn/learn/design/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%80%9D%E8%80%83%E4%B8%8E%E8%AE%A4%E7%9F%A5/",
      "id": "https://java.springlearn.cn/learn/design/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%80%9D%E8%80%83%E4%B8%8E%E8%AE%A4%E7%9F%A5/",
      "content_html": "<blockquote>\n<p>本项目是基于小编的开发经验与心得,分享小编关于领域模型的理解, 个人愚见仅供参考,希望能为渴望进步的你提供帮助。如果你感到有用对你有帮助,请不要吝啬你的关注,求关注,求转发。\n文章有三个议题，什么是领域模型,为什么需要领域模型设计,以及领域驱动的项目结构是什么样的?</p>\n</blockquote>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1594392162000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"一、领域驱动模型是什么\"> 一、领域驱动模型是什么？</h2>\n<p>如果你是第一次听到这个词,嗯,多么恐怖的一件事情呀! 什么是领域模型,一种新的技术吗? 领域模型到底有什么用呢?\n为什么那么多大佬都在讲领域模型。网络上充斥着着各种高端的解释,各种高大上的名字,各种复杂的系统设计图。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1595078884000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>fuck !\n身边总是有这样一群人的出现。总喜欢中文里加载者英文,英文中夹杂着中文,仿佛这样能使他们更加自信一样。把你讲懵了,他就自信了。 very fuck !</p>\n<p>身为技术人,尽量想把一种事情给将清楚,说明白。而不是用各种抽象的晦涩难懂但看上去高大上的名词给解释。千万不要怕,下面我们通过先做一点小小的铺垫。最后在总结领域模型的理解。</p>\n<h3 id=\"_1-贫血模型\"> 1. 贫血模型</h3>\n<p>在讲清楚领域模型之前我们先来看引入一个词汇 <strong>“贫血模型”</strong> ，读到这里不要怕。只是一个词汇而已。是对我们平时的项目代码结构的一个形容词。相信无论面前的你\n是一个大牛，还是一个刚入行的小菜鸟。你都一定写过这样的代码:</p>\n<ul>\n<li>dao层: 负责持久化</li>\n<li>model层: 数据模型</li>\n<li>service层: 服务层</li>\n<li>web层: 提供对UI层的访问</li>\n</ul>\n<p>嗯。这就是一个典型的贫血模型, 哇,真的好形象,这是谁想出来的词汇,真想给他说一句 fuck you!  但是，但是，你还有更好的词汇来形容这种项目结构吗?\n所谓贫血模型是指使用的领域对象中只有 <code>setter</code> 和 <code>getter</code> 方法（POJO），所有的业务逻辑都不包含在领域对象中而是放在业务逻辑层。</p>\n<p>往往我们入行的初期我们都是在这样的项目结构中进行编程的,那个时候我们的业务往往都是简单的,对于那个时候的我们来说,这样的代码结构真是太好用了。清晰易懂。甚至想说一声 i love code !!!</p>\n<p>这个时期,我们的关注点往往不是业务的复杂度,而是技术的使用,语法的使用。以及代码是否能编译通过。所以下面我们来总结一下贫血模型的优点。</p>\n<h3 id=\"_2-贫血模型优点\"> 2. 贫血模型优点</h3>\n<ol>\n<li>被许多程序员所掌握，对于刚入行的同学来说，这种模型很自然很舒服，典型的MVC结构</li>\n<li>它非常简单，对于并不复杂的业务，它工作得很好，开发起来非常迅速。它似乎也不需要对领域的充分了解，只要给出要实现功能的每一个步骤，就能实现它。</li>\n<li>事务边界相当清楚，一般来说service的每个方法都可以看成一个事务。</li>\n</ol>\n<h3 id=\"_3-贫血模型缺点\"> 3. 贫血模型缺点</h3>\n<p>随着发际线推移,随着历史的变迁,随着候鸟的迁徙。不知不觉我们的业务越来越复杂了。万恶的资本家,总想让我们一夜之间开发一个淘宝,一夜之间开发一个百度,一夜之间开发一个QQ。于是我们的service层,不断的\n不断的增加。代码量从100行,200行,300行,10000行刹不住车了。终于小张忍不住了,辞职走了。留下了孤独的你独自承受这忧伤。\n<img src=\"https://img.springlearn.cn/blog/learn_1594392402000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>这样代码是什么意思？ 这样代码能不能删？这行代码怎么没有走？这样代码能不能拆出去? 这样改万一项目上线崩溃了怎么办? 想一想老婆,望一望孩子。哎,算了吧。于是乎service复杂度指数般的递增。这就是贫血模型的缺点。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1594392441000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>缺点</strong></p>\n<ol>\n<li>所有的业务都在service中处理，当业越来越复杂时，service会变得越来越庞大，最终难以理解和维护，轻则项目组解散，重则妻离子散。</li>\n<li>将所有的业务放在无状态的service中实际上是一个过程化的设计,这与面向对象的编程风格,相向而行。(你转身离开分手说不出来,海鸟跟鱼相爱只是一场意外)</li>\n<li>项目代码写的不少,重用的不多。(fuck and fuck = double kill)</li>\n</ol>\n<h3 id=\"_4-充血模型\"> 4. 充血模型</h3>\n<p>前面说我说了贫血模型,这里顺便提一下充血模型,也不要怕,也只是一个吓人的词汇。前面我们理解了贫血模型，那么充血模型，很容易就能理解。\n前面我们说贫血模型实体类只有SET GET方法，逻辑基本在服务层实现。而**充血模型它的实体类里不但有状态，还有行为，即属性和方法都有。它的Service层很薄。**显然者不符合MVC的思想,因为充血模型中model中不仅有数据,还有状态。维护起来非常麻烦。</p>\n<h3 id=\"_5-领域驱动总结\"> 5. 领域驱动总结</h3>\n<p>针对贫血模型的service层非常复杂臃肿的缺点,领域模型的概念越来越流行起来,至少在一些很多的大公司中,非常盛行。领域模型的概念不仅可以重新去设计service,同时也在微服务设计中有重要的意义。\n所以说领域模型其实就是要解决service越来越臃肿的一种设计思想。主要就是对service中的复杂的业务逻辑进行拆分,根据领域来进行拆分。用面向对象的思想去重新设计service。\n有人给他起了一个高大上的词汇: 领域模型。</p>\n<p>所以最后小编想用一大白话来总结一下领域模型。</p>\n<p><strong>领域模型就是要用面向对象的思想去重新设计充斥着复杂业务逻辑的service层。</strong></p>\n<h2 id=\"二、为什么要进行领域模型设计\"> 二、为什么要进行领域模型设计?</h2>\n<p>相信看到这里的你,一定对领域模型有一个自己的认识。为什么要进行领域模型设计? 相信自己心里一定有一个自己的判断了。贫血模型的项目结构, service层无可避免的非常的臃肿，臃肿到一个方法可能深不见底。对于业务老油条，可能还凑合能看成，<br>\n假如你是一个新的同学,当你看到这样的代码一定是崩溃的，假如说注释也没有,那你内心更是崩溃的。假如说这是一个很庞大的系统,很复杂的业务流程,这就更不用说了。\n<img src=\"https://img.springlearn.cn/blog/learn_1594478376000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>如果读到这里,你还是对领域驱动设计感到迷茫，那么就其实这个标题也可以这样讲: <strong>我们如何对臃肿的service进行面向对象的设计。设计的过程就是对service层的代码进行领域设计。</strong><br>\n而我们之所以这样做的目的。</p>\n<ol>\n<li>为了快乐的coding</li>\n<li>为了业务系统的稳定</li>\n<li>为了业务更快的迭代升级。</li>\n</ol>\n<p>当然这一切的前提是你对业务有一个全局的认识,有一个前瞻性的判断,否则也设计不出来,真正适合自身系统的领域驱动模型。</p>\n<h2 id=\"三、领域驱动的项目结构是什么样的\"> 三、领域驱动的项目结构是什么样的?</h2>\n<p>**一千个人眼里有一千个哈姆雷特,没有最好的项目结构,只有最适合自己的业务系统。**本文只是小编对领域驱动的模块的思考和认识。\n仅供参考,希望对你有所启示和引导。</p>\n<h3 id=\"_1-领域划分-模块化建造\"> 1. 领域划分|模块化建造</h3>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1594574191000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>领域划分,小编感觉用另外一个词形容也非常的合适,就是业务模块化。所有能力都进行能力化抽象,形成模块,形成领域。 当遇到新的业务逻辑,底层的数据结构和数据关系肯定也是一样的。那么就可以像堆积木一样,根据这些模块快速的组装成新的业务逻辑。快速的实现业务的迭代和升级。\n关于这个问题,需要结合自己的业务系统来进行抽象和设计。而小编的能做的就是,提醒你<strong>模块化设计,领域化设计的重要意义。</strong></p>\n<h3 id=\"_2-项目结构\"> 2. 项目结构</h3>\n<p>基础层(外部调用,db操作) + 领域层(偏向领域的业务逻辑) + 业务层(对领域层的业务编排) + 外观层(可以提供能力,可以提供视图)。\n有一个完善的领域层,可以方便快速便捷的对业务进行扩展。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1595074590000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>领域层就是模块化设计的积木。丰富的模块化有助于业务扩展。</p>\n<p>一定要控制项目的依赖情况。service只能出现领域层的依赖, 领域层只能存在dao层和第三方服务层。各个层代码不能平行调用。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1595069641000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_3-编程规范\"> 3. 编程规范</h3>\n<p>关于项目提出6个注意的点。如果把做项目比作是前线打仗,那么打仗最重要的是战斗成员目标要一致。在目标不一致的情况下一定要进行\n充分讨论(项目负责人要做的),说明情况互相妥协指定出统一的项目编程规范。去进行执行。一旦指定不能违背。否则项目质量不保。</p>\n<p><strong>项目固然重要,但是作为软件开发工程师,首先要对代码质量做保障。</strong></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1595078292000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_4-日志设计\"> 4. 日志设计</h3>\n<p>天下没有完美的项目,任何系统不存在bug是不可能的。想要发现bug并快速定位问题,日志系统的不能缺少的。</p>\n<p>日志系统是非常重要的系统, 对系统的监控, 在设计日志系统中,我们需要关注的点</p>\n<ol>\n<li>日志结构(目的是按照结构解析到日志引擎中)\n如果想做日志的搜索平台,一定要进行日志结构化设计,方便被搜索平台的解析。如ELK日志搜索系统。</li>\n<li>日志打印降级能力\n在遇到大促时候,可以减少不必要的日志打印,要对日志打印做降级的设计</li>\n<li>异步输入日志</li>\n<li>日志归档</li>\n</ol>\n<div><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;configuration&gt;\n    &lt;!-- 系统日志打印 --&gt;\n    &lt;appender name=&quot;logfile&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;\n        &lt;File&gt;${logger.logback.logpath}mbp-game-service.log&lt;/File&gt;\n        &lt;encoder&gt;\n            &lt;Pattern&gt;[%date] [%-5level] %c{40} %line --%mdc{client} [%X{TRACE_LOG_ID}] [%X{dstTraceId}] %msg%n&lt;/Pattern&gt;\n            &lt;charset&gt;UTF-8&lt;/charset&gt;\n        &lt;/encoder&gt;\n        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;\n            &lt;fileNamePattern&gt;${logger.logback.logpath}mbp-game-service.%d{yyyy-MM-dd}.%i.log&lt;/fileNamePattern&gt;\n            &lt;maxHistory&gt;30&lt;/maxHistory&gt;\n            &lt;TimeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt;\n                &lt;maxFileSize&gt;512MB&lt;/maxFileSize&gt;\n            &lt;/TimeBasedFileNamingAndTriggeringPolicy&gt;\n        &lt;/rollingPolicy&gt;\n    &lt;/appender&gt;\n\n    &lt;!-- 异步输出 --&gt;\n    &lt;appender name=&quot;asyncAppender&quot; class=&quot;ch.qos.logback.classic.AsyncAppender&quot;&gt;\n        &lt;!-- 不丢失日志.默认的,如果队列的80%已满,则会丢弃TRACT、DEBUG、INFO级别的日志 --&gt;\n        &lt;discardingThreshold&gt;0&lt;/discardingThreshold&gt;\n        &lt;!-- 更改默认的队列的深度,该值会影响性能.默认值为256 --&gt;\n        &lt;queueSize&gt;1024&lt;/queueSize&gt;\n        &lt;!-- 添加附加的appender,最多只能添加一个 --&gt;\n        &lt;appender-ref ref=&quot;logfile&quot;/&gt;\n    &lt;/appender&gt;\n\n\n    &lt;!-- 外部jar包 日志级别设置 --&gt;\n    &lt;logger level=&quot;${logger.outside.logLevel}&quot; name=&quot;com.ibatis&quot;/&gt;\n    &lt;logger level=&quot;${logger.outside.logLevel}&quot; name=&quot;org.springframework&quot;/&gt;\n    &lt;logger level=&quot;${logger.outside.logLevel}&quot; name=&quot;java.sql&quot;/&gt;\n    &lt;logger level=&quot;${logger.outside.logLevel}&quot; name=&quot;org.apache&quot;/&gt;\n    &lt;logger level=&quot;${logger.outside.logLevel}&quot; name=&quot;com.alibaba.dubbo&quot;/&gt;\n    &lt;logger level=&quot;${logger.outside.logLevel}&quot; name=&quot;org.I0Itec&quot;/&gt;\n    &lt;logger level=&quot;${logger.outside.logLevel}&quot; name=&quot;org.dozer&quot;/&gt;\n    &lt;logger level=&quot;${logger.outside.logLevel}&quot; name=&quot;kafka.producer.SyncProducer&quot;/&gt;\n    &lt;logger level=&quot;${logger.kafka.outside.logLevel}&quot; name=&quot;org.apache.kafka&quot;/&gt;\n    &lt;logger level=&quot;${logger.kafka.outside.logLevel}&quot; name=&quot;org.springframework.kafka&quot;/&gt;\n\n    &lt;!-- 输出到文件，可定义更多的 Appender --&gt;\n    &lt;root level=&quot;${logger.logLevel}&quot;&gt;\n        &lt;appender-ref ref=&quot;asyncAppender&quot;/&gt;\n    &lt;/root&gt;\n\n&lt;/configuration&gt;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br></div></div><p>最后求关注,求订阅,谢谢你的阅读!</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589360371000.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1594392162000.png",
      "date_published": "2021-12-21T05:46:37.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "没有规矩不成方圆",
      "url": "https://java.springlearn.cn/learn/design/",
      "id": "https://java.springlearn.cn/learn/design/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/learn_1598165820000.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1598165820000.png",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "第10篇:分布式事务处理",
      "url": "https://java.springlearn.cn/learn/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/",
      "id": "https://java.springlearn.cn/learn/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/",
      "content_html": "",
      "date_published": "2022-05-22T07:02:41.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "分布式"
      ]
    },
    {
      "title": "第07篇:分布式服务熔断",
      "url": "https://java.springlearn.cn/learn/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD/",
      "id": "https://java.springlearn.cn/learn/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD/",
      "content_html": "",
      "date_published": "2022-05-22T07:02:41.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "分布式"
      ]
    },
    {
      "title": "分布式服务",
      "url": "https://java.springlearn.cn/learn/distributed/",
      "id": "https://java.springlearn.cn/learn/distributed/",
      "content_html": "<Djt/>\n<p><strong>本系列文章不讲具体的微服务框架, 只<code>研究其中的实现思路</code>。会从 <code>Spring cloud</code> 和 <code>double</code> 等框架中举例。\n从而来了解微服务架构的设计思路。</strong></p>\n<h3 id=\"什么是微服务\"> 什么是微服务？</h3>\n<p>微服务是一种现代的软件方法，应用程序代码以小的、可管理的部分交付，独立于其他部分。</p>\n<h3 id=\"为什么要构建微服务\"> 为什么要构建微服务？</h3>\n<p>它们的小规模和相对隔离可以带来许多额外的好处，例如更容易维护、提高生产力、更大的容错性、更好的业务一致性等等。</p>\n<p><img src=\"https://spring.io/images/diagram-microservices-88e01c7d34c688cb49556435c130d352.svg\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://spring.io/images/diagram-microservices-88e01c7d34c688cb49556435c130d352.svg",
      "date_published": "2022-05-08T04:06:59.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "分布式"
      ]
    },
    {
      "title": "六大原则 & 23种设计模式",
      "url": "https://java.springlearn.cn/learn/design/%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91/",
      "id": "https://java.springlearn.cn/learn/design/%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/learn_1653399918000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"一、设计模式\"> 一、设计模式</h2>\n<p>设计模式一般分为三类：创建型模式、结构型模式、行为型模式。</p>\n<ul>\n<li>创建型模式：对象实例化的模式，创建型模式用于解耦对象的实例化过程。</li>\n<li>结构型模式：把类或对象结合在一起形成一个更大的结构。</li>\n<li>行为型模式：类和对象如何交互，及划分责任和算法</li>\n</ul>\n<p><img src=\"https://img.springlearn.cn/27c9d5187cd283f8d160ec1ed2b5ac89.jpg\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_1-1-创建型模式\"> 1.1 创建型模式</h2>\n<p>创建型模式简单来说就是用来创建对象的。一共有五种：单例模式、建造者模式、工厂方法模式、抽象工厂模式、原型模式。</p>\n<ol>\n<li>单例模式 ：确保某一个类只有一个实例，并且提供一个全局访问点。</li>\n<li>建造者模式 ： 用来创建复杂的复合对象。</li>\n<li>工厂方法模式 ：让子类来决定要创建哪个对象。</li>\n<li>抽象工厂模式 ：创建多个产品族中的产品对象。</li>\n<li>原型模式 ：通过复制原型来创建新对象。</li>\n</ol>\n<h2 id=\"_1-2-结构型模式\"> 1.2 结构型模式</h2>\n<p>结构型模式主要是用于处理类或者对象的组合。一共有七种：适配器模式、装饰模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p>\n<ol>\n<li>代理模式 ：控制客户端对对象的访问。</li>\n<li>组合模式 ：将整体与局部（树形结构）进行递归组合，让客户端能够以一种的方式对其进行处理。</li>\n<li>适配器模式 ：将原来不兼容的两个类融合在一起。</li>\n<li>装饰者模式 ：为对象添加新功能。</li>\n<li>享元模式 ：使用对象池来减少重复对象的创建。</li>\n<li>外观模式 ：对外提供一个统一的接口用来访问子系统。</li>\n<li>桥接模式 ：将两个能够独立变化的部分分离开来。</li>\n</ol>\n<h2 id=\"_1-3-行为型模式\"> 1.3 行为型模式</h2>\n<p>行为型模式主要是描述类或者对象是怎样交互和怎样分配职责的。一共有十一种：策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p>\n<ol>\n<li>策略模式 ：封装不同的算法，算法之间能互相替换。</li>\n<li>状态模式 ：根据不同的状态做出不同的行为。</li>\n<li>责任链模式 ：将事件沿着链去处理。</li>\n<li>观察者模式 ：状态发生改变时通知观察者，一对多的关系。</li>\n<li>模板方法模式 ：定义一套流程模板，根据需要实现模板中的操作。</li>\n<li>迭代器模式 ：提供一种方法顺序访问一个聚合对象中的各个元素。</li>\n<li>备忘录模式 ：保存对象的状态，在需要时进行恢复。</li>\n<li>访问者模式 ：稳定数据结构中，定义新的操作行为。</li>\n<li>中介者模式 ：将网状结构转变为星型结构，所有行为都通过中介。</li>\n<li>解释器模式 ：定义语法，并对其进行解释。</li>\n<li>命令模式 ：将请求封装成命令，并记录下来，能够撤销与重做。</li>\n</ol>\n<p><strong>总结</strong>\n虽然设计模式是个好东西，能够给我们带来各种好处，比如降低对象之间的耦合，增加程序的可复用性、可扩展性、可维护性等等。\n但是我们也不应该滥用设计模式，设计模式在一定程序上会增加系统的复杂性。我们在写码时应该评估好各方面，避免过度设计。</p>\n<h2 id=\"二、六大原则\"> 二、六大原则</h2>\n<h2 id=\"_2-1-开闭原则\"> 2.1 开闭原则</h2>\n<p><strong>定义</strong></p>\n<p>一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</p>\n<p><strong>问题场景</strong></p>\n<p>在软件的生命周期内，因为变化、升级和维护等原因需要<code>对软件原有代码进行修改时</code>，可能会<code>给旧代码中引入错误</code>，也可能会使我们<code>不得不对整个功能进行重构</code>，并且需要原有代码经过重新测试。</p>\n<p><strong>解决方案</strong></p>\n<p>当软件需要变化时，<code>尽量通过扩展软件实体的行为来实现变化</code>，而<code>不是通过修改已有的代码</code>来实现变化。</p>\n<p><strong>表达</strong></p>\n<p>用抽象构建框架，用实现扩展细节因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节，我们用从抽象派生的实现类来进行扩展，当软件需要发生变化时，我们只需要根据需求重新派生一个实现类来扩展就可以了。当然前提是我们的抽象要合理，要对需求的变更有前瞻性和预见性才行。</p>\n<p><strong>分析</strong></p>\n<p>就是对扩展开放,对修改关闭, 里式替换原则理论支持了这个一说法,及子类要能替换父类,这样子类就可以在父类的基础上,扩展</p>\n<h2 id=\"_2-2-单一职责原则\"> 2.2 单一职责原则</h2>\n<p><strong>定义</strong></p>\n<p><code>一个类只负责一项职责。</code></p>\n<p><strong>问题场景</strong></p>\n<p>类T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。</p>\n<p><strong>解决方案</strong></p>\n<p>遵循单一职责原则。分别建立两个类T1、T2，使T1完成职责P1功能，T2完成职责P2功能。这样，当修改类T1时，不会使职责P2发生故障风险；同理，当修改T2时，也不会使职责P1发生故障风险。</p>\n<p><strong>表达</strong></p>\n<p>不要让责任扩散</p>\n<p><strong>分析</strong></p>\n<p>一个类,指责要单一,避免如果有多种职责,修改一个职责的时候,误触到其他职责的问题</p>\n<h2 id=\"_2-3-里氏替换原则\"> 2.3 里氏替换原则</h2>\n<p><strong>定义</strong></p>\n<p>所有引用基类的地方必须能透明地使用其子类的对象。</p>\n<p><strong>问题场景</strong></p>\n<p>有一功能P由类A完成，现在要扩展P,其中P由类A的子类B完成，则子类在完成的同时，可能会导致原来功能故障</p>\n<p><strong>解决方案</strong></p>\n<p>当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。</p>\n<p><strong>表达</strong></p>\n<p>使用继承的时候，不要随便修改父类中已经实现的方法</p>\n<p><strong>分析</strong></p>\n<p>子类要能替换父类</p>\n<h2 id=\"_2-4-依赖倒置原则\"> 2.4 依赖倒置原则</h2>\n<p><strong>定义</strong></p>\n<p>高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。</p>\n<p><strong>问题场景</strong></p>\n<p>类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。</p>\n<p><strong>解决方案</strong></p>\n<p>将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率。</p>\n<p><strong>表达</strong></p>\n<p>如果A依赖B，现在要改为依赖C，如果直接修改A有风险，可以让A去依赖一个接口，BC都实现这个接口，也就是策略模式</p>\n<p><strong>分析</strong></p>\n<p>白话就是说,要根据接口或者抽象去设计,不要依赖于细节,eg.项目中要换数据库,不用重新写底层的数据库代码. 就是使用了hibernate一样,替换方言就好了,因为hibernate是根据接口设计的,不同数据库有不同的实现,可以直接使用. eg2: 我生病了要去买药,如果A药铺,没有我就用B药铺买. 因为他们都是药铺,都有一样的功能,可以友好的替换</p>\n<h2 id=\"_2-5-接口隔离原则\"> 2.5 接口隔离原则</h2>\n<p><strong>定义</strong></p>\n<p>客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。</p>\n<p><strong>问题场景</strong></p>\n<p>类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则<strong>类B和类D必须去实现他们不需要的方法</strong>。</p>\n<p><strong>解决方案</strong></p>\n<p>将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则</p>\n<p><strong>表达</strong></p>\n<p>防止去实现不需要的接口方法，可以按接口拆分，避免臃肿。</p>\n<p><strong>分析</strong></p>\n<p>白话,接口要最小化,功能更细分. 目的是:不需要的功能,就不要去实现</p>\n<p>比如有些接口可能里面什么方法都没有，其存在的意义，就是为了其实现类拥有特殊的功能.所以我们也要怕我们的接口里面没有方法，就怀疑了它存在的价值</p>\n<div><pre><code>public class RandomAccess{\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>当实现RandomAccess的类比如ArrayList就具有随机访问的能力，而没有实现该接口的，就只能去迭代访问。</p>\n<p>我们可以简单的看下Collections下的binarySearch方法的源码</p>\n<div><pre><code>    <span>public</span> <span>static</span> <span><span>&lt;</span><span>T</span><span>></span></span>\n    <span>int</span> <span>binarySearch</span><span>(</span><span>List</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>Comparable</span><span>&lt;</span><span>?</span> <span>super</span> <span>T</span><span>></span><span>></span></span> list<span>,</span> <span>T</span> key<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>list <span>instanceof</span> <span>RandomAccess</span> <span>||</span> list<span>.</span><span>size</span><span>(</span><span>)</span><span>&lt;</span>BINARYSEARCH_THRESHOLD<span>)</span>\n            <span>return</span> <span>Collections</span><span>.</span><span>indexedBinarySearch</span><span>(</span>list<span>,</span> key<span>)</span><span>;</span>\n        <span>else</span>\n            <span>return</span> <span>Collections</span><span>.</span><span>iteratorBinarySearch</span><span>(</span>list<span>,</span> key<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id=\"_2-6-迪米特法则\"> 2.6 迪米特法则</h2>\n<p><strong>定义</strong></p>\n<p>一个对象应该对其他对象保持最少的了解。</p>\n<p><strong>问题场景</strong></p>\n<p>类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。</p>\n<p><strong>解决方案</strong></p>\n<p>尽量降低类与类之间的耦合。</p>\n<p><strong>表达</strong></p>\n<p>尽量降低类与类之间的耦合。</p>\n<p><strong>分析</strong></p>\n<p>降低类与类之间直接交互,能隐藏的属性就可以隐藏. eg. 修电脑,去IT部门,之前一直找小张,现在小张走了,还需要重新认识小李. 迪米特法则,就是直接找IT主管,让主管派人修. 主管就是接口，调用接口的方法，底层具体是小张还是小李，我们不用去管</p>\n<p>这里其实也强调了接口的重要性!</p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1653399918000.png",
      "date_published": "2022-05-24T00:00:00.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "设计&规范"
      ]
    },
    {
      "title": "第05篇:分布式服务降级",
      "url": "https://java.springlearn.cn/learn/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7/",
      "id": "https://java.springlearn.cn/learn/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7/",
      "content_html": "",
      "date_published": "2022-05-22T07:02:41.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "分布式"
      ]
    },
    {
      "title": "第03篇:分布式服务调用",
      "url": "https://java.springlearn.cn/learn/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/",
      "id": "https://java.springlearn.cn/learn/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/",
      "content_html": "<h2 id=\"一、前言\"> 一、前言</h2>\n<p>首先我们说下，什么是服务调用。其实就相当于两个服务器直接能进行通信。那么计算机之间是如何进行通信的呢?\n那就不得不说TCP/IP协议了。而关于TCP协议底层涉及的知识也比较多,随便拿出来一点都够学一个月的。但是这不是本篇\n内容的重点，我们只要知道TCP是帮助我们将完整数据进行分块,并且给每块数据进行ip打包进行发送，并且要在数据接u， 飞得更高过过过过过过军扩木，7667EEID .Y VC  受端能将\n没有顺序的数据包,重新按照顺序进行组装然后还原数据的就行了。知道这些就行了。如果这些东西你看了,还是没有思路。那么\n你可以简单理解成,二进制数据就好了，我们就是对二进制数据按照一定的协议规则，进行数据还原。将二进制数据还原成我们\n原来的数据即可。</p>\n<h2 id=\"二、通信协议\"> 二、通信协议</h2>\n<h3 id=\"_2-1-tpc协议\"> 2.1 TPC协议</h3>\n<h3 id=\"_2-2-http协议\"> 2.2 HTTP协议</h3>\n<h3 id=\"_2-3-rmi协议\"> 2.3 RMI协议</h3>\n<h2 id=\"三、实现\"> 三、实现</h2>\n<h3 id=\"_3-1-springcloud方案\"> 3.1 SpringCloud方案</h3>\n<h3 id=\"_3-2-dubbo方案\"> 3.2 dubbo方案</h3>\n<h3 id=\"_3-3-grpc方案\"> 3.3 GRPC方案</h3>\n<h2 id=\"四、知识扩展\"> 四、知识扩展</h2>\n<h3 id=\"_4-1-自定义通信协议\"> 4.1 自定义通信协议</h3>\n<h3 id=\"_4-2-rpc是什么\"> 4.2 RPC是什么</h3>\n",
      "date_published": "2022-05-22T07:02:41.000Z",
      "date_modified": "2022-07-12T12:38:40.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "分布式"
      ]
    },
    {
      "title": "第08篇:分布式服务网关",
      "url": "https://java.springlearn.cn/learn/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3/",
      "id": "https://java.springlearn.cn/learn/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3/",
      "content_html": "",
      "date_published": "2022-05-22T07:02:41.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "分布式"
      ]
    },
    {
      "title": "第06篇:分布式服务限流",
      "url": "https://java.springlearn.cn/learn/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E9%99%90%E6%B5%81/",
      "id": "https://java.springlearn.cn/learn/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E9%99%90%E6%B5%81/",
      "content_html": "",
      "date_published": "2022-05-22T07:02:41.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "分布式"
      ]
    },
    {
      "title": "第02篇:分布式负载均衡",
      "url": "https://java.springlearn.cn/learn/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/",
      "id": "https://java.springlearn.cn/learn/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/learn_1652886627000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"一、什么叫负载均衡\"> 一、什么叫负载均衡</h2>\n<p>什么叫<code>负载均衡</code>, 所谓负载。先可以理解为当流量请求到某一个微服务应用, 则这么微服务应用就承受了负载。</p>\n<p><code>什么叫均衡</code>如下图，浏览器发送了3次请求,后台有2个节点的微服务应用。但是每次都请求在某一台。而另外一台一直空闲没有流量。这种情况就是不均衡的。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1652839006000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>已上图为例，实际情况可能并不一定是一次请求，也可能是<code>一次任务的调用</code>。但是不论实际情况是什么, 负载均衡就是要解决一个事情，就是<code>让流量均衡的分布</code>。<code>防止服务器过载运行</code>产生故障。</p>\n<h2 id=\"二、常见解决思路\"> 二、常见解决思路</h2>\n<p>所谓负载均衡就是从一个集服务器集合中，找到一个最适合的服务器。去进行操作处理。所以首先我们先定义一个服务器集合。\n然后我们再通过常见的算法去进行挑选。</p>\n<p><code>List&lt;String&gt; services;</code></p>\n<h2 id=\"_2-1-随机算法\"> 2.1 随机算法</h2>\n<div><pre><code> <span>public</span> <span>static</span> <span>String</span> <span>random</span><span>(</span><span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> services<span>)</span> <span>{</span>\n        <span>Random</span> random <span>=</span> <span>new</span> <span>Random</span><span>(</span><span>)</span><span>;</span>\n        <span>String</span><span>[</span><span>]</span> addressArr <span>=</span> services<span>.</span><span>toArray</span><span>(</span><span>new</span> <span>String</span><span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>\n        <span>// random</span>\n        <span>return</span> addressArr<span>[</span>random<span>.</span><span>nextInt</span><span>(</span>services<span>.</span><span>size</span><span>(</span><span>)</span><span>)</span><span>]</span><span>;</span>\n <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id=\"_2-2-轮训算法\"> 2.2 轮训算法</h2>\n<div><pre><code><span>public</span> <span>class</span> <span>RoundBalanceTest</span> <span>{</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> services <span>=</span> <span>Arrays</span><span>.</span><span>asList</span><span>(</span><span>\"service1\"</span><span>,</span> <span>\"service2\"</span><span>,</span> <span>\"service3\"</span><span>)</span><span>;</span>\n        <span>XxlBalanceTest</span><span>.</span><span>manyRoute</span><span>(</span>i <span>-></span> <span>{</span>\n            <span>// 请求次数,取模。serviceKey 可以更细粒度的控制轮训</span>\n            <span>ColorConsole</span><span>.</span><span>colorPrintln</span><span>(</span><span>\"轮训负载({}):{}\"</span><span>,</span> i<span>,</span> <span>round</span><span>(</span>services<span>)</span><span>)</span><span>;</span>\n        <span>}</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>private</span> <span>static</span> <span>final</span> <span>AtomicInteger</span> atomicInteger <span>=</span> <span>new</span> <span>AtomicInteger</span><span>(</span><span>)</span><span>;</span>\n\n    <span>private</span> <span>static</span> <span>String</span> <span>round</span><span>(</span><span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> services<span>)</span> <span>{</span>\n        <span>int</span> count <span>=</span> atomicInteger<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span>count <span>>=</span> <span>Integer</span><span>.</span>MAX_VALUE<span>)</span> <span>{</span>\n            atomicInteger<span>.</span><span>set</span><span>(</span><span>0</span><span>)</span><span>;</span>\n        <span>}</span>\n        atomicInteger<span>.</span><span>incrementAndGet</span><span>(</span><span>)</span><span>;</span>\n        <span>String</span><span>[</span><span>]</span> toArray <span>=</span> services<span>.</span><span>toArray</span><span>(</span><span>new</span> <span>String</span><span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>\n        <span>return</span> toArray<span>[</span>count <span>%</span> toArray<span>.</span>length<span>]</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h2 id=\"_2-3-加权算法\"> 2.3 加权算法</h2>\n<p>加权算法的有很多的变异算法, 可以通过配置的方式，也可以通过某种策略动态的给每台服务器进行加权，从而来提高被轮训到的次数。\n这里说两种网上常见的实现。</p>\n<h3 id=\"_2-3-1-简单加权算法\"> 2.3.1 简单加权算法</h3>\n<p>一个简单暴力的加权算法,如下图。按照权重，重新构建集合。然后再将集合进行取模轮训即可。即可实现一个最简单\n的加权算法。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1652884737000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>代码实现也是比较简单的,如下代码。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>WeightBalanceTest</span> <span>{</span>\n\n    <span>private</span> <span>static</span> <span>class</span> <span>Server</span> <span>{</span>\n\n        <span>private</span> <span>String</span> host<span>;</span>\n\n        <span>private</span> <span>Integer</span> port<span>;</span>\n\n        <span>public</span> <span>Server</span><span>(</span><span>String</span> host<span>,</span> <span>Integer</span> port<span>)</span> <span>{</span>\n            <span>this</span><span>.</span>host <span>=</span> host<span>;</span>\n            <span>this</span><span>.</span>port <span>=</span> port<span>;</span>\n        <span>}</span>\n\n        <span>@Override</span>\n        <span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span>\n            <span>return</span> <span>\"Server{\"</span> <span>+</span>\n                    <span>\"host='\"</span> <span>+</span> host <span>+</span> <span>'\\''</span> <span>+</span>\n                    <span>\", port=\"</span> <span>+</span> port <span>+</span>\n                    <span>'}'</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>private</span> <span>static</span> <span>final</span> <span>AtomicInteger</span> atomicInteger <span>=</span> <span>new</span> <span>AtomicInteger</span><span>(</span><span>)</span><span>;</span>\n\n    <span>public</span> <span>static</span> <span>Server</span> <span>round</span><span>(</span><span>List</span><span><span>&lt;</span><span>Server</span><span>></span></span> services<span>)</span> <span>{</span>\n        <span>int</span> count <span>=</span> atomicInteger<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span>count <span>>=</span> <span>Integer</span><span>.</span>MAX_VALUE<span>)</span> <span>{</span>\n            atomicInteger<span>.</span><span>set</span><span>(</span><span>0</span><span>)</span><span>;</span>\n        <span>}</span>\n        atomicInteger<span>.</span><span>incrementAndGet</span><span>(</span><span>)</span><span>;</span>\n        <span>Server</span><span>[</span><span>]</span> toArray <span>=</span> services<span>.</span><span>toArray</span><span>(</span><span>new</span> <span>Server</span><span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>\n        <span>return</span> toArray<span>[</span>count <span>%</span> toArray<span>.</span>length<span>]</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>Map</span><span><span>&lt;</span><span>Server</span><span>,</span> <span>Integer</span><span>></span></span> confWeight <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        confWeight<span>.</span><span>put</span><span>(</span><span>new</span> <span>Server</span><span>(</span><span>\"127.0.0.1\"</span><span>,</span> <span>80</span><span>)</span><span>,</span> <span>2</span><span>)</span><span>;</span>\n        confWeight<span>.</span><span>put</span><span>(</span><span>new</span> <span>Server</span><span>(</span><span>\"127.0.0.1\"</span><span>,</span> <span>81</span><span>)</span><span>,</span> <span>3</span><span>)</span><span>;</span>\n        confWeight<span>.</span><span>put</span><span>(</span><span>new</span> <span>Server</span><span>(</span><span>\"127.0.0.1\"</span><span>,</span> <span>82</span><span>)</span><span>,</span> <span>5</span><span>)</span><span>;</span>\n\n        <span>List</span><span><span>&lt;</span><span>Server</span><span>></span></span> servers <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>Map<span>.</span>Entry</span><span><span>&lt;</span><span>Server</span><span>,</span> <span>Integer</span><span>></span></span> entity <span>:</span> confWeight<span>.</span><span>entrySet</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n            <span>Server</span> server <span>=</span> entity<span>.</span><span>getKey</span><span>(</span><span>)</span><span>;</span>\n            <span>Integer</span> weight <span>=</span> entity<span>.</span><span>getValue</span><span>(</span><span>)</span><span>;</span>\n            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> weight<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n                servers<span>.</span><span>add</span><span>(</span>server<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>Loops</span><span>.</span><span>loop</span><span>(</span><span>10</span><span>,</span> i <span>-></span> <span>{</span>\n            <span>ColorConsole</span><span>.</span><span>colorPrintln</span><span>(</span><span>\"第{}次,权重轮训{}\"</span><span>,</span> i<span>,</span> <span>round</span><span>(</span>servers<span>)</span><span>)</span><span>;</span>\n        <span>}</span><span>)</span><span>;</span>\n    <span>}</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br></div></div><div><pre><code>第0次,权重轮训Server{host=&#39;127.0.0.1&#39;, port=80}  \n第1次,权重轮训Server{host=&#39;127.0.0.1&#39;, port=80}  \n第2次,权重轮训Server{host=&#39;127.0.0.1&#39;, port=82}  \n第3次,权重轮训Server{host=&#39;127.0.0.1&#39;, port=82}  \n第4次,权重轮训Server{host=&#39;127.0.0.1&#39;, port=82}  \n第5次,权重轮训Server{host=&#39;127.0.0.1&#39;, port=82}  \n第6次,权重轮训Server{host=&#39;127.0.0.1&#39;, port=82}  \n第7次,权重轮训Server{host=&#39;127.0.0.1&#39;, port=81}  \n第8次,权重轮训Server{host=&#39;127.0.0.1&#39;, port=81}  \n第9次,权重轮训Server{host=&#39;127.0.0.1&#39;, port=81}  \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>但这样还是不均匀的, 相同的ip可能被连续的访问到其实就没有做到负载均衡。</p>\n<h3 id=\"_2-3-2-平滑加权算法\"> 2.3.2 平滑加权算法</h3>\n<p>主要解决上面那种不平滑的方案。这种方案是由<a href=\"https://github.com/phusion/nginx/commit/27e94984486058d73157038f7950a0a36ecc6e35\" target=\"_blank\" rel=\"noopener noreferrer\">nginx</a>提出来的。\n算法的数学原理。</p>\n<ul>\n<li>最大权重，减总权重</li>\n<li>当前权重加上原权重</li>\n</ul>\n<p>如下权重变化。</p>\n<table>\n<thead>\n<tr>\n<th>轮数</th>\n<th>选择前的当前权重</th>\n<th>选择节点</th>\n<th>选择后的当前权重</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>{5, 1, 1}</td>\n<td>a</td>\n<td>{-2, 1, 1}</td>\n</tr>\n<tr>\n<td>2</td>\n<td>{3, 2, 2}</td>\n<td>a</td>\n<td>{-4, 2, 2}</td>\n</tr>\n<tr>\n<td>3</td>\n<td>{1, 3, 3}</td>\n<td>b</td>\n<td>{1, -4, 3}</td>\n</tr>\n<tr>\n<td>4</td>\n<td>{6, -3, 4}</td>\n<td>a</td>\n<td>{-1, -3, 4}</td>\n</tr>\n<tr>\n<td>5</td>\n<td>{4, -2, 5}</td>\n<td>c</td>\n<td>{4, -2, -2}</td>\n</tr>\n<tr>\n<td>6</td>\n<td>{9, -1, -1}</td>\n<td>a</td>\n<td>{2, -1, -1}</td>\n</tr>\n<tr>\n<td>7</td>\n<td>{7, 0, 0}</td>\n<td>a</td>\n<td>{0, 0, 0}</td>\n</tr>\n</tbody>\n</table>\n<p>下面我们通过代码来实现。</p>\n<ul>\n<li>首先我们定义出服务器模型, <code>weight</code> 是初始配置的权重，<code>currentWeight</code> 是计算后的权重。</li>\n<li>初始值 <code>weight = currentWeight</code></li>\n</ul>\n<div><pre><code>    <span>@Data</span>\n    <span>@AllArgsConstructor</span>\n    <span>@ToString</span>\n    <span>@EqualsAndHashCode</span>\n    <span>private</span> <span>static</span> <span>class</span> <span>Server</span> <span>{</span>\n        <span>private</span> <span>String</span> host<span>;</span>\n        <span>private</span> <span>Integer</span> port<span>;</span>\n        <span>// 初始化权重</span>\n        <span>private</span> <span>Integer</span> weight<span>;</span>\n        <span>// 计算后的当前权重</span>\n        <span>private</span> <span>Integer</span> currentWeight<span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>然后我们根据算法的核心点来选择节点。这里我们先不考虑性能只说思路，有了思路在自己来优化代码。</p>\n<ol>\n<li><mark>line(3-6)</mark>  首先获取总权重</li>\n<li><mark>line(8-14)</mark> 然后获取当前最大权重的节点</li>\n<li><mark>line(16-21)</mark> 重新计算权重(<code>主要使用算法的思想</code>)\n<ul>\n<li>当前最大权重节点，重新计算权重。当前权重 = 当前权重 - 总权重 + 原始权重</li>\n<li>其他节点，重新计算权重。当前权重 = 当前权重 + 原始权重</li>\n</ul>\n</li>\n</ol>\n<div><div><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br></div><pre><code>    <span>public</span> <span>static</span> <span>Server</span> <span>selectServer</span><span>(</span><span>List</span><span><span>&lt;</span><span>Server</span><span>></span></span> servers<span>)</span> <span>{</span>\n        <span>// 获取总权重</span>\n        <span>Integer</span> totalWeight <span>=</span> <span>0</span><span>;</span>\n        <span>for</span> <span>(</span><span>Server</span> server <span>:</span> servers<span>)</span> <span>{</span>\n            totalWeight <span>+=</span> server<span>.</span><span>getWeight</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>// 根据权重从小到大排序</span>\n        <span>List</span><span><span>&lt;</span><span>Server</span><span>></span></span> sortByCurrentWeight <span>=</span> servers<span>.</span><span>stream</span><span>(</span><span>)</span><span>.</span><span>sorted</span><span>(</span><span>Comparator</span><span>.</span><span>comparing</span><span>(</span><span>Server</span><span>::</span><span>getCurrentWeight</span><span>)</span><span>)</span>\n                <span>.</span><span>collect</span><span>(</span><span>Collectors</span><span>.</span><span>toList</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// 集合反转,从大到小排序</span>\n        <span>Collections</span><span>.</span><span>reverse</span><span>(</span>sortByCurrentWeight<span>)</span><span>;</span>\n        <span>// 当前最大权重</span>\n        <span>Server</span> maxWeightServer <span>=</span> sortByCurrentWeight<span>.</span><span>get</span><span>(</span><span>0</span><span>)</span><span>;</span>\n        <span>// 重新计算权重</span>\n        <span>for</span> <span>(</span><span>Server</span> server <span>:</span> servers<span>)</span> <span>{</span>\n            <span>if</span> <span>(</span>server<span>.</span><span>equals</span><span>(</span>maxWeightServer<span>)</span><span>)</span> <span>{</span>\n                server<span>.</span><span>setCurrentWeight</span><span>(</span>server<span>.</span><span>getCurrentWeight</span><span>(</span><span>)</span> <span>-</span> totalWeight<span>)</span><span>;</span>\n            <span>}</span>\n            server<span>.</span><span>setCurrentWeight</span><span>(</span>server<span>.</span><span>getCurrentWeight</span><span>(</span><span>)</span> <span>+</span> server<span>.</span><span>getWeight</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> maxWeightServer<span>;</span>\n    <span>}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>可以看到非常的平滑均匀，每个ip都会被分散。</p>\n<div><pre><code>第0次,平滑权重轮训WeightBalanceTest2.Server(host=127,0,0,1, port=8080, weight=4, currentWeight=1)\n第1次,平滑权重轮训WeightBalanceTest2.Server(host=127,0,0,1, port=8081, weight=2, currentWeight=-1)\n第2次,平滑权重轮训WeightBalanceTest2.Server(host=127,0,0,1, port=8080, weight=4, currentWeight=2)\n第3次,平滑权重轮训WeightBalanceTest2.Server(host=127,0,0,1, port=8082, weight=1, currentWeight=-2)\n第4次,平滑权重轮训WeightBalanceTest2.Server(host=127,0,0,1, port=8080, weight=4, currentWeight=3)\n第5次,平滑权重轮训WeightBalanceTest2.Server(host=127,0,0,1, port=8081, weight=2, currentWeight=0)\n第6次,平滑权重轮训WeightBalanceTest2.Server(host=127,0,0,1, port=8080, weight=4, currentWeight=4)\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id=\"三、举例子\"> 三、举例子</h2>\n<p><img src=\"https://www.gif.cn/Upload/newsucai/2022-05-12/165233481994659.gif\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>好了前面，我们把常见的负载均衡算法都介绍完了，当然实际中的还有很多变异的算法，但是核心思想基本都是以上的思想。下面我们来\n看看常见的开源框架中都使用了那些算法吧。</strong></p>\n<p><code>具体算法如何实现不主要研究，只要知道其中的思想即可。如果开发中要使用，在去借鉴就好。</code></p>\n<h2 id=\"_3-1-xxljob\"> 3.1 xxljob</h2>\n<p>xxl内置了5种负载机制在 <code>LoadBalance</code> 可以找到，其中默认是轮训算法。前两种就不说了，就是上面我们提的。还有其他三种</p>\n<ol>\n<li>XxlRpcLoadBalanceLRUStrategy\n<ul>\n<li>LRU，即：最近最少使用淘汰算法（Least Recently Used）</li>\n<li>利用迭代器进行轮训: lruItem.entrySet().iterator().next().getKey().并且最长时间没有被用到的会被删除。</li>\n</ul>\n</li>\n<li>XxlRpcLoadBalanceLFUStrategy\n<ul>\n<li>LFU，即：最不经常使用淘汰算法（Least Frequently Used）。</li>\n<li>使用次数最少的会优先被选中</li>\n</ul>\n</li>\n<li>XxlRpcLoadBalanceConsistentHashStrategy\n<ul>\n<li>一致性Hash算法 <a href=\"/learn/other/一致性hash问题/\">Hash一致性</a></li>\n<li>思路: 将每个节点进行hash,每个地址虚拟5个节点,然后放到TreeMap里面进行排序。</li>\n<li>每次对serviceKey进行hash然后获取TreeMap中距离hash最近的一个节点</li>\n<li>每个serviceKey对应的服务是唯一的</li>\n</ul>\n</li>\n</ol>\n<p><a href=\"/learn/other/一致性hash问题/\">一致性hash</a></p>\n<div><pre><code><span>public</span> <span>enum</span> <span>LoadBalance</span> <span>{</span>\n    <span>RANDOM</span><span>(</span><span>new</span> <span>XxlRpcLoadBalanceRandomStrategy</span><span>(</span><span>)</span><span>)</span><span>,</span>\n    <span>ROUND</span><span>(</span><span>new</span> <span>XxlRpcLoadBalanceRoundStrategy</span><span>(</span><span>)</span><span>)</span><span>,</span>\n    <span>LRU</span><span>(</span><span>new</span> <span>XxlRpcLoadBalanceLRUStrategy</span><span>(</span><span>)</span><span>)</span><span>,</span>\n    <span>LFU</span><span>(</span><span>new</span> <span>XxlRpcLoadBalanceLFUStrategy</span><span>(</span><span>)</span><span>)</span><span>,</span>\n    <span>CONSISTENT_HASH</span><span>(</span><span>new</span> <span>XxlRpcLoadBalanceConsistentHashStrategy</span><span>(</span><span>)</span><span>)</span><span>;</span>\n<span>}</span> \n\n<span>public</span> <span>abstract</span> <span>class</span> <span>XxlRpcLoadBalance</span> <span>{</span>\n    <span>// serviceKey 是job的服务名拼接，addressSet是一共能选的机器</span>\n    <span>public</span> <span>abstract</span> <span>String</span> <span>route</span><span>(</span><span>String</span> serviceKey<span>,</span> <span>TreeSet</span><span><span>&lt;</span><span>String</span><span>></span></span> addressSet<span>)</span><span>;</span>\n<span>}</span>   \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id=\"_3-2-ribbon\"> 3.2 Ribbon</h2>\n<p><code>Ribbon</code> 是 SpringCloud体系下一个核心的负载均衡组件。</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>ILoadBalancer</span> <span>{</span>\n    <span>// 添加服务器列表</span>\n\t<span>public</span> <span>void</span> <span>addServers</span><span>(</span><span>List</span><span><span>&lt;</span><span>Server</span><span>></span></span> newServers<span>)</span><span>;</span>\n\t<span>// 选择可用的服务</span>\n\t<span>public</span> <span>Server</span> <span>chooseServer</span><span>(</span><span>Object</span> key<span>)</span><span>;</span>\n\t<span>// 标记服务下线</span>\n\t<span>public</span> <span>void</span> <span>markServerDown</span><span>(</span><span>Server</span> server<span>)</span><span>;</span>\n\t<span>// 当前活跃的服务</span>\n    <span>public</span> <span>List</span><span><span>&lt;</span><span>Server</span><span>></span></span> <span>getReachableServers</span><span>(</span><span>)</span><span>;</span>\n    <span>// 当前所有的服务</span>\n\t<span>public</span> <span>List</span><span><span>&lt;</span><span>Server</span><span>></span></span> <span>getAllServers</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>public</span> <span>interface</span> <span>IRule</span><span>{</span>\n    <span>// 真正来做选择的接口</span>\n    <span>public</span> <span>Server</span> <span>choose</span><span>(</span><span>Object</span> key<span>)</span><span>;</span>\n    \n    <span>public</span> <span>void</span> <span>setLoadBalancer</span><span>(</span><span>ILoadBalancer</span> lb<span>)</span><span>;</span>\n    \n    <span>public</span> <span>ILoadBalancer</span> <span>getLoadBalancer</span><span>(</span><span>)</span><span>;</span>    \n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p><img src=\"https://img.springlearn.cn/blog/learn_1652939033000.png\" alt=\"\" loading=\"lazy\"></p>\n<table>\n<thead>\n<tr>\n<th>序号</th>\n<th>实现类</th>\n<th>负载均衡策略</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>RoundRobinRule</td>\n<td>按照线性轮询策略，即按照一定的顺序依次选取服务实例</td>\n</tr>\n<tr>\n<td>2</td>\n<td>RandomRule</td>\n<td>随机选取一个服务实例</td>\n</tr>\n<tr>\n<td>3</td>\n<td>RetryRule</td>\n<td>按照 RoundRobinRule（轮询）的策略来获取服务，如果获取的服务实例为 null 或已经失效，则在指定的时间之内不断地进行重试（重试时获取服务的策略还是 RoundRobinRule 中定义的策略），如果超过指定时间依然没获取到服务实例则返回 null 。</td>\n</tr>\n<tr>\n<td>4</td>\n<td>WeightedResponseTimeRule</td>\n<td>WeightedResponseTimeRule 是 RoundRobinRule 的一个子类，它对 RoundRobinRule 的功能进行了扩展。  根据平均响应时间，来计算所有服务实例的权重，响应时间越短的服务实例权重越高，被选中的概率越大。刚启动时，如果统计信息不足，则使用线性轮询策略，等信息足够时，再切换到 WeightedResponseTimeRule。</td>\n</tr>\n<tr>\n<td>5</td>\n<td>BestAvailableRule</td>\n<td>继承自 ClientConfigEnabledRoundRobinRule。先过滤点故障或失效的服务实例，然后再选择并发量最小的服务实例。</td>\n</tr>\n<tr>\n<td>6</td>\n<td>AvailabilityFilteringRule</td>\n<td>先过滤掉故障或失效的服务实例，然后再选择并发量较小的服务实例。</td>\n</tr>\n<tr>\n<td>7</td>\n<td>ZoneAvoidanceRule</td>\n<td>默认的负载均衡策略，综合判断服务所在区域（zone）的性能和服务（server）的可用性，来选择服务实例。在没有区域的环境下，该策略与轮询（RandomRule）策略类似。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"_3-3-dubbo\"> 3.3 dubbo</h2>\n<p><code>dubbo</code> 负载均衡接口</p>\n<div><pre><code><span>@SPI</span><span>(</span><span>RandomLoadBalance</span><span>.</span>NAME<span>)</span>\n<span>public</span> <span>interface</span> <span>LoadBalance</span> <span>{</span>\n    <span>@Adaptive</span><span>(</span><span>\"loadbalance\"</span><span>)</span>\n    <span><span>&lt;</span><span>T</span><span>></span></span> <span>Invoker</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>select</span><span>(</span><span>List</span><span><span>&lt;</span><span>Invoker</span><span>&lt;</span><span>T</span><span>></span><span>></span></span> invokers<span>,</span> <span>URL</span> url<span>,</span> <span>Invocation</span> invocation<span>)</span> <span>throws</span> <span>RpcException</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><img src=\"https://img.springlearn.cn/learn_dad4a02061611976e7f89376d893dfe6.png\" alt=\"\" loading=\"lazy\"></p>\n<p>可以看到常用的算法都提供了，可能具体的实现方式可能不一样。</p>\n<table>\n<thead>\n<tr>\n<th>序号</th>\n<th>实现类</th>\n<th>负载均衡策略</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>RandomLoadBalance</td>\n<td>随机算法</td>\n</tr>\n<tr>\n<td>2</td>\n<td>RoundRobinLoadBalance</td>\n<td>加权轮训</td>\n</tr>\n<tr>\n<td>3</td>\n<td>LeastActiveLoadBalance</td>\n<td>当前最少调用的服务先被选中</td>\n</tr>\n<tr>\n<td>4</td>\n<td>ConsistentHashLoadBalance</td>\n<td>一致性hash算法</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"四、总结\"> 四、总结</h2>\n<ul>\n<li>xxl的负载均衡是无状态的</li>\n<li>Ribbon和dubbo有些策略是有状态的，比如会记录服务当前的活跃次数和耗时将这些也算入到权重</li>\n</ul>\n<p><code>无状态设计具有通用性比较简答。而有状态设计虽然不能通用,但是会充分考虑到服务器的性能进行负载。</code></p>\n<p>假如我们来涉及负载均衡，要采用那种设计呢?</p>\n<p>其次我们还有那些场景需要关心呢? 请留下你的评论。</p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1652886627000.png",
      "date_published": "2022-05-22T07:02:41.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "分布式"
      ]
    },
    {
      "title": "第09篇:分布式链路追踪",
      "url": "https://java.springlearn.cn/learn/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/",
      "id": "https://java.springlearn.cn/learn/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/",
      "content_html": "",
      "date_published": "2022-05-22T07:02:41.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "分布式"
      ]
    },
    {
      "title": "第01篇:分布式注册中心",
      "url": "https://java.springlearn.cn/learn/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/",
      "id": "https://java.springlearn.cn/learn/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/learn_1652941175000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"一、什么是注册中心\"> 一、什么是注册中心</h2>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1652941012000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>什么是<code>注册中心</code>，<code>注册中心</code> 往往是在分布式的应用体系下才会遇到的。对于分布式体系应用都是横向进行扩展。如下图<code>User App</code>这个服务，具有2台服务器\n但是当用户从网关进来访问, 网关是如何知道这个 <code>User App</code>有几台服务及每台服务的网络地址是什么呢? 所以就需要有一个地方能收集到每台应用的地址及命名。\n往往这个地方就被叫做 <code>注册中心</code>。分布式环境下的应用在启动时候都会向这个地方来注册自己的网络地址，及命名。</p>\n<h2 id=\"二、注册中心的职责\"> 二、注册中心的职责</h2>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1652941926000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><code>但是注册中心只能注册服务吗?</code> 当然不是,如果仅仅只做这个事情，那么岂不是浪费了自己的资源呢? 注册中心要做到</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1652942499000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>好了，我们看下再分布式的环境下，注册中心的位置有多<code>重要</code>了，如果没有了注册中心，网络上的服务都是<code>瞎子</code>了。所以这个系统\n的设计我们要重新考虑到他的<code>可用性</code>，以及就算注册中心挂了，各服务之间不要里面就瞎。最起码要留给注册中心一个<code>重启的时间</code>。</p>\n<p>好了，知道这么多，我们直接开始设计吧。</p>\n<h2 id=\"三、设计注册中心\"> 三、设计注册中心</h2>\n<h2 id=\"_3-1-ip地址获取\"> 3.1 ip地址获取</h2>\n<p>这里要注意的点是不要拿到了127.0.0.1这个本地回环地址。类似工具网络很多,这不是重点。看下就行。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>HostUtils</span> <span>{</span>\n    <span>private</span> <span>static</span> <span>String</span> ip<span>;</span>\n    <span>private</span> <span>static</span> <span>String</span> hostName<span>;</span>\n    <span>private</span> <span>static</span> <span>void</span> <span>resolveHost</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>InetAddress</span> localHost <span>=</span> <span>InetAddress</span><span>.</span><span>getLocalHost</span><span>(</span><span>)</span><span>;</span>\n        hostName <span>=</span> localHost<span>.</span><span>getHostName</span><span>(</span><span>)</span><span>;</span>\n        ip <span>=</span> localHost<span>.</span><span>getHostAddress</span><span>(</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span>localHost<span>.</span><span>isLoopbackAddress</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n            <span>Enumeration</span><span><span>&lt;</span><span>NetworkInterface</span><span>></span></span> networkInterfaces <span>=</span> <span>NetworkInterface</span><span>.</span><span>getNetworkInterfaces</span><span>(</span><span>)</span><span>;</span>\n            <span>while</span> <span>(</span>networkInterfaces<span>.</span><span>hasMoreElements</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n                <span>NetworkInterface</span> networkInterface <span>=</span> networkInterfaces<span>.</span><span>nextElement</span><span>(</span><span>)</span><span>;</span>\n                <span>Enumeration</span><span><span>&lt;</span><span>InetAddress</span><span>></span></span> inetAddresses <span>=</span> networkInterface<span>.</span><span>getInetAddresses</span><span>(</span><span>)</span><span>;</span>\n                <span>while</span> <span>(</span>inetAddresses<span>.</span><span>hasMoreElements</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n                    <span>InetAddress</span> inetAddress <span>=</span> inetAddresses<span>.</span><span>nextElement</span><span>(</span><span>)</span><span>;</span>\n                    <span>if</span> <span>(</span><span>!</span>inetAddress<span>.</span><span>isLoopbackAddress</span><span>(</span><span>)</span> <span>&amp;&amp;</span> <span>(</span>inetAddress <span>instanceof</span> <span>Inet4Address</span><span>)</span><span>)</span> <span>{</span>\n                        ip <span>=</span> inetAddress<span>.</span><span>getHostAddress</span><span>(</span><span>)</span><span>;</span>\n                    <span>}</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n    <span>public</span> <span>static</span> <span>String</span> <span>getIp</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> ip<span>;</span>\n    <span>}</span>\n    <span>public</span> <span>static</span> <span>String</span> <span>getHostName</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> hostName<span>;</span>\n    <span>}</span>\n    <span>static</span> <span>{</span>\n        <span>try</span> <span>{</span>\n            <span>resolveHost</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><h2 id=\"_3-2-通信协议-技术选型\"> 3.2 通信协议 &amp; 技术选型</h2>\n<p>通信协议一般为了兼容多语言环境, 最好使用的http协议。因为应用比较广泛。当然你也可以自定义协议。这里推荐一个\n小编基于Netty封装的通信框架 <a href=\"https://mojito.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">mojito</a> 这里我们主要考虑通用性,使用\nhttp协议。因为现在微服务使用 <mark>Spring Cloud</mark> 的较多，所以我们的注册中心的框架选型使用 <mark>Spring Boot</mark></p>\n<p>这里我们可以使用SpringBoot的<a href=\"/learn/spring/Endpoint监控端点扩展/\">Endpoint</a> 实现自己的扩展点，同时也可以使用服务自带的健康检查能力,进行状态监控。</p>\n<p>下面描述下实现思路</p>\n<h2 id=\"_3-3-交互流程\"> 3.3 交互流程</h2>\n<h3 id=\"_3-3-1-服务端能力\"> 3.3.1 服务端能力</h3>\n<ul>\n<li>提供服务注册接口\n<ul>\n<li>数据可以落到数据库, 同时记录内存缓存，服务量大可以考虑使用redis</li>\n<li>同时要落到文件中, 避免数据库挂了能从文件中恢复到缓存中</li>\n</ul>\n</li>\n<li>提供服务下线接口\n<ul>\n<li>当服务下线，主动调用注册中心下线接口，注册中心要提供被动接受下线能力</li>\n<li>当轮训到服务状态不好,主动将服务标记为下线，当服务状态恢复重新标记为正常</li>\n</ul>\n</li>\n<li>提供服务健康检查能力\n<ul>\n<li>轮训已注册的机器的健康检查接口，动态更新节点状态</li>\n<li>启动定时任务,定时发送状态检查,检查客户端服务状态</li>\n</ul>\n</li>\n<li>提供服务发现接口\n<ul>\n<li>通过传递服务名，返回服务名对应的服务列表</li>\n</ul>\n</li>\n<li>提供应用配置能力\n<ul>\n<li>做到服务隔离,不要把某个服务的配置,推送到全部服务器,只需要推动到这个服务对应的节点即可</li>\n<li>能主动发起配置变更消息</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"_3-3-2-客户端能力\"> 3.3.2 客户端能力</h3>\n<ul>\n<li>服务注册能力\n<ul>\n<li>实现 <code>ApplicationContextInitializer</code> 应用启动时候读取应用配置,然后将自己注册到注册中心</li>\n<li>将注册中心的配置,同时拉下来,放到Spring配置环境</li>\n</ul>\n</li>\n<li>服务重新或者宕机主动下线\n<ul>\n<li>利用<code>@PreDestroy</code>销毁方法,或者注册<a href=\"/learn/java/hooks函数/\">Jvm Hooks</a>程序</li>\n</ul>\n</li>\n<li>服务发现能力\n<ul>\n<li>根据服务名获取服务列表接口，同时缓存到本地一份</li>\n<li>如果注册中心无响应，要能使用本地缓存, 给注册中心留一个重启的时间</li>\n</ul>\n</li>\n<li>监听服务器配置信息\n<ul>\n<li>将监听到的配置变更刷新到Spring容器 <a href=\"/learn/spring/Spring动态绑定配置/\">动态绑定配置方案参考</a></li>\n</ul>\n</li>\n<li>打开健康检查</li>\n</ul>\n<h2 id=\"四、常见的注册中心\"> 四、常见的注册中心</h2>\n<p><a href=\"https://blog.csdn.net/sanmi8276/article/details/113513488\" target=\"_blank\" rel=\"noopener noreferrer\">注册中心对比</a></p>\n<h2 id=\"_4-1-zookeeper\"> 4.1 Zookeeper</h2>\n<p><a href=\"https://zhuanlan.zhihu.com/p/62526102\" target=\"_blank\" rel=\"noopener noreferrer\">什么是ZooKeeper？</a></p>\n<p>可以用ZooKeeper来做：统一配置管理、统一命名服务、分布式锁、集群管理。</p>\n<p>ZooKeeper的数据结构，跟Unix文件系统非常类似，可以看做是一颗树，每个节点叫做ZNode。每一个节点可以通过路径来标识，结构图如下：</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1653357711000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>那ZooKeeper这颗&quot;树&quot;有什么特点呢？？ZooKeeper的节点我们称之为Znode，Znode分为两种类型：</p>\n<p>短暂/临时(Ephemeral)：当客户端和服务端断开连接后，所创建的Znode(节点)会自动删除\n持久(Persistent)：当客户端和服务端断开连接后，所创建的Znode(节点)不会删除</p>\n<p>另外Zookeeper提供了节点监听的能力,当节点发生变化会发起通知事件。我们可以根据这个特性做一些事情,比如节点被删除就移除注册在这个节点上的服务。</p>\n<p><a href=\"/learn/other/zookeeper/\">zookeepr api</a></p>\n<h2 id=\"_4-2-eureka\"> 4.2 Eureka</h2>\n<p><a href=\"https://blog.csdn.net/buyaoshuohua1/article/details/119620675\" target=\"_blank\" rel=\"noopener noreferrer\">Eureka是干什么的?</a>\nEureka是SpringBoot默认的注册中心组件。没有配置的能力</p>\n<h2 id=\"_4-3-consul\"> 4.3 Consul</h2>\n<p>Consul是用于服务发现和配置的工具。Consul是分布式的，高度可用的，并且具有极高的可伸缩性，而且开发使用都很简便。它提供了一个功能齐全的控制面板，主要特点是：服务发现、健康检查、键值存储、安全服务通信、多数据中心、ServiceMesh。Consul在设计上把很多分布式服务治理上要用到的功能都包含在内了。</p>\n<h2 id=\"_4-4-nacos\"> 4.4 Nacos</h2>\n<p>Nacos致力于发现、配置和管理微服务。Nacos提供了一组简单易用的特性集，帮助您实现动态服务发现、服务配置管理、服务及流量管理。Nacos更敏捷和容易地构建、交付和管理微服务平台。 Nacos 是构建以“服务”为中心的现代应用架构(例如微服务范式、云原生范式)的服务基础设施。Nacos支持作为RPC注册中心，例如：支持Dubbo框架；也具备微服务注册中心的能力，例如：SpringCloud框架。</p>\n<h2 id=\"五、总结\"> 五、总结</h2>\n<p>市面上的注册中心有以上这些，核心逻辑思路都大差不差。其中Consul和Nacos是支持配置的。如果我们开发注册中心的话,没必要研究其源码。\n只有当我们要做注册中心,这个时候我们可以去研究下源码。对于一般开发使用,只要知道他是做什么的就好了。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1653371613000.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1652941175000.png",
      "date_published": "2022-05-22T07:02:41.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "分布式"
      ]
    },
    {
      "title": "第04篇:分布式配置中心",
      "url": "https://java.springlearn.cn/learn/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/",
      "id": "https://java.springlearn.cn/learn/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/",
      "content_html": "",
      "date_published": "2022-05-22T07:02:41.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "分布式"
      ]
    },
    {
      "title": "dubbo 服务端注册流程",
      "url": "https://java.springlearn.cn/learn/dubbo/Dubbo%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E6%9C%8D%E5%8A%A1%E7%AB%AFProvider/",
      "id": "https://java.springlearn.cn/learn/dubbo/Dubbo%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E6%9C%8D%E5%8A%A1%E7%AB%AFProvider/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/aa3147663675b9b5692915030cf264b9.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"一、启动一个服务端provider\"> 一、启动一个服务端Provider</h2>\n<h3 id=\"_1-定义一个接口和实现\"> 1. 定义一个接口和实现</h3>\n<div><pre><code><span>public</span> <span>interface</span> <span>UserService</span> <span>{</span>\n    <span>void</span> <span>say</span><span>(</span><span>String</span> message<span>)</span><span>;</span>\n<span>}</span>\n<span>public</span> <span>class</span> <span>UserServiceImpl</span> <span>implements</span> <span>UserService</span> <span>{</span>\n    <span>public</span> <span>void</span> <span>say</span><span>(</span><span>String</span> message<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"say:\"</span> <span>+</span> message<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id=\"_2-本地服务注册到zk\"> 2. 本地服务注册到zk</h3>\n<div><pre><code><span>public</span> <span>class</span> <span>Tester</span> <span>{</span>\n\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>providerTest</span><span>(</span><span>)</span> <span>{</span>\n\n        <span>//1. 服务方要把UserService方法提供给外面调用</span>\n        <span>UserService</span> userService <span>=</span> <span>new</span> <span>UserServiceImpl</span><span>(</span><span>)</span><span>;</span>\n\n        <span>//2. 应用配置</span>\n        <span>ApplicationConfig</span> app <span>=</span> <span>new</span> <span>ApplicationConfig</span><span>(</span><span>)</span><span>;</span>\n        app<span>.</span><span>setName</span><span>(</span><span>\"providerTest\"</span><span>)</span><span>;</span>\n\n        <span>//3. 指定一个注册中心</span>\n        <span>RegistryConfig</span> registry <span>=</span> <span>new</span> <span>RegistryConfig</span><span>(</span><span>)</span><span>;</span>\n        registry<span>.</span><span>setAddress</span><span>(</span><span>\"zookeeper://127.0.0.1:2181\"</span><span>)</span><span>;</span>\n\n        <span>//4. 指定协议类型</span>\n        <span>ProtocolConfig</span> protocol <span>=</span> <span>new</span> <span>ProtocolConfig</span><span>(</span><span>)</span><span>;</span>\n        protocol<span>.</span><span>setName</span><span>(</span><span>\"dubbo\"</span><span>)</span><span>;</span>\n        protocol<span>.</span><span>setPort</span><span>(</span><span>8012</span><span>)</span><span>;</span>\n        protocol<span>.</span><span>setThreads</span><span>(</span><span>200</span><span>)</span><span>;</span>\n\n        <span>// 服务提供者暴露服务配置</span>\n        <span>ServiceConfig</span><span><span>&lt;</span><span>UserService</span><span>></span></span> service <span>=</span> <span>new</span> <span>ServiceConfig</span><span><span>&lt;</span><span>UserService</span><span>></span></span><span>(</span><span>)</span><span>;</span> <span>// 此实例很重，封装了与注册中心的连接，请自行缓存，否则可能造成内存和连接泄漏</span>\n        service<span>.</span><span>setApplication</span><span>(</span>app<span>)</span><span>;</span>\n        service<span>.</span><span>setRegistry</span><span>(</span>registry<span>)</span><span>;</span> <span>// 多个注册中心可以用setRegistries()</span>\n        service<span>.</span><span>setProtocol</span><span>(</span>protocol<span>)</span><span>;</span> <span>// 多个协议可以用setProtocols()</span>\n        service<span>.</span><span>setInterface</span><span>(</span><span>UserService</span><span>.</span><span>class</span><span>)</span><span>;</span>\n        service<span>.</span><span>setRef</span><span>(</span>userService<span>)</span><span>;</span>\n        service<span>.</span><span>setVersion</span><span>(</span><span>\"1.0.0\"</span><span>)</span><span>;</span>\n\n        <span>// 暴露及注册服务</span>\n        <span>//dubbo://192.168.1.9:8012/code.UserService?anyhost=true&amp;application=providerTest&amp;dubbo=2.5.3&amp;interface=code.UserService&amp;methods=say&amp;pid=46787&amp;revision=1.0.0&amp;side=provider&amp;threads=200&amp;timestamp=1597048727957&amp;version=1.0.0</span>\n        service<span>.</span><span>export</span><span>(</span><span>)</span><span>;</span>\n\n    <span>}</span>\n\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div><h3 id=\"_3-分析原理\"> 3. 分析原理</h3>\n<p><strong>这里只是分析下大概原理,给各位童靴先带来带你感受,实际步骤后面分析源码时候再细说</strong></p>\n<p>在进行分析之前我们思考一下,当我们不使用RPC框架和SpringCloud的时候,如果我们要调用其他第三方的服务时候,我们会怎么处理呢?</p>\n<p>通过下面这中方式每次调用时候构建一个HTTP的请求。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Tester</span><span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>sayRequest</span><span>(</span><span>String</span> message<span>)</span><span>{</span>\n        <span>OkHttpClient</span> client <span>=</span> <span>new</span> <span>OkHttpClient</span><span>(</span><span>)</span><span>;</span>\n        <span>Request</span> request <span>=</span> <span>new</span> <span>Request<span>.</span>Builder</span><span>(</span><span>)</span>\n            <span>.</span><span>url</span><span>(</span><span>\"http://第三方服务的接口地址?message\"</span><span>+</span>message<span>)</span>\n            <span>.</span><span>get</span><span>(</span><span>)</span><span>.</span><span>addHeader</span><span>(</span><span>\"Cache-Control\"</span><span>,</span><span>\"no-cache\"</span><span>)</span>\n            <span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>\n        client<span>.</span><span>newCall</span><span>(</span>request<span>)</span><span>.</span><span>execute</span><span>(</span><span>)</span><span>;</span>    \n    <span>}</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span>args<span>)</span><span>{</span>\n        <span>sayRequest</span><span>(</span><span>\"你好\"</span><span>)</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>使用后我们就可以像调用本地方法一样来调用远程接口了? 那么Dubbo是如何实现的呢? 其实就是在底层帮我们做了类似于http的通信\n而通过api的方式屏蔽了底层。让我们直接将调用本地方法一样调用远程方法。</p>\n<h4 id=\"关键词一-通信协议\"> 关键词一:通信协议</h4>\n<p>dubbo默认不是基于HTTP,而是基于dubbo自定义的协议。因为jdk自带的socket api不太友好,所以dubbo底层是使用netty类做通信的\n说白了这个协议和http类似都是基于tcp协议从而进行封装,不同点就是数据格式不同。\n如下我们自定义了一个协议来读取tcp连接中数据。</p>\n<p>下面代码不是重点,重点知道协议就是,约定从tcp连接中读取数据的方式和方法。比如约定了读的第一个字节是协议类型,第二个是序列化类型,第三个是报文数据长度,第四个就是具体的报文数据。</p>\n<div><pre><code>    <span>/**\n     * 主要依据:\n     * 数据有\n     * 协议类型(1位) + 序列化类型(1位) + 报文大小(4位) + 数据报文组成(N位)\n     * *******************************************************************************\n     * ----------------     -----------------   ----------------   ------------------\n     * | 协议类型(1位) |   + | 序列化类型(1位) | + | 报文大小(4位) | + | 数据报文组成(N位)|\n     * ----------------     -----------------   ----------------   ------------------\n     * *******************************************************************************¬ \n     **/</span>\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>doDecode</span><span>(</span><span>ChannelHandlerContext</span> ctx<span>,</span> <span>ByteBuf</span> inByteBuf<span>,</span> <span>List</span><span><span>&lt;</span><span>Object</span><span>></span></span> out<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>byte</span><span>[</span><span>]</span> dataArr<span>;</span>\n        <span>//1. 不可读就关闭</span>\n        <span>if</span> <span>(</span><span>!</span>inByteBuf<span>.</span><span>isReadable</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n            <span>Channel</span> channel <span>=</span> ctx<span>.</span><span>channel</span><span>(</span><span>)</span><span>;</span>\n            <span>SocketAddress</span> socketAddress <span>=</span> channel<span>.</span><span>remoteAddress</span><span>(</span><span>)</span><span>;</span>\n            channel<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n            <span>System</span><span>.</span>err<span>.</span><span>println</span><span>(</span><span>\">>>>>>>>>[\"</span> <span>+</span> socketAddress <span>+</span> <span>\"]客户端已主动断开连接....\"</span><span>)</span><span>;</span>\n            <span>return</span><span>;</span>\n        <span>}</span>\n        <span>//2. 可读的数据大小</span>\n        <span>int</span> dataHeadSize <span>=</span> inByteBuf<span>.</span><span>readableBytes</span><span>(</span><span>)</span><span>;</span>\n        <span>//3. 不是完整的数据头就直接返回</span>\n        <span>if</span> <span>(</span><span>!</span><span>isFullMessageHeader</span><span>(</span>dataHeadSize<span>)</span><span>)</span> <span>{</span>\n            <span>return</span><span>;</span>\n        <span>}</span>\n        <span>//4. 完整的数据头就开始看数据长度是否满足</span>\n        inByteBuf<span>.</span><span>markReaderIndex</span><span>(</span><span>)</span><span>;</span>\n        <span>//协议类型</span>\n        <span>byte</span> protocolType <span>=</span> inByteBuf<span>.</span><span>readByte</span><span>(</span><span>)</span><span>;</span>\n        <span>//序列化类型</span>\n        <span>byte</span> serializationType <span>=</span> inByteBuf<span>.</span><span>readByte</span><span>(</span><span>)</span><span>;</span>\n        <span>//数据长度</span>\n        <span>int</span> dataSize <span>=</span> inByteBuf<span>.</span><span>readInt</span><span>(</span><span>)</span><span>;</span>\n        <span>//5. 拆包的直接返回下次数据完整了,在处理</span>\n        <span>if</span> <span>(</span><span>!</span><span>isFullMessage</span><span>(</span>inByteBuf<span>,</span> dataSize<span>)</span><span>)</span> <span>{</span>\n            inByteBuf<span>.</span><span>resetReaderIndex</span><span>(</span><span>)</span><span>;</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>)</span><span>;</span>\n            <span>System</span><span>.</span>err<span>.</span><span>println</span><span>(</span><span>\"######################数据不足已重置buffer######################\"</span><span>)</span><span>;</span>\n            <span>return</span><span>;</span>\n        <span>}</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>err<span>.</span><span>println</span><span>(</span><span>\"######################数据完整######################\"</span><span>)</span><span>;</span>\n        <span>//6. 黏包的直接读取数据</span>\n        dataArr <span>=</span> <span>new</span> <span>byte</span><span>[</span>dataSize<span>]</span><span>;</span>\n        inByteBuf<span>.</span><span>readBytes</span><span>(</span>dataArr<span>,</span> <span>0</span><span>,</span> dataSize<span>)</span><span>;</span>\n        <span>//找到序列化器,性能有提升空间,可以序列化器可以进行池化</span>\n        <span>SerializeEnum</span> serializeEnum <span>=</span> <span>SerializeEnum</span><span>.</span><span>ofByType</span><span>(</span>serializationType<span>)</span><span>;</span>\n        <span>Class</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>Serialize</span><span>></span></span> serialize <span>=</span> serializeEnum<span>.</span><span>getSerialize</span><span>(</span><span>)</span><span>;</span>\n        <span>//根据类型获取序列化器</span>\n        <span>Serialize</span> serializeNewInstance <span>=</span> serialize<span>.</span><span>newInstance</span><span>(</span><span>)</span><span>;</span>\n        <span>Object</span> deserialize <span>=</span> serializeNewInstance<span>.</span><span>deserialize</span><span>(</span>dataArr<span>)</span><span>;</span>\n        out<span>.</span><span>add</span><span>(</span>deserialize<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br></div></div><h4 id=\"关键词二-封装通信\"> 关键词二:封装通信</h4>\n<h5 id=\"服务端\"> 服务端</h5>\n<ol>\n<li>服务端将需要提供的接口实现方法封装起来</li>\n<li>并启动一个Netty服务</li>\n<li>同时将自己的地址注册到zk中</li>\n</ol>\n<h5 id=\"客户端\"> 客户端</h5>\n<ol>\n<li>客户端通过将接口方法封装成URL</li>\n<li>去请求zk,拿到真实的provider地址</li>\n<li>具体调用时候去请求服务端的netty服务之星</li>\n</ol>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1597050844000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"二、提供服务流程\"> 二、提供服务流程</h2>\n<p>这里我们只先分析dubbo的源码,后面再说dubbo整合spring的原理。</p>\n<h3 id=\"_1-要提供服务的对象\"> 1. 要提供服务的对象</h3>\n<div><pre><code><span>public</span> <span>interface</span> <span>UserService</span> <span>{</span>\n    <span>void</span> <span>say</span><span>(</span><span>String</span> message<span>)</span><span>;</span>\n<span>}</span>\n<span>public</span> <span>class</span> <span>UserServiceImpl</span> <span>implements</span> <span>UserService</span> <span>{</span>\n    <span>public</span> <span>void</span> <span>say</span><span>(</span><span>String</span> message<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"say:\"</span> <span>+</span> message<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id=\"_2-创建一个应用\"> 2. 创建一个应用</h3>\n<div><pre><code><span>ApplicationConfig</span> app <span>=</span> <span>new</span> <span>ApplicationConfig</span><span>(</span><span>)</span><span>;</span>\napp<span>.</span><span>setName</span><span>(</span><span>\"providerTest\"</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"_3-指定注册中心\"> 3. 指定注册中心</h3>\n<p>这里我们使用zookeeper作为注册中心</p>\n<div><pre><code> <span>RegistryConfig</span> registry <span>=</span> <span>new</span> <span>RegistryConfig</span><span>(</span><span>)</span><span>;</span>\n registry<span>.</span><span>setAddress</span><span>(</span><span>\"zookeeper://127.0.0.1:2181\"</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"_4-指定通信协议\"> 4. 指定通信协议</h3>\n<div><pre><code>        <span>ProtocolConfig</span> protocol <span>=</span> <span>new</span> <span>ProtocolConfig</span><span>(</span><span>)</span><span>;</span>\n        protocol<span>.</span><span>setName</span><span>(</span><span>\"dubbo\"</span><span>)</span><span>;</span>\n        protocol<span>.</span><span>setPort</span><span>(</span><span>8012</span><span>)</span><span>;</span>\n        protocol<span>.</span><span>setThreads</span><span>(</span><span>200</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"_5-导出服务到zk\"> 5. 导出服务到zk</h3>\n<div><pre><code>       <span>// 服务提供者暴露服务配置</span>\n        <span>ServiceConfig</span><span><span>&lt;</span><span>UserService</span><span>></span></span> service <span>=</span> <span>new</span> <span>ServiceConfig</span><span><span>&lt;</span><span>UserService</span><span>></span></span><span>(</span><span>)</span><span>;</span> <span>// 此实例很重，封装了与注册中心的连接，请自行缓存，否则可能造成内存和连接泄漏</span>\n        service<span>.</span><span>setApplication</span><span>(</span>app<span>)</span><span>;</span>\n        service<span>.</span><span>setRegistry</span><span>(</span>registry<span>)</span><span>;</span> <span>// 多个注册中心可以用setRegistries()</span>\n        service<span>.</span><span>setProtocol</span><span>(</span>protocol<span>)</span><span>;</span> <span>// 多个协议可以用setProtocols()</span>\n        service<span>.</span><span>setInterface</span><span>(</span><span>UserService</span><span>.</span><span>class</span><span>)</span><span>;</span>\n        service<span>.</span><span>setRef</span><span>(</span>userService<span>)</span><span>;</span>\n        service<span>.</span><span>setVersion</span><span>(</span><span>\"1.0.0\"</span><span>)</span><span>;</span>\n\n        <span>// 暴露及注册服务</span>\n        <span>//dubbo://192.168.1.9:8012/code.UserService?anyhost=true&amp;application=providerTest&amp;dubbo=2.5.3&amp;interface=code.UserService&amp;methods=say&amp;pid=46787&amp;revision=1.0.0&amp;side=provider&amp;threads=200&amp;timestamp=1597048727957&amp;version=1.0.0</span>\n        service<span>.</span><span>export</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>当这一步进行完后,我们会在zookeeper的控制台找到自己的服务地址。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1597051466000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>通过url解码之后就是</p>\n<p><code>dubbo://192.168.1.9:8012/code.UserService?anyhost=true&amp;application=providerTest&amp;dubbo=2.5.3&amp;interface=code.UserService&amp;methods=say&amp;pid=46787&amp;revision=1.0.0&amp;side=provider&amp;threads=200&amp;timestamp=1597048727957&amp;version=1.0.0</code></p>\n<h2 id=\"三、源码分析\"> 三、源码分析</h2>\n<h3 id=\"_1-服务注册\"> 1. 服务注册</h3>\n<p>我们在看二流程中,可以看到前面的1234创建的步骤都是在5中使用的,说明1234其实都是数据的载体,具体如何使用是在5中来使用的。而5的对象是<code>ServiceConfig</code>。所以说看源码的入口就从<code>ServiceConfig.export()</code>开始。</p>\n<p>ServiceConfig的export最终后调用doExport();</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1597051802000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>doExport方法会先检查然后在注册服务到Netty服务器和注册到zk</p>\n<div><pre><code>    <span>protected</span> <span>synchronized</span> <span>void</span> <span>doExport</span><span>(</span><span>)</span> <span>{</span>\n        interfaceClass <span>=</span> <span>Class</span><span>.</span><span>forName</span><span>(</span>interfaceName<span>,</span> <span>true</span><span>,</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span>\n                        <span>.</span><span>getContextClassLoader</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>//检查接口方法是否存在在接口中,这种是使用的方法级别的执行时候</span>\n        <span>checkInterfaceAndMethods</span><span>(</span>interfaceClass<span>,</span> methods<span>)</span><span>;</span>\n        <span>//检查接口实例是否存在,必须存在否则无法执行反射</span>\n        <span>checkRef</span><span>(</span><span>)</span><span>;</span>\n        <span>//检查应该配置,如果没有配置自动创建一个,应用名是dubbo.application.name的值</span>\n        <span>checkApplication</span><span>(</span><span>)</span><span>;</span>\n        <span>//检查注册中心</span>\n        <span>checkRegistry</span><span>(</span><span>)</span><span>;</span>\n        <span>//检查协议,默认是dubbo协议</span>\n        <span>checkProtocol</span><span>(</span><span>)</span><span>;</span>\n        <span>appendProperties</span><span>(</span><span>this</span><span>)</span><span>;</span>\n        <span>checkStubAndMock</span><span>(</span>interfaceClass<span>)</span><span>;</span>\n        <span>if</span> <span>(</span>path <span>==</span> <span>null</span> <span>||</span> path<span>.</span><span>length</span><span>(</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>\n            path <span>=</span> interfaceName<span>;</span>\n        <span>}</span>\n        <span>//真正导出服务</span>\n        <span>doExportUrls</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>这一步会将服务在本地启动一个服务,同时将服务注册到注册中心中。</p>\n<div><pre><code>    <span>private</span> <span>void</span> <span>doExportUrls</span><span>(</span><span>)</span> <span>{</span>\n        <span>List</span><span><span>&lt;</span>URL<span>></span></span> registryURLs <span>=</span> <span>loadRegistries</span><span>(</span><span>true</span><span>)</span><span>;</span>\n        <span>//registry://127.0.0.1:2181/com.alibaba.dubbo.registry.RegistryService?application=providerTest&amp;dubbo=2.5.3&amp;pid=48656&amp;registry=zookeeper&amp;timestamp=1597052329640</span>\n        <span>for</span> <span>(</span><span>ProtocolConfig</span> protocolConfig <span>:</span> protocols<span>)</span> <span>{</span>\n            <span>//核心逻辑在这里</span>\n            <span>doExportUrlsFor1Protocol</span><span>(</span>protocolConfig<span>,</span> registryURLs<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>根据doExportUrlsFor1Protocol的源码。我们发现dubbo中的所有模型都向Invoker来靠拢。</p>\n<ul>\n<li>先创建一个Socket来验证下能不能连接上注册中心</li>\n<li>然后根据协议信息,找到实现类。端口如果指定了就用指定的,没有指定就随机生成。默认是20880</li>\n<li>获取服务版本号,首先查找MANIFEST.MF规范中的版本号。没有就用指定的版本号</li>\n<li>通过反射生成Invoker对象</li>\n<li>导出Invoker启动一个Netty服务DubboProtocol.openServer</li>\n<li>注册到zk中RegistryProtocol.export</li>\n</ul>\n<h3 id=\"_2-netty服务接受服务\"> 2. Netty服务接受服务</h3>\n<p>前面注册时候,我们说了在DubboProtocol中去创建服务的。那我们直接看这部分代码。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>DubboProtocol</span> <span>extends</span> <span>AbstractProtocol</span> <span>{</span>\n    <span>//逻辑处理器</span>\n    <span>private</span> <span>ExchangeHandler</span> requestHandler <span>=</span> <span>new</span> <span>ExchangeHandlerAdapter</span><span>(</span><span>)</span> <span>{</span>\n        \n        <span>public</span> <span>Object</span> <span>reply</span><span>(</span><span>ExchangeChannel</span> channel<span>,</span> <span>Object</span> message<span>)</span> <span>throws</span> <span>RemotingException</span> <span>{</span>\n            <span>if</span> <span>(</span>message <span>instanceof</span> <span>Invocation</span><span>)</span> <span>{</span>\n                <span>Invocation</span> inv <span>=</span> <span>(</span><span>Invocation</span><span>)</span> message<span>;</span>\n                <span>Invoker</span><span><span>&lt;</span><span>?</span><span>></span></span> invoker <span>=</span> <span>getInvoker</span><span>(</span>channel<span>,</span> inv<span>)</span><span>;</span>\n                <span>//如果是callback 需要处理高版本调用低版本的问题</span>\n                <span>if</span> <span>(</span><span>Boolean</span><span>.</span>TRUE<span>.</span><span>toString</span><span>(</span><span>)</span><span>.</span><span>equals</span><span>(</span>inv<span>.</span><span>getAttachments</span><span>(</span><span>)</span><span>.</span><span>get</span><span>(</span>IS_CALLBACK_SERVICE_INVOKE<span>)</span><span>)</span><span>)</span><span>{</span>\n                    <span>String</span> methodsStr <span>=</span> invoker<span>.</span><span>getUrl</span><span>(</span><span>)</span><span>.</span><span>getParameters</span><span>(</span><span>)</span><span>.</span><span>get</span><span>(</span><span>\"methods\"</span><span>)</span><span>;</span>\n                    <span>boolean</span> hasMethod <span>=</span> <span>false</span><span>;</span>\n                    <span>if</span> <span>(</span>methodsStr <span>==</span> <span>null</span> <span>||</span> methodsStr<span>.</span><span>indexOf</span><span>(</span><span>\",\"</span><span>)</span> <span>==</span> <span>-</span><span>1</span><span>)</span><span>{</span>\n                        hasMethod <span>=</span> inv<span>.</span><span>getMethodName</span><span>(</span><span>)</span><span>.</span><span>equals</span><span>(</span>methodsStr<span>)</span><span>;</span>\n                    <span>}</span> <span>else</span> <span>{</span>\n                        <span>String</span><span>[</span><span>]</span> methods <span>=</span> methodsStr<span>.</span><span>split</span><span>(</span><span>\",\"</span><span>)</span><span>;</span>\n                        <span>for</span> <span>(</span><span>String</span> method <span>:</span> methods<span>)</span><span>{</span>\n                            <span>if</span> <span>(</span>inv<span>.</span><span>getMethodName</span><span>(</span><span>)</span><span>.</span><span>equals</span><span>(</span>method<span>)</span><span>)</span><span>{</span>\n                                hasMethod <span>=</span> <span>true</span><span>;</span>\n                                <span>break</span><span>;</span>\n                            <span>}</span>\n                        <span>}</span>\n                    <span>}</span>\n                    <span>if</span> <span>(</span><span>!</span>hasMethod<span>)</span><span>{</span>\n                        logger<span>.</span><span>warn</span><span>(</span><span>new</span> <span>IllegalStateException</span><span>(</span><span>\"The methodName \"</span><span>+</span>inv<span>.</span><span>getMethodName</span><span>(</span><span>)</span><span>+</span><span>\" not found in callback service interface ,invoke will be ignored. please update the api interface. url is:\"</span> <span>+</span> invoker<span>.</span><span>getUrl</span><span>(</span><span>)</span><span>)</span> <span>+</span><span>\" ,invocation is :\"</span><span>+</span>inv <span>)</span><span>;</span>\n                        <span>return</span> <span>null</span><span>;</span>\n                    <span>}</span>\n                <span>}</span>\n                <span>RpcContext</span><span>.</span><span>getContext</span><span>(</span><span>)</span><span>.</span><span>setRemoteAddress</span><span>(</span>channel<span>.</span><span>getRemoteAddress</span><span>(</span><span>)</span><span>)</span><span>;</span>\n                <span>return</span> invoker<span>.</span><span>invoke</span><span>(</span>inv<span>)</span><span>;</span>\n            <span>}</span>\n            <span>throw</span> <span>new</span> <span>RemotingException</span><span>(</span>channel<span>,</span> <span>\"Unsupported request: \"</span> <span>+</span> message <span>==</span> <span>null</span> <span>?</span> <span>null</span> <span>:</span> <span>(</span>message<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\": \"</span> <span>+</span> message<span>)</span> <span>+</span> <span>\", channel: consumer: \"</span> <span>+</span> channel<span>.</span><span>getRemoteAddress</span><span>(</span><span>)</span> <span>+</span> <span>\" --> provider: \"</span> <span>+</span> channel<span>.</span><span>getLocalAddress</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>//创建服务    </span>\n    <span>private</span> <span>void</span> <span>openServer</span><span>(</span><span>URL</span> url<span>)</span> <span>{</span>\n        <span>// find server.</span>\n        <span>String</span> key <span>=</span> url<span>.</span><span>getAddress</span><span>(</span><span>)</span><span>;</span>\n        <span>//client 也可以暴露一个只有server可以调用的服务。</span>\n        <span>boolean</span> isServer <span>=</span> url<span>.</span><span>getParameter</span><span>(</span><span>Constants</span><span>.</span>IS_SERVER_KEY<span>,</span><span>true</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span>isServer<span>)</span> <span>{</span>\n        \t<span>ExchangeServer</span> server <span>=</span> serverMap<span>.</span><span>get</span><span>(</span>key<span>)</span><span>;</span>\n        \t<span>if</span> <span>(</span>server <span>==</span> <span>null</span><span>)</span> <span>{</span>\n        \t\tserverMap<span>.</span><span>put</span><span>(</span>key<span>,</span> <span>createServer</span><span>(</span>url<span>)</span><span>)</span><span>;</span>\n        \t<span>}</span> <span>else</span> <span>{</span>\n        \t\t<span>//server支持reset,配合override功能使用</span>\n        \t\tserver<span>.</span><span>reset</span><span>(</span>url<span>)</span><span>;</span>\n        \t<span>}</span>\n        <span>}</span>\n    <span>}</span>\n    <span>//创建服务</span>\n    <span>private</span> <span>ExchangeServer</span> <span>createServer</span><span>(</span><span>URL</span> url<span>)</span> <span>{</span>\n        <span>//默认开启server关闭时发送readonly事件</span>\n        url <span>=</span> url<span>.</span><span>addParameterIfAbsent</span><span>(</span><span>Constants</span><span>.</span>CHANNEL_READONLYEVENT_SENT_KEY<span>,</span> <span>Boolean</span><span>.</span>TRUE<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>//默认开启heartbeat</span>\n        url <span>=</span> url<span>.</span><span>addParameterIfAbsent</span><span>(</span><span>Constants</span><span>.</span>HEARTBEAT_KEY<span>,</span> <span>String</span><span>.</span><span>valueOf</span><span>(</span><span>Constants</span><span>.</span>DEFAULT_HEARTBEAT<span>)</span><span>)</span><span>;</span>\n        <span>String</span> str <span>=</span> url<span>.</span><span>getParameter</span><span>(</span><span>Constants</span><span>.</span>SERVER_KEY<span>,</span> <span>Constants</span><span>.</span>DEFAULT_REMOTING_SERVER<span>)</span><span>;</span>\n\n        <span>if</span> <span>(</span>str <span>!=</span> <span>null</span> <span>&amp;&amp;</span> str<span>.</span><span>length</span><span>(</span><span>)</span> <span>></span> <span>0</span> <span>&amp;&amp;</span> <span>!</span> <span>ExtensionLoader</span><span>.</span><span>getExtensionLoader</span><span>(</span><span>Transporter</span><span>.</span><span>class</span><span>)</span><span>.</span><span>hasExtension</span><span>(</span>str<span>)</span><span>)</span>\n            <span>throw</span> <span>new</span> <span>RpcException</span><span>(</span><span>\"Unsupported server type: \"</span> <span>+</span> str <span>+</span> <span>\", url: \"</span> <span>+</span> url<span>)</span><span>;</span>\n\n        url <span>=</span> url<span>.</span><span>addParameter</span><span>(</span><span>Constants</span><span>.</span>CODEC_KEY<span>,</span> <span>Version</span><span>.</span><span>isCompatibleVersion</span><span>(</span><span>)</span> <span>?</span> COMPATIBLE_CODEC_NAME <span>:</span> <span>DubboCodec</span><span>.</span>NAME<span>)</span><span>;</span>\n        <span>ExchangeServer</span> server<span>;</span>\n        <span>try</span> <span>{</span>\n            server <span>=</span> <span>Exchangers</span><span>.</span><span>bind</span><span>(</span>url<span>,</span> requestHandler<span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>RemotingException</span> e<span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>RpcException</span><span>(</span><span>\"Fail to start server(url: \"</span> <span>+</span> url <span>+</span> <span>\") \"</span> <span>+</span> e<span>.</span><span>getMessage</span><span>(</span><span>)</span><span>,</span> e<span>)</span><span>;</span>\n        <span>}</span>\n        str <span>=</span> url<span>.</span><span>getParameter</span><span>(</span><span>Constants</span><span>.</span>CLIENT_KEY<span>)</span><span>;</span>\n        <span>if</span> <span>(</span>str <span>!=</span> <span>null</span> <span>&amp;&amp;</span> str<span>.</span><span>length</span><span>(</span><span>)</span> <span>></span> <span>0</span><span>)</span> <span>{</span>\n            <span>Set</span><span><span>&lt;</span><span>String</span><span>></span></span> supportedTypes <span>=</span> <span>ExtensionLoader</span><span>.</span><span>getExtensionLoader</span><span>(</span><span>Transporter</span><span>.</span><span>class</span><span>)</span><span>.</span><span>getSupportedExtensions</span><span>(</span><span>)</span><span>;</span>\n            <span>if</span> <span>(</span><span>!</span>supportedTypes<span>.</span><span>contains</span><span>(</span>str<span>)</span><span>)</span> <span>{</span>\n                <span>throw</span> <span>new</span> <span>RpcException</span><span>(</span><span>\"Unsupported client type: \"</span> <span>+</span> str<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> server<span>;</span>\n    <span>}</span>    \n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br></div></div><p>我们主要看服务端要的3个方法</p>\n<ul>\n<li>ExchangeHandler逻辑处理器</li>\n<li>创建服务openServer和createServer。\n<ul>\n<li>底层实现NettyTransporter</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"exchangehandler-exchangehandler\"> ExchangeHandler#ExchangeHandler</h4>\n<p>既然我们说了底层是Netty来实现的,那么又知道Netty是通信框架。那么我们来看下服务端的处理逻辑吧。</p>\n<div><pre><code><span>class</span> <span>DubboProtocol</span><span>{</span>\n        <span>private</span> <span>ExchangeHandler</span> requestHandler <span>=</span> <span>new</span> <span>ExchangeHandlerAdapter</span><span>(</span><span>)</span> <span>{</span>\n        <span>public</span> <span>Object</span> <span>reply</span><span>(</span><span>ExchangeChannel</span> channel<span>,</span> <span>Object</span> message<span>)</span> <span>throws</span> <span>RemotingException</span> <span>{</span>\n            <span>if</span> <span>(</span>message <span>instanceof</span> <span>Invocation</span><span>)</span> <span>{</span>\n                <span>Invocation</span> inv <span>=</span> <span>(</span><span>Invocation</span><span>)</span> message<span>;</span>\n                <span>Invoker</span><span><span>&lt;</span><span>?</span><span>></span></span> invoker <span>=</span> <span>getInvoker</span><span>(</span>channel<span>,</span> inv<span>)</span><span>;</span>\n                <span>//如果是callback 需要处理高版本调用低版本的问题</span>\n                <span>if</span> <span>(</span><span>Boolean</span><span>.</span>TRUE<span>.</span><span>toString</span><span>(</span><span>)</span><span>.</span><span>equals</span><span>(</span>inv<span>.</span><span>getAttachments</span><span>(</span><span>)</span><span>.</span><span>get</span><span>(</span>IS_CALLBACK_SERVICE_INVOKE<span>)</span><span>)</span><span>)</span><span>{</span>\n                    <span>String</span> methodsStr <span>=</span> invoker<span>.</span><span>getUrl</span><span>(</span><span>)</span><span>.</span><span>getParameters</span><span>(</span><span>)</span><span>.</span><span>get</span><span>(</span><span>\"methods\"</span><span>)</span><span>;</span>\n                    <span>boolean</span> hasMethod <span>=</span> <span>false</span><span>;</span>\n                    <span>if</span> <span>(</span>methodsStr <span>==</span> <span>null</span> <span>||</span> methodsStr<span>.</span><span>indexOf</span><span>(</span><span>\",\"</span><span>)</span> <span>==</span> <span>-</span><span>1</span><span>)</span><span>{</span>\n                        hasMethod <span>=</span> inv<span>.</span><span>getMethodName</span><span>(</span><span>)</span><span>.</span><span>equals</span><span>(</span>methodsStr<span>)</span><span>;</span>\n                    <span>}</span> <span>else</span> <span>{</span>\n                        <span>String</span><span>[</span><span>]</span> methods <span>=</span> methodsStr<span>.</span><span>split</span><span>(</span><span>\",\"</span><span>)</span><span>;</span>\n                        <span>for</span> <span>(</span><span>String</span> method <span>:</span> methods<span>)</span><span>{</span>\n                            <span>if</span> <span>(</span>inv<span>.</span><span>getMethodName</span><span>(</span><span>)</span><span>.</span><span>equals</span><span>(</span>method<span>)</span><span>)</span><span>{</span>\n                                hasMethod <span>=</span> <span>true</span><span>;</span>\n                                <span>break</span><span>;</span>\n                            <span>}</span>\n                        <span>}</span>\n                    <span>}</span>\n                    <span>if</span> <span>(</span><span>!</span>hasMethod<span>)</span><span>{</span>\n                        logger<span>.</span><span>warn</span><span>(</span><span>new</span> <span>IllegalStateException</span><span>(</span><span>\"The methodName \"</span><span>+</span>inv<span>.</span><span>getMethodName</span><span>(</span><span>)</span><span>+</span><span>\" not found in callback service interface ,invoke will be ignored. please update the api interface. url is:\"</span> <span>+</span> invoker<span>.</span><span>getUrl</span><span>(</span><span>)</span><span>)</span> <span>+</span><span>\" ,invocation is :\"</span><span>+</span>inv <span>)</span><span>;</span>\n                        <span>return</span> <span>null</span><span>;</span>\n                    <span>}</span>\n                <span>}</span>\n                <span>RpcContext</span><span>.</span><span>getContext</span><span>(</span><span>)</span><span>.</span><span>setRemoteAddress</span><span>(</span>channel<span>.</span><span>getRemoteAddress</span><span>(</span><span>)</span><span>)</span><span>;</span>\n                <span>return</span> invoker<span>.</span><span>invoke</span><span>(</span>inv<span>)</span><span>;</span>\n            <span>}</span>\n            <span>throw</span> <span>new</span> <span>RemotingException</span><span>(</span>channel<span>,</span> <span>\"Unsupported request: \"</span> <span>+</span> message <span>==</span> <span>null</span> <span>?</span> <span>null</span> <span>:</span> <span>(</span>message<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\": \"</span> <span>+</span> message<span>)</span> <span>+</span> <span>\", channel: consumer: \"</span> <span>+</span> channel<span>.</span><span>getRemoteAddress</span><span>(</span><span>)</span> <span>+</span> <span>\" --> provider: \"</span> <span>+</span> channel<span>.</span><span>getLocalAddress</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><ul>\n<li>过滤器</li>\n</ul>\n<p><strong>请看注释</strong></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1597060745000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_3-编码器和解码器\"> 3. 编码器和解码器</h3>\n<p>这里稍微说一点编码器,dubbo协议的编码器。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1597057272000.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code><span>public</span> <span>class</span> <span>NettyServer</span> <span>extends</span> <span>AbstractServer</span> <span>implements</span> <span>Server</span> <span>{</span>\n    \n\n    <span>@Override</span>\n    <span>protected</span> <span>void</span> <span>doOpen</span><span>(</span><span>)</span> <span>throws</span> <span>Throwable</span> <span>{</span>\n        <span>NettyHelper</span><span>.</span><span>setNettyLoggerFactory</span><span>(</span><span>)</span><span>;</span>\n        <span>ExecutorService</span> boss <span>=</span> <span>Executors</span><span>.</span><span>newCachedThreadPool</span><span>(</span><span>new</span> <span>NamedThreadFactory</span><span>(</span><span>\"NettyServerBoss\"</span><span>,</span> <span>true</span><span>)</span><span>)</span><span>;</span>\n        <span>ExecutorService</span> worker <span>=</span> <span>Executors</span><span>.</span><span>newCachedThreadPool</span><span>(</span><span>new</span> <span>NamedThreadFactory</span><span>(</span><span>\"NettyServerWorker\"</span><span>,</span> <span>true</span><span>)</span><span>)</span><span>;</span>\n        <span>ChannelFactory</span> channelFactory <span>=</span> <span>new</span> <span>NioServerSocketChannelFactory</span><span>(</span>boss<span>,</span> worker<span>,</span> <span>getUrl</span><span>(</span><span>)</span><span>.</span><span>getPositiveParameter</span><span>(</span><span>Constants</span><span>.</span>IO_THREADS_KEY<span>,</span> <span>Constants</span><span>.</span>DEFAULT_IO_THREADS<span>)</span><span>)</span><span>;</span>\n        bootstrap <span>=</span> <span>new</span> <span>ServerBootstrap</span><span>(</span>channelFactory<span>)</span><span>;</span>\n        \n        <span>final</span> <span>NettyHandler</span> nettyHandler <span>=</span> <span>new</span> <span>NettyHandler</span><span>(</span><span>getUrl</span><span>(</span><span>)</span><span>,</span> <span>this</span><span>)</span><span>;</span>\n        channels <span>=</span> nettyHandler<span>.</span><span>getChannels</span><span>(</span><span>)</span><span>;</span>\n        <span>// https://issues.jboss.org/browse/NETTY-365</span>\n        <span>// https://issues.jboss.org/browse/NETTY-379</span>\n        <span>// final Timer timer = new HashedWheelTimer(new NamedThreadFactory(\"NettyIdleTimer\", true));</span>\n        bootstrap<span>.</span><span>setPipelineFactory</span><span>(</span><span>new</span> <span>ChannelPipelineFactory</span><span>(</span><span>)</span> <span>{</span>\n            <span>public</span> <span>ChannelPipeline</span> <span>getPipeline</span><span>(</span><span>)</span> <span>{</span>\n                <span>NettyCodecAdapter</span> adapter <span>=</span> <span>new</span> <span>NettyCodecAdapter</span><span>(</span><span>getCodec</span><span>(</span><span>)</span> <span>,</span><span>getUrl</span><span>(</span><span>)</span><span>,</span> <span>NettyServer</span><span>.</span><span>this</span><span>)</span><span>;</span>\n                <span>ChannelPipeline</span> pipeline <span>=</span> <span>Channels</span><span>.</span><span>pipeline</span><span>(</span><span>)</span><span>;</span>\n                <span>/*int idleTimeout = getIdleTimeout();\n                if (idleTimeout > 10000) {\n                    pipeline.addLast(\"timer\", new IdleStateHandler(timer, idleTimeout / 1000, 0, 0));\n                }*/</span>\n                <span>//解码器</span>\n                pipeline<span>.</span><span>addLast</span><span>(</span><span>\"decoder\"</span><span>,</span> adapter<span>.</span><span>getDecoder</span><span>(</span><span>)</span><span>)</span><span>;</span>\n                <span>//编码器</span>\n                pipeline<span>.</span><span>addLast</span><span>(</span><span>\"encoder\"</span><span>,</span> adapter<span>.</span><span>getEncoder</span><span>(</span><span>)</span><span>)</span><span>;</span>\n                pipeline<span>.</span><span>addLast</span><span>(</span><span>\"handler\"</span><span>,</span> nettyHandler<span>)</span><span>;</span>\n                <span>return</span> pipeline<span>;</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n        <span>// bind</span>\n        channel <span>=</span> bootstrap<span>.</span><span>bind</span><span>(</span><span>getBindAddress</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>    \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><p><strong>NettyCodecAdapter adapter = new NettyCodecAdapter(getCodec() ,getUrl(), NettyServer.this);</strong></p>\n<p>主要看这个类<code>Codec2</code></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1597057522000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>我们主要看服务端如何将tcp二进制数据转成dubbo里面的模型。</p>\n<p>客户端: 数据DecodeableRpcInvocation -&gt; 通过编码器转换成 -&gt; 二进制数据</p>\n<p>服务端: 二进制数据 -&gt; 解码器 -&gt; DecodeableRpcInvocation -&gt; DubboProtocol#requestHandler处理</p>\n<h3 id=\"_4-序列化协议\"> 4. 序列化协议</h3>\n<p>java模型如何转二进制,就是序列化协议。我们所说的hession2协议就在这里用的。这里追求的是速度快,数据小。</p>\n<p><code>Serialization s = CodecSupport.getSerialization(channel.getUrl(), proto);</code></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1597058345000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"四、invoker\"> 四、Invoker</h2>\n<p>前面说了dubbo中的模型都想Invoker靠拢。其实说白了就是反射。</p>\n<h3 id=\"_1-生成invoker对象\"> 1. 生成Invoker对象</h3>\n<p>可以看到dubbo里面已经提供了,构建方法。我们先熟悉如何使用其API。然后把这些小的知识点慢慢的串起来就好了。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Tester</span> <span>{</span>\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>buildInvokerTest</span><span>(</span><span>)</span> <span>{</span>\n        <span>JavassistProxyFactory</span> factory <span>=</span> <span>new</span> <span>JavassistProxyFactory</span><span>(</span><span>)</span><span>;</span>\n        <span>UserService</span> userService <span>=</span> <span>new</span> <span>UserServiceImpl</span><span>(</span><span>)</span><span>;</span>\n        <span>URL</span> dubboUrl <span>=</span> URL<span>.</span><span>valueOf</span><span>(</span><span>\"test://\"</span><span>)</span><span>;</span>\n        <span>final</span> <span>Invoker</span><span><span>&lt;</span><span>UserService</span><span>></span></span> invoker <span>=</span> factory<span>.</span><span>getInvoker</span><span>(</span>userService<span>,</span> <span>UserService</span><span>.</span><span>class</span><span>,</span> dubboUrl<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id=\"_2-创建执行参数\"> 2. 创建执行参数</h3>\n<p>Invoker是执行体,Invocation是执行参数</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Tester</span> <span>{</span>\n     <span>public</span> <span>void</span> <span>buildInvokerTest</span><span>(</span><span>)</span> <span>{</span>\n      <span>final</span> <span>Invoker</span><span><span>&lt;</span><span>UserService</span><span>></span></span> invoker <span>=</span> factory<span>.</span><span>getInvoker</span><span>(</span>userService<span>,</span> <span>UserService</span><span>.</span><span>class</span><span>,</span> dubboUrl<span>)</span><span>;</span>\n\n        <span>Invocation</span> invocation <span>=</span> <span>new</span> <span>Invocation</span><span>(</span><span>)</span> <span>{</span>\n\n            <span>public</span> <span>String</span> <span>getMethodName</span><span>(</span><span>)</span> <span>{</span>\n                <span>return</span> <span>\"say\"</span><span>;</span>\n            <span>}</span>\n\n            <span>public</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span><span>[</span><span>]</span> <span>getParameterTypes</span><span>(</span><span>)</span> <span>{</span>\n                <span>return</span> <span>new</span> <span>Class</span><span>[</span><span>]</span><span>{</span><span>String</span><span>.</span><span>class</span><span>}</span><span>;</span>\n            <span>}</span>\n\n            <span>public</span> <span>Object</span><span>[</span><span>]</span> <span>getArguments</span><span>(</span><span>)</span> <span>{</span>\n                <span>return</span> <span>new</span> <span>Object</span><span>[</span><span>]</span><span>{</span><span>\"hello\"</span><span>}</span><span>;</span>\n            <span>}</span>\n\n            <span>public</span> <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> <span>getAttachments</span><span>(</span><span>)</span> <span>{</span>\n                <span>return</span> <span>null</span><span>;</span>\n            <span>}</span>\n\n            <span>public</span> <span>String</span> <span>getAttachment</span><span>(</span><span>String</span> key<span>)</span> <span>{</span>\n                <span>return</span> <span>null</span><span>;</span>\n            <span>}</span>\n\n            <span>public</span> <span>String</span> <span>getAttachment</span><span>(</span><span>String</span> key<span>,</span> <span>String</span> defaultValue<span>)</span> <span>{</span>\n                <span>return</span> <span>null</span><span>;</span>\n            <span>}</span>\n\n            <span>public</span> <span>Invoker</span><span><span>&lt;</span><span>?</span><span>></span></span> <span>getInvoker</span><span>(</span><span>)</span> <span>{</span>\n                <span>return</span> <span>null</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>invoker<span>.</span><span>invoke</span><span>(</span>invocation<span>)</span><span>)</span><span>;</span>\n      <span>}</span> \n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><h3 id=\"_3-构建带有过滤器的invoker\"> 3. 构建带有过滤器的Invoker</h3>\n<div><pre><code><span>@Test</span>\n    <span>public</span> <span>void</span> <span>linkedInvokerTest</span><span>(</span><span>)</span> <span>{</span>\n        <span>JavassistProxyFactory</span> factory <span>=</span> <span>new</span> <span>JavassistProxyFactory</span><span>(</span><span>)</span><span>;</span>\n        <span>UserService</span> userService <span>=</span> <span>new</span> <span>UserServiceImpl</span><span>(</span><span>)</span><span>;</span>\n        <span>URL</span> dubboUrl <span>=</span> URL<span>.</span><span>valueOf</span><span>(</span><span>\"test://\"</span><span>)</span><span>;</span>\n        <span>final</span> <span>Invoker</span><span><span>&lt;</span><span>UserService</span><span>></span></span> invoker <span>=</span> factory<span>.</span><span>getInvoker</span><span>(</span>userService<span>,</span> <span>UserService</span><span>.</span><span>class</span><span>,</span> dubboUrl<span>)</span><span>;</span>\n        <span>List</span><span><span>&lt;</span><span>Filter</span><span>></span></span> filters <span>=</span> <span>new</span> <span>ArrayList</span><span>(</span><span>)</span><span>;</span>\n        <span>Filter</span> filter <span>=</span> <span>new</span> <span>Filter</span><span>(</span><span>)</span> <span>{</span>\n            <span>public</span> <span>Result</span> <span>invoke</span><span>(</span><span>Invoker</span><span><span>&lt;</span><span>?</span><span>></span></span> invoker<span>,</span> <span>Invocation</span> invocation<span>)</span> <span>throws</span> <span>RpcException</span> <span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"-------执行过滤器-------\"</span><span>)</span><span>;</span>\n                <span>return</span> invoker<span>.</span><span>invoke</span><span>(</span>invocation<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>;</span>\n        filters<span>.</span><span>add</span><span>(</span>filter<span>)</span><span>;</span>\n        <span>Invoker</span><span><span>&lt;</span><span>UserService</span><span>></span></span> userServiceInvoker <span>=</span> <span>buildInvokerChain</span><span>(</span>invoker<span>,</span> filters<span>)</span><span>;</span>\n        userServiceInvoker<span>.</span><span>invoke</span><span>(</span><span>new</span> <span>Invocation</span><span>(</span><span>)</span> <span>{</span>\n            <span>public</span> <span>String</span> <span>getMethodName</span><span>(</span><span>)</span> <span>{</span>\n                <span>return</span> <span>\"say\"</span><span>;</span>\n            <span>}</span>\n\n            <span>public</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span><span>[</span><span>]</span> <span>getParameterTypes</span><span>(</span><span>)</span> <span>{</span>\n                <span>return</span> <span>new</span> <span>Class</span><span>[</span><span>]</span><span>{</span><span>String</span><span>.</span><span>class</span><span>}</span><span>;</span>\n            <span>}</span>\n\n            <span>public</span> <span>Object</span><span>[</span><span>]</span> <span>getArguments</span><span>(</span><span>)</span> <span>{</span>\n                <span>return</span> <span>new</span> <span>Object</span><span>[</span><span>]</span><span>{</span><span>\"hello 过滤器\"</span><span>}</span><span>;</span>\n            <span>}</span>\n\n            <span>public</span> <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> <span>getAttachments</span><span>(</span><span>)</span> <span>{</span>\n                <span>return</span> <span>null</span><span>;</span>\n            <span>}</span>\n\n            <span>public</span> <span>String</span> <span>getAttachment</span><span>(</span><span>String</span> key<span>)</span> <span>{</span>\n                <span>return</span> <span>null</span><span>;</span>\n            <span>}</span>\n\n            <span>public</span> <span>String</span> <span>getAttachment</span><span>(</span><span>String</span> key<span>,</span> <span>String</span> defaultValue<span>)</span> <span>{</span>\n                <span>return</span> <span>null</span><span>;</span>\n            <span>}</span>\n\n            <span>public</span> <span>Invoker</span><span><span>&lt;</span><span>?</span><span>></span></span> <span>getInvoker</span><span>(</span><span>)</span> <span>{</span>\n                <span>return</span> <span>null</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n    <span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><h2 id=\"五、总结\"> 五、总结</h2>\n<p><strong>知识点回顾</strong></p>\n<ul>\n<li>如何将对象方法生成Invoker</li>\n<li>如何将Invoker注册到注册地中心</li>\n<li>如何处理客户端的请求</li>\n<li>二进制数据转java数据协议</li>\n<li>协议中包含的序列化知识</li>\n</ul>\n<p>最后求关注,求订阅,谢谢你的阅读!</p>\n<p>下一篇会讲,dubbo如何与Spring进行整合。</p>\n",
      "image": "https://img.springlearn.cn/blog/aa3147663675b9b5692915030cf264b9.png",
      "date_published": "2022-08-22T01:35:49.000Z",
      "date_modified": "2022-08-22T01:35:49.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "java"
      ]
    },
    {
      "title": "dubbo",
      "url": "https://java.springlearn.cn/learn/dubbo/",
      "id": "https://java.springlearn.cn/learn/dubbo/",
      "content_html": "<p><img src=\"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fdingyue.nosdn.127.net%2FE6THXq%3DiQcEIsorT3I0CkBOmDirJ3h7O7kCs%3DrKoxB0Wc1541040371523.jpg&amp;refer=http%3A%2F%2Fdingyue.nosdn.127.net&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1663654489&amp;t=afedceaba71c16648aa56834849aa4d6\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"为什么会有工具系列专题\"> 为什么会有工具系列专题</h3>\n<p>好比, 初入江湖, 要想成为一个武林高手。必须要有一个基础的内功心法。内功心法越高, 练成最上乘武功就越快。\n而这些常用的框架，就是基础的内功心法。当然没有内功心法也能练成上乘武功。只不过可能时间花费会更多点。\n本篇小编分享下常用的Java 工具。这些会在后面我们写框架或者是写业务代码时候。如果你还有更多好的工具,可以留下\n你的评论。我们一起学习。</p>\n",
      "image": "https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fdingyue.nosdn.127.net%2FE6THXq%3DiQcEIsorT3I0CkBOmDirJ3h7O7kCs%3DrKoxB0Wc1541040371523.jpg&refer=http%3A%2F%2Fdingyue.nosdn.127.net&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1663654489&t=afedceaba71c16648aa56834849aa4d6",
      "date_published": "2022-08-22T01:35:49.000Z",
      "date_modified": "2022-08-22T01:35:49.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "java"
      ]
    },
    {
      "title": "Java常用工具汇总",
      "url": "https://java.springlearn.cn/learn/electron/",
      "id": "https://java.springlearn.cn/learn/electron/",
      "content_html": "<h2 id=\"electron-教程\"> Electron 教程</h2>\n",
      "date_published": "2022-08-22T01:35:49.000Z",
      "date_modified": "2022-08-22T01:35:49.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "java"
      ]
    },
    {
      "title": "组件禁用",
      "url": "https://java.springlearn.cn/learn/guide/disable/",
      "id": "https://java.springlearn.cn/learn/guide/disable/",
      "summary": "<p>你可以通过设置页面的 Frontmatter，在页面禁用一些功能。</p>\n",
      "content_html": "<p>你可以通过设置页面的 Frontmatter，在页面禁用一些功能。</p>\n\n<p>本页面应当禁用了:</p>\n<ul>\n<li>导航栏</li>\n<li>侧边栏</li>\n<li>路径导航</li>\n<li>页面信息</li>\n<li>贡献者</li>\n<li>编辑此页链接</li>\n<li>更新时间</li>\n<li>上一篇/下一篇 链接</li>\n<li>评论</li>\n<li>页脚</li>\n<li>返回顶部按钮</li>\n</ul>\n",
      "date_published": "2021-12-21T05:46:37.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "使用指南"
      ]
    },
    {
      "title": "我开源了我的图床软件",
      "url": "https://java.springlearn.cn/learn/electron/%E5%9B%BE%E5%BA%8A%E8%BD%AF%E4%BB%B6%E7%A4%BA%E4%BE%8B/",
      "id": "https://java.springlearn.cn/learn/electron/%E5%9B%BE%E5%BA%8A%E8%BD%AF%E4%BB%B6%E7%A4%BA%E4%BE%8B/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/learn_1659014013000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"前言\"> 前言</h2>\n<p>今天下班前，小编看到隔壁老李，竟然买了一个图床工具。我当场大呵!\n小李呀，你咋不找我啊。我有多款免费的图床工具, 全部不要钱。</p>\n<p>小李当场吐血去世!</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1659014390000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>都2222年了，不会有人不知道什么是图床吧。</p>\n<h2 id=\"什么是图床\"> 什么是图床?</h2>\n<p>图床其实就是放图片的空间，我们在网络上浏览的图片，其实都存放在网络的服务器上的，比如qq空间，csdn等等网站。</p>\n<p>那么既然上面这些网站都已经给我们提供了图床，我们为啥还要自己搭建图床呢? 不知道大家有没有发现，我们在qq空间或者是csdn上传的图片。如果要在其他网站上去引用。这些平台会自动给你加了一个水印。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1659014804000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>还有更气人的，它直接给你403，然后给你显示一个其他的图片。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1659014921000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>所以说对于那些个人博客网站，千万不能使用外链的图片，否则可能那天就不能在访问了。前车之鉴，后车请自动饶坑。</p>\n<h2 id=\"申请免费空间-自定义水印\"> 申请免费空间 + 自定义水印</h2>\n<p>前面我们说了图床是什么，其实就是找个能放图片的网络空间。那么有没有免费的空间呢? 当然有了。某🐂 云对个人用户提供10g的免费空间。你写博客用不了10g吧。另外还支持cdn加速，还能自定义水印。</p>\n<p>以免被认为小编是在说广告，这里就不说是哪个厂子了。如果有人知道的，可以留下评论。如果不知道的点击关注，我们细细再聊。</p>\n<p>下面教大家如何正确使用图床，然后做一个懒人。</p>\n<h2 id=\"懒人1-0版本\"> 懒人1.0版本</h2>\n<p>基于python写的一个脚本。先演示。这个脚本的好处是，任何文件都能上传。不管是图片还是文件，都可以上传的个人空间。坏处是每次要上传文件都要进到命令控制台。</p>\n<p><img src=\"https://img.springlearn.cn/learn_af73829d6dc06e603eea011da75a30f9.41.01.gif\" alt=\"\" loading=\"lazy\"></p>\n<p>以下脚本送上，拿走不谢。这个脚本我用了1年。后来我又变懒了。于是懒人2.0版本要出来了。</p>\n<div><pre><code>from prettytable import PrettyTable\nimport argparse\nimport hashlib\nimport time\nimport uuid\nfrom colorama import init, Fore, Back\n\n\nclass Color:\n    @staticmethod\n    def red(s, isLight=False):\n        if not isLight:\n            return Fore.RED + s + Fore.RESET\n        return Fore.LIGHTRED_EX + s + Fore.RESET\n\n    @staticmethod\n    def green(s, isLight=False):\n        if not isLight:\n            return Fore.GREEN + s + Fore.RESET\n        return Fore.LIGHTGREEN_EX + s + Fore.RESET\n\n    @staticmethod\n    def yellow(s, isLight=False):\n        if not isLight:\n            return Fore.YELLOW + s + Fore.RESET\n        return Fore.LIGHTYELLOW_EX + s + Fore.RESET\n\n    @staticmethod\n    def white(s, isLight=False):\n        if not isLight:\n            return Fore.WHITE + s + Fore.RESET\n        return Fore.LIGHTWHITE_EX + s + Fore.RESET\n\n    @staticmethod\n    def blue(s, isLight=False):\n        if not isLight:\n            return Fore.BLUE + s + Fore.RESET\n        return Fore.LIGHTBLUE_EX + s + Fore.RESET\n\n    @staticmethod\n    def black(s, isLight=False):\n        if not isLight:\n            return Fore.BLACK + s + Fore.RESET\n        return Fore.LIGHTBLACK_EX + s + Fore.RESET\n\n\ndef fileByLocation(fileLocation):\n    &#39;&#39;&#39;从完整的路径名计算出文件名&#39;&#39;&#39;\n    if fileLocation.count(&#39;/&#39;) &gt; 0:\n        return fileLocation.split(&#39;/&#39;)[-1]\n    else:\n        return fileLocation\n\n\ndef fileNameEncode(fileName, prefix):\n    &#39;&#39;&#39;文件名加密,使用md算法&#39;&#39;&#39;\n    index = fileName.index(&#39;.&#39;)\n    random_str = str(uuid.uuid1())\n    preFileName = fileName[0:index] + random_str;\n    fileEncode = hashlib.md5(preFileName.encode(encoding=&#39;UTF-8&#39;)).hexdigest()\n    suffix = fileName[index:]\n    return prefix + &#39;_&#39; + fileEncode + suffix\n\n\ndef checkBucketName(bucket_name):\n    if not bucket_name:\n        return &quot;springlearn&quot;\n    return bucket_name\n\n\nparser = argparse.ArgumentParser(description=&quot;图床工具&quot;)\nparser.add_argument(&#39;-i&#39;, &#39;--imgLocation&#39;, type=str, help=&#39;文件地址&#39;)\nparser.add_argument(&#39;-b&#39;, &#39;--bucket_name&#39;, type=str, help=&#39;bucket_name&#39;)\nparser.add_argument(&#39;-p&#39;, &#39;--prefix&#39;, type=str, help=&#39;bucket_name&#39;)\nargs = parser.parse_args()\nbucket_name = checkBucketName(args.bucket_name)\n# 文件的完整路径\nfileLocation = args.imgLocation\n# 命名前缀\nprefix = args.prefix\n# 根据文件路径获取文件名\nfileName = fileByLocation(fileLocation)\n# 对文件名进行加密\nif (prefix == None):\n    key = fileNameEncode(fileName, &quot;learn&quot;)\n\nelse:\n    key = fileNameEncode(fileName, prefix)\n\naccess_key = &#39;换成自己的秘钥&#39;\nsecret_key = &#39;换成自己的秘钥&#39;\n\nq = Auth(access_key, secret_key)\ntoken = q.upload_token(bucket_name, key, 3600)\nret, info = put_file(token, key, fileLocation)\n\nbase_table_head = [&quot;文件名&quot;, &quot;加密文件名&quot;, &quot;上传路径&quot;, &quot;外链&quot;, &quot;时间&quot;, &quot;成功&quot;]\ntable = PrettyTable(base_table_head)\nraw = list()\nraw.append(fileName)\nraw.append(key)\nraw.append(fileLocation)\nraw.append(&quot;https://img.springlearn.cn/{0}&quot;.format(key))\nraw.append(time.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;))\nraw.append(info.ok())\ntable.add_row(raw)\nprint(Color.green(str(table)))\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br></div></div><h2 id=\"懒人2-0版本\"> 懒人2.0版本</h2>\n<p>懒人2.0就是解决，懒人1.0的问题，不再需要每次上传时候进入到控制台，只要进行截图。然后输入快捷键，就会自动读取粘贴板图片进行上传，上传后发送通知，并且自动转换成markdown语法，重新放到粘贴板中，然后只用ctrl+v黏贴就可以了。于是我又又用了一年。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1659016174000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>上面就是软件打开的样子，什么都没有，只绑定了一个快捷键。😂\n如此简单。当执行快捷键后会自动上传，然后发出一个通知。如下。点击通知后自动打开图片，ctrl+v后直接输出到文档中。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1659016220000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>于是我又用了一年。后来我又又又变懒了。于是懒人3.0诞生了。</p>\n<h2 id=\"懒人3-0版本\"> 懒人3.0版本</h2>\n<p><img src=\"https://img.springlearn.cn/blog/1e74e710252219faaacec102c33eff32.png\" alt=\"\" loading=\"lazy\"></p>\n<p>懒人3.0版本，我甚至连快捷键都不想按了。我还变的贪心了，我不仅要有快捷键我还要可视化，所见即所得，凡是能看到的图片都可以直接拖动上传，并且要具备我懒人2.0所有的功能。我甚至为了\n解决看时间的问题，我还添加了一个时钟功能，来提醒我: 打工人，六点了，该下班了。不要在卷了。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1659016599000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>甚至为了保护我的眼镜，还增加了一个主题功能，一键打开暗黑模式。</p>\n<p><img src=\"https://img.springlearn.cn/blog/6dda96052f0ae124d10ce45fd62754e6.png\" alt=\"\" loading=\"lazy\"></p>\n<hr>\n<h2 id=\"分享给大家\"> 分享给大家</h2>\n<p><strong>最后我把他开源了</strong>，支持window和mac系统。我想我应该还能再用一年吧。毕竟我还没想到，有更懒人的办法。</p>\n<p><img src=\"https://img.springlearn.cn/blog/38e536df54407e400d87d13354b777bd.png\" alt=\"\" loading=\"lazy\"></p>\n<p>友情提醒: 如果要使用，最终还是要配置个人的空间。如果不会配置的，点击关注，我们细细交流。每人10个g免费个人空间。不用白不用。当然如果需要的话，也可以学习一下。如果不想学习就别折腾了，毕竟要费点脑子。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1659017176000.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1659014013000.png",
      "date_published": "2022-08-22T01:35:49.000Z",
      "date_modified": "2022-08-22T01:35:49.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "java"
      ]
    },
    {
      "title": "密码加密的文章",
      "url": "https://java.springlearn.cn/learn/guide/encrypt/",
      "id": "https://java.springlearn.cn/learn/guide/encrypt/",
      "content_html": "<h1 id=\"密码加密的文章\"> 密码加密的文章</h1>\n<p>实际的文章内容。</p>\n<p>段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字。</p>\n<p>段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字。</p>\n",
      "date_published": "2021-12-21T05:46:37.000Z",
      "date_modified": "2021-12-21T05:46:37.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "使用指南"
      ]
    },
    {
      "title": "dubbo适配Spring原理",
      "url": "https://java.springlearn.cn/learn/dubbo/dubbo%E6%95%B4%E5%90%88spring%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/",
      "id": "https://java.springlearn.cn/learn/dubbo/dubbo%E6%95%B4%E5%90%88spring%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/",
      "content_html": "<blockquote>\n<p>前面两篇博文,主要讲dubbo服务端和客户端的知识点,在对服务端和客户端有了一个新的认识之后,我们本篇 来看下spring是如何整合dubbo服务的</p>\n</blockquote>\n<h2 id=\"一、整合dubbo的两种方式\"> 一、整合dubbo的两种方式</h2>\n<p>spring中使用dubbo一共有两种方式。这两种方式只是在解析dubbo类时候不同。一种通过xml方式，一种注解标签方式。\n下面我们说下他们的原理。</p>\n<ol>\n<li>xml方式</li>\n<li>注解方式</li>\n</ol>\n<h2 id=\"二、两种方式原理\"> 二、两种方式原理</h2>\n<h3 id=\"_1-namespacehandler-xml方式\"> 1. NamespaceHandler(xml方式)</h3>\n<p>NamespaceHandler是spring提供的解析标签的类。dubbo首先继承该接口。在初始化时候\n给每个标签绑定一个解析器。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>DubboNamespaceHandler</span> <span>extends</span> <span>NamespaceHandlerSupport</span> <span>{</span>\n\n\t<span>static</span> <span>{</span>\n\t\t<span>Version</span><span>.</span><span>checkDuplicate</span><span>(</span><span>DubboNamespaceHandler</span><span>.</span><span>class</span><span>)</span><span>;</span>\n\t<span>}</span>\n\n\t<span>public</span> <span>void</span> <span>init</span><span>(</span><span>)</span> <span>{</span>\n\t    <span>registerBeanDefinitionParser</span><span>(</span><span>\"application\"</span><span>,</span> <span>new</span> <span>DubboBeanDefinitionParser</span><span>(</span><span>ApplicationConfig</span><span>.</span><span>class</span><span>,</span> <span>true</span><span>)</span><span>)</span><span>;</span>\n        <span>registerBeanDefinitionParser</span><span>(</span><span>\"module\"</span><span>,</span> <span>new</span> <span>DubboBeanDefinitionParser</span><span>(</span><span>ModuleConfig</span><span>.</span><span>class</span><span>,</span> <span>true</span><span>)</span><span>)</span><span>;</span>\n        <span>registerBeanDefinitionParser</span><span>(</span><span>\"registry\"</span><span>,</span> <span>new</span> <span>DubboBeanDefinitionParser</span><span>(</span><span>RegistryConfig</span><span>.</span><span>class</span><span>,</span> <span>true</span><span>)</span><span>)</span><span>;</span>\n        <span>registerBeanDefinitionParser</span><span>(</span><span>\"monitor\"</span><span>,</span> <span>new</span> <span>DubboBeanDefinitionParser</span><span>(</span><span>MonitorConfig</span><span>.</span><span>class</span><span>,</span> <span>true</span><span>)</span><span>)</span><span>;</span>\n        <span>registerBeanDefinitionParser</span><span>(</span><span>\"provider\"</span><span>,</span> <span>new</span> <span>DubboBeanDefinitionParser</span><span>(</span><span>ProviderConfig</span><span>.</span><span>class</span><span>,</span> <span>true</span><span>)</span><span>)</span><span>;</span>\n        <span>registerBeanDefinitionParser</span><span>(</span><span>\"consumer\"</span><span>,</span> <span>new</span> <span>DubboBeanDefinitionParser</span><span>(</span><span>ConsumerConfig</span><span>.</span><span>class</span><span>,</span> <span>true</span><span>)</span><span>)</span><span>;</span>\n        <span>registerBeanDefinitionParser</span><span>(</span><span>\"protocol\"</span><span>,</span> <span>new</span> <span>DubboBeanDefinitionParser</span><span>(</span><span>ProtocolConfig</span><span>.</span><span>class</span><span>,</span> <span>true</span><span>)</span><span>)</span><span>;</span>\n        <span>registerBeanDefinitionParser</span><span>(</span><span>\"service\"</span><span>,</span> <span>new</span> <span>DubboBeanDefinitionParser</span><span>(</span><span>ServiceBean</span><span>.</span><span>class</span><span>,</span> <span>true</span><span>)</span><span>)</span><span>;</span>\n        <span>registerBeanDefinitionParser</span><span>(</span><span>\"reference\"</span><span>,</span> <span>new</span> <span>DubboBeanDefinitionParser</span><span>(</span><span>ReferenceBean</span><span>.</span><span>class</span><span>,</span> <span>false</span><span>)</span><span>)</span><span>;</span>\n        <span>registerBeanDefinitionParser</span><span>(</span><span>\"annotation\"</span><span>,</span> <span>new</span> <span>DubboBeanDefinitionParser</span><span>(</span><span>AnnotationBean</span><span>.</span><span>class</span><span>,</span> <span>true</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p><img src=\"https://img.springlearn.cn/blog/learn_1597065763000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>到这里spring就能解析各种的dubbo标签了。</p>\n<h3 id=\"_2-解析注解方式\"> 2. 解析注解方式</h3>\n<ul>\n<li>服务端: BeanPostProcessor#postProcessAfterInitialization在服务端初始化后来根据Service注解生成服务并导出。</li>\n<li>客户端: BeanPostProcessor#postProcessBeforeInitialization客户端在初始化前解析Reference,并注入到bean中</li>\n</ul>\n<h2 id=\"三、服务端servicebean\"> 三、服务端ServiceBean</h2>\n<p>服务端使用@Service或者是xml解析参数生成ServiceBean,用Spring进行管理处理容器完成事件和bean初始化事件来来导出服务。</p>\n<p>ServiceBean是一个被Spring管理的bean。</p>\n<ul>\n<li>实现了InitializingBean#afterPropertiesSet初始化方法</li>\n<li>实现了DisposableBean#destory销毁方法</li>\n<li>实现了ApplicationListener的事件方法onApplicationEvent</li>\n<li>实现了ApplicationContextAware注入上下文</li>\n<li>实现了BeanNameAware注入beanName</li>\n</ul>\n<p>其中当Spring容器启动了,会发出<code>ContextRefreshedEvent</code>事件</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1597066316000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"四、客户端referencebean\"> 四、客户端ReferenceBean</h2>\n<p>客户端使用Reference生成ReferenceBean,ReferenceBean是一个FactoryBean。</p>\n<p>ReferenceBean#getObject来生成代理类。</p>\n<div><pre><code>   <span>public</span> <span>Object</span> <span>getObject</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>return</span> <span>get</span><span>(</span><span>)</span><span>;</span>\n   <span>}</span>\n   <span>public</span> <span>synchronized</span> <span>T</span> <span>get</span><span>(</span><span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>destroyed<span>)</span><span>{</span>\n            <span>throw</span> <span>new</span> <span>IllegalStateException</span><span>(</span><span>\"Already destroyed!\"</span><span>)</span><span>;</span>\n        <span>}</span>\n    \t<span>if</span> <span>(</span>ref <span>==</span> <span>null</span><span>)</span> <span>{</span>\n    \t\t<span>init</span><span>(</span><span>)</span><span>;</span>\n    \t<span>}</span>\n    \t<span>return</span> ref<span>;</span>\n    <span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id=\"五、总结\"> 五、总结</h2>\n<p>导出服务和创建远程服务的本地代理。原理是就是netty实现的。这是dubbo的逻辑。本篇就不说了。本篇的重点是\nspring是如何整合dubbo的。你学习到了吗?</p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1597065763000.png",
      "date_published": "2022-08-22T01:35:49.000Z",
      "date_modified": "2022-08-22T01:35:49.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "java"
      ]
    },
    {
      "title": "Markdown 增强",
      "url": "https://java.springlearn.cn/learn/guide/markdown/",
      "id": "https://java.springlearn.cn/learn/guide/markdown/",
      "summary": "<p><code>vuepress-theme-hope</code> 通过内置 <a href=\"https://vuepress-theme-hope.github.io/md-enhance\" target=\"_blank\" rel=\"noopener noreferrer\">md-enhance</a>，在 Markdown 中启用了更多的语法与新功能。</p>\n",
      "content_html": "<p><code>vuepress-theme-hope</code> 通过内置 <a href=\"https://vuepress-theme-hope.github.io/md-enhance\" target=\"_blank\" rel=\"noopener noreferrer\">md-enhance</a>，在 Markdown 中启用了更多的语法与新功能。</p>\n\n<h2 id=\"一键启用\"> 一键启用</h2>\n<p>你可以设置 <code>themeconfig.mdEnhance.enableAll</code> 启用 <a href=\"https://vuepress-theme-hope.github.io/md-enhance\" target=\"_blank\" rel=\"noopener noreferrer\">md-enhance</a> 插件的所有功能。</p>\n<div><div><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br></div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>\n  <span>themeConfig</span><span>:</span> <span>{</span>\n    <span>mdEnhance</span><span>:</span> <span>{</span>\n      <span>enableAll</span><span>:</span> <span>true</span><span>,</span>\n    <span>}</span><span>,</span>\n  <span>}</span><span>,</span>\n<span>}</span><span>;</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id=\"新增的更多语法\"> 新增的更多语法</h2>\n<h3 id=\"上下角标\"> 上下角标</h3>\n<p>19<sup>th</sup> H<sub>2</sub>O</p>\n<details><summary>代码</summary>\n<div><pre><code>19^th^ H<span><span>~</span><span>2</span><span>~</span></span>O\n</code></pre>\n<div><span>1</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/zh/guide/markdown/sup-sub/\" target=\"_blank\" rel=\"noopener noreferrer\">点击查看</a></li>\n</ul>\n<h3 id=\"自定义对齐\"> 自定义对齐</h3>\n<div>\n<p>我是居中的</p>\n</div>\n<div>\n<p>我在右对齐</p>\n</div>\n<details><summary>代码</summary>\n<div><pre><code>::: center\n\n我是居中的\n\n:::\n\n::: right\n\n我在右对齐\n\n:::\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/zh/guide/markdown/align/\" target=\"_blank\" rel=\"noopener noreferrer\">点击查看</a></li>\n</ul>\n<h3 id=\"脚注\"> 脚注</h3>\n<p>此文字有脚注<sup></sup>.</p>\n<details><summary>代码</summary>\n<div><pre><code>此文字有脚注[^first].\n\n<span><span>[</span><span>^first</span><span>]</span><span>:</span> 这是脚注内容</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/zh/guide/markdown/footnote/\" target=\"_blank\" rel=\"noopener noreferrer\">点击查看</a></li>\n</ul>\n<h3 id=\"标记\"> 标记</h3>\n<p>你可以标记 <mark>重要的内容</mark> 。</p>\n<details><summary>代码</summary>\n<div><pre><code>你可以标记 ==重要的内容== 。\n</code></pre>\n<div><span>1</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/zh/guide/markdown/mark/\" target=\"_blank\" rel=\"noopener noreferrer\">点击查看</a></li>\n</ul>\n<h3 id=\"任务列表\"> 任务列表</h3>\n<ul>\n<li><input type=\"checkbox\" checked=\"checked\" disabled=\"disabled\" id=\"task-item-0\"><label for=\"task-item-0\"> 计划 1</label></li>\n<li><input type=\"checkbox\"  disabled=\"disabled\" id=\"task-item-1\"><label for=\"task-item-1\"> 计划 2</label></li>\n</ul>\n<details><summary>Code</summary>\n<div><pre><code><span>-</span> [x] 计划 1\n<span>-</span> [ ] 计划 2\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/guide/markdown/tasklist/\" target=\"_blank\" rel=\"noopener noreferrer\">点击查看</a></li>\n</ul>\n<h3 id=\"流程图\"> 流程图</h3>\n<i>Not supported content</i><details><summary>代码</summary>\n<div><pre><code><span><span>```</span><span>flow</span>\n<span>cond=>condition: Process?\nprocess=>operation: Process\ne=>end: End\n\ncond(yes)->process->e\ncond(no)->e</span>\n<span>```</span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/zh/guide/markdown/flowchart/\" target=\"_blank\" rel=\"noopener noreferrer\">点击查看</a></li>\n</ul>\n<h2 id=\"mermaid\"> Mermaid</h2>\n<Mermaid id=\"mermaid-64a57060\" data-code=\"graph%20TD%3B%0A%20%20%20%20A--%3EB%3B%0A%20%20%20%20A--%3EC%3B%0A%20%20%20%20B--%3ED%3B%0A%20%20%20%20C--%3ED%3B%0A\"></Mermaid><details><summary>代码</summary>\n<div><pre><code><span><span>```</span><span>mermaid</span>\n<span>graph TD;\n    A-->B;\n    A-->C;\n    B-->D;\n    C-->D;</span>\n<span>```</span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/zh/guide/markdown/mermaid/\" target=\"_blank\" rel=\"noopener noreferrer\">点击查看</a></li>\n</ul>\n<h3 id=\"tex-语法\"> Tex 语法</h3>\n<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:2.4em;vertical-align:-0.95em;\"></span><span><span></span><span><span><span><span style=\"height:1.3714em;\"><span style=\"top:-2.314em;\"><span style=\"height:3em;\"></span><span><span style=\"margin-right:0.05556em;\">∂</span><span><span style=\"margin-right:0.03588em;\">ω</span><span><span><span><span style=\"height:0.5904em;\"><span style=\"top:-2.989em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span style=\"margin-right:0.02778em;\">r</span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span style=\"height:3em;\"></span><span style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span style=\"height:3em;\"></span><span><span><span style=\"margin-right:0.05556em;\">∂</span><span><span><span><span style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span style=\"margin-right:0.02778em;\">r</span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style=\"height:0.686em;\"><span></span></span></span></span></span><span></span></span><span style=\"margin-right:0.1667em;\"></span><span><span style=\"top:0em;\"><span>(</span></span><span><span></span><span><span><span><span style=\"height:1.3414em;\"><span style=\"top:-2.314em;\"><span style=\"height:3em;\"></span><span><span style=\"margin-right:0.03588em;\">ω</span></span></span><span style=\"top:-3.23em;\"><span style=\"height:3em;\"></span><span style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span style=\"height:3em;\"></span><span><span><span style=\"margin-right:0.03588em;\">y</span><span><span><span><span style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span style=\"margin-right:0.03588em;\">ω</span></span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style=\"height:0.686em;\"><span></span></span></span></span></span><span></span></span><span style=\"top:0em;\"><span>)</span></span></span><span style=\"margin-right:0.2778em;\"></span><span>=</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:3.0277em;vertical-align:-1.2777em;\"></span><span><span style=\"top:0em;\"><span>(</span></span><span><span></span><span><span><span><span style=\"height:1.3414em;\"><span style=\"top:-2.314em;\"><span style=\"height:3em;\"></span><span><span style=\"margin-right:0.03588em;\">ω</span></span></span><span style=\"top:-3.23em;\"><span style=\"height:3em;\"></span><span style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span style=\"height:3em;\"></span><span><span><span style=\"margin-right:0.03588em;\">y</span><span><span><span><span style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span style=\"margin-right:0.03588em;\">ω</span></span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style=\"height:0.686em;\"><span></span></span></span></span></span><span></span></span><span style=\"top:0em;\"><span>)</span></span></span><span style=\"margin-right:0.1667em;\"></span><span><span style=\"top:0em;\"><span>{</span></span><span>(</span><span>lo<span style=\"margin-right:0.01389em;\">g</span></span><span style=\"margin-right:0.1667em;\"></span><span style=\"margin-right:0.03588em;\">y</span><span><span>)</span><span><span><span><span style=\"height:0.7144em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span style=\"margin-right:0.02778em;\">r</span></span></span></span></span></span></span></span><span style=\"margin-right:0.2222em;\"></span><span>+</span><span style=\"margin-right:0.2222em;\"></span><span><span><span><span style=\"height:1.6514em;\"><span style=\"top:-1.8723em;margin-left:0em;\"><span style=\"height:3.05em;\"></span><span><span><span>i</span><span>=</span><span>1</span></span></span></span><span style=\"top:-3.05em;\"><span style=\"height:3.05em;\"></span><span><span>∑</span></span></span><span style=\"top:-4.3em;margin-left:0em;\"><span style=\"height:3.05em;\"></span><span><span style=\"margin-right:0.02778em;\">r</span></span></span></span><span>​</span></span><span><span style=\"height:1.2777em;\"><span></span></span></span></span></span><span style=\"margin-right:0.1667em;\"></span><span><span></span><span><span><span><span style=\"height:1.5017em;\"><span style=\"top:-2.314em;\"><span style=\"height:3em;\"></span><span><span><span style=\"margin-right:0.03588em;\">ω</span><span><span><span><span style=\"height:0.7507em;\"><span style=\"top:-2.989em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>i</span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span style=\"height:3em;\"></span><span style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span style=\"height:3em;\"></span><span><span>(</span><span>−</span><span>1</span><span><span>)</span><span><span><span><span style=\"height:0.8247em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>i</span></span></span></span></span></span></span></span><span style=\"margin-right:0.02778em;\">r</span><span style=\"margin-right:0.1667em;\"></span><span>⋯</span><span style=\"margin-right:0.1667em;\"></span><span>(</span><span style=\"margin-right:0.02778em;\">r</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span><span>i</span><span style=\"margin-right:0.2222em;\"></span><span>+</span><span style=\"margin-right:0.2222em;\"></span><span>1</span><span>)</span><span>(</span><span>lo<span style=\"margin-right:0.01389em;\">g</span></span><span style=\"margin-right:0.1667em;\"></span><span style=\"margin-right:0.03588em;\">y</span><span><span>)</span><span><span><span><span style=\"height:0.8247em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span style=\"margin-right:0.02778em;\">r</span><span>−</span><span>i</span></span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style=\"height:0.686em;\"><span></span></span></span></span></span><span></span></span><span style=\"top:0em;\"><span>}</span></span></span></span></span></span></span></p>\n<details><summary>代码</summary>\n<div><pre><code>$$\n\\frac {\\partial^r} {\\partial \\omega^r} \\left(\\frac {y^{\\omega}} {\\omega}\\right)\n= \\left(\\frac {y^{\\omega}} {\\omega}\\right) \\left\\{(\\log y)^r + \\sum_{i=1}^r \\frac {(-1)^i r \\cdots (r-i+1) (\\log y)^{r-i}} {\\omega^i} \\right\\}\n$$\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/zh/guide/markdown/tex/\" target=\"_blank\" rel=\"noopener noreferrer\">点击查看</a></li>\n</ul>\n<h3 id=\"代码案例\"> 代码案例</h3>\n\n          <div\n            id=\"code-demo-5ac6bc9f\"\n           \n  \n data-title=\"%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%20Demo\"\n\n            data-code=\"%7B%22html%22%3A%22%3Ch1%3EMr.Hope%3C%2Fh1%3E%5Cn%3Cp%3E%3Cspan%20id%3D%5C%22very%5C%22%3E%E5%8D%81%E5%88%86%3C%2Fspan%3E%20%E5%B8%85%3C%2Fp%3E%5Cn%22%2C%22js%22%3A%22document.querySelector(%5C%22%23very%5C%22).addEventListener(%5C%22click%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20alert(%5C%22%E5%8D%81%E5%88%86%E5%B8%85%5C%22)%3B%5Cn%7D)%3B%5Cn%22%2C%22css%22%3A%22span%20%7B%5Cn%20%20color%3A%20red%3B%5Cn%7D%5Cn%22%7D\"\n          >\n              \n              <div>\n                <div>\n<div><pre><code><span><span><span>&lt;</span>h1</span><span>></span></span>Mr.Hope<span><span><span>&lt;/</span>h1</span><span>></span></span>\n<span><span><span>&lt;</span>p</span><span>></span></span><span><span><span>&lt;</span>span</span> <span>id</span><span><span>=</span><span>\"</span>very<span>\"</span></span><span>></span></span>十分<span><span><span>&lt;/</span>span</span><span>></span></span> 帅<span><span><span>&lt;/</span>p</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><div><pre><code>document<span>.</span><span>querySelector</span><span>(</span><span>\"#very\"</span><span>)</span><span>.</span><span>addEventListener</span><span>(</span><span>\"click\"</span><span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>\n  <span>alert</span><span>(</span><span>\"十分帅\"</span><span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code><span>span</span> <span>{</span>\n  <span>color</span><span>:</span> red<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div>\n            </div>\n          </div>\n          \n        </div>\n<details><summary>代码</summary>\n<div><pre><code>::: demo 一个普通 Demo\n\n<span><span>```</span><span>html</span>\n<span><span><span><span>&lt;</span>h1</span><span>></span></span>Mr.Hope<span><span><span>&lt;/</span>h1</span><span>></span></span>\n<span><span><span>&lt;</span>p</span><span>></span></span><span><span><span>&lt;</span>span</span> <span>id</span><span><span>=</span><span>\"</span>very<span>\"</span></span><span>></span></span>十分<span><span><span>&lt;/</span>span</span><span>></span></span> 帅<span><span><span>&lt;/</span>p</span><span>></span></span></span>\n<span>```</span></span>\n\n<span><span>```</span><span>js</span>\n<span>document<span>.</span><span>querySelector</span><span>(</span><span>\"#very\"</span><span>)</span><span>.</span><span>addEventListener</span><span>(</span><span>\"click\"</span><span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>\n  <span>alert</span><span>(</span><span>\"十分帅\"</span><span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span></span>\n<span>```</span></span>\n\n<span><span>```</span><span>css</span>\n<span><span>span</span> <span>{</span>\n  <span>color</span><span>:</span> red<span>;</span>\n<span>}</span></span>\n<span>```</span></span>\n\n:::\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div></details>\n\n          <div\n            id=\"code-demo-693e1878\"\n           \n  data-type=\"react\"\n data-title=\"%E4%B8%80%E4%B8%AA%20React%20Demo\"\n\n            data-code=\"%7B%22js%22%3A%22export%20default%20class%20App%20extends%20React.Component%20%7B%5Cn%20%20constructor(props)%20%7B%5Cn%20%20%20%20super(props)%3B%5Cn%20%20%20%20this.state%20%3D%20%7B%20message%3A%20%5C%22%E5%8D%81%E5%88%86%E5%B8%85%5C%22%20%7D%3B%5Cn%20%20%7D%5Cn%20%20render()%20%7B%5Cn%20%20%20%20return%20(%5Cn%20%20%20%20%20%20%3Cdiv%20className%3D%5C%22box-react%5C%22%3E%5Cn%20%20%20%20%20%20%20%20Mr.Hope%20%3Cspan%3E%7Bthis.state.message%7D%3C%2Fspan%3E%5Cn%20%20%20%20%20%20%3C%2Fdiv%3E%5Cn%20%20%20%20)%3B%5Cn%20%20%7D%5Cn%7D%5Cn%22%2C%22css%22%3A%22.box-react%20span%20%7B%5Cn%20%20color%3A%20red%3B%5Cn%7D%5Cn%22%7D\"\n          >\n              \n              <div>\n                <div>\n<div><pre><code><span>export</span> <span>default</span> <span>class</span> <span>App</span> <span>extends</span> <span>React<span>.</span>Component</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>props</span><span>)</span> <span>{</span>\n    <span>super</span><span>(</span>props<span>)</span><span>;</span>\n    <span>this</span><span>.</span>state <span>=</span> <span>{</span> <span>message</span><span>:</span> <span>\"十分帅\"</span> <span>}</span><span>;</span>\n  <span>}</span>\n  <span>render</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>(</span>\n      <span>&lt;</span>div className<span>=</span><span>\"box-react\"</span><span>></span>\n        Mr<span>.</span>Hope <span>&lt;</span>span<span>></span><span>{</span><span>this</span><span>.</span>state<span>.</span>message<span>}</span><span>&lt;</span><span>/</span>span<span>></span>\n      <span>&lt;</span><span>/</span>div<span>></span>\n    <span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><div><pre><code><span>.box-react span</span> <span>{</span>\n  <span>color</span><span>:</span> red<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div>\n            </div>\n          </div>\n          \n        </div>\n<details><summary>代码</summary>\n<div><pre><code>::: demo [react] 一个 React Demo\n\n<span><span>```</span><span>js</span>\n<span><span>export</span> <span>default</span> <span>class</span> <span>App</span> <span>extends</span> <span>React<span>.</span>Component</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>props</span><span>)</span> <span>{</span>\n    <span>super</span><span>(</span>props<span>)</span><span>;</span>\n    <span>this</span><span>.</span>state <span>=</span> <span>{</span> <span>message</span><span>:</span> <span>\"十分帅\"</span> <span>}</span><span>;</span>\n  <span>}</span>\n  <span>render</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>(</span>\n      <span>&lt;</span>div className<span>=</span><span>\"box-react\"</span><span>></span>\n        Mr<span>.</span>Hope <span>&lt;</span>span<span>></span><span>{</span><span>this</span><span>.</span>state<span>.</span>message<span>}</span><span>&lt;</span><span>/</span>span<span>></span>\n      <span>&lt;</span><span>/</span>div<span>></span>\n    <span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span></span>\n<span>```</span></span>\n\n<span><span>```</span><span>css</span>\n<span><span>.box-react span</span> <span>{</span>\n  <span>color</span><span>:</span> red<span>;</span>\n<span>}</span></span>\n<span>```</span></span>\n\n:::\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div></details>\n\n          <div\n            id=\"code-demo-2c0b9cdb\"\n           \n  data-type=\"vue\"\n data-title=\"%E4%B8%80%E4%B8%AA%20Vue%20Demo\"\n\n            data-code=\"%7B%22vue%22%3A%22%3Ctemplate%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%5C%22%3E%5Cn%20%20%20%20Mr.Hope%20%3Cspan%3E%7B%7B%20message%20%7D%7D%3C%2Fspan%3E%5Cn%20%20%3C%2Fdiv%3E%5Cn%3C%2Ftemplate%3E%5Cn%3Cscript%3E%5Cnexport%20default%20%7B%5Cn%20%20data%3A%20()%20%3D%3E%20(%7B%20message%3A%20%5C%22%E5%8D%81%E5%88%86%E5%B8%85%5C%22%20%7D)%2C%5Cn%7D%3B%5Cn%3C%2Fscript%3E%5Cn%3Cstyle%3E%5Cn.box%20span%20%7B%5Cn%20%20color%3A%20red%3B%5Cn%7D%5Cn%3C%2Fstyle%3E%5Cn%22%7D\"\n          >\n              \n              <div>\n                <div>\n<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>box<span>\"</span></span><span>></span></span>\n    Mr.Hope <span><span><span>&lt;</span>span</span><span>></span></span>{{ message }}<span><span><span>&lt;/</span>span</span><span>></span></span>\n  <span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;/</span>template</span><span>></span></span>\n<span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n<span>export</span> <span>default</span> <span>{</span>\n  <span>data</span><span>:</span> <span>(</span><span>)</span> <span>=></span> <span>(</span><span>{</span> <span>message</span><span>:</span> <span>\"十分帅\"</span> <span>}</span><span>)</span><span>,</span>\n<span>}</span><span>;</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n<span><span><span>&lt;</span>style</span><span>></span></span><span><span>\n<span>.box span</span> <span>{</span>\n  <span>color</span><span>:</span> red<span>;</span>\n<span>}</span>\n</span></span><span><span><span>&lt;/</span>style</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div>\n            </div>\n          </div>\n          \n        </div>\n<details><summary>代码</summary>\n<div><pre><code>::: demo [vue] 一个 Vue Demo\n\n<span><span>```</span><span>vue</span>\n<span>&lt;template>\n  &lt;div>\n    Mr.Hope &lt;span>{{ message }}&lt;/span>\n  &lt;/div>\n&lt;/template>\n&lt;script>\nexport default {\n  data: () => ({ message: \"十分帅\" }),\n};\n&lt;/script>\n&lt;style>\n.box span {\n  color: red;\n}\n&lt;/style></span>\n<span>```</span></span>\n\n:::\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div></details>\n\n          <div\n            id=\"code-demo-2869b0e2\"\n           \n  \n data-title=\"%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%20Demo\"\n\n            data-code=\"%7B%22md%22%3A%22%23%20%E6%A0%87%E9%A2%98%5Cn%5Cn%E5%8D%81%E5%88%86%E5%B8%85%5Cn%22%2C%22ts%22%3A%22const%20message%3A%20string%20%3D%20%5C%22Mr.Hope%5C%22%3B%5Cn%5Cndocument.querySelector(%5C%22h1%5C%22).innerHTML%20%3D%20message%3B%5Cn%22%2C%22scss%22%3A%22h1%20%7B%5Cn%20%20font-style%3A%20italic%3B%5Cn%5Cn%20%20%2B%20p%20%7B%5Cn%20%20%20%20color%3A%20red%3B%5Cn%20%20%7D%5Cn%7D%5Cn%22%7D\"\n          >\n              \n              <div>\n                <div>\n<div><pre><code><span><span>#</span> 标题</span>\n\n十分帅\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code><span>const</span> message<span>:</span> <span>string</span> <span>=</span> <span>\"Mr.Hope\"</span><span>;</span>\n\ndocument<span>.</span><span>querySelector</span><span>(</span><span>\"h1\"</span><span>)</span><span>.</span>innerHTML <span>=</span> message<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code><span>h1 </span><span>{</span>\n  <span>font-style</span><span>:</span> italic<span>;</span>\n\n  <span>+ p </span><span>{</span>\n    <span>color</span><span>:</span> red<span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div>\n            </div>\n          </div>\n          \n        </div>\n<details><summary>代码</summary>\n<div><pre><code>::: demo 一个普通 Demo\n\n<span><span>```</span><span>md</span>\n<span><span><span>#</span> 标题</span>\n\n十分帅</span>\n<span>```</span></span>\n\n<span><span>```</span><span>ts</span>\n<span><span>const</span> message<span>:</span> <span>string</span> <span>=</span> <span>\"Mr.Hope\"</span><span>;</span>\n\ndocument<span>.</span><span>querySelector</span><span>(</span><span>\"h1\"</span><span>)</span><span>.</span>innerHTML <span>=</span> message<span>;</span></span>\n<span>```</span></span>\n\n<span><span>```</span><span>scss</span>\n<span><span>h1 </span><span>{</span>\n  <span>font-style</span><span>:</span> italic<span>;</span>\n\n  <span>+ p </span><span>{</span>\n    <span>color</span><span>:</span> red<span>;</span>\n  <span>}</span>\n<span>}</span></span>\n<span>```</span></span>\n\n:::\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/zh/guide/markdown/demo/\" target=\"_blank\" rel=\"noopener noreferrer\">点击查看</a></li>\n</ul>\n<h3 id=\"幻灯片\"> 幻灯片</h3>\n<i>Not supported content</i><details><summary>代码</summary>\n<div><pre><code>@slidestart\n\n<span><span>##</span> 幻灯片 1</span>\n\n一个有文字和 <span>[<span>链接</span>](<span>https://mrhope.site</span>)</span> 的段落\n\n<span>---</span>\n\n<span><span>##</span> 幻灯片 2</span>\n\n<span>-</span> 列表 1\n<span>-</span> 列表 2\n\n<span>---</span>\n\n<span><span>##</span> 幻灯片 3.1</span>\n\n<span><span>```</span><span>js</span>\n<span><span>const</span> a <span>=</span> <span>1</span><span>;</span></span>\n<span>```</span></span>\n\n--\n\n<span><span>##</span> 幻灯片 3.2</span>\n\n$$\nJ(\\theta_0,\\theta_1) = \\sum_{i=0}\n$$\n\n@slideend\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/zh/guide/markdown/presentation/\" target=\"_blank\" rel=\"noopener noreferrer\">点击查看</a></li>\n</ul>\n<h2 id=\"其他语法\"> 其他语法</h2>\n<div><p>自定义标题</p>\n<p>信息容器</p>\n</div>\n<div><p>自定义标题</p>\n<p>提示容器</p>\n</div>\n<div><p>自定义标题</p>\n<p>警告容器</p>\n</div>\n<div><p>自定义标题</p>\n<p>危险容器</p>\n</div>\n<details><summary>自定义标题</summary>\n<p>详情容器</p>\n</details>\n<details><summary>代码</summary>\n<div><pre><code>::: info 自定义标题\n\n信息容器\n\n:::\n\n::: tip 自定义标题\n\n提示容器\n\n:::\n\n::: warning 自定义标题\n\n警告容器\n\n:::\n\n::: danger 自定义标题\n\n危险容器\n\n:::\n\n::: details 自定义标题\n\n详情容器\n\n:::\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div></details>\n<hr>\n<section>\n<ol>\n<li id=\"footnote1\"><p>这是脚注内容 </p>\n</li>\n</ol>\n</section>\n",
      "date_published": "2021-12-21T05:46:37.000Z",
      "date_modified": "2021-12-21T05:46:37.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "使用指南"
      ]
    },
    {
      "title": "页面配置",
      "url": "https://java.springlearn.cn/learn/guide/page/",
      "id": "https://java.springlearn.cn/learn/guide/page/",
      "content_html": "<h2 id=\"页面信息\"> 页面信息</h2>\n<p>你可以在 Markdown 的 Frontmatter 中设置页面信息。</p>\n<ul>\n<li>\n<p>作者设置为 Ms.Hope。</p>\n</li>\n<li>\n<p>写作时间应为 2020 年 1 月 1 日</p>\n</li>\n<li>\n<p>分类为 “使用指南”</p>\n</li>\n<li>\n<p>标签为 “页面配置” 和 “使用指南”</p>\n</li>\n</ul>\n<h2 id=\"页面内容\"> 页面内容</h2>\n<p>你可以自由在这里书写你的 Markdown。</p>\n<div><p>提示</p>\n<ul>\n<li>\n<p>Markdown 文件夹的图片请使用相对链接 <code>./</code> 进行引用。</p>\n</li>\n<li>\n<p><code>.vuepress/public</code> 文件夹的图片，请使用绝对链接 <code>/</code> 进行引用</p>\n</li>\n</ul>\n</div>\n<p>主题包含了一个自定义徽章章可以使用:</p>\n<blockquote>\n<p>文字结尾应该有深蓝色的 徽章文字 徽章。 <i>Not supported content</i></p>\n</blockquote>\n<h2 id=\"页面结构\"> 页面结构</h2>\n<p>此页面应当包含：</p>\n<ul>\n<li>返回顶部按钮</li>\n<li>路径导航</li>\n<li>评论</li>\n<li>页脚</li>\n</ul>\n",
      "date_published": "2020-01-01T00:00:00.000Z",
      "date_modified": "2022-05-23T14:56:52.000Z",
      "authors": [
        {
          "name": "Ms.Hope"
        }
      ],
      "tags": [
        "使用指南"
      ]
    },
    {
      "title": "主要功能与配置演示",
      "url": "https://java.springlearn.cn/learn/guide/",
      "id": "https://java.springlearn.cn/learn/guide/",
      "content_html": "<h1 id=\"主要功能与配置演示\"> 主要功能与配置演示</h1>\n<ul>\n<li>\n<p><a href=\"./page.html\">页面展示</a></p>\n</li>\n<li>\n<p><a href=\"./markdown.html\">Markdown 展示</a></p>\n</li>\n<li>\n<p><a href=\"./disable.html\">禁用展示</a></p>\n</li>\n<li>\n<p><a href=\"./encrypt.html\">加密展示</a></p>\n</li>\n</ul>\n",
      "date_published": "2021-12-21T05:46:37.000Z",
      "date_modified": "2021-12-21T05:46:37.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "使用指南"
      ]
    },
    {
      "title": "Home",
      "url": "https://java.springlearn.cn/learn/home/",
      "id": "https://java.springlearn.cn/learn/home/",
      "content_html": "<Djt/>\n<p><img src=\"https://img.springlearn.cn/blog/a982515ed6df23c14bd77c4e6585ff57.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"\"> <i>Not supported content</i> <i>Not supported content</i>  <i>Not supported content</i> <i>Not supported content</i>  <i>Not supported content</i></h2>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1648909278000.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://img.springlearn.cn/blog/a982515ed6df23c14bd77c4e6585ff57.png",
      "date_published": "2021-12-21T05:46:37.000Z",
      "date_modified": "2022-08-22T01:35:49.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Java并发包队列之BlockingQueue",
      "url": "https://java.springlearn.cn/learn/java/BlockingQueue/",
      "id": "https://java.springlearn.cn/learn/java/BlockingQueue/",
      "content_html": "<h2 id=\"一、什么是blockingqueue\"> 一、什么是BlockingQueue</h2>\n<p>BlockingQueue即阻塞队列，从阻塞这个词可以看出，在某些情况下对阻塞队列的访问可能会造成阻塞。被阻塞的情况主要有如下两种：</p>\n<ol>\n<li>当队列满了的时候进行入队列操作</li>\n<li>当队列空了的时候进行出队列操作\n因此，当一个线程试图对一个已经满了的队列进行入队列操作时，它将会被阻塞，除非有另一个线程做了出队列操作；同样，当一个线程试图对一个空队列进行出队列操作时，它将会被阻塞，除非有另一个线程进行了入队列操作。</li>\n</ol>\n<h2 id=\"二、blockingqueue的用法\"> 二、BlockingQueue的用法</h2>\n<p>阻塞队列主要用在生产者/消费者的场景，下面这幅图展示了一个线程生产、一个线程消费的场景：</p>\n<p><img src=\"http://img.blog.csdn.net/20150929153140497\" alt=\"\" loading=\"lazy\"></p>\n<p>负责生产的线程不断的制造新对象并插入到阻塞队列中，直到达到这个队列的上限值。队列达到上限值之后生产线程将会被阻塞，直到消费的线程对这个队列进行消费。同理，负责消费的线程不断的从队列中消费对象，直到这个队列为空，当队列为空时，消费线程将会被阻塞，除非队列中有新的对象被插入。</p>\n<h2 id=\"三、blockingqueue接口中的方法\"> 三、BlockingQueue接口中的方法</h2>\n<p>阻塞队列一共有四套方法分别用来进行insert、remove和examine，当每套方法对应的操作不能马上执行时会有不同的反应，下面这个表格就分类列出了这些方法：</p>\n<table>\n<thead>\n<tr>\n<th>-</th>\n<th>Throws Exception</th>\n<th>Special Value</th>\n<th>Blocks</th>\n<th>Times Out</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Insert</td>\n<td>add(o)</td>\n<td>offer(o)</td>\n<td>put(o)</td>\n<td>offer(o, timeout, timeunit)</td>\n</tr>\n<tr>\n<td>Remove</td>\n<td>remove(o)</td>\n<td>poll()</td>\n<td>take()</td>\n<td>poll(timeout, timeunit)</td>\n</tr>\n<tr>\n<td>Examine</td>\n<td>element()</td>\n<td>peek()</td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li>ThrowsException：如果操作不能马上进行，则抛出异常</li>\n<li>SpecialValue：如果操作不能马上进行，将会返回一个特殊的值，一般是true或者false</li>\n<li>Blocks:如果操作不能马上进行，操作会被阻塞</li>\n<li>TimesOut:如果操作不能马上进行，操作会被阻塞指定的时间，如果指定时间没执行，则返回一个特殊值，一般是true或者false\n需要注意的是，我们不能向BlockingQueue中插入null，否则会报NullPointerException。</li>\n</ol>\n<h2 id=\"四、blockingqueue的实现类\"> 四、BlockingQueue的实现类</h2>\n<p>BlockingQueue只是java.util.concurrent包中的一个接口，而在具体使用时，我们用到的是它的实现类，当然这些实现类也位于java.util.concurrent包中。在Java6中，BlockingQueue的实现类主要有以下几种：</p>\n<ol>\n<li>ArrayBlockingQueue</li>\n<li>DelayQueue</li>\n<li>LinkedBlockingQueue</li>\n<li>PriorityBlockingQueue</li>\n<li>SynchronousQueue</li>\n</ol>\n<h3 id=\"_4-1-arrayblockingqueue\"> 4.1 ArrayBlockingQueue</h3>\n<p>ArrayBlockingQueue是一个有边界的阻塞队列，它的内部实现是一个数组。有边界的意思是它的容量是有限的，我们必须在其初始化的时候指定它的容量大小，容量大小一旦指定就不可改变。</p>\n<p>ArrayBlockingQueue是以先进先出的方式存储数据，最新插入的对象是尾部，最新移出的对象是头部。下面是一个初始化和使用ArrayBlockingQueue的例子：</p>\n<p>BlockingQueue queue = new ArrayBlockingQueue(1024);\nqueue.put(&quot;1&quot;);\nObject object = queue.take();</p>\n<h3 id=\"_4-2-delayqueue\"> 4.2 DelayQueue</h3>\n<p>DelayQueue阻塞的是其内部元素，DelayQueue中的元素必须实现 java.util.concurrent.Delayed接口，这个接口的定义非常简单：</p>\n<div><pre><code>public interface Delayed extends Comparable&lt;Delayed&gt; {\nlong getDelay(TimeUnit unit);\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>getDelay()方法的返回值就是队列元素被释放前的保持时间，如果返回0或者一个负值，就意味着该元素已经到期需要被释放，此时DelayedQueue会通过其take()方法释放此对象。</p>\n<p>从上面Delayed 接口定义可以看到，它还继承了Comparable接口，这是因为DelayedQueue中的元素需要进行排序，一般情况，我们都是按元素过期时间的优先级进行排序。</p>\n<p>例1：为一个对象指定过期时间</p>\n<p>首先，我们先定义一个元素，这个元素要实现Delayed接口</p>\n<div><pre><code>public class DelayedElement implements Delayed {\n  private long expired;\n  private long delay;\n  private String name;\n\n  DelayedElement(String elementName, long delay) {\n         this. name = elementName;\n         this. delay= delay;\n         expired = ( delay + System. currentTimeMillis());\n  }\n\n  @Override\n  public int compareTo(Delayed o) {\n        DelayedElement cached=(DelayedElement) o;\n         return cached.getExpired()&gt; expired?1:-1;\n  }\n\n  @Override\n  public long getDelay(TimeUnit unit) {\n\n         return ( expired - System. currentTimeMillis());\n  }\n\n  @Override\n  public String toString() {\n         return &quot;DelayedElement [delay=&quot; + delay + &quot;, name=&quot; + name + &quot;]&quot;;\n  }\n\n  public long getExpired() {\n         return expired;\n  }\n\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><p>设置这个元素的过期时间为3s</p>\n<div><pre><code>public class DelayQueueExample {\n  public static void main(String[] args) throws InterruptedException {\n        DelayQueue&lt;DelayedElement&gt; queue= new DelayQueue&lt;&gt;();\n        DelayedElement ele= new DelayedElement( &quot;cache 3 seconds&quot;,3000);\n         queue.put( ele);\n        System. out.println( queue.take());\n\n  }\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>运行这个main函数，我们可以发现，我们需要等待3s之后才会打印这个对象。</p>\n<p>其实DelayQueue应用场景很多，比如定时关闭连接、缓存对象，超时处理等各种场景，下面我们就拿学生考试为例让大家更深入的理解DelayQueue的使用。</p>\n<p>例2：把所有考试的学生看做是一个DelayQueue，谁先做完题目释放谁</p>\n<p>首先，我们构造一个学生对象</p>\n<div><pre><code>public class Student implements Runnable,Delayed{\n  private String name;  //姓名\n  private long costTime;//做试题的时间\n  private long finishedTime;//完成时间\n\n  public Student(String name, long costTime) {\n         this. name = name;\n         this. costTime= costTime;\n         finishedTime = costTime + System. currentTimeMillis();\n  }\n\n  @Override\n  public void run() {\n        System. out.println( name + &quot; 交卷,用时&quot; + costTime /1000);\n  }\n\n  @Override\n  public long getDelay(TimeUnit unit) {\n         return ( finishedTime - System. currentTimeMillis());\n  }\n\n  @Override\n  public int compareTo(Delayed o) {\n        Student other = (Student) o;\n         return costTime &gt;= other. costTime?1:-1;\n  }\n\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p>然后在构造一个教师对象对学生进行考试</p>\n<div><pre><code>public class Teacher {\n  static final int STUDENT_SIZE = 30;\n  public static void main(String[] args) throws InterruptedException {\n        Random r = new Random();\n        //把所有学生看做一个延迟队列\n        DelayQueue&lt;Student&gt; students = new DelayQueue&lt;Student&gt;();\n        //构造一个线程池用来让学生们“做作业”\n        ExecutorService exec = Executors.newFixedThreadPool(STUDENT_SIZE);\n         for ( int i = 0; i &lt; STUDENT_SIZE; i++) {\n               //初始化学生的姓名和做题时间\n               students.put( new Student( &quot;学生&quot; + (i + 1), 3000 + r.nextInt(10000)));\n        }\n        //开始做题\n        while(! students.isEmpty()){\n               exec.execute( students.take());\n        }\n         exec.shutdown();\n  }\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>我们看一下运行结果：</p>\n<div><pre><code>学生2 交卷,用时3\n学生1 交卷,用时5\n学生5 交卷,用时7\n学生4 交卷,用时8\n学生3 交卷,用时11\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>通过运行结果我们可以发现，每个学生在指定开始时间到达之后就会“交卷”（取决于getDelay()方法），并且是先做完的先交卷（取决于compareTo()方法）。</p>\n<h3 id=\"_4-3-linkedblockingqueue\"> 4.3 LinkedBlockingQueue</h3>\n<p>LinkedBlockingQueue阻塞队列大小的配置是可选的，如果我们初始化时指定一个大小，它就是有边界的，如果不指定，它就是无边界的。说是无边界，其实是采用了默认大小为Integer.MAX_VALUE的容量 。它的内部实现是一个链表。</p>\n<p>和ArrayBlockingQueue一样，LinkedBlockingQueue 也是以先进先出的方式存储数据，最新插入的对象是尾部，最新移出的对象是头部。下面是一个初始化和使LinkedBlockingQueue的例子：</p>\n<div><pre><code>BlockingQueue&lt;String&gt; unbounded = new LinkedBlockingQueue&lt;String&gt;();\nBlockingQueue&lt;String&gt; bounded   = new LinkedBlockingQueue&lt;String&gt;(1024);\nbounded.put(&quot;Value&quot;);\nString value = bounded.take();\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"_4-4-priorityblockingqueue\"> 4.4 PriorityBlockingQueue</h3>\n<p>PriorityBlockingQueue是一个没有边界的队列，它的排序规则和 java.util.PriorityQueue一样。需要注意，PriorityBlockingQueue中允许插入null对象。</p>\n<p>所有插入PriorityBlockingQueue的对象必须实现 java.lang.Comparable接口，队列优先级的排序规则就是按照我们对这个接口的实现来定义的。</p>\n<p>另外，我们可以从PriorityBlockingQueue获得一个迭代器Iterator，但这个迭代器并不保证按照优先级顺序进行迭代。</p>\n<p>下面我们举个例子来说明一下，首先我们定义一个对象类型，这个对象需要实现Comparable接口：</p>\n<div><pre><code>public class PriorityElement implements Comparable&lt;PriorityElement&gt; {\nprivate int priority;//定义优先级\nPriorityElement(int priority) {\n    //初始化优先级\n    this.priority = priority;\n}\n@Override\npublic int compareTo(PriorityElement o) {\n    //按照优先级大小进行排序\n    return priority &gt;= o.getPriority() ? 1 : -1;\n}\npublic int getPriority() {\n    return priority;\n}\npublic void setPriority(int priority) {\n    this.priority = priority;\n}\n@Override\npublic String toString() {\n    return &quot;PriorityElement [priority=&quot; + priority + &quot;]&quot;;\n}\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>然后我们把这些元素随机设置优先级放入队列中</p>\n<div><pre><code>public class PriorityBlockingQueueExample {\npublic static void main(String[] args) throws InterruptedException {\n    PriorityBlockingQueue&lt;PriorityElement&gt; queue = new PriorityBlockingQueue&lt;&gt;();\n    for (int i = 0; i &lt; 5; i++) {\n        Random random=new Random();\n        PriorityElement ele = new PriorityElement(random.nextInt(10));\n        queue.put(ele);\n    }\n    while(!queue.isEmpty()){\n        System.out.println(queue.take());\n    }\n}\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>看一下运行结果：</p>\n<div><pre><code>PriorityElement [priority=3]\nPriorityElement [priority=4]\nPriorityElement [priority=5]\nPriorityElement [priority=8]\nPriorityElement [priority=9]\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id=\"_4-5-synchronousqueue\"> 4.5 SynchronousQueue</h3>\n<p>SynchronousQueue队列内部仅允许容纳一个元素。当一个线程插入一个元素后会被阻塞，除非这个元素被另一个线程消费。</p>\n",
      "image": "http://img.blog.csdn.net/20150929153140497",
      "date_published": "2022-05-22T07:02:41.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Java进阶"
      ]
    },
    {
      "title": "指南",
      "url": "https://java.springlearn.cn/learn/guide/test/",
      "id": "https://java.springlearn.cn/learn/guide/test/",
      "content_html": "<p>不是使用自动生成侧边栏，而是使用。自定以侧边栏。</p>\n<p>https://vuepress-theme-hope.github.io/zh/guide/layout/sidebar/#%E4%BE%A7%E8%BE%B9%E6%A0%8F%E5%88%86%E7%BB%84</p>\n<h2 id=\"一、本站知识阅览\"> 一、本站知识阅览</h2>\n<h3 id=\"_1-多撒多\"> 1. 多撒多</h3>\n<h3 id=\"_2-fdsa\"> 2. fdsa</h3>\n<h2 id=\"二、学习路线参\"> 二、学习路线参</h2>\n<p>考\n范德萨</p>\n<h2 id=\"三、java\"> 三、Java</h2>\n<p>德萨</p>\n",
      "date_published": "2021-12-21T05:46:37.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "没有条件创造条件Condition",
      "url": "https://java.springlearn.cn/learn/java/Condition/",
      "id": "https://java.springlearn.cn/learn/java/Condition/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n<p>https://blog.csdn.net/a1439775520/article/details/98471610</p>\n<p>Condition 是为了调换 Object 中的 wait()\n和notify().</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">API</th>\n<th style=\"text-align:center\">Object</th>\n<th style=\"text-align:center\">Condition</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">等待</td>\n<td style=\"text-align:center\">wait()</td>\n<td style=\"text-align:center\">wait()</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">通知</td>\n<td style=\"text-align:center\">notify()</td>\n<td style=\"text-align:center\">signal()</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">通知所有</td>\n<td style=\"text-align:center\">notifyAll()</td>\n<td style=\"text-align:center\">signalAll()</td>\n</tr>\n</tbody>\n</table>\n<p><strong>wait是会释放锁</strong></p>\n<h2 id=\"相同点\"> 相同点</h2>\n<ul>\n<li>都必须被包裹在同步代码块中，即加锁</li>\n<li>当调用wait都会释放锁</li>\n</ul>\n<h2 id=\"不同点\"> 不同点</h2>\n<ul>\n<li>Object 依赖 synchronized 锁</li>\n<li>Condition 依赖 Lock 锁</li>\n</ul>\n<h2 id=\"objectwait\"> ObjectWait</h2>\n<div><p>运行结果</p>\n<ul>\n<li>当前线程进入线程一</li>\n<li>当前线程进入线程二</li>\n<li>当前线程释放main</li>\n<li>当前线程释放main</li>\n<li>当前线程退出线程一</li>\n<li>当前线程退出线程二</li>\n</ul>\n</div>\n<div><pre><code><span>/**\n * @author liuxin\n * 2022/1/5 12:24 上午\n */</span>\n<span>public</span> <span>class</span> <span>ObjectWait</span> <span>{</span>\n\n    <span>public</span> <span>synchronized</span> <span>void</span> <span>objWait</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"当前线程进入\"</span> <span>+</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>wait</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"当前线程退出\"</span> <span>+</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>synchronized</span> <span>void</span> <span>objNotify</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"当前线程释放\"</span> <span>+</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>notify</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>ObjectWait</span> objectWait <span>=</span> <span>new</span> <span>ObjectWait</span><span>(</span><span>)</span><span>;</span>\n        <span>// 使用synchronized修饰方法，就是锁的是当前这个示例synchronized(this)</span>\n        <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>\n            <span>try</span> <span>{</span>\n                <span>// 当前进入等待，然后释放锁。wait会释放锁</span>\n                objectWait<span>.</span><span>objWait</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n                e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>,</span><span>\"线程一\"</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n\n        <span>// 使用synchronized修饰方法，就是锁的是当前这个示例synchronized(this)</span>\n        <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>\n            <span>try</span> <span>{</span>\n                <span>// 当前进入等待，然后释放锁。wait会释放锁</span>\n                objectWait<span>.</span><span>objWait</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n                e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>,</span><span>\"线程二\"</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>1000L</span><span>)</span><span>;</span>\n        <span>// 释放锁后才会放行</span>\n        objectWait<span>.</span><span>objNotify</span><span>(</span><span>)</span><span>;</span>\n        <span>// 释放锁后才会放行</span>\n        objectWait<span>.</span><span>objNotify</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><h2 id=\"lockwait\"> LockWait</h2>\n<div><p>运行结果</p>\n<ul>\n<li>当前线程进入线程一</li>\n<li>当前线程进入线程二</li>\n<li>当前线程释放main</li>\n<li>当前线程释放main</li>\n<li>当前线程退出线程一</li>\n<li>当前线程退出线程二</li>\n</ul>\n</div>\n<div><pre><code><span>/**\n * @author liuxin\n * 2022/1/5 24:24 上午\n */</span>\n<span>public</span> <span>class</span> <span>LockWait</span> <span>{</span>\n\n    <span>private</span> <span>ReentrantLock</span> lock <span>=</span> <span>new</span> <span>ReentrantLock</span><span>(</span><span>)</span><span>;</span>\n\n    <span>private</span> <span>Condition</span> condition <span>=</span> lock<span>.</span><span>newCondition</span><span>(</span><span>)</span><span>;</span>\n\n    <span>public</span> <span>void</span> <span>lockWait</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        lock<span>.</span><span>lock</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"当前线程进入\"</span> <span>+</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        condition<span>.</span><span>await</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"当前线程退出\"</span> <span>+</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        lock<span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>lockNotify</span><span>(</span><span>)</span> <span>{</span>\n        lock<span>.</span><span>lock</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"当前线程释放\"</span> <span>+</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        condition<span>.</span><span>signal</span><span>(</span><span>)</span><span>;</span>\n        lock<span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>LockWait</span> lockWait <span>=</span> <span>new</span> <span>LockWait</span><span>(</span><span>)</span><span>;</span>\n        <span>// lock.lock()  线程一: 获取锁,然后wait之后，进入释放锁,然后进入到等待队列</span>\n        <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>\n            <span>try</span> <span>{</span>\n                <span>// 当前进入等待，然后释放锁。</span>\n                lockWait<span>.</span><span>lockWait</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n                e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>,</span> <span>\"线程一\"</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        <span>// lock.lock()  当前线程二获取锁,然后wait之后，进入释放锁,然后进入到等待队列</span>\n        <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>\n            <span>try</span> <span>{</span>\n                <span>// 当前进入等待，然后释放锁。</span>\n                lockWait<span>.</span><span>lockWait</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n                e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>,</span><span>\"线程二\"</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n\n        <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>1000L</span><span>)</span><span>;</span>\n        <span>// 调用第一次，会唤醒线程一，继续向下执行</span>\n        lockWait<span>.</span><span>lockNotify</span><span>(</span><span>)</span><span>;</span>\n        <span>// 调用第二次，会唤醒线程二，继续向下执行</span>\n        lockWait<span>.</span><span>lockNotify</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br></div></div>",
      "image": "https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png",
      "date_published": "2022-01-04T14:58:20.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Java进阶"
      ]
    },
    {
      "title": "循环锁屏障 CyclicBarrier",
      "url": "https://java.springlearn.cn/learn/java/CyclicBarrier/",
      "id": "https://java.springlearn.cn/learn/java/CyclicBarrier/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n<p>举个例子,五个人开黑,少一个人就开不了。</p>\n<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>Throwable</span> <span>{</span>\n        <span>CyclicBarrier</span> cb <span>=</span> <span>new</span> <span>CyclicBarrier</span><span>(</span><span>5</span><span>,</span> <span>new</span> <span>Runnable</span><span>(</span><span>)</span> <span>{</span>\n            <span>@Override</span>\n            <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"人都到齐了,游戏开始进入峡谷\"</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n        <span>Runnable</span> player <span>=</span> <span>new</span> <span>Runnable</span><span>(</span><span>)</span> <span>{</span>\n            <span>@Override</span>\n            <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\"已经进来了\"</span><span>)</span><span>;</span>\n                <span>try</span> <span>{</span>\n                    cb<span>.</span><span>await</span><span>(</span><span>)</span><span>;</span>\n                <span>}</span> <span>catch</span> <span>(</span><span>Throwable</span> e<span>)</span> <span>{</span>\n                    e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span><span>;</span>\n        <span>new</span> <span>Thread</span><span>(</span>player<span>,</span> <span>\"上路程咬金\"</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        <span>new</span> <span>Thread</span><span>(</span>player<span>,</span> <span>\"中路安琪拉\"</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        <span>new</span> <span>Thread</span><span>(</span>player<span>,</span> <span>\"下路小鲁班\"</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        <span>new</span> <span>Thread</span><span>(</span>player<span>,</span> <span>\"辅助李元芳\"</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        <span>new</span> <span>Thread</span><span>(</span>player<span>,</span> <span>\"打野孙悟空\"</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div>",
      "image": "https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png",
      "date_published": "2021-12-25T09:26:08.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Java进阶"
      ]
    },
    {
      "title": "性能优化之@Contended减少伪共享",
      "url": "https://java.springlearn.cn/learn/java/Contended/",
      "id": "https://java.springlearn.cn/learn/java/Contended/",
      "content_html": "<h2 id=\"一、什么叫伪共享\"> 一、什么叫伪共享</h2>\n<p>说到伪共享,就要说CPU缓存,我们程序执行时候信息会被保存到CPU缓存中\n而这些缓存中的数据可能被多线程访问,假如一个线程还没处理完，另外一个线程\n就对数据进行了修改,就会导致上一个线程发生幻读的情况,比如刚才看到a=1,然后准备a = a+1。\n但是还没做,另外一个线程就先将a变成2了。导致了上一个线程计算后本来应该是a = 1 + 1,变成了a = 2 + 1\n计算结果就不对了。</p>\n<p>那么对于这种情况当然是不允许发生的，解决方案就是当发现另外一个线程更新了共享变量，就会把cpu缓存中的数据给失效。\n然后都重新读取最新的变量值。</p>\n<p><mark>这里有一个前提是共享变量，因为两个线程都会用到a,所以a是共享变量。</mark></p>\n<p>那么我们在聊伪共享就简单了，下面举一个伪共享变量的例子。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>ContendedTest</span> <span>{</span>\n\n    <span>volatile</span> <span>long</span> a<span>;</span>\n    \n    <span>volatile</span> <span>long</span> b<span>;</span>\n    \n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>test</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>ContendedTest</span> c <span>=</span> <span>new</span> <span>ContendedTest</span><span>(</span><span>)</span><span>;</span>\n        <span>Thread</span> thread1 <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>\n            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>10000_0000L</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n                c<span>.</span>a <span>=</span> i<span>;</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n        <span>Thread</span> thread2 <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>\n            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>10000_0000L</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n                c<span>.</span>b <span>=</span> i<span>;</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n        <span>final</span> <span>long</span> start <span>=</span> <span>System</span><span>.</span><span>nanoTime</span><span>(</span><span>)</span><span>;</span>\n        thread1<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        thread2<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        thread1<span>.</span><span>join</span><span>(</span><span>)</span><span>;</span>\n        thread2<span>.</span><span>join</span><span>(</span><span>)</span><span>;</span>\n        <span>// 1933</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>(</span><span>System</span><span>.</span><span>nanoTime</span><span>(</span><span>)</span> <span>-</span> start<span>)</span> <span>/</span> <span>100_0000</span><span>)</span><span>;</span>\n    <span>}</span>\n     \n<span>}</span>    \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><p>两个线程分别来更新a和b属性,根据缓存失效的原理,因为a和b都在同一个对象中,当一个属性被更新,就会触发cpu缓存失效。\n那么等于这种情况cpu缓存就没什么用了。我们思考下两个线程分别更新a和b，而a和b没有任何关系。那么a和b是共享变量吗?\n当然不是,这就叫伪共享。</p>\n<h2 id=\"二、主动告诉程序伪共享\"> 二、主动告诉程序伪共享</h2>\n<p>我们可以使用 <code>@Contended</code> 来声明伪共享变量,从而是cpu不更新缓存。\n本地测试时候记得加上jvm参数 <mark>-XX:-RestrictContended</mark>，否则无效哦。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>ContendedTest</span> <span>{</span>\n\n    <span>@Contended</span>\n    <span>volatile</span> <span>int</span> a<span>;</span>\n\n    <span>@Contended</span>\n    <span>volatile</span> <span>int</span> b<span>;</span>\n\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>test</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>ContendedTest</span> c <span>=</span> <span>new</span> <span>ContendedTest</span><span>(</span><span>)</span><span>;</span>\n        <span>Thread</span> thread1 <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>\n            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>10000_0000L</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n                c<span>.</span>a <span>=</span> i<span>;</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n        <span>Thread</span> thread2 <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>\n            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>10000_0000L</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n                c<span>.</span>b <span>=</span> i<span>;</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n        <span>final</span> <span>long</span> start <span>=</span> <span>System</span><span>.</span><span>nanoTime</span><span>(</span><span>)</span><span>;</span>\n        thread1<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        thread2<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        thread1<span>.</span><span>join</span><span>(</span><span>)</span><span>;</span>\n        thread2<span>.</span><span>join</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>(</span><span>System</span><span>.</span><span>nanoTime</span><span>(</span><span>)</span> <span>-</span> start<span>)</span> <span>/</span> <span>100_0000</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><p>那么你猜下性能能提高多少呢? 前者<code>1933</code>后者<code>758ms</code>,差不多2.5倍的样子。</p>\n<p>那么留下一个问题? 有多少场景都在使用<code>@Contended</code>呢? 知道的请留言评论。</p>\n",
      "date_published": "2022-05-22T07:02:41.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Java进阶"
      ]
    },
    {
      "title": "倒计锁 CountDownLatch",
      "url": "https://java.springlearn.cn/learn/java/CountDownLatch/",
      "id": "https://java.springlearn.cn/learn/java/CountDownLatch/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n<p>上文我们知道了 <code>Semaphore</code> 信号量的用法，那么这一篇基本不用学了。因为原理基本上是一样的。\n但是用法不太一样。</p>\n<p><code>Semaphore</code> 是获取到资源就执行，获取不到资源就等待。\n<code>CountDownLatch</code> 跟 <code>Semaphore</code> 正好相反。</p>\n<p>CountDownLatch#await() 可以理解为获取不到资源，就等待。这么说不太好理解，直接看源码吧。</p>\n<div><pre><code><span>private</span> <span>static</span> <span>final</span> <span>class</span> <span>Sync</span> <span>extends</span> <span>AbstractQueuedSynchronizer</span> <span>{</span>\n        <span>private</span> <span>static</span> <span>final</span> <span>long</span> serialVersionUID <span>=</span> <span>4982264981922014374L</span><span>;</span>\n\n        <span>Sync</span><span>(</span><span>int</span> count<span>)</span> <span>{</span>\n            <span>setState</span><span>(</span>count<span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>int</span> <span>getCount</span><span>(</span><span>)</span> <span>{</span>\n            <span>return</span> <span>getState</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>protected</span> <span>int</span> <span>tryAcquireShared</span><span>(</span><span>int</span> acquires<span>)</span> <span>{</span>\n            <span>// 获取资源,await就是调用这个方法。当tryReleaseShared没有进行扣减之前。</span>\n            <span>// 这里一直都是-1。而-1就是获取不到资源进行等待</span>\n            <span>return</span> <span>(</span><span>getState</span><span>(</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span>?</span> <span>1</span> <span>:</span> <span>-</span><span>1</span><span>;</span>\n        <span>}</span>\n\n        <span>protected</span> <span>boolean</span> <span>tryReleaseShared</span><span>(</span><span>int</span> releases<span>)</span> <span>{</span>\n            <span>// countDown就调用这个方法,进行扣减1</span>\n            <span>for</span> <span>(</span><span>;</span><span>;</span><span>)</span> <span>{</span>\n                <span>int</span> c <span>=</span> <span>getState</span><span>(</span><span>)</span><span>;</span>\n                <span>if</span> <span>(</span>c <span>==</span> <span>0</span><span>)</span>\n                    <span>return</span> <span>false</span><span>;</span>\n                <span>int</span> nextc <span>=</span> c<span>-</span><span>1</span><span>;</span>\n                <span>if</span> <span>(</span><span>compareAndSetState</span><span>(</span>c<span>,</span> nextc<span>)</span><span>)</span>\n                    <span>return</span> nextc <span>==</span> <span>0</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><h2 id=\"常用用法\"> 常用用法</h2>\n<p><strong>注意:</strong>\n<mark>CountDownLatch不可重复使用，当计数器减少到0之后，就废了，无法继续使用了。</mark></p>\n<p>CountDownLatch是在java1.5被引入的，跟它一起被引入的并发工具类还有CyclicBarrier、Semaphore、ConcurrentHashMap和BlockingQueue，它们都存在于java.util.concurrent包下。CountDownLatch这个类能够使一个线程等待其他线程完成各自的工作后再执行。例如，应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行。</p>\n<p>CountDownLatch是通过一个计数器来实现的，计数器的初始值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就会减1。当计数器值到达0时，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务。</p>\n<p><img src=\"http://incdn1.b0.upaiyun.com/2015/04/f65cc83b7b4664916fad5d1398a36005.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"countdownlatch-存在的意义\"> CountDownLatch 存在的意义</h2>\n<p>让主线程阻塞，等待线程结束后在运行</p>\n<p>直译过来就是倒计数(CountDown)门闩(Latch)。倒计数不用说，门闩的意思顾名思义就是阻止前进。在这里就是指 CountDownLatch.await() 方法在倒计数为0之前会阻塞当前线程。</p>\n<p><strong>实现</strong></p>\n<p>CountDownLatch内部维护一个最大线程数，当每个线程执行结束，就调用\n<code>latch.countDown();</code> 将数量减 1 ,当数量为0的时候，就放弃阻塞主线程，也就是放弃 <code>countDownLatch.await()</code>阻塞的线程</p>\n<h2 id=\"代码解释\"> 代码解释</h2>\n<div><pre><code> <span>public</span> <span>void</span> <span>test</span><span>(</span><span>)</span><span>throws</span> <span>Exception</span><span>{</span>\n        <span>int</span> pagecount<span>=</span><span>3</span><span>;</span>\n        <span>ExecutorService</span> executors <span>=</span> <span>Executors</span><span>.</span><span>newFixedThreadPool</span><span>(</span>pagecount<span>)</span><span>;</span>\n        <span>CountDownLatch</span> countDownLatch <span>=</span> <span>new</span> <span>CountDownLatch</span><span>(</span>pagecount<span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> pagecount<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            <span>// 启动线程抓取</span>\n            executors\n                    <span>.</span><span>execute</span><span>(</span><span>new</span> <span>Runnable</span><span>(</span><span>)</span> <span>{</span>\n                        <span>@Override</span>\n                        <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n                            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n                            countDownLatch<span>.</span><span>countDown</span><span>(</span><span>)</span><span>;</span>\n                        <span>}</span>\n                    <span>}</span><span>)</span><span>;</span>\n        <span>}</span>\n        countDownLatch<span>.</span><span>await</span><span>(</span><span>)</span><span>;</span><span>//主线程阻塞在这里，等到线程结束,</span>\n        <span>//然后关闭线程池</span>\n        executors<span>.</span><span>shutdown</span><span>(</span><span>)</span><span>;</span>\n\n    <span>}</span>\n\n\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h2 id=\"最大缺点\"> 最大缺点</h2>\n<p>通过前面源码我们发现, <code>CountDownLatch</code> 只有减没有加，所以导致了一个最大的缺点就是\n只能使用一次,当扣减为0的时候,那么就不能在继续使用了。所以就要引入 <code>CyclicBarrier</code>了。</p>\n",
      "image": "https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png",
      "date_published": "2021-12-25T09:26:08.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Java进阶"
      ]
    },
    {
      "title": "面试再也不怕被HashMap欺负了",
      "url": "https://java.springlearn.cn/learn/java/HashMap/",
      "id": "https://java.springlearn.cn/learn/java/HashMap/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/learn_1596467333000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n<blockquote>\n<p>HashMap是我们在日常开发中经常使用的一个结合类型,同时也是面试时候最好提问的集合类型,在这里进行整理\n一起学习,进步。</p>\n</blockquote>\n<h2 id=\"一、数据结构\"> 一、数据结构</h2>\n<p>先说两种数据结构, 不用怕, 如果要对付面试只要了解就行了。不用手写实现, 同时也因为已经有人帮我写好,所以开发中我们只要用就行。</p>\n<h3 id=\"_1-二叉树\"> 1. 二叉树</h3>\n<p><a href=\"https://www.cs.usfca.edu/~galles/visualization/BST.html\" target=\"_blank\" rel=\"noopener noreferrer\">动画展示二叉树</a></p>\n<p>本来是一个相对平衡的二叉树(当前数据 &gt; 根节点 ？ 从右边插入 : 从左边插入)。\n<img src=\"https://img.springlearn.cn/blog/learn_1596522740000.png\" alt=\"\" loading=\"lazy\">\n但是由于在使用的过程中的删除,慢慢的变成了一个瘸腿。此时树的高度越高,数据越多,导致查询叶子\n的耗时越长。\n<img src=\"https://img.springlearn.cn/blog/learn_1596522608000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>于是乎人们在这个数据结构的基础上,研究出新的结构,就是下面的红黑树。</p>\n<h3 id=\"_2-红黑树\"> 2. 红黑树</h3>\n<p><a href=\"https://www.cs.usfca.edu/~galles/visualization/RedBlack.html\" target=\"_blank\" rel=\"noopener noreferrer\">动画展示红黑树</a></p>\n<p>依次插入7 5 3 2 4 6 8 9 12 11 17 13 14 16</p>\n<p>很明显我们可以看出红黑树比二叉树相对比较平衡。\n<img src=\"https://img.springlearn.cn/blog/learn_1596523217000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>在对比一下二叉树</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596523318000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>好了关于数据结构的知识就说这么多,可以通过图就能知道这两种数据结构情况了。因为数据结构不是我们本篇研究的点。\n所以就提这么多。</p>\n<h2 id=\"二、源码分析\"> 二、源码分析</h2>\n<p>HashMap 实现了 Map 接口,JDK1.7由 数组 + 链表实现， 1.8后由 数组 + 链表 + 红黑树实现</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596527068000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_1-put的源码分析\"> 1. put的源码分析</h3>\n<p>HashMap中声明的常量信息,注意看。下面源码中会提到。</p>\n<table>\n<thead>\n<tr>\n<th>变量</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>DEFAULT_INITIAL_CAPACITY</td>\n<td>默认的初始容量</td>\n</tr>\n<tr>\n<td>MAXIMUM_CAPACITY</td>\n<td>最大的容量2^30</td>\n</tr>\n<tr>\n<td>DEFAULT_LOAD_FACTOR</td>\n<td>容器个数 size &gt; 负载因子 * 数组长度  就需要进行扩容</td>\n</tr>\n<tr>\n<td>TREEIFY_THRESHOLD</td>\n<td>如果数组中某一个链表 &gt;= 8 需要转化为红黑树</td>\n</tr>\n<tr>\n<td>UNTREEIFY_THRESHOLD</td>\n<td>如果数组中某一个链表转化为红黑树后的节点 &lt; 6 的时候 继续转为 链表</td>\n</tr>\n</tbody>\n</table>\n<div><pre><code> final V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;\n        if ((tab = table) == null || (n = tab.length) == 0)\n            n = (tab = resize()).length;\n        if ((p = tab[i = (n - 1) &amp; hash]) == null)\n            tab[i] = newNode(hash, key, value, null);\n        else {\n            Node&lt;K,V&gt; e; K k;\n            if (p.hash == hash &amp;&amp;\n                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))\n                e = p;\n            //判断是否是树    \n            else if (p instanceof TreeNode)\n                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);\n            //继续用链表    \n            else {\n                // 循环链表\n                for (int binCount = 0; ; ++binCount) {\n                    if ((e = p.next) == null) {\n                        // 新建节点存储\n                        p.next = newNode(hash, key, value, null);\n                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                            //大于树的阀值,就转换为树结构\n                            treeifyBin(tab, hash);\n                        break;\n                    }\n                    if (e.hash == hash &amp;&amp;\n                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))\n                        break;\n                    p = e;\n                }\n            }\n            if (e != null) { // existing mapping for key\n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value;\n                afterNodeAccess(e);\n                return oldValue;\n            }\n        }\n        ++modCount;\n        if (++size &gt; threshold)\n            resize();\n        afterNodeInsertion(evict);\n        return null;\n    }\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br></div></div><p>从上面源码中我们可以看到在put时候会判断是链表结构还是红黑树。如果是树就用树put\n<code>((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</code>。</p>\n<p>如果是链表就循环列表插入数据,如果发现列表长度大于树的阀值就讲链表转换为树</p>\n<h3 id=\"_2-put流程赘述\"> 2. put流程赘述</h3>\n<ol>\n<li>判断 table 是否为 null。为 null 则新建一个 table 数组</li>\n<li>调用 hash 获取 该 key 的 hash 值\n<img src=\"https://img.springlearn.cn/blog/learn_1596528441000.png\" alt=\"\" loading=\"lazy\"></li>\n<li>将hash &amp; n-1的值当做下标去找数据</li>\n<li>如果发现有数据\n<ol>\n<li>但是数据的hash和key都和当前要插入的一致就替换。(此时还是一个Node节点)</li>\n<li>但是数据的hash一致,但是key不一致,说明是hash冲突了。就转换成一个Node链表,数据放到链表尾部</li>\n</ol>\n</li>\n<li>如果发现链表长度大于等于8,就转换成红黑树\n<img src=\"https://img.springlearn.cn/blog/learn_1596528854000.png\" alt=\"\" loading=\"lazy\"></li>\n</ol>\n<h2 id=\"三、面试知识扩展\"> 三、面试知识扩展</h2>\n<p>前面我们知道了HashMap在1.8之后的优化。这里我们最后再说一个面试题。\n问: 1.7时候hashmap在扩容时候回出现死链的问题。问题原因是什么?  已经出现的场景是什么?</p>\n<p>首先看下扩容方法 <code>resize</code>\n<img src=\"https://img.springlearn.cn/blog/learn_1596530770000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_1-优化1\"> 1. 优化1</h3>\n<p>jdk1.8在对链表进行扩容时候时候不是直接都去hash了。而是\n<code>(e.hash &amp; oldCap) == 0</code> 下标不变\n<code>(e.hash &amp; oldCap) != 0</code> 下标 = 原下标 + oldCap</p>\n<h3 id=\"_2-出现的场景\"> 2. 出现的场景</h3>\n<p>多线程操作扩容</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596531864000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>最后求关注,求订阅,谢谢你的阅读!</p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1596467333000.png",
      "date_published": "2022-01-04T14:58:20.000Z",
      "date_modified": "2022-08-22T01:35:49.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Java进阶"
      ]
    },
    {
      "title": "Java编程",
      "url": "https://java.springlearn.cn/learn/java/",
      "id": "https://java.springlearn.cn/learn/java/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/learn_1648126927000.png\" alt=\"\" loading=\"lazy\"></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n",
      "image": "https://img.springlearn.cn/blog/learn_1648126927000.png",
      "date_published": "2021-12-25T09:26:08.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "读写锁 ReadWriteLock",
      "url": "https://java.springlearn.cn/learn/java/ReadWriteLock/",
      "id": "https://java.springlearn.cn/learn/java/ReadWriteLock/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n",
      "image": "https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png",
      "date_published": "2021-12-25T09:26:08.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Java进阶"
      ]
    },
    {
      "title": "重入锁 ReentrantLock",
      "url": "https://java.springlearn.cn/learn/java/ReentrantLock/",
      "id": "https://java.springlearn.cn/learn/java/ReentrantLock/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n",
      "image": "https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png",
      "date_published": "2021-12-25T09:26:08.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Java进阶"
      ]
    },
    {
      "title": "信号量 Semaphore",
      "url": "https://java.springlearn.cn/learn/java/Semaphore/",
      "id": "https://java.springlearn.cn/learn/java/Semaphore/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n<h2 id=\"🚀-知识快读\"> 🚀 知识快读</h2>\n<p><code>Semaphore</code> 翻译过来就是信号量, 其根本原理就是基于 <code>CAS</code> 共享锁的一种实现。举一个例子。\n假设停车场只有三个车位，一开始三个车位都是空的。这时如果同时来了五辆车，看门人允许其中三辆不受阻碍的进入，然后放下车拦，剩下的车则必须在入口等待，此后来的车也都不得不在入口处等待。这时，有一辆车离开停车场，看门人得知后，打开车拦，放入一辆，如果又离开两辆，则又可以放入两辆，如此往复。</p>\n<p>那么上面的这个例子可以这样理解，资源一共有3个, 即三个车位。如何来控制这5辆汽车，来合理的使用这3个资源呢?\n<code>Semaphore</code> 可以这样来定义。</p>\n<div><pre><code><span>// 1. 定一个信号量,声明有3个资源。使用公平模式线程将会按到达的顺序（FIFO）执行(也就是等待时间最长的先执行),如果是非公平，则可以后请求的有可能排在队列的头部。</span>\n<span>Semaphore</span> semp <span>=</span> <span>new</span> <span>Semaphore</span><span>(</span><span>3</span><span>)</span><span>;</span>\n<span>// 2. 获取1个许可 - 最大允许3个进入，一但超过就让其等待,除非已经释放</span>\nsemp<span>.</span><span>acquire</span><span>(</span><span>)</span><span>;</span>  \n<span>// 3. 释放1个许可 </span>\nsemp<span>.</span><span>release</span><span>(</span><span>)</span><span>;</span> \n<span>// 4. 获取1许可,失败就返回,不等待</span>\nsemp<span>.</span><span>tryAcquire</span><span>(</span><span>)</span><span>;</span>  \n<span>// 5. 获取2许可,失败就返回,不等待</span>\nsemp<span>.</span><span>tryAcquire</span><span>(</span><span>2</span><span>)</span><span>;</span>  \n<span>// 6. 不允许被中断</span>\nsemp<span>.</span><span>acquireUninterruptibly</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id=\"知识点1-fair-nofair\"> 知识点1: Fair &amp; NoFair</h2>\n<p><code>Semaphore</code> 的模式配置,只是构造来定义。</p>\n<ul>\n<li>默认构造不公平模式, 谁来申请资源,就先尝试获取资源。排队的要等到没有资源进来申请才能继续申请</li>\n</ul>\n<div><pre><code>    <span>public</span> <span>Semaphore</span><span>(</span><span>int</span> <span>permits</span><span>)</span> <span>{</span>\n        sync <span>=</span> <span>new</span> <span>NonfairSync</span><span>(</span><span>permits</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>Semaphore</span><span>(</span><span>int</span> <span>permits</span><span>,</span> <span>boolean</span> fair<span>)</span> <span>{</span>\n        sync <span>=</span> fair <span>?</span> <span>new</span> <span>FairSync</span><span>(</span><span>permits</span><span>)</span> <span>:</span> <span>new</span> <span>NonfairSync</span><span>(</span><span>permits</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><img src=\"https://img.springlearn.cn/blog/learn_1640531082000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"知识点2-申请资源\"> 知识点2: 申请资源</h2>\n<ul>\n<li>acquire() 获取1个资源,获取不到就等待,如果线程中断,会直接中断。</li>\n<li>acquire(2) 获取2个资源,获取不到就等待,如果线程中断,会直接中断。</li>\n<li>tryAcquire() 获取1个资源,获取不到就返回 <code>false</code>,如果线程中断,会直接中断。</li>\n<li>acquireUninterruptibly() 获取1个资源,获取不到就等待,不会关心线程中断。</li>\n</ul>\n<h2 id=\"知识点3-释放资源\"> 知识点3: 释放资源</h2>\n<ul>\n<li>release() 释放一个资源</li>\n<li>release(2) 释放两个资源</li>\n</ul>\n<h2 id=\"知识点4-其他api\"> 知识点4: 其他API</h2>\n<ul>\n<li>availablePermits() 当前资源数量</li>\n<li>drainPermits() 获取当前资源数量，并将剩余资源清零，直接赋值0</li>\n<li>reducePermits(2) 将资源数量，扣减2个</li>\n<li>isFair() 是否公平</li>\n<li>hasQueuedThreads() 是否还有线程等待</li>\n<li>getQueueLength() 还有多少线程等待</li>\n<li>getQueuedThreads() 获取所有的线程集合</li>\n</ul>\n",
      "image": "https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png",
      "date_published": "2021-12-25T09:26:08.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Java进阶"
      ]
    },
    {
      "title": "SPI服务发现机制",
      "url": "https://java.springlearn.cn/learn/java/SPI/",
      "id": "https://java.springlearn.cn/learn/java/SPI/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/learn_1590160192000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n<h2 id=\"一、什么是spi\"> 一、什么是SPI</h2>\n<p>SPI ，全称为 Service Provider Interface，是一种服务发现机制。JDK中的SPI是通过在ClassPath路径下的META-INF/services文件夹查找扩展文件,自动加载文件里所定义的类。</p>\n<p>在小编的理解来,觉得它更是一种思想。即找到服务的接口, 美其名曰: 服务发现机制思想。很多开源框架都有借用这种思想，比如dubbo、jdbc。</p>\n<h2 id=\"二、spi在jdk中如何使用\"> 二、SPI在JDK中如何使用</h2>\n<p>SPI在JDK中,我们可以使用 <code>ServiceLoader</code> 类进行使用。\n<img src=\"https://img.springlearn.cn/blog/learn_1590225886000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_1-前提准备\"> 1. 前提准备</h3>\n<div><pre><code>public interface SpiService {\n    String say();\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>两个实现类</p>\n<div><pre><code>public class ASpiServiceImpl implements SpiService {\n    static {\n        System.out.println(&quot;static init a&quot;);\n    }\n\n    {\n        System.out.println(&quot;init a&quot;);\n    }\n\n    @Override\n    public String say() {\n        return &quot;A&quot;;\n    }\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><div><pre><code>public class BSpiServiceImpl implements SpiService {\n    static {\n        System.out.println(&quot;static init b&quot;);\n    }\n\n    {\n        System.out.println(&quot;init b&quot;);\n    }\n    @Override\n    public String say() {\n        return &quot;B&quot;;\n    }\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id=\"_2-进行配置\"> 2. 进行配置</h3>\n<p>在resources中创建META-INF/services目录</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1590225980000.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>│  └── resources\n│      └── META-INF\n│          └── services\n│              └── com.github.easylog.spi.SpiService\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>com.github.easylog.spi.SpiService文件内容</p>\n<div><pre><code>com.github.easylog.spi.impl.ASpiServiceImpl\ncom.github.easylog.spi.impl.BSpiServiceImpl\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"_3-使用\"> 3. 使用</h3>\n<p>通过ServiceLoader类我们可以加载到所有配置的实现类,并对实现类进行处理。需要注意一点的是，看4使用注意。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1590226089000.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>public class SpiTester {\n    public static void main(String[] args) {\n        ServiceLoader&lt;SpiService&gt; spiServices = ServiceLoader.load(SpiService.class);\n        Iterator&lt;SpiService&gt; iterator = spiServices.iterator();\n        while (iterator.hasNext()) {\n            SpiService next = iterator.next();\n            System.out.println(next.say());\n        }\n    }\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id=\"_4-使用注意\"> 4. 使用注意</h3>\n<p>可以看下小编前面声明的两个实现类,都定义了静态代码块和非静态代码块。正常情况当这个字节码被加载,就会执行静态代码块里面的内容，但是实际运行时候却没有执行, 其实是有原因的。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1590223793000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>可以看到第二个参数是false。即加载时候不进行初始化。</p>\n<h2 id=\"三、dubbo中服务发现思想\"> 三、Dubbo中服务发现思想</h2>\n<p>服务发现这种思想的特点是: 代码不是硬编码的方式,而是可配置的。只要将要支持的实现类放到指定配置文件下面,就会自动被加载起来了。然后代码中只关心使用即可。我们可以利用这种思想来实现, 框架的扩展,比如前面说了。Dubbo会利用SPI的思想进行，加载用户自定义的过滤器。</p>\n<p>这种思想特别适合做服务扩展。现在大多数开源框架中都会使用到这种思想。</p>\n<h3 id=\"_1-定义过滤器\"> 1. 定义过滤器</h3>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1590226192000.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>@Activate(group = { Constants.PROVIDER })\npublic class ProviderHelloFilter implements Filter {\n  \n    @Override\n    public Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException {\n        System.out.pringln(&quot;hello ok!&quot;);\n        return invoker.invoke(invocation);\n    }\n\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id=\"_2-添加配置文件\"> 2. 添加配置文件</h3>\n<p><code>META-INF/dubbo/Interal/com.alibaba.dubbo.rpc.Filter</code></p>\n<p>默认支持的过滤器</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1590224576000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>利用SPI原理,我们自定义一个过滤器</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1590224824000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_3-使用-2\"> 3. 使用</h3>\n<p>其实API跟JDK中使用ServiceLoader的方式,非常类同。唯一不同的是Dubbo中是使用ExtensionLoader。因为dubbo中做了一些特殊的增强处理。比如在配置文件中支持自定义一个别名key。如上图hello就是key。通过getExtension(&quot;hello&quot;)就能获取指定的实现类。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1590226285000.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>public class SpiTester {\n    public static void main(String[] args) throws Exception{\n        ExtensionLoader&lt;Filter&gt; filterExtensionLoader = ExtensionLoader.getExtensionLoader(Filter.class);\n        Set&lt;String&gt; supportedExtensions = filterExtensionLoader.getSupportedExtensions();\n        System.out.println(supportedExtensions);\n        //[accesslog, activelimit, cache...]\n        Filter hello = filterExtensionLoader.getExtension(&quot;hello&quot;);\n        //com.github.easylog.spi.ProviderHelloFilter@299a06ac\n        System.out.println(hello);\n    }\n    \n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>**那么这种思想你学会了吗? **</p>\n<p><img src=\"https://i04piccdn.sogoucdn.com/96a6f7554ee28b9c\" alt=\"\" loading=\"lazy\"></p>\n<p>最后求关注,求订阅,谢谢你的阅读!</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589360371000.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1590160192000.png",
      "date_published": "2021-12-25T09:26:08.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Java进阶"
      ]
    },
    {
      "title": "Java异常体系",
      "url": "https://java.springlearn.cn/learn/java/Java%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/",
      "id": "https://java.springlearn.cn/learn/java/Java%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/learn_1589293715000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n<p>知己知彼方能百战不殆,在小编初学Java时候特别怕程序报异常,经常会因为异常不知所措,相信这个问题应该是所有\n初学者都会有的心理感受;如果你也有这种感受,那么只有一种解决方法:\n迎难而上,攻克Java异常体系,长痛不如短痛,只要清楚了Java的异常体系,就不会再有这种感受了。下面跟着小编来窥探Java的异常体系吧。</p>\n<h1 id=\"一、java异常体系其实很简单\"> 一、Java异常体系其实很简单</h1>\n<p>其实Java的异常体系是非常简单的,简单到只要你看过本文就能明白百分之八九十的样子。当你清楚了Java的异常体系\n那么在遇到项目执行异常的时候,基本看报错的异常就大概明白问题出在哪里,遇到的错误多了,就成长了,处理的问题就是\n你未来在技术路上所积累的财富。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589294764000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>在Java的异常体系中 <code>Throwable</code> 我们可以理解为是一个根异常,即所有的异常都是它的子类</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589295509000.png\" alt=\"\" loading=\"lazy\"></p>\n<h1 id=\"二、error\"> 二、Error</h1>\n<p>前面我们说了Java的异常体系中 <code>Throwable</code> 可以理解是一个根异常,那么 <code>Error</code> 就是这个根节点的一个子节点。\n<code>Error</code> 类对象由 <code>Java</code> 虚拟机生成并抛出，大多数错误与代码编写者所执行的操作无关。程序无法处理的异常，一般伴随者jvm虚拟机停止，或者断电之类\n这种问题，是无法通过程序来解决的。</p>\n<p><strong>这种异常基本很少,如果遇到也不要慌,跟你的业务逻辑没有关系,顶多是Java代码写的有问题,只要不是业务问题其实大多都能先通过重启解决;\n但是假如项目还未上线,只是在开发过程中出现这种问题一定要弄清楚原因,是那一部分代码编写异常导致的,否则上线可能有重大隐患</strong></p>\n<p><strong>经验教学:</strong></p>\n<ol>\n<li>如果是在项目系统过程中遇到这种问题,可能是因为Jar包冲突导致的。</li>\n<li>如果是在项目运行过程中遇到这种问题,可能是因为对象创建过多没有释放,导致堆栈溢出。这个时候就要看GC是否频繁,然后对堆栈日志进行分析,看存在最多的对象是哪一个,然后分析代码解决。</li>\n</ol>\n<h1 id=\"三、exception\"> 三、Exception</h1>\n<p><code>Exception</code> 异常时我们平时在开发中遇到最多，其实 <code>Exception</code> 也分为两种即:</p>\n<ol>\n<li><code>checkException</code> 编译异常，这种异常，是哪些没有遵守java语言规则，容易看出和解决的</li>\n<li><code>uncheckException</code> 运行异常，运行异常，具有不确定性，往往难以排查，包括处理逻辑问题。</li>\n</ol>\n<p>然而 <code>checkException</code> 和 <code>uncheckException</code> 其实只是一个概念,并没有对应的 <code>Java异常类</code>。我们基本可以忽略\n<code>checkException</code> 因为这种异常基本现在的编译器都会给我们做了，我们在写代码时候就会实时的给我提示错误了。我们\n只用关心 <code>uncheckException</code>即可。</p>\n<p><strong>uncheckException</strong></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589297073000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><code>RuntimeException</code> + <code>Error</code> 和其子类都是属于 <code>uncheckException</code></p>\n<p>前面我们已经对 <code>Error</code> 做了说明，现在就主要来看下 <code>RuntimeException</code>。 <code>RuntimeException</code> 从名字来看就是\n运行异常,所谓运行异常就是可能在程序运行过程中发生的异常,这种异常一般是可以通过代码逻辑进行处理的。\n我们举例一个例子,我们都知道0不能作为除数。但是假如在下面这个代码中</p>\n<div><pre><code>public class Tester {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        System.out.print(&quot;请输入被除数a:&quot;);\n        int a = sc.nextInt();\n        System.out.print(&quot;请输入除数b:&quot;);\n        int b = sc.nextInt();\n        System.out.println(&quot;a/b=&quot; + a / b);\n    }\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>当输入a=8,b=2,那么结果就是4。</p>\n<p><img src=\"https://i02piccdn.sogoucdn.com/8206a4441e0386c3\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>假如我们输入b=0呢?</strong></p>\n<p>学过数学都知道0不能做除数,程序也不运行你这么输入,但是却不能阻止你,只能通过报错的方式来告诉你。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589298143000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>那么我们就要对这个异常进行处理,当发现有这个异常就在控制台来提醒用户。那么代码就会变成这样</p>\n<div><pre><code>public class Tester {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        System.out.print(&quot;请输入被除数a:&quot;);\n        int a = sc.nextInt();\n        System.out.print(&quot;请输入除数b:&quot;);\n        int b = sc.nextInt();\n        try {\n            System.out.println(&quot;a/b=&quot; + a / b);\n        } catch (ArithmeticException ate) {\n            //对算术异常进行捕捉\n            System.err.println(&quot;0不能作为除数,请输入不为0的任意数&quot;);\n        }\n    }\n}\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>当出现算术异常直接提示: &quot;0不能作为除数,请输入不为0的任意数&quot;\n<img src=\"https://img.springlearn.cn/blog/learn_1589298261000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>那么像这种程序中无可避免会出现,且又能通过逻辑来处理的异常就是运行异常。运行异常一般都可以正常运行,只是在特定情况下会导致异常发生。\n像这面这个例子,我们只要看到 <code>ArithmeticException</code> 就知道是算术异常。所以只要我们对运行异常类有一个认识，其实就能解决大多数的程序问题了。\n下面我们来看下运行异常都要有哪些类把。</p>\n<p><img src=\"https://i03piccdn.sogoucdn.com/f960e6a461d218d2\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>只要对下面运行异常类进行熟悉了,基本就清楚掌握了Java的异常体系了</strong></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589299119000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589299523000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>以上就是常见的运行异常类,当然Java中还有很多不常见的异常类。剩下的我们就可以在日常工作中去学习了。</p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1589293715000.png",
      "date_published": "2021-12-25T09:26:08.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Java进阶"
      ]
    },
    {
      "title": "synchronized锁升级",
      "url": "https://java.springlearn.cn/learn/java/synchronized/",
      "id": "https://java.springlearn.cn/learn/java/synchronized/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/learn_1596467333000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n<h2 id=\"一、重量级锁\"> 一、重量级锁</h2>\n<p>什么叫重量级锁？</p>\n<p>就是申请资源必须经过kernel(内核也叫操作系统)，调用。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596467437000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"二、轻量级锁\"> 二、轻量级锁</h2>\n<p>轻量级锁,是不经过操作系统。轻量级锁是相对于重量级锁来叫的,也可以叫乐观锁。</p>\n<p>在Java中乐观锁就是cas操作(compare and swap)根据英文翻译就是比较和交换。\n底层都是调用的Unsafe里面的方法,可以看到这些方法是native方法。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596467628000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>通过看jvm源码,看到c++的代码有一个汇编语言支持cas</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596467784000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>但是，这条cmpchg1不具有原子性，点进lock_if_mp(%4)里</p>\n<p>最终实现是lock cmpxchg 指令：表示在硬件在执行后面的指令会锁定一个北桥总线。（相当于锁定总线，但是比锁总线要轻量级）解决了下面的问题</p>\n<h2 id=\"三、偏向锁\"> 三、偏向锁</h2>\n<p>顾名思义，它会偏向于第一个访问锁的线程，如果在运行过程中，同步锁只有一个线程访问，不存在多线程争用的情况，则线程是不需要触发同步的，这种情况下，就会给线程加一个偏向锁。\n说白了,没有竞争,还叫啥锁呀。就是加了一个标记。认为没有人给你竞争。</p>\n<h2 id=\"四、锁升级步骤\"> 四、锁升级步骤</h2>\n<p>偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁</p>\n<p>在jdk1.6之前synchronized直接就是一个重量级锁,一了百了。\njdk优化后出现了,锁升级的概念。</p>\n<p>那么其实synchronized的执行过程:</p>\n<ol>\n<li>检测Mark Word里面是不是当前线程的ID，如果是，表示当前线程处于偏向锁</li>\n<li>如果不是，则使用CAS将当前线程的ID替换Mard Word，如果成功则表示当前线程获得偏向锁，置偏向标志位1(前面一个线程刚好释放的情况下,这个才能成功,否则看3)</li>\n<li>如果失败，则说明发生竞争，撤销偏向锁，进而升级为轻量级锁。</li>\n<li>当前线程使用CAS将对象头的Mark Word替换为锁记录指针，如果成功，当前线程获得锁</li>\n<li>如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</li>\n<li>如果自旋成功则依然处于轻量级状态。</li>\n<li>如果自旋失败，则升级为重量级锁。</li>\n</ol>\n<p>翻译成白话问:</p>\n<ol>\n<li>\n<p>当没有人跟你竞争就是一个偏向锁,当cas失败了,说明有人跟你竞争了,这个时候锁就从偏向锁升级成了轻量级锁。</p>\n</li>\n<li>\n<p>轻量级锁的状态下,仍然还有很多线程来竞争,那么此时cas就会比较严重从而浪费cpu执行。就升级为重量级锁。\n其次其他等待线程就进入了阻塞状态。</p>\n</li>\n</ol>\n<p>最后求关注,求订阅,谢谢你的阅读!</p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1596467333000.png",
      "date_published": "2022-01-04T14:58:20.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Java进阶"
      ]
    },
    {
      "title": "Lambda函数式编程",
      "url": "https://java.springlearn.cn/learn/java/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/",
      "id": "https://java.springlearn.cn/learn/java/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n<blockquote>\n<p>Java8所有的新特性基本基于函数式编程的思想，函数式编程给Java带来了注入了新鲜的活力。\n函数式编程其实并不是很难，小编在学习函数式编程时候刚开始一头雾水，最后仔细观察就发现了其中的小窍门，读了本篇文章如果还没有掌握，就算我输了</p>\n</blockquote>\n<h1 id=\"函数式编程\"> 函数式编程</h1>\n<h2 id=\"一、lambda表达式\"> 一、Lambda表达式</h2>\n<p><strong>注意</strong>: 以下方法都可以使用表达式来进行缩写</p>\n<p>我们来看Java中如何来定义一个方法</p>\n<h3 id=\"_1-语法\"> 1. 语法</h3>\n<p><code>()-&gt;{}</code></p>\n<p>其中小括号里面可以放入参，大括号就是方法体，里面也允许有返回值。</p>\n<p><strong>当方法体中只有返回值而没有其他语句时候，大括号和 <code>return</code> 关键字都可以省略不写。</strong></p>\n<h3 id=\"_2-方法引用\"> 2. 方法引用</h3>\n<p><em>只要用.引用不报错的，都可以将.换成:</em></p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>语法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1、引用静态方法</td>\n<td>ClassName::staticMethodName</td>\n</tr>\n<tr>\n<td>2、引用构造函数</td>\n<td>ClassName::new</td>\n</tr>\n<tr>\n<td>3、引用特定类型的实例方法</td>\n<td>ClassName::instanceMethodName</td>\n</tr>\n<tr>\n<td>4、引用特定对象的实例方法</td>\n<td>objectName::instanceMethodName</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"二、java8新增函数式接口\"> 二、Java8新增函数式接口</h2>\n<h3 id=\"_1-predicate接口\"> 1. Predicate接口</h3>\n<p>Predicate 接口只有一个参数，返回boolean类型。该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）</p>\n<div><pre><code>Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; 0;\n</code></pre>\n<div><span>1</span><br></div></div><p>根据前面的语法我们知道小括号里面可以放入参，大括号里面放出参，当大括号里面只有返回值时候，大括号和 <code>return</code> 关键字也可以省略。如上。</p>\n<h3 id=\"_2-function-接口\"> 2. Function 接口</h3>\n<p>Function 接口有一个参数并且返回一个结果，并附带了一些可以和其他函数组合的默认方法（compose, andThen）：</p>\n<div><pre><code>Function&lt;Integer, Integer&gt; function = (x) -&gt; 2 * x;\n</code></pre>\n<div><span>1</span><br></div></div><p>同理，这个接口有一个入参和出参，如果返回体重不包含其他逻辑，只有一个返回值，大括号和 <code>return</code> 关键字也可以省略。如上。</p>\n<h3 id=\"_3-supplier-接口\"> 3. Supplier 接口</h3>\n<p>Supplier 接口返回一个任意范型的值，和Function接口不同的是该接口没有任何参数</p>\n<div><pre><code>public class Main{\n    public static void main(String[] args) {\n        //构造方法\n        Supplier&lt;Main&gt; supplier = () -&gt; new Main();\n        Supplier&lt;Main&gt; mainSupplier = Main::new;\n        Supplier&lt;Main&gt; mainSupplier1 = Main::staticMethod;\n    }\n    private static Main staticMethod() {\n        return new Main();\n    }\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>因为没有入参，所以小括号里面什么都不用写。当遇到这种情况，同样可以用上面其他两种来替换</p>\n<h3 id=\"_4-consumer-接口\"> 4. Consumer 接口</h3>\n<p>Consumer 是一个只有入参，但是无出参的接口。</p>\n<div><pre><code>public class Main {\n    public static void main(String[] args) {\n        List&lt;String&gt; dataList = Arrays.asList(&quot;1&quot;, &quot;2&quot;);\n\n        //特定类的静态方法\n        dataList.forEach(Main::staticMethod);\n        dataList.forEach((x) -&gt; System.out.println(x));\n        dataList.forEach(System.out::println);\n\n    }\n    private static void staticMethod(String name) {\n        System.out.println(&quot;对象静态方法引用:&quot; + name);\n    }\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h2 id=\"三、快速记忆\"> 三、快速记忆</h2>\n<p>虽然新增的函数式接口并不多，但是想要一次性死记住，还是有一点点的难度。小编的学习方式是\n理解这记忆。</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>简记</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1、Predicate</td>\n<td>条件类型</td>\n</tr>\n<tr>\n<td>2、Supplier</td>\n<td>无入参，有出参</td>\n</tr>\n<tr>\n<td>3、Function</td>\n<td>有入参，有出参</td>\n</tr>\n<tr>\n<td>4、Consumer</td>\n<td>有入参，无出参</td>\n</tr>\n</tbody>\n</table>\n<p>最后求关注,求订阅,谢谢你的阅读!</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589360371000.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png",
      "date_published": "2021-12-25T09:26:08.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Java进阶"
      ]
    },
    {
      "title": "Java四大引用",
      "url": "https://java.springlearn.cn/learn/java/%E5%9B%9B%E5%A4%A7%E5%BC%95%E7%94%A8/",
      "id": "https://java.springlearn.cn/learn/java/%E5%9B%9B%E5%A4%A7%E5%BC%95%E7%94%A8/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n<h1 id=\"一、概念\"> 一、概念</h1>\n<h2 id=\"_1-强引用\"> 1. 强引用</h2>\n<p>new 对象并指向引用变量的都是强引用,开发中大部分都是强引用。对于强引用,JVM宁愿报错<code>OutOfMemoryError</code>错误,是程序异常终止,\n也不会回收强引用来解决内存, 对这类情况,可以通过赋值强引用对象=null,从而被JVM回收。\n但是一般我们在方法中定义的强引用,会存在方法栈中,当方法运行完,退出,此时方法中的强引用也会因为引用数为0,从而被回收。</p>\n<h2 id=\"_2-软引用\"> 2. 软引用</h2>\n<p>在内存充足情况下,GC不会回收软引用对象,如果内存空间不足了,才会回收这些对象的内存。也正因为这个特性,所以软引用经常用作缓存对象使用。</p>\n<h2 id=\"_3-弱引用\"> 3. 弱引用</h2>\n<p>任意GC都会清理掉软引用对象,弱引用是最容易记的,任何的GC动作都会将弱引用对象给回收掉。</p>\n<h2 id=\"_4-虚引用\"> 4. 虚引用</h2>\n<p>和其他三个不一样,这个不对生命周期,有影响,而是当要回收时候,加入到Queue队列中</p>\n<h1 id=\"二、在jdk中的体现\"> 二、在JDK中的体现</h1>\n<table>\n<thead>\n<tr>\n<th>类</th>\n<th>引用说明</th>\n<th>用途</th>\n<th>生存时间</th>\n<th>被垃圾回收时间</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Object</td>\n<td>默认new出来的都是强引用</td>\n<td>对象正常状态</td>\n<td>JVM停止或者无引用被回收</td>\n<td>无任务对象使用</td>\n</tr>\n<tr>\n<td>SoftReference</td>\n<td>软引用</td>\n<td>常用作缓存</td>\n<td>当内存不足时候终止</td>\n<td>内存不足时候回收</td>\n</tr>\n<tr>\n<td>WeakReference</td>\n<td>弱引用</td>\n<td>常用作缓存</td>\n<td>垃圾回收后终止</td>\n<td>任何垃圾回收时</td>\n</tr>\n<tr>\n<td>PhantomReference</td>\n<td>虚引用</td>\n<td>用于跟踪对象是否被回收</td>\n<td>垃圾回收后终止</td>\n<td>任何垃圾回收时</td>\n</tr>\n</tbody>\n</table>\n<p>最后求关注,求订阅,谢谢你的阅读!</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589360371000.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png",
      "date_published": "2021-12-25T09:26:08.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Java进阶"
      ]
    },
    {
      "title": "JVM钩子hooks函数",
      "url": "https://java.springlearn.cn/learn/java/hooks%E5%87%BD%E6%95%B0/",
      "id": "https://java.springlearn.cn/learn/java/hooks%E5%87%BD%E6%95%B0/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/learn_1589383784000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n<p>什么是钩子函数,在学习钩子函数之前,小编先提一个问题。</p>\n<p><strong>请问在Spring中,如果JVM异常终止,Spring是如何保证会释放掉占用的资源,比如说数据库连接等资源呢?</strong></p>\n<p>钩子函数非常简单,简单到小编只用摘抄一段Spring代码即可。走你,现在开始。</p>\n<h1 id=\"问题\"> 问题</h1>\n<p><code>Spring</code> 容器中 <code>Bean</code> 在什么时候执行销毁方法?</p>\n<p>我们知道在Spring中定义销毁方法有两种方式</p>\n<ol>\n<li>实现 <code>DisposableBean</code> 的 <code>destroy</code> 方法。</li>\n<li>使用 <code>@PreDestroy</code> 注解修饰方法</li>\n</ol>\n<div><pre><code>@Component\npublic class DataCollectBean implements DisposableBean {\n\n    /**\n     * 第一种方法实现 DisposableBean#destroy方法\n     *\n     * @throws Exception 异常\n     */\n    @Override\n    public void destroy() throws Exception {\n        System.err.println(&quot;执行销毁方法&quot;);\n    }\n\n    /**\n     * 第二种方法使用PreDestroy注解声明销毁方法\n     */\n    @PreDestroy\n    public void customerDestroy() {\n        System.err.println(&quot;执行自定义销毁方法&quot;);\n    }\n\n\n}\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h2 id=\"那么在什么时候执行销毁方法\"> 那么在什么时候执行销毁方法?</h2>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589471346000.png\" alt=\"\" loading=\"lazy\"></p>\n<ol>\n<li>主动执行销毁bean</li>\n</ol>\n<div><pre><code>    public static void main(String[] args) {\n        ConfigurableApplicationContext run = SpringApplication.run(DemoApplication.class, args);\n        DataCollectBean bean = run.getBean(DataCollectBean.class);\n        //1. 主动销毁bean\n        run.getBeanFactory().destroyBean(bean);\n    }\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ol start=\"2\">\n<li>JVM关闭时候自动执行销毁方法。</li>\n</ol>\n<p>这里就要用到钩子函数了, <code>Spring</code> 的钩子函数在 <code>AbstractApplicationContext#shutdownHook属性</code></p>\n<p>如果我们是SpringBoot项目我们看到在SpringApplication启动时候会注册一个钩子函数</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589473259000.png\" alt=\"\" loading=\"lazy\"></p>\n<h1 id=\"如何定义钩子函数\"> 如何定义钩子函数?</h1>\n<p>简直太简单了，没有任何学习成本。一行代码就能搞定。</p>\n<div><pre><code>public class HooksTester {\n    public static void main(String[] args) {\n        Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(&quot;钩子函数执行&quot;);\n            }\n        }));\n        //当主动关闭应用\n        while (true);\n    }\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p><img src=\"https://img.springlearn.cn/blog/learn_1589471574000.png\" alt=\"\" loading=\"lazy\"></p>\n<h1 id=\"触发钩子函数的场景\"> 触发钩子函数的场景</h1>\n<p>只要不是机器断电，强制kill -9 强制杀进程，都会触发。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589473502000.png\" alt=\"\" loading=\"lazy\"></p>\n<h1 id=\"钩子函数能做什么\"> 钩子函数能做什么？</h1>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589383970000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>正如上图所示优雅停机,在项目将要关闭时候,主动释放程序占用的资源信息,释放db连接池的连接等其他占用的资源信息。\n如果我们是 <code>Spring</code> 项目其实我们不用自己定义钩子函数,我们只要使用Spring提供给我们的销毁方法即可。因为\nSpring定义的钩子函数中会去执行, <code>DisposableBean.destory()</code> 和被 <code>PreDestroy</code> 修饰的方法。</p>\n<p>我们看下源码</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589472185000.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>protected void doClose() {\n\t\t// Check whether an actual close attempt is necessary...\n\t\tif (this.active.get() &amp;&amp; this.closed.compareAndSet(false, true)) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(&quot;Closing &quot; + this);\n\t\t\t}\n\n\t\t\tLiveBeansView.unregisterApplicationContext(this);\n\n\t\t\ttry {\n\t\t\t\t// Publish shutdown event.\n\t\t\t\tpublishEvent(new ContextClosedEvent(this));\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tlogger.warn(&quot;Exception thrown from ApplicationListener handling ContextClosedEvent&quot;, ex);\n\t\t\t}\n\n\t\t\t// Stop all Lifecycle beans, to avoid delays during individual destruction.\n\t\t\tif (this.lifecycleProcessor != null) {\n\t\t\t\ttry {\n\t\t\t\t\tthis.lifecycleProcessor.onClose();\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tlogger.warn(&quot;Exception thrown from LifecycleProcessor on context close&quot;, ex);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Destroy all cached singletons in the context&#39;s BeanFactory.\n\t\t\tdestroyBeans();\n\n\t\t\t// Close the state of this context itself.\n\t\t\tcloseBeanFactory();\n\n\t\t\t// Let subclasses do some final clean-up if they wish...\n\t\t\tonClose();\n\n\t\t\t// Reset local application listeners to pre-refresh state.\n\t\t\tif (this.earlyApplicationListeners != null) {\n\t\t\t\tthis.applicationListeners.clear();\n\t\t\t\tthis.applicationListeners.addAll(this.earlyApplicationListeners);\n\t\t\t}\n\n\t\t\t// Switch to inactive.\n\t\t\tthis.active.set(false);\n\t\t}\n\t}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><p>可以看到：doClose()方法会执行bean的destroy()，也会执行SmartLifeCycle的stop()方法，我们就可以通过重写这些方法来实现对象的关闭，生命周期的管理，实现平滑shutdown</p>\n<p><img src=\"https://i03piccdn.sogoucdn.com/7eac32473373b70a\" alt=\"\" loading=\"lazy\"></p>\n<p>最后求关注,求订阅,谢谢你的阅读!</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589360371000.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1589383784000.png",
      "date_published": "2021-12-25T09:26:08.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Java进阶"
      ]
    },
    {
      "title": "线程安全之原子操作",
      "url": "https://java.springlearn.cn/learn/java/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/",
      "id": "https://java.springlearn.cn/learn/java/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/learn_1589361031000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n<p><strong>原子特性: 原子是最小的粒子,不可再分</strong></p>\n<p>这并不是一个化学课,而是巧妙的借用了化学上的一个概念,即原子是最小的粒子,不可再分;原子操作也是不能再分的操作;\n为了能把这个讲明白,下文基本都是大白话,其实Java本来并不是很难,而是总有一些人喜欢把简单的概念给复杂化。小编不喜欢\n那种说辞,所以尽量简单易懂。如有问题,欢迎提出问题。共同交流进步,最后谢谢你的阅读。</p>\n<hr>\n<h1 id=\"举例说明原子操作重要性\"> 举例说明原子操作重要性</h1>\n<p>在很多场景中我们需要我们的操作是原子特性的,如果我们写的程序都是单线程的,其实我们没必要考虑原子操作。但是假如\n我们写多线程操作,或者是在Web服务中来更新对象属性,那么就必须要来考虑原子操作问题了。</p>\n<p>举一个🌰例子A:</p>\n<div><pre><code>int a = 1;\n</code></pre>\n<div><span>1</span><br></div></div><p>可以看到程序对变量 <code>a</code> 操作,其实是有多个步骤进行的。在单线程环境下基本不会发生任何问题\n<img src=\"https://img.springlearn.cn/blog/learn_1589372995000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>举一个🌰例子B(单线程操作):</p>\n<div><pre><code>public class Tester {\n\n    private static Integer a = 1;\n\n    private static AtomicInteger aa = new AtomicInteger(1);\n\n    private static void restore() {\n        a = 1;\n        aa = new AtomicInteger(1);\n    }\n\n    public static void main(String[] args) {\n        for (int i = 0; i &lt; 10; i++) {\n            test(&quot;第&quot; + i + &quot;次&quot;);\n            restore();\n        }\n    }\n\n    private static void test(String str) {\n        for (int i = 1; i &lt;= 1000; i++) {\n            new Thread(() -&gt; a = a + 1).start();\n            new Thread(() -&gt; aa.addAndGet(1)).start();\n        }\n        System.out.print(str + &quot;常规操作a=&quot; + a);\n        System.out.println(&quot; &lt;===&gt; &quot;+str+&quot;原子操作操作aa=&quot; + aa);\n    }\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>规律:</p>\n<div><pre><code>        /**\n         * i              i+1\n         * 1: a = 1 + 1 = 2\n         * 2: a = 2 + 1 = 3\n         * 3: a = 3 + 1 = 4\n         * 4: a = 4 + 1 = 5\n         * 5: a = 5 + 1 = 6\n         * 6: a = 6 + 1 = 7\n         * 7: a = 7 + 1 = 8\n         * 8: a = 8 + 1 = 9\n         * 9: a = 9 + 1 = 10\n         * 10:a = 10 + 1 = 11\n         */\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>如上面代码变量a是基本类型,变量aa是原子类型,正常情况对a或者aa进行1000次操作结果都应该是\n<code>1001</code>。正常情况我们可以理解是单线程操作。结果也是没有问题的。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589380382000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>举一个🌰例子C(多线程操作):</p>\n<div><pre><code>public class Tester {\n\n    private static Integer a = 1;\n\n    private static AtomicInteger aa = new AtomicInteger(1);\n\n    private static void restore() {\n        a = 1;\n        aa = new AtomicInteger(1);\n    }\n\n    public static void main(String[] args) throws Exception {\n        for (int i = 0; i &lt; 10; i++) {\n            test(&quot;第&quot; + i + &quot;次&quot;);\n            restore();\n        }\n    }\n\n    private static void test(String str) throws Exception {\n        for (int i = 1; i &lt;= 100; i++) {\n            new Thread(() -&gt; a = a + 1).start();\n            new Thread(() -&gt; a = a + 1).start();\n\n            new Thread(() -&gt; aa.addAndGet(1)).start();\n            new Thread(() -&gt; aa.addAndGet(1)).start();\n            Thread.sleep(1);\n        }\n        System.out.print(str + &quot;常规操作a=&quot; + a);\n        System.out.println(&quot; &lt;===&gt; &quot; + str + &quot;原子操作操作aa=&quot; + aa);\n    }\n    \n}\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><p>规律:</p>\n<div><pre><code>    /**\n     * i          2 * i + 1\n     * 1: a = 1 + 1 + 1 = 3\n     * 2: a = 3 + 1 + 1 = 5\n     * 3: a = 5 + 1 + 1 = 7\n     * 4: a = 7 + 1 + 1 = 9\n     * 5:                 11\n     * 6:                 13\n     * 7:                 15\n     * 8:                 17\n     * 9:                 19\n     * 10:                21\n     */\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>多线程环境下操作会不会有问题呢? 出现了问题。我们看到使用常规操作的a变量出现了数据不一致情况。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589375176000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>实际上当循环的次数越多,出现错误的几率就越大,如下我们循环了1000次。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589375386000.png\" alt=\"\" loading=\"lazy\"></p>\n<h1 id=\"问题分析\"> 问题分析</h1>\n<p>我们思考为什么基本类型进行多线程操作时候会出现这种情况呢? 其实问题答案最开始已经说了。 我们通过这张图\n就可以找到原因。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589372995000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>对变量的每次操作其实都有3个步骤</p>\n<ol>\n<li>读取变量值</li>\n<li>变量值操作</li>\n<li>变量重新赋值。</li>\n</ol>\n<p>我们模拟一下错误的原因。</p>\n<p>当A线程读取a=1,并对1+1。但是还未对变量重新赋值a=2的时候，\nB线程也读取了A还未赋值的变量,此时变量还是1,那么B线程因为读取了还未更新的数据,所以也做1+1的操作。然后B对a\n重新赋值了此时a=2,是B赋值的。这个时候A因为已经执行完了前两个步骤,最后也重新赋值了a=2。</p>\n<p>这样数据就更新丢了。这就是因为数据更新不是原子性从而导致的问题。</p>\n<p>因为数据更新丢了,所以出现了。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589380830000.png\" alt=\"\" loading=\"lazy\"></p>\n<h1 id=\"如何解决这种问题\"> 如何解决这种问题</h1>\n<p>如何解决这种问题,其实很简单只要我们保证我们的操作是原子操作即可,简单来说就是将更新的三个步骤合并成一个步骤即可,在Java中JDK已经为我们提供了很多的\n原子操作每一个基本类型都对应一个原子操作。</p>\n<h2 id=\"原子基础类\"> 原子基础类</h2>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589378016000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>原子基础类API</strong></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589378409000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"原子数组类\"> 原子数组类</h2>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589378718000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>原子更新数组API</strong></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589378583000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"原子引用类\"> 原子引用类</h2>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589379304000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>注意:</strong></p>\n<p>想要原子的更新字段，需要两个步骤：</p>\n<p>1.每次使用的时候必须使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类和属性</p>\n<p>2.更新类的字段（属性）必须使用public volatile修饰符</p>\n<h1 id=\"最后我们看一下原子操作的原理\"> 最后我们看一下原子操作的原理</h1>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589379629000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>最后求关注,求订阅,谢谢你的阅读!</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589360371000.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1589361031000.png",
      "date_published": "2021-12-25T09:26:08.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Java进阶"
      ]
    },
    {
      "title": "分布式锁",
      "url": "https://java.springlearn.cn/learn/java/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/",
      "id": "https://java.springlearn.cn/learn/java/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/learn_1596467333000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>在单机环境下多线程操作共享数据时候回用到锁的概念,因为是单机可以直接使用jdk提供的锁机制就可以满足。\n但是在微服务场景下,因为是多服务共享数据,此时jdk提供的锁就不能再使用了。于是乎就有了分布式锁。\n本文介绍常见的几种可以使用的生产的分布式锁</p>\n</div>\n<p><strong>本文面向有开发经验的同学,所以场景就不赘述,直接上干货</strong></p>\n<h2 id=\"一、分布式锁具有的品格\"> 一、分布式锁具有的品格</h2>\n<ul>\n<li>基本的加锁和释放锁</li>\n<li>具备锁失效机制,防止死锁</li>\n<li>非阻塞机制</li>\n<li>高性能和高可用</li>\n</ul>\n<h2 id=\"二、思考一下如何自己实现\"> 二、思考一下如何自己实现?</h2>\n<h3 id=\"_1-db\"> 1. db</h3>\n<p>根据上面提出的要求,发现只要能满足多服务之前通信就能实现。\n比如我们可以用mysql就能实现,比如A服务对一个表加锁和释放锁。B服务就会发现表加了锁。此时B就阻塞了。</p>\n<p>当然这明显不满足,非阻塞的机制。另外如果要用一个数据库来做锁的场景也太浪费性能了。</p>\n<h3 id=\"_2-redis\"> 2. redis</h3>\n<p>利用redis命令来实现,如果返回ok说明获取锁。返回nil说明没有获取到锁。</p>\n<p>不阻塞,防止死锁,高性能,都满足</p>\n<div><pre><code>set key value [EX seconds] [PX milliseconds] [NX|XX]\nEX seconds：设置失效时长，单位秒\nPX milliseconds：设置失效时长，单位毫秒\nNX：key不存在时设置value，成功返回OK，失败返回(nil)\nXX：key存在时设置value，成功返回OK，失败返回(nil)\n//对资源加一个锁 key为资源名 value可以为任意 ex为秒 1为过期时间 nx为\n127.0.0.1:6379&gt; set ziyuanming 1 ex 1 nx\nOK\n127.0.0.1:6379&gt; set ziyuanming 1 ex 1 nx\n(nil)\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id=\"_3-zookeeper\"> 3. zookeeper</h3>\n<h4 id=\"获取锁\"> 获取锁</h4>\n<ol>\n<li>在Zookeeper当中创建一个持久节点ParentLock。当第一个客户端想要获得锁时，需要在ParentLock这个节点下面创建一个临时顺序节点 Lock1。</li>\n<li>Client1查找ParentLock下面所有的临时顺序节点并排序，判断自己所创建的节点Lock1是不是顺序最靠前的一个。如果是第一个节点，则成功获得锁。</li>\n<li>如果再有一个客户端 Client2 前来获取锁，则在ParentLock下载再创建一个临时顺序节点Lock2。\n此时Client2发现自己并不是最靠前的就像Lock1注册了一个Watcher,用于监听Lock1节点释放。此时Client2就进入等待状态</li>\n<li>Client3,4以此类推</li>\n</ol>\n<h4 id=\"释放锁\"> 释放锁</h4>\n<ol>\n<li>Client1释放了锁,此时Zookeeper就讲Lock1移出,并触发了Lock1的Watcher。</li>\n<li>Client2一直在监听Lock1的状态,当Lock1节点被删除,Client2里面收到通知获得了锁。</li>\n</ol>\n<h2 id=\"三、现成的解决方案\"> 三、现成的解决方案</h2>\n<h3 id=\"_1-db的方式就不考虑了\"> 1. db的方式就不考虑了</h3>\n<p>实现简单,但是不划算,性能也不是最好的。</p>\n<h3 id=\"_2-redis-2\"> 2. redis</h3>\n<div><pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.redisson&lt;/groupId&gt;\n    &lt;artifactId&gt;redisson&lt;/artifactId&gt;\n    &lt;version&gt;3.11.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code>\npublic class RedLockTester {\n    public static void main(String[] args) {\n        //连接redis\n        Config config = new Config();\n        config.useSingleServer().setAddress(&quot;redis://127.0.0.1:6379&quot;);\n        RedissonClient redisson = Redisson.create(config);\n        log.info(&quot;连接Redis&quot;);\n\n        //1.定义锁\n        RLock lock = redisson.getLock(&quot;myTest001&quot;);\n\n        try {\n            //尝试加锁的超时时间\n            Long timeout = 300L;\n            //锁过期时间\n            Long expire = 30L;\n            //2.获取锁\n            if (lock.tryLock(timeout, expire, TimeUnit.MILLISECONDS)) {\n                //2.1.获取锁成功的处理\n                log.info(&quot;加锁成功&quot;);\n                //...do something\n                log.info(&quot;使用完毕&quot;);\n            } else {\n                //2.2.获取锁失败的处理\n                log.info(&quot;加锁失败&quot;);\n                log.info(&quot;其他处理&quot;);\n            }\n        } catch (InterruptedException e) {\n            log.error(&quot;尝试获取分布式锁失败&quot;, e);\n        } finally {\n            //3.释放锁\n            try {\n                lock.unlock();\n                log.info(&quot;锁释放成功&quot;);\n            } catch (Exception e) {\n                //do nothing...\n            }\n        }\n\n        //关闭连接\n        redisson.shutdown();\n        log.info(&quot;关闭redis连接&quot;);\n    }\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br></div></div><p>通过官方文档能找到实现第三方工具</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596471713000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><a href=\"https://www.cnblogs.com/rgcLOVEyaya/p/RGC_LOVE_YAYA_1003days.html\" target=\"_blank\" rel=\"noopener noreferrer\">参考文章</a></p>\n<h3 id=\"_3-zookeeper-2\"> 3. zookeeper</h3>\n<p><a href=\"https://curator.apache.org/\" target=\"_blank\" rel=\"noopener noreferrer\">Curator</a></p>\n<div><pre><code>&lt;!-- 对zookeeper的底层api的一些封装 --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;\n            &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;\n            &lt;version&gt;2.12.0&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!-- 封装了一些高级特性，如：Cache事件监听、选举、分布式锁、分布式Barrier --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;\n            &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;\n            &lt;version&gt;2.12.0&lt;/version&gt;\n        &lt;/dependency&gt;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>几乎对所有的JDK锁都实现了,基于Zookeeper的分布式锁。具体使用方法可以自行百度。</p>\n<ul>\n<li>InterProcessMutex：分布式可重入排它锁</li>\n<li>InterProcessSemaphoreMutex：分布式排它锁</li>\n<li>InterProcessReadWriteLock：分布式读写锁</li>\n<li>InterProcessMultiLock：将多个锁作为单个实体管理的容器</li>\n<li>InterProcessSemaphoreV2 信号量</li>\n<li>DistributedBarrier 分布式栅栏</li>\n<li>DistributedDoubleBarrier 分布式栅栏</li>\n</ul>\n<p>最后求关注,求订阅,谢谢你的阅读!</p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1596467333000.png",
      "date_published": "2022-01-04T14:58:20.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Java进阶"
      ]
    },
    {
      "title": "线程安全感",
      "url": "https://java.springlearn.cn/learn/java/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/",
      "id": "https://java.springlearn.cn/learn/java/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/learn_1608963968000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n<h1 id=\"线程安全\"> 线程安全</h1>\n<blockquote>\n<p>所谓发生线程安全其实是有一个前提条件,即当有多线程时候才会设计到线程安全,单线程是不存在线程安全的问题的。且只有在有状态对象中才会发生。</p>\n</blockquote>\n<h2 id=\"_1-什么叫有状态对象\"> 1. 什么叫有状态对象?</h2>\n<h3 id=\"_1-1-无状态对象\"> 1.1 无状态对象</h3>\n<div><pre><code><span>public</span> <span>class</span> <span>Home</span><span>{</span>\n    <span>public</span> <span>String</span> <span>say</span><span>(</span><span>String</span> message<span>)</span><span>{</span>\n        <span>return</span> message<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"_1-2-有状态对象\"> 1.2 有状态对象</h3>\n<div><pre><code><span>public</span> <span>class</span> <span>Home</span><span>{</span>\n    <span>//实例变量</span>\n    <span>public</span> <span>int</span> age <span>=</span> <span>0</span><span>;</span>\n    <span>public</span> <span>String</span> <span>say</span><span>(</span><span>String</span> message<span>)</span><span>{</span>\n        <span>return</span> message <span>+</span> <span>(</span>age<span>++</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>为什么说无状态对象不会发生线程安全,线程对公共变量（实例变量，类变量）进行操作才会发生线程安全问题，而方法中变量是保存在每个线程的私有栈中的,所以不存在线程安全问题</p>\n<h2 id=\"_2-什么时候要保证线程安全\"> 2. 什么时候要保证线程安全？</h2>\n<ol>\n<li>当变量属于实例,该实例被多线程操作</li>\n<li>当多线程会影响到执行结果时候,需要保证线程安全</li>\n<li>当变量属于共享属性时候需要保证线程安全,而方法内变量属于每个\n线程的空间,则不需要。</li>\n</ol>\n<h2 id=\"_3-如何保证线程安全\"> 3. 如何保证线程安全？</h2>\n<ol>\n<li>原子性 lock操作,Syn...</li>\n<li>可见性 volatile</li>\n<li>顺序性 防止被重排序</li>\n</ol>\n<h2 id=\"_3-1-原子性\"> 3.1 原子性</h2>\n<p>原子是世界上的最小单位，具有不可分割性。比如 a=0；（a非long和double类型） 这个操作是不可分割的，那么我们说这个操作时原子操作。再比如：a++； 这个操作实际是a = a + 1；是可分割的，所以他不是一个原子操作。非原子操作都会存在线程安全问题，需要我们使用同步技术（sychronized）来让它变成一个原子操作。</p>\n<h2 id=\"_3-2-可见性\"> 3.2 可见性</h2>\n<p>可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个线程修改的结果。另一个线程马上就能看到。比如：用volatile修饰的变量，就会具有可见性。volatile修饰的变量不允许线程内部缓存和重排序，即直接修改内存。所以对其他线程是可见的。</p>\n<ul>\n<li>volatile 本质是在告诉jvm当前变量在寄存器中的值是不确定的,需要从主存中读取,</li>\n<li>synchronized 则是锁定当前变量,只有当前线程可以访问该变量,其他线程被阻塞住.</li>\n</ul>\n<h2 id=\"_3-3-那么什么时候用可见性\"> 3.3 那么什么时候用可见性？</h2>\n<p>当多线程并不直接进行原子性操作的时候，可以用 volatile 修饰,这样可以保证每个线程读取的都是最新的</p>\n<h2 id=\"_3-4-什么时候用原子性\"> 3.4 什么时候用原子性?</h2>\n<p>当涉及到多个线程对同一个数据进行操作的时候，为了保证在同一刻只有一个操作，就用 synchronized 修饰加锁🔐</p>\n<h2 id=\"_4-servlet线程安全问题思考\"> 4. Servlet线程安全问题思考</h2>\n<p>Servlet本身是无状态的，一个无状态的Servlet是绝对线程安全的，无状态对象设计也是解决线程安全问题的一种有效手段。</p>\n<p>所以，servlet是否线程安全是由它的实现来决定的，如果它内部的属性或方法会被多个线程改变，它就是线程不安全的，反之，就是线程安全的。</p>\n<p>在一个无状态的情况下，是不存在线程安全问题的，即使存在那也是跟它的实现类相关</p>\n<p>在Servlet中避免使用实例变量是保证Servlet线程安全的最佳选择。</p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1608963968000.png",
      "date_published": "2021-12-25T09:26:08.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Java进阶"
      ]
    },
    {
      "title": "dubbo 客户端调用流程",
      "url": "https://java.springlearn.cn/learn/dubbo/Dubbo%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E5%AE%A2%E6%88%B7%E7%AB%AFConsumer/",
      "id": "https://java.springlearn.cn/learn/dubbo/Dubbo%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E5%AE%A2%E6%88%B7%E7%AB%AFConsumer/",
      "content_html": "<blockquote>\n<p>前面我们学习了服务端如何启动暴露一个外部服务,本文主要学习客户端如何通过代理方式访问客户端请求</p>\n</blockquote>\n<h2 id=\"一、启动一个客户端consumer\"> 一、启动一个客户端Consumer</h2>\n<h3 id=\"_1-定义一个接口\"> 1. 定义一个接口</h3>\n<p>注意这里其实是引用的前文中的接口。生产中是服务提供方打一个jar包给客户端用。</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>UserService</span> <span>{</span>\n    <span>void</span> <span>say</span><span>(</span><span>String</span> message<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"_2-生成本地服务\"> 2. 生成本地服务</h3>\n<div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>consumerTest</span><span>(</span><span>)</span> <span>{</span>\n        <span>// 当前应用配置</span>\n        <span>ApplicationConfig</span> application <span>=</span> <span>new</span> <span>ApplicationConfig</span><span>(</span><span>)</span><span>;</span>\n        application<span>.</span><span>setName</span><span>(</span><span>\"consumerTest\"</span><span>)</span><span>;</span>\n\n        <span>// 连接注册中心配置</span>\n        <span>RegistryConfig</span> registry <span>=</span> <span>new</span> <span>RegistryConfig</span><span>(</span><span>)</span><span>;</span>\n        registry<span>.</span><span>setAddress</span><span>(</span><span>\"zookeeper://127.0.0.1:2181\"</span><span>)</span><span>;</span>\n\n        <span>// 注意：ReferenceConfig为重对象，内部封装了与注册中心的连接，以及与服务提供方的连接</span>\n        <span>// 引用远程服务</span>\n        <span>ReferenceConfig</span><span><span>&lt;</span><span>UserService</span><span>></span></span> reference <span>=</span> <span>new</span> <span>ReferenceConfig</span><span><span>&lt;</span><span>UserService</span><span>></span></span><span>(</span><span>)</span><span>;</span> <span>// 此实例很重，封装了与注册中心的连接以及与提供者的连接，请自行缓存，否则可能造成内存和连接泄漏</span>\n        reference<span>.</span><span>setApplication</span><span>(</span>application<span>)</span><span>;</span>\n        reference<span>.</span><span>setRegistry</span><span>(</span>registry<span>)</span><span>;</span> <span>// 多个注册中心可以用setRegistries()</span>\n        reference<span>.</span><span>setInterface</span><span>(</span><span>UserService</span><span>.</span><span>class</span><span>)</span><span>;</span>\n        reference<span>.</span><span>setVersion</span><span>(</span><span>\"1.0.0\"</span><span>)</span><span>;</span>\n        <span>UserService</span> userService <span>=</span> reference<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>\n        userService<span>.</span><span>say</span><span>(</span><span>\"hello\"</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h3 id=\"_3-原理分析\"> 3. 原理分析</h3>\n<p>首先客户端只有接口的,那么可以根据这个接口生成一个代理。而代理对象中逻辑就是,从zk中找到服务端地址。\n然后通过netty客户端去请求服务端的数据。然后返回</p>\n<h2 id=\"二、源码分析\"> 二、源码分析</h2>\n<p>带着我们猜测的逻辑一起来看下<code>ReferenceConfig</code>的实现原理。</p>\n<div><pre><code>  <span>public</span> <span>synchronized</span> <span>T</span> <span>get</span><span>(</span><span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>destroyed<span>)</span><span>{</span>\n            <span>throw</span> <span>new</span> <span>IllegalStateException</span><span>(</span><span>\"Already destroyed!\"</span><span>)</span><span>;</span>\n        <span>}</span>\n    \t<span>if</span> <span>(</span>ref <span>==</span> <span>null</span><span>)</span> <span>{</span>\n    \t    <span>//逻辑就在init里面</span>\n    \t\t<span>init</span><span>(</span><span>)</span><span>;</span>\n    \t<span>}</span>\n    \t<span>return</span> ref<span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>init先做写检查信息,如这个方法是否存在接口中\ncreateProxy#loadRegistries</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1597062241000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_1-集群容错策略\"> 1. 集群容错策略</h3>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1597062347000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>可以看到一共有9中策略。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1597063062000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>当时服务端是多个的时候,才会生成集群策略。另外既然是集群就要选择到底使用哪个来执行。这就是\n负载均衡或者说叫路由策略。</p>\n<h4 id=\"loadbalance负载均衡\"> LoadBalance负载均衡</h4>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1597064955000.png\" alt=\"\" loading=\"lazy\"></p>\n<ul>\n<li>directory中获取所有的invoker</li>\n<li>如果有多个invoker就去看配置的负载均衡策略</li>\n<li>根据负载均衡策略找到一个Inoker</li>\n</ul>\n<div><pre><code><span>public</span> <span>abstract</span> <span>class</span> <span>AbstractClusterInvoker</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>implements</span> <span>Invoker</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>{</span>\n    <span>public</span> <span>Result</span> <span>invoke</span><span>(</span><span>final</span> <span>Invocation</span> invocation<span>)</span> <span>throws</span> <span>RpcException</span> <span>{</span>\n\n        <span>checkWheatherDestoried</span><span>(</span><span>)</span><span>;</span>\n\n        <span>LoadBalance</span> loadbalance<span>;</span>\n        <span>//获取所有的invoker</span>\n        <span>List</span><span><span>&lt;</span><span>Invoker</span><span>&lt;</span><span>T</span><span>></span><span>></span></span> invokers <span>=</span> <span>list</span><span>(</span>invocation<span>)</span><span>;</span>\n        <span>//如果有多个invoker就去看配置的负载均衡策略</span>\n        <span>if</span> <span>(</span>invokers <span>!=</span> <span>null</span> <span>&amp;&amp;</span> invokers<span>.</span><span>size</span><span>(</span><span>)</span> <span>></span> <span>0</span><span>)</span> <span>{</span>\n            loadbalance <span>=</span> <span>ExtensionLoader</span><span>.</span><span>getExtensionLoader</span><span>(</span><span>LoadBalance</span><span>.</span><span>class</span><span>)</span><span>.</span><span>getExtension</span><span>(</span>invokers<span>.</span><span>get</span><span>(</span><span>0</span><span>)</span><span>.</span><span>getUrl</span><span>(</span><span>)</span>\n                    <span>.</span><span>getMethodParameter</span><span>(</span>invocation<span>.</span><span>getMethodName</span><span>(</span><span>)</span><span>,</span><span>Constants</span><span>.</span>LOADBALANCE_KEY<span>,</span> <span>Constants</span><span>.</span>DEFAULT_LOADBALANCE<span>)</span><span>)</span><span>;</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            loadbalance <span>=</span> <span>ExtensionLoader</span><span>.</span><span>getExtensionLoader</span><span>(</span><span>LoadBalance</span><span>.</span><span>class</span><span>)</span><span>.</span><span>getExtension</span><span>(</span><span>Constants</span><span>.</span>DEFAULT_LOADBALANCE<span>)</span><span>;</span>\n        <span>}</span>\n        <span>RpcUtils</span><span>.</span><span>attachInvocationIdIfAsync</span><span>(</span><span>getUrl</span><span>(</span><span>)</span><span>,</span> invocation<span>)</span><span>;</span>\n        <span>//根据策略选一个</span>\n        <span>return</span> <span>doInvoke</span><span>(</span>invocation<span>,</span> invokers<span>,</span> loadbalance<span>)</span><span>;</span>\n    <span>}</span>\n     \n     <span>protected</span>  <span>List</span><span><span>&lt;</span><span>Invoker</span><span>&lt;</span><span>T</span><span>></span><span>></span></span> <span>list</span><span>(</span><span>Invocation</span> invocation<span>)</span> <span>throws</span> <span>RpcException</span> <span>{</span>\n    \t<span>List</span><span><span>&lt;</span><span>Invoker</span><span>&lt;</span><span>T</span><span>></span><span>></span></span> invokers <span>=</span> directory<span>.</span><span>list</span><span>(</span>invocation<span>)</span><span>;</span>\n    \t<span>return</span> invokers<span>;</span>\n     <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p><img src=\"https://img.springlearn.cn/blog/learn_1597064611000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_2-invoker生成代理对象\"> 2. invoker生成代理对象</h3>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1597063197000.png\" alt=\"\" loading=\"lazy\">\n代理的知识点不用说了。</p>\n<h3 id=\"_3-客户端的invoker逻辑\"> 3. 客户端的invoker逻辑</h3>\n<h4 id=\"protocol-refer\"> Protocol#refer</h4>\n<p>主要看DubboProtocol的逻辑</p>\n<div><pre><code>  <span>public</span> <span><span>&lt;</span><span>T</span><span>></span></span> <span>Invoker</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>refer</span><span>(</span><span>Class</span><span><span>&lt;</span><span>T</span><span>></span></span> serviceType<span>,</span> <span>URL</span> url<span>)</span> <span>throws</span> <span>RpcException</span> <span>{</span>\n        <span>// create rpc invoker.</span>\n        <span>DubboInvoker</span><span><span>&lt;</span><span>T</span><span>></span></span> invoker <span>=</span> <span>new</span> <span>DubboInvoker</span><span><span>&lt;</span><span>T</span><span>></span></span><span>(</span>serviceType<span>,</span> url<span>,</span> <span>getClients</span><span>(</span>url<span>)</span><span>,</span> invokers<span>)</span><span>;</span>\n        invokers<span>.</span><span>add</span><span>(</span>invoker<span>)</span><span>;</span>\n        <span>return</span> invoker<span>;</span>\n  <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h4 id=\"dubboinvoker\"> DubboInvoker</h4>\n<p>底层调用netty通信api发送数据到客户端。然后读取数据。</p>\n<div><pre><code>\n客户端doInvoke时候会生成<span>ExchangeClient</span>就是<span>NettyClient</span>。\n<span>public</span> <span>class</span> <span>DubboInvoker</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>extends</span> <span>AbstractInvoker</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>{</span>\n\n    <span>@Override</span>\n    <span>protected</span> <span>Result</span> <span>doInvoke</span><span>(</span><span>final</span> <span>Invocation</span> invocation<span>)</span> <span>throws</span> <span>Throwable</span> <span>{</span>\n        <span>RpcInvocation</span> inv <span>=</span> <span>(</span><span>RpcInvocation</span><span>)</span> invocation<span>;</span>\n        <span>final</span> <span>String</span> methodName <span>=</span> <span>RpcUtils</span><span>.</span><span>getMethodName</span><span>(</span>invocation<span>)</span><span>;</span>\n        inv<span>.</span><span>setAttachment</span><span>(</span><span>Constants</span><span>.</span>PATH_KEY<span>,</span> <span>getUrl</span><span>(</span><span>)</span><span>.</span><span>getPath</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        inv<span>.</span><span>setAttachment</span><span>(</span><span>Constants</span><span>.</span>VERSION_KEY<span>,</span> version<span>)</span><span>;</span>\n        \n        <span>ExchangeClient</span> currentClient<span>;</span>\n        <span>if</span> <span>(</span>clients<span>.</span>length <span>==</span> <span>1</span><span>)</span> <span>{</span>\n            currentClient <span>=</span> clients<span>[</span><span>0</span><span>]</span><span>;</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            currentClient <span>=</span> clients<span>[</span>index<span>.</span><span>getAndIncrement</span><span>(</span><span>)</span> <span>%</span> clients<span>.</span>length<span>]</span><span>;</span>\n        <span>}</span>\n        <span>try</span> <span>{</span>\n            <span>boolean</span> isAsync <span>=</span> <span>RpcUtils</span><span>.</span><span>isAsync</span><span>(</span><span>getUrl</span><span>(</span><span>)</span><span>,</span> invocation<span>)</span><span>;</span>\n            <span>boolean</span> isOneway <span>=</span> <span>RpcUtils</span><span>.</span><span>isOneway</span><span>(</span><span>getUrl</span><span>(</span><span>)</span><span>,</span> invocation<span>)</span><span>;</span>\n            <span>int</span> timeout <span>=</span> <span>getUrl</span><span>(</span><span>)</span><span>.</span><span>getMethodParameter</span><span>(</span>methodName<span>,</span> <span>Constants</span><span>.</span>TIMEOUT_KEY<span>,</span><span>Constants</span><span>.</span>DEFAULT_TIMEOUT<span>)</span><span>;</span>\n            <span>if</span> <span>(</span>isOneway<span>)</span> <span>{</span>\n            \t<span>boolean</span> isSent <span>=</span> <span>getUrl</span><span>(</span><span>)</span><span>.</span><span>getMethodParameter</span><span>(</span>methodName<span>,</span> <span>Constants</span><span>.</span>SENT_KEY<span>,</span> <span>false</span><span>)</span><span>;</span>\n                currentClient<span>.</span><span>send</span><span>(</span>inv<span>,</span> isSent<span>)</span><span>;</span>\n                <span>RpcContext</span><span>.</span><span>getContext</span><span>(</span><span>)</span><span>.</span><span>setFuture</span><span>(</span><span>null</span><span>)</span><span>;</span>\n                <span>return</span> <span>new</span> <span>RpcResult</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span> <span>else</span> <span>if</span> <span>(</span>isAsync<span>)</span> <span>{</span>\n            \t<span>ResponseFuture</span> future <span>=</span> currentClient<span>.</span><span>request</span><span>(</span>inv<span>,</span> timeout<span>)</span> <span>;</span>\n                <span>RpcContext</span><span>.</span><span>getContext</span><span>(</span><span>)</span><span>.</span><span>setFuture</span><span>(</span><span>new</span> <span>FutureAdapter</span><span><span>&lt;</span><span>Object</span><span>></span></span><span>(</span>future<span>)</span><span>)</span><span>;</span>\n                <span>return</span> <span>new</span> <span>RpcResult</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span> <span>else</span> <span>{</span>\n            \t<span>RpcContext</span><span>.</span><span>getContext</span><span>(</span><span>)</span><span>.</span><span>setFuture</span><span>(</span><span>null</span><span>)</span><span>;</span>\n                <span>return</span> <span>(</span><span>Result</span><span>)</span> currentClient<span>.</span><span>request</span><span>(</span>inv<span>,</span> timeout<span>)</span><span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>TimeoutException</span> e<span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>RpcException</span><span>(</span><span>RpcException</span><span>.</span>TIMEOUT_EXCEPTION<span>,</span> <span>\"Invoke remote method timeout. method: \"</span> <span>+</span> invocation<span>.</span><span>getMethodName</span><span>(</span><span>)</span> <span>+</span> <span>\", provider: \"</span> <span>+</span> <span>getUrl</span><span>(</span><span>)</span> <span>+</span> <span>\", cause: \"</span> <span>+</span> e<span>.</span><span>getMessage</span><span>(</span><span>)</span><span>,</span> e<span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>RemotingException</span> e<span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>RpcException</span><span>(</span><span>RpcException</span><span>.</span>NETWORK_EXCEPTION<span>,</span> <span>\"Failed to invoke remote method: \"</span> <span>+</span> invocation<span>.</span><span>getMethodName</span><span>(</span><span>)</span> <span>+</span> <span>\", provider: \"</span> <span>+</span> <span>getUrl</span><span>(</span><span>)</span> <span>+</span> <span>\", cause: \"</span> <span>+</span> e<span>.</span><span>getMessage</span><span>(</span><span>)</span><span>,</span> e<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n    \n    <span>@Override</span>\n    <span>public</span> <span>boolean</span> <span>isAvailable</span><span>(</span><span>)</span> <span>{</span>\n        <span>if</span> <span>(</span><span>!</span><span>super</span><span>.</span><span>isAvailable</span><span>(</span><span>)</span><span>)</span>\n            <span>return</span> <span>false</span><span>;</span>\n        <span>for</span> <span>(</span><span>ExchangeClient</span> client <span>:</span> clients<span>)</span><span>{</span>\n            <span>if</span> <span>(</span>client<span>.</span><span>isConnected</span><span>(</span><span>)</span> <span>&amp;&amp;</span> <span>!</span>client<span>.</span><span>hasAttribute</span><span>(</span><span>Constants</span><span>.</span>CHANNEL_ATTRIBUTE_READONLY_KEY<span>)</span><span>)</span><span>{</span>\n                <span>//cannot write == not Available ?</span>\n                <span>return</span> <span>true</span> <span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> <span>false</span><span>;</span>\n    <span>}</span>\n\n  \n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br></div></div><h2 id=\"三、总结\"> 三、总结</h2>\n<p>在前文的基础上,客户端的代码算是比较简单的。主要是集群容错和负载均衡、路由。</p>\n<p>主要是利用代理来实现的。</p>\n<p>最后求关注,求订阅,谢谢你的阅读!</p>\n<p>下一篇会讲,dubbo如何与Spring进行整合。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589360371000.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1597062241000.png",
      "date_published": "2022-08-22T01:35:49.000Z",
      "date_modified": "2022-08-22T01:35:49.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "java"
      ]
    },
    {
      "title": "成熟的线程要懂得拒绝",
      "url": "https://java.springlearn.cn/learn/java/%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5/",
      "id": "https://java.springlearn.cn/learn/java/%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n<h1 id=\"拒绝策略\"> 拒绝策略</h1>\n<p><strong>拒绝策略就是任务实在是已经执行不了，那么就需要你告诉程序，怎么样去拒绝在执行其他任务</strong></p>\n<p>在实际开发场景中，基本使用JDK自带的策略就可以完成日常开发，但是作为程序员必须要知道。下面说一下JDK自带有哪些线程策略</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>RejectedExecutionHandler</span> <span>{</span>\n    <span>void</span> <span>rejectedExecution</span><span>(</span><span>Runnable</span> r<span>,</span> <span>ThreadPoolExecutor</span> executor<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h1 id=\"四种拒绝策略\"> 四种拒绝策略</h1>\n<blockquote>\n<p>ThreadPoolExecutor类里面是内置了4中拒绝策略，我们一个一个来分析</p>\n</blockquote>\n<h2 id=\"_1-callerrunspolicy\"> 1. CallerRunsPolicy</h2>\n<p>直接执行该任务，如果线程池已经关闭，就不运行</p>\n<div><pre><code>    <span>public</span> <span>static</span> <span>class</span> <span>CallerRunsPolicy</span> <span>implements</span> <span>RejectedExecutionHandler</span> <span>{</span>\n        <span>public</span> <span>CallerRunsPolicy</span><span>(</span><span>)</span> <span>{</span> <span>}</span>\n        <span>public</span> <span>void</span> <span>rejectedExecution</span><span>(</span><span>Runnable</span> r<span>,</span> <span>ThreadPoolExecutor</span> e<span>)</span> <span>{</span>\n            <span>if</span> <span>(</span><span>!</span>e<span>.</span><span>isShutdown</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n                r<span>.</span><span>run</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id=\"_2-abortpolicy-【默认策略】\"> 2. AbortPolicy 【默认策略】</h2>\n<p>直接报异常，简单粗暴</p>\n<div><pre><code><span>public</span> <span>static</span> <span>class</span> <span>AbortPolicy</span> <span>implements</span> <span>RejectedExecutionHandler</span> <span>{</span>\n        <span>public</span> <span>AbortPolicy</span><span>(</span><span>)</span> <span>{</span> <span>}</span>\n        <span>public</span> <span>void</span> <span>rejectedExecution</span><span>(</span><span>Runnable</span> r<span>,</span> <span>ThreadPoolExecutor</span> e<span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>RejectedExecutionException</span><span>(</span><span>\"Task \"</span> <span>+</span> r<span>.</span><span>toString</span><span>(</span><span>)</span> <span>+</span>\n                                                 <span>\" rejected from \"</span> <span>+</span>\n                                                 e<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id=\"_3-discardpolicy\"> 3. DiscardPolicy</h2>\n<p>直接丢弃，不记录任何信息</p>\n<div><pre><code> <span>public</span> <span>static</span> <span>class</span> <span>DiscardPolicy</span> <span>implements</span> <span>RejectedExecutionHandler</span> <span>{</span>\n        <span>public</span> <span>DiscardPolicy</span><span>(</span><span>)</span> <span>{</span> <span>}</span>\n        <span>public</span> <span>void</span> <span>rejectedExecution</span><span>(</span><span>Runnable</span> r<span>,</span> <span>ThreadPoolExecutor</span> e<span>)</span> <span>{</span>\n        <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"_4-discardoldestpolicy\"> 4. DiscardOldestPolicy</h2>\n<p>丢弃一个老任务，然后执行当前任务</p>\n<div><pre><code><span>public</span> <span>static</span> <span>class</span> <span>DiscardOldestPolicy</span> <span>implements</span> <span>RejectedExecutionHandler</span> <span>{</span>\n        <span>public</span> <span>DiscardOldestPolicy</span><span>(</span><span>)</span> <span>{</span> <span>}</span>\n        <span>public</span> <span>void</span> <span>rejectedExecution</span><span>(</span><span>Runnable</span> r<span>,</span> <span>ThreadPoolExecutor</span> e<span>)</span> <span>{</span>\n            <span>if</span> <span>(</span><span>!</span>e<span>.</span><span>isShutdown</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n\t\t\t\t<span>// Retrieves and removes the head of this queue 移出最头任务，也就是老任务</span>\n                e<span>.</span><span>getQueue</span><span>(</span><span>)</span><span>.</span><span>poll</span><span>(</span><span>)</span><span>;</span>\n                e<span>.</span><span>execute</span><span>(</span>r<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h1 id=\"分析\"> 分析</h1>\n<p>拒绝策略其实很简单，知己知彼百战百胜，在多线程多任务编程场景下，我们可以根据业务特性定义拒绝策略。\n比如，在任务满的情况将，任务放到数据库中，或者打印到特殊的日志中，用来恢复任务。</p>\n<p>最后求关注,求订阅,谢谢你的阅读!</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589360371000.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png",
      "date_published": "2021-12-25T09:26:08.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Java进阶"
      ]
    },
    {
      "title": "给线程归归类",
      "url": "https://java.springlearn.cn/learn/java/%E7%BA%BF%E7%A8%8B%E7%BB%84/",
      "id": "https://java.springlearn.cn/learn/java/%E7%BA%BF%E7%A8%8B%E7%BB%84/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n<h1 id=\"线程组\"> 线程组</h1>\n<p>可以把线程归属到某一个线程组中，线程组中可以有线程对象，也可以有线程组，组中还可以有线程，这样的组织结构有点类似于树的形式，如图所示.</p>\n<p>线程组的作用是：可以批量管理线程或线程组对象，有效地对线程或线程组对象进行组织\n<img src=\"https://img.springlearn.cn/blog/learn_1599301362000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>线程组提供对组内的线程的管理能力,如我们可以用一个线程组里面的线程去执行任务,任何一个任务失败,就把所有组内的线程都给中断。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>MThreadGroup</span> <span>extends</span> <span>ThreadGroup</span> <span>{</span>\n    <span>public</span> <span>MThreadGroup</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>\n        <span>super</span><span>(</span>s<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>MThreadGroup</span><span>(</span><span>ThreadGroup</span> threadGroup<span>,</span> <span>String</span> s<span>)</span> <span>{</span>\n        <span>super</span><span>(</span>threadGroup<span>,</span> s<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>uncaughtException</span><span>(</span><span>Thread</span> thread<span>,</span> <span>Throwable</span> throwable<span>)</span> <span>{</span>\n        <span>//任何一个线程异常就讲所有组内的线程中断</span>\n        thread<span>.</span><span>getThreadGroup</span><span>(</span><span>)</span><span>.</span><span>interrupt</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div>",
      "image": "https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png",
      "date_published": "2021-12-25T09:26:08.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Java进阶"
      ]
    },
    {
      "title": "委派双亲之类加载器",
      "url": "https://java.springlearn.cn/learn/java/%E5%A7%94%E6%B4%BE%E5%8F%8C%E4%BA%B2%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/",
      "id": "https://java.springlearn.cn/learn/java/%E5%A7%94%E6%B4%BE%E5%8F%8C%E4%BA%B2%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/learn_1589811713000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n<ul>\n<li>BootStrap ClassLoader：称为启动类加载器，是Java类加载层次中最顶层的类加载器，负责加载JDK中的核心类库，如：rt.jar、resources.jar、charsets.jar等，可通过如下程序获得该类加载器从哪些地方加载了相关的jar或class文件：</li>\n<li>Extension ClassLoader：称为扩展类加载器，负责加载Java的扩展类库，默认加载JAVA_HOME/jre/lib/ext/目下的所有jar。</li>\n<li>App ClassLoader：称为系统类加载器，负责加载应用程序classpath目录下的所有jar和class文件。</li>\n</ul>\n<h2 id=\"一、类加载器\"> 一、类加载器</h2>\n<p>类的加载在JVM的外部实现。对于任意的一个类，都必须由加载它的类加载器和这个类本身共同确立其在Java虚拟机中的唯一性。JVM提供中类加载器。</p>\n<h2 id=\"二、启动类加载器-bootstrap-classloader\"> 二、启动类加载器（Bootstrap ClassLoader）</h2>\n<p>负责加载 JAVA_HOME\\lib 目录中的，或通过-Xbootclasspath 参数指定路径中的，且被 虚拟机认可（按文件名识别，如 rt.jar）的类。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589811324000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"三、扩展类加载器-extension-classloader\"> 三、扩展类加载器(Extension ClassLoader)</h2>\n<p>负责加载 JAVA_HOME\\lib\\ext 目录中的，或通过 java.ext.dirs 系统变量指定路径中的类 库。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589811366000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"四、应用程序类加载器-application-classloader\"> 四、应用程序类加载器(Application ClassLoader)</h2>\n<p>负责加载用户路径（classpath）上的类库。 JVM 通过双亲委派模型进行类的加载，当然我们也可以通过继承 java.lang.ClassLoader 实现自定义的类加载器。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589811400000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"五、原理解释\"> 五、原理解释</h2>\n<p>ClassLoader使用的是双亲委托模型来搜索类的，每个ClassLoader实例都有一个父类加载器的引用（不是继承的关系，是一个包含的关系），虚拟机内置的类加载器（Bootstrap ClassLoader）本身没有父类加载器，但可以用作其它ClassLoader实例的的父类加载器。当一个ClassLoader实例需要加载某个类时，它会试图亲自搜索某个类之前，先把这个任务委托给它的父类加载器，这个过程是由上至下依次检查的，首先由最顶层的类加载器Bootstrap ClassLoader试图加载，如果没加载到，则把任务转交给Extension ClassLoader试图加载，如果也没加载到，则转交给App ClassLoader 进行加载，如果它也没有加载得到的话，则返回给委托的发起者，由它到指定的文件系统或网络等URL中加载该类。如果它们都没有加载到这个类时，则抛出ClassNotFoundException异常。否则将这个找到的类生成一个类的定义，并将它加载到内存当中，最后返回这个类在内存中的Class实例对象。</p>\n<h2 id=\"六、为什么要使用双亲委托这种模型呢\"> 六、为什么要使用双亲委托这种模型呢？</h2>\n<p>因为这样可以避免重复加载，当父亲已经加载了该类的时候，就没有必要子ClassLoader再加载一次。考虑到安全因素，我们试想一下，如果不使用这种委托模式，那我们就可以随时使用自定义的String来动态替代java核心api中定义的类型，这样会存在非常大的安全隐患，而双亲委托的方式，就可以避免这种情况，因为String已经在启动时就被引导类加载器（Bootstrcp ClassLoader）加载，所以用户自定义的ClassLoader永远也无法加载一个自己写的String，除非你改变JDK中ClassLoader搜索类的默认算法。</p>\n<h2 id=\"七、但是jvm在搜索类的时候-又是如何判定两个class是相同的呢\"> 七、但是JVM在搜索类的时候，又是如何判定两个class是相同的呢？</h2>\n<p>JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。只有两者同时满足的情况下，JVM才认为这两个class是相同的。就算两个class是同一份class字节码，如果被两个不同的ClassLoader实例所加载，JVM也会认为它们是两个不同class。</p>\n<div><pre><code> /**\n         * rt目录:\n         * 加载rt.jar的类加载器\n         */\n        ClassLoader rtClassLoader = StringBuffer.class.getClassLoader();\n        System.out.println(rtClassLoader);\n\n        /**\n         * lib/ext扩展包\n         * sun.misc.Launcher$ExtClassLoader@67b6d4ae\n         */\n        ClassLoader extClassLoader = EventID.class.getClassLoader();\n        System.out.println(extClassLoader);\n\n        /**\n         * 当前应用加载器\n         * sun.misc.Launcher$AppClassLoader@33909752\n         */\n        ClassLoader classLoader = BaseSyntaxTest.class.getClassLoader();\n        System.out.println(classLoader);\n\n        /**\n         * sun.misc.Launcher$AppClassLoader@33909752\n         */\n        ClassLoader currentClassLoader = Thread.currentThread().getContextClassLoader();\n        System.out.println(currentClassLoader);\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>最后求关注,求订阅,谢谢你的阅读!</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589360371000.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1589811713000.png",
      "date_published": "2021-12-25T09:26:08.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Java进阶"
      ]
    },
    {
      "title": "Java异常体系",
      "url": "https://java.springlearn.cn/learn/java2/Java%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/",
      "id": "https://java.springlearn.cn/learn/java2/Java%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/learn_1589293715000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>知己知彼方能百战不殆,在小编初学Java时候特别怕程序报异常,经常会因为异常不知所措,相信这个问题应该是所有\n初学者都会有的心理感受;如果你也有这种感受,那么只有一种解决方法:\n迎难而上,攻克Java异常体系,长痛不如短痛,只要清楚了Java的异常体系,就不会再有这种感受了。下面跟着小编来窥探Java的异常体系吧。</p>\n<h1 id=\"一、java异常体系其实很简单\"> 一、Java异常体系其实很简单</h1>\n<p>其实Java的异常体系是非常简单的,简单到只要你看过本文就能明白百分之八九十的样子。当你清楚了Java的异常体系\n那么在遇到项目执行异常的时候,基本看报错的异常就大概明白问题出在哪里,遇到的错误多了,就成长了,处理的问题就是\n你未来在技术路上所积累的财富。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589294764000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>在Java的异常体系中 <code>Throwable</code> 我们可以理解为是一个根异常,即所有的异常都是它的子类</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589295509000.png\" alt=\"\" loading=\"lazy\"></p>\n<h1 id=\"二、error\"> 二、Error</h1>\n<p>前面我们说了Java的异常体系中 <code>Throwable</code> 可以理解是一个根异常,那么 <code>Error</code> 就是这个根节点的一个子节点。\n<code>Error</code> 类对象由 <code>Java</code> 虚拟机生成并抛出，大多数错误与代码编写者所执行的操作无关。程序无法处理的异常，一般伴随者jvm虚拟机停止，或者断电之类\n这种问题，是无法通过程序来解决的。</p>\n<p><strong>这种异常基本很少,如果遇到也不要慌,跟你的业务逻辑没有关系,顶多是Java代码写的有问题,只要不是业务问题其实大多都能先通过重启解决;\n但是假如项目还未上线,只是在开发过程中出现这种问题一定要弄清楚原因,是那一部分代码编写异常导致的,否则上线可能有重大隐患</strong></p>\n<p><strong>经验教学:</strong></p>\n<ol>\n<li>如果是在项目系统过程中遇到这种问题,可能是因为Jar包冲突导致的。</li>\n<li>如果是在项目运行过程中遇到这种问题,可能是因为对象创建过多没有释放,导致堆栈溢出。这个时候就要看GC是否频繁,然后对堆栈日志进行分析,看存在最多的对象是哪一个,然后分析代码解决。</li>\n</ol>\n<h1 id=\"三、exception\"> 三、Exception</h1>\n<p><code>Exception</code> 异常时我们平时在开发中遇到最多，其实 <code>Exception</code> 也分为两种即:</p>\n<ol>\n<li><code>checkException</code> 编译异常，这种异常，是哪些没有遵守java语言规则，容易看出和解决的</li>\n<li><code>uncheckException</code> 运行异常，运行异常，具有不确定性，往往难以排查，包括处理逻辑问题。</li>\n</ol>\n<p>然而 <code>checkException</code> 和 <code>uncheckException</code> 其实只是一个概念,并没有对应的 <code>Java异常类</code>。我们基本可以忽略\n<code>checkException</code> 因为这种异常基本现在的编译器都会给我们做了，我们在写代码时候就会实时的给我提示错误了。我们\n只用关心 <code>uncheckException</code>即可。</p>\n<p><strong>uncheckException</strong></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589297073000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><code>RuntimeException</code> + <code>Error</code> 和其子类都是属于 <code>uncheckException</code></p>\n<p>前面我们已经对 <code>Error</code> 做了说明，现在就主要来看下 <code>RuntimeException</code>。 <code>RuntimeException</code> 从名字来看就是\n运行异常,所谓运行异常就是可能在程序运行过程中发生的异常,这种异常一般是可以通过代码逻辑进行处理的。\n我们举例一个例子,我们都知道0不能作为除数。但是假如在下面这个代码中</p>\n<div><pre><code>public class Tester {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        System.out.print(&quot;请输入被除数a:&quot;);\n        int a = sc.nextInt();\n        System.out.print(&quot;请输入除数b:&quot;);\n        int b = sc.nextInt();\n        System.out.println(&quot;a/b=&quot; + a / b);\n    }\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>当输入a=8,b=2,那么结果就是4。</p>\n<p><img src=\"https://i02piccdn.sogoucdn.com/8206a4441e0386c3\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>假如我们输入b=0呢?</strong></p>\n<p>学过数学都知道0不能做除数,程序也不运行你这么输入,但是却不能阻止你,只能通过报错的方式来告诉你。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589298143000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>那么我们就要对这个异常进行处理,当发现有这个异常就在控制台来提醒用户。那么代码就会变成这样</p>\n<div><pre><code>public class Tester {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        System.out.print(&quot;请输入被除数a:&quot;);\n        int a = sc.nextInt();\n        System.out.print(&quot;请输入除数b:&quot;);\n        int b = sc.nextInt();\n        try {\n            System.out.println(&quot;a/b=&quot; + a / b);\n        } catch (ArithmeticException ate) {\n            //对算术异常进行捕捉\n            System.err.println(&quot;0不能作为除数,请输入不为0的任意数&quot;);\n        }\n    }\n}\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>当出现算术异常直接提示: &quot;0不能作为除数,请输入不为0的任意数&quot;\n<img src=\"https://img.springlearn.cn/blog/learn_1589298261000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>那么像这种程序中无可避免会出现,且又能通过逻辑来处理的异常就是运行异常。运行异常一般都可以正常运行,只是在特定情况下会导致异常发生。\n像这面这个例子,我们只要看到 <code>ArithmeticException</code> 就知道是算术异常。所以只要我们对运行异常类有一个认识，其实就能解决大多数的程序问题了。\n下面我们来看下运行异常都要有哪些类把。</p>\n<p><img src=\"https://i03piccdn.sogoucdn.com/f960e6a461d218d2\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>只要对下面运行异常类进行熟悉了,基本就清楚掌握了Java的异常体系了</strong></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589299119000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589299523000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>以上就是常见的运行异常类,当然Java中还有很多不常见的异常类。剩下的我们就可以在日常工作中去学习了。</p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1589293715000.png",
      "date_published": "2021-12-25T09:26:08.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "hehe",
      "url": "https://java.springlearn.cn/learn/java2/",
      "id": "https://java.springlearn.cn/learn/java2/",
      "content_html": "<h1 id=\"hehe\"> hehe</h1>\n",
      "date_published": "2021-12-25T09:26:08.000Z",
      "date_modified": "2021-12-25T09:26:08.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Java管理扩展",
      "url": "https://java.springlearn.cn/learn/java/JMX/",
      "id": "https://java.springlearn.cn/learn/java/JMX/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/learn_1590919227000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n<p><strong>JMX（Java Management Extensions，即Java管理扩展）是一个为应用程序、设备、系统等植入管理功能的框架。JMX可以跨越一系列异构操作系统平台、系统体系结构和网络传输协议，灵活的开发无缝集成的系统、网络和服务管理应用。</strong></p>\n<p>前面是对JMX的介绍，那么JMX在我们日常的开发过程中，有什么实际的意义呢? 相信很多做Java开发的同学都使用过JDK自带的 jconsole 或者 jvisualvm 监控过JVM的运行情况，但不知道有没有留意过它们会有一个MBean的功能/标签，通过MBean可以看到在JVM中运行的组件的一些属性和操作。下面小编就通过一个SpringBoot应用来一探究竟。并教会你如何自定义扩展。</p>\n<h2 id=\"一、实际意义\"> 一、实际意义</h2>\n<h3 id=\"_1-启动一个springboot应用\"> 1. 启动一个SpringBoot应用</h3>\n<p>下面我们以SpringBoot应用为例子，启动一个SpringBoot项目。端口是 <code>8080</code></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1590921574000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_2-命令行打开jconsole\"> 2. 命令行打开Jconsole</h3>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1590921682000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_3-连接前面的应用\"> 3. 连接前面的应用</h3>\n<p><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlly1gfbtkkzi1bj30p00ku761.jpg\" alt=\"image-20200531184151871\" loading=\"lazy\"></p>\n<p>选中MBean标签,然后可以看到一个SpringApplication的类。shutdown是服务下线。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1590921783000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>当我们点击了shutdown方法后,应用就会自动的关闭了。导致Jconsole连接丢失\n<img src=\"https://tva1.sinaimg.cn/large/007S8ZIlly1gfbtpwfbbqj30oy0i2gof.jpg\" alt=\"image-20200531184702204\" loading=\"lazy\"></p>\n<p>getProperty方法是获取应用中的配置信息。如图我们获取redis的相关信息。可以看到返回值是Spring应用中我们定义的值\n6379</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1590921918000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/007S8ZIlly1gfbtoo8x1yj30lc07imy6.jpg\" alt=\"image-20200531184553346\" loading=\"lazy\"></p>\n<p>那么其实这个能力就是利用JMX提供的接口来实现的。下面我们通过分析SpringBoot中的源码来看他是如何实现的。</p>\n<hr>\n<h2 id=\"二、源码追踪看springboot应用如何实现\"> 二、源码追踪看SpringBoot应用如何实现?</h2>\n<p>我们通过看Jconsole工具,可以看到工具里面的类名叫SpringApplication，目录是admin，于是我们就根据这个推测SpringBoot中的命名,果然我们找到两个实现类。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1590922192000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>1. SpringApplicationAdminMXBean</strong></p>\n<p>这个类就是JMX中的MBean，我们可以简单理解这个里面的方法都是可以通过Jconsole来调用的。\n通过将这个类注册给JMX管理器就能实现在Jconsole中的数据展示。</p>\n<p>首先看<strong>SpringApplicationAdminMXBean</strong></p>\n<div><pre><code><span>public</span> <span>interface</span> <span>SpringApplicationAdminMXBean</span> <span>{</span>\n   <span>//是否可读</span>\n   <span>boolean</span> <span>isReady</span><span>(</span><span>)</span><span>;</span>\n   <span>//是否web应用</span>\n   <span>boolean</span> <span>isEmbeddedWebApplication</span><span>(</span><span>)</span><span>;</span>\n   <span>//获取配置信息</span>\n   <span>String</span> <span>getProperty</span><span>(</span><span>String</span> key<span>)</span><span>;</span>\n   <span>//下线应用</span>\n   <span>void</span> <span>shutdown</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>实现类<strong>SpringApplicationAdmin</strong>,是SpringApplicationAdminMXBeanRegistrar的内部类</p>\n<div><pre><code><span>private</span> <span>class</span> <span>SpringApplicationAdmin</span> <span>implements</span> <span>SpringApplicationAdminMXBean</span> <span>{</span>\n    <span>// 是否可读，当应用还没起来时候这个值是false</span>\n      <span>@Override</span>\n      <span>public</span> <span>boolean</span> <span>isReady</span><span>(</span><span>)</span> <span>{</span>\n         <span>return</span> <span>SpringApplicationAdminMXBeanRegistrar</span><span>.</span><span>this</span><span>.</span>ready<span>;</span>\n      <span>}</span>\n      <span>// 是否是web应用</span>\n      <span>@Override</span>\n      <span>public</span> <span>boolean</span> <span>isEmbeddedWebApplication</span><span>(</span><span>)</span> <span>{</span>\n         <span>return</span> <span>SpringApplicationAdminMXBeanRegistrar</span><span>.</span><span>this</span><span>.</span>embeddedWebApplication<span>;</span>\n      <span>}</span>\n    <span>// 从Spring的配置信息中实时读取值</span>\n      <span>@Override</span>\n      <span>public</span> <span>String</span> <span>getProperty</span><span>(</span><span>String</span> key<span>)</span> <span>{</span>\n         <span>return</span> <span>SpringApplicationAdminMXBeanRegistrar</span><span>.</span><span>this</span><span>.</span>environment<span>.</span><span>getProperty</span><span>(</span>key<span>)</span><span>;</span>\n      <span>}</span>\n    <span>// 关闭Spring应用</span>\n      <span>@Override</span>\n      <span>public</span> <span>void</span> <span>shutdown</span><span>(</span><span>)</span> <span>{</span>\n         logger<span>.</span><span>info</span><span>(</span><span>\"Application shutdown requested.\"</span><span>)</span><span>;</span>\n         <span>SpringApplicationAdminMXBeanRegistrar</span><span>.</span><span>this</span><span>.</span>applicationContext<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n      <span>}</span>\n\n   <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p><strong>2. SpringApplicationAdminMXBeanRegistrar</strong></p>\n<p>提供注册能力。这个类中我们可以知道如何注册JMX以及如何取消注册。下面我看这个类如何利用Spring提供的接口能力,来实现应用下线。及注册到JMX上的吧。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1590922871000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>自动化配置将SpringApplicationAdminMXBeanRegistrar声明成一个Spring中的Bean对象。并配置JMX中的命名及目录。\n<img src=\"https://img.springlearn.cn/blog/learn_1590923451000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_1-applicationcontextaware\"> 1. ApplicationContextAware</h3>\n<p>获得读取上下文能力。在Spring容器中一个bean如何实现了该方法则就可以获取上下文对象。</p>\n<div><pre><code>   @Override\n   public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n      Assert.state(applicationContext instanceof ConfigurableApplicationContext,\n            &quot;ApplicationContext does not implement ConfigurableApplicationContext&quot;);\n      this.applicationContext = (ConfigurableApplicationContext) applicationContext;\n   }\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id=\"_2-genericapplicationlistener\"> 2. GenericApplicationListener</h3>\n<p>获取处理事件的能力,同样在Spring中只要实现该接口,就获取了事件监听的能力,不过具体监听什么事件要自己去判断。大家可以根据例子\n来理解。</p>\n<div><pre><code>  // 根据事件泛型判断是否需要处理，这里判断如果是ApplicationReadyEvent和WebServerInitializedEvent\n  // 事件就处理\n  @Override\n   public boolean supportsEventType(ResolvableType eventType) {\n      Class&lt;?&gt; type = eventType.getRawClass();\n      if (type == null) {\n         return false;\n      }\n      return ApplicationReadyEvent.class.isAssignableFrom(type)\n            || WebServerInitializedEvent.class.isAssignableFrom(type);\n   }\n\n   @Override\n   public boolean supportsSourceType(Class&lt;?&gt; sourceType) {\n      return true;\n   }\n\n   @Override\n   public void onApplicationEvent(ApplicationEvent event) {\n    // 如果Spring已经准备好了,就将this.ready = true;\n      if (event instanceof ApplicationReadyEvent) {\n         onApplicationReadyEvent((ApplicationReadyEvent) event);\n      }\n    // 如果是Web应用,this.embeddedWebApplication = true\n      if (event instanceof WebServerInitializedEvent) {\n         onWebServerInitializedEvent((WebServerInitializedEvent) event);\n      }\n   }\n   //优先级\n   @Override\n   public int getOrder() {\n      return Ordered.HIGHEST_PRECEDENCE;\n   }\n\n   void onApplicationReadyEvent(ApplicationReadyEvent event) {\n      if (this.applicationContext.equals(event.getApplicationContext())) {\n         this.ready = true;\n      }\n   }\n\n   void onWebServerInitializedEvent(WebServerInitializedEvent event) {\n      if (this.applicationContext.equals(event.getApplicationContext())) {\n         this.embeddedWebApplication = true;\n      }\n   }\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br></div></div><h3 id=\"_3-environmentaware\"> 3. EnvironmentAware</h3>\n<p>获取应用配置信息, 和上面一样实现了Aware结尾的接口,都能获取对象的Spring内容的对象实例，然后我们就可以根据该实例,来进行功能扩展。</p>\n<div><pre><code>@Override\n   public void setEnvironment(Environment environment) {\n      this.environment = environment;\n   }\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"_4-initializingbean\"> 4. InitializingBean</h3>\n<p>这里就要着重看了，在初始化时候将MBean注册到JMX上。当然我们可以通过 @PostConstruct注解来声明初始化方法。</p>\n<div><pre><code>@Override\n   public void afterPropertiesSet() throws Exception {\n      MBeanServer server = ManagementFactory.getPlatformMBeanServer();\n      server.registerMBean(new SpringApplicationAdmin(), this.objectName);\n      if (logger.isDebugEnabled()) {\n         logger.debug(&quot;Application Admin MBean registered with name &#39;&quot; + this.objectName + &quot;&#39;&quot;);\n      }\n   }\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id=\"_5-disposablebean\"> 5. DisposableBean</h3>\n<p>应用销毁时候,取消注册。同样我们也可以用@PreDestroy注解来实现</p>\n<div><pre><code>@Override\n   public void destroy() throws Exception {\n      ManagementFactory.getPlatformMBeanServer().unregisterMBean(this.objectName);\n   }\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>通过对SpringBoot应用源码的追踪，我们大概已经明白JMX的实际意义了，并且能自定义一个能提供类似能力的MBean了吧，但是JMX能做的远远不止如此。</p>\n<h2 id=\"三、自定义mbean\"> 三、自定义MBean</h2>\n<p>注意接口名必须是MBean结尾，实现类必须去掉MBean</p>\n<p>如CustomMBean接口对应的实现类必须是Custom。</p>\n<h3 id=\"_1-代码实现\"> 1. 代码实现</h3>\n<div><pre><code><span>@Component</span>\n<span>public</span> <span>class</span> <span>CustomMbeanRegistrar</span> <span>implements</span> <span>ApplicationContextAware</span><span>,</span> <span>InitializingBean</span><span>,</span> <span>DisposableBean</span> <span>{</span>\n    <span>private</span> <span>ConfigurableApplicationContext</span> applicationContext<span>;</span>\n    <span>private</span> <span>ObjectName</span> objectName <span>=</span> <span>new</span> <span>ObjectName</span><span>(</span><span>\"com.example.demo:type=CustomAdmin,name=CustomMXBean\"</span><span>)</span><span>;</span>\n\n    <span>public</span> <span>CustomMbeanRegistrar</span><span>(</span><span>)</span> <span>throws</span> <span>MalformedObjectNameException</span> <span>{</span>\n    <span>}</span>\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>destroy</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>ManagementFactory</span><span>.</span><span>getPlatformMBeanServer</span><span>(</span><span>)</span><span>.</span><span>unregisterMBean</span><span>(</span><span>this</span><span>.</span>objectName<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>afterPropertiesSet</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>MBeanServer</span> server <span>=</span> <span>ManagementFactory</span><span>.</span><span>getPlatformMBeanServer</span><span>(</span><span>)</span><span>;</span>\n        server<span>.</span><span>registerMBean</span><span>(</span><span>new</span> <span>Custom</span><span>(</span><span>)</span><span>,</span> <span>this</span><span>.</span>objectName<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>setApplicationContext</span><span>(</span><span>ApplicationContext</span> applicationContext<span>)</span> <span>throws</span> <span>BeansException</span> <span>{</span>\n        <span>this</span><span>.</span>applicationContext <span>=</span> <span>(</span><span>ConfigurableApplicationContext</span><span>)</span> applicationContext<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>interface</span> <span>CustomMBean</span> <span>{</span>\n        <span>int</span> <span>getDatabaseConnectionPoolSize</span><span>(</span><span>)</span><span>;</span>\n        <span>void</span> <span>customShutdown</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>private</span> <span>class</span> <span>Custom</span> <span>implements</span> <span>CustomMBean</span> <span>{</span>\n\n        <span>/**\n         * 获取数据库连接池大小\n         *\n         * @return 模拟\n         */</span>\n        <span>@Override</span>\n        <span>public</span> <span>int</span> <span>getDatabaseConnectionPoolSize</span><span>(</span><span>)</span> <span>{</span>\n            <span>return</span> <span>new</span> <span>Random</span><span>(</span><span>)</span><span>.</span><span>nextInt</span><span>(</span><span>100</span><span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>/**\n         * 自定义一个销毁方法\n         */</span>\n        <span>public</span> <span>void</span> <span>customShutdown</span><span>(</span><span>)</span> <span>{</span>\n            <span>CustomMbeanRegistrar</span><span>.</span><span>this</span><span>.</span>applicationContext<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br></div></div><h3 id=\"_2-演示\"> 2. 演示</h3>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1590924584000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"四、总结\"> 四、总结</h2>\n<p>通过前面的演示,大概我们对JMX在实际中的用处有一个大概的了解了吧。根据这个特性,我们就可以根据我们的需求来定制属于自己的能力。</p>\n<p>最后求关注,求订阅,谢谢你的阅读!</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589360371000.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1590919227000.png",
      "date_published": "2021-12-25T09:26:08.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Java进阶"
      ]
    },
    {
      "title": "函数式编程",
      "url": "https://java.springlearn.cn/learn/java2/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/",
      "id": "https://java.springlearn.cn/learn/java2/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/",
      "content_html": "<div><p>提示</p>\n<p>Java8所有的新特性基本基于函数式编程的思想，函数式编程给Java带来了注入了新鲜的活力。\n函数式编程其实并不是很难，小编在学习函数式编程时候刚开始一头雾水，最后仔细观察就发现了其中的小窍门，读了本篇文章如果还没有掌握，就算我输了\n加我微信: lxchinesszz 找我一对一教学</p>\n</div>\n<h1 id=\"函数式编程\"> 函数式编程</h1>\n<h2 id=\"一、lambda表达式\"> 一、Lambda表达式</h2>\n<p><strong>注意</strong>: 以下方法都可以使用表达式来进行缩写</p>\n<p>我们来看Java中如何来定义一个方法</p>\n<h3 id=\"_1-语法\"> 1. 语法</h3>\n<p><code>()-&gt;{}</code></p>\n<p>其中小括号里面可以放入参，大括号就是方法体，里面也允许有返回值。</p>\n<p><strong>当方法体中只有返回值而没有其他语句时候，大括号和 <code>return</code> 关键字都可以省略不写。</strong></p>\n<h3 id=\"_2-方法引用\"> 2. 方法引用</h3>\n<p><em>只要用.引用不报错的，都可以将.换成:</em></p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>语法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1、引用静态方法</td>\n<td>ClassName::staticMethodName</td>\n</tr>\n<tr>\n<td>2、引用构造函数</td>\n<td>ClassName::new</td>\n</tr>\n<tr>\n<td>3、引用特定类型的实例方法</td>\n<td>ClassName::instanceMethodName</td>\n</tr>\n<tr>\n<td>4、引用特定对象的实例方法</td>\n<td>objectName::instanceMethodName</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"二、java8新增函数式接口\"> 二、Java8新增函数式接口</h2>\n<h3 id=\"_1-predicate接口\"> 1. Predicate接口</h3>\n<p>Predicate 接口只有一个参数，返回boolean类型。该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）</p>\n<div><pre><code>Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; 0;\n</code></pre>\n<div><span>1</span><br></div></div><p>根据前面的语法我们知道小括号里面可以放入参，大括号里面放出参，当大括号里面只有返回值时候，大括号和 <code>return</code> 关键字也可以省略。如上。</p>\n<h3 id=\"_2-function-接口\"> 2. Function 接口</h3>\n<p>Function 接口有一个参数并且返回一个结果，并附带了一些可以和其他函数组合的默认方法（compose, andThen）：</p>\n<div><pre><code>Function&lt;Integer, Integer&gt; function = (x) -&gt; 2 * x;\n</code></pre>\n<div><span>1</span><br></div></div><p>同理，这个接口有一个入参和出参，如果返回体重不包含其他逻辑，只有一个返回值，大括号和 <code>return</code> 关键字也可以省略。如上。</p>\n<h3 id=\"_3-supplier-接口\"> 3. Supplier 接口</h3>\n<p>Supplier 接口返回一个任意范型的值，和Function接口不同的是该接口没有任何参数</p>\n<div><pre><code>public class Main{\n    public static void main(String[] args) {\n        //构造方法\n        Supplier&lt;Main&gt; supplier = () -&gt; new Main();\n        Supplier&lt;Main&gt; mainSupplier = Main::new;\n        Supplier&lt;Main&gt; mainSupplier1 = Main::staticMethod;\n    }\n    private static Main staticMethod() {\n        return new Main();\n    }\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>因为没有入参，所以小括号里面什么都不用写。当遇到这种情况，同样可以用上面其他两种来替换</p>\n<h3 id=\"_4-consumer-接口\"> 4. Consumer 接口</h3>\n<p>Consumer 是一个只有入参，但是无出参的接口。</p>\n<div><pre><code>public class Main {\n    public static void main(String[] args) {\n        List&lt;String&gt; dataList = Arrays.asList(&quot;1&quot;, &quot;2&quot;);\n\n        //特定类的静态方法\n        dataList.forEach(Main::staticMethod);\n        dataList.forEach((x) -&gt; System.out.println(x));\n        dataList.forEach(System.out::println);\n\n    }\n    private static void staticMethod(String name) {\n        System.out.println(&quot;对象静态方法引用:&quot; + name);\n    }\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h2 id=\"三、快速记忆\"> 三、快速记忆</h2>\n<p>虽然新增的函数式接口并不多，但是想要一次性死记住，还是有一点点的难度。小编的学习方式是\n理解这记忆。</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>简记</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1、Predicate</td>\n<td>条件类型</td>\n</tr>\n<tr>\n<td>2、Supplier</td>\n<td>无入参，有出参</td>\n</tr>\n<tr>\n<td>3、Function</td>\n<td>有入参，有出参</td>\n</tr>\n<tr>\n<td>4、Consumer</td>\n<td>有入参，无出参</td>\n</tr>\n</tbody>\n</table>\n<p>最后求关注,求订阅,谢谢你的阅读!</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1589360371000.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1589360371000.png",
      "date_published": "2021-12-25T09:26:08.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "线程池扫盲",
      "url": "https://java.springlearn.cn/learn/java/%E7%BA%BF%E7%A8%8B%E6%B1%A0/",
      "id": "https://java.springlearn.cn/learn/java/%E7%BA%BF%E7%A8%8B%E6%B1%A0/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n<blockquote>\n<p>[!TIP]\n本篇文章通读时间大概3分钟,希望在三分钟内的讲解，对你有所帮助，\n一定要认真看并思考，好了。废话不多数，直接上干货,本节内容我们讲\n的是Java的线程池,在讲之前我们首先看一下有哪些线程池，这些线程池\n我们不过多讲解,因为我们的关注点是他们是如何实现的,和其运行的原理。</p>\n</blockquote>\n<h1 id=\"一、常用线程池列表\"> 一、常用线程池列表</h1>\n<p>这部分内容,只是帮助你回顾一下线程池的知识，大家重点看方法内的实现</p>\n<p>1、构造一个固定线程数目的线程池，配置的corePoolSize与maximumPoolSize大小相同，同时使用了一个无界LinkedBlockingQueue存放阻塞任务，因此多余的任务将存在再阻塞队列，不会由RejectedExecutionHandler处理</p>\n<div><pre><code>    <span>public</span> <span>static</span> <span>ExecutorService</span> <span>newFixedThreadPool</span><span>(</span><span>int</span> nThreads<span>)</span> <span>{</span>\n        <span>return</span> <span>new</span> <span>ThreadPoolExecutor</span><span>(</span>nThreads<span>,</span> nThreads<span>,</span>\n                                      <span>0L</span><span>,</span> <span>TimeUnit</span><span>.</span>MILLISECONDS<span>,</span>\n                                      <span>new</span> <span>LinkedBlockingQueue</span><span><span>&lt;</span><span>Runnable</span><span>></span></span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>2、构造一个缓冲功能的线程池，配置corePoolSize=0，maximumPoolSize=Integer.MAX_VALUE，keepAliveTime=60s,以及一个无容量的阻塞队列 SynchronousQueue，因此任务提交之后，将会创建新的线程执行；线程空闲超过60s将会销毁</p>\n<div><pre><code>    <span>public</span> <span>static</span> <span>ExecutorService</span> <span>newCachedThreadPool</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>new</span> <span>ThreadPoolExecutor</span><span>(</span><span>0</span><span>,</span> <span>Integer</span><span>.</span>MAX_VALUE<span>,</span>\n                                      <span>60L</span><span>,</span> <span>TimeUnit</span><span>.</span>SECONDS<span>,</span>\n                                      <span>new</span> <span>SynchronousQueue</span><span><span>&lt;</span><span>Runnable</span><span>></span></span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>3、构造一个只支持一个线程的线程池，配置corePoolSize=maximumPoolSize=1，无界阻塞队列LinkedBlockingQueue；保证任务由一个线程串行执行</p>\n<div><pre><code>    <span>public</span> <span>static</span> <span>ExecutorService</span> <span>newSingleThreadExecutor</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>new</span> <span>FinalizableDelegatedExecutorService</span>\n            <span>(</span><span>new</span> <span>ThreadPoolExecutor</span><span>(</span><span>1</span><span>,</span> <span>1</span><span>,</span>\n                                    <span>0L</span><span>,</span> <span>TimeUnit</span><span>.</span>MILLISECONDS<span>,</span>\n                                    <span>new</span> <span>LinkedBlockingQueue</span><span><span>&lt;</span><span>Runnable</span><span>></span></span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>4、构造有定时功能的线程池，配置corePoolSize，无界延迟阻塞队列DelayedWorkQueue；有意思的是：maximumPoolSize=Integer.MAX_VALUE，由于DelayedWorkQueue是无界队列，所以这个值是没有意义的</p>\n<div><pre><code>    <span>/**\n     * Creates a thread pool that can schedule commands to run after a\n     * given delay, or to execute periodically.\n     * @param corePoolSize the number of threads to keep in the pool,\n     * even if they are idle\n     * @return a newly created scheduled thread pool\n     * @throws IllegalArgumentException if {@code corePoolSize &lt; 0}\n     */</span>\n    <span>public</span> <span>static</span> <span>ScheduledExecutorService</span> <span>newScheduledThreadPool</span><span>(</span><span>int</span> corePoolSize<span>)</span> <span>{</span>\n        <span>return</span> <span>new</span> <span>ScheduledThreadPoolExecutor</span><span>(</span>corePoolSize<span>)</span><span>;</span>\n    <span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h1 id=\"二、threadpoolexecutor\"> 二、ThreadPoolExecutor</h1>\n<p>相信大家从上面的众多线程池中都已经看到了这个类,因为上面的线程池底层的构造都是由这个类创建的,</p>\n<p>那么我们就开始研究这个类</p>\n<div><pre><code><span>/**\n * @since 1.5\n * @author Doug Lea\n */</span>\n<span>public</span> <span>class</span> <span>ThreadPoolExecutor</span> <span>extends</span> <span>AbstractExecutorService</span> <span>{</span>\n\t<span>.</span><span>.</span><span>.</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>首先看一下构造方法，关于注释一定要好好看，每个参数都理解了，那么你就弄懂了</p>\n<div><pre><code>\n<span>/**\n     *\n     * @param corePoolSize 核心线程池大小\n     * @param maximumPoolSize 线程池最大容量\n     * @param keepAliveTime 线程池空闲时，线程存活时间\n     * @param unit 时间单位\n     * @param workQueue 工作队列\n\t * @param threadFactory 线程工厂\n     * @throws IllegalArgumentException if one of the following holds:&lt;br>\n     *         {@code corePoolSize &lt; 0}&lt;br>\n     *         {@code keepAliveTime &lt; 0}&lt;br>\n     *         {@code maximumPoolSize &lt;= 0}&lt;br>\n     *         {@code maximumPoolSize &lt; corePoolSize}\n     * @throws NullPointerException if {@code workQueue} is null\n     */</span>\n      <span>public</span> <span>ThreadPoolExecutor</span><span>(</span><span>int</span> corePoolSize<span>,</span>\n                                 <span>int</span> maximumPoolSize<span>,</span>\n                                 <span>long</span> keepAliveTime<span>,</span>\n                                 <span>TimeUnit</span> unit<span>,</span>\n                                 <span>BlockingQueue</span><span><span>&lt;</span><span>Runnable</span><span>></span></span> workQueue<span>,</span>\n                                 <span>ThreadFactory</span> threadFactory<span>)</span> <span>{</span>\n           <span>this</span><span>(</span>corePoolSize<span>,</span> maximumPoolSize<span>,</span> keepAliveTime<span>,</span> unit<span>,</span> workQueue<span>,</span>\n                threadFactory<span>,</span> defaultHandler<span>)</span><span>;</span>\n       <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h1 id=\"三、构造参数详解\"> 三、构造参数详解</h1>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>corePoolSize</td>\n<td>核心的线程数</td>\n</tr>\n<tr>\n<td>maximumPoolSize</td>\n<td>最大线程池就是说你定义的线程池运行创建的最大线程数量</td>\n</tr>\n<tr>\n<td>keepAliveTime</td>\n<td>空闲时间回收，当这个时间后还没有任务执行就将线程回收</td>\n</tr>\n<tr>\n<td>unit</td>\n<td>单位,控制上面时间的单位，可以为秒，或者分钟</td>\n</tr>\n<tr>\n<td>workQueue</td>\n<td>核心线程都已经去执行任务但是，任务还有，那么久先放到这个队列里，就相当于集合</td>\n</tr>\n<tr>\n<td>threadFactory</td>\n<td>创建线程用户的线程工厂,里面只有一个方法就是newThread，你可以自定义线程名</td>\n</tr>\n</tbody>\n</table>\n<p><font color=red>上面的文字可能你看的不太明白，小编这里画了一个图，大家仔细看看 </font></p>\n<p>这张图是小编之前画的，但是头条压缩了，导致图不太清楚，大家看到字就行了</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1640316132000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_1-执行顺序\"> 1. 执行顺序</h2>\n<ol>\n<li>首先交给核心线程数来执行corePoolSize</li>\n<li>如果核心都用完了，就放到workQueue队列里面</li>\n<li>当队列和核心线程数都满了，就继续创建线程，直到等于maximumPoolSize为止</li>\n<li>当任务已经塞不下了，就开始执行拒绝策略(下一篇讲)</li>\n</ol>\n",
      "image": "https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png",
      "date_published": "2021-12-25T09:26:08.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Java进阶"
      ]
    },
    {
      "title": "多线程之线程隔离",
      "url": "https://java.springlearn.cn/learn/java/%E7%BA%BF%E7%A8%8B%E9%9A%94%E7%A6%BB/",
      "id": "https://java.springlearn.cn/learn/java/%E7%BA%BF%E7%A8%8B%E9%9A%94%E7%A6%BB/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n<blockquote>\n<p>[!TIP]\nJava多线程之隔离技术ThreadLocal源码详解</p>\n</blockquote>\n<h1 id=\"java多线程之隔离技术threadlocal源码详解\"> Java多线程之隔离技术ThreadLocal源码详解</h1>\n<p><strong>本篇文章是对ThreadLocal和InheritableThreadLocal,TransmittableThreadLocal的原理和源码进行深入分析,并举例讲解,其中前两个是JDK自带的。原理相对比较简单,其解决了单线程环境和在单线程中又创建线程(父子线程)中线程隔离的问题, TransmittableThreadLocal主要是解决,线程池中线程复用的场景。全文涉及到源码比较多阅读起来需要动脑筋思考,文章前半部分比较简单,后半部分比较困难,注意看代码注释。有不懂的可以留言。</strong></p>\n<p><img src=\"http://p3.pstatp.com/large/pgc-image/1529412918151862e9151ba\" alt=\"\" loading=\"lazy\"></p>\n<p>以上是百度百科检索到的描述,相信通过上面的描述大家已经有了一个大概的了解,也相信大多数开发人员对这个类也是比较了解的,小编首先从原理开始讲解,开始吧!</p>\n<h2 id=\"_1-threadlocal-的原理是什么呢\"> 1. ThreadLocal 的原理是什么呢 ?</h2>\n<p>其实就相当于一个Map集合,只不过这个Map 的Key是固定的,都是当前线程。\n<strong>它能解决什么问题呢? 它存在的价值是什么呢?</strong></p>\n<ul>\n<li>它的存在就是为了线程隔离,让每个线程都能拥有属于自己的变量空间,线程之间互相不影响,为什么这么说呢? 看下代码就明白</li>\n</ul>\n<p><img src=\"http://p1.pstatp.com/large/pgc-image/15294130178426b9ba68b45\" alt=\"\" loading=\"lazy\"></p>\n<p>通过上面的代码,可以发现其实ThreadLocal的set()方法就相当于\n<img src=\"http://p3.pstatp.com/large/pgc-image/15294130624201011b98c5d\" alt=\"\" loading=\"lazy\"></p>\n<p>之所以能起到线程隔离的作用,是因为Key就是当前的线程,所以每个线程的值都是隔离的，就像上图那样。</p>\n<p>其实并不是这样简单,之所以这样讲是为了,大家理解,其实这里的核心点在getMap中,从Thread中拿到一个Map，然后把value放到这个线程的map中</p>\n<p>因为每个线程都有一个自己的Map，也就是threadLocals。从而起到了线程隔离的作用</p>\n<p><img src=\"http://p3.pstatp.com/large/pgc-image/1529413112969790858fd09\" alt=\"\" loading=\"lazy\">\n<img src=\"http://p3.pstatp.com/large/pgc-image/15294131130928909328961\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_2-根据jdk原理-自己实现一个类似的\"> 2. 根据JDK原理,自己实现一个类似的</h2>\n<p><img src=\"http://p1.pstatp.com/large/pgc-image/1529413164762e67c5cae45\" alt=\"\" loading=\"lazy\"></p>\n<p>测试用例</p>\n<p><img src=\"http://p1.pstatp.com/large/pgc-image/152941318828671381eeadc\" alt=\"\" loading=\"lazy\"></p>\n<p>Result:</p>\n<p><img src=\"http://p3.pstatp.com/large/pgc-image/1529413210711e5595823b7\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_3-单线程隔离\"> 3. 单线程隔离</h2>\n<p>什么是单线程隔离，这个是小编自己想的名字,其实是为了和父子线程区分开来，上面我们演示的都是属于在单一线程的情况下的使用。</p>\n<h2 id=\"_4-父子线程隔离\"> 4.父子线程隔离</h2>\n<p>什么是父子线程,需要解释下是，当我们创建一个线程,在线程内有去运行另一个线程的时候，作为子线程，如何去拿到父线程的私有属性呢?</p>\n<p><img src=\"http://p3.pstatp.com/large/pgc-image/15294132718636bd88455c1\" alt=\"\" loading=\"lazy\">\n<img src=\"http://p3.pstatp.com/large/pgc-image/1529413271771989993f0f7\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>我们怎么能拿到父线程的属性呢?</strong></p>\n<ul>\n<li>我们看前面标记的①,在get()时候有一个getMap(),在②有一个createMap方法\n<img src=\"http://p3.pstatp.com/large/pgc-image/1529413312687008ee8dca7\" alt=\"\" loading=\"lazy\"></li>\n</ul>\n<p>既然我们想拿到父线程的私有变量,那我们想在线程内创建线程时候,子线程能不能拿到父线程的的私有变量呢?</p>\n<p><strong>答案:当然是可以的,</strong></p>\n<p><strong>我们看Thread的源码的时候，可以找到这样两个属性</strong></p>\n<p><img src=\"http://p1.pstatp.com/large/pgc-image/152941335122800b1bf88f6\" alt=\"\" loading=\"lazy\">\n那么它是如何实现继承的呢？我们可以在Thread的构造初始化init方法中，找到答案\n<img src=\"http://p3.pstatp.com/large/pgc-image/152941349280560c1a07a41\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>看到这里我们分析，为什么ThreadLocal不能把父线程的私有变量传递给子线程?</strong></p>\n<ol>\n<li>因为getMap和createMap都是对threadLocals进行操作，而threadLocals变量是不能被继承的。</li>\n</ol>\n<p>那么我们怎么去实现能传递呢?</p>\n<p>其实JDK是为我们实现了一套的,这个类就是InheritableThreadLocal,我们看他为什么能实现呢? 在看代码前，我们先自己思考下，是不是InheritableThreadLocal操作的是可继承的字段inheritableThreadLocals呢？答案也是肯定的</p>\n<p><img src=\"http://p3.pstatp.com/large/pgc-image/15294135331813f5f2b77fd\" alt=\"\" loading=\"lazy\"></p>\n<p>在父线程内创建子线程的时候,子线程会在拿到父线程中的可继承的私有变量空间属性,也就是inheritableThreadLocals字段。</p>\n<p><strong>测试用例</strong></p>\n<p><img src=\"http://p1.pstatp.com/large/pgc-image/152941358189410391e60ee\" alt=\"\" loading=\"lazy\">\n<img src=\"http://p3.pstatp.com/large/pgc-image/1529413587585a39d62e8a9\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_5-线程池线程复用隔离\"> 5. 线程池线程复用隔离</h2>\n<p>在解决上面的问题后，我们来研究一个更有难度的问题,就是线程池线程复用的情况，怎么实现?</p>\n<p>为什么会遇到这个问题呢? 是因为在线程池中核心线程用完，并不会直接被回收,而是返回到线程池中，既然是重新利用，</p>\n<p>那么久不会重新创建线程，不会创建线程，父子之间就不会传递(如果这点没有明白,请继续看上面父子线程)。</p>\n<p>那么这时父子线程关系的ThreadLocal值传递已经没有意义。</p>\n<p>那么根据这个原理 ，我们继续来深入研究一波。</p>\n<p><img src=\"http://p3.pstatp.com/large/pgc-image/152941368203290892a2f3c\" alt=\"\" loading=\"lazy\">\n<img src=\"http://p1.pstatp.com/large/pgc-image/1529413681980c41819c3c7\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>解决方案是什么呢？</strong></p>\n<div><pre><code>在submit的时候把父线程copy给子线程\n\n在execute的时候结束后吧线程的ThreadLocal清理，就能解决这个问题\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>上面是网上搜到的答案，小编在证实上面答案的时候走了很多坑，根本没有找到清理的代码。最后小编发现,根本就没有清理的代码，而是重新赋值的形式来实现清理。</p>\n<p>到底是怎么来实现的呢？我们看TransmittableThreadLocal核心代码</p>\n<p><img src=\"http://p1.pstatp.com/large/pgc-image/15294137835549160937407\" alt=\"\" loading=\"lazy\"></p>\n<ol>\n<li>\n<p>拿到创建线程时候的备份所有线程空间 【深复制】因为浅复制会结果会被修改</p>\n</li>\n<li>\n<p>在执行时候将之前的备份恢复，将最新的值返回到backup变量中</p>\n</li>\n<li>\n<p>执行完成后，再将backup最新的值重新写入到TransmittableThreadLocal中</p>\n</li>\n</ol>\n<p>代码看起来很简洁，但是理解起来并不容易，每一步都有很多细节？我们一个一个来看</p>\n<ol>\n<li>copy方法。</li>\n</ol>\n<p>TransmittableThreadLocal内维护了一个holder保存所有TransmittableThreadLocal实例当set时候addValue方法</p>\n<p><img src=\"http://p3.pstatp.com/large/pgc-image/15294137826850f0a707402\" alt=\"\" loading=\"lazy\"></p>\n<p>如果还没添加就添加，null在这里只是占位,没有其他用，因为this就包含了所有值\n<img src=\"http://p9.pstatp.com/large/pgc-image/15294137828914b65c93dde\" alt=\"\" loading=\"lazy\"></p>\n<p>copy方法就是将holder里面维护的TransmittableThreadLocal实例和值通过深复制的形式返回，为什么是深复制,因为引用复制可能会在其他地方值被修改。</p>\n<ol start=\"2\">\n<li>\n<p>backupAndSetToCopied方法从copide中恢复数据，然后新值返回出去，放到backup变量中</p>\n</li>\n<li>\n<p>当线程已经执行完，在调用restoreBackup方法恢复backup变量中的值。</p>\n</li>\n</ol>\n<p>这点理解其他优点困难，尽管小编已经很努力的讲清楚，但是可以通过下面一个例子可以将以上几种方法的用处讲清。</p>\n<h4 id=\"请注意文中的注释\"> 请注意文中的注释!</h4>\n<p><img src=\"http://p1.pstatp.com/large/pgc-image/152941378383811d7b64d7d\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"问题\"> 问题</h3>\n<p>子线程修改变量空间值，是否会影响父线程值？</p>\n<p>答案：当然影响。因为子线程获取父线程的inheritableThreadLocals时候，方法ThreadLocal.createInheritedMap(parent.inheritableThreadLocals)其实是浅复制，也就是引用复制，其主要用途是从key.childValue，就是运行ThreadLocal的继承者，重写childValue方法，从而能改变父线程的本地空间ThreadLocal</p>\n<p><img src=\"http://p3.pstatp.com/large/pgc-image/1529413784125d263a0718c\" alt=\"\" loading=\"lazy\">\n<img src=\"http://p9.pstatp.com/large/pgc-image/15294137837064b50ac393d\" alt=\"\" loading=\"lazy\"></p>\n<p>交给子类去实现了</p>\n<p>总结:</p>\n<ul>\n<li>\n<p>ThreadLocal 基础实现 (原理: 保存着线程中)</p>\n</li>\n<li>\n<p>inheritableThreadLocals 实现了父子直接的传递 （原理: 可继承的变量空间,在Thread初始化init方法时候给子赋值）</p>\n</li>\n<li>\n<p>TransmittableThreadLocal 实现线程复用 (原理: 在每次线程执行时候重新给ThreadLocal赋值)</p>\n</li>\n</ul>\n",
      "image": "https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png",
      "date_published": "2022-05-29T13:46:15.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Java进阶"
      ]
    },
    {
      "title": "Elastic-Job源码解析(一)之与Spring完美整合",
      "url": "https://java.springlearn.cn/learn/jobs/Elastic-Job%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(%E4%B8%80)%E4%B9%8B%E4%B8%8ESpring%E5%AE%8C%E7%BE%8E%E6%95%B4%E5%90%88/",
      "id": "https://java.springlearn.cn/learn/jobs/Elastic-Job%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(%E4%B8%80)%E4%B9%8B%E4%B8%8ESpring%E5%AE%8C%E7%BE%8E%E6%95%B4%E5%90%88/",
      "content_html": "<blockquote>\n<p>看过小编写SpringFramework源码解析的同学应该对Spring支持自定义标签还有点印象吧，没有的话我们回顾下，然后看看Elastic-Job是如何巧妙的利用自定义标签生成Job任务的吧。请注意这里用了一个巧妙关键字。我们看它如何巧妙的吧。</p>\n</blockquote>\n<h2 id=\"elastic-job-自定义标签原理\"> Elastic Job 自定义标签原理</h2>\n<p>在Spring中实现自定义标签只用继承NamespaceHandlerSupport类，然后定义自己的BeanDefinitionParse来生成BeanDefinition就可以了。就会被Spring的IOC容器加载到了。</p>\n<div><pre><code><span>/**\n * 分布式作业的命名空间处理器\n */</span>\n<span>public</span> <span>final</span> <span>class</span> <span>JobNamespaceHandler</span> <span>extends</span> <span>NamespaceHandlerSupport</span> <span>{</span>\n    <span>public</span> <span>JobNamespaceHandler</span><span>(</span><span>)</span> <span>{</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>init</span><span>(</span><span>)</span> <span>{</span>\n        <span>this</span><span>.</span><span>registerBeanDefinitionParser</span><span>(</span><span>\"simple\"</span><span>,</span> <span>new</span> <span>SimpleJobBeanDefinitionParser</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>this</span><span>.</span><span>registerBeanDefinitionParser</span><span>(</span><span>\"dataflow\"</span><span>,</span> <span>new</span> <span>DataflowJobBeanDefinitionParser</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>this</span><span>.</span><span>registerBeanDefinitionParser</span><span>(</span><span>\"script\"</span><span>,</span> <span>new</span> <span>ScriptJobBeanDefinitionParser</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><table>\n<thead>\n<tr>\n<th>类型</th>\n<th>解析器</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>simple</td>\n<td>SimpleJobBeanDefinitionParser</td>\n<td>一般任务</td>\n</tr>\n<tr>\n<td>dataflow</td>\n<td>DataflowJobBeanDefinitionParser</td>\n<td>数据流任务</td>\n</tr>\n<tr>\n<td>script</td>\n<td>ScriptJobBeanDefinitionParser</td>\n<td>脚本任务</td>\n</tr>\n</tbody>\n</table>\n<p>注册中心解析器</p>\n<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>RegNamespaceHandler</span> <span>extends</span> <span>NamespaceHandlerSupport</span> <span>{</span>\n    <span>public</span> <span>RegNamespaceHandler</span><span>(</span><span>)</span> <span>{</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>init</span><span>(</span><span>)</span> <span>{</span>\n        <span>this</span><span>.</span><span>registerBeanDefinitionParser</span><span>(</span><span>\"zookeeper\"</span><span>,</span> <span>new</span> <span>ZookeeperBeanDefinitionParser</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><ul>\n<li>在jar中添加 <code>/META-INF/spring.handler</code> 指定文件的解析器</li>\n<li>在jar中添加 <code>/META-INF/spring.schemas</code> 指定文件的xml约束信息</li>\n</ul>\n<p><img src=\"https://img.springlearn.cn/blog/ded053e68c5fbedda0c82581c80fba2c.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"elastic-job如何巧妙\"> Elastic-Job如何巧妙?</h2>\n<p>注意: 定时任务 = 定时器 + 任务\nElastic Job只给我们提供了任务标签，所以我们平时用Elastic-Job写的只是一个任务，而不是一个Bean。另外关于标签的属性，即: 定时的信息,是以属性配置的形式放在xml中的,我们可以看xsd文件约束中找到，都有哪些属性可以用，下图</p>\n<p><img src=\"https://img.springlearn.cn/blog/297f09f2a289942949fb4bfe30722dc0.png\" alt=\"\" loading=\"lazy\"></p>\n<p><img src=\"https://img.springlearn.cn/blog/c426616c1337a7ba39da1d2171cb07fd.png\" alt=\"\" loading=\"lazy\"></p>\n<p>Elastic-Job会解析我们的xml任务信息,并通过定时的相关参数，生成SpringJobScheduler对象,在哪里进行着一操作呢？\n感觉很怪异，找了很久才找到，竟然在每个任务的解析器中。为什么这么说呢? 因为实现都在抽象类中生成。</p>\n<p><img src=\"https://img.springlearn.cn/blog/d046d029692e7b204f56dc023609ca39.png\" alt=\"\" loading=\"lazy\"></p>\n<p>所有的任务解析器都实现了一个抽象方法AbstractJobBeanDefinitionParser。而在这里面对我们写的job标签进行了解析生成job对象，作为属性注入到SpringJobScheduler中，在init方法中，开始执行定时 任务(quartz)。</p>\n<p><img src=\"https://img.springlearn.cn/blog/7c71ed058225816bcd38f1de71836f5f.png\" alt=\"\" loading=\"lazy\"></p>\n<p>其实BeanDefinitionParse的主要职责是解析Bean对象的，而Elastic-Job巧妙的用来生成SpringJobScheduler。\n由此联想到Es Job的标签都是 job:{taskType}开头的，看来命名真的很有技巧，<code>注意他不是一个bean而是SpringJobSchedulerBean的一个参数声明 !</code> 还能这么用! get 到一个新技能。</p>\n<p><strong>另外注意</strong></p>\n<ul>\n<li>①: init初始化方法中完成定时任务的初始化操作，即开始定时，底层还是使用的quartz的一个封装</li>\n<li>②: shutdown回收资源,关闭线程池</li>\n</ul>\n",
      "image": "https://img.springlearn.cn/blog/ded053e68c5fbedda0c82581c80fba2c.png",
      "date_published": "2022-08-22T01:35:49.000Z",
      "date_modified": "2022-08-22T01:35:49.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "java"
      ]
    },
    {
      "title": "自定义布局",
      "url": "https://java.springlearn.cn/learn/layout/",
      "id": "https://java.springlearn.cn/learn/layout/",
      "content_html": "<p>您可以使用带有 Markdown 支持的插槽来自定义页面布局。</p>\n<div><p>注意</p>\n<p>此处仅仅是一个演示，你应该自行根据需求添加样式。</p>\n\n\n</div>\n<template #page-top><p>页面顶部内容</p>\n</template><template #page-bottom><p>页面底部内容</p>\n</template><template #content-top><p>内容顶部内容</p>\n</template><template #content-bottom><p>内容底部内容</p>\n</template><template #navbar-start><p>导航栏起始内容</p>\n</template><template #navbar-center><p>导航栏中部内容</p>\n</template><template #navbar-end><p>导航栏末尾内容</p>\n</template><template #sidebar-top><p>侧边栏顶部内容</p>\n</template><template #sidebar-center><p>侧边栏中部内容</p>\n</template><template #sidebar-bottom><p>侧边栏底部内容</p>\n</template><p>更多详情，详见 <a href=\"https://vuepress-theme-hope.github.io/zh/guide/layout/custom/\" target=\"_blank\" rel=\"noopener noreferrer\">自定义布局</a>.</p>\n",
      "date_published": "2021-12-21T05:46:37.000Z",
      "date_modified": "2021-12-21T05:46:37.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "maven-resources-plugin",
      "url": "https://java.springlearn.cn/learn/maven/maven-resources-plugin/",
      "id": "https://java.springlearn.cn/learn/maven/maven-resources-plugin/",
      "content_html": "<blockquote>\n<p>maven-resources-plugin</p>\n</blockquote>\n<p>资源插件处理将项目资源复制到输出目录。有两种不同的资源：主要资源和测试资源。区别在于主要资源是与主要源代码相关联的资源，而测试资源与测试源代码相关联。</p>\n<p>因此，这允许主要源代码及其单元测试的资源分离。</p>\n<p>从 2.3 版开始，这个插件使用Maven Filtering共享组件来过滤资源。</p>\n<p><img src=\"https://maven.apache.org/images/maventxt_logo_200.gif\" alt=\"\" loading=\"lazy\"></p>\n<p><a href=\"https://maven.apache.org/plugins/maven-resources-plugin/\" target=\"_blank\" rel=\"noopener noreferrer\">maven-resources-plugin官网</a></p>\n<h2 id=\"主要功能\"> 主要功能</h2>\n<ul>\n<li>\n<p>resources:resources\n将主源代码的资源复制到主输出目录。\n这个目标通常会自动执行，因为它默认绑定到流程资源生命周期阶段。它总是使用 project.build.resources 元素来指定资源，并且默认使用 project.build.outputDirectory 来指定复制目标。</p>\n</li>\n<li>\n<p>resources:testResources\n将测试源代码的资源复制到测试输出目录。\n这个目标通常会自动执行，因为它默认绑定到 process-test-resources 生命周期阶段。它总是使用 project.build.testResources 元素来指定资源，并且默认使用 project.build.testOutputDirectory 来指定复制目标。</p>\n</li>\n<li>\n<p>resources:copy-resources\n将资源复制到输出目录。此目标要求您配置要复制的资源，并指定 outputDirectory。</p>\n</li>\n</ul>\n",
      "image": "https://maven.apache.org/images/maventxt_logo_200.gif",
      "date_published": "2021-12-21T05:46:37.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Maven"
      ]
    },
    {
      "title": "Elastic-Job源码解析(三)之分片定时任务执行",
      "url": "https://java.springlearn.cn/learn/jobs/Elastic-Job%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(%E4%B8%89)%E4%B9%8B%E5%88%86%E7%89%87%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C/",
      "id": "https://java.springlearn.cn/learn/jobs/Elastic-Job%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(%E4%B8%89)%E4%B9%8B%E5%88%86%E7%89%87%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C/",
      "content_html": "<blockquote>\n<p>通过本篇的阅读你将学会了解Elastic-Job的定时时机,及如何通过分片方式做一个分布式的定时任务框架。了解常用的三种分片策略，及如何自定义分布式分片策略</p>\n</blockquote>\n<h2 id=\"elastic-job如何通过springjobscheduler启动定时\"> Elastic-Job如何通过SpringJobScheduler启动定时</h2>\n<p>在&lt;&lt;Elastic-Job源码解析（一）之与Spring完美整合&gt;&gt;中我们已经了解Elasti-Job非常巧妙的用BeanDefinitionParse解析器将任务类型最终通过抽象类的方式解析成了SpringJobScheduler</p>\n<p><img src=\"https://img.springlearn.cn/blog/7f001280f2350642dd2e9b1a9ebfbf46.png\" alt=\"\" loading=\"lazy\"></p>\n<ul>\n<li>SpringJobScheduler</li>\n</ul>\n<div><div><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><pre><code><span>public</span> <span>abstract</span> <span>class</span> <span>AbstractJobBeanDefinitionParser</span> <span>extends</span> <span>AbstractBeanDefinitionParser</span> <span>{</span>\n    \n    <span>@Override</span>\n    <span>protected</span> <span>AbstractBeanDefinition</span> <span>parseInternal</span><span>(</span><span>final</span> <span>Element</span> element<span>,</span> <span>final</span> <span>ParserContext</span> parserContext<span>)</span> <span>{</span>\n        <span>BeanDefinitionBuilder</span> factory <span>=</span> <span>BeanDefinitionBuilder</span><span>.</span><span>rootBeanDefinition</span><span>(</span><span>SpringJobScheduler</span><span>.</span><span>class</span><span>)</span><span>;</span>\n        factory<span>.</span><span>setInitMethodName</span><span>(</span><span>\"init\"</span><span>)</span><span>;</span>\n        <span>//TODO 抽象子类</span>\n        <span>if</span> <span>(</span><span>\"\"</span><span>.</span><span>equals</span><span>(</span>element<span>.</span><span>getAttribute</span><span>(</span>JOB_REF_ATTRIBUTE<span>)</span><span>)</span><span>)</span> <span>{</span>\n            <span>if</span> <span>(</span><span>\"\"</span><span>.</span><span>equals</span><span>(</span>element<span>.</span><span>getAttribute</span><span>(</span>CLASS_ATTRIBUTE<span>)</span><span>)</span><span>)</span> <span>{</span>\n                factory<span>.</span><span>addConstructorArgValue</span><span>(</span><span>null</span><span>)</span><span>;</span>\n            <span>}</span> <span>else</span> <span>{</span>\n                factory<span>.</span><span>addConstructorArgValue</span><span>(</span><span>BeanDefinitionBuilder</span><span>.</span><span>rootBeanDefinition</span><span>(</span>element<span>.</span><span>getAttribute</span><span>(</span>CLASS_ATTRIBUTE<span>)</span><span>)</span><span>.</span><span>getBeanDefinition</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            factory<span>.</span><span>addConstructorArgReference</span><span>(</span>element<span>.</span><span>getAttribute</span><span>(</span>JOB_REF_ATTRIBUTE<span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n        factory<span>.</span><span>addConstructorArgReference</span><span>(</span>element<span>.</span><span>getAttribute</span><span>(</span>REGISTRY_CENTER_REF_ATTRIBUTE<span>)</span><span>)</span><span>;</span>\n        factory<span>.</span><span>addConstructorArgValue</span><span>(</span><span>createLiteJobConfiguration</span><span>(</span>parserContext<span>,</span> element<span>)</span><span>)</span><span>;</span>\n        <span>BeanDefinition</span> jobEventConfig <span>=</span> <span>createJobEventConfig</span><span>(</span>element<span>)</span><span>;</span>\n        <span>if</span> <span>(</span><span>null</span> <span>!=</span> jobEventConfig<span>)</span> <span>{</span>\n            factory<span>.</span><span>addConstructorArgValue</span><span>(</span>jobEventConfig<span>)</span><span>;</span>\n        <span>}</span>\n        factory<span>.</span><span>addConstructorArgValue</span><span>(</span><span>createJobListeners</span><span>(</span>element<span>)</span><span>)</span><span>;</span>\n        <span>return</span> factory<span>.</span><span>getBeanDefinition</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>    \n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>通过抽象类的方式解析成了SpringJobScheduler 我们看SpringJobScheduler定时器的架构,SpringJobScheduler就是一个定时器,是JobScheduler的子类。真正定时的逻辑是由JobScheduler类处理的包括上面的init方法和shutdown方法。</p>\n<p><img src=\"https://img.springlearn.cn/blog/42691e6cc0c516599e3d809cab770d1e.png\" alt=\"\" loading=\"lazy\"></p>\n<ul>\n<li>\n<p>init方法中启动定时器,可以看到内部核心还是由quartz来实现的和小编在上一篇写的quartz很类似</p>\n<p><img src=\"https://img.springlearn.cn/blog/e875c92491af1fee146358a70d55c673.png\" alt=\"\" loading=\"lazy\"></p>\n</li>\n</ul>\n<div><pre><code>    <span>public</span> <span>void</span> <span>scheduleJob</span><span>(</span><span>final</span> <span>String</span> cron<span>)</span> <span>{</span>\n        <span>try</span> <span>{</span>\n            <span>if</span> <span>(</span><span>!</span>scheduler<span>.</span><span>checkExists</span><span>(</span>jobDetail<span>.</span><span>getKey</span><span>(</span><span>)</span><span>)</span><span>)</span> <span>{</span>\n                scheduler<span>.</span><span>scheduleJob</span><span>(</span>jobDetail<span>,</span> <span>createTrigger</span><span>(</span>cron<span>)</span><span>)</span><span>;</span>\n            <span>}</span>\n            scheduler<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>final</span> <span>SchedulerException</span> ex<span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>JobSystemException</span><span>(</span>ex<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>然后根据任务类型生成指定类型的执行器,并执行</p>\n<div><pre><code><span>@NoArgsConstructor</span><span>(</span>access <span>=</span> <span>AccessLevel</span><span>.</span>PRIVATE<span>)</span>\n<span>public</span> <span>final</span> <span>class</span> <span>JobExecutorFactory</span> <span>{</span>\n    \n    <span>/**\n     * 获取作业执行器.\n     *\n     * @param elasticJob 分布式弹性作业\n     * @param jobFacade 作业内部服务门面服务\n     * @return 作业执行器\n     */</span>\n    <span>@SuppressWarnings</span><span>(</span><span>\"unchecked\"</span><span>)</span>\n    <span>public</span> <span>static</span> <span>AbstractElasticJobExecutor</span> <span>getJobExecutor</span><span>(</span><span>final</span> <span>ElasticJob</span> elasticJob<span>,</span> <span>final</span> <span>JobFacade</span> jobFacade<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span><span>null</span> <span>==</span> elasticJob<span>)</span> <span>{</span>\n            <span>return</span> <span>new</span> <span>ScriptJobExecutor</span><span>(</span>jobFacade<span>)</span><span>;</span>\n        <span>}</span>\n        <span>if</span> <span>(</span>elasticJob <span>instanceof</span> <span>SimpleJob</span><span>)</span> <span>{</span>\n            <span>return</span> <span>new</span> <span>SimpleJobExecutor</span><span>(</span><span>(</span><span>SimpleJob</span><span>)</span> elasticJob<span>,</span> jobFacade<span>)</span><span>;</span>\n        <span>}</span>\n        <span>if</span> <span>(</span>elasticJob <span>instanceof</span> <span>DataflowJob</span><span>)</span> <span>{</span>\n            <span>return</span> <span>new</span> <span>DataflowJobExecutor</span><span>(</span><span>(</span><span>DataflowJob</span><span>)</span> elasticJob<span>,</span> jobFacade<span>)</span><span>;</span>\n        <span>}</span>\n        <span>throw</span> <span>new</span> <span>JobConfigurationException</span><span>(</span><span>\"Cannot support job type '%s'\"</span><span>,</span> elasticJob<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getCanonicalName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>任务类型对应的执行器是下面这些</p>\n<p><img src=\"https://img.springlearn.cn/blog/a0d048b046f999ee5516dfea48d6f7d6.png\" alt=\"\" loading=\"lazy\"></p>\n<p>从中我们分析最常见的任务类型SimpleJobExecutor，这里面我们主要看ShardingContext分片上下文是怎么生成的，很明显是有抽象类AbstractElasticJobExecutor来生成的。分片策略一定也是在这个里面执行的，最终生成ShardingContext类的，而这个类就是Elastic-Job给每台服务器上的任务分配的上下文,这里面就包括了分配标识</p>\n<p><img src=\"https://img.springlearn.cn/blog/0e9939fffeb0a11e4bbe85dbf5761f8f.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"分片策略如何使用\"> 分片策略如何使用</h2>\n<p>给分布式环境下的每个任务实例, 一个特定的分片标记。然后每个任务实例中根据分片标记去获取数据。以此来避免任务重复执行。那么究竟是如何避免呢?\n其实还是开发者自己来避免的, job只保证同一个分片只会分到一个实例上，不会分配到两个实例上。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>InvokerTimer</span> <span>implements</span> <span>SimpleJob</span><span>{</span>\n\n    <span>@Autowired</span>\n    <span>private</span> <span>Core</span> core<span>;</span>\n    \n    <span>public</span> <span>void</span> <span>execute</span><span>(</span><span>ShardingContext</span> shardingContext<span>)</span><span>{</span>\n        <span>// 获取分片信息</span>\n        <span>int</span> item <span>=</span> shardingContext<span>.</span><span>getShardingItem</span><span>(</span><span>)</span><span>;</span>\n        <span>// 根据分片信息,获取这台实例上应该处理的数据</span>\n        <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> orgIds <span>=</span> core<span>.</span><span>queryOrgIdsByScheduleZone</span><span>(</span>item<span>)</span><span>;</span>\n        <span>.</span><span>.</span><span>.</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id=\"elastic-job的三种分片策略\"> Elastic-Job的三种分片策略</h2>\n<p>什么是分片策略呢? 什么情况下有分片策略呢? 其实这就是Elastic Job 作为分布式任务的亮点。就是通过分片的策略，来给每台实例指定数据，防止多台实例重复处理数据。\nElasticJob 是通过Zookeeper来进行交互和分配任务，这里说分配任务有点夸大了他的能力，他其实只是给你个分片，然后开发者根据分片去自己到数据库或者是其他数据源中拿到，改分片对应的\n任务来执行。而我们所谓说的分片就是ShardingContext对象。就是说ElasticJob把你生成了ShardingContext。ElasticJob提供了3中策略。</p>\n<p><img src=\"https://img.springlearn.cn/blog/a7395e57fec4434fa4ec95b9675733b4.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"平均分片\"> 平均分片</h3>\n<p>AverageAllocationJobShardingStrategy 平均分片</p>\n<p>如果分片不能整除, 则不能整除的多余分片将依次追加到序号小的服务器.</p>\n<p>如:</p>\n<p>如果有3台服务器, 分成9片, 则每台服务器分到的分片是: 1=[0,1,2], 2=[3,4,5], 3=[6,7,8].\n如果有3台服务器, 分成8片, 则每台服务器分到的分片是: 1=[0,1,6], 2=[2,3,7], 3=[4,5].\n如果有3台服务器, 分成10片, 则每台服务器分到的分片是: 1=[0,1,2,9], 2=[3,4,5], 3=[6,7,8].</p>\n<p><img src=\"https://img.springlearn.cn/blog/255465d3eb11f645df51d02e2410c243.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"hash-分片\"> hash 分片</h3>\n<p>根据作业名的哈希值奇偶数决定IP升降序算法的分片策略.</p>\n<ul>\n<li>作业名的哈希值为奇数则IP升序.</li>\n<li>作业名的哈希值为偶数则IP降序.\n用于不同的作业平均分配负载至不同的服务器.</li>\n</ul>\n<p>如:</p>\n<ol>\n<li>如果有3台服务器, 分成2片, 作业名称的哈希值为奇数, 则每台服务器分到的分片是: 1=[0], 2=[1], 3=[].</li>\n<li>如果有3台服务器, 分成2片, 作业名称的哈希值为偶数, 则每台服务器分到的分片是: 3=[0], 2=[1], 1=[].</li>\n</ol>\n<p><img src=\"https://img.springlearn.cn/blog/ecb79278e6946fc1a601ea26c22d0877.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"轮训分片\"> 轮训分片</h3>\n<p><img src=\"https://img.springlearn.cn/blog/35ace4831dd6794a3365d5a95889eace.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"分片策略总结\"> 分片策略总结</h2>\n<p>通过对上面的分片策略来看啊，这所谓的三种分片策略其实都是利用AverageAllocationJobShardingStrategy 平均分片，<code>非常巧妙也非常敷衍😂</code>。\n巧妙是说充分利用了平均分片的策略，只不过将serverList排序就实现了另一种分片策略，敷衍是说没有多大作用。其实完全可以实现通过机器性能的监控同步到ZK,然后在根据机器性能来平均分片的，这样小编感觉更加合理写。不过因为Elastic Job提供了指定策略的接口，所以具体怎么分的能力，就交给使用者自己去实现吧。\n对于根据作业名轮询策略和IP降级策略，小编无话可说，不知道到底好用不好用，以及有啥实际用处。不过小编在工作中一直用平均策略。说到这里我们顺便分析下如何自定义分片策略。</p>\n<h2 id=\"如何自定义分片策略\"> 如何自定义分片策略</h2>\n<p>我们先看源码是从哪里弄到分片策略信息的</p>\n<p><img src=\"https://img.springlearn.cn/blog/99436a94e51cf77981d3be3fd16f688c.png\" alt=\"\" loading=\"lazy\">\n从配置中读取分片策略class属性值\n<img src=\"https://img.springlearn.cn/blog/a763c56d2152e8da15019d05b97e798f.png\" alt=\"\" loading=\"lazy\"></p>\n<p>自定义分片策略class\n如果没有指定默认平均分，在JobShardingStrategyFactory中指定默认</p>\n<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>JobShardingStrategyFactory</span> <span>{</span>\n    \n    <span>/**\n     * 获取作业分片策略实例.\n     * \n     * @param jobShardingStrategyClassName 作业分片策略类名\n     * @return 作业分片策略实例\n     */</span>\n    <span>public</span> <span>static</span> <span>JobShardingStrategy</span> <span>getStrategy</span><span>(</span><span>final</span> <span>String</span> jobShardingStrategyClassName<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span><span>Strings</span><span>.</span><span>isNullOrEmpty</span><span>(</span>jobShardingStrategyClassName<span>)</span><span>)</span> <span>{</span>\n            <span>return</span> <span>new</span> <span>AverageAllocationJobShardingStrategy</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>try</span> <span>{</span>\n            <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> jobShardingStrategyClass <span>=</span> <span>Class</span><span>.</span><span>forName</span><span>(</span>jobShardingStrategyClassName<span>)</span><span>;</span>\n            <span>if</span> <span>(</span><span>!</span><span>JobShardingStrategy</span><span>.</span><span>class</span><span>.</span><span>isAssignableFrom</span><span>(</span>jobShardingStrategyClass<span>)</span><span>)</span> <span>{</span>\n                <span>throw</span> <span>new</span> <span>JobConfigurationException</span><span>(</span><span>\"Class '%s' is not job strategy class\"</span><span>,</span> jobShardingStrategyClassName<span>)</span><span>;</span>\n            <span>}</span>\n            <span>return</span> <span>(</span><span>JobShardingStrategy</span><span>)</span> jobShardingStrategyClass<span>.</span><span>newInstance</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>final</span> <span>ClassNotFoundException</span> <span>|</span> <span>InstantiationException</span> <span>|</span> <span>IllegalAccessException</span> ex<span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>JobConfigurationException</span><span>(</span><span>\"Sharding strategy class '%s' config error, message details are '%s'\"</span><span>,</span> jobShardingStrategyClassName<span>,</span> ex<span>.</span><span>getMessage</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div>",
      "image": "https://img.springlearn.cn/blog/7f001280f2350642dd2e9b1a9ebfbf46.png",
      "date_published": "2022-08-22T01:35:49.000Z",
      "date_modified": "2022-08-22T01:35:49.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "java"
      ]
    },
    {
      "title": "Elastic-Job源码",
      "url": "https://java.springlearn.cn/learn/jobs/",
      "id": "https://java.springlearn.cn/learn/jobs/",
      "content_html": "",
      "date_published": "2022-08-22T01:35:49.000Z",
      "date_modified": "2022-08-22T01:35:49.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "java"
      ]
    },
    {
      "title": "spring-boot-maven-plugin",
      "url": "https://java.springlearn.cn/learn/maven/spring-boot-maven-plugin/",
      "id": "https://java.springlearn.cn/learn/maven/spring-boot-maven-plugin/",
      "content_html": "<blockquote>\n<p>spring-boot-maven-plugin</p>\n</blockquote>\n",
      "date_published": "2021-12-21T05:46:37.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Maven"
      ]
    },
    {
      "title": "编译卡点插件",
      "url": "https://java.springlearn.cn/learn/maven/plugin/artifact-check-maven-plugin/",
      "id": "https://java.springlearn.cn/learn/maven/plugin/artifact-check-maven-plugin/",
      "content_html": "<Pwd/>\n<p>小编问一个问题,你们依赖的项目在发布线上环境时候,依赖中是否还会有快照版本呢?\n如果有，那你就危险了,因为是快照版本,随时都可以进行覆盖,如果覆盖了之前的版本。很有可能你的项目有很大的风险。\n举一个例子,项目A组使用了项目B组提供的一个依赖。开发时候因为都是使用快照包。但是上线B向A提供了一个RELEASE包。\n但是A项目组上线时候,忘记使用RELEASE包了。代码运行也完全没问题。\n但是突然有一天项目B组将之前的快照包给覆盖了,并且删除了里面的一些代码。这个时候项目A的项目,可能就启动不起来了。\n因为他依赖的快照包被覆盖了。</p>\n<p>那么如何解决上面的问题呢? 本篇我们就利用我们之前学的知识来开发一个,版本检查的工具。在每次项目编译的时候去进行检查。</p>\n<p>通过不同环境，执行不同的参数来对依赖版本进行校验。</p>\n<h2 id=\"一、开发思路\"> 一、开发思路</h2>\n<p>思路比较简单,在maven 打包时候,通过添加参数的方式,对打包的依赖进行正则分析。当发现有被匹配到的版本。就收集起来。\n最后进行阻断,不允许打包通过。</p>\n<h2 id=\"二、开始开发\"> 二、开始开发</h2>\n<h2 id=\"_2-1-声明一个mojo插件\"> 2.1 声明一个Mojo插件</h2>\n<p>本文我们都基于Maven3进行插件开发。使用注解方式进行声明。</p>\n<div><pre><code><span>@Mojo</span><span>(</span>name <span>=</span> <span>\"versionCheck\"</span><span>,</span> defaultPhase <span>=</span> <span>LifecyclePhase</span><span>.</span>PACKAGE<span>,</span> threadSafe <span>=</span> <span>true</span><span>,</span> requiresDependencyCollection <span>=</span> <span>ResolutionScope</span><span>.</span>TEST<span>)</span>\n<span>@Execute</span><span>(</span>phase <span>=</span> <span>LifecyclePhase</span><span>.</span>PACKAGE<span>)</span>\n<span>public</span> <span>class</span> <span>ArtifactVersionCheckMojo</span> <span>extends</span> <span>AbstractMojo</span> <span>{</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>execute</span><span>(</span><span>)</span> <span>throws</span> <span>MojoExecutionException</span><span>,</span> <span>MojoFailureException</span> <span>{</span>\n    \n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id=\"_2-2-添加拦截规则\"> 2.2 添加拦截规则</h2>\n<p>拦击规则我们让用户自己进行配置。</p>\n<div><pre><code>    <span>@Parameter</span><span>(</span>property <span>=</span> <span>\"versionCheckRegular\"</span><span>)</span>\n    <span>private</span> <span>String</span><span>[</span><span>]</span> assertDependencyRegular<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>用户可以通过set方式注入</p>\n<div><pre><code>              <span><span><span>&lt;</span>plugin</span><span>></span></span>\n                <span><span><span>&lt;</span>groupId</span><span>></span></span>com.github.lxchinesszz<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n                <span><span><span>&lt;</span>artifactId</span><span>></span></span>learn-maven-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n                <span><span><span>&lt;</span>version</span><span>></span></span>1.0.1-SNAPSHOT<span><span><span>&lt;/</span>version</span><span>></span></span>\n                <span><span><span>&lt;</span>executions</span><span>></span></span>\n                    <span><span><span>&lt;</span>execution</span><span>></span></span>\n                        <span><span><span>&lt;</span>phase</span><span>></span></span>package<span><span><span>&lt;/</span>phase</span><span>></span></span>\n                        <span><span><span>&lt;</span>goals</span><span>></span></span>\n                            <span><span><span>&lt;</span>goal</span><span>></span></span>versionCheck<span><span><span>&lt;/</span>goal</span><span>></span></span>\n                        <span><span><span>&lt;/</span>goals</span><span>></span></span>\n                    <span><span><span>&lt;/</span>execution</span><span>></span></span>\n                <span><span><span>&lt;/</span>executions</span><span>></span></span>\n                <span><span><span>&lt;</span>configuration</span><span>></span></span>\n                    // 使用标签就行配置\n                    <span><span><span>&lt;</span>assertDependencyRegular</span><span>></span></span>\n                        <span><span><span>&lt;</span>param</span><span>></span></span>.*SNAPSHOT<span><span><span>&lt;/</span>param</span><span>></span></span>\n                    <span><span><span>&lt;/</span>assertDependencyRegular</span><span>></span></span>\n                <span><span><span>&lt;/</span>configuration</span><span>></span></span>\n            <span><span><span>&lt;/</span>plugin</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>同时也可以使用-D在命令行进行操作。</p>\n<p><code>mvn package -DversionCheckRegular=.*SNAPSHOT</code></p>\n<h2 id=\"_2-3-依赖分析\"> 2.3 依赖分析</h2>\n<p>这里为了避免你的maven版本过低建议你指定版本。</p>\n<div><pre><code>        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>org.apache.maven<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>maven-core<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n            <span><span><span>&lt;</span>version</span><span>></span></span>3.8.5<span><span><span>&lt;/</span>version</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>我们使用分析工具. DependencyGraphBuilder</p>\n<div><pre><code>    <span>ProjectBuildingRequest</span> buildingRequest <span>=</span> <span>new</span> <span>DefaultProjectBuildingRequest</span><span>(</span>session<span>.</span><span>getProjectBuildingRequest</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    buildingRequest<span>.</span><span>setProject</span><span>(</span>project<span>)</span><span>;</span>\n    <span>DependencyNode</span> rootNode <span>=</span> dependencyGraphBuilder<span>.</span><span>buildDependencyGraph</span><span>(</span>buildingRequest<span>,</span> <span>new</span> <span>ScopeArtifactFilter</span><span>(</span><span>\"test\"</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"三、使用演示\"> 三、使用演示</h2>\n<h2 id=\"_3-1-安装插件\"> 3.1 安装插件</h2>\n<div><pre><code>    <span><span><span>&lt;</span>build</span><span>></span></span>\n        <span><span><span>&lt;</span>plugins</span><span>></span></span>\n            <span><span><span>&lt;</span>plugin</span><span>></span></span>\n                <span><span><span>&lt;</span>groupId</span><span>></span></span>com.github.lxchinesszz<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n                <span><span><span>&lt;</span>artifactId</span><span>></span></span>learn-maven-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n                <span><span><span>&lt;</span>version</span><span>></span></span>1.0.1-SNAPSHOT<span><span><span>&lt;/</span>version</span><span>></span></span>\n                <span><span><span>&lt;</span>executions</span><span>></span></span>\n                    <span><span><span>&lt;</span>execution</span><span>></span></span>\n                        <span><span><span>&lt;</span>phase</span><span>></span></span>package<span><span><span>&lt;/</span>phase</span><span>></span></span>\n                        <span><span><span>&lt;</span>goals</span><span>></span></span>\n                            <span><span><span>&lt;</span>goal</span><span>></span></span>versionCheck<span><span><span>&lt;/</span>goal</span><span>></span></span>\n                        <span><span><span>&lt;/</span>goals</span><span>></span></span>\n                    <span><span><span>&lt;/</span>execution</span><span>></span></span>\n                <span><span><span>&lt;/</span>executions</span><span>></span></span>\n                <span><span><span>&lt;</span>configuration</span><span>></span></span>\n                    <span><span><span>&lt;</span>assertDependencyRegular</span><span>></span></span>\n                        <span><span><span>&lt;</span>param</span><span>></span></span>.*SNAPSHOT<span><span><span>&lt;/</span>param</span><span>></span></span>\n                    <span><span><span>&lt;/</span>assertDependencyRegular</span><span>></span></span>\n                <span><span><span>&lt;/</span>configuration</span><span>></span></span>\n            <span><span><span>&lt;/</span>plugin</span><span>></span></span>\n        <span><span><span>&lt;/</span>plugins</span><span>></span></span>\n    <span><span><span>&lt;/</span>build</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h2 id=\"_3-2-执行打包命令\"> 3.2 执行打包命令</h2>\n<ul>\n<li>因为我们绑定的是package所以我们直接执行插件</li>\n</ul>\n<p><code>mvn com.github.lxchinesszz:learn-maven-plugin:1.0.1-SNAPSHOT:versionCheck</code></p>\n<ul>\n<li>或者我们直接执行打包命令,同样会触发插件执行</li>\n</ul>\n<p><code>mvn package -DversionCheckRegular=.*SNAPSHOT</code></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1651591415000.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1651591415000.png",
      "date_published": "2022-05-08T04:06:59.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Maven"
      ]
    },
    {
      "title": "maven-surefire-plugin",
      "url": "https://java.springlearn.cn/learn/maven/maven-surefire-plugin/",
      "id": "https://java.springlearn.cn/learn/maven/maven-surefire-plugin/",
      "content_html": "<blockquote>\n<p>maven-surefire-plugin Surefire 插件在test构建生命周期阶段用于执行应用程序的单元测试。</p>\n</blockquote>\n<p><img src=\"https://maven.apache.org/images/maventxt_logo_200.gif\" alt=\"\" loading=\"lazy\"></p>\n<p><a href=\"https://maven.apache.org/surefire/maven-surefire-plugin/index.html\" target=\"_blank\" rel=\"noopener noreferrer\">maven-surefire-plugin官网</a></p>\n<h2 id=\"一、介绍\"> 一、介绍</h2>\n<p>如果你执行过mvn test或者执行其他maven命令时跑了测试用例，你就已经用过maven-surefire-plugin了。\nmaven-surefire-plugin是maven里执行测试用例的插件，不显示配置就会用默认配置。\n这个插件的surefire:test命令会默认绑定maven执行的test阶段。</p>\n<p>如果你自己声明了，那么可以指定自己的版本，并且可以配置自定义的参数。</p>\n<h2 id=\"二、实践\"> 二、实践</h2>\n<h3 id=\"_2-1-用法\"> 2.1 用法</h3>\n<div><pre><code> &lt;build&gt;\n    &lt;pluginManagement&gt;\n      &lt;plugins&gt;\n        &lt;plugin&gt;\n          &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n          &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;\n          &lt;version&gt;3.0.0-M5&lt;/version&gt;\n        &lt;/plugin&gt;\n      &lt;/plugins&gt;\n    &lt;/pluginManagement&gt;\n  &lt;/build&gt;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id=\"_2-2-使用方法\"> 2.2 使用方法</h3>\n<p><code>mvn test</code></p>\n<h2 id=\"三、源码分析\"> 三、源码分析</h2>\n<h3 id=\"_3-1-学习目标\"> 3.1 学习目标</h3>\n<div><p>相关信息</p>\n<p>框架整体比较复杂，但是对于我们有学习价值的东西不多，我们没必要太深入研究。在此只提几个关键的知识点学习。</p>\n</div>\n<ol>\n<li>maven-surefire-plugin的常用参数及作用</li>\n<li>maven-surefire-plugin实现单测的原理</li>\n</ol>\n<h3 id=\"_3-2-学习搭建环境\"> 3.2 学习搭建环境</h3>\n<div><pre><code>    <span>&lt;!-- 先声明插件版本 --></span>\n    <span><span><span>&lt;</span>build</span><span>></span></span>\n        <span><span><span>&lt;</span>plugins</span><span>></span></span>\n            <span><span><span>&lt;</span>plugin</span><span>></span></span>\n                <span><span><span>&lt;</span>groupId</span><span>></span></span>org.apache.maven.plugins<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n                <span><span><span>&lt;</span>artifactId</span><span>></span></span>maven-surefire-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n                <span>&lt;!-- JUnit 5 requires Surefire version 2.22.0 or higher --></span>\n                <span><span><span>&lt;</span>version</span><span>></span></span>2.22.0<span><span><span>&lt;/</span>version</span><span>></span></span>\n            <span><span><span>&lt;/</span>plugin</span><span>></span></span>\n        <span><span><span>&lt;/</span>plugins</span><span>></span></span>\n    <span><span><span>&lt;/</span>build</span><span>></span></span>\n    <span>&lt;!-- 然后引入依赖,方便debug跟进源码--></span>\n      <span><span><span>&lt;</span>dependency</span><span>></span></span>\n          <span><span><span>&lt;</span>groupId</span><span>></span></span>junit<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n          <span><span><span>&lt;</span>artifactId</span><span>></span></span>junit<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n          <span><span><span>&lt;</span>version</span><span>></span></span>4.13.2<span><span><span>&lt;/</span>version</span><span>></span></span>\n          <span><span><span>&lt;</span>scope</span><span>></span></span>test<span><span><span>&lt;/</span>scope</span><span>></span></span>\n      <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n      <span><span><span>&lt;</span>dependency</span><span>></span></span>\n          <span><span><span>&lt;</span>groupId</span><span>></span></span>org.apache.maven.plugins<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n          <span><span><span>&lt;</span>artifactId</span><span>></span></span>maven-surefire-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n          <span><span><span>&lt;</span>version</span><span>></span></span>3.0.0-M5<span><span><span>&lt;/</span>version</span><span>></span></span>\n      <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n      <span><span><span>&lt;</span>dependency</span><span>></span></span>\n          <span><span><span>&lt;</span>groupId</span><span>></span></span>org.apache.maven<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n          <span><span><span>&lt;</span>artifactId</span><span>></span></span>maven-core<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n          <span><span><span>&lt;</span>version</span><span>></span></span>3.8.4<span><span><span>&lt;/</span>version</span><span>></span></span>\n      <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n      <span><span><span>&lt;</span>dependency</span><span>></span></span>\n          <span><span><span>&lt;</span>groupId</span><span>></span></span>org.apache.maven.surefire<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n          <span><span><span>&lt;</span>artifactId</span><span>></span></span>surefire-junit4<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n          <span><span><span>&lt;</span>version</span><span>></span></span>3.0.0-M5<span><span><span>&lt;/</span>version</span><span>></span></span>\n      <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n      <span><span><span>&lt;</span>dependency</span><span>></span></span>\n          <span><span><span>&lt;</span>groupId</span><span>></span></span>org.apache.maven<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n          <span><span><span>&lt;</span>artifactId</span><span>></span></span>maven-plugin-api<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n          <span><span><span>&lt;</span>version</span><span>></span></span>${dep.maven-api.version}<span><span><span>&lt;/</span>version</span><span>></span></span>\n      <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n      <span><span><span>&lt;</span>dependency</span><span>></span></span>\n          <span><span><span>&lt;</span>groupId</span><span>></span></span>org.apache.maven<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n          <span><span><span>&lt;</span>artifactId</span><span>></span></span>maven-model<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n          <span><span><span>&lt;</span>version</span><span>></span></span>${dep.maven-api.version}<span><span><span>&lt;/</span>version</span><span>></span></span>\n      <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n      <span><span><span>&lt;</span>dependency</span><span>></span></span>\n          <span><span><span>&lt;</span>groupId</span><span>></span></span>org.apache.maven.plugin-tools<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n          <span><span><span>&lt;</span>artifactId</span><span>></span></span>maven-plugin-annotations<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n          <span><span><span>&lt;</span>version</span><span>></span></span>${dep.maven-api.version}<span><span><span>&lt;/</span>version</span><span>></span></span>\n      <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n      <span><span><span>&lt;</span>dependency</span><span>></span></span>\n          <span><span><span>&lt;</span>groupId</span><span>></span></span>org.apache.maven.plugins<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n          <span><span><span>&lt;</span>artifactId</span><span>></span></span>maven-plugin-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n          <span><span><span>&lt;</span>version</span><span>></span></span>${dep.maven-api.version}<span><span><span>&lt;/</span>version</span><span>></span></span>\n      <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br></div></div><h3 id=\"_3-3-找到插件入口\"> 3.3 找到插件入口</h3>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1645113430000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>前面通过学习知道Mojo是运行的核心类,而SurefirePlugin就是Mojo的子类。\n由此可知,如果要学习这个 <code>maven-surefire-plugin</code>，入口就是在SurefirePlugin类。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1644857307000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1645114616000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"四、-带着问题来学习\"> 四、 带着问题来学习</h2>\n<h3 id=\"_4-1-常用的参数都有那些\"> 4.1 常用的参数都有那些</h3>\n<p>大多数为不常用的</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">是否常用</th>\n<th style=\"text-align:left\">参数名</th>\n<th style=\"text-align:center\">使用方法</th>\n<th style=\"text-align:center\">解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">常用</td>\n<td style=\"text-align:left\">skipTests</td>\n<td style=\"text-align:center\">-D,或者xml配置标签</td>\n<td style=\"text-align:center\">用于跳过单测</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">常用</td>\n<td style=\"text-align:left\">maven.test.skip.exec</td>\n<td style=\"text-align:center\">-D,或者xml配置标签</td>\n<td style=\"text-align:center\">用于跳过单测</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">常用</td>\n<td style=\"text-align:left\">maven.test.skip</td>\n<td style=\"text-align:center\">-D,或者xml配置标签</td>\n<td style=\"text-align:center\">用于跳过单测</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">不常用</td>\n<td style=\"text-align:left\">testClassesDirectory</td>\n<td style=\"text-align:center\">xml配置标签</td>\n<td style=\"text-align:center\">指定测试模块目录编译后目录</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">不常用</td>\n<td style=\"text-align:left\">maven.test.dependency.excludes</td>\n<td style=\"text-align:center\">-D,或者xml配置标签</td>\n<td style=\"text-align:center\">要排除的依赖,格式:groupId:artifactId</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">不常用</td>\n<td style=\"text-align:left\">maven.test.additionalClasspath</td>\n<td style=\"text-align:center\">-D,或者xml配置标签</td>\n<td style=\"text-align:center\">追加classpath</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">不常用</td>\n<td style=\"text-align:left\">project.build.testSourceDirectory</td>\n<td style=\"text-align:center\">xml配置标签</td>\n<td style=\"text-align:center\">指定测试模块目录源码目录</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">不常用</td>\n<td style=\"text-align:left\">excludes</td>\n<td style=\"text-align:center\">xml配置</td>\n<td style=\"text-align:center\">指定规则的类不需要被单测，eg: **/*Test.java</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">不常用</td>\n<td style=\"text-align:left\">surefire.reportNameSuffix</td>\n<td style=\"text-align:center\">-D,或者xml配置标签</td>\n<td style=\"text-align:center\">test报表后缀</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">不常用</td>\n<td style=\"text-align:left\">maven.test.redirectTestOutputToFile</td>\n<td style=\"text-align:center\">-D,或者xml配置标签</td>\n<td style=\"text-align:center\">运行的单侧输出重定向到report目录中</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">不常用</td>\n<td style=\"text-align:left\">failIfNoTests</td>\n<td style=\"text-align:center\">-D,或者xml配置标签</td>\n<td style=\"text-align:center\">如果没有单测就报错</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">不常用</td>\n<td style=\"text-align:left\">forkMode</td>\n<td style=\"text-align:center\">-D,或者xml配置标签</td>\n<td style=\"text-align:center\">运行模式</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">不常用</td>\n<td style=\"text-align:left\">jvm</td>\n<td style=\"text-align:center\">-D,或者xml配置标签</td>\n<td style=\"text-align:center\">指定jvm目录,如果不指定会读取系统</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">不常用</td>\n<td style=\"text-align:left\">argLine</td>\n<td style=\"text-align:center\">-D,或者xml配置标签</td>\n<td style=\"text-align:center\">Jvm运行参数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">不常用</td>\n<td style=\"text-align:left\">threadCount</td>\n<td style=\"text-align:center\">-D,或者xml配置标签</td>\n<td style=\"text-align:center\">线程数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">不常用</td>\n<td style=\"text-align:left\">forkCount</td>\n<td style=\"text-align:center\">-D,或者xml配置标签</td>\n<td style=\"text-align:center\">指定启用多少个vm,1.5C 以数字结尾,数字乘以cpu核心数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">不常用</td>\n<td style=\"text-align:left\">reuseForks</td>\n<td style=\"text-align:center\">-D,或者xml配置标签</td>\n<td style=\"text-align:center\">是否可重新使用forks进程</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">不常用</td>\n<td style=\"text-align:left\">disableXmlReport</td>\n<td style=\"text-align:center\">-D,或者xml配置标签</td>\n<td style=\"text-align:center\">禁用xml报告</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">不常用</td>\n<td style=\"text-align:left\">enableassertions</td>\n<td style=\"text-align:center\">-D,或者xml配置标签</td>\n<td style=\"text-align:center\">启用断言assert语句</td>\n</tr>\n</tbody>\n</table>\n<p><strong>forkMode 可设置值有 “never”， “once”， “always” 和 “pertest”。</strong></p>\n<ul>\n<li>pretest： 每一个测试创建一个新进程，为每个测试创建新的JVM是单独测试的最彻底方式，但也是最慢的，不适合hudson上持续回归。</li>\n<li>once：在一个进程中进行所有测试。once为默认设置，在Hudson上持续回归时建议使用默认设置。</li>\n<li>always：在一个进程中并行的运行脚本，Junit4.7以上版本才可以使用，surefire的版本要在2.6以上提供这个功能，</li>\n</ul>\n<h3 id=\"_4-2-知识点\"> 4.2 知识点</h3>\n<div><pre><code>// 大于等于2.0.0，小于2.1.2\nVersionRange range = VersionRange.createFromVersionSpec(&quot;[2.0.0,2.1.2)&quot;);\nSystem.out.println(range.containsVersion(new DefaultArtifactVersion(&quot;1.0&quot;)));\nSystem.out.println(range.containsVersion(new DefaultArtifactVersion(&quot;2.0.0&quot;)));\nSystem.out.println(range.containsVersion(new DefaultArtifactVersion(&quot;2.1.1&quot;)));\nSystem.out.println(range.containsVersion(new DefaultArtifactVersion(&quot;2.1.2&quot;)));\nSystem.out.println(&quot;------------&quot;);\nVersionRange range2 = VersionRange.createFromVersionSpec(&quot;[2.0.0-M1SN,2.1.2)&quot;);\nSystem.out.println(range2.containsVersion(new DefaultArtifactVersion(&quot;2.1.1-M2&quot;)));\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div>",
      "image": "https://maven.apache.org/images/maventxt_logo_200.gif",
      "date_published": "2021-12-21T05:46:37.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Maven"
      ]
    },
    {
      "title": "Maven基础入门",
      "url": "https://java.springlearn.cn/learn/maven/",
      "id": "https://java.springlearn.cn/learn/maven/",
      "content_html": "<blockquote>\n<p>Maven 翻译为&quot;专家&quot;、&quot;内行&quot;，是 Apache 下的一个纯 Java 开发的开源项目。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。\nMaven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。\nMaven 也可被用于构建和管理各种项目，例如 C#，Ruby，Scala 和其他语言编写的项目。Maven 曾是 Jakarta 项目的子项目，现为由 Apache 软件基金会主持的独立 Apache 项目。</p>\n</blockquote>\n<h2 id=\"maven-默认插件\"> Maven 默认插件</h2>\n<p>已知 Maven 使用 plugin 来执行实际操作的，在默认情况下，Maven 会绑定以下几个插件来完成基本操作。</p>\n<table>\n<thead>\n<tr>\n<th>plugin</th>\n<th>function</th>\n<th>life cycle phase</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>maven-clean-plugin</td>\n<td>清理上一次执行创建的目标文件</td>\n<td>clean</td>\n</tr>\n<tr>\n<td>maven-resources-plugin</td>\n<td>处理源资源文件和测试资源文件</td>\n<td>resources,testResources</td>\n</tr>\n<tr>\n<td>maven-compiler-plugin</td>\n<td>编译源文件和测试源文件</td>\n<td>compile,testCompile</td>\n</tr>\n<tr>\n<td>maven-surefire-plugin</td>\n<td>执行测试文件</td>\n<td>test</td>\n</tr>\n<tr>\n<td>maven-jar-plugin</td>\n<td>创建 jar</td>\n<td>jar</td>\n</tr>\n<tr>\n<td>maven-install-plugin</td>\n<td>安装 jar，将创建生成的 jar 拷贝到 .m2/repository 下面</td>\n<td>install</td>\n</tr>\n<tr>\n<td>maven-deploy-plugin</td>\n<td>发布 jar</td>\n<td>deploy</td>\n</tr>\n</tbody>\n</table>\n<p>如果针对各个 plugin 有特殊配置的话，需要显示指定 plugin 和 属性配置。</p>\n<h2 id=\"maven-生命周期\"> Maven 生命周期</h2>\n<blockquote>\n<p>官网地址: http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html</p>\n</blockquote>\n<p>下面列出了default,clean和site生命周期的所有构建阶段，它们按照指定的时间点之前的顺序执行。</p>\n<p><code>mvn test -X</code> 查看debug日志</p>\n<div><pre><code>[DEBUG] Lifecycle clean -&gt; [pre-clean, clean, post-clean]\n[DEBUG] Lifecycle site -&gt; [pre-site, site, post-site, site-deploy]\n[DEBUG] Lifecycle default -&gt; [validate, initialize, generate-sources, process-sources, generate-resources, process-resources, compile, process-classes, generate-test-sources, process-test-sources, generate-test-resources, process-test-resources, test-compile, process-test-classes, test, prepare-package, package, pre-integration-test, integration-test, post-integration-test, verify, install, deploy]\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"default生命周期\"> default生命周期</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">阶段</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>validate</code></td>\n<td style=\"text-align:left\">验证项目是否正确并且所有必要的信息都可用。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>initialize</code></td>\n<td style=\"text-align:left\">初始化构建状态，例如设置属性或创建目录。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>generate-sources</code></td>\n<td style=\"text-align:left\">生成包含在编译中的任何源代码。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>process-sources</code></td>\n<td style=\"text-align:left\">处理源代码，例如过滤任何值。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>generate-resources</code></td>\n<td style=\"text-align:left\">生成包含在包中的资源。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>process-resources</code></td>\n<td style=\"text-align:left\">将资源复制并处理到目标目录中，准备打包。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>compile</code></td>\n<td style=\"text-align:left\">编译项目的源代码。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>process-classes</code></td>\n<td style=\"text-align:left\">对编译生成的文件进行后处理，例如对 Java 类进行字节码增强。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>generate-test-sources</code></td>\n<td style=\"text-align:left\">生成任何测试源代码以包含在编译中。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>process-test-sources</code></td>\n<td style=\"text-align:left\">处理测试源代码，例如过滤任何值。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>generate-test-resources</code></td>\n<td style=\"text-align:left\">创建用于测试的资源。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>process-test-resources</code></td>\n<td style=\"text-align:left\">将资源复制并处理到测试目标目录中。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>test-compile</code></td>\n<td style=\"text-align:left\">将测试源代码编译到测试目标目录中</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>process-test-classes</code></td>\n<td style=\"text-align:left\">对测试编译生成的文件进行后处理，例如对 Java 类进行字节码增强。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>test</code></td>\n<td style=\"text-align:left\">使用合适的单元测试框架运行测试。这些测试不应该要求打包或部署代码。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>prepare-package</code></td>\n<td style=\"text-align:left\">在实际包装之前执行准备包装所需的任何操作。这通常会导致包的解压缩、处理版本。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>package</code></td>\n<td style=\"text-align:left\">获取编译后的代码并将其打包为其可分发格式，例如 JAR。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>pre-integration-test</code></td>\n<td style=\"text-align:left\">在执行集成测试之前执行所需的操作。这可能涉及诸如设置所需环境之类的事情。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>integration-test</code></td>\n<td style=\"text-align:left\">如有必要，处理并部署包到可以运行集成测试的环境中。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>post-integration-test</code></td>\n<td style=\"text-align:left\">执行集成测试后执行所需的操作。这可能包括清理环境。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>verify</code></td>\n<td style=\"text-align:left\">运行任何检查以验证包裹是否有效并符合质量标准。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>install</code></td>\n<td style=\"text-align:left\">将包安装到本地存储库中，用作本地其他项目的依赖项。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>deploy</code></td>\n<td style=\"text-align:left\">在集成或发布环境中完成，将最终包复制到远程存储库以与其他开发人员和项目共享。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"site生命周期\"> site生命周期</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">阶段</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>pre-site</code></td>\n<td style=\"text-align:left\">在实际项目现场生成之前执行所需的流程</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>site</code></td>\n<td style=\"text-align:left\">生成项目的站点文档</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>post-site</code></td>\n<td style=\"text-align:left\">执行完成站点生成和准备站点部署所需的流程</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>site-deploy</code></td>\n<td style=\"text-align:left\">将生成的站点文档部署到指定的 Web 服务器</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"clean生命周期\"> clean生命周期</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">阶段</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>pre-clean</code></td>\n<td style=\"text-align:left\">在实际项目清理之前执行所需的流程</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>clean</code></td>\n<td style=\"text-align:left\">删除先前构建生成的所有文件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>post-clean</code></td>\n<td style=\"text-align:left\">执行完成项目清理所需的流程</td>\n</tr>\n</tbody>\n</table>\n",
      "date_published": "2021-12-21T05:46:37.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Maven"
      ]
    },
    {
      "title": "自定义插件教程",
      "url": "https://java.springlearn.cn/learn/maven/%E8%87%AA%E5%AE%9A%E4%B9%89maven%E6%8F%92%E4%BB%B6/",
      "id": "https://java.springlearn.cn/learn/maven/%E8%87%AA%E5%AE%9A%E4%B9%89maven%E6%8F%92%E4%BB%B6/",
      "content_html": "<blockquote>\n<p>Maven插件官网: https://maven.apache.org/guides/plugin/guide-java-plugin-development.html</p>\n</blockquote>\n<div><p>前言介绍</p>\n<p>前面我们大概了解了Maven的生命周期,本篇主要是学习如何在Maven的生命周期内指定一些插件的执行。主要分为3个步骤。<br>\n<i>Not supported content</i> 第一个步骤先了解学习下Maven官方的命名规则建议。<br>\n<i>Not supported content</i> 第二个步骤根据命名规则,我们自定义一个插件 Mojo。<br>\n<i>Not supported content</i> 第三个部分学习如何向插件内 Mojo 注入一些，Maven的配置和自定义的配置信息。<br></p>\n</div>\n<h2 id=\"一、命名规范\"> 一、命名规范</h2>\n<ul>\n<li>官方的命名规则: <code>maven-&lt;yourplugin&gt;-plugin</code>（注意“Maven”位于插件名称的开头)</li>\n<li>个人自定义建议: <code>&lt;yourplugin&gt;-maven-plugin</code>（注意“Maven”位于插件名称的中间)</li>\n</ul>\n<p>个人不得使用官方命名规则,因为它是 Apache Maven 团队使用的插件保留命名模式。\n如果个人使用这种命名模式是会侵犯了 Apache Maven 商标。<code>org.apache.maven.plugins</code></p>\n<h2 id=\"二、自定义插件\"> 二、自定义插件</h2>\n<p>当我们使用idea创建一个maven插件,里面已经为我们创建了一个Mojo。定义Mojo首先要集成\n<code>AbstractMojo</code> 抽象类。另外要声明这个Mojo的名字和Maven执行阶段。有两种方法声明</p>\n<p><a href=\"https://maven.apache.org/developers/mojo-api-specification.html\" target=\"_blank\" rel=\"noopener noreferrer\">mojo-api-specification</a></p>\n<h3 id=\"_2-1-使用javadoc的方式声明\"> 2.1 使用javadoc的方式声明</h3>\n<p>因为maven诞生比较早,当时没有注解。所以使用了javadoc。</p>\n<p><a href=\"https://maven.apache.org/plugin-tools/maven-plugin-tools-java/index.html\" target=\"_blank\" rel=\"noopener noreferrer\">Maven Plugin Tool for Java Annotated with Mojo Javadoc Tags</a></p>\n<div><pre><code><span>/**\n* Goal which touches a timestamp file.\n*\n* @goal touch\n* @phase process-sources\n*/</span>\n<span>public</span> <span>class</span> <span>MyMojo</span> <span>extends</span> <span>AbstractMojo</span> <span>{</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>execute</span><span>(</span><span>)</span>\n    <span>throws</span> <span>MojoExecutionException</span> <span>{</span>\n    <span>getLog</span><span>(</span><span>)</span><span>.</span><span>info</span><span>(</span><span>\"我是一个Maven插件: FirstDemo\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>指定mvn install 安装到本地仓库,然后找个项目执行一下。</p>\n<div><pre><code>[INFO] Scanning for projects...\n[INFO]\n[INFO] ---------------------&lt; org.example:nobug-learn-01 &gt;---------------------\n[INFO] Building nobug-learn-01 1.0-SNAPSHOT\n[INFO] --------------------------------[ jar ]---------------------------------\n[INFO]\n[INFO] --- firstdemo-maven-plugin:1.0-SNAPSHOT:touch (default-cli) @ nobug-learn-01 ---\n[INFO] 我是一个Maven插件: FirstDemo\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time:  0.296 s\n[INFO] Finished at: 2021-11-26T17:00:32+08:00\n[INFO] ------------------------------------------------------------------------\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id=\"_2-2-使用注解的方式\"> 2.2 使用注解的方式</h3>\n<p>前面使用javadoc的形式来定义缺失有点显得过时了,现在我们可以使用注解的方式来定义插件。但是首先需要引入注解包\n下面这些依赖直接拷贝进去就行，注意如果你的maven版本太低，可能会识别不了注解。所以建议制定下构建插件的maven为\n3.5</p>\n<p><a href=\"https://maven.apache.org/plugin-tools/maven-plugin-tools-annotations/index.html\" target=\"_blank\" rel=\"noopener noreferrer\">Maven Plugin Tools Java5 Annotations</a></p>\n<p>使用 @Mojo 注解定义插件, Mojo中有一个非常重要的属性需要知道下。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">属性值</th>\n<th style=\"text-align:center\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">name</td>\n<td style=\"text-align:center\">插件名称</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">defaultPhase</td>\n<td style=\"text-align:center\">绑定的声明周期</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">requiresDependencyResolution</td>\n<td style=\"text-align:center\">在插件运行之前就将所有的依赖模块给构建好</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">requiresDependencyCollection</td>\n<td style=\"text-align:center\">这个注解不会解析依赖项的文件,只分析依赖关系</td>\n</tr>\n</tbody>\n</table>\n<p>建议requiresDependencyCollection是要指定的,不然你得到的maven插件中,是不会分析依赖关系的。</p>\n<p><mark>下面的依赖建议你直接拷贝使用</mark></p>\n<ul>\n<li>注意第一行一定不能忘记</li>\n</ul>\n<div><div><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><pre><code>    <span><span><span>&lt;</span>packaging</span><span>></span></span>maven-plugin<span><span><span>&lt;/</span>packaging</span><span>></span></span> \n    <span><span><span>&lt;</span>properties</span><span>></span></span>\n        <span><span><span>&lt;</span>dep.maven-api.version</span><span>></span></span>3.5.2<span><span><span>&lt;/</span>dep.maven-api.version</span><span>></span></span>\n    <span><span><span>&lt;/</span>properties</span><span>></span></span>\n    <span><span><span>&lt;</span>dependencies</span><span>></span></span>\n        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>org.apache.maven<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>maven-plugin-api<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n            <span><span><span>&lt;</span>version</span><span>></span></span>${dep.maven-api.version}<span><span><span>&lt;/</span>version</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>org.apache.maven<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>maven-model<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n            <span><span><span>&lt;</span>version</span><span>></span></span>${dep.maven-api.version}<span><span><span>&lt;/</span>version</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>org.apache.maven.plugin-tools<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>maven-plugin-annotations<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n            <span><span><span>&lt;</span>version</span><span>></span></span>${dep.maven-api.version}<span><span><span>&lt;/</span>version</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>org.apache.maven.plugins<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>maven-plugin-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n            <span><span><span>&lt;</span>version</span><span>></span></span>3.5<span><span><span>&lt;/</span>version</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>junit<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>junit<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n            <span><span><span>&lt;</span>version</span><span>></span></span>3.8.1<span><span><span>&lt;/</span>version</span><span>></span></span>\n            <span><span><span>&lt;</span>scope</span><span>></span></span>test<span><span><span>&lt;/</span>scope</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>org.apache.maven<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>maven-core<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n            <span><span><span>&lt;</span>version</span><span>></span></span>3.8.5<span><span><span>&lt;/</span>version</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n    <span><span><span>&lt;/</span>dependencies</span><span>></span></span>\n   <span>&lt;!--注意这一步也非常重要，否则如果你系统的maven版本太低，就可能无法识别maven的注解--></span>\n    <span><span><span>&lt;</span>build</span><span>></span></span>\n    <span><span><span>&lt;</span>plugins</span><span>></span></span>\n     <span><span><span>&lt;</span>plugin</span><span>></span></span>\n      <span><span><span>&lt;</span>groupId</span><span>></span></span>org.apache.maven.plugins<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n      <span><span><span>&lt;</span>artifactId</span><span>></span></span>maven-plugin-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n      <span><span><span>&lt;</span>version</span><span>></span></span>3.5<span><span><span>&lt;/</span>version</span><span>></span></span>\n     <span><span><span>&lt;/</span>plugin</span><span>></span></span>\n    <span><span><span>&lt;/</span>plugins</span><span>></span></span>\n    <span><span><span>&lt;/</span>build</span><span>></span></span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br></div></div><p>Mojo类</p>\n<div><pre><code><span>@Mojo</span><span>(</span>name <span>=</span> <span>\"myMojo\"</span><span>,</span> defaultPhase <span>=</span> <span>LifecyclePhase</span><span>.</span>VALIDATE<span>,</span> threadSafe <span>=</span> <span>true</span><span>)</span>\n<span>@Execute</span><span>(</span>phase <span>=</span> <span>LifecyclePhase</span><span>.</span>VALIDATE<span>)</span>\n<span>public</span> <span>class</span> <span>MyMojo</span>\n        <span>extends</span> <span>AbstractMojo</span> <span>{</span>\n\n    <span>public</span> <span>void</span> <span>execute</span><span>(</span><span>)</span>\n            <span>throws</span> <span>MojoExecutionException</span> <span>{</span>\n        <span>getLog</span><span>(</span><span>)</span><span>.</span><span>info</span><span>(</span><span>\"我是一个Maven插件: FirstDemo\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>注意: 自定义的maven插件是没办法直接就执行的，一定要在build中指定要执行的mojo。如下代码。</p>\n<div><pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;org.example&lt;/groupId&gt;\n    &lt;artifactId&gt;firstdemo-maven-plugin&lt;/artifactId&gt;\n    &lt;version&gt;1.2-SNAPSHOT&lt;/version&gt;\n    &lt;executions&gt;\n        &lt;execution&gt;\n        &lt;!--                        如果插件中没有生命周期,这里要进行声明。如果插件中声明了就不用写这个--&gt;\n         &lt;phase&gt;clean&lt;/phase&gt;\n         &lt;goals&gt;\n         &lt;!--                            自定义的插件,不会自动执行,要在这里进行声明--&gt;\n            &lt;goal&gt;myMojo&lt;/goal&gt;\n        &lt;/goals&gt;\n        &lt;/execution&gt;\n    &lt;/executions&gt;\n&lt;/plugin&gt;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h2 id=\"三、参数注入\"> 三、参数注入</h2>\n<p>maven插件中是可以自定以参数的,通过配置然后传递到Mojo类中。 主要使用 <code>@Parameter</code> 注解完成，下面是详细介绍。</p>\n<p>主要使用<code>@Parameter</code>进行定义。</p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>name</td>\n<td>声明参数的名字</td>\n</tr>\n<tr>\n<td>alias</td>\n<td>声明一个别名</td>\n</tr>\n<tr>\n<td>property</td>\n<td>从pom的propertys标签中读取,或是-Dtest=123 使用-D添加到命令行</td>\n</tr>\n<tr>\n<td>defaultValue</td>\n<td>字段的默认值</td>\n</tr>\n<tr>\n<td>required</td>\n<td>是否必须</td>\n</tr>\n<tr>\n<td>readonly</td>\n<td>是否只读</td>\n</tr>\n</tbody>\n</table>\n<p>字段的类型可以是多样的。</p>\n<h2 id=\"_3-1-外部参数注入\"> 3.1 外部参数注入</h2>\n<h3 id=\"_3-1-1-boolean类型\"> 3.1.1 boolean类型</h3>\n<p>这包括类型为 boolean 和 Boolean 的变量。 读取配置时，文本“true”会导致参数设置为 true，所有其他文本都会导致参数设置为 false。 例子：</p>\n<div><pre><code>    /**\n     * My boolean.\n     */\n    @Parameter\n    private boolean myBoolean;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><code>&lt;myBoolean&gt;true&lt;/myBoolean&gt;</code></p>\n<h3 id=\"_3-1-2-integer类型\"> 3.1.2 Integer类型</h3>\n<p>这包括类型为 byte、Byte、int、Integer、long、Long、short 和 Short 的变量。 读取配置时，使用 Integer.parseInt() 或相应类的 valueOf() 方法将 XML 文件中的文本转换为整数值。 这意味着字符串必须是有效的十进制整数值，仅由数字 0 到 9 组成，前面有一个可选的 - 表示负值。 例子：</p>\n<div><pre><code>    /**\n     * My Integer.\n     */\n    @Parameter\n    private Integer myInteger;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><code>&lt;myInteger&gt;10&lt;/myInteger&gt;</code></p>\n<h3 id=\"_3-1-3-double类型\"> 3.1.3 Double类型</h3>\n<p>这包括类型为 double、Double、float 和 Float 的变量。 读取配置时，XML 文件中的文本使用相应类的 valueOf() 方法转换为二进制形式。</p>\n<div><pre><code>    /**\n     * My Double.\n     */\n    @Parameter\n    private Double myDouble;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><code>&lt;myDouble&gt;1.0&lt;/myDouble&gt;</code></p>\n<h3 id=\"_3-1-4-date类型\"> 3.1.4 Date类型</h3>\n<p>这包括类型为日期的变量。 读取配置时，XML 文件中的文本使用以下日期格式之一进行转换：“yyyy-MM-dd HH:mm:ss.S a”（示例日期为“2005-10-06 2:22 :55.1 PM”）或“yyyy-MM-dd HH:mm:ssa”（示例日期为“2005-10-06 2:22:55PM”）。 请注意，解析是使用 DateFormat.parse() 完成的，它允许对格式进行一些宽容。 如果该方法可以解析指定的日期和时间，即使它与上面的模式不完全匹配，它也会这样做。 例子：</p>\n<div><pre><code>    /**\n     * My Date.\n     */\n    @Parameter\n    private Date myDate;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><code>&lt;myDate&gt;2005-10-06 2:22:55.1 PM&lt;/myDate&gt;</code></p>\n<h3 id=\"_3-1-5-file类型\"> 3.1.5 File类型</h3>\n<p>这包括类型为 File 的变量。 读取配置时，XML 文件中的文本用作所需文件或目录的路径。 如果路径是相对的（不以 / 或 C: 之类的驱动器号开头），则该路径是相对于包含 POM 的目录。 例子：</p>\n<div><pre><code>    /**\n     * My File.\n     */\n    @Parameter\n    private File myFile;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><code>&lt;myFile&gt;c:\\temp&lt;/myFile&gt;</code></p>\n<h3 id=\"_3-1-6-url\"> 3.1.6 URL</h3>\n<p>这包括变量类型的 URL。 读取配置时，使用 XML 文件中的文本作为 URL。 格式必须遵循 RFC 2396 准则，并且看起来像任何 Web 浏览器 URL (scheme://host:port/path/to/file)。 转换 URL 时，对 URL 任何部分的内容都没有限制。</p>\n<div><pre><code>    /**\n     * My URL.\n     */\n    @Parameter\n    private URL myURL;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><code>&lt;myURL&gt;http://maven.apache.org&lt;/myURL&gt;</code></p>\n<h3 id=\"_3-1-7-枚举\"> 3.1.7 枚举</h3>\n<p>也可以使用枚举类型参数。 首先你需要定义你的枚举类型，然后你可以在参数定义中使用枚举类型：</p>\n<div><pre><code>    public enum Color {\n      GREEN,\n      RED,\n      BLUE\n    }\n\n    /**\n     * My Enum\n     */\n    @Parameter\n    private Color myColor;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p><code>&lt;myColor&gt;GREEN&lt;/myColor&gt;</code></p>\n<h3 id=\"_3-1-8-arrays\"> 3.1.8 Arrays</h3>\n<div><pre><code>    /**\n     * My Array.\n     */\n    @Parameter\n    private String[] myArray;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code>&lt;myArray&gt;\n  &lt;param&gt;value1&lt;/param&gt;\n  &lt;param&gt;value2&lt;/param&gt;\n&lt;/myArray&gt;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"_3-1-9-collections\"> 3.1.9 Collections</h3>\n<p>此类别涵盖任何实现 java.util.Collection 的类，例如 ArrayList 或 HashSet。 这些参数是通过多次指定参数来配置的，就像数组一样。 例子：</p>\n<div><pre><code>   /**\n     * My List.\n     */\n    @Parameter\n    private List myList;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code>&lt;myList&gt;\n  &lt;param&gt;value1&lt;/param&gt;\n  &lt;param&gt;value2&lt;/param&gt;\n&lt;/myList&gt;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"_3-1-10-maps\"> 3.1.10 Maps</h3>\n<p>此类别涵盖任何实现 java.util.Map（例如 HashMap）但未实现 java.util.Properties 的类。 这些参数是通过在参数配置中以 <key>value</key> 形式包含 XML 标签来配置的。 例子：</p>\n<div><pre><code>    /**\n     * My Map.\n     */\n    @Parameter\n    private Map myMap;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code>&lt;myMap&gt;\n  &lt;key1&gt;value1&lt;/key1&gt;\n  &lt;key2&gt;value2&lt;/key2&gt;\n&lt;/myMap&gt;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"_3-1-11-properties\"> 3.1.11 Properties</h3>\n<p>此类别涵盖实现 java.util.Properties 的任何地图。 这些参数是通过在参数配置中以 <property><name>myName</name> <value>myValue</value> </property> 形式包含 XML 标记来配置的。 例子：</p>\n<div><pre><code>    /**\n     * My Properties.\n     */\n    @Parameter\n    private Properties myProperties;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code>&lt;myProperties&gt;\n  &lt;property&gt;\n    &lt;name&gt;propertyName1&lt;/name&gt;\n    &lt;value&gt;propertyValue1&lt;/value&gt;\n  &lt;property&gt;\n  &lt;property&gt;\n    &lt;name&gt;propertyName2&lt;/name&gt;\n    &lt;value&gt;propertyValue2&lt;/value&gt;\n  &lt;property&gt;\n&lt;/myProperties&gt;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id=\"_3-1-12-object\"> 3.1.12 Object</h3>\n<div><pre><code>    /**\n     * My Object.\n     */\n    @Parameter\n    private MyObject myObject;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code>&lt;myObject&gt;\n  &lt;myField&gt;test&lt;/myField&gt;\n&lt;/myObject&gt;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"_3-2-maven组件注入\"> 3.2 Maven组件注入</h2>\n<h3 id=\"_3-2-1-mavensession\"> 3.2.1 MavenSession</h3>\n<p>包含Maven执行请求对象和结果,当前模块和总模块。和依赖模块信息等信息</p>\n<div><pre><code>    @Parameter(defaultValue = &quot;${session}&quot;, readonly = true)\n    private MavenSession session;\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"_3-2-2-mavenproject\"> 3.2.2 MavenProject</h3>\n<p>当前模块，及模块依赖</p>\n<div><pre><code>    @Parameter(defaultValue = &quot;${project}&quot;, readonly = true)\n    private MavenProject project;\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"_3-2-3-mojoexecution\"> 3.2.3 MojoExecution</h3>\n<div><pre><code>    @Parameter(defaultValue = &quot;${mojoExecution}&quot;, readonly = true)\n    private MojoExecution mojo;\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"_3-2-4-plugindescriptor\"> 3.2.4 PluginDescriptor</h3>\n<div><pre><code>    @Parameter(defaultValue = &quot;${plugin}&quot;, readonly = true)\n    private PluginDescriptor plugin;\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"_3-2-5-settings\"> 3.2.5 Settings</h3>\n<div><pre><code>    /**\n     * maven的配置信息\n     */\n    @Parameter(defaultValue = &quot;${settings}&quot;, readonly = true)\n    private Settings settings;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"_3-2-6-项目路径\"> 3.2.6. 项目路径</h3>\n<div><pre><code>    /**\n     * 项目路径\n     */\n    @Parameter(defaultValue = &quot;${project.basedir}&quot;, readonly = true)\n    private File basedir;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"_3-2-7-编译后目录\"> 3.2.7. 编译后目录</h3>\n<div><pre><code>    /**\n     * 编译后目录\n     */\n    @Parameter(defaultValue = &quot;${project.build.directory}&quot;, readonly = true)\n    private File target;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"四、插件执行\"> 四、插件执行</h2>\n<blockquote>\n<p>类似问题: https://www.coder.work/article/3592058</p>\n</blockquote>\n<div><p>注意</p>\n<p>我们自己开发的插件,要想执行必须要在项目的pom文件中来指定,插件不会默认来进行执行的。如下。</p>\n</div>\n<div><pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;org.example&lt;/groupId&gt;\n    &lt;artifactId&gt;firstdemo-maven-plugin&lt;/artifactId&gt;\n    &lt;version&gt;1.2-SNAPSHOT&lt;/version&gt;\n    &lt;executions&gt;\n        &lt;execution&gt;\n        &lt;!--                        如果插件中没有生命周期,这里要进行声明。如果插件中声明了就不用写这个--&gt;\n         &lt;phase&gt;clean&lt;/phase&gt;\n         &lt;goals&gt;\n         &lt;!--                            自定义的插件,不会自动执行,要在这里进行声明--&gt;\n            &lt;goal&gt;myMojo&lt;/goal&gt;\n        &lt;/goals&gt;\n        &lt;/execution&gt;\n    &lt;/executions&gt;\n&lt;/plugin&gt;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><ul>\n<li><input type=\"checkbox\" checked=\"checked\" disabled=\"disabled\" id=\"task-item-0\"><label for=\"task-item-0\"> phase 如果插件中没有生命周期,这里要进行声明。如果插件中声明了就不用写这个</label></li>\n<li><input type=\"checkbox\" checked=\"checked\" disabled=\"disabled\" id=\"task-item-1\"><label for=\"task-item-1\"> goal  自定义的插件,不会自动执行,要在这里进行声明</label></li>\n</ul>\n<h3 id=\"命令行执行\"> 命令行执行</h3>\n<ul>\n<li>\n<p><code>mvn org.example:firstdemo-maven-plugin:1.4-SNAPSHOT:myMojo</code></p>\n</li>\n<li>\n<p><code>mvn ${groupId}:${artifactId}:${version}:${mojoName}</code></p>\n</li>\n</ul>\n",
      "date_published": "2021-12-21T05:46:37.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Maven"
      ]
    },
    {
      "title": "第13篇:Mybatis权限插件设计",
      "url": "https://java.springlearn.cn/learn/mybatis/AuthPlugin/",
      "id": "https://java.springlearn.cn/learn/mybatis/AuthPlugin/",
      "content_html": "<PageBanner/>\n",
      "date_published": "2022-03-30T15:42:58.000Z",
      "date_modified": "2022-07-12T12:38:40.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Mybatis"
      ]
    },
    {
      "title": "第11篇:Mybatis查询限制插件设计",
      "url": "https://java.springlearn.cn/learn/mybatis/LimitPlugin/",
      "id": "https://java.springlearn.cn/learn/mybatis/LimitPlugin/",
      "content_html": "<PageBanner/>\n<h2 id=\"一、实现目标\"> 一、实现目标</h2>\n<p>目标: 针对Mysql数据库实现动态修改sql的能力，增加上limit的查询限制。</p>\n<h2 id=\"二、知识扩展\"> 二、知识扩展</h2>\n<p>首先下了解下有那些的分页技术。</p>\n<h2 id=\"_2-1-物理分页\"> 2.1 物理分页</h2>\n<p>所谓物理分页是数据库直接提供了分页的预发, 如mysql的limit,oracle的rownum,好处是效率高;不好的地方就是不同数据库有不同的语法。</p>\n<h2 id=\"_2-2-逻辑分页\"> 2.2 逻辑分页</h2>\n<p>逻辑分页利用游标分页，好处是所有数据库都统一，坏处就是效率低。</p>\n<h2 id=\"二、实现分析\"> 二、实现分析</h2>\n<p>首先我们先易后难,先说逻辑分页。</p>\n<h2 id=\"_2-1-逻辑分页\"> 2.1 逻辑分页</h2>\n<p>首先我们看下Mybatis中当执行查询时候的代码,当返回是list时候。会走到executeForMany方法中。\n该方法主要判断是否需要进行逻辑分页。代码不难,看就完了。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>MapperMethod</span> <span>{</span>\n    <span>public</span> <span>Object</span> <span>execute</span><span>(</span><span>SqlSession</span> sqlSession<span>,</span> <span>Object</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>.</span><span>.</span><span>.</span><span>.</span>\n        <span>case</span> SELECT<span>:</span>\n        <span>if</span> <span>(</span>method<span>.</span><span>returnsVoid</span><span>(</span><span>)</span> <span>&amp;&amp;</span> method<span>.</span><span>hasResultHandler</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n          <span>executeWithResultHandler</span><span>(</span>sqlSession<span>,</span> args<span>)</span><span>;</span>\n          result <span>=</span> <span>null</span><span>;</span>\n        <span>}</span> <span>else</span> <span>if</span> <span>(</span>method<span>.</span><span>returnsMany</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n          result <span>=</span> <span>executeForMany</span><span>(</span>sqlSession<span>,</span> args<span>)</span><span>;</span>\n        <span>}</span>  \n        <span>.</span><span>.</span><span>.</span>\n    <span>}</span>\n    \n    <span>private</span> <span><span>&lt;</span><span>E</span><span>></span></span> <span>Object</span> <span>executeForMany</span><span>(</span><span>SqlSession</span> sqlSession<span>,</span> <span>Object</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>List</span><span><span>&lt;</span><span>E</span><span>></span></span> result<span>;</span>\n        <span>// 参数解析</span>\n        <span>Object</span> param <span>=</span> method<span>.</span><span>convertArgsToSqlCommandParam</span><span>(</span>args<span>)</span><span>;</span>\n        <span>// 判断是否逻辑分页了。</span>\n        <span>if</span> <span>(</span>method<span>.</span><span>hasRowBounds</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n          <span>RowBounds</span> rowBounds <span>=</span> method<span>.</span><span>extractRowBounds</span><span>(</span>args<span>)</span><span>;</span>\n          result <span>=</span> sqlSession<span>.</span><span>selectList</span><span>(</span>command<span>.</span><span>getName</span><span>(</span><span>)</span><span>,</span> param<span>,</span> rowBounds<span>)</span><span>;</span>\n        <span>}</span> <span>else</span> <span>{</span>\n          result <span>=</span> sqlSession<span>.</span><span>selectList</span><span>(</span>command<span>.</span><span>getName</span><span>(</span><span>)</span><span>,</span> param<span>)</span><span>;</span>\n        <span>}</span>\n        <span>.</span><span>.</span><span>.</span><span>.</span>   \n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>hasRowBounds 可以判断当前的方法是否要走逻辑分页。\nMethodSignature#hasRowBounds的逻辑也比较简单,就是判断方法入参中是否包含了RowBounds,如下代码。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>MethodSignature</span><span>{</span>\n    <span>public</span> <span>MethodSignature</span><span>(</span><span>Configuration</span> configuration<span>,</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> mapperInterface<span>,</span> <span>Method</span> method<span>)</span> <span>{</span>\n      <span>this</span><span>.</span>rowBoundsIndex <span>=</span> <span>getUniqueParamIndex</span><span>(</span>method<span>,</span> <span>RowBounds</span><span>.</span><span>class</span><span>)</span><span>;</span>\n      <span>this</span><span>.</span>resultHandlerIndex <span>=</span> <span>getUniqueParamIndex</span><span>(</span>method<span>,</span> <span>ResultHandler</span><span>.</span><span>class</span><span>)</span><span>;</span>\n      <span>this</span><span>.</span>paramNameResolver <span>=</span> <span>new</span> <span>ParamNameResolver</span><span>(</span>configuration<span>,</span> method<span>)</span><span>;</span>\n    <span>}</span>\n    <span>private</span> <span>Integer</span> <span>getUniqueParamIndex</span><span>(</span><span>Method</span> method<span>,</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> paramType<span>)</span> <span>{</span>\n      <span>Integer</span> index <span>=</span> <span>null</span><span>;</span>\n      <span>final</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span><span>[</span><span>]</span> argTypes <span>=</span> method<span>.</span><span>getParameterTypes</span><span>(</span><span>)</span><span>;</span>\n      <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> argTypes<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>paramType<span>.</span><span>isAssignableFrom</span><span>(</span>argTypes<span>[</span>i<span>]</span><span>)</span><span>)</span> <span>{</span>\n          <span>if</span> <span>(</span>index <span>==</span> <span>null</span><span>)</span> <span>{</span>\n            index <span>=</span> i<span>;</span>\n          <span>}</span> <span>else</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>BindingException</span><span>(</span>method<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\" cannot have multiple \"</span> <span>+</span> paramType<span>.</span><span>getSimpleName</span><span>(</span><span>)</span> <span>+</span> <span>\" parameters\"</span><span>)</span><span>;</span>\n          <span>}</span>\n        <span>}</span>\n      <span>}</span>\n      <span>return</span> index<span>;</span>\n    <span>}</span>\n    <span>public</span> <span>boolean</span> <span>hasRowBounds</span><span>(</span><span>)</span> <span>{</span>\n      <span>return</span> rowBoundsIndex <span>!=</span> <span>null</span><span>;</span>\n    <span>}</span>\n<span>}</span>    \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>如果方法入参中有RowBounds则会逻辑分页,如果没有指定则使用默认RowBounds即不限制数量。说不限制其实也限制了，\n就是Integer.MAX_VALUE 😂</p>\n<div><pre><code><span>public</span> <span>class</span> <span>DefaultSqlSession</span> <span>implements</span> <span>SqlSession</span> <span>{</span>\n  <span>@Override</span>\n  <span>public</span> <span><span>&lt;</span><span>E</span><span>></span></span> <span>List</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>selectList</span><span>(</span><span>String</span> statement<span>,</span> <span>Object</span> parameter<span>)</span> <span>{</span>\n    <span>return</span> <span>this</span><span>.</span><span>selectList</span><span>(</span>statement<span>,</span> parameter<span>,</span> <span>RowBounds</span><span>.</span>DEFAULT<span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>  \n\n<span>public</span> <span>class</span> <span>RowBounds</span> <span>{</span>\n\n  <span>public</span> <span>static</span> <span>final</span> <span>int</span> NO_ROW_OFFSET <span>=</span> <span>0</span><span>;</span>\n  <span>public</span> <span>static</span> <span>final</span> <span>int</span> NO_ROW_LIMIT <span>=</span> <span>Integer</span><span>.</span>MAX_VALUE<span>;</span>\n  <span>public</span> <span>static</span> <span>final</span> <span>RowBounds</span> DEFAULT <span>=</span> <span>new</span> <span>RowBounds</span><span>(</span><span>)</span><span>;</span>\n\n  <span>private</span> <span>final</span> <span>int</span> offset<span>;</span>\n  <span>private</span> <span>final</span> <span>int</span> limit<span>;</span>\n\n  <span>public</span> <span>RowBounds</span><span>(</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>offset <span>=</span> NO_ROW_OFFSET<span>;</span>\n    <span>this</span><span>.</span>limit <span>=</span> NO_ROW_LIMIT<span>;</span>\n  <span>}</span>\n<span>}</span> \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>那么逻辑分页的处理游标的地方在哪里呢? 因为前面我们已经对Mybatis的所有执行流程分析过了,所以这个时候我们应该有自己的思考了。\n应该是在jdbc执行后 处理返回数据的时候，那么应该就是在DefaultResultSetHandler中。直接看源码吧。</p>\n<ul>\n<li>line(4-16) 用于处理偏移量, 如从第四页开始,则执行next跳过前三行。</li>\n<li>line(17-19) 处理限制数量，如最大查询5行，如果返回值中大于5就返回false就不在添加数据。</li>\n<li>line(25) 填过偏移量</li>\n<li>line(26) 判断limit</li>\n</ul>\n<div><div><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br><br><br></div><pre><code>\n<span>public</span> <span>class</span> <span>DefaultResultSetHandler</span> <span>implements</span> <span>ResultSetHandler</span> <span>{</span>\n \n  <span>private</span> <span>void</span> <span>skipRows</span><span>(</span><span>ResultSet</span> rs<span>,</span> <span>RowBounds</span> rowBounds<span>)</span> <span>throws</span> <span>SQLException</span> <span>{</span>\n    <span>if</span> <span>(</span>rs<span>.</span><span>getType</span><span>(</span><span>)</span> <span>!=</span> <span>ResultSet</span><span>.</span>TYPE_FORWARD_ONLY<span>)</span> <span>{</span>\n      <span>if</span> <span>(</span>rowBounds<span>.</span><span>getOffset</span><span>(</span><span>)</span> <span>!=</span> <span>RowBounds</span><span>.</span>NO_ROW_OFFSET<span>)</span> <span>{</span>\n        rs<span>.</span><span>absolute</span><span>(</span>rowBounds<span>.</span><span>getOffset</span><span>(</span><span>)</span><span>)</span><span>;</span>\n      <span>}</span>\n    <span>}</span> <span>else</span> <span>{</span>\n      <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> rowBounds<span>.</span><span>getOffset</span><span>(</span><span>)</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n        <span>if</span> <span>(</span><span>!</span>rs<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n          <span>break</span><span>;</span>\n        <span>}</span>\n      <span>}</span>\n    <span>}</span>\n  <span>}</span>\n  <span>private</span> <span>boolean</span> <span>shouldProcessMoreRows</span><span>(</span><span>ResultContext</span><span><span>&lt;</span><span>?</span><span>></span></span> context<span>,</span> <span>RowBounds</span> rowBounds<span>)</span> <span>{</span>\n    <span>return</span> <span>!</span>context<span>.</span><span>isStopped</span><span>(</span><span>)</span> <span>&amp;&amp;</span> context<span>.</span><span>getResultCount</span><span>(</span><span>)</span> <span>&lt;</span> rowBounds<span>.</span><span>getLimit</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span>\n  \n  <span>private</span> <span>void</span> <span>handleRowValuesForSimpleResultMap</span><span>(</span><span>ResultSetWrapper</span> rsw<span>,</span> <span>ResultMap</span> resultMap<span>,</span> <span>ResultHandler</span><span><span>&lt;</span><span>?</span><span>></span></span> resultHandler<span>,</span> <span>RowBounds</span> rowBounds<span>,</span> <span>ResultMapping</span> parentMapping<span>)</span>\n      <span>throws</span> <span>SQLException</span> <span>{</span>\n    <span>DefaultResultContext</span><span><span>&lt;</span><span>Object</span><span>></span></span> resultContext <span>=</span> <span>new</span> <span>DefaultResultContext</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n    <span>ResultSet</span> resultSet <span>=</span> rsw<span>.</span><span>getResultSet</span><span>(</span><span>)</span><span>;</span>\n    <span>skipRows</span><span>(</span>resultSet<span>,</span> rowBounds<span>)</span><span>;</span>\n    <span>while</span> <span>(</span><span>shouldProcessMoreRows</span><span>(</span>resultContext<span>,</span> rowBounds<span>)</span> <span>&amp;&amp;</span> <span>!</span>resultSet<span>.</span><span>isClosed</span><span>(</span><span>)</span> <span>&amp;&amp;</span> resultSet<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n      <span>ResultMap</span> discriminatedResultMap <span>=</span> <span>resolveDiscriminatedResultMap</span><span>(</span>resultSet<span>,</span> resultMap<span>,</span> <span>null</span><span>)</span><span>;</span>\n      <span>Object</span> rowValue <span>=</span> <span>getRowValue</span><span>(</span>rsw<span>,</span> discriminatedResultMap<span>,</span> <span>null</span><span>)</span><span>;</span>\n      <span>storeObject</span><span>(</span>resultHandler<span>,</span> resultContext<span>,</span> rowValue<span>,</span> parentMapping<span>,</span> resultSet<span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>  \n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><p>好了，知道了这些我们就开始分析我们要如何使用插件了吧。对就是拦截ResultSetHandler,利用反射的方法,将默认的\nRowBounds添加limit限制。</p>\n<div><pre><code>    <span>/**\n     * 那我们就拦截处理结果.\n     * 启用反射修改默认的RowBounds limit属性\n     */</span>\n    <span>@Intercepts</span><span>(</span><span>@Signature</span><span>(</span>type <span>=</span> <span>ResultSetHandler</span><span>.</span><span>class</span><span>,</span> method <span>=</span> <span>\"handleResultSets\"</span><span>,</span> args <span>=</span> <span>{</span><span>Statement</span><span>.</span><span>class</span><span>}</span><span>)</span><span>)</span>\n    <span>public</span> <span>static</span> <span>class</span> <span>DefaultRowBoundsHandler</span> <span>implements</span> <span>Interceptor</span> <span>{</span>\n\n        <span>@Override</span>\n        <span>public</span> <span>Object</span> <span>intercept</span><span>(</span><span>Invocation</span> invocation<span>)</span> <span>throws</span> <span>Throwable</span> <span>{</span>\n            <span>Object</span> target <span>=</span> invocation<span>.</span><span>getTarget</span><span>(</span><span>)</span><span>;</span>\n            <span>Field</span> rowBounds <span>=</span> target<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getDeclaredField</span><span>(</span><span>\"rowBounds\"</span><span>)</span><span>;</span>\n            rowBounds<span>.</span><span>setAccessible</span><span>(</span><span>true</span><span>)</span><span>;</span>\n            <span>RowBounds</span> originRowBounds <span>=</span> <span>(</span><span>RowBounds</span><span>)</span> rowBounds<span>.</span><span>get</span><span>(</span>target<span>)</span><span>;</span>\n            <span>// 如果是默认的则替换下</span>\n            <span>if</span> <span>(</span>originRowBounds<span>.</span><span>equals</span><span>(</span><span>RowBounds</span><span>.</span>DEFAULT<span>)</span><span>)</span> <span>{</span>\n                <span>MetaObject</span> metaObject <span>=</span> <span>MetaObject</span><span>.</span><span>forObject</span><span>(</span>originRowBounds<span>,</span> <span>new</span> <span>DefaultObjectFactory</span><span>(</span><span>)</span><span>,</span> <span>new</span> <span>DefaultObjectWrapperFactory</span><span>(</span><span>)</span><span>,</span> <span>new</span> <span>DefaultReflectorFactory</span><span>(</span><span>)</span><span>)</span><span>;</span>\n                metaObject<span>.</span><span>setValue</span><span>(</span><span>\"limit\"</span><span>,</span> <span>2</span><span>)</span><span>;</span>\n            <span>}</span>\n            <span>return</span> invocation<span>.</span><span>proceed</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>limitAddRowBounds</span><span>(</span><span>)</span><span>{</span>\n        <span>// 读取配置信息(为什么路径前不用加/,因为是相对路径。maven编译后的资源文件和class文件都是在一个包下,所以不用加/就是当前包目录)</span>\n        <span>InputStream</span> mapperInputStream <span>=</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getContextClassLoader</span><span>(</span><span>)</span><span>.</span><span>getResourceAsStream</span><span>(</span><span>\"example01/mybatisConfig.xml\"</span><span>)</span><span>;</span>\n        <span>// 生成SqlSession工厂,SqlSession从名字上看就是,跟数据库交互的会话信息,负责将sql提交到数据库进行执行</span>\n        <span>SqlSessionFactory</span> sqlSessionFactory <span>=</span> <span>new</span> <span>SqlSessionFactoryBuilder</span><span>(</span><span>)</span><span>.</span><span>build</span><span>(</span>mapperInputStream<span>,</span> <span>\"development\"</span><span>)</span><span>;</span>\n        <span>// 获取Mybatis配置信息</span>\n        <span>Configuration</span> configuration <span>=</span> sqlSessionFactory<span>.</span><span>getConfiguration</span><span>(</span><span>)</span><span>;</span>\n        <span>// 添加上我们的拦截器</span>\n        configuration<span>.</span><span>addInterceptor</span><span>(</span><span>new</span> <span>DefaultRowBoundsHandler</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// 参数: autoCommit,从名字上看就是是否自动提交事务</span>\n        <span>SqlSession</span> sqlSession <span>=</span> sqlSessionFactory<span>.</span><span>openSession</span><span>(</span><span>false</span><span>)</span><span>;</span>\n        <span>// 获取Mapper</span>\n        <span>TUserMapper</span> mapper <span>=</span> configuration<span>.</span><span>getMapperRegistry</span><span>(</span><span>)</span><span>.</span><span>getMapper</span><span>(</span><span>TUserMapper</span><span>.</span><span>class</span><span>,</span> sqlSession<span>)</span><span>;</span>\n        <span>// 如果自己加了RowBounds，则不自动加limit</span>\n        <span>RowBounds</span> rowBounds <span>=</span> <span>new</span> <span>RowBounds</span><span>(</span><span>0</span><span>,</span> <span>3</span><span>)</span><span>;</span>\n        <span>List</span><span><span>&lt;</span><span>TUser</span><span>></span></span> users1 <span>=</span> mapper<span>.</span><span>selectRowBounds</span><span>(</span>rowBounds<span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>users1<span>.</span><span>size</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// 如果不加显示,默认limit = 2</span>\n        <span>List</span><span><span>&lt;</span><span>TUser</span><span>></span></span> users <span>=</span> mapper<span>.</span><span>selectAll</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>users<span>.</span><span>size</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><p>好了，到这里逻辑分页已经搞定了。注意奥,这里只拦截了 <code>ResultSetHandler#handleResultSets</code> 其他两个没有拦截。\n注意奥这里只是一个思路，其实解决还有几种方法，我们要学会举一反三，比如我们也可以拦截 <code>Executor#query</code> 直接修改入参中的RowBounds参数。</p>\n<h2 id=\"_2-2-物理分页\"> 2.2 物理分页</h2>\n<p>物理分页就是给sql添加上参数。那么sql信息都在哪里呢? 就在下图中。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1649779778000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>那么我们如何能修改参数呢? 当然就是从下面两个类中利用反射来给sql增加上limit了。那么我们在哪里拦截呢?</p>\n<p>首先确定拦截地方,首先上面两个类。RawSqlSource(占位符)、DynamicSqlSource(变量符)。都属于MappedStatement的内部属性，只要我们能\n拿到MappedStatement就可以了。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1649782868000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>其中Executor中就可以。那么我们开始操作吧。</p>\n<ul>\n<li>line(14) RawSqlSource 占位符是最好处理的,内部属性就是StaticSqlSource,而StaticSqlSource中的sql是现成的直接造就行了。</li>\n<li>line(26) DynamicSqlSource 变量符,稍微有点难搞,因为你不能直接拿到sql,所以我们只能去重写它。如下。</li>\n<li>line(48-63) 从DynamicContext拿到原生sql然后,跟上面一样。</li>\n</ul>\n<div><div><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br></div><pre><code>    <span>/**\n     * 那我们就拦截处理结果.\n     * 启用反射修改默认的RowBounds limit属性\n     */</span>\n    <span>@Intercepts</span><span>(</span><span>@Signature</span><span>(</span>type <span>=</span> <span>Executor</span><span>.</span><span>class</span><span>,</span> method <span>=</span> <span>\"query\"</span><span>,</span>\n            args <span>=</span> <span>{</span><span>MappedStatement</span><span>.</span><span>class</span><span>,</span> <span>Object</span><span>.</span><span>class</span><span>,</span> <span>RowBounds</span><span>.</span><span>class</span><span>,</span> <span>ResultHandler</span><span>.</span><span>class</span><span>}</span><span>)</span><span>)</span>\n    <span>public</span> <span>static</span> <span>class</span> <span>PhysicalHandler</span> <span>implements</span> <span>Interceptor</span> <span>{</span>\n\n        <span>@Override</span>\n        <span>public</span> <span>Object</span> <span>intercept</span><span>(</span><span>Invocation</span> invocation<span>)</span> <span>throws</span> <span>Throwable</span> <span>{</span>\n            <span>Object</span><span>[</span><span>]</span> args <span>=</span> invocation<span>.</span><span>getArgs</span><span>(</span><span>)</span><span>;</span>\n            <span>MappedStatement</span> ms <span>=</span> <span>(</span><span>MappedStatement</span><span>)</span> args<span>[</span><span>0</span><span>]</span><span>;</span>\n            <span>SqlSource</span> sqlSource <span>=</span> ms<span>.</span><span>getSqlSource</span><span>(</span><span>)</span><span>;</span>\n            <span>if</span> <span>(</span>sqlSource <span>instanceof</span> <span>RawSqlSource</span><span>)</span> <span>{</span>\n                <span>MetaObject</span> rawSqlSource <span>=</span> ms<span>.</span><span>getConfiguration</span><span>(</span><span>)</span><span>.</span><span>newMetaObject</span><span>(</span><span>(</span><span>RawSqlSource</span><span>)</span> sqlSource<span>)</span><span>;</span>\n                <span>Object</span> staticSqlSource <span>=</span> rawSqlSource<span>.</span><span>getValue</span><span>(</span><span>\"sqlSource\"</span><span>)</span><span>;</span>\n                <span>MetaObject</span> metaObject <span>=</span> ms<span>.</span><span>getConfiguration</span><span>(</span><span>)</span><span>.</span><span>newMetaObject</span><span>(</span>staticSqlSource<span>)</span><span>;</span>\n                <span>String</span> sql <span>=</span> <span>(</span><span>String</span><span>)</span> metaObject<span>.</span><span>getValue</span><span>(</span><span>\"sql\"</span><span>)</span><span>;</span>\n                <span>if</span> <span>(</span>sql<span>.</span><span>indexOf</span><span>(</span><span>\"limit\"</span><span>)</span> <span>&lt;=</span> <span>0</span><span>)</span> <span>{</span>\n                    <span>String</span> limitSql <span>=</span> sql <span>+</span> <span>\" limit 2\"</span><span>;</span>\n                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>limitSql<span>)</span><span>;</span>\n                    metaObject<span>.</span><span>setValue</span><span>(</span><span>\"sql\"</span><span>,</span> limitSql<span>)</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n            <span>// 如果是动态sql,则需要解析</span>\n            <span>if</span> <span>(</span>sqlSource <span>instanceof</span> <span>DynamicSqlSource</span><span>)</span> <span>{</span>\n                <span>MetaObject</span> metaObject <span>=</span> ms<span>.</span><span>getConfiguration</span><span>(</span><span>)</span><span>.</span><span>newMetaObject</span><span>(</span>ms<span>)</span><span>;</span>\n                <span>LimitDynamicSqlSource</span> limitDynamicSqlSource <span>=</span> <span>new</span> <span>LimitDynamicSqlSource</span><span>(</span><span>(</span><span>DynamicSqlSource</span><span>)</span> sqlSource<span>)</span><span>;</span>\n                metaObject<span>.</span><span>setValue</span><span>(</span><span>\"sqlSource\"</span><span>,</span> limitDynamicSqlSource<span>)</span><span>;</span>\n            <span>}</span>\n            <span>return</span> invocation<span>.</span><span>proceed</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>class</span> <span>LimitDynamicSqlSource</span> <span>implements</span> <span>SqlSource</span> <span>{</span>\n\n        <span>private</span> <span>final</span> <span>Configuration</span> configuration<span>;</span>\n\n        <span>private</span> <span>final</span> <span>SqlNode</span> rootSqlNode<span>;</span>\n        \n        <span>public</span> <span>LimitDynamicSqlSource</span><span>(</span><span>DynamicSqlSource</span> dynamicSqlSource<span>)</span> <span>{</span>\n            <span>MetaObject</span> metaObject <span>=</span> <span>MetaObject</span><span>.</span><span>forObject</span><span>(</span>dynamicSqlSource<span>,</span> <span>new</span> <span>DefaultObjectFactory</span><span>(</span><span>)</span><span>,</span> <span>new</span> <span>DefaultObjectWrapperFactory</span><span>(</span><span>)</span><span>,</span> <span>new</span> <span>DefaultReflectorFactory</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>this</span><span>.</span>configuration <span>=</span> <span>(</span><span>Configuration</span><span>)</span> metaObject<span>.</span><span>getValue</span><span>(</span><span>\"configuration\"</span><span>)</span><span>;</span>\n            <span>this</span><span>.</span>rootSqlNode <span>=</span> <span>(</span><span>SqlNode</span><span>)</span> metaObject<span>.</span><span>getValue</span><span>(</span><span>\"rootSqlNode\"</span><span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>@Override</span>\n        <span>public</span> <span>BoundSql</span> <span>getBoundSql</span><span>(</span><span>Object</span> parameterObject<span>)</span> <span>{</span>\n            <span>DynamicContext</span> context <span>=</span> <span>new</span> <span>DynamicContext</span><span>(</span>configuration<span>,</span> parameterObject<span>)</span><span>;</span>\n            rootSqlNode<span>.</span><span>apply</span><span>(</span>context<span>)</span><span>;</span>\n            <span>SqlSourceBuilder</span> sqlSourceParser <span>=</span> <span>new</span> <span>SqlSourceBuilder</span><span>(</span>configuration<span>)</span><span>;</span>\n            <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> parameterType <span>=</span> parameterObject <span>==</span> <span>null</span> <span>?</span> <span>Object</span><span>.</span><span>class</span> <span>:</span> parameterObject<span>.</span><span>getClass</span><span>(</span><span>)</span><span>;</span>\n            <span>String</span> sql <span>=</span> context<span>.</span><span>getSql</span><span>(</span><span>)</span><span>;</span>\n            <span>String</span> limitSql <span>=</span> sql<span>;</span>\n            <span>// 给原生sql增加limit</span>\n            <span>if</span> <span>(</span>sql<span>.</span><span>indexOf</span><span>(</span><span>\"limit\"</span><span>)</span> <span>&lt;=</span> <span>0</span><span>)</span> <span>{</span>\n                limitSql <span>=</span> sql <span>+</span> <span>\" limit 2\"</span><span>;</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>limitSql<span>)</span><span>;</span>\n            <span>}</span>\n            <span>SqlSource</span> sqlSource <span>=</span> sqlSourceParser<span>.</span><span>parse</span><span>(</span>limitSql<span>,</span> parameterType<span>,</span> context<span>.</span><span>getBindings</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>BoundSql</span> boundSql <span>=</span> sqlSource<span>.</span><span>getBoundSql</span><span>(</span>parameterObject<span>)</span><span>;</span>\n            context<span>.</span><span>getBindings</span><span>(</span><span>)</span><span>.</span><span>forEach</span><span>(</span>boundSql<span>::</span><span>setAdditionalParameter</span><span>)</span><span>;</span>\n            <span>return</span> boundSql<span>;</span>\n        <span>}</span>\n    <span>}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br></div></div><p>好了我们直接来验证下吧。</p>\n<div><pre><code>    <span>/**\n     * 物理分页\n     * 就是拼装sql\n     */</span>\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>physicalLimit</span><span>(</span><span>)</span> <span>{</span>\n        <span>// 读取配置信息(为什么路径前不用加/,因为是相对路径。maven编译后的资源文件和class文件都是在一个包下,所以不用加/就是当前包目录)</span>\n        <span>InputStream</span> mapperInputStream <span>=</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getContextClassLoader</span><span>(</span><span>)</span><span>.</span><span>getResourceAsStream</span><span>(</span><span>\"example01/mybatisConfig.xml\"</span><span>)</span><span>;</span>\n        <span>// 生成SqlSession工厂,SqlSession从名字上看就是,跟数据库交互的会话信息,负责将sql提交到数据库进行执行</span>\n        <span>SqlSessionFactory</span> sqlSessionFactory <span>=</span> <span>new</span> <span>SqlSessionFactoryBuilder</span><span>(</span><span>)</span><span>.</span><span>build</span><span>(</span>mapperInputStream<span>,</span> <span>\"development\"</span><span>)</span><span>;</span>\n        <span>// 获取Mybatis配置信息</span>\n        <span>Configuration</span> configuration <span>=</span> sqlSessionFactory<span>.</span><span>getConfiguration</span><span>(</span><span>)</span><span>;</span>\n        <span>// 添加上我们的拦截器</span>\n        configuration<span>.</span><span>addInterceptor</span><span>(</span><span>new</span> <span>PhysicalHandler</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// 参数: autoCommit,从名字上看就是是否自动提交事务</span>\n        <span>SqlSession</span> sqlSession <span>=</span> sqlSessionFactory<span>.</span><span>openSession</span><span>(</span><span>false</span><span>)</span><span>;</span>\n        <span>// 获取Mapper</span>\n        <span>TUserMapper</span> mapper <span>=</span> configuration<span>.</span><span>getMapperRegistry</span><span>(</span><span>)</span><span>.</span><span>getMapper</span><span>(</span><span>TUserMapper</span><span>.</span><span>class</span><span>,</span> sqlSession<span>)</span><span>;</span>\n        <span>List</span><span><span>&lt;</span><span>TUser</span><span>></span></span> users <span>=</span> mapper<span>.</span><span>selectAll</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>users<span>.</span><span>size</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>好了，到这里我们就实现了动态修改sql了。重要的是思路, 思路决定出路。要学会举一反三。本篇所有的代码示例都在</p>\n<p><code>com.test.plugin.LimitPluginTest</code></p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1649779778000.png",
      "date_published": "2022-03-30T15:42:58.000Z",
      "date_modified": "2022-07-12T12:38:40.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Mybatis"
      ]
    },
    {
      "title": "第04篇:Mybatis代理对象生成",
      "url": "https://java.springlearn.cn/learn/mybatis/Mapper%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA/",
      "id": "https://java.springlearn.cn/learn/mybatis/Mapper%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA/",
      "content_html": "<PageBanner/>\n<h2 id=\"一、架构分析\"> 一、架构分析</h2>\n<p>Mybatis中Mapper一般只是一个接口,  那么为什么能执行数据操作的呢? 那肯定是基于代理没得说。在了解Mybatis如何实现代理\n前,  我们先大概看下它的架构是什么样的,  对这些关键的类有个大概的认识,  知道它所处的位置在哪里。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1649424512000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>本篇我们只深入研究下代理层,   学习下mybatis是如何进行代理操作的,   而关于sql的最终执行,   放到下一篇执行流程中来研究。</p>\n<h2 id=\"二、源码分析\"> 二、源码分析</h2>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1649301019000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>首先不要慌,  看上面这个图,  Mybatis的代理流程还是比较简单的。下面主要看下每个核心的类是做什么用的。</p>\n<h2 id=\"_2-1-mapperproxyfactory\"> 2.1 MapperProxyFactory</h2>\n<ul>\n<li>代理工厂里面看代码是比较简单的,  就是利用Proxy创建代理对象。</li>\n<li>对于已经生成的代理方法,  直接放到MethodCache缓存起来。</li>\n</ul>\n<div><pre><code><span>public</span> <span>class</span> <span>MapperProxyFactory</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>{</span>\n\n  <span>private</span> <span>final</span> <span>Class</span><span><span>&lt;</span><span>T</span><span>></span></span> mapperInterface<span>;</span>\n  <span>private</span> <span>final</span> <span>Map</span><span><span>&lt;</span><span>Method</span><span>,</span>   <span>MapperMethodInvoker</span><span>></span></span> methodCache <span>=</span> <span>new</span> <span>ConcurrentHashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n\n  <span>// Jdk代理Proxy,  可以看到主要逻辑在MapperProxy中</span>\n  <span>protected</span> <span>T</span> <span>newInstance</span><span>(</span><span>MapperProxy</span><span><span>&lt;</span><span>T</span><span>></span></span> mapperProxy<span>)</span> <span>{</span>\n    <span>return</span> <span>(</span><span>T</span><span>)</span> <span>Proxy</span><span>.</span><span>newProxyInstance</span><span>(</span>mapperInterface<span>.</span><span>getClassLoader</span><span>(</span><span>)</span><span>,</span>   <span>new</span> <span>Class</span><span>[</span><span>]</span> <span>{</span> mapperInterface <span>}</span><span>,</span>   mapperProxy<span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>public</span> <span>T</span> <span>newInstance</span><span>(</span><span>SqlSession</span> sqlSession<span>)</span> <span>{</span>\n    <span>final</span> <span>MapperProxy</span><span><span>&lt;</span><span>T</span><span>></span></span> mapperProxy <span>=</span> <span>new</span> <span>MapperProxy</span><span><span>&lt;</span><span>></span></span><span>(</span>sqlSession<span>,</span>   mapperInterface<span>,</span>   methodCache<span>)</span><span>;</span>\n    <span>return</span> <span>newInstance</span><span>(</span>mapperProxy<span>)</span><span>;</span>\n  <span>}</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id=\"_2-2-mapperproxy\"> 2.2 MapperProxy</h2>\n<p>MapperProxy 的代理逻辑也非常简单,  就以下三个能力,  看图理解。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1649079715000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>下面将核心的处理代码给挑选了出来,  增加了注释。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>MapperProxy</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>implements</span> <span>InvocationHandler</span><span>,</span>   <span>Serializable</span> <span>{</span>\n  <span>@Override</span>\n  <span>public</span> <span>Object</span> <span>invoke</span><span>(</span><span>Object</span> proxy<span>,</span>   <span>Method</span> method<span>,</span>   <span>Object</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>Throwable</span> <span>{</span>\n    <span>try</span> <span>{</span>\n      <span>// Object方法直接执行</span>\n      <span>if</span> <span>(</span><span>Object</span><span>.</span><span>class</span><span>.</span><span>equals</span><span>(</span>method<span>.</span><span>getDeclaringClass</span><span>(</span><span>)</span><span>)</span><span>)</span> <span>{</span>\n        <span>return</span> method<span>.</span><span>invoke</span><span>(</span><span>this</span><span>,</span>   args<span>)</span><span>;</span>\n      <span>}</span> <span>else</span> <span>{</span>\n        <span>// 其他方法生成代理方法</span>\n        <span>return</span> <span>cachedInvoker</span><span>(</span>method<span>)</span><span>.</span><span>invoke</span><span>(</span>proxy<span>,</span>   method<span>,</span>   args<span>,</span>   sqlSession<span>)</span><span>;</span>\n      <span>}</span>\n    <span>}</span> <span>catch</span> <span>(</span><span>Throwable</span> t<span>)</span> <span>{</span>\n      <span>throw</span> <span>ExceptionUtil</span><span>.</span><span>unwrapThrowable</span><span>(</span>t<span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n  \n  <span>private</span> <span>MapperMethodInvoker</span> <span>cachedInvoker</span><span>(</span><span>Method</span> method<span>)</span> <span>throws</span> <span>Throwable</span> <span>{</span>\n    <span>try</span> <span>{</span>\n      <span>return</span> <span>MapUtil</span><span>.</span><span>computeIfAbsent</span><span>(</span>methodCache<span>,</span>   method<span>,</span>   m <span>-></span> <span>{</span>\n        <span>// 如果是默认方法</span>\n        <span>if</span> <span>(</span>m<span>.</span><span>isDefault</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n          <span>try</span> <span>{</span>\n            <span>if</span> <span>(</span>privateLookupInMethod <span>==</span> <span>null</span><span>)</span> <span>{</span>\n              <span>// 生成java8的语法解析生成代理方法</span>\n              <span>return</span> <span>new</span> <span>DefaultMethodInvoker</span><span>(</span><span>getMethodHandleJava8</span><span>(</span>method<span>)</span><span>)</span><span>;</span>\n            <span>}</span> <span>else</span> <span>{</span>\n              <span>// // 生成java9的语法解析生成代理方法</span>\n              <span>return</span> <span>new</span> <span>DefaultMethodInvoker</span><span>(</span><span>getMethodHandleJava9</span><span>(</span>method<span>)</span><span>)</span><span>;</span>\n            <span>}</span>\n          <span>}</span> <span>catch</span> <span>(</span><span>IllegalAccessException</span> <span>|</span> <span>InstantiationException</span> <span>|</span> <span>InvocationTargetException</span>\n              <span>|</span> <span>NoSuchMethodException</span> e<span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>RuntimeException</span><span>(</span>e<span>)</span><span>;</span>\n          <span>}</span>\n        <span>}</span> <span>else</span> <span>{</span>\n        <span>// 不是默认方法,   生成代理方法 MapperMethod</span>\n          <span>return</span> <span>new</span> <span>PlainMethodInvoker</span><span>(</span><span>new</span> <span>MapperMethod</span><span>(</span>mapperInterface<span>,</span>   method<span>,</span>   sqlSession<span>.</span><span>getConfiguration</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n      <span>}</span><span>)</span><span>;</span>\n    <span>}</span> <span>catch</span> <span>(</span><span>RuntimeException</span> re<span>)</span> <span>{</span>\n      <span>Throwable</span> cause <span>=</span> re<span>.</span><span>getCause</span><span>(</span><span>)</span><span>;</span>\n      <span>throw</span> cause <span>==</span> <span>null</span> <span>?</span> re <span>:</span> cause<span>;</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><h2 id=\"_2-3-plainmethodinvoker\"> 2.3 PlainMethodInvoker</h2>\n<p>前面说了代理方法主要有三种场景。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1649079715000.png\" alt=\"\" loading=\"lazy\"></p>\n<ol>\n<li>Object方法直接method.invoker(this,  args);</li>\n<li>default关键字修饰的方法,  是DefaultMethodInvoker</li>\n<li>而更重要的要执行sql的代理Invoker是PlainMethodInvoker</li>\n</ol>\n<p>PlainMethodInvoker 才是真正处理需要进行sql的具体实现类。真正的代理逻辑在 MapperMethod 中。</p>\n<div><pre><code><span>private</span> <span>static</span> <span>class</span> <span>PlainMethodInvoker</span> <span>implements</span> <span>MapperMethodInvoker</span> <span>{</span>\n    <span>private</span> <span>final</span> <span>MapperMethod</span> mapperMethod<span>;</span>\n\n    <span>public</span> <span>PlainMethodInvoker</span><span>(</span><span>MapperMethod</span> mapperMethod<span>)</span> <span>{</span>\n      <span>super</span><span>(</span><span>)</span><span>;</span>\n      <span>this</span><span>.</span>mapperMethod <span>=</span> mapperMethod<span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>Object</span> <span>invoke</span><span>(</span><span>Object</span> proxy<span>,</span>   <span>Method</span> method<span>,</span>   <span>Object</span><span>[</span><span>]</span> args<span>,</span>   <span>SqlSession</span> sqlSession<span>)</span> <span>throws</span> <span>Throwable</span> <span>{</span>\n      <span>return</span> mapperMethod<span>.</span><span>execute</span><span>(</span>sqlSession<span>,</span>   args<span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>MapperMethod,  简单看下流程,   里面有2个重要的实现类,   分别用于判断sql类型,   处理方法参数(解析@Param参数)并最终交给SqlSession执行。到这里就把代理的\n流程给搞清楚了。但是具体sql怎么组装参数,   如何调用数据库jdbc接口,   都还没有看到。这部分内容。我们放到下一篇 <a href=\"../Mybatis%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90\">第05篇:Mybatis的SQL执行流程分析</a></p>\n<div><pre><code><span>public</span> <span>class</span> <span>MapperMethod</span> <span>{</span>\n\n  <span>private</span> <span>final</span> <span>SqlCommand</span> command<span>;</span>\n  <span>private</span> <span>final</span> <span>MethodSignature</span> method<span>;</span>\n\n  <span>public</span> <span>MapperMethod</span><span>(</span><span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> mapperInterface<span>,</span>   <span>Method</span> method<span>,</span>   <span>Configuration</span> config<span>)</span> <span>{</span>\n    <span>this</span><span>.</span>command <span>=</span> <span>new</span> <span>SqlCommand</span><span>(</span>config<span>,</span>   mapperInterface<span>,</span>   method<span>)</span><span>;</span>\n    <span>this</span><span>.</span>method <span>=</span> <span>new</span> <span>MethodSignature</span><span>(</span>config<span>,</span>   mapperInterface<span>,</span>   method<span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>public</span> <span>Object</span> <span>execute</span><span>(</span><span>SqlSession</span> sqlSession<span>,</span>   <span>Object</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n    <span>Object</span> result<span>;</span>\n    <span>switch</span> <span>(</span>command<span>.</span><span>getType</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n      <span>case</span> INSERT<span>:</span> <span>{</span>\n        <span>Object</span> param <span>=</span> method<span>.</span><span>convertArgsToSqlCommandParam</span><span>(</span>args<span>)</span><span>;</span>\n        result <span>=</span> <span>rowCountResult</span><span>(</span>sqlSession<span>.</span><span>insert</span><span>(</span>command<span>.</span><span>getName</span><span>(</span><span>)</span><span>,</span>   param<span>)</span><span>)</span><span>;</span>\n        <span>break</span><span>;</span>\n      <span>}</span>\n      <span>case</span> UPDATE<span>:</span> <span>{</span>\n        <span>Object</span> param <span>=</span> method<span>.</span><span>convertArgsToSqlCommandParam</span><span>(</span>args<span>)</span><span>;</span>\n        result <span>=</span> <span>rowCountResult</span><span>(</span>sqlSession<span>.</span><span>update</span><span>(</span>command<span>.</span><span>getName</span><span>(</span><span>)</span><span>,</span>   param<span>)</span><span>)</span><span>;</span>\n        <span>break</span><span>;</span>\n      <span>}</span>\n      <span>case</span> DELETE<span>:</span> <span>{</span>\n        <span>Object</span> param <span>=</span> method<span>.</span><span>convertArgsToSqlCommandParam</span><span>(</span>args<span>)</span><span>;</span>\n        result <span>=</span> <span>rowCountResult</span><span>(</span>sqlSession<span>.</span><span>delete</span><span>(</span>command<span>.</span><span>getName</span><span>(</span><span>)</span><span>,</span>   param<span>)</span><span>)</span><span>;</span>\n        <span>break</span><span>;</span>\n      <span>}</span>\n      <span>case</span> SELECT<span>:</span>\n        <span>if</span> <span>(</span>method<span>.</span><span>returnsVoid</span><span>(</span><span>)</span> <span>&amp;&amp;</span> method<span>.</span><span>hasResultHandler</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n          <span>executeWithResultHandler</span><span>(</span>sqlSession<span>,</span>   args<span>)</span><span>;</span>\n          result <span>=</span> <span>null</span><span>;</span>\n        <span>}</span> <span>else</span> <span>if</span> <span>(</span>method<span>.</span><span>returnsMany</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n          result <span>=</span> <span>executeForMany</span><span>(</span>sqlSession<span>,</span>   args<span>)</span><span>;</span>\n        <span>}</span> <span>else</span> <span>if</span> <span>(</span>method<span>.</span><span>returnsMap</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n          result <span>=</span> <span>executeForMap</span><span>(</span>sqlSession<span>,</span>   args<span>)</span><span>;</span>\n        <span>}</span> <span>else</span> <span>if</span> <span>(</span>method<span>.</span><span>returnsCursor</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n          result <span>=</span> <span>executeForCursor</span><span>(</span>sqlSession<span>,</span>   args<span>)</span><span>;</span>\n        <span>}</span> <span>else</span> <span>{</span>\n          <span>Object</span> param <span>=</span> method<span>.</span><span>convertArgsToSqlCommandParam</span><span>(</span>args<span>)</span><span>;</span>\n          result <span>=</span> sqlSession<span>.</span><span>selectOne</span><span>(</span>command<span>.</span><span>getName</span><span>(</span><span>)</span><span>,</span>   param<span>)</span><span>;</span>\n          <span>if</span> <span>(</span>method<span>.</span><span>returnsOptional</span><span>(</span><span>)</span>\n              <span>&amp;&amp;</span> <span>(</span>result <span>==</span> <span>null</span> <span>||</span> <span>!</span>method<span>.</span><span>getReturnType</span><span>(</span><span>)</span><span>.</span><span>equals</span><span>(</span>result<span>.</span><span>getClass</span><span>(</span><span>)</span><span>)</span><span>)</span><span>)</span> <span>{</span>\n            result <span>=</span> <span>Optional</span><span>.</span><span>ofNullable</span><span>(</span>result<span>)</span><span>;</span>\n          <span>}</span>\n        <span>}</span>\n        <span>break</span><span>;</span>\n      <span>case</span> FLUSH<span>:</span>\n        result <span>=</span> sqlSession<span>.</span><span>flushStatements</span><span>(</span><span>)</span><span>;</span>\n        <span>break</span><span>;</span>\n      <span>default</span><span>:</span>\n        <span>throw</span> <span>new</span> <span>BindingException</span><span>(</span><span>\"Unknown execution method for: \"</span> <span>+</span> command<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>if</span> <span>(</span>result <span>==</span> <span>null</span> <span>&amp;&amp;</span> method<span>.</span><span>getReturnType</span><span>(</span><span>)</span><span>.</span><span>isPrimitive</span><span>(</span><span>)</span> <span>&amp;&amp;</span> <span>!</span>method<span>.</span><span>returnsVoid</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n      <span>throw</span> <span>new</span> <span>BindingException</span><span>(</span><span>\"Mapper method '\"</span> <span>+</span> command<span>.</span><span>getName</span><span>(</span><span>)</span>\n          <span>+</span> <span>\" attempted to return null from a method with a primitive return type (\"</span> <span>+</span> method<span>.</span><span>getReturnType</span><span>(</span><span>)</span> <span>+</span> <span>\").\"</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>return</span> result<span>;</span>\n  <span>}</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br></div></div>",
      "image": "https://img.springlearn.cn/blog/learn_1649424512000.png",
      "date_published": "2022-03-30T15:42:58.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Mybatis"
      ]
    },
    {
      "title": "开个工厂造线程",
      "url": "https://java.springlearn.cn/learn/java/%E7%BA%BF%E7%A8%8B%E5%B7%A5%E5%8E%82/",
      "id": "https://java.springlearn.cn/learn/java/%E7%BA%BF%E7%A8%8B%E5%B7%A5%E5%8E%82/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明\n<strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<div><p>西魏陶渊明</p>\n<p>莫笑少年江湖梦，谁不少年梦江湖</p>\n</div>\n<h1 id=\"线程工厂\"> 线程工厂</h1>\n<p>线程是Java里面很重要的一个概念，具体体现就是Thread这个类。我们平时最常用的创建线程就是在用Executors来创建线程池。在前面的章节\n也可以看到，创建线程池时候有一个入参就是线程工厂，ThreadFactory这个类。那么这个类具体有什么用呢? 其实就是为了统一在创建线程时设置一些参数，\n如是否守护线程。线程一些特性等，如优先级，名称。</p>\n<div><pre><code>\t<span>/**\n\t * @param threadFactory 线程工厂\n     */</span>\n      <span>public</span> <span>ThreadPoolExecutor</span><span>(</span><span>int</span> corePoolSize<span>,</span>\n                                 <span>int</span> maximumPoolSize<span>,</span>\n                                 <span>long</span> keepAliveTime<span>,</span>\n                                 <span>TimeUnit</span> unit<span>,</span>\n                                 <span>BlockingQueue</span><span><span>&lt;</span><span>Runnable</span><span>></span></span> workQueue<span>,</span>\n                                 <span>ThreadFactory</span> threadFactory<span>)</span> <span>{</span>\n           <span>this</span><span>(</span>corePoolSize<span>,</span> maximumPoolSize<span>,</span> keepAliveTime<span>,</span> unit<span>,</span> workQueue<span>,</span>\n                threadFactory<span>,</span> defaultHandler<span>)</span><span>;</span>\n       <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h1 id=\"自定义\"> 自定义</h1>\n<p>所谓线程工厂其实就是创建线程使用的。正常情况下我们创建线程是下面这样的。</p>\n<div><pre><code>  <span>Thread</span> ret <span>=</span> <span>new</span> <span>Thread</span><span>(</span>runnable<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>但是线程的构造其实并不是只有一个,它有一个线程组的概念,另外也可以给每个线程去设置一个名字。这样的目的是可以通过名字就能辨认是什么线程在执行。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1599299678000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>那么我们就看下这里面怎么实现的,其实非常简单。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>NamedThreadFactory</span> <span>implements</span> <span>ThreadFactory</span> <span>{</span>\n\n  <span>protected</span> <span>static</span> <span>final</span> <span>AtomicInteger</span> POOL_SEQ <span>=</span> <span>new</span> <span>AtomicInteger</span><span>(</span><span>1</span><span>)</span><span>;</span>\n\n  <span>protected</span> <span>final</span> <span>AtomicInteger</span> mThreadNum <span>=</span> <span>new</span> <span>AtomicInteger</span><span>(</span><span>1</span><span>)</span><span>;</span>\n\n  <span>protected</span> <span>final</span> <span>String</span> mPrefix<span>;</span>\n\n  <span>protected</span> <span>final</span> <span>boolean</span> mDaemon<span>;</span>\n\n  <span>protected</span> <span>final</span> <span>ThreadGroup</span> mGroup<span>;</span>\n\n  <span>public</span> <span>NamedThreadFactory</span><span>(</span><span>)</span> <span>{</span>\n    <span>this</span><span>(</span><span>\"pool-\"</span> <span>+</span> POOL_SEQ<span>.</span><span>getAndIncrement</span><span>(</span><span>)</span><span>,</span> <span>false</span><span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>public</span> <span>NamedThreadFactory</span><span>(</span><span>String</span> prefix<span>)</span> <span>{</span>\n    <span>this</span><span>(</span>prefix<span>,</span> <span>false</span><span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>public</span> <span>NamedThreadFactory</span><span>(</span><span>String</span> prefix<span>,</span> <span>boolean</span> daemon<span>)</span> <span>{</span>\n    mPrefix <span>=</span> prefix <span>+</span> <span>\"-thread-\"</span><span>;</span>\n    mDaemon <span>=</span> daemon<span>;</span>\n    <span>SecurityManager</span> s <span>=</span> <span>System</span><span>.</span><span>getSecurityManager</span><span>(</span><span>)</span><span>;</span>\n    mGroup <span>=</span> <span>(</span>s <span>==</span> <span>null</span><span>)</span> <span>?</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getThreadGroup</span><span>(</span><span>)</span> <span>:</span> s<span>.</span><span>getThreadGroup</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>@Override</span>\n  <span>public</span> <span>Thread</span> <span>newThread</span><span>(</span><span>Runnable</span> runnable<span>)</span> <span>{</span>\n    <span>//就是给线程创建了一个名字和指定了一个线程组</span>\n    <span>String</span> name <span>=</span> mPrefix <span>+</span> mThreadNum<span>.</span><span>getAndIncrement</span><span>(</span><span>)</span><span>;</span>\n    <span>Thread</span> ret <span>=</span> <span>new</span> <span>Thread</span><span>(</span>mGroup<span>,</span> runnable<span>,</span> name<span>,</span> <span>0</span><span>)</span><span>;</span>\n    ret<span>.</span><span>setDaemon</span><span>(</span>mDaemon<span>)</span><span>;</span>\n    <span>return</span> ret<span>;</span>\n  <span>}</span>\n\n  <span>public</span> <span>ThreadGroup</span> <span>getThreadGroup</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> mGroup<span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><p>如此而已,线程工厂就是这样。</p>\n",
      "image": "https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png",
      "date_published": "2021-12-25T09:26:08.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Java进阶"
      ]
    },
    {
      "title": "第14篇:Mybatis中反射工具",
      "url": "https://java.springlearn.cn/learn/mybatis/MetaObject/",
      "id": "https://java.springlearn.cn/learn/mybatis/MetaObject/",
      "content_html": "<div><p>提示</p>\n<p>我们知道在java中基于反射的速度相对来说是很慢的, 但是如果对反射信息加了缓存性能可以提升1半以上, 如果在对反射设置了忽略安全检查, 性能更是会再提升1半。那么这个时候\n反射带来的性能问题基本可以忽略了。在Mybatis中关于反射的工具就可以很大程度来解决这个问题。本篇讲解下Mybatis中的工具类, 以后在项目中也可以直接使用。</p>\n</div>\n<h2 id=\"一、反射缓存类-reflector\"> 一、反射缓存类 Reflector</h2>\n<p>所有的反射对象都会被生成一个 <code>Reflector</code>, Reflector 会把反射的方法、构造、字段、类型等信息都缓存起来。这样的设计主要是为了解决性能问题。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Reflector</span> <span>{</span>\n\n  <span>private</span> <span>final</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> type<span>;</span>\n  <span>private</span> <span>final</span> <span>String</span><span>[</span><span>]</span> readablePropertyNames<span>;</span>\n  <span>private</span> <span>final</span> <span>String</span><span>[</span><span>]</span> writablePropertyNames<span>;</span>\n  <span>private</span> <span>final</span> <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Invoker</span><span>></span></span> setMethods <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n  <span>private</span> <span>final</span> <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Invoker</span><span>></span></span> getMethods <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n  <span>private</span> <span>final</span> <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Class</span><span>&lt;</span><span>?</span><span>></span><span>></span></span> setTypes <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n  <span>private</span> <span>final</span> <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Class</span><span>&lt;</span><span>?</span><span>></span><span>></span></span> getTypes <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n  <span>private</span> <span>Constructor</span><span><span>&lt;</span><span>?</span><span>></span></span> defaultConstructor<span>;</span>\n\n  <span>private</span> <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> caseInsensitivePropertyMap <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n  \n<span>}</span>  \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>ReflectorFactory 反射工厂用来缓存反射对象 Reflector</p>\n<div><pre><code>\n<span>public</span> <span>class</span> <span>DefaultReflectorFactory</span> <span>implements</span> <span>ReflectorFactory</span> <span>{</span>\n  <span>private</span> <span>boolean</span> classCacheEnabled <span>=</span> <span>true</span><span>;</span>\n  <span>private</span> <span>final</span> <span>ConcurrentMap</span><span><span>&lt;</span><span>Class</span><span>&lt;</span><span>?</span><span>></span><span>,</span> <span>Reflector</span><span>></span></span> reflectorMap <span>=</span> <span>new</span> <span>ConcurrentHashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n  \n  <span>@Override</span>\n  <span>public</span> <span>Reflector</span> <span>findForClass</span><span>(</span><span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> type<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>classCacheEnabled<span>)</span> <span>{</span>\n      <span>// synchronized (type) removed see issue #461</span>\n      <span>return</span> <span>MapUtil</span><span>.</span><span>computeIfAbsent</span><span>(</span>reflectorMap<span>,</span> type<span>,</span> <span>Reflector</span><span>::</span><span>new</span><span>)</span><span>;</span>\n    <span>}</span> <span>else</span> <span>{</span>\n      <span>return</span> <span>new</span> <span>Reflector</span><span>(</span>type<span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n  \n<span>}</span>  \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id=\"二、通过反射操作对象-metaobject\"> 二、通过反射操作对象 MetaObject</h2>\n<p>MetaObject 从名字来看就是对对象进行操作,他的操作都是通过反射来进行的。</p>\n<h2 id=\"_2-1-简单对象操作\"> 2.1 简单对象操作</h2>\n<div><pre><code>    <span>@AllArgsConstructor</span>\n    <span>@ToString</span>\n    <span>public</span> <span>static</span> <span>class</span> <span>Person</span> <span>{</span>\n\n        <span>@Getter</span><span>(</span><span>AccessLevel</span><span>.</span>PRIVATE<span>)</span>\n        <span>@Setter</span><span>(</span><span>AccessLevel</span><span>.</span>PRIVATE<span>)</span>\n        <span>private</span> <span>String</span> name<span>;</span>\n\n        <span>@Getter</span><span>(</span><span>AccessLevel</span><span>.</span>PRIVATE<span>)</span>\n        <span>@Setter</span><span>(</span><span>AccessLevel</span><span>.</span>PRIVATE<span>)</span>\n        <span>private</span> <span>int</span> age<span>;</span>\n\n        <span>@Getter</span><span>(</span><span>AccessLevel</span><span>.</span>PRIVATE<span>)</span>\n        <span>@Setter</span><span>(</span><span>AccessLevel</span><span>.</span>PRIVATE<span>)</span>\n        <span>private</span> <span>Long</span> userId<span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 通过反射给对象赋值\n     */</span>\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>metaObjectTest</span><span>(</span><span>)</span> <span>{</span>\n        <span>Person</span> jay <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>\"周杰伦\"</span><span>,</span> <span>40</span><span>,</span> <span>1L</span><span>)</span><span>;</span>\n        <span>MetaObject</span> jayMetaObject <span>=</span> <span>MetaObject</span><span>.</span><span>forObject</span><span>(</span>jay<span>,</span> <span>new</span> <span>DefaultObjectFactory</span><span>(</span><span>)</span><span>,</span> <span>new</span> <span>DefaultObjectWrapperFactory</span><span>(</span><span>)</span><span>,</span> <span>new</span> <span>DefaultReflectorFactory</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span>jayMetaObject<span>.</span><span>hasGetter</span><span>(</span><span>\"name\"</span><span>)</span><span>)</span> <span>{</span>\n            <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> name <span>=</span> jayMetaObject<span>.</span><span>getGetterType</span><span>(</span><span>\"name\"</span><span>)</span><span>;</span>\n            <span>// class java.lang.String</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>name<span>)</span><span>;</span>\n            jayMetaObject<span>.</span><span>setValue</span><span>(</span><span>\"name\"</span><span>,</span> <span>\"昆凌\"</span><span>)</span><span>;</span>\n            <span>// 昆凌</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>jayMetaObject<span>.</span><span>getValue</span><span>(</span><span>\"name\"</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>// 昆凌</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>jay<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><h2 id=\"_2-2-嵌套对象操作\"> 2.2 嵌套对象操作</h2>\n<div><pre><code>    <span>@AllArgsConstructor</span>\n    <span>@ToString</span>\n    <span>public</span> <span>static</span> <span>class</span> <span>Person</span> <span>{</span>\n\n        <span>@Getter</span><span>(</span><span>AccessLevel</span><span>.</span>PRIVATE<span>)</span>\n        <span>@Setter</span><span>(</span><span>AccessLevel</span><span>.</span>PRIVATE<span>)</span>\n        <span>private</span> <span>String</span> name<span>;</span>\n\n        <span>@Getter</span><span>(</span><span>AccessLevel</span><span>.</span>PRIVATE<span>)</span>\n        <span>@Setter</span><span>(</span><span>AccessLevel</span><span>.</span>PRIVATE<span>)</span>\n        <span>private</span> <span>int</span> age<span>;</span>\n\n        <span>@Getter</span><span>(</span><span>AccessLevel</span><span>.</span>PRIVATE<span>)</span>\n        <span>@Setter</span><span>(</span><span>AccessLevel</span><span>.</span>PRIVATE<span>)</span>\n        <span>private</span> <span>Long</span> userId<span>;</span>\n    <span>}</span>\n    \n    <span>@AllArgsConstructor</span>\n    <span>@ToString</span>\n    <span>public</span> <span>static</span> <span>class</span> <span>School</span> <span>{</span>\n\n        <span>@Getter</span><span>(</span><span>AccessLevel</span><span>.</span>PRIVATE<span>)</span>\n        <span>@Setter</span><span>(</span><span>AccessLevel</span><span>.</span>PRIVATE<span>)</span>\n        <span>private</span> <span>String</span> name<span>;</span>\n\n        <span>@Getter</span><span>(</span><span>AccessLevel</span><span>.</span>PRIVATE<span>)</span>\n        <span>@Setter</span><span>(</span><span>AccessLevel</span><span>.</span>PRIVATE<span>)</span>\n        <span>private</span> <span>Person</span> person<span>;</span>\n    <span>}</span>\n    \n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>fillChildObjectTest</span><span>(</span><span>)</span> <span>{</span>\n        <span>School</span> school <span>=</span> <span>new</span> <span>School</span><span>(</span><span>\"西天大学\"</span><span>,</span> <span>new</span> <span>Person</span><span>(</span><span>\"周杰伦\"</span><span>,</span> <span>40</span><span>,</span> <span>1L</span><span>)</span><span>)</span><span>;</span>\n        <span>MetaObject</span> schoolMetaObject <span>=</span> <span>MetaObject</span><span>.</span><span>forObject</span><span>(</span>school<span>,</span> <span>new</span> <span>DefaultObjectFactory</span><span>(</span><span>)</span><span>,</span> <span>new</span> <span>DefaultObjectWrapperFactory</span><span>(</span><span>)</span><span>,</span> <span>new</span> <span>DefaultReflectorFactory</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// 周杰伦</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>schoolMetaObject<span>.</span><span>getValue</span><span>(</span><span>\"person.name\"</span><span>)</span><span>)</span><span>;</span>\n        schoolMetaObject<span>.</span><span>setValue</span><span>(</span><span>\"person.name\"</span><span>,</span> <span>\"昆凌\"</span><span>)</span><span>;</span>\n        <span>// 昆凌</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>school<span>.</span><span>getPerson</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><h2 id=\"三、获取反射信息-metaclass\"> 三、获取反射信息 MetaClass</h2>\n<p>MetaClass 主要是对 Reflector信息的一个包装并提供些更高级的操作。如跟嵌套类赋值</p>\n<div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>metaClassTest</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>MetaClass</span> metaClass <span>=</span> <span>MetaClass</span><span>.</span><span>forClass</span><span>(</span><span>School</span><span>.</span><span>class</span><span>,</span> <span>new</span> <span>DefaultReflectorFactory</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// class com.test.tool.MetaObjectTest$Person</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>metaClass<span>.</span><span>getGetterType</span><span>(</span><span>\"person\"</span><span>)</span><span>)</span><span>;</span>\n\n        <span>School</span> school <span>=</span> <span>new</span> <span>School</span><span>(</span><span>)</span><span>;</span>\n        <span>Invoker</span> setNameInvoker <span>=</span> metaClass<span>.</span><span>getSetInvoker</span><span>(</span><span>\"name\"</span><span>)</span><span>;</span>\n        <span>// 通过反射给空对象赋值</span>\n        setNameInvoker<span>.</span><span>invoke</span><span>(</span>school<span>,</span> <span>new</span> <span>Object</span><span>[</span><span>]</span><span>{</span><span>\"Jay\"</span><span>}</span><span>)</span><span>;</span>\n\n        <span>// 通过反射获取空对象</span>\n        <span>Invoker</span> getNameInvoker <span>=</span> metaClass<span>.</span><span>getGetInvoker</span><span>(</span><span>\"name\"</span><span>)</span><span>;</span>\n        <span>// Jay</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>getNameInvoker<span>.</span><span>invoke</span><span>(</span>school<span>,</span> <span>new</span> <span>Object</span><span>[</span><span>]</span><span>{</span><span>}</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div>",
      "date_published": "2022-04-26T15:44:59.000Z",
      "date_modified": "2022-07-12T12:38:40.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Mybatis"
      ]
    },
    {
      "title": "第05篇:Mybatis的SQL执行流程分析",
      "url": "https://java.springlearn.cn/learn/mybatis/Mybatis%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/",
      "id": "https://java.springlearn.cn/learn/mybatis/Mybatis%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/",
      "content_html": "<PageBanner/>\n<h2 id=\"一、前言\"> 一、前言</h2>\n<p>前面我们知道了Mybatis是如何进行代理的, 但是最终 <code>PlainMethodInvoker</code> 中是如何将参数转组装成Sql,并执行处理Sql返回值的地方还都没看到。本篇我们就带着如下三个问题开始我们的探索吧。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1649427915000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>本篇内容因为涉及跟jdbc的知识,如果对这部分内容有点遗忘,请先<a href=\"./../mybatis/环境搭建/#_2-2-1-jdbc驱动\">JDBC知识复习</a>，另本篇内容知识点较多,目录较复杂,建议根据文字结合\n代码在实践的过程中一起学习。最好也可以自己debug一下。会收获更大。做好准备现在发车。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1649428750000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"二、流程分析\"> 二、流程分析</h2>\n<h2 id=\"_2-1-sql是如何组装参数的\"> 2.1 Sql是如何组装参数的?</h2>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1649428892000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>在组装参数之前我们先来提一个小问题,sql的类型是如何判断的。sql类型有增删该查。\n除了查询会有结果集外，其他三种都是返回更新行数。他们对应的处理逻辑也是不一样的。\n我们要先弄清这个问题。</p>\n<h3 id=\"_2-1-1-sql类型如何判断\"> 2.1.1 sql类型如何判断?</h3>\n<p>我们知道sql的类型是可以通过关键字来判断的,如select/update/delete/insert。那么在Mybatis中哪里能输入sql呢?\n一种有2种方式。</p>\n<ol>\n<li>在Mapper.xml中直接编写sql，如下示例。</li>\n</ol>\n<div><pre><code><span>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?></span>\n<span><span>&lt;!</span><span>DOCTYPE</span> <span>mapper</span> <span>PUBLIC</span> <span>\"-//mybatis.org//DTD Mapper 3.0//EN\"</span> <span>\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"</span><span>></span></span>\n<span><span><span>&lt;</span>mapper</span> <span>namespace</span><span><span>=</span><span>\"</span>orm.example.dal.mapper.TUserMapper<span>\"</span></span><span>></span></span>\n    <span><span><span>&lt;</span>delete</span> <span>id</span><span><span>=</span><span>\"</span>deleteByPrimaryKey<span>\"</span></span> <span>parameterType</span><span><span>=</span><span>\"</span>java.lang.String<span>\"</span></span><span>></span></span>\n        delete from T_USER\n        where token_id = #{tokenId,jdbcType=CHAR}\n    <span><span><span>&lt;/</span>delete</span><span>></span></span>\n    <span><span><span>&lt;</span>insert</span> <span>id</span><span><span>=</span><span>\"</span>insert<span>\"</span></span> <span>parameterType</span><span><span>=</span><span>\"</span>orm.example.dal.model.TUser<span>\"</span></span><span>></span></span>\n        insert into T_USER (token_id, uid, name)\n        values (#{tokenId,jdbcType=CHAR}, #{uid,jdbcType=INTEGER}, #{name,jdbcType=CHAR})\n    <span><span><span>&lt;/</span>insert</span><span>></span></span>\n    <span><span><span>&lt;</span>update</span> <span>id</span><span><span>=</span><span>\"</span>updateByPrimaryKey<span>\"</span></span> <span>parameterType</span><span><span>=</span><span>\"</span>orm.example.dal.model.TUser<span>\"</span></span><span>></span></span>\n        update T_USER\n        set uid = #{uid,jdbcType=INTEGER},\n        name = #{name,jdbcType=CHAR}\n        where token_id = #{tokenId,jdbcType=CHAR}\n    <span><span><span>&lt;/</span>update</span><span>></span></span>\n    <span><span><span>&lt;</span>select</span> <span>id</span><span><span>=</span><span>\"</span>selectAll<span>\"</span></span> <span>resultMap</span><span><span>=</span><span>\"</span>BaseResultMap<span>\"</span></span><span>></span></span>\n        select token_id, uid, name\n        from T_USER\n    <span><span><span>&lt;/</span>select</span><span>></span></span>\n\n<span><span><span>&lt;/</span>mapper</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><ol start=\"2\">\n<li>在Mapper类中使用注解编写sql</li>\n</ol>\n<div><pre><code><span>public</span> <span>interface</span> <span>TUserMapper</span> <span>{</span>\n    <span>@Select</span><span>(</span><span>\"select * from t_user where id = #{id}\"</span><span>)</span>\n    <span>TUser</span> <span>selectById</span><span>(</span><span>Long</span> id<span>)</span><span>;</span>\n<span>}</span>    \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>这些sql信息都保存在 MappedStatement。在PlainMethodInvoker通过SqlCommand进行调用。</p>\n<ul>\n<li>line(9) 最终通过type = ms.getSqlCommandType() 获取sql的类型</li>\n</ul>\n<div><div><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br></div><pre><code><span>SqlCommand</span> sqlCommand <span>=</span> <span>new</span> <span>SqlCommand</span><span>(</span>config<span>,</span> mapperInterface<span>,</span> method<span>)</span><span>;</span>\n\n<span>// 构造参数中找MappedStatement</span>\n<span>public</span> <span>SqlCommand</span><span>(</span><span>Configuration</span> configuration<span>,</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> mapperInterface<span>,</span> <span>Method</span> method<span>)</span> <span>{</span>\n      <span>final</span> <span>String</span> methodName <span>=</span> method<span>.</span><span>getName</span><span>(</span><span>)</span><span>;</span>\n      <span>final</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> declaringClass <span>=</span> method<span>.</span><span>getDeclaringClass</span><span>(</span><span>)</span><span>;</span>\n      <span>MappedStatement</span> ms <span>=</span> <span>resolveMappedStatement</span><span>(</span>mapperInterface<span>,</span> methodName<span>,</span> declaringClass<span>,</span>\n          configuration<span>)</span><span>;</span>\n      type <span>=</span> ms<span>.</span><span>getSqlCommandType</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>          \n<span>// 寻找方法是接口全路径名.方法名</span>\n<span>private</span> <span>MappedStatement</span> <span>resolveMappedStatement</span><span>(</span><span>)</span><span>{</span>\n    <span>String</span> statementId <span>=</span> mapperInterface<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\".\"</span> <span>+</span> methodName<span>;</span>\n    configuration<span>.</span><span>hasStatement</span><span>(</span>statementId<span>)</span>\n<span>}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>那么MappedStatement中的SqlCommandType是如何获取的呢?</p>\n<h3 id=\"_2-1-1-1-xml文件方式\"> 2.1.1.1 xml文件方式</h3>\n<p>解析xml标签来实现</p>\n<p>XMLMapperBuilder#parseStatementNode</p>\n<ul>\n<li>line(11) 通过标签来映射成指定的类型SqlCommandType</li>\n</ul>\n<div><div><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br></div><pre><code>public class XMLStatementBuilder extends BaseBuilder {\n public void parseStatementNode() {\n    String id = context.getStringAttribute(\"id\");\n    String databaseId = context.getStringAttribute(\"databaseId\");\n\n    if (!databaseIdMatchesCurrent(id, databaseId, this.requiredDatabaseId)) {\n      return;\n    }\n\n    String nodeName = context.getNode().getNodeName();\n    SqlCommandType sqlCommandType = SqlCommandType.valueOf(nodeName.toUpperCase(Locale.ENGLISH));\n  }\n}  \npublic enum SqlCommandType {\n  UNKNOWN, INSERT, UPDATE, DELETE, SELECT, FLUSH\n}    \n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id=\"_2-1-1-2-注解方式\"> 2.1.1.2 注解方式</h3>\n<p>一定是解析注解方法 AnnotationWrapper。将不同的注解解析成SqlCommandType。如下伪代码。通过解析方法上的注解,判断注解类型,来确定sql的类型。\nMapperAnnotationBuilder#getAnnotationWrapper(method, true, statementAnnotationTypes)</p>\n<div><pre><code><span>private</span> <span>class</span> <span>AnnotationWrapper</span> <span>{</span>\n    <span>private</span> <span>final</span> <span>Annotation</span> annotation<span>;</span>\n    <span>private</span> <span>final</span> <span>String</span> databaseId<span>;</span>\n    <span>private</span> <span>final</span> <span>SqlCommandType</span> sqlCommandType<span>;</span>\n\n    <span>AnnotationWrapper</span><span>(</span><span>Annotation</span> annotation<span>)</span> <span>{</span>\n      <span>super</span><span>(</span><span>)</span><span>;</span>\n      <span>this</span><span>.</span>annotation <span>=</span> annotation<span>;</span>\n      <span>if</span> <span>(</span>annotation <span>instanceof</span> <span>Select</span><span>)</span> <span>{</span>\n        databaseId <span>=</span> <span>(</span><span>(</span><span>Select</span><span>)</span> annotation<span>)</span><span>.</span><span>databaseId</span><span>(</span><span>)</span><span>;</span>\n        sqlCommandType <span>=</span> <span>SqlCommandType</span><span>.</span>SELECT<span>;</span>\n      <span>}</span> <span>else</span> <span>if</span> <span>(</span>annotation <span>instanceof</span> <span>Update</span><span>)</span> <span>{</span>\n        databaseId <span>=</span> <span>(</span><span>(</span><span>Update</span><span>)</span> annotation<span>)</span><span>.</span><span>databaseId</span><span>(</span><span>)</span><span>;</span>\n        sqlCommandType <span>=</span> <span>SqlCommandType</span><span>.</span>UPDATE<span>;</span>\n      <span>}</span> <span>else</span> <span>if</span> <span>(</span>annotation <span>instanceof</span> <span>Insert</span><span>)</span> <span>{</span>\n        databaseId <span>=</span> <span>(</span><span>(</span><span>Insert</span><span>)</span> annotation<span>)</span><span>.</span><span>databaseId</span><span>(</span><span>)</span><span>;</span>\n        sqlCommandType <span>=</span> <span>SqlCommandType</span><span>.</span>INSERT<span>;</span>\n      <span>}</span> <span>else</span> <span>if</span> <span>(</span>annotation <span>instanceof</span> <span>Delete</span><span>)</span> <span>{</span>\n        databaseId <span>=</span> <span>(</span><span>(</span><span>Delete</span><span>)</span> annotation<span>)</span><span>.</span><span>databaseId</span><span>(</span><span>)</span><span>;</span>\n        sqlCommandType <span>=</span> <span>SqlCommandType</span><span>.</span>DELETE<span>;</span>\n      <span>}</span> <span>else</span> <span>if</span> <span>(</span>annotation <span>instanceof</span> <span>SelectProvider</span><span>)</span> <span>{</span>\n        databaseId <span>=</span> <span>(</span><span>(</span><span>SelectProvider</span><span>)</span> annotation<span>)</span><span>.</span><span>databaseId</span><span>(</span><span>)</span><span>;</span>\n        sqlCommandType <span>=</span> <span>SqlCommandType</span><span>.</span>SELECT<span>;</span>\n      <span>}</span> <span>else</span> <span>if</span> <span>(</span>annotation <span>instanceof</span> <span>UpdateProvider</span><span>)</span> <span>{</span>\n        databaseId <span>=</span> <span>(</span><span>(</span><span>UpdateProvider</span><span>)</span> annotation<span>)</span><span>.</span><span>databaseId</span><span>(</span><span>)</span><span>;</span>\n        sqlCommandType <span>=</span> <span>SqlCommandType</span><span>.</span>UPDATE<span>;</span>\n      <span>}</span> <span>else</span> <span>if</span> <span>(</span>annotation <span>instanceof</span> <span>InsertProvider</span><span>)</span> <span>{</span>\n        databaseId <span>=</span> <span>(</span><span>(</span><span>InsertProvider</span><span>)</span> annotation<span>)</span><span>.</span><span>databaseId</span><span>(</span><span>)</span><span>;</span>\n        sqlCommandType <span>=</span> <span>SqlCommandType</span><span>.</span>INSERT<span>;</span>\n      <span>}</span> <span>else</span> <span>if</span> <span>(</span>annotation <span>instanceof</span> <span>DeleteProvider</span><span>)</span> <span>{</span>\n        databaseId <span>=</span> <span>(</span><span>(</span><span>DeleteProvider</span><span>)</span> annotation<span>)</span><span>.</span><span>databaseId</span><span>(</span><span>)</span><span>;</span>\n        sqlCommandType <span>=</span> <span>SqlCommandType</span><span>.</span>DELETE<span>;</span>\n      <span>}</span> <span>else</span> <span>{</span>\n        sqlCommandType <span>=</span> <span>SqlCommandType</span><span>.</span>UNKNOWN<span>;</span>\n        <span>if</span> <span>(</span>annotation <span>instanceof</span> <span>Options</span><span>)</span> <span>{</span>\n          databaseId <span>=</span> <span>(</span><span>(</span><span>Options</span><span>)</span> annotation<span>)</span><span>.</span><span>databaseId</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span> <span>else</span> <span>if</span> <span>(</span>annotation <span>instanceof</span> <span>SelectKey</span><span>)</span> <span>{</span>\n          databaseId <span>=</span> <span>(</span><span>(</span><span>SelectKey</span><span>)</span> annotation<span>)</span><span>.</span><span>databaseId</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span> <span>else</span> <span>{</span>\n          databaseId <span>=</span> <span>\"\"</span><span>;</span>\n        <span>}</span>\n      <span>}</span>\n    <span>}</span>\n\n    <span>Annotation</span> <span>getAnnotation</span><span>(</span><span>)</span> <span>{</span>\n      <span>return</span> annotation<span>;</span>\n    <span>}</span>\n\n    <span>SqlCommandType</span> <span>getSqlCommandType</span><span>(</span><span>)</span> <span>{</span>\n      <span>return</span> sqlCommandType<span>;</span>\n    <span>}</span>\n<span>}</span>    \n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br></div></div><p>到这里我们知道了sql类型是如何区分出来的，既然能区分出来，就知道如何去执行sql了。\n是不是很简单? 当然看的话很简单，但是如何让你自己来找，你能找到吗? 所以建议在阅读的时候\n要自己去源码中找找。</p>\n<h3 id=\"_2-1-2-sql参数如何组装\"> 2.1.2 sql参数如何组装?</h3>\n<p>在mybatis中有两种处理sql参数的地方,第一种是<code>#{}</code> 占位符，第二种是<code>${}</code> 变量符。这两种都是处理参数的方式。那说到这里,不得不提的就是sql注入的黑客技术。\nsql注入就是就是利用了变量符。将我们原来的sql进行恶意的修改。举一个例子。下面根据用户id和用户密码查询用户信息。</p>\n<p><code>select * from t_user as u where u.pass = ${user_pass} and u.id = ${user_id}</code></p>\n<p>那么如何在不知道密码只有用户id的情况下查询到用户信息呢? 我们只需要将sql转换成下面这样即可。</p>\n<p><code>select * from t_user as u where u.pass = '' or 1 = 1 and u.id = ${user_id}</code></p>\n<p>那mybatis允许我们这样做吗? 允许，如果我们使用的是 <code>${}</code> 变量符,那么mybatis只是将参数和变量符进行替换。你输入的参数可能也会被当成sql去执行了。如下代码示例。</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>T4UserMapper</span> <span>{</span>\n    <span>/**\n     * 获取用户信息\n     *\n     * @param uid     用户id\n     * @param tokenId token\n     * @return TUser\n     */</span>\n    <span>@Select</span><span>(</span><span>\"select * from t_user where token_id = ${token_id} and uid = ${uid}\"</span><span>)</span>\n    <span>TUser</span> <span>queryUserById</span><span>(</span><span>@Param</span><span>(</span><span>\"uid\"</span><span>)</span> <span>Long</span> uid<span>,</span> <span>@Param</span><span>(</span><span>\"token_id\"</span><span>)</span> <span>String</span> tokenId<span>)</span><span>;</span>\n<span>}</span>\n<span>public</span> <span>class</span> <span>Test</span><span>{</span>\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>sql</span><span>(</span><span>)</span><span>{</span>\n        <span>// 读取配置信息</span>\n        <span>InputStream</span> mapperInputStream <span>=</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getContextClassLoader</span><span>(</span><span>)</span><span>.</span><span>getResourceAsStream</span><span>(</span><span>\"example05/mybatisConfig.xml\"</span><span>)</span><span>;</span>\n        <span>// 生成SqlSession工厂,SqlSession从名字上看就是,跟数据库交互的会话信息,负责将sql提交到数据库进行执行</span>\n        <span>SqlSessionFactory</span> sqlSessionFactory <span>=</span> <span>new</span> <span>SqlSessionFactoryBuilder</span><span>(</span><span>)</span><span>.</span><span>build</span><span>(</span>mapperInputStream<span>,</span> <span>\"development\"</span><span>)</span><span>;</span>\n        <span>// 获取Mybatis配置信息</span>\n        <span>Configuration</span> configuration <span>=</span> sqlSessionFactory<span>.</span><span>getConfiguration</span><span>(</span><span>)</span><span>;</span>\n        <span>SqlSession</span> sqlSession <span>=</span> sqlSessionFactory<span>.</span><span>openSession</span><span>(</span><span>false</span><span>)</span><span>;</span>\n        <span>// debug</span>\n        <span>T4UserMapper</span> mapper <span>=</span> configuration<span>.</span><span>getMapper</span><span>(</span><span>T4UserMapper</span><span>.</span><span>class</span><span>,</span> sqlSession<span>)</span><span>;</span>\n        <span>// 模拟sql注入</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>mapper<span>.</span><span>queryUserById</span><span>(</span><span>37L</span><span>,</span><span>\"0 or 1 = 1\"</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>    \n\n<span>Setting</span> autocommit <span>to</span> <span>false</span> on JDBC <span>Connection</span> <span>[</span><span><span>com<span>.</span>mysql<span>.</span>cj<span>.</span>jdbc<span>.</span></span>ConnectionImpl</span><span>@62ddbd7e</span><span>]</span>\n<span>==</span><span>></span>  <span>Preparing</span><span>:</span> select <span>*</span> from t_user where token_id <span>=</span> <span>0</span> or <span>1</span> <span>=</span> <span>1</span> and uid <span>=</span> <span>37</span>\n<span>==</span><span>></span> <span>Parameters</span><span>:</span> \n<span>&lt;=</span><span>=</span>    <span>Columns</span><span>:</span> uid<span>,</span> name<span>,</span> token_id\n<span>&lt;=</span><span>=</span>        <span>Row</span><span>:</span> <span>37</span><span>,</span> 无天<span>,</span> <span>60</span>\n<span>&lt;=</span><span>=</span>      <span>Total</span><span>:</span> <span>1</span>\n<span>TUser</span><span>(</span>tokenId<span>=</span><span>null</span><span>,</span> uid<span>=</span><span>37</span><span>,</span> name<span>=</span>无天<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><p>要想避免这样的问题,我们只需要将<code>${}</code> 变量符,都替换成<code>#{}</code> 占位符就好了。那么Mybatis只会将你的参数当做是参数处理，不会当做是sql执行。如下代码示例。</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>T4UserMapper</span> <span>{</span>\n    <span>/**\n     * 获取用户信息\n     *\n     * @param uid     用户id\n     * @param tokenId token\n     * @return TUser\n     */</span>\n    <span>@Select</span><span>(</span><span>\"select * from t_user where token_id = #{token_id} and uid = #{uid}\"</span><span>)</span>\n    <span>TUser</span> <span>queryUserById</span><span>(</span><span>@Param</span><span>(</span><span>\"uid\"</span><span>)</span> <span>Long</span> uid<span>,</span> <span>@Param</span><span>(</span><span>\"token_id\"</span><span>)</span> <span>String</span> tokenId<span>)</span><span>;</span>\n<span>}</span>\n<span>public</span> <span>class</span> <span>Test</span><span>{</span>\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>sql</span><span>(</span><span>)</span><span>{</span>\n        <span>// 读取配置信息</span>\n        <span>InputStream</span> mapperInputStream <span>=</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getContextClassLoader</span><span>(</span><span>)</span><span>.</span><span>getResourceAsStream</span><span>(</span><span>\"example05/mybatisConfig.xml\"</span><span>)</span><span>;</span>\n        <span>// 生成SqlSession工厂,SqlSession从名字上看就是,跟数据库交互的会话信息,负责将sql提交到数据库进行执行</span>\n        <span>SqlSessionFactory</span> sqlSessionFactory <span>=</span> <span>new</span> <span>SqlSessionFactoryBuilder</span><span>(</span><span>)</span><span>.</span><span>build</span><span>(</span>mapperInputStream<span>,</span> <span>\"development\"</span><span>)</span><span>;</span>\n        <span>// 获取Mybatis配置信息</span>\n        <span>Configuration</span> configuration <span>=</span> sqlSessionFactory<span>.</span><span>getConfiguration</span><span>(</span><span>)</span><span>;</span>\n        <span>SqlSession</span> sqlSession <span>=</span> sqlSessionFactory<span>.</span><span>openSession</span><span>(</span><span>false</span><span>)</span><span>;</span>\n        <span>// debug</span>\n        <span>T4UserMapper</span> mapper <span>=</span> configuration<span>.</span><span>getMapper</span><span>(</span><span>T4UserMapper</span><span>.</span><span>class</span><span>,</span> sqlSession<span>)</span><span>;</span>\n        <span>// 模拟sql注入 => null</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>mapper<span>.</span><span>queryUserById</span><span>(</span><span>37L</span><span>,</span><span>\"0 or 1 = 1\"</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>  \n\n<span>Created</span> connection <span>798981583.</span>\n<span>Setting</span> autocommit <span>to</span> <span>false</span> on JDBC <span>Connection</span> <span>[</span><span><span>com<span>.</span>mysql<span>.</span>cj<span>.</span>jdbc<span>.</span></span>ConnectionImpl</span><span>@2f9f7dcf</span><span>]</span>\n<span>==</span><span>></span>  <span>Preparing</span><span>:</span> select <span>*</span> from t_user where token_id <span>=</span> <span>?</span> and uid <span>=</span> <span>?</span>\n<span>==</span><span>></span> <span>Parameters</span><span>:</span> <span>0</span> or <span>1</span> <span>=</span> <span>1</span><span>(</span><span>String</span><span>)</span><span>,</span> <span>37</span><span>(</span><span>Long</span><span>)</span>\n<span>&lt;=</span><span>=</span>      <span>Total</span><span>:</span> <span>0</span>\n<span>null</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><p>以上演示代码可以在 <code>com.test.example05.SqlParseTest</code>中找到。那么无论是变量符还是占位符，其实都是sql组装,下面我们正式开始学习。</p>\n<p><mark>同样我们先提两个问题</mark></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1649510242000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_2-1-2-1-方法参数如何来解析\"> 2.1.2.1 方法参数如何来解析</h3>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1649510559000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>关键代码就在MapperMethod的execute的入参 Object [] args;\n关于参数的处理都在这里处理了。MethodSignature#convertArgsToSqlCommandParam。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>MapperMethod</span> <span>{</span>\n  <span>public</span> <span>Object</span> <span>execute</span><span>(</span><span>SqlSession</span> sqlSession<span>,</span> <span>Object</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n    <span>Object</span> result<span>;</span>\n    <span>switch</span> <span>(</span>command<span>.</span><span>getType</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n      <span>case</span> INSERT<span>:</span> <span>{</span>\n        <span>Object</span> param <span>=</span> method<span>.</span><span>convertArgsToSqlCommandParam</span><span>(</span>args<span>)</span><span>;</span>\n        result <span>=</span> <span>rowCountResult</span><span>(</span>sqlSession<span>.</span><span>insert</span><span>(</span>command<span>.</span><span>getName</span><span>(</span><span>)</span><span>,</span> param<span>)</span><span>)</span><span>;</span>\n        <span>break</span><span>;</span>\n      <span>}</span>\n      <span>case</span> UPDATE<span>:</span> <span>{</span>\n        <span>Object</span> param <span>=</span> method<span>.</span><span>convertArgsToSqlCommandParam</span><span>(</span>args<span>)</span><span>;</span>\n        result <span>=</span> <span>rowCountResult</span><span>(</span>sqlSession<span>.</span><span>update</span><span>(</span>command<span>.</span><span>getName</span><span>(</span><span>)</span><span>,</span> param<span>)</span><span>)</span><span>;</span>\n        <span>break</span><span>;</span>\n      <span>}</span>\n      <span>case</span> DELETE<span>:</span> <span>{</span>\n        <span>Object</span> param <span>=</span> method<span>.</span><span>convertArgsToSqlCommandParam</span><span>(</span>args<span>)</span><span>;</span>\n        result <span>=</span> <span>rowCountResult</span><span>(</span>sqlSession<span>.</span><span>delete</span><span>(</span>command<span>.</span><span>getName</span><span>(</span><span>)</span><span>,</span> param<span>)</span><span>)</span><span>;</span>\n        <span>break</span><span>;</span>\n      <span>}</span>\n    <span>.</span><span>.</span><span>.</span><span>.</span>  \n    <span>return</span> result<span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><div><pre><code><span>public</span> <span>Object</span> <span>convertArgsToSqlCommandParam</span><span>(</span><span>Object</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n    <span>return</span> paramNameResolver<span>.</span><span>getNamedParams</span><span>(</span>args<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>参数会被解析成什么样呢? 关键代码就在这里。</p>\n<div><pre><code> <span>public</span> <span>Object</span> <span>getNamedParams</span><span>(</span><span>Object</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n    <span>final</span> <span>int</span> paramCount <span>=</span> names<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span>\n    <span>// 没有参数直接返回</span>\n    <span>if</span> <span>(</span>args <span>==</span> <span>null</span> <span>||</span> paramCount <span>==</span> <span>0</span><span>)</span> <span>{</span>\n      <span>return</span> <span>null</span><span>;</span>\n    <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>!</span>hasParamAnnotation <span>&amp;&amp;</span> paramCount <span>==</span> <span>1</span><span>)</span> <span>{</span>\n      <span>// 没有注解只有一个参数</span>\n      <span>Object</span> value <span>=</span> args<span>[</span>names<span>.</span><span>firstKey</span><span>(</span><span>)</span><span>]</span><span>;</span>\n      <span>return</span> <span>wrapToMapIfCollection</span><span>(</span>value<span>,</span> useActualParamName <span>?</span> names<span>.</span><span>get</span><span>(</span><span>0</span><span>)</span> <span>:</span> <span>null</span><span>)</span><span>;</span>\n    <span>}</span> <span>else</span> <span>{</span>\n      <span>final</span> <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Object</span><span>></span></span> param <span>=</span> <span>new</span> <span>ParamMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n      <span>int</span> i <span>=</span> <span>0</span><span>;</span>\n      <span>// names key = 参数下标 value = @Param里面的值</span>\n      <span>for</span> <span>(</span><span>Map<span>.</span>Entry</span><span><span>&lt;</span><span>Integer</span><span>,</span> <span>String</span><span>></span></span> entry <span>:</span> names<span>.</span><span>entrySet</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n        <span>// key = @Param里面的值,value = args[index] 真实数据</span>\n        param<span>.</span><span>put</span><span>(</span>entry<span>.</span><span>getValue</span><span>(</span><span>)</span><span>,</span> args<span>[</span>entry<span>.</span><span>getKey</span><span>(</span><span>)</span><span>]</span><span>)</span><span>;</span>\n        <span>// 生成param1,参数</span>\n        <span>final</span> <span>String</span> genericParamName <span>=</span> GENERIC_NAME_PREFIX <span>+</span> <span>(</span>i <span>+</span> <span>1</span><span>)</span><span>;</span>\n        <span>// ensure not to overwrite parameter named with @Param</span>\n        <span>if</span> <span>(</span><span>!</span>names<span>.</span><span>containsValue</span><span>(</span>genericParamName<span>)</span><span>)</span> <span>{</span>\n          param<span>.</span><span>put</span><span>(</span>genericParamName<span>,</span> args<span>[</span>entry<span>.</span><span>getKey</span><span>(</span><span>)</span><span>]</span><span>)</span><span>;</span>\n        <span>}</span>\n        i<span>++</span><span>;</span>\n      <span>}</span>\n      <span>return</span> param<span>;</span>\n    <span>}</span>\n  <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>我们直接说结论,如果方法签名中使用了@Param注解结论,则占位符中的参数名就是注解的值。如果没有注解在就是arg+参数的位置.</p>\n<p><code>com.test.example04.MethodSignatureTest</code></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数类型</th>\n<th style=\"text-align:left\">方法签名</th>\n<th style=\"text-align:left\">参数值</th>\n<th style=\"text-align:left\">结果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">解析单参数不带@Param</td>\n<td style=\"text-align:left\">TUser queryUserByName(String name)</td>\n<td style=\"text-align:left\">methodSignature.convertArgsToSqlCommandParam(new Object[]{&quot;孙悟空&quot;})</td>\n<td style=\"text-align:left\">孙悟空</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">解析单参数带@Param</td>\n<td style=\"text-align:left\">TUser queryUserById(@Param(&quot;userId&quot;) Long id)</td>\n<td style=\"text-align:left\">methodSignature.convertArgsToSqlCommandParam(new Object[]{1L})</td>\n<td style=\"text-align:left\">{userId=1, param1=1}</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">解析多参数不带@Param</td>\n<td style=\"text-align:left\">TUser queryUserByTokenId(Long tokenId,String name)</td>\n<td style=\"text-align:left\">methodSignature.convertArgsToSqlCommandParam(new Object[]{1L, &quot;孙悟空&quot;})</td>\n<td style=\"text-align:left\">{arg0=1, arg1=孙悟空, param1=1, param2=孙悟空}</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">解析多参数带@Param</td>\n<td style=\"text-align:left\">TUser queryUserByTokenId(@Param(&quot;tokenId&quot;) Long tokenId, @Param(&quot;name&quot;) String name)</td>\n<td style=\"text-align:left\">methodSignature.convertArgsToSqlCommandParam(new Object[]{1L, &quot;孙悟空&quot;})</td>\n<td style=\"text-align:left\">{tokenId=1, name=孙悟空, param1=1, param2=孙悟空}</td>\n</tr>\n</tbody>\n</table>\n<p>如果项目编译中设置了编译后保存参数名，那么可以获取代码中编写的参数名。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1649512062000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>好了到这里我们知道方法的参数最终都会被Mybatis重新解析,解析后的结果可以看以上的表格。主要就是为拼装参数提前准备数据。下面我们看sql信息最终是如何最终组装的吧。</p>\n<h3 id=\"_2-1-2-2-方法参数组装\"> 2.1.2.2 方法参数组装</h3>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1649512620000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>这里我们思考一下，变量符应该是动态sql,在调用jdbc时候应该是下面的例子。</p>\n<div><pre><code> <span>PreparedStatement</span> preparedStatement <span>=</span> connection<span>.</span><span>prepareStatement</span><span>(</span><span>\"select * from t_user where token_id = 0 or 1 = 1 and uid = 37\"</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>那么我们就寻找哪里有这样的代码。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1649514573000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>PreparedStatementHandler#instantiateStatement.</p>\n<div><pre><code><span>@Override</span>\n  <span>protected</span> <span>Statement</span> <span>instantiateStatement</span><span>(</span><span>Connection</span> connection<span>)</span> <span>throws</span> <span>SQLException</span> <span>{</span>\n    <span>String</span> sql <span>=</span> boundSql<span>.</span><span>getSql</span><span>(</span><span>)</span><span>;</span>\n    <span>if</span> <span>(</span>mappedStatement<span>.</span><span>getKeyGenerator</span><span>(</span><span>)</span> <span>instanceof</span> <span>Jdbc3KeyGenerator</span><span>)</span> <span>{</span>\n      <span>String</span><span>[</span><span>]</span> keyColumnNames <span>=</span> mappedStatement<span>.</span><span>getKeyColumns</span><span>(</span><span>)</span><span>;</span>\n      <span>if</span> <span>(</span>keyColumnNames <span>==</span> <span>null</span><span>)</span> <span>{</span>\n        <span>return</span> connection<span>.</span><span>prepareStatement</span><span>(</span>sql<span>,</span> <span>PreparedStatement</span><span>.</span>RETURN_GENERATED_KEYS<span>)</span><span>;</span>\n      <span>}</span> <span>else</span> <span>{</span>\n        <span>return</span> connection<span>.</span><span>prepareStatement</span><span>(</span>sql<span>,</span> keyColumnNames<span>)</span><span>;</span>\n      <span>}</span>\n    <span>}</span> <span>else</span> <span>if</span> <span>(</span>mappedStatement<span>.</span><span>getResultSetType</span><span>(</span><span>)</span> <span>==</span> <span>ResultSetType</span><span>.</span>DEFAULT<span>)</span> <span>{</span>\n      <span>return</span> connection<span>.</span><span>prepareStatement</span><span>(</span>sql<span>)</span><span>;</span>\n    <span>}</span> <span>else</span> <span>{</span>\n      <span>return</span> connection<span>.</span><span>prepareStatement</span><span>(</span>sql<span>,</span> mappedStatement<span>.</span><span>getResultSetType</span><span>(</span><span>)</span><span>.</span><span>getValue</span><span>(</span><span>)</span><span>,</span> <span>ResultSet</span><span>.</span>CONCUR_READ_ONLY<span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>关键的代码就在这里静态sql,直接从MappedStatement#getBoundSql(Object parameterObject)#getSql()获取组装后的代码。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1649514858000.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>  <span>@Override</span>\n  <span>public</span> <span><span>&lt;</span><span>E</span><span>></span></span> <span>List</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>doQuery</span><span>(</span><span>MappedStatement</span> ms<span>,</span> <span>Object</span> parameter<span>,</span> <span>RowBounds</span> rowBounds<span>,</span> <span>ResultHandler</span> resultHandler<span>,</span> <span>BoundSql</span> boundSql<span>)</span> <span>throws</span> <span>SQLException</span> <span>{</span>\n    <span>Statement</span> stmt <span>=</span> <span>null</span><span>;</span>\n    <span>try</span> <span>{</span>\n      <span>Configuration</span> configuration <span>=</span> ms<span>.</span><span>getConfiguration</span><span>(</span><span>)</span><span>;</span>\n      <span>StatementHandler</span> handler <span>=</span> configuration<span>.</span><span>newStatementHandler</span><span>(</span>wrapper<span>,</span> ms<span>,</span> parameter<span>,</span> rowBounds<span>,</span> resultHandler<span>,</span> boundSql<span>)</span><span>;</span>\n      stmt <span>=</span> <span>prepareStatement</span><span>(</span>handler<span>,</span> ms<span>.</span><span>getStatementLog</span><span>(</span><span>)</span><span>)</span><span>;</span>\n      <span>return</span> handler<span>.</span><span>query</span><span>(</span>stmt<span>,</span> resultHandler<span>)</span><span>;</span>\n    <span>}</span> <span>finally</span> <span>{</span>\n      <span>closeStatement</span><span>(</span>stmt<span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n  \n  <span>// 这里parameterObject就是前面对方法参数的解析返回值。通过mappedStatement.getBoundSql(parameterObject)组装静态sql</span>\n  <span>protected</span> <span>PreparedStatementHandler</span><span>(</span><span>Executor</span> executor<span>,</span> <span>MappedStatement</span> mappedStatement<span>,</span> <span>Object</span> parameterObject<span>,</span> <span>RowBounds</span> rowBounds<span>,</span> <span>ResultHandler</span> resultHandler<span>,</span> <span>BoundSql</span> boundSql<span>)</span> <span>{</span>\n    <span>this</span><span>.</span>configuration <span>=</span> mappedStatement<span>.</span><span>getConfiguration</span><span>(</span><span>)</span><span>;</span>\n    <span>this</span><span>.</span>executor <span>=</span> executor<span>;</span>\n    <span>this</span><span>.</span>mappedStatement <span>=</span> mappedStatement<span>;</span>\n    <span>this</span><span>.</span>rowBounds <span>=</span> rowBounds<span>;</span>\n\n    <span>this</span><span>.</span>typeHandlerRegistry <span>=</span> configuration<span>.</span><span>getTypeHandlerRegistry</span><span>(</span><span>)</span><span>;</span>\n    <span>this</span><span>.</span>objectFactory <span>=</span> configuration<span>.</span><span>getObjectFactory</span><span>(</span><span>)</span><span>;</span>\n    <span>if</span> <span>(</span>boundSql <span>==</span> <span>null</span><span>)</span> <span>{</span> <span>// issue #435, get the key before calculating the statement</span>\n      <span>generateKeys</span><span>(</span>parameterObject<span>)</span><span>;</span>\n      boundSql <span>=</span> mappedStatement<span>.</span><span>getBoundSql</span><span>(</span>parameterObject<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>this</span><span>.</span>boundSql <span>=</span> boundSql<span>;</span>\n    <span>this</span><span>.</span>parameterHandler <span>=</span> configuration<span>.</span><span>newParameterHandler</span><span>(</span>mappedStatement<span>,</span> parameterObject<span>,</span> boundSql<span>)</span><span>;</span>\n    <span>this</span><span>.</span>resultSetHandler <span>=</span> configuration<span>.</span><span>newResultSetHandler</span><span>(</span>executor<span>,</span> mappedStatement<span>,</span> rowBounds<span>,</span> parameterHandler<span>,</span> resultHandler<span>,</span> boundSql<span>)</span><span>;</span>\n  <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p>好了，到这里我们就知道静态sql是哪里组装的了。关键点就在BoundSql这个类是如何构建的。我们以注解方式举例。</p>\n<p>在构建MappedStatement的时候,MapperBuilderAssistant#parse会解析Mapper类所有的方法,获取方法上的注解,生成Sql的信息。\n判断sql类型,如果是${}变量符,Sql资源就是DynamicSqlSource动态Sql。如果是#{}占位符就是RawSqlSource会将占位符替换成<code>?</code>,同时生成ParameterMapping信息\n用于方法执行时候使用PreparedStatement去set参数信息。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1649520231000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>下面我们以示例中的代码来看下BoundSql中究竟有什么信息。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1649520894000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>那么对于第一种DynamicSqlSource动态sql,参数信息是如何组装的呢?</p>\n<div><pre><code><span>public</span> <span>class</span> <span>DynamicSqlSource</span> <span>implements</span> <span>SqlSource</span> <span>{</span>\n\n  <span>private</span> <span>final</span> <span>Configuration</span> configuration<span>;</span>\n  <span>private</span> <span>final</span> <span>SqlNode</span> rootSqlNode<span>;</span>\n\n  <span>public</span> <span>DynamicSqlSource</span><span>(</span><span>Configuration</span> configuration<span>,</span> <span>SqlNode</span> rootSqlNode<span>)</span> <span>{</span>\n    <span>this</span><span>.</span>configuration <span>=</span> configuration<span>;</span>\n    <span>this</span><span>.</span>rootSqlNode <span>=</span> rootSqlNode<span>;</span>\n  <span>}</span>\n\n  <span>@Override</span>\n  <span>public</span> <span>BoundSql</span> <span>getBoundSql</span><span>(</span><span>Object</span> parameterObject<span>)</span> <span>{</span>\n    <span>DynamicContext</span> context <span>=</span> <span>new</span> <span>DynamicContext</span><span>(</span>configuration<span>,</span> parameterObject<span>)</span><span>;</span>\n    <span>// 处理sql中如果有&lt;if>&lt;where>&lt;Trim>等自带标签的情况,同时处理将变量符提供换成真正的参数。</span>\n    rootSqlNode<span>.</span><span>apply</span><span>(</span>context<span>)</span><span>;</span>\n    <span>// 当执行完上面的流程变量符就被替换成真正的参数了。下面在看是否同时也包含了#{}占位符,如果包含就替换成?</span>\n    <span>// 在调换成?的同时新增一个ParameterMapping对象</span>\n    <span>SqlSourceBuilder</span> sqlSourceParser <span>=</span> <span>new</span> <span>SqlSourceBuilder</span><span>(</span>configuration<span>)</span><span>;</span>\n    <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> parameterType <span>=</span> parameterObject <span>==</span> <span>null</span> <span>?</span> <span>Object</span><span>.</span><span>class</span> <span>:</span> parameterObject<span>.</span><span>getClass</span><span>(</span><span>)</span><span>;</span>\n    <span>SqlSource</span> sqlSource <span>=</span> sqlSourceParser<span>.</span><span>parse</span><span>(</span>context<span>.</span><span>getSql</span><span>(</span><span>)</span><span>,</span> parameterType<span>,</span> context<span>.</span><span>getBindings</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>BoundSql</span> boundSql <span>=</span> sqlSource<span>.</span><span>getBoundSql</span><span>(</span>parameterObject<span>)</span><span>;</span>\n    context<span>.</span><span>getBindings</span><span>(</span><span>)</span><span>.</span><span>forEach</span><span>(</span>boundSql<span>::</span><span>setAdditionalParameter</span><span>)</span><span>;</span>\n    <span>return</span> boundSql<span>;</span>\n  <span>}</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>核心的方法就是变量符替换,下面直接将核心的代码展示出来。</p>\n<div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>dynamicSql</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>// 读取配置信息(为什么路径前不用加/,因为是相对路径。maven编译后的资源文件和class文件都是在一个包下,所以不用加/就是当前包目录)</span>\n        <span>InputStream</span> mapperInputStream <span>=</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getContextClassLoader</span><span>(</span><span>)</span><span>.</span><span>getResourceAsStream</span><span>(</span><span>\"example05/mybatisConfig.xml\"</span><span>)</span><span>;</span>\n        <span>// 生成SqlSession工厂,SqlSession从名字上看就是,跟数据库交互的会话信息,负责将sql提交到数据库进行执行</span>\n        <span>SqlSessionFactory</span> sqlSessionFactory <span>=</span> <span>new</span> <span>SqlSessionFactoryBuilder</span><span>(</span><span>)</span><span>.</span><span>build</span><span>(</span>mapperInputStream<span>,</span> <span>\"development\"</span><span>)</span><span>;</span>\n        <span>// 获取Mybatis配置信息</span>\n        <span>Configuration</span> configuration <span>=</span> sqlSessionFactory<span>.</span><span>getConfiguration</span><span>(</span><span>)</span><span>;</span>\n        <span>// 生成动态Sql</span>\n        <span>TextSqlNode</span> textSqlNode <span>=</span> <span>new</span> <span>TextSqlNode</span><span>(</span><span>\"select * from t_user where token_id = ${token_id} and uid = ${uid}\"</span><span>)</span><span>;</span>\n        <span>DynamicSqlSource</span> dynamicSqlSource <span>=</span> <span>new</span> <span>DynamicSqlSource</span><span>(</span>configuration<span>,</span> textSqlNode<span>)</span><span>;</span>\n\n        <span>// 装参数</span>\n        <span>MapperMethod<span>.</span>ParamMap</span><span><span>&lt;</span><span>Object</span><span>></span></span> paramMap <span>=</span> <span>new</span> <span>MapperMethod<span>.</span>ParamMap</span><span><span>&lt;</span><span>Object</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        paramMap<span>.</span><span>put</span><span>(</span><span>\"uid\"</span><span>,</span><span>37L</span><span>)</span><span>;</span>\n        paramMap<span>.</span><span>put</span><span>(</span><span>\"token_id\"</span><span>,</span><span>\"0 or 1 = 1\"</span><span>)</span><span>;</span>\n        <span>BoundSql</span> boundSql <span>=</span> dynamicSqlSource<span>.</span><span>getBoundSql</span><span>(</span>paramMap<span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>boundSql<span>.</span><span>getSql</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n    \n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>dynamicSql2</span><span>(</span><span>)</span><span>{</span>\n        <span>// 读取配置信息(为什么路径前不用加/,因为是相对路径。maven编译后的资源文件和class文件都是在一个包下,所以不用加/就是当前包目录)</span>\n        <span>InputStream</span> mapperInputStream <span>=</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getContextClassLoader</span><span>(</span><span>)</span><span>.</span><span>getResourceAsStream</span><span>(</span><span>\"example05/mybatisConfig.xml\"</span><span>)</span><span>;</span>\n        <span>// 生成SqlSession工厂,SqlSession从名字上看就是,跟数据库交互的会话信息,负责将sql提交到数据库进行执行</span>\n        <span>SqlSessionFactory</span> sqlSessionFactory <span>=</span> <span>new</span> <span>SqlSessionFactoryBuilder</span><span>(</span><span>)</span><span>.</span><span>build</span><span>(</span>mapperInputStream<span>,</span> <span>\"development\"</span><span>)</span><span>;</span>\n        <span>// 获取Mybatis配置信息</span>\n        <span>Configuration</span> configuration <span>=</span> sqlSessionFactory<span>.</span><span>getConfiguration</span><span>(</span><span>)</span><span>;</span>\n\n        <span>// 装参数</span>\n        <span>MapperMethod<span>.</span>ParamMap</span><span><span>&lt;</span><span>Object</span><span>></span></span> paramMap <span>=</span> <span>new</span> <span>MapperMethod<span>.</span>ParamMap</span><span><span>&lt;</span><span>Object</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        paramMap<span>.</span><span>put</span><span>(</span><span>\"uid\"</span><span>,</span><span>37L</span><span>)</span><span>;</span>\n        paramMap<span>.</span><span>put</span><span>(</span><span>\"token_id\"</span><span>,</span><span>\"0 or 1 = 1\"</span><span>)</span><span>;</span>\n        <span>DynamicContext</span> context <span>=</span> <span>new</span> <span>DynamicContext</span><span>(</span>configuration<span>,</span> paramMap<span>)</span><span>;</span>\n\n        <span>// 生成动态Sql</span>\n        <span>TextSqlNode</span> textSqlNode <span>=</span> <span>new</span> <span>TextSqlNode</span><span>(</span><span>\"select * from t_user where token_id = ${token_id} and uid = ${uid}\"</span><span>)</span><span>;</span>\n        textSqlNode<span>.</span><span>apply</span><span>(</span>context<span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>context<span>.</span><span>getSql</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><p>好了，我们知道动态sql其实就是${}，变量符号替换。\n下面我们看静态sql是如何处理占位符的吧。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1649523284000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>前面我们说了静态sql,在初始化时候就会将占位符替换成? 同时生成一个ParameterMapping对象,然后在执行sql时候通过PreparedStatement进行set参数信息。\n那么我们先看占位符如何替换成?的吧。实现逻辑其实就在RawSqlSource的构造方法中。</p>\n<ul>\n<li>line(1-5) 在Mybatis初始化时候,会生成RawSqlSource。在构造中去调换占位符</li>\n<li>line(8-19) 占位符替换的实现方式,最终生成StaticSqlSource</li>\n<li>line(22-28) 占位符返回?的同时,生成一个ParameterMapping对象</li>\n</ul>\n<div><div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br></div><pre><code><span>public</span> <span>RawSqlSource</span><span>(</span><span>Configuration</span> configuration<span>,</span> <span>String</span> sql<span>,</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> parameterType<span>)</span> <span>{</span>\n    <span>SqlSourceBuilder</span> sqlSourceParser <span>=</span> <span>new</span> <span>SqlSourceBuilder</span><span>(</span>configuration<span>)</span><span>;</span>\n    <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> clazz <span>=</span> parameterType <span>==</span> <span>null</span> <span>?</span> <span>Object</span><span>.</span><span>class</span> <span>:</span> parameterType<span>;</span>\n    sqlSource <span>=</span> sqlSourceParser<span>.</span><span>parse</span><span>(</span>sql<span>,</span> clazz<span>,</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>)</span><span>;</span>\n<span>}</span>\n  \n<span>// sql = select * from t_user where token_id = #{token_id} and uid = #{uid}</span>\n<span>public</span> <span>SqlSource</span> <span>parse</span><span>(</span><span>String</span> originalSql<span>,</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> parameterType<span>,</span> <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Object</span><span>></span></span> additionalParameters<span>)</span> <span>{</span>\n    <span>ParameterMappingTokenHandler</span> handler <span>=</span> <span>new</span> <span>ParameterMappingTokenHandler</span><span>(</span>configuration<span>,</span> parameterType<span>,</span> additionalParameters<span>)</span><span>;</span>\n    <span>// 对</span>\n    <span>GenericTokenParser</span> parser <span>=</span> <span>new</span> <span>GenericTokenParser</span><span>(</span><span>\"#{\"</span><span>,</span> <span>\"}\"</span><span>,</span> handler<span>)</span><span>;</span>\n    <span>String</span> sql<span>;</span>\n    <span>if</span> <span>(</span>configuration<span>.</span><span>isShrinkWhitespacesInSql</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n      sql <span>=</span> parser<span>.</span><span>parse</span><span>(</span><span>removeExtraWhitespaces</span><span>(</span>originalSql<span>)</span><span>)</span><span>;</span>\n    <span>}</span> <span>else</span> <span>{</span>\n      sql <span>=</span> parser<span>.</span><span>parse</span><span>(</span>originalSql<span>)</span><span>;</span>\n    <span>}</span>\n    <span>return</span> <span>new</span> <span>StaticSqlSource</span><span>(</span>configuration<span>,</span> sql<span>,</span> handler<span>.</span><span>getParameterMappings</span><span>(</span><span>)</span><span>)</span><span>;</span>\n  <span>}</span>\n \n <span>// 会将占位符号#{token_id}替换成 ？同时生成一个ParameterMapping对象。</span>\n <span>private</span> <span>static</span> <span>class</span> <span>ParameterMappingTokenHandler</span> <span>extends</span> <span>BaseBuilder</span> <span>implements</span> <span>TokenHandler</span> <span>{</span>\n    <span>// content = token_id</span>\n    <span>@Override</span>\n    <span>public</span> <span>String</span> <span>handleToken</span><span>(</span><span>String</span> content<span>)</span> <span>{</span>\n      parameterMappings<span>.</span><span>add</span><span>(</span><span>buildParameterMapping</span><span>(</span>content<span>)</span><span>)</span><span>;</span>\n      <span>return</span> <span>\"?\"</span><span>;</span>\n    <span>}</span>\n <span>}</span>  \n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><p>到这里占位符的解析已经很清楚了。BoundSql中的数据我们也知道了，我们直接看参数组装的逻辑吧。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1649524815000.png\" alt=\"\" loading=\"lazy\"></p>\n<ol>\n<li>从boundSql中获取占位符信息。</li>\n<li>根据占位符获取参数信息</li>\n<li>根据参数类型确定使用那个TypeHandler，如果都没有指定就用UnknownTypeHandler</li>\n<li>UnknownTypeHandler会根据参数的类型，从默认配置中找到要用的类型,如果是Long类型就是PreparedStatement#setLong，如果是String类型就是PreparedStatement#setString</li>\n</ol>\n<div><pre><code><span>public</span> <span>class</span> <span>DefaultParameterHandler</span> <span>implements</span> <span>ParameterHandler</span> <span>{</span>\n  <span>@Override</span>\n  <span>public</span> <span>void</span> <span>setParameters</span><span>(</span><span>PreparedStatement</span> ps<span>)</span> <span>{</span>\n    <span>ErrorContext</span><span>.</span><span>instance</span><span>(</span><span>)</span><span>.</span><span>activity</span><span>(</span><span>\"setting parameters\"</span><span>)</span><span>.</span><span>object</span><span>(</span>mappedStatement<span>.</span><span>getParameterMap</span><span>(</span><span>)</span><span>.</span><span>getId</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>List</span><span><span>&lt;</span><span>ParameterMapping</span><span>></span></span> parameterMappings <span>=</span> boundSql<span>.</span><span>getParameterMappings</span><span>(</span><span>)</span><span>;</span>\n    <span>if</span> <span>(</span>parameterMappings <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n      <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> parameterMappings<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n        <span>ParameterMapping</span> parameterMapping <span>=</span> parameterMappings<span>.</span><span>get</span><span>(</span>i<span>)</span><span>;</span>\n        <span>if</span> <span>(</span>parameterMapping<span>.</span><span>getMode</span><span>(</span><span>)</span> <span>!=</span> <span>ParameterMode</span><span>.</span>OUT<span>)</span> <span>{</span>\n          <span>Object</span> value<span>;</span>\n          <span>String</span> propertyName <span>=</span> parameterMapping<span>.</span><span>getProperty</span><span>(</span><span>)</span><span>;</span>\n          <span>if</span> <span>(</span>boundSql<span>.</span><span>hasAdditionalParameter</span><span>(</span>propertyName<span>)</span><span>)</span> <span>{</span> <span>// issue #448 ask first for additional params</span>\n            value <span>=</span> boundSql<span>.</span><span>getAdditionalParameter</span><span>(</span>propertyName<span>)</span><span>;</span>\n          <span>}</span> <span>else</span> <span>if</span> <span>(</span>parameterObject <span>==</span> <span>null</span><span>)</span> <span>{</span>\n            value <span>=</span> <span>null</span><span>;</span>\n          <span>}</span> <span>else</span> <span>if</span> <span>(</span>typeHandlerRegistry<span>.</span><span>hasTypeHandler</span><span>(</span>parameterObject<span>.</span><span>getClass</span><span>(</span><span>)</span><span>)</span><span>)</span> <span>{</span>\n            value <span>=</span> parameterObject<span>;</span>\n          <span>}</span> <span>else</span> <span>{</span>\n            <span>MetaObject</span> metaObject <span>=</span> configuration<span>.</span><span>newMetaObject</span><span>(</span>parameterObject<span>)</span><span>;</span>\n            value <span>=</span> metaObject<span>.</span><span>getValue</span><span>(</span>propertyName<span>)</span><span>;</span>\n          <span>}</span>\n          <span>TypeHandler</span> typeHandler <span>=</span> parameterMapping<span>.</span><span>getTypeHandler</span><span>(</span><span>)</span><span>;</span>\n          <span>JdbcType</span> jdbcType <span>=</span> parameterMapping<span>.</span><span>getJdbcType</span><span>(</span><span>)</span><span>;</span>\n          <span>if</span> <span>(</span>value <span>==</span> <span>null</span> <span>&amp;&amp;</span> jdbcType <span>==</span> <span>null</span><span>)</span> <span>{</span>\n            jdbcType <span>=</span> configuration<span>.</span><span>getJdbcTypeForNull</span><span>(</span><span>)</span><span>;</span>\n          <span>}</span>\n          <span>try</span> <span>{</span>\n            typeHandler<span>.</span><span>setParameter</span><span>(</span>ps<span>,</span> i <span>+</span> <span>1</span><span>,</span> value<span>,</span> jdbcType<span>)</span><span>;</span>\n          <span>}</span> <span>catch</span> <span>(</span><span>TypeException</span> <span>|</span> <span>SQLException</span> e<span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>TypeException</span><span>(</span><span>\"Could not set parameters for mapping: \"</span> <span>+</span> parameterMapping <span>+</span> <span>\". Cause: \"</span> <span>+</span> e<span>,</span> e<span>)</span><span>;</span>\n          <span>}</span>\n        <span>}</span>\n      <span>}</span>\n    <span>}</span>\n  <span>}</span>\n\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br></div></div><p>好了到这里我们就搞清楚Mybatis中的参数是如何组装的了。 以及Jdbc是如何执行sql的了。\n这部分内容比较复杂，仅仅通过看是看不明白的，建议根据文中的代码自己走一边。加深理解。</p>\n<p>下面我们看Mybatis是如何处理返回值的吧。</p>\n<h2 id=\"_2-2-sql结果集是如何转换方法返回值的\"> 2.2 Sql结果集是如何转换方法返回值的?</h2>\n<p>我们重新回到PreparedStatementHandler中跟数据库打交道的地方,当PreparedStatement#execute发送sql给数据库后,最终处理结果集的类是\nResultHandler，下面我们就围绕这个类做分析。</p>\n<div><pre><code>  <span>@Override</span>\n  <span>public</span> <span><span>&lt;</span><span>E</span><span>></span></span> <span>List</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>query</span><span>(</span><span>Statement</span> statement<span>,</span> <span>ResultHandler</span> resultHandler<span>)</span> <span>throws</span> <span>SQLException</span> <span>{</span>\n    <span>PreparedStatement</span> ps <span>=</span> <span>(</span><span>PreparedStatement</span><span>)</span> statement<span>;</span>\n    ps<span>.</span><span>execute</span><span>(</span><span>)</span><span>;</span>\n    <span>return</span> resultSetHandler<span>.</span><span>handleResultSets</span><span>(</span>ps<span>)</span><span>;</span>\n  <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>ResultSetHandler,我们看接口定义,处理结果集就在这里了。我们再来看实现。</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>ResultSetHandler</span> <span>{</span>\n\n  <span><span>&lt;</span><span>E</span><span>></span></span> <span>List</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>handleResultSets</span><span>(</span><span>Statement</span> stmt<span>)</span> <span>throws</span> <span>SQLException</span><span>;</span>\n\n  <span><span>&lt;</span><span>E</span><span>></span></span> <span>Cursor</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>handleCursorResultSets</span><span>(</span><span>Statement</span> stmt<span>)</span> <span>throws</span> <span>SQLException</span><span>;</span>\n\n  <span>void</span> <span>handleOutputParameters</span><span>(</span><span>CallableStatement</span> cs<span>)</span> <span>throws</span> <span>SQLException</span><span>;</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>默认的实现DefaultResultSetHandler。Mybatis实现较为复杂，我们一开始可能看不懂。我们先用原生的jdbc来自己实现一边。\n然后脑子里有一个思路，然后在根据思路来看DefaultResultSetHandler的实现吧。</p>\n<h3 id=\"_2-2-1-jdbc提供的结果处理api\"> 2.2.1 JDBC提供的结果处理API</h3>\n<p>思路是statement执行完后会返回结果集ResultSet。\n结果集包含了返回的数据及这些数据对应的字段信息。\n然后拿到这些字段信息分别从结果集中获取数据。下面的代码如果明白了，我们就去看Mybatis中的源码</p>\n<div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>resultMetaData</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>String</span> dbUrl <span>=</span> <span>\"jdbc:mysql://127.0.0.1:3306/test\"</span><span>;</span>\n        <span>String</span> user <span>=</span> <span>\"root\"</span><span>;</span>\n        <span>String</span> pass <span>=</span> <span>\"123456\"</span><span>;</span>\n        <span>// 1. 获取数据库连接</span>\n        <span>Connection</span> connection <span>=</span> <span>DriverManager</span><span>.</span><span>getConnection</span><span>(</span>dbUrl<span>,</span> user<span>,</span> pass<span>)</span><span>;</span>\n        <span>Statement</span> statement <span>=</span> connection<span>.</span><span>createStatement</span><span>(</span><span>)</span><span>;</span>\n        <span>// 2. 执行sql语句获取结果集</span>\n        <span>ResultSet</span> resultSet <span>=</span> statement<span>.</span><span>executeQuery</span><span>(</span><span>\"select uid,name,token_id as tokenId from T_User\"</span><span>)</span><span>;</span>\n        <span>// 3. 从结果集中，获取数据库返回的数据列名</span>\n        <span>ResultSetMetaData</span> metaData <span>=</span> resultSet<span>.</span><span>getMetaData</span><span>(</span><span>)</span><span>;</span>\n        <span>int</span> columnCount <span>=</span> metaData<span>.</span><span>getColumnCount</span><span>(</span><span>)</span><span>;</span>\n        <span>// 所有的列名</span>\n        <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> columnNames <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        <span>// 列名对应的java类型</span>\n        <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Class</span><span>&lt;</span><span>?</span><span>></span><span>></span></span> column2JavaTypeAsMap <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;=</span> columnCount<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"字段:\"</span> <span>+</span> metaData<span>.</span><span>getColumnName</span><span>(</span>i<span>)</span> <span>+</span> <span>\"是否自增:\"</span> <span>+</span> metaData<span>.</span><span>isAutoIncrement</span><span>(</span>i<span>)</span><span>)</span><span>;</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"字段名:\"</span> <span>+</span> metaData<span>.</span><span>getColumnName</span><span>(</span>i<span>)</span><span>)</span><span>;</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"字段别名:\"</span> <span>+</span> metaData<span>.</span><span>getColumnLabel</span><span>(</span>i<span>)</span><span>)</span><span>;</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"MySql字段类型:\"</span> <span>+</span> metaData<span>.</span><span>getColumnTypeName</span><span>(</span>i<span>)</span><span>)</span><span>;</span>\n            <span>// Java 类的完全限定名称</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Java字段类型:\"</span> <span>+</span> metaData<span>.</span><span>getColumnClassName</span><span>(</span>i<span>)</span><span>)</span><span>;</span>\n            <span>// 获取指定列的指定列大小。</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"字段长度:\"</span> <span>+</span> metaData<span>.</span><span>getPrecision</span><span>(</span>i<span>)</span><span>)</span><span>;</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"字段保留小数位:\"</span> <span>+</span> metaData<span>.</span><span>getScale</span><span>(</span>i<span>)</span><span>)</span><span>;</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"字段属于的表名:\"</span> <span>+</span> metaData<span>.</span><span>getTableName</span><span>(</span>i<span>)</span><span>)</span><span>;</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"是否可为空:\"</span> <span>+</span> metaData<span>.</span><span>isNullable</span><span>(</span>i<span>)</span><span>)</span><span>;</span>\n            <span>// 这里使用别名,如果没有别名的情况,别名跟字段名是一样的。</span>\n            columnNames<span>.</span><span>add</span><span>(</span>metaData<span>.</span><span>getColumnLabel</span><span>(</span>i<span>)</span><span>)</span><span>;</span>\n            column2JavaTypeAsMap<span>.</span><span>put</span><span>(</span>metaData<span>.</span><span>getColumnLabel</span><span>(</span>i<span>)</span><span>,</span> <span>Class</span><span>.</span><span>forName</span><span>(</span>metaData<span>.</span><span>getColumnClassName</span><span>(</span>i<span>)</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>int</span> row <span>=</span> <span>1</span><span>;</span>\n        <span>while</span> <span>(</span>resultSet<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"----------第\"</span> <span>+</span> row <span>+</span> <span>\"行数据开始----------\"</span><span>)</span><span>;</span>\n            <span>for</span> <span>(</span><span>String</span> columnName <span>:</span> columnNames<span>)</span> <span>{</span>\n                <span>Object</span> columnValue <span>=</span> <span>getValue</span><span>(</span>columnName<span>,</span> resultSet<span>,</span> column2JavaTypeAsMap<span>)</span><span>;</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"列:\"</span> <span>+</span> columnName <span>+</span> <span>\":value:\"</span> <span>+</span> columnValue<span>)</span><span>;</span>\n            <span>}</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"----------第\"</span> <span>+</span> row <span>+</span> <span>\"行数据结束----------\"</span><span>)</span><span>;</span>\n            row<span>++</span><span>;</span>\n        <span>}</span>\n        resultSet<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n        statement<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n        connection<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 根据不同的字段类型,调用不同的方法获取数据\n     *\n     * @param columnName           列名\n     * @param resultSet            集合集\n     * @param column2JavaTypeAsMap 字段对应的Java类型\n     * @return 结果值\n     * @throws Exception 未知异常\n     */</span>\n    <span>public</span> <span>Object</span> <span>getValue</span><span>(</span><span>String</span> columnName<span>,</span> <span>ResultSet</span> resultSet<span>,</span> <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Class</span><span>&lt;</span><span>?</span><span>></span><span>></span></span> column2JavaTypeAsMap<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> column2JavaType <span>=</span> column2JavaTypeAsMap<span>.</span><span>get</span><span>(</span>columnName<span>)</span><span>;</span>\n        <span>Object</span> value <span>=</span> <span>null</span><span>;</span>\n        <span>if</span> <span>(</span>column2JavaType<span>.</span><span>equals</span><span>(</span><span>Integer</span><span>.</span><span>class</span><span>)</span><span>)</span> <span>{</span>\n            value <span>=</span> resultSet<span>.</span><span>getInt</span><span>(</span>columnName<span>)</span><span>;</span>\n        <span>}</span> <span>else</span> <span>if</span> <span>(</span>column2JavaType<span>.</span><span>equals</span><span>(</span><span>String</span><span>.</span><span>class</span><span>)</span><span>)</span> <span>{</span>\n            value <span>=</span> resultSet<span>.</span><span>getString</span><span>(</span>columnName<span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> value<span>;</span>\n    <span>}</span>\n    \n字段<span>:</span>uid是否自增<span>:</span><span>true</span>\n字段名<span>:</span>uid\n字段别名<span>:</span>uid\n<span>MySql</span>字段类型<span>:</span>INT\n<span>Java</span>字段类型<span>:</span><span><span>java<span>.</span>lang<span>.</span></span>Integer</span>\n字段长度<span>:</span><span>11</span>\n字段保留小数位<span>:</span><span>0</span>\n字段属于的表名<span>:</span>t_user\n是否可为空<span>:</span><span>0</span>\n字段<span>:</span>name是否自增<span>:</span><span>false</span>\n字段名<span>:</span>name\n字段别名<span>:</span>name\n<span>MySql</span>字段类型<span>:</span>CHAR\n<span>Java</span>字段类型<span>:</span><span><span>java<span>.</span>lang<span>.</span></span>String</span>\n字段长度<span>:</span><span>32</span>\n字段保留小数位<span>:</span><span>0</span>\n字段属于的表名<span>:</span>t_user\n是否可为空<span>:</span><span>1</span>\n字段<span>:</span>token_id是否自增<span>:</span><span>false</span>\n字段名<span>:</span>token_id\n字段别名<span>:</span>tokenId\n<span>MySql</span>字段类型<span>:</span>CHAR\n<span>Java</span>字段类型<span>:</span><span><span>java<span>.</span>lang<span>.</span></span>String</span>\n字段长度<span>:</span><span>64</span>\n字段保留小数位<span>:</span><span>0</span>\n字段属于的表名<span>:</span>t_user\n是否可为空<span>:</span><span>0</span>\n<span>--</span><span>--</span><span>--</span><span>--</span><span>--</span>第<span>1</span>行数据开始<span>--</span><span>--</span><span>--</span><span>--</span><span>--</span>\n列<span>:</span>uid<span>:</span>value<span>:</span><span>37</span>\n列<span>:</span>name<span>:</span>value<span>:</span>无天\n列<span>:</span>tokenId<span>:</span>value<span>:</span><span>60</span>\n<span>--</span><span>--</span><span>--</span><span>--</span><span>--</span>第<span>1</span>行数据结束<span>--</span><span>--</span><span>--</span><span>--</span><span>--</span>\n<span>--</span><span>--</span><span>--</span><span>--</span><span>--</span>第<span>2</span>行数据开始<span>--</span><span>--</span><span>--</span><span>--</span><span>--</span>\n列<span>:</span>uid<span>:</span>value<span>:</span><span>9846</span>\n列<span>:</span>name<span>:</span>value<span>:</span>斗战胜佛\n列<span>:</span>tokenId<span>:</span>value<span>:</span><span>80</span>\n<span>--</span><span>--</span><span>--</span><span>--</span><span>--</span>第<span>2</span>行数据结束<span>--</span><span>--</span><span>--</span><span>--</span><span>--</span>\n<span>--</span><span>--</span><span>--</span><span>--</span><span>--</span>第<span>3</span>行数据开始<span>--</span><span>--</span><span>--</span><span>--</span><span>--</span>\n列<span>:</span>uid<span>:</span>value<span>:</span><span>9847</span>\n列<span>:</span>name<span>:</span>value<span>:</span>净坛使者\n列<span>:</span>tokenId<span>:</span>value<span>:</span><span>90</span>\n<span>--</span><span>--</span><span>--</span><span>--</span><span>--</span>第<span>3</span>行数据结束<span>--</span><span>--</span><span>--</span><span>--</span><span>--</span>\n<span>--</span><span>--</span><span>--</span><span>--</span><span>--</span>第<span>4</span>行数据开始<span>--</span><span>--</span><span>--</span><span>--</span><span>--</span>\n列<span>:</span>uid<span>:</span>value<span>:</span><span>9848</span>\n列<span>:</span>name<span>:</span>value<span>:</span>无量功德佛祖\n列<span>:</span>tokenId<span>:</span>value<span>:</span><span>100</span>\n<span>--</span><span>--</span><span>--</span><span>--</span><span>--</span>第<span>4</span>行数据结束<span>--</span><span>--</span><span>--</span><span>--</span><span>--</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br></div></div><p>ResultSetMetaData 方法是比较重要的，这里把他常用的api方法及解释以表格形式列举一下。\n当我们拿到返回的列名，就可以直接根据列名来返回数据了。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">方法</th>\n<th style=\"text-align:left\">含义</th>\n<th style=\"text-align:left\">示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ResultSetMetaData#getColumnName</td>\n<td style=\"text-align:left\">获取数据库字段名</td>\n<td style=\"text-align:left\">name</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ResultSetMetaData#getColumnLabel</td>\n<td style=\"text-align:left\">查询语句中字段别名,如果没有保持跟字段名一致</td>\n<td style=\"text-align:left\">user_id as userId,这里就是userId</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ResultSetMetaData#getColumnTypeName</td>\n<td style=\"text-align:left\">返回Sql字段类型</td>\n<td style=\"text-align:left\">INT、CHAR</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ResultSetMetaData#getColumnClassName</td>\n<td style=\"text-align:left\">返回Java字段类型的完整限定名</td>\n<td style=\"text-align:left\">java.lang.String、java.lang.Integer</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ResultSetMetaData#getPrecision</td>\n<td style=\"text-align:left\">获取定义的字段长度</td>\n<td style=\"text-align:left\">int(11),返回11</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ResultSetMetaData#getScale</td>\n<td style=\"text-align:left\">获取字段定义的保留小数位</td>\n<td style=\"text-align:left\">-</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ResultSetMetaData#getTableName</td>\n<td style=\"text-align:left\">字段对应的表</td>\n<td style=\"text-align:left\">-</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ResultSetMetaData#isNullable</td>\n<td style=\"text-align:left\">字段是否可以为空</td>\n<td style=\"text-align:left\">-</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ResultSetMetaData#isAutoIncrement</td>\n<td style=\"text-align:left\">是否数据库自增字段</td>\n<td style=\"text-align:left\">-</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ResultSetMetaData#isAutoIncrement</td>\n<td style=\"text-align:left\">是否数据库自增字段</td>\n<td style=\"text-align:left\">-</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_2-2-2-mybatis获取结果集\"> 2.2.2 Mybatis获取结果集</h3>\n<p>思考下结果集可能是什么?</p>\n<ol>\n<li>场景一: 可能返回的是List</li>\n</ol>\n<div><pre><code>    <span>@Select</span><span>(</span><span>\"select * from t_user\"</span><span>)</span>\n    <span>List</span><span><span>&lt;</span><span>TUser</span><span>></span></span> <span>queryAllUsers</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><ol start=\"2\">\n<li>场景二: 可能返回的是单个对象</li>\n</ol>\n<div><pre><code>    <span>@Select</span><span>(</span><span>\"select * from t_user where uid = #{uid}\"</span><span>)</span>\n    <span>TUser</span> <span>queryUserByPlaceholderId</span><span>(</span><span>@Param</span><span>(</span><span>\"uid\"</span><span>)</span> <span>Long</span> uid<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><ol start=\"3\">\n<li>场景三: 更新语句返回结果集是条数。</li>\n</ol>\n<div><pre><code>    <span>@Update</span><span>(</span><span>\"update t_user set name = #{name}\"</span><span>)</span>\n    <span>int</span> <span>updateName</span><span>(</span><span>@Param</span><span>(</span><span>\"uid\"</span><span>)</span> <span>Long</span> uid<span>,</span> <span>@Param</span><span>(</span><span>\"name\"</span><span>)</span> <span>String</span> name<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><ol start=\"4\">\n<li>场景四: 更新语句返回boolean</li>\n</ol>\n<div><pre><code>    <span>@Update</span><span>(</span><span>\"update t_user set name = #{name} where uid = #{uid}\"</span><span>)</span>\n    <span>boolean</span> <span>updateNameById</span><span>(</span><span>@Param</span><span>(</span><span>\"uid\"</span><span>)</span> <span>Long</span> uid<span>,</span> <span>@Param</span><span>(</span><span>\"name\"</span><span>)</span> <span>String</span> name<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>分别来分析。</p>\n<h3 id=\"场景一\"> 场景一:</h3>\n<div><pre><code><span>public</span> <span>class</span> <span>MapperMethod</span> <span>{</span>\n    <span>private</span> <span>final</span> <span>MethodSignature</span> method<span>;</span>\n    <span>public</span> <span>Object</span> <span>execute</span><span>(</span><span>SqlSession</span> sqlSession<span>,</span> <span>Object</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>Object</span> result<span>;</span>\n        <span>switch</span> <span>(</span>command<span>.</span><span>getType</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n          <span>case</span> SELECT<span>:</span>\n            <span>if</span> <span>(</span>method<span>.</span><span>returnsVoid</span><span>(</span><span>)</span> <span>&amp;&amp;</span> method<span>.</span><span>hasResultHandler</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n              <span>executeWithResultHandler</span><span>(</span>sqlSession<span>,</span> args<span>)</span><span>;</span>\n              result <span>=</span> <span>null</span><span>;</span>\n            <span>}</span> <span>else</span> <span>if</span> <span>(</span>method<span>.</span><span>returnsMany</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n              result <span>=</span> <span>executeForMany</span><span>(</span>sqlSession<span>,</span> args<span>)</span><span>;</span>\n            <span>}</span> <span>else</span> <span>if</span> <span>(</span>method<span>.</span><span>returnsMap</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n              result <span>=</span> <span>executeForMap</span><span>(</span>sqlSession<span>,</span> args<span>)</span><span>;</span>\n            <span>}</span> <span>else</span> <span>if</span> <span>(</span>method<span>.</span><span>returnsCursor</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n              result <span>=</span> <span>executeForCursor</span><span>(</span>sqlSession<span>,</span> args<span>)</span><span>;</span>\n            <span>}</span> <span>else</span> <span>{</span>\n              <span>Object</span> param <span>=</span> method<span>.</span><span>convertArgsToSqlCommandParam</span><span>(</span>args<span>)</span><span>;</span>\n              result <span>=</span> sqlSession<span>.</span><span>selectOne</span><span>(</span>command<span>.</span><span>getName</span><span>(</span><span>)</span><span>,</span> param<span>)</span><span>;</span>\n              <span>if</span> <span>(</span>method<span>.</span><span>returnsOptional</span><span>(</span><span>)</span>\n                  <span>&amp;&amp;</span> <span>(</span>result <span>==</span> <span>null</span> <span>||</span> <span>!</span>method<span>.</span><span>getReturnType</span><span>(</span><span>)</span><span>.</span><span>equals</span><span>(</span>result<span>.</span><span>getClass</span><span>(</span><span>)</span><span>)</span><span>)</span><span>)</span> <span>{</span>\n                result <span>=</span> <span>Optional</span><span>.</span><span>ofNullable</span><span>(</span>result<span>)</span><span>;</span>\n              <span>}</span>\n            <span>}</span>\n            <span>break</span><span>;</span>\n          <span>case</span> FLUSH<span>:</span>\n            result <span>=</span> sqlSession<span>.</span><span>flushStatements</span><span>(</span><span>)</span><span>;</span>\n            <span>break</span><span>;</span>\n          <span>default</span><span>:</span>\n            <span>throw</span> <span>new</span> <span>BindingException</span><span>(</span><span>\"Unknown execution method for: \"</span> <span>+</span> command<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>if</span> <span>(</span>result <span>==</span> <span>null</span> <span>&amp;&amp;</span> method<span>.</span><span>getReturnType</span><span>(</span><span>)</span><span>.</span><span>isPrimitive</span><span>(</span><span>)</span> <span>&amp;&amp;</span> <span>!</span>method<span>.</span><span>returnsVoid</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n          <span>throw</span> <span>new</span> <span>BindingException</span><span>(</span><span>\"Mapper method '\"</span> <span>+</span> command<span>.</span><span>getName</span><span>(</span><span>)</span>\n              <span>+</span> <span>\" attempted to return null from a method with a primitive return type (\"</span> <span>+</span> method<span>.</span><span>getReturnType</span><span>(</span><span>)</span> <span>+</span> <span>\").\"</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> result<span>;</span>\n      <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><p>可以看到这里对于方法的返回值判断是根据MethodSignature,MethodSignature不仅提供了对参数的解析,同时也是对方法的分析。\n包括判断方法的返回值，我们看它的内部属性。</p>\n<div><pre><code> <span>public</span> <span>static</span> <span>class</span> <span>MethodSignature</span> <span>{</span>\n    <span>// 是否返回集合</span>\n    <span>private</span> <span>final</span> <span>boolean</span> returnsMany<span>;</span>\n    <span>// 是否返回是map结构</span>\n    <span>private</span> <span>final</span> <span>boolean</span> returnsMap<span>;</span>\n    <span>// 是否没有返回值</span>\n    <span>private</span> <span>final</span> <span>boolean</span> returnsVoid<span>;</span>\n    <span>// 是否返回的是游标</span>\n    <span>private</span> <span>final</span> <span>boolean</span> returnsCursor<span>;</span>\n    <span>// 是否返回的是Optional对象</span>\n    <span>private</span> <span>final</span> <span>boolean</span> returnsOptional<span>;</span>\n    <span>// 返回值类型</span>\n    <span>private</span> <span>final</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> returnType<span>;</span>\n    <span>// 返回map结构使用的key字段</span>\n    <span>private</span> <span>final</span> <span>String</span> mapKey<span>;</span>\n    <span>// 如果入参是ResultHandler 记录器下标</span>\n    <span>private</span> <span>final</span> <span>Integer</span> resultHandlerIndex<span>;</span>\n    <span>// 如果参数是RowBounds，记录其下标</span>\n    <span>private</span> <span>final</span> <span>Integer</span> rowBoundsIndex<span>;</span>\n    <span>// 参数处理</span>\n    <span>private</span> <span>final</span> <span>ParamNameResolver</span> paramNameResolver<span>;</span>\n    \n  <span>}</span>  \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>如果发现是返回List。则MethodSignature#returnsMany=true。直接调用SqlSession#selectList</p>\n<div><pre><code><span>private</span> <span><span>&lt;</span><span>E</span><span>></span></span> <span>Object</span> <span>executeForMany</span><span>(</span><span>SqlSession</span> sqlSession<span>,</span> <span>Object</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n    <span>List</span><span><span>&lt;</span><span>E</span><span>></span></span> result<span>;</span>\n    <span>Object</span> param <span>=</span> method<span>.</span><span>convertArgsToSqlCommandParam</span><span>(</span>args<span>)</span><span>;</span>\n    <span>// 方法中是否包含逻辑分页参数RowBounds</span>\n    <span>if</span> <span>(</span>method<span>.</span><span>hasRowBounds</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n      <span>// 如果有就获取逻辑分页参数</span>\n      <span>RowBounds</span> rowBounds <span>=</span> method<span>.</span><span>extractRowBounds</span><span>(</span>args<span>)</span><span>;</span>\n      <span>// 执行sql</span>\n      result <span>=</span> sqlSession<span>.</span><span>selectList</span><span>(</span>command<span>.</span><span>getName</span><span>(</span><span>)</span><span>,</span> param<span>,</span> rowBounds<span>)</span><span>;</span>\n    <span>}</span> <span>else</span> <span>{</span>\n      result <span>=</span> sqlSession<span>.</span><span>selectList</span><span>(</span>command<span>.</span><span>getName</span><span>(</span><span>)</span><span>,</span> param<span>)</span><span>;</span>\n    <span>}</span>\n    <span>// issue #510 Collections &amp; arrays support</span>\n    <span>if</span> <span>(</span><span>!</span>method<span>.</span><span>getReturnType</span><span>(</span><span>)</span><span>.</span><span>isAssignableFrom</span><span>(</span>result<span>.</span><span>getClass</span><span>(</span><span>)</span><span>)</span><span>)</span> <span>{</span>\n      <span>if</span> <span>(</span>method<span>.</span><span>getReturnType</span><span>(</span><span>)</span><span>.</span><span>isArray</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n        <span>return</span> <span>convertToArray</span><span>(</span>result<span>)</span><span>;</span>\n      <span>}</span> <span>else</span> <span>{</span>\n        <span>return</span> <span>convertToDeclaredCollection</span><span>(</span>sqlSession<span>.</span><span>getConfiguration</span><span>(</span><span>)</span><span>,</span> result<span>)</span><span>;</span>\n      <span>}</span>\n    <span>}</span>\n    <span>return</span> result<span>;</span>\n  <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>最终在DefaultResultSetHandler#handleResultSets处理返回值。下面的代码看了先不要害怕,其实\n思路跟我们用jdbc来处理是一样的。第一要拿到返回的数据信息。第二要将返回的数据信息包装成方法的返回值。\n只不过Mybatis将上面的两个能力,都提供成了对应的接口。其中数据的返回集就是ResultSetWrapper,从返回集中获取数据是TypeHandler。\n而将数据库返回的行数据，转换成方法的返回值就要用到ResultMap。</p>\n<div><pre><code>  <span>@Override</span>\n  <span>public</span> <span>List</span><span><span>&lt;</span><span>Object</span><span>></span></span> <span>handleResultSets</span><span>(</span><span>Statement</span> stmt<span>)</span> <span>throws</span> <span>SQLException</span> <span>{</span>\n    <span>ErrorContext</span><span>.</span><span>instance</span><span>(</span><span>)</span><span>.</span><span>activity</span><span>(</span><span>\"handling results\"</span><span>)</span><span>.</span><span>object</span><span>(</span>mappedStatement<span>.</span><span>getId</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\n    <span>final</span> <span>List</span><span><span>&lt;</span><span>Object</span><span>></span></span> multipleResults <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n\n    <span>int</span> resultSetCount <span>=</span> <span>0</span><span>;</span>\n    <span>// 读取返回的数据信息(jdbcType,javaType,列名和别名)</span>\n    <span>ResultSetWrapper</span> rsw <span>=</span> <span>getFirstResultSet</span><span>(</span>stmt<span>)</span><span>;</span>\n    <span>// Mapper签名中找到返回集应该信息</span>\n    <span>List</span><span><span>&lt;</span><span>ResultMap</span><span>></span></span> resultMaps <span>=</span> mappedStatement<span>.</span><span>getResultMaps</span><span>(</span><span>)</span><span>;</span>\n    <span>int</span> resultMapCount <span>=</span> resultMaps<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span>\n    <span>// 做个校验,如果sql执行后没有任何返回信息，但是Mapper签名中却指定了返回映射信息。则会报错告警 A query was run and no Result Maps were found for the Mapped Statement</span>\n    <span>validateResultMapsCount</span><span>(</span>rsw<span>,</span> resultMapCount<span>)</span><span>;</span>\n    <span>while</span> <span>(</span>rsw <span>!=</span> <span>null</span> <span>&amp;&amp;</span> resultMapCount <span>></span> resultSetCount<span>)</span> <span>{</span>\n      <span>ResultMap</span> resultMap <span>=</span> resultMaps<span>.</span><span>get</span><span>(</span>resultSetCount<span>)</span><span>;</span>\n      <span>// 处理返回集</span>\n      <span>handleResultSet</span><span>(</span>rsw<span>,</span> resultMap<span>,</span> multipleResults<span>,</span> <span>null</span><span>)</span><span>;</span>\n      rsw <span>=</span> <span>getNextResultSet</span><span>(</span>stmt<span>)</span><span>;</span>\n      <span>cleanUpAfterHandlingResultSet</span><span>(</span><span>)</span><span>;</span>\n      resultSetCount<span>++</span><span>;</span>\n    <span>}</span>\n\n    <span>String</span><span>[</span><span>]</span> resultSets <span>=</span> mappedStatement<span>.</span><span>getResultSets</span><span>(</span><span>)</span><span>;</span>\n    <span>if</span> <span>(</span>resultSets <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n      <span>while</span> <span>(</span>rsw <span>!=</span> <span>null</span> <span>&amp;&amp;</span> resultSetCount <span>&lt;</span> resultSets<span>.</span>length<span>)</span> <span>{</span>\n        <span>ResultMapping</span> parentMapping <span>=</span> nextResultMaps<span>.</span><span>get</span><span>(</span>resultSets<span>[</span>resultSetCount<span>]</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span>parentMapping <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n          <span>String</span> nestedResultMapId <span>=</span> parentMapping<span>.</span><span>getNestedResultMapId</span><span>(</span><span>)</span><span>;</span>\n          <span>ResultMap</span> resultMap <span>=</span> configuration<span>.</span><span>getResultMap</span><span>(</span>nestedResultMapId<span>)</span><span>;</span>\n          <span>handleResultSet</span><span>(</span>rsw<span>,</span> resultMap<span>,</span> <span>null</span><span>,</span> parentMapping<span>)</span><span>;</span>\n        <span>}</span>\n        rsw <span>=</span> <span>getNextResultSet</span><span>(</span>stmt<span>)</span><span>;</span>\n        <span>cleanUpAfterHandlingResultSet</span><span>(</span><span>)</span><span>;</span>\n        resultSetCount<span>++</span><span>;</span>\n      <span>}</span>\n    <span>}</span>\n\n    <span>return</span> <span>collapseSingleResultList</span><span>(</span>multipleResults<span>)</span><span>;</span>\n  <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><p>下面我们看这几个关键类。ResultSetWrapper。这个的源码是不是有点想我们前面自己写的原生jdbc的方法了?\n拿到返回的列名和对应的java类型。</p>\n<div><pre><code> <span>public</span> <span>ResultSetWrapper</span><span>(</span><span>ResultSet</span> rs<span>,</span> <span>Configuration</span> configuration<span>)</span> <span>throws</span> <span>SQLException</span> <span>{</span>\n    <span>super</span><span>(</span><span>)</span><span>;</span>\n    <span>this</span><span>.</span>typeHandlerRegistry <span>=</span> configuration<span>.</span><span>getTypeHandlerRegistry</span><span>(</span><span>)</span><span>;</span>\n    <span>this</span><span>.</span>resultSet <span>=</span> rs<span>;</span>\n    <span>final</span> <span>ResultSetMetaData</span> metaData <span>=</span> rs<span>.</span><span>getMetaData</span><span>(</span><span>)</span><span>;</span>\n    <span>final</span> <span>int</span> columnCount <span>=</span> metaData<span>.</span><span>getColumnCount</span><span>(</span><span>)</span><span>;</span>\n    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;=</span> columnCount<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n      columnNames<span>.</span><span>add</span><span>(</span>configuration<span>.</span><span>isUseColumnLabel</span><span>(</span><span>)</span> <span>?</span> metaData<span>.</span><span>getColumnLabel</span><span>(</span>i<span>)</span> <span>:</span> metaData<span>.</span><span>getColumnName</span><span>(</span>i<span>)</span><span>)</span><span>;</span>\n      jdbcTypes<span>.</span><span>add</span><span>(</span><span>JdbcType</span><span>.</span><span>forCode</span><span>(</span>metaData<span>.</span><span>getColumnType</span><span>(</span>i<span>)</span><span>)</span><span>)</span><span>;</span>\n      classNames<span>.</span><span>add</span><span>(</span>metaData<span>.</span><span>getColumnClassName</span><span>(</span>i<span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>TypeHandler 是从jdbc中获取数据的接口，这个功能就跟前面我们用原生API实现时候的getValue方法类似。\n主要是根据数据的类型，来确定是调用ResultSet#getString还是调用ResultSet#getInt等方法。</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>TypeHandler</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>{</span>\n\n  <span>void</span> <span>setParameter</span><span>(</span><span>PreparedStatement</span> ps<span>,</span> <span>int</span> i<span>,</span> <span>T</span> parameter<span>,</span> <span>JdbcType</span> jdbcType<span>)</span> <span>throws</span> <span>SQLException</span><span>;</span>\n\n  <span>T</span> <span>getResult</span><span>(</span><span>ResultSet</span> rs<span>,</span> <span>String</span> columnName<span>)</span> <span>throws</span> <span>SQLException</span><span>;</span>\n\n  <span>T</span> <span>getResult</span><span>(</span><span>CallableStatement</span> cs<span>,</span> <span>int</span> columnIndex<span>)</span> <span>throws</span> <span>SQLException</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>ResultMap 是返回数据对应的Java对象。会在生成MappedStatement时候构建完成。如果是在xml中定义了就是 <code>&lt;resultMap/&gt;</code> 标签,如果没有就是\n根据返回类自动生成一个resultMap。可以看到这个类属性其实跟他的标签是一样的。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>ResultMap</span> <span>{</span>\n  <span>private</span> <span>Configuration</span> configuration<span>;</span>\n\n  <span>// 如果配置了&lt;resultMap id=\"BaseResultMap\" ，就是类全路径名+BaseResultMap。如果没有就是类名加方法名+Inline</span>\n  <span>private</span> <span>String</span> id<span>;</span>\n  <span>private</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> type<span>;</span>\n  <span>private</span> <span>List</span><span><span>&lt;</span><span>ResultMapping</span><span>></span></span> resultMappings<span>;</span>\n  <span>private</span> <span>List</span><span><span>&lt;</span><span>ResultMapping</span><span>></span></span> idResultMappings<span>;</span>\n  <span>private</span> <span>List</span><span><span>&lt;</span><span>ResultMapping</span><span>></span></span> constructorResultMappings<span>;</span>\n  <span>private</span> <span>List</span><span><span>&lt;</span><span>ResultMapping</span><span>></span></span> propertyResultMappings<span>;</span>\n  <span>private</span> <span>Set</span><span><span>&lt;</span><span>String</span><span>></span></span> mappedColumns<span>;</span>\n  <span>private</span> <span>Set</span><span><span>&lt;</span><span>String</span><span>></span></span> mappedProperties<span>;</span>\n  <span>private</span> <span>Discriminator</span> discriminator<span>;</span>\n  <span>private</span> <span>boolean</span> hasNestedResultMaps<span>;</span>\n  <span>private</span> <span>boolean</span> hasNestedQueries<span>;</span>\n  <span>private</span> <span>Boolean</span> autoMapping<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>ResultMap的标签功能比较强大,我们深入研究下。举一个例子。</p>\n<div><pre><code><span>/**\n * 一个学校，一个校长，多个学生\n * name,headMaster(id,name),users()\n * 2022/4/10 22:07\n */</span>\n<span>@Data</span>\n<span>public</span> <span>class</span> <span>School</span> <span>{</span>\n\n    <span>private</span> <span>Long</span> id<span>;</span>\n\n    <span>private</span> <span>String</span> name<span>;</span>\n\n    <span>private</span> <span>SchoolHeadMaster</span> schoolHeadMaster<span>;</span>\n\n    <span>private</span> <span>List</span><span><span>&lt;</span><span>Student</span><span>></span></span> students<span>;</span>\n\n<span>}</span>\n<span>@Data</span>\n<span>public</span> <span>class</span> <span>SchoolHeadMaster</span> <span>{</span>\n\n    <span>private</span> <span>Long</span> id<span>;</span>\n\n    <span>private</span> <span>String</span> name<span>;</span>\n<span>}</span>\n\n<span>@Data</span>\n<span>public</span> <span>class</span> <span>Student</span> <span>{</span>\n\n    <span>private</span> <span>Long</span> id<span>;</span>\n\n    <span>private</span> <span>String</span> name<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><p>配置文件如下</p>\n<div><pre><code><span><span><span>&lt;</span>mapper</span> <span>namespace</span><span><span>=</span><span>\"</span>orm.example.dal.mapper.SchoolMapper<span>\"</span></span><span>></span></span>\n    <span><span><span>&lt;</span>resultMap</span> <span>id</span><span><span>=</span><span>\"</span>BaseResultMap<span>\"</span></span> <span>type</span><span><span>=</span><span>\"</span>orm.example.dal.model.TUser<span>\"</span></span><span>></span></span>\n        <span><span><span>&lt;</span>id</span> <span>column</span><span><span>=</span><span>\"</span>token_id<span>\"</span></span> <span>jdbcType</span><span><span>=</span><span>\"</span>CHAR<span>\"</span></span> <span>property</span><span><span>=</span><span>\"</span>tokenId<span>\"</span></span><span>/></span></span>\n        <span><span><span>&lt;</span>result</span> <span>column</span><span><span>=</span><span>\"</span>uid<span>\"</span></span> <span>jdbcType</span><span><span>=</span><span>\"</span>INTEGER<span>\"</span></span> <span>property</span><span><span>=</span><span>\"</span>uid<span>\"</span></span><span>/></span></span>\n        <span><span><span>&lt;</span>result</span> <span>column</span><span><span>=</span><span>\"</span>name<span>\"</span></span> <span>jdbcType</span><span><span>=</span><span>\"</span>CHAR<span>\"</span></span> <span>property</span><span><span>=</span><span>\"</span>name<span>\"</span></span><span>/></span></span>\n    <span><span><span>&lt;/</span>resultMap</span><span>></span></span>\n\n    <span><span><span>&lt;</span>resultMap</span> <span>id</span><span><span>=</span><span>\"</span>schoolResultMap<span>\"</span></span> <span>type</span><span><span>=</span><span>\"</span>orm.example.dal.model.School<span>\"</span></span><span>></span></span>\n        <span><span><span>&lt;</span>result</span> <span>column</span><span><span>=</span><span>\"</span>schoolId<span>\"</span></span> <span>jdbcType</span><span><span>=</span><span>\"</span>CHAR<span>\"</span></span> <span>property</span><span><span>=</span><span>\"</span>id<span>\"</span></span><span>/></span></span>\n        <span><span><span>&lt;</span>result</span> <span>column</span><span><span>=</span><span>\"</span>schoolName<span>\"</span></span> <span>jdbcType</span><span><span>=</span><span>\"</span>CHAR<span>\"</span></span> <span>property</span><span><span>=</span><span>\"</span>name<span>\"</span></span><span>/></span></span>\n        <span>&lt;!--        学校校长跟学校关系1对1--></span>\n        <span><span><span>&lt;</span>association</span> <span>property</span><span><span>=</span><span>\"</span>schoolHeadMaster<span>\"</span></span> <span>javaType</span><span><span>=</span><span>\"</span>orm.example.dal.model.SchoolHeadMaster<span>\"</span></span><span>></span></span>\n            <span><span><span>&lt;</span>id</span> <span>column</span><span><span>=</span><span>\"</span>hmId<span>\"</span></span> <span>property</span><span><span>=</span><span>\"</span>id<span>\"</span></span><span>/></span></span>\n            <span><span><span>&lt;</span>result</span> <span>column</span><span><span>=</span><span>\"</span>schoolHeadName<span>\"</span></span> <span>jdbcType</span><span><span>=</span><span>\"</span>CHAR<span>\"</span></span> <span>property</span><span><span>=</span><span>\"</span>name<span>\"</span></span><span>/></span></span>\n        <span><span><span>&lt;/</span>association</span><span>></span></span>\n        <span>&lt;!--        学生关系是1对n--></span>\n        <span><span><span>&lt;</span>collection</span> <span>property</span><span><span>=</span><span>\"</span>students<span>\"</span></span> <span>javaType</span><span><span>=</span><span>\"</span>list<span>\"</span></span> <span>ofType</span><span><span>=</span><span>\"</span>orm.example.dal.model.Student<span>\"</span></span><span>></span></span>\n            <span><span><span>&lt;</span>id</span> <span>column</span><span><span>=</span><span>\"</span>studentId<span>\"</span></span> <span>property</span><span><span>=</span><span>\"</span>id<span>\"</span></span><span>/></span></span>\n            <span><span><span>&lt;</span>result</span> <span>column</span><span><span>=</span><span>\"</span>studentName<span>\"</span></span> <span>jdbcType</span><span><span>=</span><span>\"</span>CHAR<span>\"</span></span> <span>property</span><span><span>=</span><span>\"</span>name<span>\"</span></span><span>/></span></span>\n        <span><span><span>&lt;/</span>collection</span><span>></span></span>\n    <span><span><span>&lt;/</span>resultMap</span><span>></span></span>\n\n\n    <span><span><span>&lt;</span>select</span> <span>id</span><span><span>=</span><span>\"</span>selectSchool<span>\"</span></span> <span>resultMap</span><span><span>=</span><span>\"</span>schoolResultMap<span>\"</span></span><span>></span></span>\n        select school.id as 'schoolId', school.name as 'schoolName', hm.id as 'hmId', hm.name as 'schoolHeadName', s.name as 'studentName', s.id as 'studentId'\n        from school\n                 left join head_master hm on hm.id = school.head_master_id\n                 left join student s on school.id = s.school_id\n    <span><span><span>&lt;/</span>select</span><span>></span></span>\n<span><span><span>&lt;/</span>mapper</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p>执行数据验证 <code>com.test.example05.ResultMapTest#parseResultMap</code></p>\n<ul>\n<li>line(11-22) 获取MappedStatement观察复杂对象ResultMap是什么样。</li>\n</ul>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1649604916000.png\" alt=\"\" loading=\"lazy\"></p>\n<ul>\n<li>line(25-26) 观察mybatis如何填充数据。</li>\n</ul>\n<div><div><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>parseResultMap</span><span>(</span><span>)</span> <span>{</span>\n        <span>// 读取配置信息(为什么路径前不用加/,因为是相对路径。maven编译后的资源文件和class文件都是在一个包下,所以不用加/就是当前包目录)</span>\n        <span>InputStream</span> mapperInputStream <span>=</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getContextClassLoader</span><span>(</span><span>)</span><span>.</span><span>getResourceAsStream</span><span>(</span><span>\"example05/mybatisConfig-ResultMap.xml\"</span><span>)</span><span>;</span>\n        <span>// 生成SqlSession工厂,SqlSession从名字上看就是,跟数据库交互的会话信息,负责将sql提交到数据库进行执行</span>\n        <span>SqlSessionFactory</span> sqlSessionFactory <span>=</span> <span>new</span> <span>SqlSessionFactoryBuilder</span><span>(</span><span>)</span><span>.</span><span>build</span><span>(</span>mapperInputStream<span>,</span> <span>\"development\"</span><span>)</span><span>;</span>\n        <span>// 获取Mybatis配置信息</span>\n        <span>Configuration</span> configuration <span>=</span> sqlSessionFactory<span>.</span><span>getConfiguration</span><span>(</span><span>)</span><span>;</span>\n\n        <span>// 只要看这个复杂对象如何映射。</span>\n        <span>MappedStatement</span> selectSchool <span>=</span> configuration<span>.</span><span>getMappedStatement</span><span>(</span><span>\"orm.example.dal.mapper.SchoolMapper.selectSchool\"</span><span>)</span><span>;</span>\n        <span>ResultMap</span> resultMap <span>=</span> selectSchool<span>.</span><span>getResultMaps</span><span>(</span><span>)</span><span>.</span><span>get</span><span>(</span><span>0</span><span>)</span><span>;</span>\n        <span>// 确定是一个复杂对象，规则是XMLMapperBuilder#processNestedResultMappings,只要发现查询语句对象的结果中有以下标签\"association\", \"collection\", \"case\"。就是复杂sql</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"是否复杂对象:\"</span> <span>+</span> resultMap<span>.</span><span>hasNestedResultMaps</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>List</span><span><span>&lt;</span><span>ResultMapping</span><span>></span></span> propertyResultMappings <span>=</span> resultMap<span>.</span><span>getPropertyResultMappings</span><span>(</span><span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>ResultMapping</span> propertyResultMapping <span>:</span> propertyResultMappings<span>)</span> <span>{</span>\n            <span>// 1. 属性:id,db列名:schoolId,JavaType:class java.lang.Long</span>\n            <span>// 2. 属性:name,db列名:schoolName,JavaType:class java.lang.String</span>\n            <span>// 3. 属性:schoolHeadMaster,db列名:null,JavaType:class orm.example.dal.model.SchoolHeadMaster,映射NestedResultMapId</span>\n            <span>// 4. 属性:students,db列名:null,JavaType:interface java.util.List,映射NestedResultMapId</span>\n            <span>printResultMapping</span><span>(</span>propertyResultMapping<span>,</span> configuration<span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>// [School(id=1, name=西天小学, schoolHeadMaster=SchoolHeadMaster(id=1, name=如来), students=[Student(id=1, name=孙悟空), Student(id=2, name=猪八戒), Student(id=3, name=唐三藏)])]</span>\n        <span>List</span><span><span>&lt;</span><span>School</span><span>></span></span> schools <span>=</span> configuration<span>.</span><span>getMapper</span><span>(</span><span>SchoolMapper</span><span>.</span><span>class</span><span>,</span> sqlSessionFactory<span>.</span><span>openSession</span><span>(</span><span>false</span><span>)</span><span>)</span><span>.</span><span>selectSchool</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>schools<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>private</span> <span>static</span> <span>void</span> <span>printResultMapping</span><span>(</span><span>ResultMapping</span> propertyResultMapping<span>,</span> <span>Configuration</span> configuration<span>)</span> <span>{</span>\n        <span>String</span> property <span>=</span> propertyResultMapping<span>.</span><span>getProperty</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"属性:\"</span> <span>+</span> property <span>+</span> <span>\",db列名:\"</span> <span>+</span> propertyResultMapping<span>.</span><span>getColumn</span><span>(</span><span>)</span> <span>+</span> <span>\",JavaType:\"</span> <span>+</span> propertyResultMapping<span>.</span><span>getJavaType</span><span>(</span><span>)</span> <span>+</span> <span>\",映射NestedResultMapId:\"</span> <span>+</span> propertyResultMapping<span>.</span><span>getNestedResultMapId</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>String</span> nestedResultMapId <span>=</span> propertyResultMapping<span>.</span><span>getNestedResultMapId</span><span>(</span><span>)</span><span>;</span>\n        <span>// 如果不等于空,说明是复杂对象。从配置文件中获取复杂属性的映射集合</span>\n        <span>if</span> <span>(</span><span>Objects</span><span>.</span><span>nonNull</span><span>(</span>nestedResultMapId<span>)</span><span>)</span> <span>{</span>\n            <span>ResultMap</span> nestedResultMap <span>=</span> configuration<span>.</span><span>getResultMap</span><span>(</span>nestedResultMapId<span>)</span><span>;</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>nestedResultMap<span>.</span><span>getType</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"是否复杂对象:\"</span> <span>+</span> nestedResultMap<span>.</span><span>hasNestedResultMaps</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>List</span><span><span>&lt;</span><span>ResultMapping</span><span>></span></span> propertyResultMappings <span>=</span> nestedResultMap<span>.</span><span>getPropertyResultMappings</span><span>(</span><span>)</span><span>;</span>\n            <span>for</span> <span>(</span><span>ResultMapping</span> resultMapping <span>:</span> propertyResultMappings<span>)</span> <span>{</span>\n                <span>printResultMapping</span><span>(</span>resultMapping<span>,</span> configuration<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><p>下面我们就看如何填充数据了。同样我们直接手撸代码。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">schoolId</th>\n<th style=\"text-align:left\">schoolName</th>\n<th style=\"text-align:left\">hmId</th>\n<th style=\"text-align:left\">schoolHeadName</th>\n<th style=\"text-align:left\">studentName</th>\n<th style=\"text-align:left\">studentId</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">西天小学</td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">如来</td>\n<td style=\"text-align:left\">孙悟空</td>\n<td style=\"text-align:left\">1</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">西天小学</td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">如来</td>\n<td style=\"text-align:left\">猪八戒</td>\n<td style=\"text-align:left\">2</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">西天小学</td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">如来</td>\n<td style=\"text-align:left\">唐三藏</td>\n<td style=\"text-align:left\">3</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">湖畔大学</td>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">马云</td>\n<td style=\"text-align:left\">马化腾</td>\n<td style=\"text-align:left\">4</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">湖畔大学</td>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">马云</td>\n<td style=\"text-align:left\">谢霆锋</td>\n<td style=\"text-align:left\">5</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">湖畔大学</td>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">马云</td>\n<td style=\"text-align:left\">张学友</td>\n<td style=\"text-align:left\">6</td>\n</tr>\n</tbody>\n</table>\n<p>Mybatis中处理返回值，分一下基础。简单对象和复杂对象这里我们直接用复杂对象距离。\n可以看到School中有2个基本属性和1个对象属性还有一个集合属性。</p>\n<p>看这个图。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1649604916000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>这部分示例代码在 <code>com.test.example05.ResultMapTest#handlerResultSet</code></p>\n<ul>\n<li>line(26) 首先我们要获取数据库返回列信息</li>\n<li>line(30) 一行一行读取数据，每次执行ResultSet#next就是下一行</li>\n<li>line(41) 因为我们School中有一个是集合属性,需要将多行数据转换成一行。此时我们执行完getRowValue\n会生成一个数据。但是这个数据不能直接就用, 还需要将第二行的数据也赋值到第一行的返回值中,这是我们就将\n第一行的数据返回值,带进去。</li>\n<li>line(41) 我们如何知道这6行数据如何合并。规则: 简单对象进行拼接，School中简单对象是id,和name。</li>\n<li>line(44) getRowValue中的每个方法都要注意看</li>\n<li>line(93-99) 主要处理是否需要合并行，合并行的时候直接填充数据接口。而不是合并则缓存中查不到数据，就重新生成一个结果。</li>\n<li>line(104) 判断ResultMap是否是一个复杂对象,这里School是一个复杂对象,因为不仅有一个HeadMaster还有一个List的学生集合。</li>\n<li>line(109) 第一次进去这里会有4个对象,id，name,schoolHeadMaster,students</li>\n<li>line(115-118) 对于School中的id和name都会在这几行被执行了。可以看到根据javaType找到了TypeHandler，然后TypeHandler负责取值。</li>\n<li>line(141) 对于schoolHeadMaster这个属性,是复杂对象,School中的Java类型是SchoolHeadMaster和他对应的ResultMap中的类型是一样的，\n则递归去获取数据,因为SchoolHeadMaster中也是都简单类型的id和name,所以最终也会在line(115-118)被执行了。</li>\n<li>line(125-138) School中的students，java类型是List,ResultMap中类型是Student，所以要先从第一行的数据去获取这个属性\n看List是否被实例化了，如果没有就实例化。然后执行add操作给list中数据追加值。</li>\n</ul>\n<p>主要这里我们使用了MetaObject这个工具,是一个包装方法。不详细介绍了，如果还不清楚请跳转</p>\n<p><a href=\"http://localhost:8080/learn/mybatis/%E6%A0%B8%E5%BF%83%E7%B1%BB%E4%BB%8B%E7%BB%8D/#_1-5-objectwrapperfactory-%E5%AF%B9%E8%B1%A1%E5%8C%85%E8%A3%85%E5%B7%A5%E5%8E%82\" target=\"_blank\" rel=\"noopener noreferrer\">第03篇:Mybatis核心类详细介绍</a></p>\n<div><div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>handlerResultSet</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n\n        <span>// 读取配置信息(为什么路径前不用加/,因为是相对路径。maven编译后的资源文件和class文件都是在一个包下,所以不用加/就是当前包目录)</span>\n        <span>InputStream</span> mapperInputStream <span>=</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getContextClassLoader</span><span>(</span><span>)</span><span>.</span><span>getResourceAsStream</span><span>(</span><span>\"example05/mybatisConfig-ResultMap.xml\"</span><span>)</span><span>;</span>\n        <span>// 生成SqlSession工厂,SqlSession从名字上看就是,跟数据库交互的会话信息,负责将sql提交到数据库进行执行</span>\n        <span>SqlSessionFactory</span> sqlSessionFactory <span>=</span> <span>new</span> <span>SqlSessionFactoryBuilder</span><span>(</span><span>)</span><span>.</span><span>build</span><span>(</span>mapperInputStream<span>,</span> <span>\"development\"</span><span>)</span><span>;</span>\n        <span>// 获取Mybatis配置信息</span>\n        <span>Configuration</span> configuration <span>=</span> sqlSessionFactory<span>.</span><span>getConfiguration</span><span>(</span><span>)</span><span>;</span>\n\n        <span>// 只要看这个复杂对象如何映射。</span>\n        <span>MappedStatement</span> selectSchool <span>=</span> configuration<span>.</span><span>getMappedStatement</span><span>(</span><span>\"orm.example.dal.mapper.SchoolMapper.selectSchool\"</span><span>)</span><span>;</span>\n        <span>ResultMap</span> resultMap <span>=</span> selectSchool<span>.</span><span>getResultMaps</span><span>(</span><span>)</span><span>.</span><span>get</span><span>(</span><span>0</span><span>)</span><span>;</span>\n\n        <span>PreparedStatement</span> preparedStatement <span>=</span> <span>execute</span><span>(</span><span>\"select school.id   as 'schoolId',\\n\"</span> <span>+</span>\n                <span>\"       school.name as 'schoolName',\\n\"</span> <span>+</span>\n                <span>\"       hm.id       as 'hmId',\\n\"</span> <span>+</span>\n                <span>\"       hm.name     as 'schoolHeadName',\\n\"</span> <span>+</span>\n                <span>\"       s.name      as 'studentName',\\n\"</span> <span>+</span>\n                <span>\"       s.id        as 'studentId'\\n\"</span> <span>+</span>\n                <span>\"from school\\n\"</span> <span>+</span>\n                <span>\"         left join head_master hm on hm.id = school.head_master_id\\n\"</span> <span>+</span>\n                <span>\"         left join student s on school.id = s.school_id\"</span><span>)</span><span>;</span>\n        <span>// 2. 执行sql语句获取结果集</span>\n        preparedStatement<span>.</span><span>execute</span><span>(</span><span>)</span><span>;</span>\n        <span>ResultSetWrapper</span> firstResultSet <span>=</span> <span>getFirstResultSet</span><span>(</span>preparedStatement<span>,</span> configuration<span>)</span><span>;</span>\n        <span>ResultSet</span> resultSet <span>=</span> firstResultSet<span>.</span><span>getResultSet</span><span>(</span><span>)</span><span>;</span>\n        <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Object</span><span>></span></span> one2ManyAsMap <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        <span>// 3. 处理结果转换,一行一行读取数据</span>\n        <span>while</span> <span>(</span>resultSet<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n            <span>// 3.1 用于判断多行数据是否要合并 规则: 简单对象属性，如果一样则可以合并。</span>\n            <span>// 如: 下面数据返回值是 List&lt;School> schools；School（Long id,String name,SchoolHeadMaster schoolHeadMaster,List&lt;Student> students）</span>\n            <span>//INSERT INTO MY_TABLE(schoolId, schoolName, hmId, schoolHeadName, studentName, studentId) VALUES (1, '西天小学', 1, '如来', '孙悟空', 1);</span>\n            <span>//INSERT INTO MY_TABLE(schoolId, schoolName, hmId, schoolHeadName, studentName, studentId) VALUES (1, '西天小学', 1, '如来', '猪八戒', 2);</span>\n            <span>//INSERT INTO MY_TABLE(schoolId, schoolName, hmId, schoolHeadName, studentName, studentId) VALUES (1, '西天小学', 1, '如来', '唐三藏', 3);</span>\n            <span>//INSERT INTO MY_TABLE(schoolId, schoolName, hmId, schoolHeadName, studentName, studentId) VALUES (2, '湖畔大学', 2, '马云', '马化腾', 4);</span>\n            <span>//INSERT INTO MY_TABLE(schoolId, schoolName, hmId, schoolHeadName, studentName, studentId) VALUES (2, '湖畔大学', 2, '马云', '谢霆锋', 5);</span>\n            <span>//INSERT INTO MY_TABLE(schoolId, schoolName, hmId, schoolHeadName, studentName, studentId) VALUES (2, '湖畔大学', 2, '马云', '张学友', 6);</span>\n            <span>// 我们如何知道这6行数据如何合并。规则: 简单对象进行拼接，School中简单对象是id,和name。</span>\n            <span>// 所以这里构建的缓存key就是 id + name。相同就不新建返回值,而是对返回值二次赋值</span>\n            <span>String</span> cacheKey <span>=</span> <span>getCacheKey</span><span>(</span>resultMap<span>,</span> resultSet<span>,</span> configuration<span>)</span><span>;</span>\n            <span>Object</span> parentObject <span>=</span> one2ManyAsMap<span>.</span><span>get</span><span>(</span>cacheKey<span>)</span><span>;</span>\n            <span>// 3.2 开始填充数据</span>\n            parentObject <span>=</span> <span>getRowValue</span><span>(</span>resultMap<span>,</span> firstResultSet<span>,</span> configuration<span>,</span> parentObject<span>)</span><span>;</span>\n            one2ManyAsMap<span>.</span><span>put</span><span>(</span>cacheKey<span>,</span> parentObject<span>)</span><span>;</span>\n        <span>}</span>\n        <span>for</span> <span>(</span><span>Object</span> value <span>:</span> one2ManyAsMap<span>.</span><span>values</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>value<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>private</span> <span>PreparedStatement</span> <span>execute</span><span>(</span><span>String</span> sql<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>String</span> dbUrl <span>=</span> <span>\"jdbc:mysql://127.0.0.1:3306/test\"</span><span>;</span>\n        <span>String</span> user <span>=</span> <span>\"root\"</span><span>;</span>\n        <span>String</span> pass <span>=</span> <span>\"123456\"</span><span>;</span>\n        <span>// 1. 获取数据库连接</span>\n        <span>Connection</span> connection <span>=</span> <span>DriverManager</span><span>.</span><span>getConnection</span><span>(</span>dbUrl<span>,</span> user<span>,</span> pass<span>)</span><span>;</span>\n        <span>return</span> connection<span>.</span><span>prepareStatement</span><span>(</span>sql<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>private</span> <span>ResultSetWrapper</span> <span>getFirstResultSet</span><span>(</span><span>Statement</span> stmt<span>,</span> <span>Configuration</span> configuration<span>)</span> <span>throws</span> <span>SQLException</span> <span>{</span>\n        <span>ResultSet</span> rs <span>=</span> stmt<span>.</span><span>getResultSet</span><span>(</span><span>)</span><span>;</span>\n        <span>while</span> <span>(</span>rs <span>==</span> <span>null</span><span>)</span> <span>{</span>\n            <span>if</span> <span>(</span>stmt<span>.</span><span>getMoreResults</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n                rs <span>=</span> stmt<span>.</span><span>getResultSet</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span> <span>else</span> <span>{</span>\n                <span>if</span> <span>(</span>stmt<span>.</span><span>getUpdateCount</span><span>(</span><span>)</span> <span>==</span> <span>-</span><span>1</span><span>)</span> <span>{</span>\n                    <span>break</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> rs <span>!=</span> <span>null</span> <span>?</span> <span>new</span> <span>ResultSetWrapper</span><span>(</span>rs<span>,</span> configuration<span>)</span> <span>:</span> <span>null</span><span>;</span>\n    <span>}</span>\n\n    <span>private</span> <span>static</span> <span>String</span> <span>getCacheKey</span><span>(</span><span>ResultMap</span> resultMap<span>,</span> <span>ResultSet</span> resultSet<span>,</span> <span>Configuration</span> configuration<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>StringBuffer</span> sb <span>=</span> <span>new</span> <span>StringBuffer</span><span>(</span><span>)</span><span>;</span>\n        sb<span>.</span><span>append</span><span>(</span>resultMap<span>.</span><span>getId</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>List</span><span><span>&lt;</span><span>ResultMapping</span><span>></span></span> propertyResultMappings <span>=</span> resultMap<span>.</span><span>getPropertyResultMappings</span><span>(</span><span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>ResultMapping</span> propertyResultMapping <span>:</span> propertyResultMappings<span>)</span> <span>{</span>\n            <span>if</span> <span>(</span>propertyResultMapping<span>.</span><span>isSimple</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n                <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> javaType <span>=</span> propertyResultMapping<span>.</span><span>getJavaType</span><span>(</span><span>)</span><span>;</span>\n                <span>TypeHandler</span><span><span>&lt;</span><span>?</span><span>></span></span> typeHandler <span>=</span> configuration<span>.</span><span>getTypeHandlerRegistry</span><span>(</span><span>)</span><span>.</span><span>getTypeHandler</span><span>(</span>javaType<span>)</span><span>;</span>\n                sb<span>.</span><span>append</span><span>(</span>propertyResultMapping<span>.</span><span>getProperty</span><span>(</span><span>)</span><span>)</span><span>;</span>\n                <span>Object</span> propertyValue <span>=</span> typeHandler<span>.</span><span>getResult</span><span>(</span>resultSet<span>,</span> propertyResultMapping<span>.</span><span>getColumn</span><span>(</span><span>)</span><span>)</span><span>;</span>\n                sb<span>.</span><span>append</span><span>(</span>propertyValue<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> sb<span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>private</span> <span>static</span> <span>Object</span> <span>getRowValue</span><span>(</span><span>ResultMap</span> resultMap<span>,</span> <span>ResultSetWrapper</span> firstResultSet<span>,</span> <span>Configuration</span> configuration<span>,</span> <span>Object</span> rowValue<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>// 获取返回值的实体类</span>\n        <span>Object</span> returnValue <span>=</span> <span>null</span><span>;</span>\n        <span>// 如果不等于空说明是处理合并,那么不构建新对象,只在合并的对象上重新赋值。</span>\n        <span>if</span> <span>(</span><span>Objects</span><span>.</span><span>nonNull</span><span>(</span>rowValue<span>)</span><span>)</span> <span>{</span>\n            returnValue <span>=</span> rowValue<span>;</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            <span>// 等于空说明是第一次进入,直接构建返回值示例。</span>\n            returnValue <span>=</span> configuration<span>.</span><span>getObjectFactory</span><span>(</span><span>)</span><span>.</span><span>create</span><span>(</span>resultMap<span>.</span><span>getType</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>// 下面对实例方法进行赋值，利用工具类MetaObject包装提供统一的赋属性方法</span>\n        <span>MetaObject</span> metaObject <span>=</span> configuration<span>.</span><span>newMetaObject</span><span>(</span>returnValue<span>)</span><span>;</span>\n        <span>// 判断是否是嵌套对象</span>\n        <span>boolean</span> nestedFlag <span>=</span> resultMap<span>.</span><span>hasNestedResultMaps</span><span>(</span><span>)</span><span>;</span>\n        <span>ResultSet</span> resultSet <span>=</span> firstResultSet<span>.</span><span>getResultSet</span><span>(</span><span>)</span><span>;</span>\n        <span>// 判断是否简单对象</span>\n        <span>if</span> <span>(</span>nestedFlag<span>)</span> <span>{</span>\n            <span>// 非简单对象,说明需要判断属性各自需要的映射对象</span>\n            <span>List</span><span><span>&lt;</span><span>ResultMapping</span><span>></span></span> propertyResultMappings <span>=</span> resultMap<span>.</span><span>getPropertyResultMappings</span><span>(</span><span>)</span><span>;</span>\n            <span>for</span> <span>(</span><span>ResultMapping</span> propertyResultMapping <span>:</span> propertyResultMappings<span>)</span> <span>{</span>\n                <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> javaType <span>=</span> propertyResultMapping<span>.</span><span>getJavaType</span><span>(</span><span>)</span><span>;</span>\n                <span>String</span> nestedResultMapId <span>=</span> propertyResultMapping<span>.</span><span>getNestedResultMapId</span><span>(</span><span>)</span><span>;</span>\n                <span>Object</span> propertyValue<span>;</span>\n                <span>// 是空说明,当前属性是基本属性</span>\n                <span>if</span> <span>(</span><span>Objects</span><span>.</span><span>isNull</span><span>(</span>nestedResultMapId<span>)</span><span>)</span> <span>{</span>\n                    <span>// 获取当前属性的Java类型,从配置中获取该类型,读取ResultSet要使用的方法。eg:StringTypeHandler 使用ResultSet#getString</span>\n                    <span>TypeHandler</span><span><span>&lt;</span><span>?</span><span>></span></span> typeHandler <span>=</span> configuration<span>.</span><span>getTypeHandlerRegistry</span><span>(</span><span>)</span><span>.</span><span>getTypeHandler</span><span>(</span>javaType<span>)</span><span>;</span>\n                    propertyValue <span>=</span> typeHandler<span>.</span><span>getResult</span><span>(</span>resultSet<span>,</span> propertyResultMapping<span>.</span><span>getColumn</span><span>(</span><span>)</span><span>)</span><span>;</span>\n                <span>}</span> <span>else</span> <span>{</span>\n                    <span>// 不等于空说明是嵌套对象,从配置中读取嵌套对象的映射信息</span>\n                    <span>ResultMap</span> nestedResultMap <span>=</span> configuration<span>.</span><span>getResultMap</span><span>(</span>nestedResultMapId<span>)</span><span>;</span>\n                    <span>// 嵌套对象的java类型。eg: School(students),这里的Java类型就是Student</span>\n                    <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> nestedJavaType <span>=</span> nestedResultMap<span>.</span><span>getType</span><span>(</span><span>)</span><span>;</span>\n                    <span>// 若果是list方式,外面的javaType=list，里面是真实java对象</span>\n                    <span>if</span> <span>(</span><span>!</span>javaType<span>.</span><span>equals</span><span>(</span>nestedJavaType<span>)</span> <span>&amp;&amp;</span> <span>Collection</span><span>.</span><span>class</span><span>.</span><span>isAssignableFrom</span><span>(</span>javaType<span>)</span><span>)</span> <span>{</span>\n                        propertyValue <span>=</span> <span>getRowValue</span><span>(</span>nestedResultMap<span>,</span> firstResultSet<span>,</span> configuration<span>,</span> <span>null</span><span>)</span><span>;</span>\n                        <span>MetaObject</span> parentMetaObject <span>=</span> configuration<span>.</span><span>newMetaObject</span><span>(</span>returnValue<span>)</span><span>;</span>\n                        <span>// 获取父对象School 获取students的List</span>\n                        <span>Object</span> collect <span>=</span> parentMetaObject<span>.</span><span>getValue</span><span>(</span>propertyResultMapping<span>.</span><span>getProperty</span><span>(</span><span>)</span><span>)</span><span>;</span>\n                        <span>if</span> <span>(</span><span>Objects</span><span>.</span><span>isNull</span><span>(</span>collect<span>)</span><span>)</span> <span>{</span>\n                            <span>// 如果是null，则将list实例化</span>\n                            collect <span>=</span> configuration<span>.</span><span>getObjectFactory</span><span>(</span><span>)</span><span>.</span><span>create</span><span>(</span>javaType<span>)</span><span>;</span>\n                            parentMetaObject<span>.</span><span>setValue</span><span>(</span>propertyResultMapping<span>.</span><span>getProperty</span><span>(</span><span>)</span><span>,</span> collect<span>)</span><span>;</span>\n                        <span>}</span>\n                        <span>// 给list中添加信息</span>\n                        <span>MetaObject</span> metaCollectObject <span>=</span> configuration<span>.</span><span>newMetaObject</span><span>(</span>collect<span>)</span><span>;</span>\n                        metaCollectObject<span>.</span><span>add</span><span>(</span>propertyValue<span>)</span><span>;</span>\n                        propertyValue <span>=</span> collect<span>;</span>\n                    <span>}</span> <span>else</span> <span>{</span>\n                        <span>// 简单对象</span>\n                        propertyValue <span>=</span> <span>getRowValue</span><span>(</span>nestedResultMap<span>,</span> firstResultSet<span>,</span> configuration<span>,</span> <span>null</span><span>)</span><span>;</span>\n                    <span>}</span>\n                <span>}</span>\n                metaObject<span>.</span><span>setValue</span><span>(</span>propertyResultMapping<span>.</span><span>getProperty</span><span>(</span><span>)</span><span>,</span> propertyValue<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            <span>List</span><span><span>&lt;</span><span>ResultMapping</span><span>></span></span> propertyResultMappings <span>=</span> resultMap<span>.</span><span>getPropertyResultMappings</span><span>(</span><span>)</span><span>;</span>\n            <span>for</span> <span>(</span><span>ResultMapping</span> propertyResultMapping <span>:</span> propertyResultMappings<span>)</span> <span>{</span>\n                <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> javaType <span>=</span> propertyResultMapping<span>.</span><span>getJavaType</span><span>(</span><span>)</span><span>;</span>\n                <span>TypeHandler</span><span><span>&lt;</span><span>?</span><span>></span></span> typeHandler <span>=</span> configuration<span>.</span><span>getTypeHandlerRegistry</span><span>(</span><span>)</span><span>.</span><span>getTypeHandler</span><span>(</span>javaType<span>)</span><span>;</span>\n                <span>Object</span> propertyValue <span>=</span> typeHandler<span>.</span><span>getResult</span><span>(</span>resultSet<span>,</span> propertyResultMapping<span>.</span><span>getColumn</span><span>(</span><span>)</span><span>)</span><span>;</span>\n                metaObject<span>.</span><span>setValue</span><span>(</span>propertyResultMapping<span>.</span><span>getProperty</span><span>(</span><span>)</span><span>,</span> propertyValue<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> returnValue<span>;</span>\n    <span>}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br><span>135</span><br><span>136</span><br><span>137</span><br><span>138</span><br><span>139</span><br><span>140</span><br><span>141</span><br><span>142</span><br><span>143</span><br><span>144</span><br><span>145</span><br><span>146</span><br><span>147</span><br><span>148</span><br><span>149</span><br><span>150</span><br><span>151</span><br><span>152</span><br><span>153</span><br><span>154</span><br><span>155</span><br><span>156</span><br></div></div><p>好了到这里对于场景1中，返回list中的数据就处理好了。</p>\n<div><pre><code>  <span>private</span> <span><span>&lt;</span><span>E</span><span>></span></span> <span>Object</span> <span>executeForMany</span><span>(</span><span>SqlSession</span> sqlSession<span>,</span> <span>Object</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n    <span>List</span><span><span>&lt;</span><span>E</span><span>></span></span> result<span>;</span>\n    <span>Object</span> param <span>=</span> method<span>.</span><span>convertArgsToSqlCommandParam</span><span>(</span>args<span>)</span><span>;</span>\n    <span>if</span> <span>(</span>method<span>.</span><span>hasRowBounds</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n      <span>RowBounds</span> rowBounds <span>=</span> method<span>.</span><span>extractRowBounds</span><span>(</span>args<span>)</span><span>;</span>\n      result <span>=</span> sqlSession<span>.</span><span>selectList</span><span>(</span>command<span>.</span><span>getName</span><span>(</span><span>)</span><span>,</span> param<span>,</span> rowBounds<span>)</span><span>;</span>\n    <span>}</span> <span>else</span> <span>{</span>\n      result <span>=</span> sqlSession<span>.</span><span>selectList</span><span>(</span>command<span>.</span><span>getName</span><span>(</span><span>)</span><span>,</span> param<span>)</span><span>;</span>\n    <span>}</span>\n    <span>// issue #510 Collections &amp; arrays support</span>\n    <span>if</span> <span>(</span><span>!</span>method<span>.</span><span>getReturnType</span><span>(</span><span>)</span><span>.</span><span>isAssignableFrom</span><span>(</span>result<span>.</span><span>getClass</span><span>(</span><span>)</span><span>)</span><span>)</span> <span>{</span>\n      <span>if</span> <span>(</span>method<span>.</span><span>getReturnType</span><span>(</span><span>)</span><span>.</span><span>isArray</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n        <span>return</span> <span>convertToArray</span><span>(</span>result<span>)</span><span>;</span>\n      <span>}</span> <span>else</span> <span>{</span>\n        <span>return</span> <span>convertToDeclaredCollection</span><span>(</span>sqlSession<span>.</span><span>getConfiguration</span><span>(</span><span>)</span><span>,</span> result<span>)</span><span>;</span>\n      <span>}</span>\n    <span>}</span>\n    <span>return</span> result<span>;</span>\n  <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h3 id=\"场景二\"> 场景二:</h3>\n<p>如果是单个对象,在基于场景一的返回值上加一个判断,如果结果只要1个就只取第一个。\n如果是多个，则报错。</p>\n<div><pre><code>  <span>public</span> <span><span>&lt;</span><span>T</span><span>></span></span> <span>T</span> <span>selectOne</span><span>(</span><span>String</span> statement<span>,</span> <span>Object</span> parameter<span>)</span> <span>{</span>\n    <span>// Popular vote was to return null on 0 results and throw exception on too many.</span>\n    <span>List</span><span><span>&lt;</span><span>T</span><span>></span></span> list <span>=</span> <span>this</span><span>.</span><span>selectList</span><span>(</span>statement<span>,</span> parameter<span>)</span><span>;</span>\n    <span>if</span> <span>(</span>list<span>.</span><span>size</span><span>(</span><span>)</span> <span>==</span> <span>1</span><span>)</span> <span>{</span>\n      <span>return</span> list<span>.</span><span>get</span><span>(</span><span>0</span><span>)</span><span>;</span>\n    <span>}</span> <span>else</span> <span>if</span> <span>(</span>list<span>.</span><span>size</span><span>(</span><span>)</span> <span>></span> <span>1</span><span>)</span> <span>{</span>\n      <span>throw</span> <span>new</span> <span>TooManyResultsException</span><span>(</span><span>\"Expected one result (or null) to be returned by selectOne(), but found: \"</span> <span>+</span> list<span>.</span><span>size</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span> <span>else</span> <span>{</span>\n      <span>return</span> <span>null</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id=\"场景三\"> 场景三:</h3>\n<p>更新语句直接 Statement#getUpdateCount 获取更新数量</p>\n<div><pre><code>  <span>public</span> <span>int</span> <span>update</span><span>(</span><span>Statement</span> statement<span>)</span> <span>throws</span> <span>SQLException</span> <span>{</span>\n    <span>PreparedStatement</span> ps <span>=</span> <span>(</span><span>PreparedStatement</span><span>)</span> statement<span>;</span>\n    ps<span>.</span><span>execute</span><span>(</span><span>)</span><span>;</span>\n    <span>int</span> rows <span>=</span> ps<span>.</span><span>getUpdateCount</span><span>(</span><span>)</span><span>;</span>\n    <span>Object</span> parameterObject <span>=</span> boundSql<span>.</span><span>getParameterObject</span><span>(</span><span>)</span><span>;</span>\n    <span>KeyGenerator</span> keyGenerator <span>=</span> mappedStatement<span>.</span><span>getKeyGenerator</span><span>(</span><span>)</span><span>;</span>\n    keyGenerator<span>.</span><span>processAfter</span><span>(</span>executor<span>,</span> mappedStatement<span>,</span> ps<span>,</span> parameterObject<span>)</span><span>;</span>\n    <span>return</span> rows<span>;</span>\n  <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"场景四\"> 场景四:</h3>\n<p>排除查询,其他语句返回都是int类型的更新成数量。那么假如方法是boolean类型，或者Long和Void呢</p>\n<div><pre><code><span>public</span> <span>class</span> <span>MapperMethod</span> <span>{</span>\n  <span>private</span> <span>Object</span> <span>rowCountResult</span><span>(</span><span>int</span> rowCount<span>)</span> <span>{</span>\n    <span>final</span> <span>Object</span> result<span>;</span>\n    <span>if</span> <span>(</span>method<span>.</span><span>returnsVoid</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n      result <span>=</span> <span>null</span><span>;</span>\n    <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>Integer</span><span>.</span><span>class</span><span>.</span><span>equals</span><span>(</span>method<span>.</span><span>getReturnType</span><span>(</span><span>)</span><span>)</span> <span>||</span> <span>Integer</span><span>.</span>TYPE<span>.</span><span>equals</span><span>(</span>method<span>.</span><span>getReturnType</span><span>(</span><span>)</span><span>)</span><span>)</span> <span>{</span>\n      result <span>=</span> rowCount<span>;</span>\n    <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>Long</span><span>.</span><span>class</span><span>.</span><span>equals</span><span>(</span>method<span>.</span><span>getReturnType</span><span>(</span><span>)</span><span>)</span> <span>||</span> <span>Long</span><span>.</span>TYPE<span>.</span><span>equals</span><span>(</span>method<span>.</span><span>getReturnType</span><span>(</span><span>)</span><span>)</span><span>)</span> <span>{</span>\n      result <span>=</span> <span>(</span><span>long</span><span>)</span> rowCount<span>;</span>\n    <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>Boolean</span><span>.</span><span>class</span><span>.</span><span>equals</span><span>(</span>method<span>.</span><span>getReturnType</span><span>(</span><span>)</span><span>)</span> <span>||</span> <span>Boolean</span><span>.</span>TYPE<span>.</span><span>equals</span><span>(</span>method<span>.</span><span>getReturnType</span><span>(</span><span>)</span><span>)</span><span>)</span> <span>{</span>\n      result <span>=</span> rowCount <span>></span> <span>0</span><span>;</span>\n    <span>}</span> <span>else</span> <span>{</span>\n      <span>throw</span> <span>new</span> <span>BindingException</span><span>(</span><span>\"Mapper method '\"</span> <span>+</span> command<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\"' has an unsupported return type: \"</span> <span>+</span> method<span>.</span><span>getReturnType</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>return</span> result<span>;</span>\n  <span>}</span>\n<span>}</span>  \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div>",
      "image": "https://img.springlearn.cn/blog/learn_1649427915000.png",
      "date_published": "2022-03-30T15:42:58.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Mybatis"
      ]
    },
    {
      "title": "Mybatis",
      "url": "https://java.springlearn.cn/learn/mybatis/",
      "id": "https://java.springlearn.cn/learn/mybatis/",
      "content_html": "<p><img src=\"https://mybatis.org/images/mybatis-logo.png\" alt=\"\" loading=\"lazy\"></p>\n<h1 id=\"什么是-mybatis-官方文档\"> 什么是 MyBatis？<a href=\"https://mybatis.net.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">官方文档</a></h1>\n<p>MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p>\n<h1 id=\"重构mybatis博客\"> 重构Mybatis博客</h1>\n<p>最早使用Mybatis是在2016年,那时候学习只会用,根本不知道什么原理,不懂的原理的地方只能死记。搭建一个小的demo放到github,工作需要的时候就直接复制黏贴,虽然也能满足工作需要但是总感觉到不带劲。在找到工作后大概2017年时候就对Mybatis的源码进行了阅读，其实相对于Dubbo,Spring,之类的源码Mybatis的源码还是非常简单的,现在也经常推荐给刚开始学习看源码的同学。\n早在2019年小编就开始写Mybatis的博客了,那时候博客主要还是自己学习为主,现在回头看看,感觉有些粗糙。这里准备回炉重造一波。将原博客进行优化。对Mybaits的核心功能，核心处理类重新重构下博客。</p>\n<p><a href=\"https://github.com/lxchinesszz/mybatis-opensource-example\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://img.shields.io/badge/源码阅读-mybatis--opensource--example-green\" alt=\"\" loading=\"lazy\"></a></p>\n",
      "image": "https://mybatis.org/images/mybatis-logo.png",
      "date_published": "2022-03-28T15:13:45.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "第15篇:Mybatis中打印Sql信息",
      "url": "https://java.springlearn.cn/learn/mybatis/Mybatissql%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0/",
      "id": "https://java.springlearn.cn/learn/mybatis/Mybatissql%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0/",
      "content_html": "<div><p>Sql打印需求</p>\n<p>在Mybatis中如果我们要对我们的sql信息进行检查, 只能启动Spring容器, 去执行根据成功和失败来判断我们的逻辑是否有问题。\n此时会比较耗时,因为要启动容器。基于这个痛点, 本文要设计一个工具。使我们不依赖Spring容器,也不依赖任何外部插件，直接就把\nSql信息的打印出来。</p>\n</div>\n<p>仓库地址: https://github.com/lxchinesszz/mybatis-sql-helper</p>\n<p>使用方法</p>\n<div><pre><code><span>OrderBatchEntityQuery</span> query <span>=</span> <span>JMockData</span><span>.</span><span>mock</span><span>(</span><span>OrderBatchEntityQuery</span><span>.</span><span>class</span><span>)</span><span>;</span>\n<span>// 如果需要绑定xml就使用bindMapper</span>\n<span>QuickMapperChecker</span><span>.</span><span>analyse</span><span>(</span><span>QuickMapperChecker</span><span>.</span><span>mock</span><span>(</span><span>IOrderMapper</span><span>.</span><span>class</span><span>)</span><span>.</span><span>list</span><span>(</span>query<span>)</span><span>)</span>\n   <span>.</span><span>bindMapper</span><span>(</span><span>\"mapper/center/ReplenishOrderMapper.xml\"</span><span>)</span><span>.</span><span>printSql</span><span>(</span><span>)</span><span>;</span>   \n<span>// 如果完全依赖注解跟简单</span>\n<span>QuickMapperChecker</span><span>.</span><span>analyse</span><span>(</span><span>QuickMapperChecker</span><span>.</span><span>mock</span><span>(</span><span>IOrderMapper</span><span>.</span><span>class</span><span>)</span><span>.</span><span>list</span><span>(</span>query<span>)</span><span>)</span>\n   <span>.</span><span>printSql</span><span>(</span><span>)</span><span>;</span>   \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id=\"一、设计思路\"> 一、设计思路</h2>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1651310469000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>基于前面我们对Mybatis的学习,我们知道所有的sql信息,都会被解析成MappedStatement,并保存在 Configuration。\n那么我们要做的</p>\n<p>第一步就是解析sql信息成MappedStatement。而在Mybatis中的sql是可以写在Mapper.xml也可以使用注解形式,\n直接写到接口类中的。</p>\n<p>第二个知识点,Mybatis中是可以使用很多标签的如 <where/> <if/> <foreach/> <include/> 这些标签要先处理成sql信息。</p>\n<p>第三步组装sql信息, 前面的学习我们知道sql信息如果是$变量符,那么会在直接会编译成sql信息。而动态sql是由DynamicSqlSource来直接解析参数\n生成sql的。那么我们就需要将#占位符都调换成变量符,然后利用DynamicSqlSource给直接生成sql信息的。</p>\n<p>第四步sql信息格式化。</p>\n<p>第五步使用方法设计。</p>\n<h2 id=\"二、思路实现\"> 二、思路实现</h2>\n<h2 id=\"_2-1-mappedstatement解析\"> 2.1 MappedStatement解析</h2>\n<h3 id=\"_2-1-1-xml参数解析\"> 2.1.1 xml参数解析</h3>\n<div><pre><code><span>private</span> <span>void</span> <span>loadMappedStatementByMapperFile</span><span>(</span><span>String</span> mapperXmlFile<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n    <span>InputStream</span> resourceAsStream <span>=</span> <span>Resources</span><span>.</span><span>getResourceAsStream</span><span>(</span>mapperXmlFile<span>)</span><span>;</span>\n    <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>XNode</span><span>></span></span> sqlFragments <span>=</span> configuration<span>.</span><span>getSqlFragments</span><span>(</span><span>)</span><span>;</span>\n    <span>new</span> <span>XMLMapperBuilder</span><span>(</span>resourceAsStream<span>,</span> configuration<span>,</span> mapperXmlFile<span>,</span> sqlFragments<span>)</span><span>.</span><span>parse</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"_2-1-2-注解sql解析\"> 2.1.2 注解sql解析</h3>\n<div><pre><code><span>private</span> <span>void</span> <span>loadMappedStatementByAnnotation</span><span>(</span><span>)</span> <span>{</span>\n    <span>MapperAnnotationBuilder</span> mapperAnnotationBuilder <span>=</span>\n        <span>new</span> <span>MapperAnnotationBuilder</span><span>(</span>configuration<span>,</span> quickMapperChecker<span>.</span>mapper<span>)</span><span>;</span>\n    mapperAnnotationBuilder<span>.</span><span>parse</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>当执行完上面的代码,所有MappedStatement就生成了并保存到你指定的Configuration中了。</p>\n<h2 id=\"_2-2-sql中标签解析\"> 2.2 Sql中标签解析</h2>\n<h3 id=\"_2-2-1-include-标签解析\"> 2.2.1 Include 标签解析</h3>\n<p>拿到所有的sql执行标签&quot;select|insert|update|delete&quot;,去执行include参数替换。\nincludeParser.applyIncludes(child.getNode());执行后 include 标签就替换成真正的sql片段了。</p>\n<div><pre><code> <span>private</span> <span>XNode</span> <span>findNode</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>InputStream</span> resourceAsStream <span>=</span> <span>Resources</span><span>.</span><span>getResourceAsStream</span><span>(</span><span>this</span><span>.</span>mapperFile<span>)</span><span>;</span>\n        <span>XPathParser</span> xPathParser <span>=</span> <span>new</span> <span>XPathParser</span><span>(</span>resourceAsStream<span>)</span><span>;</span>\n        <span>XNode</span> mapperNode <span>=</span> xPathParser<span>.</span><span>evalNode</span><span>(</span><span>\"/mapper\"</span><span>)</span><span>;</span>\n        <span>List</span><span><span>&lt;</span><span>XNode</span><span>></span></span> children <span>=</span> mapperNode<span>.</span><span>getChildren</span><span>(</span><span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>XNode</span> child <span>:</span> children<span>)</span> <span>{</span>\n            <span>if</span> <span>(</span>child<span>.</span><span>getStringAttribute</span><span>(</span><span>\"id\"</span><span>)</span><span>.</span><span>equals</span><span>(</span>quickMapperChecker<span>.</span>methodName<span>)</span><span>)</span> <span>{</span>\n                <span>MapperBuilderAssistant</span> mapperBuilderAssistant <span>=</span>\n                    <span>new</span> <span>MapperBuilderAssistant</span><span>(</span>configuration<span>,</span> quickMapperChecker<span>.</span>mapperFile<span>)</span><span>;</span>\n                mapperBuilderAssistant<span>.</span><span>setCurrentNamespace</span><span>(</span>mapper<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n                <span>XMLIncludeTransformer</span> includeParser <span>=</span> <span>new</span> <span>XMLIncludeTransformer</span><span>(</span>configuration<span>,</span> mapperBuilderAssistant<span>)</span><span>;</span>\n                includeParser<span>.</span><span>applyIncludes</span><span>(</span>child<span>.</span><span>getNode</span><span>(</span><span>)</span><span>)</span><span>;</span>\n                <span>return</span> child<span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>// \"select|insert|update|delete\"</span>\n        <span>return</span> <span>null</span><span>;</span>\n    <span>}</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h3 id=\"_2-2-1-其他标签解析\"> 2.2.1 其他标签解析</h3>\n<div><pre><code> <span>private</span> <span>void</span> <span>initNodeHandlerMap</span><span>(</span><span>)</span> <span>{</span>\n    nodeHandlerMap<span>.</span><span>put</span><span>(</span><span>\"trim\"</span><span>,</span> <span>new</span> <span>TrimHandler</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    nodeHandlerMap<span>.</span><span>put</span><span>(</span><span>\"where\"</span><span>,</span> <span>new</span> <span>WhereHandler</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    nodeHandlerMap<span>.</span><span>put</span><span>(</span><span>\"set\"</span><span>,</span> <span>new</span> <span>SetHandler</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    nodeHandlerMap<span>.</span><span>put</span><span>(</span><span>\"foreach\"</span><span>,</span> <span>new</span> <span>ForEachHandler</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    nodeHandlerMap<span>.</span><span>put</span><span>(</span><span>\"if\"</span><span>,</span> <span>new</span> <span>IfHandler</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    nodeHandlerMap<span>.</span><span>put</span><span>(</span><span>\"choose\"</span><span>,</span> <span>new</span> <span>ChooseHandler</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    nodeHandlerMap<span>.</span><span>put</span><span>(</span><span>\"when\"</span><span>,</span> <span>new</span> <span>IfHandler</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    nodeHandlerMap<span>.</span><span>put</span><span>(</span><span>\"otherwise\"</span><span>,</span> <span>new</span> <span>OtherwiseHandler</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    nodeHandlerMap<span>.</span><span>put</span><span>(</span><span>\"bind\"</span><span>,</span> <span>new</span> <span>BindHandler</span><span>(</span><span>)</span><span>)</span><span>;</span>\n  <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>这里我们要使用XMLScriptBuilder#parseDynamicTags。很可惜这个方法是受到保护的。\n我们只能使用反射来对参数进行解析。</p>\n<div><pre><code> <span>// 解析xml中的标签信息</span>\n <span>Method</span> parseDynamicTags <span>=</span> <span>XMLScriptBuilder</span><span>.</span><span>class</span><span>.</span><span>getDeclaredMethod</span><span>(</span><span>\"parseDynamicTags\"</span><span>,</span> <span>XNode</span><span>.</span><span>class</span><span>)</span><span>;</span>\n parseDynamicTags<span>.</span><span>setAccessible</span><span>(</span><span>true</span><span>)</span><span>;</span>\n\n <span>XMLScriptBuilder</span> xmlScriptBuilder <span>=</span> <span>new</span> <span>XMLScriptBuilder</span><span>(</span>configuration<span>,</span> node<span>)</span><span>;</span>\n <span>MixedSqlNode</span> rootSqlNode <span>=</span> <span>(</span><span>MixedSqlNode</span><span>)</span>parseDynamicTags<span>.</span><span>invoke</span><span>(</span>xmlScriptBuilder<span>,</span> node<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id=\"_2-2-2-bind参数生成\"> 2.2.2 bind参数生成</h3>\n<p>这里要说明下,我们举一个列子。以下面例子,我们拿到的参数是query。</p>\n<div><pre><code><span>List</span><span><span>&lt;</span><span>OrderDO</span><span>></span></span> <span>list</span><span>(</span><span>@Param</span><span>(</span><span>\"query\"</span><span>)</span> <span>OrderBatchEntityQuery</span> query<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>而他的xml比较复杂的。</p>\n<div><pre><code><span><span><span>&lt;</span>select</span> <span>id</span><span><span>=</span><span>\"</span>list<span>\"</span></span> <span>resultType</span><span><span>=</span><span>\"</span>com.center.dal.entity.OrderDO<span>\"</span></span><span>></span></span>\n        select *\n        from order as ro\n                 left join order_detail rod on ro.id = rod.replenish_order_id\n        <span><span><span>&lt;</span>where</span><span>></span></span>\n            <span><span><span>&lt;</span>if</span> <span>test</span><span><span>=</span><span>\"</span>@com.center.dal.util.MybatisIfUtils@isNotEmpty(query.ids)<span>\"</span></span><span>></span></span>\n                and ro.id in\n                <span><span><span>&lt;</span>foreach</span> <span>collection</span><span><span>=</span><span>\"</span>query.ids<span>\"</span></span> <span>open</span><span><span>=</span><span>\"</span>(<span>\"</span></span> <span>separator</span><span><span>=</span><span>\"</span>,<span>\"</span></span> <span>index</span><span><span>=</span><span>\"</span>index<span>\"</span></span> <span>item</span><span><span>=</span><span>\"</span>id<span>\"</span></span>\n                         <span>close</span><span><span>=</span><span>\"</span>)<span>\"</span></span><span>></span></span>\n                    #{id}\n                <span><span><span>&lt;/</span>foreach</span><span>></span></span>\n            <span><span><span>&lt;/</span>if</span><span>></span></span>\n            <span><span><span>&lt;</span>if</span> <span>test</span><span><span>=</span><span>\"</span>@com.center.dal.util.MybatisIfUtils@isNotEmpty(query.orderCode)<span>\"</span></span><span>></span></span>\n                and ro.order_code = #{query.orderCode}\n            <span><span><span>&lt;/</span>if</span><span>></span></span>\n            <span><span><span>&lt;</span>if</span> <span>test</span><span><span>=</span><span>\"</span>@com.center.dal.util.MybatisIfUtils@isNotEmpty(query.statusList)<span>\"</span></span><span>></span></span>\n                and ro.status in\n                <span><span><span>&lt;</span>foreach</span> <span>collection</span><span><span>=</span><span>\"</span>query.statusList<span>\"</span></span> <span>open</span><span><span>=</span><span>\"</span>(<span>\"</span></span> <span>separator</span><span><span>=</span><span>\"</span>,<span>\"</span></span> <span>index</span><span><span>=</span><span>\"</span>index<span>\"</span></span> <span>item</span><span><span>=</span><span>\"</span>status<span>\"</span></span>\n                         <span>close</span><span><span>=</span><span>\"</span>)<span>\"</span></span><span>></span></span>\n                    #{status}\n                <span><span><span>&lt;/</span>foreach</span><span>></span></span>\n            <span><span><span>&lt;/</span>if</span><span>></span></span>\n            <span><span><span>&lt;</span>if</span> <span>test</span><span><span>=</span><span>\"</span>@com.center.dal.util.MybatisIfUtils@isNotEmpty(query.title)<span>\"</span></span><span>></span></span>\n                and ro.title = #{query.title}\n            <span><span><span>&lt;/</span>if</span><span>></span></span>\n            <span><span><span>&lt;</span>if</span> <span>test</span><span><span>=</span><span>\"</span>@com.center.dal.util.MybatisIfUtils@isNotEmpty(query.salesWarehouseId)<span>\"</span></span><span>></span></span>\n                and ro.sales_warehouse_id = #{query.salesWarehouseId}\n            <span><span><span>&lt;/</span>if</span><span>></span></span>\n            <span><span><span>&lt;</span>if</span> <span>test</span><span><span>=</span><span>\"</span>@com.center.dal.util.MybatisIfUtils@isNotEmpty(query.brandCode)<span>\"</span></span><span>></span></span>\n                and ro.brand_code = #{query.brandCode}\n            <span><span><span>&lt;/</span>if</span><span>></span></span>\n            <span><span><span>&lt;</span>if</span> <span>test</span><span><span>=</span><span>\"</span>@com.center.dal.util.MybatisIfUtils@isNotEmpty(query.businessLineId)<span>\"</span></span><span>></span></span>\n                and ro.business_line_id = #{query.businessLineId}\n            <span><span><span>&lt;/</span>if</span><span>></span></span>\n            <span><span><span>&lt;</span>if</span> <span>test</span><span><span>=</span><span>\"</span>@com.center.dal.util.MybatisIfUtils@isNotEmpty(query.signOwnerCode)<span>\"</span></span><span>></span></span>\n                and ro.sign_owner_code = #{query.signOwnerCode}\n            <span><span><span>&lt;/</span>if</span><span>></span></span>\n            <span><span><span>&lt;</span>if</span> <span>test</span><span><span>=</span><span>\"</span>@com.center.dal.util.MybatisIfUtils@isNotEmpty(query.storageOwnerCode)<span>\"</span></span><span>></span></span>\n                and ro.storage_owner_code = #{query.storageOwnerCode}\n            <span><span><span>&lt;/</span>if</span><span>></span></span>\n            <span><span><span>&lt;</span>if</span> <span>test</span><span><span>=</span><span>\"</span>@com.center.dal.util.MybatisIfUtils@isNotEmpty(query.goodsBarcodes)<span>\"</span></span><span>></span></span>\n                and rod.goods_barcode in\n                <span><span><span>&lt;</span>foreach</span> <span>collection</span><span><span>=</span><span>\"</span>query.goodsBarcodes<span>\"</span></span> <span>open</span><span><span>=</span><span>\"</span>(<span>\"</span></span> <span>separator</span><span><span>=</span><span>\"</span>,<span>\"</span></span> <span>index</span><span><span>=</span><span>\"</span>index<span>\"</span></span> <span>item</span><span><span>=</span><span>\"</span>goods_barcode<span>\"</span></span>\n                         <span>close</span><span><span>=</span><span>\"</span>)<span>\"</span></span><span>></span></span>\n                    #{goods_barcode}\n                <span><span><span>&lt;/</span>foreach</span><span>></span></span>\n            <span><span><span>&lt;/</span>if</span><span>></span></span>\n        <span><span><span>&lt;/</span>where</span><span>></span></span>\n    <span><span><span>&lt;/</span>select</span><span>></span></span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br></div></div><p>以上参数分为2部分,一部分是原始方法参数的解析。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1651311823000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>而BoundsSql中ParameterMapping是这样的。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1651311916000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>需要拿到参数中每个的数据信息。</p>\n<div><pre><code> <span>// 解析xml中的标签信息</span>\n <span>Method</span> parseDynamicTags <span>=</span> <span>XMLScriptBuilder</span><span>.</span><span>class</span><span>.</span><span>getDeclaredMethod</span><span>(</span><span>\"parseDynamicTags\"</span><span>,</span> <span>XNode</span><span>.</span><span>class</span><span>)</span><span>;</span>\n parseDynamicTags<span>.</span><span>setAccessible</span><span>(</span><span>true</span><span>)</span><span>;</span>\n\n <span>XMLScriptBuilder</span> xmlScriptBuilder <span>=</span> <span>new</span> <span>XMLScriptBuilder</span><span>(</span>configuration<span>,</span> node<span>)</span><span>;</span>\n <span>MixedSqlNode</span> rootSqlNode <span>=</span> <span>(</span><span>MixedSqlNode</span><span>)</span>parseDynamicTags<span>.</span><span>invoke</span><span>(</span>xmlScriptBuilder<span>,</span> node<span>)</span><span>;</span>\n <span>DynamicContext</span> context <span>=</span> <span>new</span> <span>DynamicContext</span><span>(</span>configuration<span>,</span> namedParams<span>)</span><span>;</span>\n rootSqlNode<span>.</span><span>apply</span><span>(</span>context<span>)</span><span>;</span>\n <span>// 标签信息参数解析</span>\n <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Object</span><span>></span></span> bindings <span>=</span> context<span>.</span><span>getBindings</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p><img src=\"https://img.springlearn.cn/blog/learn_1651312104000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>到这里复杂标签中的参数就获取到了。</p>\n<h2 id=\"_2-3-占位符替换成变量符\"> 2.3 占位符替换成变量符</h2>\n<h3 id=\"_2-3-1-占位符替换变量符\"> 2.3.1 占位符替换变量符</h3>\n<p>因为#占位符都会先调换成?。而参数都会按照顺序放在ParameterMapping中。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1651312283000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>这里我们要写代码将?替换成${ParameterMapping#getProperty}。</p>\n<div><pre><code>    <span>/**\n     * 处理占位符已经被替换成?的时候，用于将占位符重新替换成变量符\n     *\n     * @param sql\n     *            占位符sql\n     * @param index\n     *            占位符当前处理的索引\n     * @param parameterMappings\n     *            占位符参数信息\n     * @return String 变量符sql\n     */</span>\n    <span>private</span> <span>String</span> <span>resetSql</span><span>(</span><span>String</span> sql<span>,</span> <span>int</span> index<span>,</span> <span>List</span><span><span>&lt;</span><span>ParameterMapping</span><span>></span></span> parameterMappings<span>,</span> <span>MetaObject</span> metaObject<span>)</span> <span>{</span>\n        <span>int</span> i <span>=</span> sql<span>.</span><span>indexOf</span><span>(</span><span>\"?\"</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span>i <span>></span> <span>-</span><span>1</span><span>)</span> <span>{</span>\n            <span>ParameterMapping</span> parameterMapping <span>=</span> parameterMappings<span>.</span><span>get</span><span>(</span>index<span>)</span><span>;</span>\n            <span>String</span> property <span>=</span> parameterMapping<span>.</span><span>getProperty</span><span>(</span><span>)</span><span>;</span>\n            <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> javaType <span>=</span> parameterMapping<span>.</span><span>getJavaType</span><span>(</span><span>)</span><span>;</span>\n            <span>Object</span> value <span>=</span> metaObject<span>.</span><span>getValue</span><span>(</span>parameterMapping<span>.</span><span>getProperty</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>String</span> s<span>;</span>\n            <span>if</span> <span>(</span>javaType<span>.</span><span>equals</span><span>(</span><span>String</span><span>.</span><span>class</span><span>)</span> <span>||</span> value <span>instanceof</span> <span>String</span><span>)</span> <span>{</span>\n                s <span>=</span> sql<span>.</span><span>replaceFirst</span><span>(</span><span>\"\\\\?\"</span><span>,</span> <span>\"\\\"\\\\${\"</span> <span>+</span> property <span>+</span> <span>\"}\\\"\"</span><span>)</span><span>;</span>\n            <span>}</span> <span>else</span> <span>{</span>\n                s <span>=</span> sql<span>.</span><span>replaceFirst</span><span>(</span><span>\"\\\\?\"</span><span>,</span> <span>\"\\\\${\"</span> <span>+</span> property <span>+</span> <span>\"}\"</span><span>)</span><span>;</span>\n            <span>}</span>\n            sql <span>=</span> <span>resetSql</span><span>(</span>s<span>,</span> <span>++</span>index<span>,</span> parameterMappings<span>,</span> metaObject<span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> sql<span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><h3 id=\"_2-3-2-生成sql\"> 2.3.2 生成Sql</h3>\n<p>利用变量符能直接生成sql的能力，我们直接将参数准备好，使用就好了。</p>\n<div><pre><code> <span>// 获取原始参数信息</span>\n <span>Object</span> namedParams <span>=</span> paramNameResolver<span>.</span><span>getNamedParams</span><span>(</span>quickMapperChecker<span>.</span>args<span>)</span><span>;</span>\n <span>// 复杂参数解析</span>\n <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Object</span><span>></span></span> bindings <span>=</span> context<span>.</span><span>getBindings</span><span>(</span><span>)</span><span>;</span>\n <span>// 标签参数 + 原始参数</span>\n <span>(</span><span>(</span><span>Map</span><span>)</span>namedParams<span>)</span><span>.</span><span>putAll</span><span>(</span>bindings<span>)</span><span>;</span>\n <span>TextSqlNode</span> textSqlNode <span>=</span> <span>new</span> <span>TextSqlNode</span><span>(</span><span>resetSql</span><span>(</span>sql<span>,</span> <span>0</span><span>,</span> parameterMappings<span>,</span> metaObject<span>)</span><span>)</span><span>;</span>\n <span>new</span> <span>DynamicSqlSource</span><span>(</span>configuration<span>,</span> textSqlNode<span>)</span><span>.</span><span>getBoundSql</span><span>(</span>namedParams<span>)</span><span>.</span><span>getSql</span><span>(</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id=\"_2-4-sql格式化\"> 2.4 sql格式化</h2>\n<p>这里我们就直接使用druid库中的sql格式化工具</p>\n<div><pre><code>       <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>com.alibaba<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>druid<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n            <span><span><span>&lt;</span>version</span><span>></span></span>1.2.6<span><span><span>&lt;/</span>version</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>这里因为我们知道是mysql数据库所以执行使用mysql格式化</p>\n<div><pre><code><span>SQLUtils</span><span>.</span><span>formatMySql</span><span>(</span>boundSql<span>.</span><span>getSql</span><span>(</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"_2-5-使用方法设计\"> 2.5 使用方法设计</h2>\n<p>基于上门的代码,首先我们已经不依赖Spring容器了,所以要想分析sql就不用启动整个项目了。\n直接将要分析的类和方法进行执行就行了。</p>\n<div><pre><code><span>OrderBatchEntityQuery</span> query <span>=</span> <span>JMockData</span><span>.</span><span>mock</span><span>(</span><span>OrderBatchEntityQuery</span><span>.</span><span>class</span><span>)</span><span>;</span>\n<span>// 如果需要绑定xml就使用bindMapper</span>\n<span>QuickMapperChecker</span><span>.</span><span>analyse</span><span>(</span><span>QuickMapperChecker</span><span>.</span><span>mock</span><span>(</span><span>IOrderMapper</span><span>.</span><span>class</span><span>)</span><span>.</span><span>list</span><span>(</span>query<span>)</span><span>)</span>\n   <span>.</span><span>bindMapper</span><span>(</span><span>\"mapper/center/ReplenishOrderMapper.xml\"</span><span>)</span><span>.</span><span>printSql</span><span>(</span><span>)</span><span>;</span>   \n<span>// 如果完全依赖注解跟简单</span>\n<span>QuickMapperChecker</span><span>.</span><span>analyse</span><span>(</span><span>QuickMapperChecker</span><span>.</span><span>mock</span><span>(</span><span>IOrderMapper</span><span>.</span><span>class</span><span>)</span><span>.</span><span>list</span><span>(</span>query<span>)</span><span>)</span>\n   <span>.</span><span>printSql</span><span>(</span><span>)</span><span>;</span>   \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id=\"三、完整代码\"> 三、完整代码</h2>\n<p>代码较为简单这里附带源码</p>\n<h2 id=\"_3-1-mybatis-使用\"> 3.1 Mybatis 使用</h2>\n<div><pre><code><span>@NoArgsConstructor</span>\n<span>public</span> <span>class</span> <span>QuickMapperChecker</span> <span>{</span>\n\n    <span>/**\n     * 方法签名id\n     */</span>\n    <span>@Getter</span>\n    <span>public</span> <span>String</span> mapperId<span>;</span>\n\n    <span>@Setter</span>\n    <span>public</span> <span>String</span> methodName<span>;</span>\n\n    <span>/**\n     * 方法参数\n     */</span>\n    <span>@Getter</span>\n    <span>private</span> <span>Object</span><span>[</span><span>]</span> args<span>;</span>\n\n    <span>/**\n     * 参数解析器\n     */</span>\n    <span>@Getter</span>\n    <span>private</span> <span>ParamNameResolver</span> paramNameResolver<span>;</span>\n\n    <span>/**\n     * mapper类型\n     */</span>\n    <span>private</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> mapper<span>;</span>\n\n    <span>/**\n     * mybatis配置\n     */</span>\n    <span>@Getter</span>\n    <span>private</span> <span>Configuration</span> configuration<span>;</span>\n\n    <span>@Getter</span>\n    <span>@Setter</span>\n    <span>private</span> <span>String</span> mapperFile<span>;</span>\n\n    <span>private</span> <span>boolean</span> simple<span>;</span>\n\n    <span>public</span> <span>QuickMapperChecker</span><span>(</span><span>String</span> mapperId<span>,</span> <span>Object</span><span>[</span><span>]</span> args<span>,</span> <span>ParamNameResolver</span> paramNameResolver<span>,</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> mapper<span>,</span>\n                              <span>Configuration</span> configuration<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>mapperId <span>=</span> mapperId<span>;</span>\n        <span>this</span><span>.</span>args <span>=</span> args<span>;</span>\n        <span>this</span><span>.</span>paramNameResolver <span>=</span> paramNameResolver<span>;</span>\n        <span>this</span><span>.</span>mapper <span>=</span> mapper<span>;</span>\n        <span>this</span><span>.</span>configuration <span>=</span> configuration<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>QuickMapperChecker</span> <span>proxy</span><span>(</span><span>)</span> <span>{</span>\n        <span>if</span> <span>(</span><span>Objects</span><span>.</span><span>isNull</span><span>(</span>quickMapperChecker<span>)</span><span>)</span> <span>{</span>\n            quickMapperChecker <span>=</span> <span>new</span> <span>QuickMapperChecker</span><span>(</span><span>)</span><span>;</span>\n            quickMapperChecker<span>.</span>simple <span>=</span> <span>true</span><span>;</span>\n        <span>}</span>\n        <span>return</span> quickMapperChecker<span>;</span>\n    <span>}</span>\n\n    <span>private</span> <span>static</span> <span>QuickMapperChecker</span> quickMapperChecker<span>;</span>\n\n    <span>private</span> <span>static</span> <span>final</span> <span>Map</span><span><span>&lt;</span><span>Class</span><span>&lt;</span><span>?</span><span>></span><span>,</span> <span>Object</span><span>></span></span> PRIMITIVE_WRAPPER_TYPE_MAP <span>=</span> <span>new</span> <span>IdentityHashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>8</span><span>)</span><span>;</span>\n\n    <span>static</span> <span>{</span>\n        PRIMITIVE_WRAPPER_TYPE_MAP<span>.</span><span>put</span><span>(</span><span>Boolean</span><span>.</span><span>class</span><span>,</span> <span>false</span><span>)</span><span>;</span>\n        PRIMITIVE_WRAPPER_TYPE_MAP<span>.</span><span>put</span><span>(</span><span>Byte</span><span>.</span><span>class</span><span>,</span> <span>0</span><span>)</span><span>;</span>\n        PRIMITIVE_WRAPPER_TYPE_MAP<span>.</span><span>put</span><span>(</span><span>Character</span><span>.</span><span>class</span><span>,</span> <span>\"\"</span><span>)</span><span>;</span>\n        PRIMITIVE_WRAPPER_TYPE_MAP<span>.</span><span>put</span><span>(</span><span>Double</span><span>.</span><span>class</span><span>,</span> <span>0D</span><span>)</span><span>;</span>\n        PRIMITIVE_WRAPPER_TYPE_MAP<span>.</span><span>put</span><span>(</span><span>Float</span><span>.</span><span>class</span><span>,</span> <span>0L</span><span>)</span><span>;</span>\n        PRIMITIVE_WRAPPER_TYPE_MAP<span>.</span><span>put</span><span>(</span><span>Integer</span><span>.</span><span>class</span><span>,</span> <span>0</span><span>)</span><span>;</span>\n        PRIMITIVE_WRAPPER_TYPE_MAP<span>.</span><span>put</span><span>(</span><span>Long</span><span>.</span><span>class</span><span>,</span> <span>0L</span><span>)</span><span>;</span>\n        PRIMITIVE_WRAPPER_TYPE_MAP<span>.</span><span>put</span><span>(</span><span>Short</span><span>.</span><span>class</span><span>,</span> <span>0</span><span>)</span><span>;</span>\n        PRIMITIVE_WRAPPER_TYPE_MAP<span>.</span><span>put</span><span>(</span><span>Void</span><span>.</span><span>class</span><span>,</span> <span>Void</span><span>.</span>TYPE<span>)</span><span>;</span>\n\n        PRIMITIVE_WRAPPER_TYPE_MAP<span>.</span><span>put</span><span>(</span><span>boolean</span><span>.</span><span>class</span><span>,</span> <span>false</span><span>)</span><span>;</span>\n        PRIMITIVE_WRAPPER_TYPE_MAP<span>.</span><span>put</span><span>(</span><span>byte</span><span>.</span><span>class</span><span>,</span> <span>0</span><span>)</span><span>;</span>\n        PRIMITIVE_WRAPPER_TYPE_MAP<span>.</span><span>put</span><span>(</span><span>char</span><span>.</span><span>class</span><span>,</span> <span>\"\"</span><span>)</span><span>;</span>\n        PRIMITIVE_WRAPPER_TYPE_MAP<span>.</span><span>put</span><span>(</span><span>double</span><span>.</span><span>class</span><span>,</span> <span>0D</span><span>)</span><span>;</span>\n        PRIMITIVE_WRAPPER_TYPE_MAP<span>.</span><span>put</span><span>(</span><span>float</span><span>.</span><span>class</span><span>,</span> <span>0L</span><span>)</span><span>;</span>\n        PRIMITIVE_WRAPPER_TYPE_MAP<span>.</span><span>put</span><span>(</span><span>int</span><span>.</span><span>class</span><span>,</span> <span>0</span><span>)</span><span>;</span>\n        PRIMITIVE_WRAPPER_TYPE_MAP<span>.</span><span>put</span><span>(</span><span>long</span><span>.</span><span>class</span><span>,</span> <span>0L</span><span>)</span><span>;</span>\n        PRIMITIVE_WRAPPER_TYPE_MAP<span>.</span><span>put</span><span>(</span><span>short</span><span>.</span><span>class</span><span>,</span> <span>0</span><span>)</span><span>;</span>\n        PRIMITIVE_WRAPPER_TYPE_MAP<span>.</span><span>put</span><span>(</span><span>void</span><span>.</span><span>class</span><span>,</span> <span>null</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>private</span> <span>static</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span><span>[</span><span>]</span> <span>interfacesFromMapper</span><span>(</span><span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> mapper<span>)</span> <span>{</span>\n        <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span><span>[</span><span>]</span> interfaces <span>=</span> mapper<span>.</span><span>getInterfaces</span><span>(</span><span>)</span><span>;</span>\n        <span>List</span><span><span>&lt;</span><span>Class</span><span>&lt;</span><span>?</span><span>></span><span>></span></span> interfacesClass <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span>interfaces<span>.</span>length <span>></span> <span>0</span><span>)</span> <span>{</span>\n            interfacesClass<span>.</span><span>addAll</span><span>(</span><span>Arrays</span><span>.</span><span>asList</span><span>(</span>interfaces<span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>if</span> <span>(</span>mapper<span>.</span><span>isInterface</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n            interfacesClass<span>.</span><span>add</span><span>(</span>mapper<span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> interfacesClass<span>.</span><span>toArray</span><span>(</span><span>new</span> <span>Class</span><span>[</span><span>]</span><span>{</span><span>}</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span><span>&lt;</span><span>T</span><span>></span></span> <span>T</span> <span>mock</span><span>(</span><span>Class</span><span><span>&lt;</span><span>T</span><span>></span></span> mapper<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>return</span> <span>mock</span><span>(</span>mapper<span>,</span> <span>new</span> <span>Configuration</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@SuppressWarnings</span><span>(</span><span>\"unchecked\"</span><span>)</span>\n    <span>public</span> <span>static</span> <span><span>&lt;</span><span>T</span><span>></span></span> <span>T</span> <span>mock</span><span>(</span><span>Class</span><span><span>&lt;</span><span>T</span><span>></span></span> mapper<span>,</span> <span>Configuration</span> configuration<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>return</span> <span>(</span><span>T</span><span>)</span> <span>Proxy</span><span>.</span><span>newProxyInstance</span><span>(</span>mapper<span>.</span><span>getClassLoader</span><span>(</span><span>)</span><span>,</span> <span>interfacesFromMapper</span><span>(</span>mapper<span>)</span><span>,</span>\n                <span>(</span>proxy<span>,</span> method<span>,</span> args<span>)</span> <span>-></span> <span>{</span>\n                    <span>String</span> mapperId <span>=</span> method<span>.</span><span>getDeclaringClass</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\".\"</span> <span>+</span> method<span>.</span><span>getName</span><span>(</span><span>)</span><span>;</span>\n                    <span>if</span> <span>(</span><span>Objects</span><span>.</span><span>isNull</span><span>(</span>quickMapperChecker<span>)</span><span>)</span> <span>{</span>\n                        quickMapperChecker <span>=</span> <span>new</span> <span>QuickMapperChecker</span><span>(</span>mapperId<span>,</span> args<span>,</span>\n                                <span>new</span> <span>ParamNameResolver</span><span>(</span>configuration<span>,</span> method<span>)</span><span>,</span> mapper<span>,</span> configuration<span>)</span><span>;</span>\n                        quickMapperChecker<span>.</span><span>setMethodName</span><span>(</span>method<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n                    <span>}</span> <span>else</span> <span>{</span>\n                        <span>boolean</span> simple <span>=</span> quickMapperChecker<span>.</span>simple<span>;</span>\n                        quickMapperChecker <span>=</span> <span>new</span> <span>QuickMapperChecker</span><span>(</span>mapperId<span>,</span> args<span>,</span>\n                                <span>new</span> <span>ParamNameResolver</span><span>(</span>configuration<span>,</span> method<span>)</span><span>,</span> mapper<span>,</span> configuration<span>)</span><span>;</span>\n                        quickMapperChecker<span>.</span>simple <span>=</span> simple<span>;</span>\n                        quickMapperChecker<span>.</span><span>setMethodName</span><span>(</span>method<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n                    <span>}</span>\n                    <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> returnType <span>=</span> method<span>.</span><span>getReturnType</span><span>(</span><span>)</span><span>;</span>\n                    <span>Object</span> result <span>=</span> PRIMITIVE_WRAPPER_TYPE_MAP<span>.</span><span>get</span><span>(</span>returnType<span>)</span><span>;</span>\n                    <span>if</span> <span>(</span>quickMapperChecker<span>.</span>simple<span>)</span> <span>{</span>\n                        quickMapperChecker<span>.</span><span>printSql</span><span>(</span><span>)</span><span>;</span>\n                    <span>}</span>\n                    <span>return</span> <span>Objects</span><span>.</span><span>nonNull</span><span>(</span>result<span>)</span> <span>?</span> result <span>:</span> <span>new</span> <span>DefaultObjectFactory</span><span>(</span><span>)</span><span>.</span><span>create</span><span>(</span>returnType<span>)</span><span>;</span>\n                <span>}</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 处理占位符已经被替换成?的时候，用于将占位符重新替换成变量符\n     *\n     * @param sql               占位符sql\n     * @param index             占位符当前处理的索引\n     * @param parameterMappings 占位符参数信息\n     * @return String 变量符sql\n     */</span>\n    <span>private</span> <span>String</span> <span>resetSql</span><span>(</span><span>String</span> sql<span>,</span> <span>int</span> index<span>,</span> <span>List</span><span><span>&lt;</span><span>ParameterMapping</span><span>></span></span> parameterMappings<span>,</span> <span>MetaObject</span> metaObject<span>)</span> <span>{</span>\n        <span>int</span> i <span>=</span> sql<span>.</span><span>indexOf</span><span>(</span><span>\"?\"</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span>i <span>></span> <span>-</span><span>1</span><span>)</span> <span>{</span>\n            <span>ParameterMapping</span> parameterMapping <span>=</span> parameterMappings<span>.</span><span>get</span><span>(</span>index<span>)</span><span>;</span>\n            <span>String</span> property <span>=</span> parameterMapping<span>.</span><span>getProperty</span><span>(</span><span>)</span><span>;</span>\n            <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> javaType <span>=</span> parameterMapping<span>.</span><span>getJavaType</span><span>(</span><span>)</span><span>;</span>\n            <span>Object</span> value <span>=</span> metaObject<span>.</span><span>getValue</span><span>(</span>parameterMapping<span>.</span><span>getProperty</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>String</span> s<span>;</span>\n            <span>if</span> <span>(</span>javaType<span>.</span><span>equals</span><span>(</span><span>String</span><span>.</span><span>class</span><span>)</span> <span>||</span> value <span>instanceof</span> <span>String</span><span>)</span> <span>{</span>\n                s <span>=</span> sql<span>.</span><span>replaceFirst</span><span>(</span><span>\"\\\\?\"</span><span>,</span> <span>\"\\\"\\\\${\"</span> <span>+</span> property <span>+</span> <span>\"}\\\"\"</span><span>)</span><span>;</span>\n            <span>}</span> <span>else</span> <span>{</span>\n                s <span>=</span> sql<span>.</span><span>replaceFirst</span><span>(</span><span>\"\\\\?\"</span><span>,</span> <span>\"\\\\${\"</span> <span>+</span> property <span>+</span> <span>\"}\"</span><span>)</span><span>;</span>\n            <span>}</span>\n            sql <span>=</span> <span>resetSql</span><span>(</span>s<span>,</span> <span>++</span>index<span>,</span> parameterMappings<span>,</span> metaObject<span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> sql<span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * sql打印\n     *\n     * @return String\n     * @throws Exception 未知异常\n     */</span>\n    <span>public</span> <span>String</span> <span>getSql</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>if</span> <span>(</span><span>!</span><span>StringUtils</span><span>.</span><span>isBlank</span><span>(</span><span>this</span><span>.</span>mapperFile<span>)</span><span>)</span> <span>{</span>\n            <span>loadMappedStatementByMapperFile</span><span>(</span><span>this</span><span>.</span>mapperFile<span>)</span><span>;</span>\n        <span>}</span>\n        <span>loadMappedStatementByAnnotation</span><span>(</span><span>)</span><span>;</span>\n        <span>boolean</span> hasMapped <span>=</span> configuration<span>.</span><span>hasStatement</span><span>(</span>quickMapperChecker<span>.</span>mapperId<span>)</span><span>;</span>\n        <span>if</span> <span>(</span><span>!</span>hasMapped<span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>RuntimeException</span><span>(</span>\n                    <span>\"未找到MappedStatement,请检查是否需要绑定mapper xml文件:[\"</span> <span>+</span> quickMapperChecker<span>.</span>mapperId <span>+</span> <span>\"]\"</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>MappedStatement</span> mappedStatement <span>=</span> configuration<span>.</span><span>getMappedStatement</span><span>(</span>quickMapperChecker<span>.</span>mapperId<span>)</span><span>;</span>\n        <span>SqlSource</span> sqlSource <span>=</span> mappedStatement<span>.</span><span>getSqlSource</span><span>(</span><span>)</span><span>;</span>\n        <span>Object</span> namedParams <span>=</span> paramNameResolver<span>.</span><span>getNamedParams</span><span>(</span>quickMapperChecker<span>.</span>args<span>)</span><span>;</span>\n        <span>BoundSql</span> boundSql <span>=</span> mappedStatement<span>.</span><span>getBoundSql</span><span>(</span>namedParams<span>)</span><span>;</span>\n        <span>// 占位符</span>\n        <span>if</span> <span>(</span>sqlSource <span>instanceof</span> <span>RawSqlSource</span> <span>||</span> sqlSource <span>instanceof</span> <span>DynamicSqlSource</span><span>)</span> <span>{</span>\n            <span>// 占位sql，将#替换成$</span>\n            <span>String</span> sql <span>=</span> boundSql<span>.</span><span>getSql</span><span>(</span><span>)</span><span>;</span>\n            <span>List</span><span><span>&lt;</span><span>ParameterMapping</span><span>></span></span> parameterMappings <span>=</span> boundSql<span>.</span><span>getParameterMappings</span><span>(</span><span>)</span><span>;</span>\n            <span>XNode</span> node <span>=</span> <span>findNode</span><span>(</span><span>)</span><span>;</span>\n            <span>if</span> <span>(</span><span>Objects</span><span>.</span><span>nonNull</span><span>(</span>node<span>)</span><span>)</span> <span>{</span>\n                <span>// 解析xml中的标签信息</span>\n                <span>Method</span> parseDynamicTags <span>=</span> <span>XMLScriptBuilder</span><span>.</span><span>class</span><span>.</span><span>getDeclaredMethod</span><span>(</span><span>\"parseDynamicTags\"</span><span>,</span> <span>XNode</span><span>.</span><span>class</span><span>)</span><span>;</span>\n                parseDynamicTags<span>.</span><span>setAccessible</span><span>(</span><span>true</span><span>)</span><span>;</span>\n\n                <span>XMLScriptBuilder</span> xmlScriptBuilder <span>=</span> <span>new</span> <span>XMLScriptBuilder</span><span>(</span>configuration<span>,</span> node<span>)</span><span>;</span>\n                <span>MixedSqlNode</span> rootSqlNode <span>=</span> <span>(</span><span>MixedSqlNode</span><span>)</span> parseDynamicTags<span>.</span><span>invoke</span><span>(</span>xmlScriptBuilder<span>,</span> node<span>)</span><span>;</span>\n                <span>DynamicContext</span> context <span>=</span> <span>new</span> <span>DynamicContext</span><span>(</span>configuration<span>,</span> namedParams<span>)</span><span>;</span>\n                rootSqlNode<span>.</span><span>apply</span><span>(</span>context<span>)</span><span>;</span>\n                <span>// 标签信息参数解析</span>\n                <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Object</span><span>></span></span> bindings <span>=</span> context<span>.</span><span>getBindings</span><span>(</span><span>)</span><span>;</span>\n                <span>// 标签参数 + 原始参数</span>\n                <span>(</span><span>(</span><span>Map</span><span>)</span> namedParams<span>)</span><span>.</span><span>putAll</span><span>(</span>bindings<span>)</span><span>;</span>\n            <span>}</span>\n            <span>MetaObject</span> metaObject <span>=</span> configuration<span>.</span><span>newMetaObject</span><span>(</span>namedParams<span>)</span><span>;</span>\n            <span>processDate</span><span>(</span>parameterMappings<span>,</span> metaObject<span>)</span><span>;</span>\n            <span>TextSqlNode</span> textSqlNode <span>=</span> <span>new</span> <span>TextSqlNode</span><span>(</span><span>resetSql</span><span>(</span>sql<span>,</span> <span>0</span><span>,</span> parameterMappings<span>,</span> metaObject<span>)</span><span>)</span><span>;</span>\n            <span>return</span> <span>SQLUtils</span>\n                    <span>.</span><span>formatMySql</span><span>(</span><span>(</span><span>new</span> <span>DynamicSqlSource</span><span>(</span>configuration<span>,</span> textSqlNode<span>)</span><span>.</span><span>getBoundSql</span><span>(</span>namedParams<span>)</span><span>.</span><span>getSql</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            <span>return</span> <span>SQLUtils</span><span>.</span><span>formatMySql</span><span>(</span>boundSql<span>.</span><span>getSql</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>private</span> <span>void</span> <span>processDate</span><span>(</span><span>List</span><span><span>&lt;</span><span>ParameterMapping</span><span>></span></span> parameterMappings<span>,</span> <span>MetaObject</span> metaObject<span>)</span> <span>{</span>\n        <span>for</span> <span>(</span><span>ParameterMapping</span> parameterMapping <span>:</span> parameterMappings<span>)</span> <span>{</span>\n            <span>String</span> property <span>=</span> parameterMapping<span>.</span><span>getProperty</span><span>(</span><span>)</span><span>;</span>\n            <span>Object</span> value <span>=</span> metaObject<span>.</span><span>getValue</span><span>(</span>property<span>)</span><span>;</span>\n            <span>if</span> <span>(</span>value <span>instanceof</span> <span>Date</span><span>)</span> <span>{</span>\n                metaObject<span>.</span><span>setValue</span><span>(</span>property<span>,</span> <span>DatePatternEnum</span><span>.</span>DATE_TIME_PATTERN<span>.</span><span>format</span><span>(</span><span>(</span><span>Date</span><span>)</span> value<span>)</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>private</span> <span>XNode</span> <span>findNode</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>InputStream</span> resourceAsStream <span>=</span> <span>Resources</span><span>.</span><span>getResourceAsStream</span><span>(</span><span>this</span><span>.</span>mapperFile<span>)</span><span>;</span>\n        <span>XPathParser</span> xPathParser <span>=</span> <span>new</span> <span>XPathParser</span><span>(</span>resourceAsStream<span>)</span><span>;</span>\n        <span>XNode</span> mapperNode <span>=</span> xPathParser<span>.</span><span>evalNode</span><span>(</span><span>\"/mapper\"</span><span>)</span><span>;</span>\n        <span>List</span><span><span>&lt;</span><span>XNode</span><span>></span></span> children <span>=</span> mapperNode<span>.</span><span>getChildren</span><span>(</span><span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>XNode</span> child <span>:</span> children<span>)</span> <span>{</span>\n            <span>if</span> <span>(</span>child<span>.</span><span>getStringAttribute</span><span>(</span><span>\"id\"</span><span>)</span><span>.</span><span>equals</span><span>(</span>quickMapperChecker<span>.</span>methodName<span>)</span><span>)</span> <span>{</span>\n                <span>MapperBuilderAssistant</span> mapperBuilderAssistant <span>=</span>\n                        <span>new</span> <span>MapperBuilderAssistant</span><span>(</span>configuration<span>,</span> quickMapperChecker<span>.</span>mapperFile<span>)</span><span>;</span>\n                mapperBuilderAssistant<span>.</span><span>setCurrentNamespace</span><span>(</span>mapper<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n                <span>XMLIncludeTransformer</span> includeParser <span>=</span> <span>new</span> <span>XMLIncludeTransformer</span><span>(</span>configuration<span>,</span> mapperBuilderAssistant<span>)</span><span>;</span>\n                includeParser<span>.</span><span>applyIncludes</span><span>(</span>child<span>.</span><span>getNode</span><span>(</span><span>)</span><span>)</span><span>;</span>\n                <span>return</span> child<span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>// \"select|insert|update|delete\"</span>\n        <span>return</span> <span>null</span><span>;</span>\n    <span>}</span>\n\n    <span>;</span>\n\n    <span>private</span> <span>void</span> <span>loadMappedStatementByAnnotation</span><span>(</span><span>)</span> <span>{</span>\n        <span>MapperAnnotationBuilder</span> mapperAnnotationBuilder <span>=</span>\n                <span>new</span> <span>MapperAnnotationBuilder</span><span>(</span>configuration<span>,</span> quickMapperChecker<span>.</span>mapper<span>)</span><span>;</span>\n        mapperAnnotationBuilder<span>.</span><span>parse</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>private</span> <span>void</span> <span>loadMappedStatementByMapperFile</span><span>(</span><span>String</span> mapperXmlFile<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>InputStream</span> resourceAsStream <span>=</span> <span>Resources</span><span>.</span><span>getResourceAsStream</span><span>(</span>mapperXmlFile<span>)</span><span>;</span>\n        <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>XNode</span><span>></span></span> sqlFragments <span>=</span> configuration<span>.</span><span>getSqlFragments</span><span>(</span><span>)</span><span>;</span>\n        <span>new</span> <span>XMLMapperBuilder</span><span>(</span>resourceAsStream<span>,</span> configuration<span>,</span> mapperXmlFile<span>,</span> sqlFragments<span>)</span><span>.</span><span>parse</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>printSql</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>ColorConsole</span><span>.</span><span>colorPrintln</span><span>(</span><span>\"🚀 格式化SQL:\"</span><span>)</span><span>;</span>\n        <span>ColorConsole</span><span>.</span><span>colorPrintln</span><span>(</span><span>AnsiColor</span><span>.</span>BRIGHT_MAGENTA<span>,</span> <span>\"{}\"</span><span>,</span> <span>getSql</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * sql信息进行检查\n     *\n     * @param t   泛型\n     * @param &lt;T> 泛型\n     * @return QuickMapperChecker\n     */</span>\n    <span>public</span> <span>static</span> <span><span>&lt;</span><span>T</span><span>></span></span> <span>QuickMapperChecker</span> <span>analyse</span><span>(</span><span>T</span> t<span>)</span> <span>{</span>\n        <span>// 1. 调用方法</span>\n        <span>return</span> quickMapperChecker<span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 绑定mapper文件\n     *\n     * @param mapperFile mapper文件地址\n     * @return QuickMapperChecker\n     */</span>\n    <span>public</span> <span>QuickMapperChecker</span> <span>bindMapper</span><span>(</span><span>String</span> mapperFile<span>)</span> <span>{</span>\n        quickMapperChecker<span>.</span><span>setMapperFile</span><span>(</span>mapperFile<span>)</span><span>;</span>\n        <span>return</span> quickMapperChecker<span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br><span>135</span><br><span>136</span><br><span>137</span><br><span>138</span><br><span>139</span><br><span>140</span><br><span>141</span><br><span>142</span><br><span>143</span><br><span>144</span><br><span>145</span><br><span>146</span><br><span>147</span><br><span>148</span><br><span>149</span><br><span>150</span><br><span>151</span><br><span>152</span><br><span>153</span><br><span>154</span><br><span>155</span><br><span>156</span><br><span>157</span><br><span>158</span><br><span>159</span><br><span>160</span><br><span>161</span><br><span>162</span><br><span>163</span><br><span>164</span><br><span>165</span><br><span>166</span><br><span>167</span><br><span>168</span><br><span>169</span><br><span>170</span><br><span>171</span><br><span>172</span><br><span>173</span><br><span>174</span><br><span>175</span><br><span>176</span><br><span>177</span><br><span>178</span><br><span>179</span><br><span>180</span><br><span>181</span><br><span>182</span><br><span>183</span><br><span>184</span><br><span>185</span><br><span>186</span><br><span>187</span><br><span>188</span><br><span>189</span><br><span>190</span><br><span>191</span><br><span>192</span><br><span>193</span><br><span>194</span><br><span>195</span><br><span>196</span><br><span>197</span><br><span>198</span><br><span>199</span><br><span>200</span><br><span>201</span><br><span>202</span><br><span>203</span><br><span>204</span><br><span>205</span><br><span>206</span><br><span>207</span><br><span>208</span><br><span>209</span><br><span>210</span><br><span>211</span><br><span>212</span><br><span>213</span><br><span>214</span><br><span>215</span><br><span>216</span><br><span>217</span><br><span>218</span><br><span>219</span><br><span>220</span><br><span>221</span><br><span>222</span><br><span>223</span><br><span>224</span><br><span>225</span><br><span>226</span><br><span>227</span><br><span>228</span><br><span>229</span><br><span>230</span><br><span>231</span><br><span>232</span><br><span>233</span><br><span>234</span><br><span>235</span><br><span>236</span><br><span>237</span><br><span>238</span><br><span>239</span><br><span>240</span><br><span>241</span><br><span>242</span><br><span>243</span><br><span>244</span><br><span>245</span><br><span>246</span><br><span>247</span><br><span>248</span><br><span>249</span><br><span>250</span><br><span>251</span><br><span>252</span><br><span>253</span><br><span>254</span><br><span>255</span><br><span>256</span><br><span>257</span><br><span>258</span><br><span>259</span><br><span>260</span><br><span>261</span><br><span>262</span><br><span>263</span><br><span>264</span><br><span>265</span><br><span>266</span><br><span>267</span><br><span>268</span><br><span>269</span><br><span>270</span><br><span>271</span><br><span>272</span><br><span>273</span><br></div></div><h2 id=\"_3-2-mybatis-plus-使用\"> 3.2 Mybatis Plus 使用</h2>\n<div><pre><code><span>/**\n * 无需启动容器对sql信息进行检查\n *\n * @author liuxin 2022/4/27 17:48\n */</span>\n<span>@NoArgsConstructor</span>\n<span>public</span> <span>class</span> <span>QuickMapperPlusChecker</span> <span>{</span>\n\n    <span>/**\n     * 方法签名id\n     */</span>\n    <span>@Getter</span>\n    <span>public</span> <span>String</span> mapperId<span>;</span>\n\n    <span>@Setter</span>\n    <span>public</span> <span>String</span> methodName<span>;</span>\n\n    <span>/**\n     * 方法参数\n     */</span>\n    <span>@Getter</span>\n    <span>private</span> <span>Object</span><span>[</span><span>]</span> args<span>;</span>\n\n    <span>/**\n     * 参数解析器\n     */</span>\n    <span>@Getter</span>\n    <span>private</span> <span>ParamNameResolver</span> paramNameResolver<span>;</span>\n\n    <span>/**\n     * mapper类型\n     */</span>\n    <span>private</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> mapper<span>;</span>\n\n    <span>/**\n     * mybatis配置\n     */</span>\n    <span>@Getter</span>\n    <span>private</span> <span>MybatisConfiguration</span> configuration<span>;</span>\n\n    <span>@Getter</span>\n    <span>@Setter</span>\n    <span>private</span> <span>String</span> mapperFile<span>;</span>\n\n    <span>private</span> <span>boolean</span> simple<span>;</span>\n\n    <span>public</span> <span>QuickMapperPlusChecker</span><span>(</span><span>String</span> mapperId<span>,</span> <span>Object</span><span>[</span><span>]</span> args<span>,</span> <span>ParamNameResolver</span> paramNameResolver<span>,</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> mapper<span>,</span>\n        <span>MybatisConfiguration</span> configuration<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>mapperId <span>=</span> mapperId<span>;</span>\n        <span>this</span><span>.</span>args <span>=</span> args<span>;</span>\n        <span>this</span><span>.</span>paramNameResolver <span>=</span> paramNameResolver<span>;</span>\n        <span>this</span><span>.</span>mapper <span>=</span> mapper<span>;</span>\n        <span>this</span><span>.</span>configuration <span>=</span> configuration<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>QuickMapperPlusChecker</span> <span>proxy</span><span>(</span><span>)</span> <span>{</span>\n        <span>if</span> <span>(</span><span>Objects</span><span>.</span><span>isNull</span><span>(</span>quickMapperChecker<span>)</span><span>)</span> <span>{</span>\n            quickMapperChecker <span>=</span> <span>new</span> <span>QuickMapperPlusChecker</span><span>(</span><span>)</span><span>;</span>\n            quickMapperChecker<span>.</span>simple <span>=</span> <span>true</span><span>;</span>\n        <span>}</span>\n        <span>return</span> quickMapperChecker<span>;</span>\n    <span>}</span>\n\n    <span>private</span> <span>static</span> <span>QuickMapperPlusChecker</span> quickMapperChecker<span>;</span>\n\n    <span>private</span> <span>static</span> <span>final</span> <span>Map</span><span><span>&lt;</span><span>Class</span><span>&lt;</span><span>?</span><span>></span><span>,</span> <span>Object</span><span>></span></span> PRIMITIVE_WRAPPER_TYPE_MAP <span>=</span> <span>new</span> <span>IdentityHashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>8</span><span>)</span><span>;</span>\n\n    <span>static</span> <span>{</span>\n        PRIMITIVE_WRAPPER_TYPE_MAP<span>.</span><span>put</span><span>(</span><span>Boolean</span><span>.</span><span>class</span><span>,</span> <span>false</span><span>)</span><span>;</span>\n        PRIMITIVE_WRAPPER_TYPE_MAP<span>.</span><span>put</span><span>(</span><span>Byte</span><span>.</span><span>class</span><span>,</span> <span>0</span><span>)</span><span>;</span>\n        PRIMITIVE_WRAPPER_TYPE_MAP<span>.</span><span>put</span><span>(</span><span>Character</span><span>.</span><span>class</span><span>,</span> <span>\"\"</span><span>)</span><span>;</span>\n        PRIMITIVE_WRAPPER_TYPE_MAP<span>.</span><span>put</span><span>(</span><span>Double</span><span>.</span><span>class</span><span>,</span> <span>0D</span><span>)</span><span>;</span>\n        PRIMITIVE_WRAPPER_TYPE_MAP<span>.</span><span>put</span><span>(</span><span>Float</span><span>.</span><span>class</span><span>,</span> <span>0L</span><span>)</span><span>;</span>\n        PRIMITIVE_WRAPPER_TYPE_MAP<span>.</span><span>put</span><span>(</span><span>Integer</span><span>.</span><span>class</span><span>,</span> <span>0</span><span>)</span><span>;</span>\n        PRIMITIVE_WRAPPER_TYPE_MAP<span>.</span><span>put</span><span>(</span><span>Long</span><span>.</span><span>class</span><span>,</span> <span>0L</span><span>)</span><span>;</span>\n        PRIMITIVE_WRAPPER_TYPE_MAP<span>.</span><span>put</span><span>(</span><span>Short</span><span>.</span><span>class</span><span>,</span> <span>0</span><span>)</span><span>;</span>\n        PRIMITIVE_WRAPPER_TYPE_MAP<span>.</span><span>put</span><span>(</span><span>Void</span><span>.</span><span>class</span><span>,</span> <span>Void</span><span>.</span>TYPE<span>)</span><span>;</span>\n\n        PRIMITIVE_WRAPPER_TYPE_MAP<span>.</span><span>put</span><span>(</span><span>boolean</span><span>.</span><span>class</span><span>,</span> <span>false</span><span>)</span><span>;</span>\n        PRIMITIVE_WRAPPER_TYPE_MAP<span>.</span><span>put</span><span>(</span><span>byte</span><span>.</span><span>class</span><span>,</span> <span>0</span><span>)</span><span>;</span>\n        PRIMITIVE_WRAPPER_TYPE_MAP<span>.</span><span>put</span><span>(</span><span>char</span><span>.</span><span>class</span><span>,</span> <span>\"\"</span><span>)</span><span>;</span>\n        PRIMITIVE_WRAPPER_TYPE_MAP<span>.</span><span>put</span><span>(</span><span>double</span><span>.</span><span>class</span><span>,</span> <span>0D</span><span>)</span><span>;</span>\n        PRIMITIVE_WRAPPER_TYPE_MAP<span>.</span><span>put</span><span>(</span><span>float</span><span>.</span><span>class</span><span>,</span> <span>0L</span><span>)</span><span>;</span>\n        PRIMITIVE_WRAPPER_TYPE_MAP<span>.</span><span>put</span><span>(</span><span>int</span><span>.</span><span>class</span><span>,</span> <span>0</span><span>)</span><span>;</span>\n        PRIMITIVE_WRAPPER_TYPE_MAP<span>.</span><span>put</span><span>(</span><span>long</span><span>.</span><span>class</span><span>,</span> <span>0L</span><span>)</span><span>;</span>\n        PRIMITIVE_WRAPPER_TYPE_MAP<span>.</span><span>put</span><span>(</span><span>short</span><span>.</span><span>class</span><span>,</span> <span>0</span><span>)</span><span>;</span>\n        PRIMITIVE_WRAPPER_TYPE_MAP<span>.</span><span>put</span><span>(</span><span>void</span><span>.</span><span>class</span><span>,</span> <span>null</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>private</span> <span>static</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span><span>[</span><span>]</span> <span>interfacesFromMapper</span><span>(</span><span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> mapper<span>)</span> <span>{</span>\n        <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span><span>[</span><span>]</span> interfaces <span>=</span> mapper<span>.</span><span>getInterfaces</span><span>(</span><span>)</span><span>;</span>\n        <span>List</span><span><span>&lt;</span><span>Class</span><span>&lt;</span><span>?</span><span>></span><span>></span></span> interfacesClass <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span>interfaces<span>.</span>length <span>></span> <span>0</span><span>)</span> <span>{</span>\n            interfacesClass<span>.</span><span>addAll</span><span>(</span><span>Arrays</span><span>.</span><span>asList</span><span>(</span>interfaces<span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>if</span> <span>(</span>mapper<span>.</span><span>isInterface</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n            interfacesClass<span>.</span><span>add</span><span>(</span>mapper<span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> interfacesClass<span>.</span><span>toArray</span><span>(</span><span>new</span> <span>Class</span><span>[</span><span>]</span> <span>{</span><span>}</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span><span>&lt;</span><span>T</span><span>></span></span> <span>T</span> <span>mock</span><span>(</span><span>Class</span><span><span>&lt;</span><span>T</span><span>></span></span> mapper<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>return</span> <span>mock</span><span>(</span>mapper<span>,</span> <span>new</span> <span>MybatisConfiguration</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@SuppressWarnings</span><span>(</span><span>\"unchecked\"</span><span>)</span>\n    <span>public</span> <span>static</span> <span><span>&lt;</span><span>T</span><span>></span></span> <span>T</span> <span>mock</span><span>(</span><span>Class</span><span><span>&lt;</span><span>T</span><span>></span></span> mapper<span>,</span> <span>MybatisConfiguration</span> configuration<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>return</span> <span>(</span><span>T</span><span>)</span><span>Proxy</span><span>.</span><span>newProxyInstance</span><span>(</span>mapper<span>.</span><span>getClassLoader</span><span>(</span><span>)</span><span>,</span> <span>interfacesFromMapper</span><span>(</span>mapper<span>)</span><span>,</span>\n            <span>(</span>proxy<span>,</span> method<span>,</span> args<span>)</span> <span>-></span> <span>{</span>\n                <span>String</span> mapperId <span>=</span> mapper<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\".\"</span> <span>+</span> method<span>.</span><span>getName</span><span>(</span><span>)</span><span>;</span>\n                <span>if</span> <span>(</span><span>Objects</span><span>.</span><span>isNull</span><span>(</span>quickMapperChecker<span>)</span><span>)</span> <span>{</span>\n                    quickMapperChecker <span>=</span> <span>new</span> <span>QuickMapperPlusChecker</span><span>(</span>mapperId<span>,</span> args<span>,</span>\n                        <span>new</span> <span>ParamNameResolver</span><span>(</span>configuration<span>,</span> method<span>)</span><span>,</span> mapper<span>,</span> configuration<span>)</span><span>;</span>\n                    quickMapperChecker<span>.</span><span>setMethodName</span><span>(</span>method<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n                <span>}</span> <span>else</span> <span>{</span>\n                    <span>boolean</span> simple <span>=</span> quickMapperChecker<span>.</span>simple<span>;</span>\n                    quickMapperChecker <span>=</span> <span>new</span> <span>QuickMapperPlusChecker</span><span>(</span>mapperId<span>,</span> args<span>,</span>\n                        <span>new</span> <span>ParamNameResolver</span><span>(</span>configuration<span>,</span> method<span>)</span><span>,</span> mapper<span>,</span> configuration<span>)</span><span>;</span>\n                    quickMapperChecker<span>.</span>simple <span>=</span> simple<span>;</span>\n                    quickMapperChecker<span>.</span><span>setMethodName</span><span>(</span>method<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n                <span>}</span>\n                <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> returnType <span>=</span> method<span>.</span><span>getReturnType</span><span>(</span><span>)</span><span>;</span>\n                <span>Object</span> result <span>=</span> PRIMITIVE_WRAPPER_TYPE_MAP<span>.</span><span>get</span><span>(</span>returnType<span>)</span><span>;</span>\n                <span>if</span> <span>(</span>quickMapperChecker<span>.</span>simple<span>)</span> <span>{</span>\n                    quickMapperChecker<span>.</span><span>printSql</span><span>(</span><span>)</span><span>;</span>\n                <span>}</span>\n                <span>return</span> <span>Objects</span><span>.</span><span>nonNull</span><span>(</span>result<span>)</span> <span>?</span> result <span>:</span> <span>new</span> <span>DefaultObjectFactory</span><span>(</span><span>)</span><span>.</span><span>create</span><span>(</span>returnType<span>)</span><span>;</span>\n            <span>}</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 处理占位符已经被替换成?的时候，用于将占位符重新替换成变量符\n     *\n     * @param sql\n     *            占位符sql\n     * @param index\n     *            占位符当前处理的索引\n     * @param parameterMappings\n     *            占位符参数信息\n     * @return String 变量符sql\n     */</span>\n    <span>private</span> <span>String</span> <span>resetSql</span><span>(</span><span>String</span> sql<span>,</span> <span>int</span> index<span>,</span> <span>List</span><span><span>&lt;</span><span>ParameterMapping</span><span>></span></span> parameterMappings<span>,</span> <span>MetaObject</span> metaObject<span>)</span> <span>{</span>\n        <span>int</span> i <span>=</span> sql<span>.</span><span>indexOf</span><span>(</span><span>\"?\"</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span>i <span>></span> <span>-</span><span>1</span><span>)</span> <span>{</span>\n            <span>ParameterMapping</span> parameterMapping <span>=</span> parameterMappings<span>.</span><span>get</span><span>(</span>index<span>)</span><span>;</span>\n            <span>String</span> property <span>=</span> parameterMapping<span>.</span><span>getProperty</span><span>(</span><span>)</span><span>;</span>\n            <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> javaType <span>=</span> parameterMapping<span>.</span><span>getJavaType</span><span>(</span><span>)</span><span>;</span>\n            <span>Object</span> value <span>=</span> metaObject<span>.</span><span>getValue</span><span>(</span>parameterMapping<span>.</span><span>getProperty</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>String</span> s<span>;</span>\n            <span>if</span> <span>(</span>javaType<span>.</span><span>equals</span><span>(</span><span>String</span><span>.</span><span>class</span><span>)</span> <span>||</span> value <span>instanceof</span> <span>String</span><span>)</span> <span>{</span>\n                s <span>=</span> sql<span>.</span><span>replaceFirst</span><span>(</span><span>\"\\\\?\"</span><span>,</span> <span>\"\\\"\\\\${\"</span> <span>+</span> property <span>+</span> <span>\"}\\\"\"</span><span>)</span><span>;</span>\n            <span>}</span> <span>else</span> <span>{</span>\n                s <span>=</span> sql<span>.</span><span>replaceFirst</span><span>(</span><span>\"\\\\?\"</span><span>,</span> <span>\"\\\\${\"</span> <span>+</span> property <span>+</span> <span>\"}\"</span><span>)</span><span>;</span>\n            <span>}</span>\n            sql <span>=</span> <span>resetSql</span><span>(</span>s<span>,</span> <span>++</span>index<span>,</span> parameterMappings<span>,</span> metaObject<span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> sql<span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * sql打印\n     * \n     * @return String\n     * @throws Exception\n     *             未知异常\n     */</span>\n    <span>public</span> <span>String</span> <span>getSql</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>if</span> <span>(</span><span>!</span><span>StringUtils</span><span>.</span><span>isBlank</span><span>(</span><span>this</span><span>.</span>mapperFile<span>)</span><span>)</span> <span>{</span>\n            <span>loadMappedStatementByMapperFile</span><span>(</span><span>this</span><span>.</span>mapperFile<span>)</span><span>;</span>\n        <span>}</span>\n        <span>loadMappedStatementByAnnotation</span><span>(</span><span>)</span><span>;</span>\n        <span>new</span> <span>SqlRunnerInjector</span><span>(</span><span>)</span><span>.</span><span>inject</span><span>(</span>configuration<span>)</span><span>;</span>\n        <span>boolean</span> hasMapped <span>=</span> configuration<span>.</span><span>hasStatement</span><span>(</span>quickMapperChecker<span>.</span>mapperId<span>)</span><span>;</span>\n        <span>if</span> <span>(</span><span>!</span>hasMapped<span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>RuntimeException</span><span>(</span>\n                <span>\"未找到MappedStatement,请检查是否需要绑定mapper xml文件:[\"</span> <span>+</span> quickMapperChecker<span>.</span>mapperId <span>+</span> <span>\"]\"</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>MappedStatement</span> mappedStatement <span>=</span> configuration<span>.</span><span>getMappedStatement</span><span>(</span>quickMapperChecker<span>.</span>mapperId<span>)</span><span>;</span>\n        <span>SqlSource</span> sqlSource <span>=</span> mappedStatement<span>.</span><span>getSqlSource</span><span>(</span><span>)</span><span>;</span>\n        <span>Object</span> namedParams <span>=</span> paramNameResolver<span>.</span><span>getNamedParams</span><span>(</span>quickMapperChecker<span>.</span>args<span>)</span><span>;</span>\n        <span>BoundSql</span> boundSql <span>=</span> mappedStatement<span>.</span><span>getBoundSql</span><span>(</span>namedParams<span>)</span><span>;</span>\n        <span>// 占位符</span>\n        <span>if</span> <span>(</span>sqlSource <span>instanceof</span> <span>RawSqlSource</span> <span>||</span> sqlSource <span>instanceof</span> <span>DynamicSqlSource</span><span>)</span> <span>{</span>\n            <span>// 占位sql，将#替换成$</span>\n            <span>String</span> sql <span>=</span> boundSql<span>.</span><span>getSql</span><span>(</span><span>)</span><span>;</span>\n            <span>List</span><span><span>&lt;</span><span>ParameterMapping</span><span>></span></span> parameterMappings <span>=</span> boundSql<span>.</span><span>getParameterMappings</span><span>(</span><span>)</span><span>;</span>\n\n            <span>XNode</span> node <span>=</span> <span>findNode</span><span>(</span><span>)</span><span>;</span>\n            <span>if</span> <span>(</span><span>Objects</span><span>.</span><span>nonNull</span><span>(</span>node<span>)</span><span>)</span> <span>{</span>\n                <span>XMLScriptBuilder</span> xmlScriptBuilder <span>=</span> <span>new</span> <span>XMLScriptBuilder</span><span>(</span>configuration<span>,</span> node<span>)</span><span>;</span>\n                <span>// 解析xml中的标签信息</span>\n                <span>Method</span> parseDynamicTags <span>=</span> <span>XMLScriptBuilder</span><span>.</span><span>class</span><span>.</span><span>getDeclaredMethod</span><span>(</span><span>\"parseDynamicTags\"</span><span>,</span> <span>XNode</span><span>.</span><span>class</span><span>)</span><span>;</span>\n                parseDynamicTags<span>.</span><span>setAccessible</span><span>(</span><span>true</span><span>)</span><span>;</span>\n                <span>MixedSqlNode</span> rootSqlNode <span>=</span> <span>(</span><span>MixedSqlNode</span><span>)</span>parseDynamicTags<span>.</span><span>invoke</span><span>(</span>xmlScriptBuilder<span>,</span> node<span>)</span><span>;</span>\n                <span>DynamicContext</span> context <span>=</span> <span>new</span> <span>DynamicContext</span><span>(</span>configuration<span>,</span> namedParams<span>)</span><span>;</span>\n                rootSqlNode<span>.</span><span>apply</span><span>(</span>context<span>)</span><span>;</span>\n                <span>// 标签信息参数解析</span>\n                <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Object</span><span>></span></span> bindings <span>=</span> context<span>.</span><span>getBindings</span><span>(</span><span>)</span><span>;</span>\n                <span>// 标签参数 + 原始参数</span>\n                <span>(</span><span>(</span><span>Map</span><span>)</span>namedParams<span>)</span><span>.</span><span>putAll</span><span>(</span>bindings<span>)</span><span>;</span>\n            <span>}</span>\n            <span>MetaObject</span> metaObject <span>=</span> configuration<span>.</span><span>newMetaObject</span><span>(</span>namedParams<span>)</span><span>;</span>\n            <span>processDate</span><span>(</span>parameterMappings<span>,</span> metaObject<span>)</span><span>;</span>\n            <span>TextSqlNode</span> textSqlNode <span>=</span> <span>new</span> <span>TextSqlNode</span><span>(</span><span>resetSql</span><span>(</span>sql<span>,</span> <span>0</span><span>,</span> parameterMappings<span>,</span> metaObject<span>)</span><span>)</span><span>;</span>\n            <span>return</span> <span>SQLUtils</span>\n                <span>.</span><span>formatMySql</span><span>(</span><span>(</span><span>new</span> <span>DynamicSqlSource</span><span>(</span>configuration<span>,</span> textSqlNode<span>)</span><span>.</span><span>getBoundSql</span><span>(</span>namedParams<span>)</span><span>.</span><span>getSql</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            <span>return</span> <span>SQLUtils</span><span>.</span><span>formatMySql</span><span>(</span>boundSql<span>.</span><span>getSql</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>private</span> <span>void</span> <span>processDate</span><span>(</span><span>List</span><span><span>&lt;</span><span>ParameterMapping</span><span>></span></span> parameterMappings<span>,</span> <span>MetaObject</span> metaObject<span>)</span> <span>{</span>\n        <span>for</span> <span>(</span><span>ParameterMapping</span> parameterMapping <span>:</span> parameterMappings<span>)</span> <span>{</span>\n            <span>String</span> property <span>=</span> parameterMapping<span>.</span><span>getProperty</span><span>(</span><span>)</span><span>;</span>\n            <span>Object</span> value <span>=</span> metaObject<span>.</span><span>getValue</span><span>(</span>property<span>)</span><span>;</span>\n            <span>if</span> <span>(</span>value <span>instanceof</span> <span>Date</span><span>)</span> <span>{</span>\n                metaObject<span>.</span><span>setValue</span><span>(</span>property<span>,</span> <span>DatePatternEnum</span><span>.</span>DATE_TIME_PATTERN<span>.</span><span>format</span><span>(</span><span>(</span><span>Date</span><span>)</span>value<span>)</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>private</span> <span>XNode</span> <span>findNode</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>if</span> <span>(</span><span>StringUtils</span><span>.</span><span>isNotBlank</span><span>(</span><span>this</span><span>.</span>mapperFile<span>)</span><span>)</span> <span>{</span>\n            <span>InputStream</span> resourceAsStream <span>=</span> <span>Resources</span><span>.</span><span>getResourceAsStream</span><span>(</span><span>this</span><span>.</span>mapperFile<span>)</span><span>;</span>\n            <span>XPathParser</span> xPathParser <span>=</span> <span>new</span> <span>XPathParser</span><span>(</span>resourceAsStream<span>)</span><span>;</span>\n            <span>XNode</span> mapperNode <span>=</span> xPathParser<span>.</span><span>evalNode</span><span>(</span><span>\"/mapper\"</span><span>)</span><span>;</span>\n            <span>List</span><span><span>&lt;</span><span>XNode</span><span>></span></span> children <span>=</span> mapperNode<span>.</span><span>getChildren</span><span>(</span><span>)</span><span>;</span>\n            <span>for</span> <span>(</span><span>XNode</span> child <span>:</span> children<span>)</span> <span>{</span>\n                <span>if</span> <span>(</span>child<span>.</span><span>getStringAttribute</span><span>(</span><span>\"id\"</span><span>)</span><span>.</span><span>equals</span><span>(</span>quickMapperChecker<span>.</span>methodName<span>)</span><span>)</span> <span>{</span>\n                    <span>MapperBuilderAssistant</span> mapperBuilderAssistant <span>=</span>\n                        <span>new</span> <span>MapperBuilderAssistant</span><span>(</span>configuration<span>,</span> quickMapperChecker<span>.</span>mapperFile<span>)</span><span>;</span>\n                    mapperBuilderAssistant<span>.</span><span>setCurrentNamespace</span><span>(</span>mapper<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n                    <span>XMLIncludeTransformer</span> includeParser <span>=</span>\n                        <span>new</span> <span>XMLIncludeTransformer</span><span>(</span>configuration<span>,</span> mapperBuilderAssistant<span>)</span><span>;</span>\n                    includeParser<span>.</span><span>applyIncludes</span><span>(</span>child<span>.</span><span>getNode</span><span>(</span><span>)</span><span>)</span><span>;</span>\n                    <span>return</span> child<span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n        <span>// \"select|insert|update|delete\"</span>\n        <span>return</span> <span>null</span><span>;</span>\n    <span>}</span><span>;</span>\n\n    <span>private</span> <span>void</span> <span>loadMappedStatementByAnnotation</span><span>(</span><span>)</span> <span>{</span>\n        <span>MybatisMapperAnnotationBuilder</span> mapperAnnotationBuilder <span>=</span>\n            <span>new</span> <span>MybatisMapperAnnotationBuilder</span><span>(</span>configuration<span>,</span> quickMapperChecker<span>.</span>mapper<span>)</span><span>;</span>\n        mapperAnnotationBuilder<span>.</span><span>parse</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>private</span> <span>void</span> <span>loadMappedStatementByMapperFile</span><span>(</span><span>String</span> mapperXmlFile<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>InputStream</span> resourceAsStream <span>=</span> <span>Resources</span><span>.</span><span>getResourceAsStream</span><span>(</span>mapperXmlFile<span>)</span><span>;</span>\n        <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>XNode</span><span>></span></span> sqlFragments <span>=</span> configuration<span>.</span><span>getSqlFragments</span><span>(</span><span>)</span><span>;</span>\n        <span>new</span> <span>XMLMapperBuilder</span><span>(</span>resourceAsStream<span>,</span> configuration<span>,</span> mapperXmlFile<span>,</span> sqlFragments<span>)</span><span>.</span><span>parse</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>printSql</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>ColorConsole</span><span>.</span><span>colorPrintln</span><span>(</span><span>\"🚀 格式化SQL:\"</span><span>)</span><span>;</span>\n        <span>ColorConsole</span><span>.</span><span>colorPrintln</span><span>(</span><span>AnsiColor</span><span>.</span>BRIGHT_MAGENTA<span>,</span> <span>\"{}\"</span><span>,</span> <span>getSql</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * sql信息进行检查\n     * \n     * @param t\n     *            泛型\n     * @return QuickMapperChecker\n     * @param &lt;T>\n     *            泛型\n     */</span>\n    <span>public</span> <span>static</span> <span><span>&lt;</span><span>T</span><span>></span></span> <span>QuickMapperPlusChecker</span> <span>analyse</span><span>(</span><span>T</span> t<span>)</span> <span>{</span>\n        <span>// 1. 调用方法</span>\n        <span>return</span> quickMapperChecker<span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 绑定mapper文件\n     * \n     * @param mapperFile\n     *            mapper文件地址\n     * @return QuickMapperChecker\n     */</span>\n    <span>public</span> <span>QuickMapperPlusChecker</span> <span>bindMapper</span><span>(</span><span>String</span> mapperFile<span>)</span> <span>{</span>\n        quickMapperChecker<span>.</span><span>setMapperFile</span><span>(</span>mapperFile<span>)</span><span>;</span>\n        <span>return</span> quickMapperChecker<span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br><span>135</span><br><span>136</span><br><span>137</span><br><span>138</span><br><span>139</span><br><span>140</span><br><span>141</span><br><span>142</span><br><span>143</span><br><span>144</span><br><span>145</span><br><span>146</span><br><span>147</span><br><span>148</span><br><span>149</span><br><span>150</span><br><span>151</span><br><span>152</span><br><span>153</span><br><span>154</span><br><span>155</span><br><span>156</span><br><span>157</span><br><span>158</span><br><span>159</span><br><span>160</span><br><span>161</span><br><span>162</span><br><span>163</span><br><span>164</span><br><span>165</span><br><span>166</span><br><span>167</span><br><span>168</span><br><span>169</span><br><span>170</span><br><span>171</span><br><span>172</span><br><span>173</span><br><span>174</span><br><span>175</span><br><span>176</span><br><span>177</span><br><span>178</span><br><span>179</span><br><span>180</span><br><span>181</span><br><span>182</span><br><span>183</span><br><span>184</span><br><span>185</span><br><span>186</span><br><span>187</span><br><span>188</span><br><span>189</span><br><span>190</span><br><span>191</span><br><span>192</span><br><span>193</span><br><span>194</span><br><span>195</span><br><span>196</span><br><span>197</span><br><span>198</span><br><span>199</span><br><span>200</span><br><span>201</span><br><span>202</span><br><span>203</span><br><span>204</span><br><span>205</span><br><span>206</span><br><span>207</span><br><span>208</span><br><span>209</span><br><span>210</span><br><span>211</span><br><span>212</span><br><span>213</span><br><span>214</span><br><span>215</span><br><span>216</span><br><span>217</span><br><span>218</span><br><span>219</span><br><span>220</span><br><span>221</span><br><span>222</span><br><span>223</span><br><span>224</span><br><span>225</span><br><span>226</span><br><span>227</span><br><span>228</span><br><span>229</span><br><span>230</span><br><span>231</span><br><span>232</span><br><span>233</span><br><span>234</span><br><span>235</span><br><span>236</span><br><span>237</span><br><span>238</span><br><span>239</span><br><span>240</span><br><span>241</span><br><span>242</span><br><span>243</span><br><span>244</span><br><span>245</span><br><span>246</span><br><span>247</span><br><span>248</span><br><span>249</span><br><span>250</span><br><span>251</span><br><span>252</span><br><span>253</span><br><span>254</span><br><span>255</span><br><span>256</span><br><span>257</span><br><span>258</span><br><span>259</span><br><span>260</span><br><span>261</span><br><span>262</span><br><span>263</span><br><span>264</span><br><span>265</span><br><span>266</span><br><span>267</span><br><span>268</span><br><span>269</span><br><span>270</span><br><span>271</span><br><span>272</span><br><span>273</span><br><span>274</span><br><span>275</span><br><span>276</span><br><span>277</span><br><span>278</span><br><span>279</span><br><span>280</span><br><span>281</span><br><span>282</span><br><span>283</span><br><span>284</span><br><span>285</span><br><span>286</span><br><span>287</span><br></div></div>",
      "image": "https://img.springlearn.cn/blog/learn_1651310469000.png",
      "date_published": "2022-05-08T04:06:59.000Z",
      "date_modified": "2022-07-12T12:38:40.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Mybatis"
      ]
    },
    {
      "title": "第07篇:Mybatis缓存装饰器",
      "url": "https://java.springlearn.cn/learn/mybatis/Mybatis%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/",
      "id": "https://java.springlearn.cn/learn/mybatis/Mybatis%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/learn_1648571408000.png\" alt=\"\" loading=\"lazy\"></p>\n<div><p>提示</p>\n<p>MyBatis 对缓存的设计是非常巧妙的。花样很多,但却不是真的花样。因为<code>Mybatis</code>只是对 <code>Map</code>数据结构的封装, 但是却实现了很多挺好用的能力。\n如果单单从设计模式上的角度来,其实就是典型的装饰器模式, 装饰器模式其实并不难,所以我们不讲设计模式, 本篇文章我们来看看<code>Mybatils</code> 缓存设计巧妙的点。</p>\n</div>\n<p><a href=\"https://mybatis.net.cn/sqlmap-xml.html#cache\" target=\"_blank\" rel=\"noopener noreferrer\">官方文档</a></p>\n<p>下面通过简单的代码review来分析下这11个缓存类设计的巧妙点。（因为是对博客重构,历史图片就没有补充,图上只有10个,请讲究下）</p>\n<hr>\n<h2 id=\"一、模式分析\"> 一、模式分析</h2>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1648571612000.png\" alt=\"\" loading=\"lazy\">\n从目录就很清晰看出,核心就是<code>impl</code> 包下面只有一个,其他都是装饰器模式，在\n<code>decorators</code> 包下</p>\n<div><p>提示</p>\n<p>其实上面就是<code>Mybatis</code> 关于 <code>Cache</code> 的核心实现,其实看到这里还没有很多知识点. 那么我们从中能学到什么呢? 如果真要找一条学习的点,那么就是:</p>\n<p>设计要面向接口设计，而不是具体实现。 这样当我们要重写 <code>Cache</code> ，比如说我们不想底层用 <code>HashMap</code> 来实现了,其实我们只要实现一下 <code>Cache</code> 接口，然后替换掉<code>PerpetualCache</code>就可以了。对于使用者其实并不感知。</p>\n</div>\n<h2 id=\"_1-1-cache\"> 1.1 Cache</h2>\n<p>接口设计没有什么好讲的，提供获取和添加方法，跟Map接口一样。 本篇我们要一起Review的类都会实现该接口的。</p>\n<p>(这句话简直就是废话,大佬勿喷,就是简单提醒。意思就是其实代码不难)</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>Cache</span> <span>{</span>\n\n  <span>String</span> <span>getId</span><span>(</span><span>)</span><span>;</span>\n  \n  <span>void</span> <span>putObject</span><span>(</span><span>Object</span> key<span>,</span> <span>Object</span> value<span>)</span><span>;</span>\n  \n  <span>Object</span> <span>getObject</span><span>(</span><span>Object</span> key<span>)</span><span>;</span>\n\n  <span>Object</span> <span>removeObject</span><span>(</span><span>Object</span> key<span>)</span><span>;</span>\n\n  <span>void</span> <span>clear</span><span>(</span><span>)</span><span>;</span>\n\n  <span>int</span> <span>getSize</span><span>(</span><span>)</span><span>;</span>\n  \n  <span>ReadWriteLock</span> <span>getReadWriteLock</span><span>(</span><span>)</span><span>;</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h2 id=\"_1-2-perpetualcache\"> 1.2 PerpetualCache</h2>\n<p>这个类就是 <code>Mybatis</code> 缓存最底层的设计, 看一下就知道其实是对 <code>Map</code> 的封装。\n其实我们只要知道他是简单的 <code>HashMap</code> 的封装就可以了。因为代码实战是太简单了,没啥分析的。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>PerpetualCache</span> <span>implements</span> <span>Cache</span> <span>{</span>\n  <span>// 唯一标识</span>\n  <span>private</span> <span>final</span> <span>String</span> id<span>;</span>\n  <span>// 就是一个HashMap结构</span>\n  <span>private</span> <span>Map</span><span><span>&lt;</span><span>Object</span><span>,</span> <span>Object</span><span>></span></span> cache <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>Object</span><span>,</span> <span>Object</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n\n  <span>public</span> <span>PerpetualCache</span><span>(</span><span>String</span> id<span>)</span> <span>{</span>\n    <span>this</span><span>.</span>id <span>=</span> id<span>;</span>\n  <span>}</span>\n\n  <span>@Override</span>\n  <span>public</span> <span>String</span> <span>getId</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> id<span>;</span>\n  <span>}</span>\n\n  <span>@Override</span>\n  <span>public</span> <span>int</span> <span>getSize</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> cache<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>@Override</span>\n  <span>public</span> <span>void</span> <span>putObject</span><span>(</span><span>Object</span> key<span>,</span> <span>Object</span> value<span>)</span> <span>{</span>\n    cache<span>.</span><span>put</span><span>(</span>key<span>,</span> value<span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>@Override</span>\n  <span>public</span> <span>Object</span> <span>getObject</span><span>(</span><span>Object</span> key<span>)</span> <span>{</span>\n    <span>return</span> cache<span>.</span><span>get</span><span>(</span>key<span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>@Override</span>\n  <span>public</span> <span>Object</span> <span>removeObject</span><span>(</span><span>Object</span> key<span>)</span> <span>{</span>\n    <span>return</span> cache<span>.</span><span>remove</span><span>(</span>key<span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>@Override</span>\n  <span>public</span> <span>void</span> <span>clear</span><span>(</span><span>)</span> <span>{</span>\n    cache<span>.</span><span>clear</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span>\n  <span>// 基本没啥用,外层谁要用,谁重写</span>\n  <span>@Override</span>\n  <span>public</span> <span>ReadWriteLock</span> <span>getReadWriteLock</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>null</span><span>;</span>\n  <span>}</span>\n\n  <span>@Override</span>\n  <span>public</span> <span>boolean</span> <span>equals</span><span>(</span><span>Object</span> o<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span><span>getId</span><span>(</span><span>)</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>\n      <span>throw</span> <span>new</span> <span>CacheException</span><span>(</span><span>\"Cache instances require an ID.\"</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>if</span> <span>(</span><span>this</span> <span>==</span> o<span>)</span> <span>{</span>\n      <span>return</span> <span>true</span><span>;</span>\n    <span>}</span>\n    <span>if</span> <span>(</span><span>!</span><span>(</span>o <span>instanceof</span> <span>Cache</span><span>)</span><span>)</span> <span>{</span>\n      <span>return</span> <span>false</span><span>;</span>\n    <span>}</span>\n\n    <span>Cache</span> otherCache <span>=</span> <span>(</span><span>Cache</span><span>)</span> o<span>;</span>\n    <span>return</span> <span>getId</span><span>(</span><span>)</span><span>.</span><span>equals</span><span>(</span>otherCache<span>.</span><span>getId</span><span>(</span><span>)</span><span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>@Override</span>\n  <span>public</span> <span>int</span> <span>hashCode</span><span>(</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span><span>getId</span><span>(</span><span>)</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>\n      <span>throw</span> <span>new</span> <span>CacheException</span><span>(</span><span>\"Cache instances require an ID.\"</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>return</span> <span>getId</span><span>(</span><span>)</span><span>.</span><span>hashCode</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span>\n\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br></div></div><h2 id=\"二、开始重头戏\"> 二、开始重头戏</h2>\n<p>从这里我们主要一起看下,代码设计的巧妙之处,一个一个研究下,以下这10个类。看 <code>Mybatis</code> 是如何巧妙设计的。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1648571791000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_2-1-blockingcache\"> 2.1 BlockingCache</h2>\n<p>BlockingCache是一个简单和低效的<code>Cache</code>的装饰器,我们主要看几个重要方法。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>BlockingCache</span> <span>implements</span> <span>Cache</span> <span>{</span>\n\n  <span>private</span> <span>long</span> timeout<span>;</span>\n  <span>//实现Cache接口的缓存对象</span>\n  <span>private</span> <span>final</span> <span>Cache</span> delegate<span>;</span>\n  <span>//对每个key生成一个锁对象</span>\n  <span>private</span> <span>final</span> <span>ConcurrentHashMap</span><span><span>&lt;</span><span>Object</span><span>,</span> <span>ReentrantLock</span><span>></span></span> locks<span>;</span>\n\n  <span>public</span> <span>BlockingCache</span><span>(</span><span>Cache</span> delegate<span>)</span> <span>{</span>\n    <span>this</span><span>.</span>delegate <span>=</span> delegate<span>;</span>\n    <span>this</span><span>.</span>locks <span>=</span> <span>new</span> <span>ConcurrentHashMap</span><span><span>&lt;</span><span>Object</span><span>,</span> <span>ReentrantLock</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>@Override</span>\n  <span>public</span> <span>String</span> <span>getId</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> delegate<span>.</span><span>getId</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>@Override</span>\n  <span>public</span> <span>int</span> <span>getSize</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> delegate<span>.</span><span>getSize</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>@Override</span>\n  <span>public</span> <span>void</span> <span>putObject</span><span>(</span><span>Object</span> key<span>,</span> <span>Object</span> value<span>)</span> <span>{</span>\n    <span>try</span> <span>{</span>\n      delegate<span>.</span><span>putObject</span><span>(</span>key<span>,</span> value<span>)</span><span>;</span>\n    <span>}</span> <span>finally</span> <span>{</span>\n      <span>//释放锁。 为什么不加锁? 所以get和put是组合使用的，当get加锁,如果没有就查询数据库然后put释放锁，然后其他线程就可以直接用缓存数据了。</span>\n      <span>releaseLock</span><span>(</span>key<span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n\n  <span>@Override</span>\n  <span>public</span> <span>Object</span> <span>getObject</span><span>(</span><span>Object</span> key<span>)</span> <span>{</span>\n    <span>//1. 当要获取一个key,首先对key进行加锁操作,如果没有锁就加一个锁,有锁就直接锁</span>\n    <span>acquireLock</span><span>(</span>key<span>)</span><span>;</span>\n    <span>Object</span> value <span>=</span> delegate<span>.</span><span>getObject</span><span>(</span>key<span>)</span><span>;</span>\n    <span>if</span> <span>(</span>value <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n      <span>//2. 如果缓存命中,就直接解锁</span>\n      <span>releaseLock</span><span>(</span>key<span>)</span><span>;</span>\n    <span>}</span>\n    <span>//3. 当value=null, 就是说没有命中缓存,那么这个key就会被锁住,其他线程进来都要等待</span>\n    <span>return</span> value<span>;</span>\n  <span>}</span>\n\n  <span>@Override</span>\n  <span>public</span> <span>Object</span> <span>removeObject</span><span>(</span><span>Object</span> key<span>)</span> <span>{</span>\n    <span>// 移除key的时候,顺便清楚缓存key的锁对象</span>\n    <span>releaseLock</span><span>(</span>key<span>)</span><span>;</span>\n    <span>return</span> <span>null</span><span>;</span>\n  <span>}</span>\n\n  <span>@Override</span>\n  <span>public</span> <span>void</span> <span>clear</span><span>(</span><span>)</span> <span>{</span>\n    delegate<span>.</span><span>clear</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>@Override</span>\n  <span>public</span> <span>ReadWriteLock</span> <span>getReadWriteLock</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>null</span><span>;</span>\n  <span>}</span>\n  \n  <span>private</span> <span>ReentrantLock</span> <span>getLockForKey</span><span>(</span><span>Object</span> key<span>)</span> <span>{</span>\n    <span>ReentrantLock</span> lock <span>=</span> <span>new</span> <span>ReentrantLock</span><span>(</span><span>)</span><span>;</span>\n    <span>ReentrantLock</span> previous <span>=</span> locks<span>.</span><span>putIfAbsent</span><span>(</span>key<span>,</span> lock<span>)</span><span>;</span>\n    <span>//如果key对应的锁存在就返回,没有就创建一个新的</span>\n    <span>return</span> previous <span>==</span> <span>null</span> <span>?</span> lock <span>:</span> previous<span>;</span>\n  <span>}</span>\n  \n  <span>private</span> <span>void</span> <span>acquireLock</span><span>(</span><span>Object</span> key<span>)</span> <span>{</span>\n    <span>Lock</span> lock <span>=</span> <span>getLockForKey</span><span>(</span>key<span>)</span><span>;</span>\n    <span>//1. 如果设置超时时间,就可以等待timeout时间(如果超时了报错)</span>\n    <span>if</span> <span>(</span>timeout <span>></span> <span>0</span><span>)</span> <span>{</span>\n      <span>try</span> <span>{</span>\n        <span>boolean</span> acquired <span>=</span> lock<span>.</span><span>tryLock</span><span>(</span>timeout<span>,</span> <span>TimeUnit</span><span>.</span>MILLISECONDS<span>)</span><span>;</span>\n        <span>if</span> <span>(</span><span>!</span>acquired<span>)</span> <span>{</span>\n          <span>throw</span> <span>new</span> <span>CacheException</span><span>(</span><span>\"Couldn't get a lock in \"</span> <span>+</span> timeout <span>+</span> <span>\" for the key \"</span> <span>+</span>  key <span>+</span> <span>\" at the cache \"</span> <span>+</span> delegate<span>.</span><span>getId</span><span>(</span><span>)</span><span>)</span><span>;</span>  \n        <span>}</span>\n      <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>\n        <span>throw</span> <span>new</span> <span>CacheException</span><span>(</span><span>\"Got interrupted while trying to acquire lock for key \"</span> <span>+</span> key<span>,</span> e<span>)</span><span>;</span>\n      <span>}</span>\n    <span>}</span> <span>else</span> <span>{</span>\n      <span>//2. 如果没有设置,直接就加锁(如果这个锁已经被人用了,那么就一直阻塞这里。等待上一个释放锁)</span>\n      lock<span>.</span><span>lock</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n  \n  <span>private</span> <span>void</span> <span>releaseLock</span><span>(</span><span>Object</span> key<span>)</span> <span>{</span>\n    <span>ReentrantLock</span> lock <span>=</span> locks<span>.</span><span>get</span><span>(</span>key<span>)</span><span>;</span>\n    <span>if</span> <span>(</span>lock<span>.</span><span>isHeldByCurrentThread</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n      lock<span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n\n  <span>public</span> <span>long</span> <span>getTimeout</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> timeout<span>;</span>\n  <span>}</span>\n\n  <span>public</span> <span>void</span> <span>setTimeout</span><span>(</span><span>long</span> timeout<span>)</span> <span>{</span>\n    <span>this</span><span>.</span>timeout <span>=</span> timeout<span>;</span>\n  <span>}</span>  \n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br></div></div><p><strong>建议</strong>看代码注释</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>acquireLock</td>\n<td>加锁操作</td>\n</tr>\n<tr>\n<td>getObject</td>\n<td>进来加锁,如果缓存存在就释放锁,不存在就不释放锁。</td>\n</tr>\n<tr>\n<td>putObject</td>\n<td>添加元素并释放锁</td>\n</tr>\n<tr>\n<td>removeObject</td>\n<td>移除key的时候,顺便清楚缓存key的锁对象</td>\n</tr>\n<tr>\n<td>getLockForKey</td>\n<td>如果key对应的锁存在就返回,没有就创建一个新的</td>\n</tr>\n</tbody>\n</table>\n<p><strong>思考</strong></p>\n<ol>\n<li>这个因为每次key请求都会加lock真的会很慢吗? 我们举两种场景。</li>\n</ol>\n<p>注意这个加lock并不是对get方法加lock,而是对每个要get的key来加lock。</p>\n<p><strong>场景一:</strong> 试想一种场景,当有10个线程同时从数据库查询一个key为123的数据时候，当第一个线程来首先从cache中读取时候，这个时候其他九个线程是会阻塞的，因为这个key已经被加lock了。当第一个线程get这个key完成时候，其他线程才能继续走。这种场景来说是不好的，</p>\n<p><strong>场景二:</strong> 但是当第一个线程来发现cache里面没有数据这个时候其他线程会阻塞，而第一个线程会从db中查询，然后在put到cache里面。这样其他9个线程就不需要在去查询db了,就减少了9次db查询。</p>\n<h2 id=\"_2-2-fifocache\"> 2.2 FifoCache</h2>\n<p><strong>FIFO( First Input First Output),简单说就是指先进先出</strong></p>\n<p>如何实现先进先出呢? 其实非常简单,当put时候,先判断是否需要执行淘汰策略,如果要执行淘汰,就 移除先进来的。 直接通过 <code>Deque</code> API 来实现先进先出。</p>\n<div><pre><code>  <span>private</span> <span>final</span> <span>Cache</span> delegate<span>;</span>\n  <span>private</span> <span>final</span> <span>Deque</span><span><span>&lt;</span><span>Object</span><span>></span></span> keyList<span>;</span>\n  <span>private</span> <span>int</span> size<span>;</span>\n\n  <span>public</span> <span>FifoCache</span><span>(</span><span>Cache</span> delegate<span>)</span> <span>{</span>\n    <span>this</span><span>.</span>delegate <span>=</span> delegate<span>;</span>\n    <span>this</span><span>.</span>keyList <span>=</span> <span>new</span> <span>LinkedList</span><span><span>&lt;</span><span>Object</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n    <span>this</span><span>.</span>size <span>=</span> <span>1024</span><span>;</span>\n  <span>}</span>\n\n<span>@Override</span>\n  <span>public</span> <span>void</span> <span>putObject</span><span>(</span><span>Object</span> key<span>,</span> <span>Object</span> value<span>)</span> <span>{</span>\n      <span>//1. put时候就判断是否需要淘汰</span>\n    <span>cycleKeyList</span><span>(</span>key<span>)</span><span>;</span>\n    delegate<span>.</span><span>putObject</span><span>(</span>key<span>,</span> value<span>)</span><span>;</span>\n  <span>}</span>\n  <span>private</span> <span>void</span> <span>cycleKeyList</span><span>(</span><span>Object</span> key<span>)</span> <span>{</span>\n    keyList<span>.</span><span>addLast</span><span>(</span>key<span>)</span><span>;</span>\n    <span>//1. size默认如果大于1024就开始淘汰</span>\n    <span>if</span> <span>(</span>keyList<span>.</span><span>size</span><span>(</span><span>)</span> <span>></span> size<span>)</span> <span>{</span>\n      <span>//2. 利用Deque队列移除第一个。</span>\n      <span>Object</span> oldestKey <span>=</span> keyList<span>.</span><span>removeFirst</span><span>(</span><span>)</span><span>;</span>\n      delegate<span>.</span><span>removeObject</span><span>(</span>oldestKey<span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h2 id=\"_2-3-loggingcache\"> 2.3 LoggingCache</h2>\n<p>从名字上看就是跟日志有关， <code>LoggingCache</code> 会在 <code>debug</code>级别下把缓存命中率给统计出来,然后通过日志系统打印出来。</p>\n<div><pre><code><span>public</span> <span>Object</span> <span>getObject</span><span>(</span><span>Object</span> key<span>)</span> <span>{</span>\n    requests<span>++</span><span>;</span>\n    <span>final</span> <span>Object</span> value <span>=</span> delegate<span>.</span><span>getObject</span><span>(</span>key<span>)</span><span>;</span>\n    <span>if</span> <span>(</span>value <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n      hits<span>++</span><span>;</span>\n    <span>}</span>\n    <span>//1. 打印缓存命中率</span>\n    <span>if</span> <span>(</span>log<span>.</span><span>isDebugEnabled</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n      log<span>.</span><span>debug</span><span>(</span><span>\"Cache Hit Ratio [\"</span> <span>+</span> <span>getId</span><span>(</span><span>)</span> <span>+</span> <span>\"]: \"</span> <span>+</span> <span>getHitRatio</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>return</span> value<span>;</span>\n  <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>除此之外没有什么其他功能。我们主要看下他是如何统计缓存命中率的。其实很简单。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>LoggingCache</span> <span>implements</span> <span>Cache</span> <span>{</span>\n\n  <span>private</span> <span>final</span> <span>Log</span> log<span>;</span>\n  <span>private</span> <span>final</span> <span>Cache</span> delegate<span>;</span>\n  <span>//1. 总请求次数</span>\n  <span>protected</span> <span>int</span> requests <span>=</span> <span>0</span><span>;</span>\n  <span>//2. 命中次数</span>\n  <span>protected</span> <span>int</span> hits <span>=</span> <span>0</span><span>;</span>\n \n  <span>.</span><span>.</span><span>.</span>\n<span>}</span>  \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>在get请求时候无论是否命中,都自增总请求次数( <code>request</code> ), 当get命中时候自增命中次数( <code>hits</code> )</p>\n<div><pre><code><span>public</span> <span>Object</span> <span>getObject</span><span>(</span><span>Object</span> key<span>)</span> <span>{</span>\n    <span>//1. 无论是否命中,都自增总请求次数( `request` )</span>\n    requests<span>++</span><span>;</span>\n    <span>final</span> <span>Object</span> value <span>=</span> delegate<span>.</span><span>getObject</span><span>(</span>key<span>)</span><span>;</span>\n    <span>if</span> <span>(</span>value <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n      <span>//2. get命中时候自增命中次数( `hits` )</span>\n      hits<span>++</span><span>;</span>\n    <span>}</span>\n    <span>if</span> <span>(</span>log<span>.</span><span>isDebugEnabled</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n      log<span>.</span><span>debug</span><span>(</span><span>\"Cache Hit Ratio [\"</span> <span>+</span> <span>getId</span><span>(</span><span>)</span> <span>+</span> <span>\"]: \"</span> <span>+</span> <span>getHitRatio</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>return</span> value<span>;</span>\n  <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>然后我们看命中率怎么算 <code>getHitRatio()</code></p>\n<p><code>命中率 = 命中次数 / 总请求次数</code></p>\n<div><pre><code> <span>private</span> <span>double</span> <span>getHitRatio</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>(</span><span>double</span><span>)</span> hits <span>/</span> <span>(</span><span>double</span><span>)</span> requests<span>;</span>\n  <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"_2-4-lrucache\"> 2.4 LruCache</h2>\n<p>LRU是Least Recently Used的缩写，即最近最少使用。</p>\n<p>首先我们看如何实现 <code>LRU</code> 策略。\n它其实就是利用 <code>LinkedHashMap</code>来实现 <code>LRU</code> 策略, <code>JDK</code> 提供的 <code>LinkedHashMap</code>天然就支持 <code>LRU</code> 策略。\n<code>LinkedHashMap</code> 有一个特点如果开启LRU策略后,每次获取到数据后,都会把数据放到最后一个节点，这样第一个节点肯定是最近最少用的元素。</p>\n<div><pre><code><span>public</span> <span>V</span> <span>get</span><span>(</span><span>Object</span> key<span>)</span> <span>{</span>\n        <span>Node</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> e<span>;</span>\n        <span>if</span> <span>(</span><span>(</span>e <span>=</span> <span>getNode</span><span>(</span><span>hash</span><span>(</span>key<span>)</span><span>,</span> key<span>)</span><span>)</span> <span>==</span> <span>null</span><span>)</span>\n            <span>return</span> <span>null</span><span>;</span>\n        <span>//1. 判断是否开始LRU策略</span>\n        <span>if</span> <span>(</span>accessOrder<span>)</span>\n            <span>//2. 开启就往后面放</span>\n            <span>afterNodeAccess</span><span>(</span>e<span>)</span><span>;</span>\n        <span>return</span> e<span>.</span>value<span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p><img src=\"https://img-blog.csdnimg.cn/2019122316004441.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" loading=\"lazy\">\n构造中先声明LRU淘汰策略,当size()大于构造中声明的1024就可以在每次\nputObject时候将要淘汰的移除掉。这点非常的巧妙,不知道你学习到了没 ?</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20191223160143543.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" loading=\"lazy\"></p>\n<h2 id=\"_2-5-scheduledcache\"> 2.5 ScheduledCache</h2>\n<p>定时删除,设计巧妙,可以借鉴。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>ScheduledCache</span> <span>implements</span> <span>Cache</span> <span>{</span>\n\n  <span>private</span> <span>final</span> <span>Cache</span> delegate<span>;</span>\n  <span>protected</span> <span>long</span> clearInterval<span>;</span>\n  <span>protected</span> <span>long</span> lastClear<span>;</span>\n\n  <span>public</span> <span>ScheduledCache</span><span>(</span><span>Cache</span> delegate<span>)</span> <span>{</span>\n    <span>this</span><span>.</span>delegate <span>=</span> delegate<span>;</span>\n    <span>//1. 指定多久清理一次缓存</span>\n    <span>this</span><span>.</span>clearInterval <span>=</span> <span>60</span> <span>*</span> <span>60</span> <span>*</span> <span>1000</span><span>;</span> <span>// 1 hour</span>\n    <span>//2. 设置初始值</span>\n    <span>this</span><span>.</span>lastClear <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>public</span> <span>void</span> <span>setClearInterval</span><span>(</span><span>long</span> clearInterval<span>)</span> <span>{</span>\n    <span>this</span><span>.</span>clearInterval <span>=</span> clearInterval<span>;</span>\n  <span>}</span>\n\n  <span>@Override</span>\n  <span>public</span> <span>String</span> <span>getId</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> delegate<span>.</span><span>getId</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>@Override</span>\n  <span>public</span> <span>int</span> <span>getSize</span><span>(</span><span>)</span> <span>{</span>\n    <span>clearWhenStale</span><span>(</span><span>)</span><span>;</span>\n    <span>return</span> delegate<span>.</span><span>getSize</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>@Override</span>\n  <span>public</span> <span>void</span> <span>putObject</span><span>(</span><span>Object</span> key<span>,</span> <span>Object</span> object<span>)</span> <span>{</span>\n    <span>clearWhenStale</span><span>(</span><span>)</span><span>;</span>\n    delegate<span>.</span><span>putObject</span><span>(</span>key<span>,</span> object<span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>@Override</span>\n  <span>public</span> <span>Object</span> <span>getObject</span><span>(</span><span>Object</span> key<span>)</span> <span>{</span>\n    <span>return</span> <span>clearWhenStale</span><span>(</span><span>)</span> <span>?</span> <span>null</span> <span>:</span> delegate<span>.</span><span>getObject</span><span>(</span>key<span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>@Override</span>\n  <span>public</span> <span>Object</span> <span>removeObject</span><span>(</span><span>Object</span> key<span>)</span> <span>{</span>\n    <span>clearWhenStale</span><span>(</span><span>)</span><span>;</span>\n    <span>return</span> delegate<span>.</span><span>removeObject</span><span>(</span>key<span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>@Override</span>\n  <span>public</span> <span>void</span> <span>clear</span><span>(</span><span>)</span> <span>{</span>\n    <span>//1. 记录最近删除一次时间戳</span>\n    lastClear <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>\n    <span>//2. 清理掉缓存信息</span>\n    delegate<span>.</span><span>clear</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>@Override</span>\n  <span>public</span> <span>ReadWriteLock</span> <span>getReadWriteLock</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>null</span><span>;</span>\n  <span>}</span>\n\n  <span>@Override</span>\n  <span>public</span> <span>int</span> <span>hashCode</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> delegate<span>.</span><span>hashCode</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>@Override</span>\n  <span>public</span> <span>boolean</span> <span>equals</span><span>(</span><span>Object</span> obj<span>)</span> <span>{</span>\n    <span>return</span> delegate<span>.</span><span>equals</span><span>(</span>obj<span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>private</span> <span>boolean</span> <span>clearWhenStale</span><span>(</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span><span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span> <span>-</span> lastClear <span>></span> clearInterval<span>)</span> <span>{</span>\n      <span>clear</span><span>(</span><span>)</span><span>;</span>\n      <span>return</span> <span>true</span><span>;</span>\n    <span>}</span>\n    <span>return</span> <span>false</span><span>;</span>\n  <span>}</span>\n\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br></div></div><p><strong>核心代码</strong></p>\n<ol>\n<li>构造中指定多久清理一次缓存(1小时)</li>\n<li>设置初始值</li>\n<li><code>clearWhenStale()</code> 核心方法</li>\n<li>然后在每个方法中调用一次这段代码,判断是否需要清理。</li>\n</ol>\n<div><pre><code><span>private</span> <span>boolean</span> <span>clearWhenStale</span><span>(</span><span>)</span> <span>{</span>\n    <span>//1. 当前时间 - 最后清理时间,如果大于定时删除时间,说明要执行清理了。</span>\n    <span>if</span> <span>(</span><span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span> <span>-</span> lastClear <span>></span> clearInterval<span>)</span> <span>{</span>\n      <span>clear</span><span>(</span><span>)</span><span>;</span>\n      <span>return</span> <span>true</span><span>;</span>\n    <span>}</span>\n    <span>return</span> <span>false</span><span>;</span>\n  <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id=\"_2-6-serializedcache\"> 2.6 SerializedCache</h2>\n<p>从名字上看就是支持序列化的缓存,那么我们就要问了，为啥要支持序列化?</p>\n<p><strong>为啥要支持序列化?</strong></p>\n<p>因为如果多个用户同时共享一个数据对象时，同时都引用这一个数据对象。如果有用户修改了这个数据对象，那么其他用户拿到的就是已经修改过的对象，这样就是出现了线程不安全。</p>\n<p><strong>如何解决这种问题</strong></p>\n<ol>\n<li>加锁当一个线程在操作时候,其他线程不允许操作</li>\n<li>新生成一个对象,这样多个线程获取到的数据就不是一个对象了。</li>\n</ol>\n<p><strong>只看一下核心代码</strong></p>\n<ol>\n<li><code>putObject</code> 将对象序列化成<code>byte[]</code></li>\n<li><code>getObject</code> 将<code>byte[]</code>反序列化成对象</li>\n</ol>\n<div><pre><code><span>public</span> <span>void</span> <span>putObject</span><span>(</span><span>Object</span> key<span>,</span> <span>Object</span> object<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>object <span>==</span> <span>null</span> <span>||</span> object <span>instanceof</span> <span>Serializable</span><span>)</span> <span>{</span>\n      <span>//1. 将对象序列化成byte[]</span>\n      delegate<span>.</span><span>putObject</span><span>(</span>key<span>,</span> <span>serialize</span><span>(</span><span>(</span><span>Serializable</span><span>)</span> object<span>)</span><span>)</span><span>;</span>\n    <span>}</span> <span>else</span> <span>{</span>\n      <span>throw</span> <span>new</span> <span>CacheException</span><span>(</span><span>\"SharedCache failed to make a copy of a non-serializable object: \"</span> <span>+</span> object<span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n<span>private</span> <span>byte</span><span>[</span><span>]</span> <span>serialize</span><span>(</span><span>Serializable</span> value<span>)</span> <span>{</span>\n    <span>try</span> <span>{</span>\n      <span>ByteArrayOutputStream</span> bos <span>=</span> <span>new</span> <span>ByteArrayOutputStream</span><span>(</span><span>)</span><span>;</span>\n      <span>ObjectOutputStream</span> oos <span>=</span> <span>new</span> <span>ObjectOutputStream</span><span>(</span>bos<span>)</span><span>;</span>\n      oos<span>.</span><span>writeObject</span><span>(</span>value<span>)</span><span>;</span>\n      oos<span>.</span><span>flush</span><span>(</span><span>)</span><span>;</span>\n      oos<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n      <span>return</span> bos<span>.</span><span>toByteArray</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n      <span>throw</span> <span>new</span> <span>CacheException</span><span>(</span><span>\"Error serializing object.  Cause: \"</span> <span>+</span> e<span>,</span> e<span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n\n <span>public</span> <span>Object</span> <span>getObject</span><span>(</span><span>Object</span> key<span>)</span> <span>{</span>\n    <span>Object</span> object <span>=</span> delegate<span>.</span><span>getObject</span><span>(</span>key<span>)</span><span>;</span>\n    <span>//1. 获取时候将byte[]反序列化成对象</span>\n    <span>return</span> object <span>==</span> <span>null</span> <span>?</span> <span>null</span> <span>:</span> <span>deserialize</span><span>(</span><span>(</span><span>byte</span><span>[</span><span>]</span><span>)</span> object<span>)</span><span>;</span>\n  <span>}</span>\n  <span>private</span> <span>Serializable</span> <span>deserialize</span><span>(</span><span>byte</span><span>[</span><span>]</span> value<span>)</span> <span>{</span>\n    <span>Serializable</span> result<span>;</span>\n    <span>try</span> <span>{</span>\n      <span>ByteArrayInputStream</span> bis <span>=</span> <span>new</span> <span>ByteArrayInputStream</span><span>(</span>value<span>)</span><span>;</span>\n      <span>ObjectInputStream</span> ois <span>=</span> <span>new</span> <span>CustomObjectInputStream</span><span>(</span>bis<span>)</span><span>;</span>\n      result <span>=</span> <span>(</span><span>Serializable</span><span>)</span> ois<span>.</span><span>readObject</span><span>(</span><span>)</span><span>;</span>\n      ois<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n      <span>throw</span> <span>new</span> <span>CacheException</span><span>(</span><span>\"Error deserializing object.  Cause: \"</span> <span>+</span> e<span>,</span> e<span>)</span><span>;</span>\n    <span>}</span>\n    <span>return</span> result<span>;</span>\n  <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br></div></div><p>这种就类似于深拷贝,因为简单的浅拷贝会出现线程安全问题,而这种办法,因为字节在被反序列化时，会在创建一个新的对象，这个新的对象的数据和原来对象的数据一模一样。所以说跟深拷贝一样。</p>\n<p><a href=\"https://blog.springlearn.cn/posts/43446/\" target=\"_blank\" rel=\"noopener noreferrer\">Java开发之深浅拷贝</a></p>\n<h2 id=\"_2-7-softcache\"> 2.7 SoftCache</h2>\n<p>从名字上看,Soft其实就是软引用。软引用就是如果内存够,GC就不会清理内存,只有当内存不够用了会出现OOM时候,才开始执行GC清理。</p>\n<p>如果要看明白这个源码首先要先了解一点垃圾回收,垃圾回收的前提是还有没有别的地方在引用这个对象了。如果没有别的地方在引用就可以回收了。\n本类中为了阻止被回收所以声明了一个变量<code>hardLinksToAvoidGarbageCollection</code>，\n也指定了一个将要被回收的垃圾队列<code>queueOfGarbageCollectedEntries</code> 。</p>\n<p>这个类的主要内容是当缓存value已经被垃圾回收了，就自动把key也清理。</p>\n<p><code>Mybatis</code> 在实际中并没有使用这个类。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>SoftCache</span> <span>implements</span> <span>Cache</span> <span>{</span>\n  <span>private</span> <span>final</span> <span>Deque</span><span><span>&lt;</span><span>Object</span><span>></span></span> hardLinksToAvoidGarbageCollection<span>;</span>\n  <span>private</span> <span>final</span> <span>ReferenceQueue</span><span><span>&lt;</span><span>Object</span><span>></span></span> queueOfGarbageCollectedEntries<span>;</span>\n  <span>private</span> <span>final</span> <span>Cache</span> delegate<span>;</span>\n  <span>private</span> <span>int</span> numberOfHardLinks<span>;</span>\n\n  <span>public</span> <span>SoftCache</span><span>(</span><span>Cache</span> delegate<span>)</span> <span>{</span>\n    <span>this</span><span>.</span>delegate <span>=</span> delegate<span>;</span>\n    <span>this</span><span>.</span>numberOfHardLinks <span>=</span> <span>256</span><span>;</span>\n    <span>this</span><span>.</span>hardLinksToAvoidGarbageCollection <span>=</span> <span>new</span> <span>LinkedList</span><span><span>&lt;</span><span>Object</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n    <span>this</span><span>.</span>queueOfGarbageCollectedEntries <span>=</span> <span>new</span> <span>ReferenceQueue</span><span><span>&lt;</span><span>Object</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>  \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p><strong>先看下变量声明</strong></p>\n<p><code>hard Links To Avoid Garbage Collection</code>\n硬连接,避免垃圾收集\n<code>queue Of Garbage Collected Entries</code>\n垃圾要收集的队列\n<code>number Of Hard Links</code>\n硬连接数量</p>\n<div><pre><code><span>@Override</span>\n  <span>public</span> <span>void</span> <span>putObject</span><span>(</span><span>Object</span> key<span>,</span> <span>Object</span> value<span>)</span> <span>{</span>\n    <span>//1. 清除已经被垃圾回收的key</span>\n    <span>removeGarbageCollectedItems</span><span>(</span><span>)</span><span>;</span>\n    <span>//2. 注意看SoftEntry(),声明一个SoftEnty对象,指定垃圾回收后要进入的队列</span>\n    <span>//3. 当SoftEntry中数据要被清理,会添加到类中声明的垃圾要收集的队列中</span>\n    delegate<span>.</span><span>putObject</span><span>(</span>key<span>,</span> <span>new</span> <span>SoftEntry</span><span>(</span>key<span>,</span> value<span>,</span> queueOfGarbageCollectedEntries<span>)</span><span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>@Override</span>\n  <span>public</span> <span>Object</span> <span>getObject</span><span>(</span><span>Object</span> key<span>)</span> <span>{</span>\n    <span>Object</span> result <span>=</span> <span>null</span><span>;</span>\n    <span>@SuppressWarnings</span><span>(</span><span>\"unchecked\"</span><span>)</span> <span>// assumed delegate cache is totally managed by this cache</span>\n    <span>SoftReference</span><span><span>&lt;</span><span>Object</span><span>></span></span> softReference <span>=</span> <span>(</span><span>SoftReference</span><span><span>&lt;</span><span>Object</span><span>></span></span><span>)</span> delegate<span>.</span><span>getObject</span><span>(</span>key<span>)</span><span>;</span>\n    <span>if</span> <span>(</span>softReference <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n      result <span>=</span> softReference<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>\n      <span>if</span> <span>(</span>result <span>==</span> <span>null</span><span>)</span> <span>{</span>\n        <span>//1. 如果数据已经没有了,就清理这个key</span>\n        delegate<span>.</span><span>removeObject</span><span>(</span>key<span>)</span><span>;</span>\n      <span>}</span> <span>else</span> <span>{</span>\n        <span>// See #586 (and #335) modifications need more than a read lock </span>\n        <span>synchronized</span> <span>(</span>hardLinksToAvoidGarbageCollection<span>)</span> <span>{</span>\n          <span>//2. 如果key存在,读取时候加一个锁操作,并将缓存值添加到硬连接集合中,避免垃圾回收</span>\n          hardLinksToAvoidGarbageCollection<span>.</span><span>addFirst</span><span>(</span>result<span>)</span><span>;</span>\n          <span>//3. 构造中指定硬链接最大256,所以如果已经有256个key的时候回开始删除最先添加的key</span>\n          <span>if</span> <span>(</span>hardLinksToAvoidGarbageCollection<span>.</span><span>size</span><span>(</span><span>)</span> <span>></span> numberOfHardLinks<span>)</span> <span>{</span>\n            hardLinksToAvoidGarbageCollection<span>.</span><span>removeLast</span><span>(</span><span>)</span><span>;</span>\n          <span>}</span>\n        <span>}</span>\n      <span>}</span>\n    <span>}</span>\n    <span>return</span> result<span>;</span>\n  <span>}</span>\n\n  <span>@Override</span>\n  <span>public</span> <span>void</span> <span>clear</span><span>(</span><span>)</span> <span>{</span>\n    <span>//执行三清</span>\n    <span>synchronized</span> <span>(</span>hardLinksToAvoidGarbageCollection<span>)</span> <span>{</span>\n      <span>//1.清除硬链接队列</span>\n      hardLinksToAvoidGarbageCollection<span>.</span><span>clear</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>//2. 清除垃圾队列</span>\n    <span>removeGarbageCollectedItems</span><span>(</span><span>)</span><span>;</span>\n    <span>//3. 清除缓存</span>\n    delegate<span>.</span><span>clear</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>private</span> <span>void</span> <span>removeGarbageCollectedItems</span><span>(</span><span>)</span> <span>{</span>\n    <span>SoftEntry</span> sv<span>;</span>\n    <span>//清除value已经gc准备回收了,就就将key也清理掉</span>\n    <span>while</span> <span>(</span><span>(</span>sv <span>=</span> <span>(</span><span>SoftEntry</span><span>)</span> queueOfGarbageCollectedEntries<span>.</span><span>poll</span><span>(</span><span>)</span><span>)</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n      delegate<span>.</span><span>removeObject</span><span>(</span>sv<span>.</span>key<span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br></div></div><h2 id=\"_2-8-synchronizedcache\"> 2.8 SynchronizedCache</h2>\n<p>从名字看就是同步的缓存,从代码看即所有的方法都被<code>synchronized</code>修饰。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20191223175457202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" loading=\"lazy\"></p>\n<h2 id=\"_2-9-transactionalcache\"> 2.9 TransactionalCache</h2>\n<p>从名字上看就应该能隐隐感觉到跟事务有关,但是这个事务呢又不是数据库的那个事务。只是类似而已是, 即通过 <code>java</code> 代码来实现了一个暂存区域,如果事务成功就添加缓存，事务失败就回滚掉或者说就把暂存区的信息删除,不进入真正的缓存里面。 这个类是比较重要的一个类,因为所谓的二级缓存就是指这个类。既然说了🎧缓存就顺便提一下一级缓存。但是说一级缓存就设计到 <code>Mybatis</code>架构里面一个 <code>Executor</code> 执行器\n<img src=\"https://img-blog.csdnimg.cn/20191223193000589.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" loading=\"lazy\"></p>\n<p>所有的查询都先从一级缓存中查询\n<img src=\"https://img-blog.csdnimg.cn/20191223193115847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" loading=\"lazy\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20191223193308898.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" loading=\"lazy\"></p>\n<p>看到这里不由己提一个面试题,面试官会问你知道<code>Mybatis</code> 的一级缓存吗?\n一般都会说<code>Mybatis</code> 的一级缓存就是 <code>SqlSession</code> 自带的缓存,这么说也对就是太笼统了，因为 <code>SqlSession</code>其实就是生成 <code>Executor</code> 而一级缓存就是里面query方法中的 <code>localCache</code>。这个时候我们就要看下了<code>localCache</code> 究竟是什么?\n看一下构造,突然豁然开朗。原来本篇文章讲的基本就是一级缓存的实现呀。\n<img src=\"https://img-blog.csdnimg.cn/20191223193711876.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" loading=\"lazy\"></p>\n<p>说到这里感觉有点跑题了，我们不是要看 <code>TransactionalCache</code> 的实现吗?</p>\n<p><code>clearOnCommit</code> 为false就是这个事务已经完成了,可以从缓存中读取数据了。</p>\n<p>当<code>clearOnCommit</code>为 <code>true</code> ,这个事务正在进行中呢?  来的查询都给你返回 <code>null</code> , 等到 <code>commit</code> 提交时候在查询就可以从缓存中取数据了。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>TransactionalCache</span> <span>implements</span> <span>Cache</span> <span>{</span>\n\n  <span>private</span> <span>static</span> <span>final</span> <span>Log</span> log <span>=</span> <span>LogFactory</span><span>.</span><span>getLog</span><span>(</span><span>TransactionalCache</span><span>.</span><span>class</span><span>)</span><span>;</span>\n    <span>// 真正的缓存</span>\n  <span>private</span> <span>final</span> <span>Cache</span> delegate<span>;</span>\n  <span>// 是否清理已经提交的实物</span>\n  <span>private</span> <span>boolean</span> clearOnCommit<span>;</span>\n  <span>// 可以理解为暂存区</span>\n  <span>private</span> <span>final</span> <span>Map</span><span><span>&lt;</span><span>Object</span><span>,</span> <span>Object</span><span>></span></span> entriesToAddOnCommit<span>;</span>\n  <span>// 缓存中没有的key</span>\n  <span>private</span> <span>final</span> <span>Set</span><span><span>&lt;</span><span>Object</span><span>></span></span> entriesMissedInCache<span>;</span>\n\n  <span>public</span> <span>TransactionalCache</span><span>(</span><span>Cache</span> delegate<span>)</span> <span>{</span>\n    <span>this</span><span>.</span>delegate <span>=</span> delegate<span>;</span>\n    <span>this</span><span>.</span>clearOnCommit <span>=</span> <span>false</span><span>;</span>\n    <span>this</span><span>.</span>entriesToAddOnCommit <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>Object</span><span>,</span> <span>Object</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n    <span>this</span><span>.</span>entriesMissedInCache <span>=</span> <span>new</span> <span>HashSet</span><span><span>&lt;</span><span>Object</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>@Override</span>\n  <span>public</span> <span>String</span> <span>getId</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> delegate<span>.</span><span>getId</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>@Override</span>\n  <span>public</span> <span>int</span> <span>getSize</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> delegate<span>.</span><span>getSize</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>@Override</span>\n  <span>public</span> <span>Object</span> <span>getObject</span><span>(</span><span>Object</span> key<span>)</span> <span>{</span>\n    <span>// 先从缓存中拿数据</span>\n    <span>Object</span> object <span>=</span> delegate<span>.</span><span>getObject</span><span>(</span>key<span>)</span><span>;</span>\n    <span>if</span> <span>(</span>object <span>==</span> <span>null</span><span>)</span> <span>{</span>\n      <span>// 如果没有添加到set集合中</span>\n      entriesMissedInCache<span>.</span><span>add</span><span>(</span>key<span>)</span><span>;</span>\n    <span>}</span>\n    <span>// 返回数据库的数据。</span>\n    <span>if</span> <span>(</span>clearOnCommit<span>)</span> <span>{</span>\n      <span>return</span> <span>null</span><span>;</span>\n    <span>}</span> <span>else</span> <span>{</span>\n      <span>return</span> object<span>;</span>\n    <span>}</span>\n  <span>}</span>\n\n  <span>@Override</span>\n  <span>public</span> <span>ReadWriteLock</span> <span>getReadWriteLock</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>null</span><span>;</span>\n  <span>}</span>\n\n  <span>@Override</span>\n  <span>public</span> <span>void</span> <span>putObject</span><span>(</span><span>Object</span> key<span>,</span> <span>Object</span> object<span>)</span> <span>{</span>\n    entriesToAddOnCommit<span>.</span><span>put</span><span>(</span>key<span>,</span> object<span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>@Override</span>\n  <span>public</span> <span>Object</span> <span>removeObject</span><span>(</span><span>Object</span> key<span>)</span> <span>{</span>\n    <span>return</span> <span>null</span><span>;</span>\n  <span>}</span>\n\n  <span>@Override</span>\n  <span>public</span> <span>void</span> <span>clear</span><span>(</span><span>)</span> <span>{</span>\n    clearOnCommit <span>=</span> <span>true</span><span>;</span>\n    entriesToAddOnCommit<span>.</span><span>clear</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>public</span> <span>void</span> <span>commit</span><span>(</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>clearOnCommit<span>)</span> <span>{</span>\n      delegate<span>.</span><span>clear</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>flushPendingEntries</span><span>(</span><span>)</span><span>;</span>\n    <span>reset</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>public</span> <span>void</span> <span>rollback</span><span>(</span><span>)</span> <span>{</span>\n    <span>unlockMissedEntries</span><span>(</span><span>)</span><span>;</span>\n    <span>reset</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>private</span> <span>void</span> <span>reset</span><span>(</span><span>)</span> <span>{</span>\n    <span>//1. 是否清除提交</span>\n    clearOnCommit <span>=</span> <span>false</span><span>;</span>\n    <span>//2. 暂存区清理,代表这个事务从头开始做了，之前的清理掉</span>\n    entriesToAddOnCommit<span>.</span><span>clear</span><span>(</span><span>)</span><span>;</span>\n    <span>//3. 同上</span>\n    entriesMissedInCache<span>.</span><span>clear</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span>\n    \n  <span>/** \n   * 将暂存区的数据提交到缓存中\n   **/</span>\n  <span>private</span> <span>void</span> <span>flushPendingEntries</span><span>(</span><span>)</span> <span>{</span>\n    <span>for</span> <span>(</span><span>Map<span>.</span>Entry</span><span><span>&lt;</span><span>Object</span><span>,</span> <span>Object</span><span>></span></span> entry <span>:</span> entriesToAddOnCommit<span>.</span><span>entrySet</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n      delegate<span>.</span><span>putObject</span><span>(</span>entry<span>.</span><span>getKey</span><span>(</span><span>)</span><span>,</span> entry<span>.</span><span>getValue</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>//如果缓存中不包含这个key,就将key对应的value设置为默认值null</span>\n    <span>for</span> <span>(</span><span>Object</span> entry <span>:</span> entriesMissedInCache<span>)</span> <span>{</span>\n      <span>if</span> <span>(</span><span>!</span>entriesToAddOnCommit<span>.</span><span>containsKey</span><span>(</span>entry<span>)</span><span>)</span> <span>{</span>\n        delegate<span>.</span><span>putObject</span><span>(</span>entry<span>,</span> <span>null</span><span>)</span><span>;</span>\n      <span>}</span>\n    <span>}</span>\n  <span>}</span>\n\n  <span>// 移除缺失的key,就是这个缓存中没有的key都移除掉</span>\n  <span>private</span> <span>void</span> <span>unlockMissedEntries</span><span>(</span><span>)</span> <span>{</span>\n    <span>for</span> <span>(</span><span>Object</span> entry <span>:</span> entriesMissedInCache<span>)</span> <span>{</span>\n      <span>try</span> <span>{</span>\n        delegate<span>.</span><span>removeObject</span><span>(</span>entry<span>)</span><span>;</span>\n      <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n        log<span>.</span><span>warn</span><span>(</span><span>\"Unexpected exception while notifiying a rollback to the cache adapter.\"</span>\n            <span>+</span> <span>\"Consider upgrading your cache adapter to the latest version.  Cause: \"</span> <span>+</span> e<span>)</span><span>;</span>\n      <span>}</span>\n    <span>}</span>\n  <span>}</span>\n\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br></div></div><h2 id=\"_2-10-weakcache\"> 2.10 WeakCache</h2>\n<p>从名字上看跟 <code>SoftCache</code> 有点关系,Soft引用是当内存不够用时候才清理, 而<code>Weak</code> 弱引用则相反, 只要有GC就会回收。 所以他们的类型特性并不是自己实现的，而是依赖于 <code>Reference&lt;T&gt;</code> 类的特性，所以代码就不看了基本和 <code>SoftCache</code> 实现一摸一样。</p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1648571408000.png",
      "date_published": "2022-03-30T15:42:58.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Mybatis"
      ]
    },
    {
      "title": "第12篇:Mybatis分页插件设计",
      "url": "https://java.springlearn.cn/learn/mybatis/PagePlugin/",
      "id": "https://java.springlearn.cn/learn/mybatis/PagePlugin/",
      "content_html": "<PageBanner/>\n",
      "date_published": "2022-03-30T15:42:58.000Z",
      "date_modified": "2022-07-12T12:38:40.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Mybatis"
      ]
    },
    {
      "title": "第08篇:Mybatis事务处理",
      "url": "https://java.springlearn.cn/learn/mybatis/%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/",
      "id": "https://java.springlearn.cn/learn/mybatis/%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/",
      "content_html": "<h2 id=\"一、jdk底层实现\"> 一、Jdk底层实现</h2>\n<p>Java JDK中提供了标准接口<code>Connection</code>,不同的数据库驱动负责具体的实现。后面无论是<code>Spring</code>还是<code>Mybatis</code>对事务的处理，无论怎么的封装,最终究其到底都是由<code>Connection</code>来提供的能力。</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>Connection</span>  <span>extends</span> <span>Wrapper</span><span>,</span> <span>AutoCloseable</span> <span>{</span>\n    <span>Statement</span> <span>createStatement</span><span>(</span><span>)</span> <span>throws</span> <span>SQLException</span><span>;</span>\n    <span>void</span> <span>commit</span><span>(</span><span>)</span> <span>throws</span> <span>SQLException</span><span>;</span>\n    <span>void</span> <span>rollback</span><span>(</span><span>)</span> <span>throws</span> <span>SQLException</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>例如 <code>com.mysql.cj.jdbc.ConnectionImpl</code>。具体负责跟mysql进行通信执行命令。</p>\n<h2 id=\"二、mybatis实现\"> 二、Mybatis实现</h2>\n<p>首先我们来看Mybatis是如何对<code>Connection</code>进行事务的封装。首先我们先来看一个图。</p>\n<p><img src=\"https://img.springlearn.cn/learn_d3cd2ff5e89f6dbfffff18289043304e.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_2-1-调用流程\"> 2.1 调用流程</h2>\n<p>根据上面的图我们看,都是一层一层的封装进行委派最终由<code>Connection</code>的具体数据库驱动来进行实现的。</p>\n<ul>\n<li>SqlSession</li>\n<li>Executor</li>\n<li>Transaction</li>\n</ul>\n<div><pre><code><span>public</span> <span>interface</span> <span>SqlSession</span> <span>extends</span> <span>Closeable</span> <span>{</span>\n  <span>void</span> <span>commit</span><span>(</span><span>)</span><span>;</span>\n  <span>void</span> <span>rollback</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n<span>public</span> <span>interface</span> <span>Executor</span> <span>{</span>\n  <span>void</span> <span>commit</span><span>(</span><span>)</span><span>;</span>\n  <span>void</span> <span>rollback</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n<span>public</span> <span>interface</span> <span>Transaction</span> <span>{</span>\n  <span>void</span> <span>commit</span><span>(</span><span>)</span> <span>throws</span> <span>SQLException</span><span>;</span>\n  <span>void</span> <span>rollback</span><span>(</span><span>)</span> <span>throws</span> <span>SQLException</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id=\"_2-2-实现原理\"> 2.2 实现原理</h2>\n<p>Mybatis中我们的接口是使用代理进行跟数据库进行交互的。所以他的事务提交逻辑是嵌套在代理方法中的。\n通过前面的调用流程学习,<a href=\"/learn/mybatis/Mapper代理对象创建/\">第04篇:Mybatis代理对象生成</a>我们知道最终都是在<code>MapperMethod</code>对SqlSession的调用执行数据库操作的。\n而SqlSession是有两个包装类的。</p>\n<ul>\n<li>SqlSession 通过底层的封装提供具体的调用指令</li>\n<li>SqlSessionManager 对SqlSession进行代理,自动对事务进行处理</li>\n<li>SqlSessionTemplate 事务的处理完全外包给Spring来处理</li>\n</ul>\n<p>下面我们分别来看下每个类具体都做了什么吧。</p>\n<h3 id=\"sqlsessionmanager\"> SqlSessionManager</h3>\n<p>SqlSessionManager 是对SqlSession的一个包装,它会自己来管理SqlSession。他的具体实现是通过对SqlSession\n生成代理，代理拦截每个方法进行增强。</p>\n<div><pre><code>\n  <span>private</span> <span>SqlSessionManager</span><span>(</span><span>SqlSessionFactory</span> sqlSessionFactory<span>)</span> <span>{</span>\n    <span>this</span><span>.</span>sqlSessionFactory <span>=</span> sqlSessionFactory<span>;</span>\n    <span>this</span><span>.</span>sqlSessionProxy <span>=</span> <span>(</span><span>SqlSession</span><span>)</span> <span>Proxy</span><span>.</span><span>newProxyInstance</span><span>(</span>\n        <span>SqlSessionFactory</span><span>.</span><span>class</span><span>.</span><span>getClassLoader</span><span>(</span><span>)</span><span>,</span>\n        <span>new</span> <span>Class</span><span>[</span><span>]</span><span>{</span><span>SqlSession</span><span>.</span><span>class</span><span>}</span><span>,</span>\n        <span>new</span> <span>SqlSessionInterceptor</span><span>(</span><span>)</span><span>)</span><span>;</span>\n  <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><strong>SqlSessionInterceptor</strong></p>\n<div><pre><code> <span>private</span> <span>class</span> <span>SqlSessionInterceptor</span> <span>implements</span> <span>InvocationHandler</span> <span>{</span>\n    <span>public</span> <span>SqlSessionInterceptor</span><span>(</span><span>)</span> <span>{</span>\n        <span>// Prevent Synthetic Access</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>Object</span> <span>invoke</span><span>(</span><span>Object</span> proxy<span>,</span> <span>Method</span> method<span>,</span> <span>Object</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>Throwable</span> <span>{</span>\n      <span>final</span> <span>SqlSession</span> sqlSession <span>=</span> <span>SqlSessionManager</span><span>.</span><span>this</span><span>.</span>localSqlSession<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>\n      <span>if</span> <span>(</span>sqlSession <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n        <span>try</span> <span>{</span>\n          <span>return</span> method<span>.</span><span>invoke</span><span>(</span>sqlSession<span>,</span> args<span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>Throwable</span> t<span>)</span> <span>{</span>\n          <span>throw</span> <span>ExceptionUtil</span><span>.</span><span>unwrapThrowable</span><span>(</span>t<span>)</span><span>;</span>\n        <span>}</span>\n      <span>}</span> <span>else</span> <span>{</span>\n        <span>try</span> <span>(</span><span>SqlSession</span> autoSqlSession <span>=</span> <span>openSession</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n          <span>try</span> <span>{</span>\n            <span>final</span> <span>Object</span> result <span>=</span> method<span>.</span><span>invoke</span><span>(</span>autoSqlSession<span>,</span> args<span>)</span><span>;</span>\n            autoSqlSession<span>.</span><span>commit</span><span>(</span><span>)</span><span>;</span>\n            <span>return</span> result<span>;</span>\n          <span>}</span> <span>catch</span> <span>(</span><span>Throwable</span> t<span>)</span> <span>{</span>\n            autoSqlSession<span>.</span><span>rollback</span><span>(</span><span>)</span><span>;</span>\n            <span>throw</span> <span>ExceptionUtil</span><span>.</span><span>unwrapThrowable</span><span>(</span>t<span>)</span><span>;</span>\n          <span>}</span>\n        <span>}</span>\n      <span>}</span>\n    <span>}</span>\n  <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><ol>\n<li>从ThreadLocal中获取SqlSession，如果有，说明是调用方要自己处理事务，那么就只进行执行数据库操作，不进行事务处理和连接的关闭。</li>\n<li>如果没有,说明要自己来管理事务，那么就新生成SqlSession，帮我们调用SqlSession#commit来提交事务,失败进行回滚。</li>\n</ol>\n<p>根据其中原理我们知道有两种使用办法，</p>\n<ul>\n<li><code>首先第一种自己管理SqlSession的方式</code></li>\n</ul>\n<div><pre><code>    <span>InputStream</span> inputStream <span>=</span> <span>Resources</span><span>.</span><span>getResourceAsStream</span><span>(</span><span>\"mybatis-config.xml\"</span><span>)</span><span>;</span>\n    <span>// 实例化sqlSessionManager</span>\n    <span>SqlSessionManager</span> sqlSessionManager <span>=</span> <span>SqlSessionManager</span><span>.</span><span>newInstance</span><span>(</span>inputStream<span>)</span><span>;</span>\n    <span>// 第一步: 开启管理SqlSession，创建一个SqlSession并存入到ThreadLocal中</span>\n    sqlSessionManager<span>.</span><span>startManagedSession</span><span>(</span><span>)</span><span>;</span>\n    <span>// 使用</span>\n    <span>UserMapper</span> mapper <span>=</span> sqlSessionManager<span>.</span><span>getMapper</span><span>(</span><span>UserMapper</span><span>.</span><span>class</span><span>)</span><span>;</span>\n    mapper<span>.</span><span>save</span><span>(</span><span>new</span> <span>User</span><span>(</span><span>\"孙悟空\"</span><span>)</span><span>)</span><span>;</span>\n    <span>// 第二步: 因为事务是我们自己开启的,所以要自己来操作提交事务，或者回滚</span>\n    sqlSessionManager<span>.</span><span>commit</span><span>(</span><span>)</span><span>;</span>\n    <span>// 第三步: 关闭连接</span>\n    sqlSessionManager<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><ul>\n<li><code>第二种,自动管理SqlSession</code></li>\n</ul>\n<div><pre><code>    <span>InputStream</span> inputStream <span>=</span> <span>Resources</span><span>.</span><span>getResourceAsStream</span><span>(</span><span>\"mybatis-config.xml\"</span><span>)</span><span>;</span>\n    <span>// 实例化sqlSessionManager</span>\n    <span>SqlSessionManager</span> sqlSessionManager <span>=</span> <span>SqlSessionManager</span><span>.</span><span>newInstance</span><span>(</span>inputStream<span>)</span><span>;</span>\n    <span>UserMapper</span> mapper <span>=</span> sqlSessionManager<span>.</span><span>getMapper</span><span>(</span><span>UserMapper</span><span>.</span><span>class</span><span>)</span><span>;</span>\n    mapper<span>.</span><span>save</span><span>(</span><span>new</span> <span>User</span><span>(</span><span>\"孙悟空\"</span><span>)</span><span>)</span><span>;</span>\n    <span>// 只用关心关闭就好了，事务的信息,都帮我们完成了。</span>\n    sqlSessionManager<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id=\"sqlsessiontemplate\"> SqlSessionTemplate</h3>\n<p>线程安全、Spring 管理、与 Spring 事务管理一起使用的SqlSession ，以确保实际使用的 SqlSession 是与当前 Spring 事务关联的那个。此外，它还管理会话生命周期，包括根据 Spring 事务配置根据需要关闭、提交或回滚会话。\n模板需要一个 SqlSessionFactory 来创建 SqlSession，作为构造函数参数传递。也可以构造指示要使用的执行器类型，如果没有，将使用会话工厂中定义的默认执行器类型。\n此模板将 MyBatis PersistenceExceptions 转换为未经检查的 DataAccessExceptions，默认情况下使用MyBatisExceptionTranslator 。</p>\n<p><mark>SqlSessionTemplate</mark> 和 <mark>SqlSessionManager</mark></p>\n<ul>\n<li><code>相同点:</code> 都是通过对SqlSession进行代理对方法进行增强的</li>\n<li><code>不同点:</code> 前者是将SqlSession外包给Spring进行管理的,后者是自己通过ThreadLocal进行管理的。</li>\n</ul>\n<p>下面我们来具体看下是如何拦截增强的。</p>\n<ol>\n<li>第一个点获取SqlSession不同。\n<ul>\n<li>从Spring中的事务管理器中获取当前线程的事务信息</li>\n</ul>\n</li>\n<li>第二个点方法执行完成后都会自动关闭SqlSession或减少引用\n<ul>\n<li>为解决嵌套事务的情况,每次执行完后会减少一次引用。当引用都减少为0才会真正进行关闭。</li>\n</ul>\n</li>\n<li>第三个点是否提交事务，有判定规则。\n<ul>\n<li>只有Spring事务管理器中没有事务时候才会自己进行提交,否则都外包给Spring进行管理。</li>\n</ul>\n</li>\n</ol>\n<p>下面我们具体来看下代码的实现吧。</p>\n<div><div><br><br><br><div>&nbsp;</div><div>&nbsp;</div><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br></div><pre><code> <span>private</span> <span>class</span> <span>SqlSessionInterceptor</span> <span>implements</span> <span>InvocationHandler</span> <span>{</span>\n    <span>@Override</span>\n    <span>public</span> <span>Object</span> <span>invoke</span><span>(</span><span>Object</span> proxy<span>,</span> <span>Method</span> method<span>,</span> <span>Object</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>Throwable</span> <span>{</span>\n      <span>SqlSession</span> sqlSession <span>=</span> <span>getSqlSession</span><span>(</span><span>SqlSessionTemplate</span><span>.</span><span>this</span><span>.</span>sqlSessionFactory<span>,</span>\n          <span>SqlSessionTemplate</span><span>.</span><span>this</span><span>.</span>executorType<span>,</span> <span>SqlSessionTemplate</span><span>.</span><span>this</span><span>.</span>exceptionTranslator<span>)</span><span>;</span>\n      <span>try</span> <span>{</span>\n        <span>Object</span> result <span>=</span> method<span>.</span><span>invoke</span><span>(</span>sqlSession<span>,</span> args<span>)</span><span>;</span>\n        <span>if</span> <span>(</span><span>!</span><span>isSqlSessionTransactional</span><span>(</span>sqlSession<span>,</span> <span>SqlSessionTemplate</span><span>.</span><span>this</span><span>.</span>sqlSessionFactory<span>)</span><span>)</span> <span>{</span>\n          <span>// force commit even on non-dirty sessions because some databases require</span>\n          <span>// a commit/rollback before calling close()</span>\n          sqlSession<span>.</span><span>commit</span><span>(</span><span>true</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> result<span>;</span>\n      <span>}</span> <span>catch</span> <span>(</span><span>Throwable</span> t<span>)</span> <span>{</span>\n        <span>Throwable</span> unwrapped <span>=</span> <span>unwrapThrowable</span><span>(</span>t<span>)</span><span>;</span>\n        <span>if</span> <span>(</span><span>SqlSessionTemplate</span><span>.</span><span>this</span><span>.</span>exceptionTranslator <span>!=</span> <span>null</span> <span>&amp;&amp;</span> unwrapped <span>instanceof</span> <span>PersistenceException</span><span>)</span> <span>{</span>\n          <span>// release the connection to avoid a deadlock if the translator is no loaded. See issue #22</span>\n          <span>closeSqlSession</span><span>(</span>sqlSession<span>,</span> <span>SqlSessionTemplate</span><span>.</span><span>this</span><span>.</span>sqlSessionFactory<span>)</span><span>;</span>\n          sqlSession <span>=</span> <span>null</span><span>;</span>\n          <span>Throwable</span> translated <span>=</span> <span>SqlSessionTemplate</span><span>.</span><span>this</span><span>.</span>exceptionTranslator\n              <span>.</span><span>translateExceptionIfPossible</span><span>(</span><span>(</span><span>PersistenceException</span><span>)</span> unwrapped<span>)</span><span>;</span>\n          <span>if</span> <span>(</span>translated <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n            unwrapped <span>=</span> translated<span>;</span>\n          <span>}</span>\n        <span>}</span>\n        <span>throw</span> unwrapped<span>;</span>\n      <span>}</span> <span>finally</span> <span>{</span>\n        <span>if</span> <span>(</span>sqlSession <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n          <span>closeSqlSession</span><span>(</span>sqlSession<span>,</span> <span>SqlSessionTemplate</span><span>.</span><span>this</span><span>.</span>sqlSessionFactory<span>)</span><span>;</span>\n        <span>}</span>\n      <span>}</span>\n    <span>}</span>\n  <span>}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><p><strong>getSqlSession</strong></p>\n<ul>\n<li>从Spring提供的事务管理器(TransactionSynchronizationManager)中获取当前线程拥有的SqlSession</li>\n<li>如果没有就新建一个并注册到TransactionSynchronizationManager上。</li>\n</ul>\n<div><pre><code> <span>public</span> <span>static</span> <span>SqlSession</span> <span>getSqlSession</span><span>(</span><span>SqlSessionFactory</span> sessionFactory<span>,</span> <span>ExecutorType</span> executorType<span>,</span>\n      <span>PersistenceExceptionTranslator</span> exceptionTranslator<span>)</span> <span>{</span>\n\n    <span>notNull</span><span>(</span>sessionFactory<span>,</span> NO_SQL_SESSION_FACTORY_SPECIFIED<span>)</span><span>;</span>\n    <span>notNull</span><span>(</span>executorType<span>,</span> NO_EXECUTOR_TYPE_SPECIFIED<span>)</span><span>;</span>\n    <span>// 从Spring提供的事务管理器(TransactionSynchronizationManager)中获取当前线程拥有的SqlSession</span>\n    <span>// 逻辑很简单key=SqlSessionFactory value=SqlSessionHolder</span>\n    <span>SqlSessionHolder</span> holder <span>=</span> <span>(</span><span>SqlSessionHolder</span><span>)</span> <span>TransactionSynchronizationManager</span><span>.</span><span>getResource</span><span>(</span>sessionFactory<span>)</span><span>;</span>\n\n    <span>SqlSession</span> session <span>=</span> <span>sessionHolder</span><span>(</span>executorType<span>,</span> holder<span>)</span><span>;</span>\n    <span>if</span> <span>(</span>session <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n      <span>return</span> session<span>;</span>\n    <span>}</span>\n\n    LOGGER<span>.</span><span>debug</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>\"Creating a new SqlSession\"</span><span>)</span><span>;</span>\n    session <span>=</span> sessionFactory<span>.</span><span>openSession</span><span>(</span>executorType<span>)</span><span>;</span>\n    <span>// 如果没有就新建一个并注册到TransactionSynchronizationManager上。</span>\n    <span>registerSessionHolder</span><span>(</span>sessionFactory<span>,</span> executorType<span>,</span> exceptionTranslator<span>,</span> session<span>)</span><span>;</span>\n\n    <span>return</span> session<span>;</span>\n  <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p><strong>registerSessionHolder</strong></p>\n<ul>\n<li>为了保险先判断下当前线程中是否已经存在同步器,如果存在还注册就提示:  &quot;SqlSession [&quot; + session + &quot;] was not registered for synchronization because synchronization is not active&quot;);</li>\n<li>如果当前线程没有,判断事务管理器是否是SpringManagedTransactionFactory,如果是就注册一个。</li>\n<li>SqlSessionHolder#requested() 注意这一行,创建后给引用次数加1.</li>\n</ul>\n<div><pre><code><span>private</span> <span>static</span> <span>void</span> <span>registerSessionHolder</span><span>(</span><span>SqlSessionFactory</span> sessionFactory<span>,</span> <span>ExecutorType</span> executorType<span>,</span>\n      <span>PersistenceExceptionTranslator</span> exceptionTranslator<span>,</span> <span>SqlSession</span> session<span>)</span> <span>{</span>\n    <span>SqlSessionHolder</span> holder<span>;</span>\n    <span>if</span> <span>(</span><span>TransactionSynchronizationManager</span><span>.</span><span>isSynchronizationActive</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n      <span>Environment</span> environment <span>=</span> sessionFactory<span>.</span><span>getConfiguration</span><span>(</span><span>)</span><span>.</span><span>getEnvironment</span><span>(</span><span>)</span><span>;</span>\n\n      <span>if</span> <span>(</span>environment<span>.</span><span>getTransactionFactory</span><span>(</span><span>)</span> <span>instanceof</span> <span>SpringManagedTransactionFactory</span><span>)</span> <span>{</span>\n        LOGGER<span>.</span><span>debug</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>\"Registering transaction synchronization for SqlSession [\"</span> <span>+</span> session <span>+</span> <span>\"]\"</span><span>)</span><span>;</span>\n\n        holder <span>=</span> <span>new</span> <span>SqlSessionHolder</span><span>(</span>session<span>,</span> executorType<span>,</span> exceptionTranslator<span>)</span><span>;</span>\n        <span>TransactionSynchronizationManager</span><span>.</span><span>bindResource</span><span>(</span>sessionFactory<span>,</span> holder<span>)</span><span>;</span>\n        <span>TransactionSynchronizationManager</span>\n            <span>.</span><span>registerSynchronization</span><span>(</span><span>new</span> <span>SqlSessionSynchronization</span><span>(</span>holder<span>,</span> sessionFactory<span>)</span><span>)</span><span>;</span>\n        holder<span>.</span><span>setSynchronizedWithTransaction</span><span>(</span><span>true</span><span>)</span><span>;</span>\n        holder<span>.</span><span>requested</span><span>(</span><span>)</span><span>;</span>\n      <span>}</span> <span>else</span> <span>{</span>\n        <span>if</span> <span>(</span><span>TransactionSynchronizationManager</span><span>.</span><span>getResource</span><span>(</span>environment<span>.</span><span>getDataSource</span><span>(</span><span>)</span><span>)</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>\n          LOGGER<span>.</span><span>debug</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>\"SqlSession [\"</span> <span>+</span> session\n              <span>+</span> <span>\"] was not registered for synchronization because DataSource is not transactional\"</span><span>)</span><span>;</span>\n        <span>}</span> <span>else</span> <span>{</span>\n          <span>throw</span> <span>new</span> <span>TransientDataAccessResourceException</span><span>(</span>\n              <span>\"SqlSessionFactory must be using a SpringManagedTransactionFactory in order to use Spring transaction synchronization\"</span><span>)</span><span>;</span>\n        <span>}</span>\n      <span>}</span>\n    <span>}</span> <span>else</span> <span>{</span>\n      LOGGER<span>.</span><span>debug</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>\"SqlSession [\"</span> <span>+</span> session\n          <span>+</span> <span>\"] was not registered for synchronization because synchronization is not active\"</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p><strong>closeSqlSession</strong></p>\n<ul>\n<li>如果是Spring的事务管理，就减少引用</li>\n<li>如果不是Spring的事务管理,就直接关闭</li>\n</ul>\n<div><pre><code>  <span>public</span> <span>static</span> <span>void</span> <span>closeSqlSession</span><span>(</span><span>SqlSession</span> session<span>,</span> <span>SqlSessionFactory</span> sessionFactory<span>)</span> <span>{</span>\n    <span>notNull</span><span>(</span>session<span>,</span> NO_SQL_SESSION_SPECIFIED<span>)</span><span>;</span>\n    <span>notNull</span><span>(</span>sessionFactory<span>,</span> NO_SQL_SESSION_FACTORY_SPECIFIED<span>)</span><span>;</span>\n\n    <span>SqlSessionHolder</span> holder <span>=</span> <span>(</span><span>SqlSessionHolder</span><span>)</span> <span>TransactionSynchronizationManager</span><span>.</span><span>getResource</span><span>(</span>sessionFactory<span>)</span><span>;</span>\n    <span>if</span> <span>(</span><span>(</span>holder <span>!=</span> <span>null</span><span>)</span> <span>&amp;&amp;</span> <span>(</span>holder<span>.</span><span>getSqlSession</span><span>(</span><span>)</span> <span>==</span> session<span>)</span><span>)</span> <span>{</span>\n      LOGGER<span>.</span><span>debug</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>\"Releasing transactional SqlSession [\"</span> <span>+</span> session <span>+</span> <span>\"]\"</span><span>)</span><span>;</span>\n      holder<span>.</span><span>released</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span> <span>else</span> <span>{</span>\n      LOGGER<span>.</span><span>debug</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>\"Closing non transactional SqlSession [\"</span> <span>+</span> session <span>+</span> <span>\"]\"</span><span>)</span><span>;</span>\n      session<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p><strong>isSqlSessionTransactional</strong></p>\n<p>事务的判定逻辑:</p>\n<ul>\n<li>如果从事务管理器中获取,说明当前线程是有事务的</li>\n<li>当前线程中的事务SqlSession和这个方法中的SqlSession是同一个,说明是嵌套事务。</li>\n</ul>\n<p>如果是Spring来管理事务,这就不会自动来提交事务。外包给Spring的事务拦截器自己去处理。</p>\n<div><pre><code>  <span>public</span> <span>static</span> <span>boolean</span> <span>isSqlSessionTransactional</span><span>(</span><span>SqlSession</span> session<span>,</span> <span>SqlSessionFactory</span> sessionFactory<span>)</span> <span>{</span>\n    <span>notNull</span><span>(</span>session<span>,</span> NO_SQL_SESSION_SPECIFIED<span>)</span><span>;</span>\n    <span>notNull</span><span>(</span>sessionFactory<span>,</span> NO_SQL_SESSION_FACTORY_SPECIFIED<span>)</span><span>;</span>\n\n    <span>SqlSessionHolder</span> holder <span>=</span> <span>(</span><span>SqlSessionHolder</span><span>)</span> <span>TransactionSynchronizationManager</span><span>.</span><span>getResource</span><span>(</span>sessionFactory<span>)</span><span>;</span>\n\n    <span>return</span> <span>(</span>holder <span>!=</span> <span>null</span><span>)</span> <span>&amp;&amp;</span> <span>(</span>holder<span>.</span><span>getSqlSession</span><span>(</span><span>)</span> <span>==</span> session<span>)</span><span>;</span>\n  <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>好了，到这里Mybatis中事务的处理逻辑我们就到了解了。</p>\n<p>SqlSession对底层进行封装提供具体的指令\nSqlSessionManager和SqlSessionTemplate都是对SqlSession进行增强来自动或者委派Spring进行事务的处理的。</p>\n<p>下面我们去看看Spring是如何来处理事务的吧。<a href=\"/learn/spring/Spring声明式事务的实现方案/\">Spring事务的处理方式</a></p>\n",
      "image": "https://img.springlearn.cn/learn_d3cd2ff5e89f6dbfffff18289043304e.png",
      "date_published": "2022-06-16T13:10:16.000Z",
      "date_modified": "2022-07-12T12:38:40.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Mybatis"
      ]
    },
    {
      "title": "第09篇:Spring处理Mybatis事务",
      "url": "https://java.springlearn.cn/learn/mybatis/Spring%E4%BA%8B%E5%8A%A1%E6%95%B4%E5%90%88/",
      "id": "https://java.springlearn.cn/learn/mybatis/Spring%E4%BA%8B%E5%8A%A1%E6%95%B4%E5%90%88/",
      "content_html": "<div><p>提示</p>\n<p>本篇文章是对Mybatis知识点的一个扩展,主要一起来研究下Spring是如何来管理事务的。顺便再多聊一点其他的知识点,在学习的过程中主要带着以下问题来进行有目的的学习\n然后最终来回答下面这些问题。</p>\n</div>\n<ol>\n<li>Mybatis是如何整合进Spring中的\n<ul>\n<li>Spring如何知道哪些接口是Mapper接口的?</li>\n<li>Mapper接口是如何变成Spring Bean的？</li>\n</ul>\n</li>\n<li>Spring在哪里声明的SqlSession的实现逻辑？</li>\n<li>Spring中声明式事务的实现方式是怎样的？</li>\n<li>Spring中如何处理嵌套事务的？</li>\n<li>Spring中事务的传播方式是如何实现的？</li>\n</ol>\n<p>https://cloud.tencent.com/developer/article/1497631</p>\n<h2 id=\"一、如何整合进spring中的\"> 一、如何整合进Spring中的</h2>\n<p>默认大家对Spring都比较了解了,这里只说结果。都知道接口是不能被实例化的,那么接口是如何成为Bean的呢?</p>\n<h2 id=\"_1-1-如何知道哪些是mybatis的接口呢\"> 1.1 如何知道哪些是Mybatis的接口呢?</h2>\n<ul>\n<li><code>@MapperScan</code> Spring中在配置类上加上这个注解。根据源码能看到还导入了<code>MapperScannerRegistrar</code></li>\n</ul>\n<div><pre><code><span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>\n<span>@Target</span><span>(</span><span>ElementType</span><span>.</span>TYPE<span>)</span>\n<span>@Documented</span>\n<span>@Import</span><span>(</span><span>MapperScannerRegistrar</span><span>.</span><span>class</span><span>)</span>\n<span>@Repeatable</span><span>(</span><span>MapperScans</span><span>.</span><span>class</span><span>)</span>\n<span>public</span> <span>@interface</span> <span>MapperScan</span> <span>{</span><span>}</span>\n\n<span>public</span> <span>class</span> <span>MapperScannerRegistrar</span> <span>implements</span> <span>ImportBeanDefinitionRegistrar</span><span>,</span> <span>ResourceLoaderAware</span> <span>{</span><span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><code>MapperScannerRegistrar</code> 会在配置类解析时候拿到<code>MapperScan</code>注解信息,并解析里面的参数。生成一个 <code>MapperScannerConfigurer</code> 信息。\n从源码中能看到Mybatis的很多配置信息,都会被注入到<code>MapperScannerConfigurer</code>中。</p>\n<p><img src=\"https://img.springlearn.cn/learn_4b3a9611962ebf20587584574ecb05ec.png\" alt=\"img.png\" loading=\"lazy\"></p>\n<div><pre><code><span>public</span> <span>class</span> <span>MapperScannerConfigurer</span>\n    <span>implements</span> <span>BeanDefinitionRegistryPostProcessor</span><span>,</span> <span>InitializingBean</span><span>,</span> <span>ApplicationContextAware</span><span>,</span> <span>BeanNameAware</span> <span>{</span><span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>实现自BeanDefinitionRegistryPostProcessor会前置,拿到MapperScan中的basePackage,最终通过<code>ClassPathMapperScanner</code>扫描并添加到\n<code>BeanDefinitionRegistry</code>中。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1655086500000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>到这里这种方式就能知道哪些是Mybatis中的Mapper接口了。</p>\n<p>还有第二种方式当发现Spring容器中没有<code>MapperScannerConfigurer</code>。会自动注入一个</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1655086934000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>会直接指定哪些类被Mapper修饰,就将他生成Bean。\n<img src=\"https://img.springlearn.cn/blog/learn_1655087073000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>好了，到这里就知道如何来确定那些接口是要生成Mybatis接口的了。下面看下个问题。</p>\n<h2 id=\"_1-2-mapper接口是如何变成spring-bean的\"> 1.2 Mapper接口是如何变成Spring Bean的？</h2>\n<p>接口是不能被实例化的，但是在Spring中如何想让接口实例化就可以使用 <a href=\"/learn/spring/FactoryBean接口实例化/\">FactoryBean</a> + 动态代理的方式，实现接口类的实例化。</p>\n<ul>\n<li>首先利用 ClassPathBeanDefinitionScanner 找到符合规则的类生成 BeanDefinition。</li>\n<li>给 BeanDefinition 指定BeanClass,执行 FactoryBean 是 <code>MapperFactoryBean</code></li>\n</ul>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1655087975000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"二、spring在哪里声明的sqlsession的实现逻辑\"> 二、Spring在哪里声明的SqlSession的实现逻辑？</h2>\n<p>通过Mybatis的学习知道SqlSession一共有2个包装类。SqlSessionManager和SqlSessionTemplate。那么SqlSession是在哪里指定用哪个的呢?\n答案就在 <code>MapperFactoryBean</code></p>\n<div><pre><code><span>public</span> <span>class</span> <span>MapperFactoryBean</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>extends</span> <span>SqlSessionDaoSupport</span> <span>implements</span> <span>FactoryBean</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>{</span>\n  <span>private</span> <span>SqlSessionTemplate</span> sqlSessionTemplate<span>;</span>\n   \n     <span>public</span> <span>void</span> <span>setSqlSessionFactory</span><span>(</span><span>SqlSessionFactory</span> sqlSessionFactory<span>)</span> <span>{</span>\n       <span>if</span> <span>(</span><span>this</span><span>.</span>sqlSessionTemplate <span>==</span> <span>null</span> <span>||</span> sqlSessionFactory <span>!=</span> <span>this</span><span>.</span>sqlSessionTemplate<span>.</span><span>getSqlSessionFactory</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n         <span>this</span><span>.</span>sqlSessionTemplate <span>=</span> <span>createSqlSessionTemplate</span><span>(</span>sqlSessionFactory<span>)</span><span>;</span>\n       <span>}</span>\n     <span>}</span>\n   \n     <span>@SuppressWarnings</span><span>(</span><span>\"WeakerAccess\"</span><span>)</span>\n     <span>protected</span> <span>SqlSessionTemplate</span> <span>createSqlSessionTemplate</span><span>(</span><span>SqlSessionFactory</span> sqlSessionFactory<span>)</span> <span>{</span>\n       <span>return</span> <span>new</span> <span>SqlSessionTemplate</span><span>(</span>sqlSessionFactory<span>)</span><span>;</span>\n     <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h2 id=\"三、spring中声明式事务的实现方式是怎样的\"> 三、Spring中声明式事务的实现方式是怎样的</h2>\n<p>看了Mybatis中事务这一章节,知道如果使用了SqlSessionTemplate,那么事务的权限就外包给了Spring。那么Spring中事务怎么处理的呢?\n终于进入正题了。Spring中提供两种事务的能力。</p>\n<ul>\n<li>声明式事务</li>\n<li>编程式事务</li>\n</ul>\n<h2 id=\"_3-1-声明式事务\"> 3.1 声明式事务</h2>\n<p>使用 <code>Transactional</code> 修饰方法，其主要实现是使用切面实现。</p>\n<ul>\n<li><code>TransactionAspectSupport#invokeWithinTransaction</code>。拦截方法。获取事务管理器。</li>\n</ul>\n<p>这里我们先来思考下,通过前面的学习知道事务的最底层实现是jdbc驱动来实现的。</p>\n<p><img src=\"https://img.springlearn.cn/learn_d3cd2ff5e89f6dbfffff18289043304e.png\" alt=\"\" loading=\"lazy\"></p>\n<p>那么切面中要想实现，就必须保证切面中的线程执行的数据库操作，一定是同一个<code>SqlSession</code>这样才能在方法正常执行时候做commit，异常时候做rollback操作。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1655099097000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>那我们看下他是如何保证切面中的数据库操作一定是同一个SqlSession的吧。这部分逻辑就在 <code>SqlSessionTemplate</code> 中。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1655099774000.png\" alt=\"\" loading=\"lazy\"></p>\n<ul>\n<li>获取当前线程是否已经有SqlSession了，如果有就直接使用，这样就保证在切面中的事务用的是同一个事务了。</li>\n</ul>\n<h2 id=\"_3-2-编程式事务\"> 3.2 编程式事务</h2>\n<ul>\n<li><code>TransactionTemplate#execute</code></li>\n</ul>\n<p>编程是事务需要实现者自己来管理事务的，Spring提供的扩展接口类是 <code>CallbackPreferringPlatformTransactionManager</code>。如果发现容器中默认的事务管理类是这个\n就直接调动全局的这个事务管理方法。如果不是就自己来处理。这种设计的好处是,事务管理器既可以做关系型数据库的事务管理,也可以满足一些特定场景的事务控制(eg: 给Kafka的逻辑做一个事务管理)。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1655100730000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"四、spring中如何处理嵌套事务的\"> 四、Spring中如何处理嵌套事务的？</h2>\n<p>什么是嵌套事务,举一个伪代码的例子。下面 <code>saveUser</code> 代码中有2个Mapper。但是有几个SqlSession呢?</p>\n<div><pre><code><span>UserMapper</span> userMapper<span>;</span>\n\n<span>RegistroyMapper</span> registoryMapper<span>;</span>\n\n<span>@Transactional</span><span>(</span>rollbackFor <span>=</span> <span>{</span><span>Throwable</span><span>.</span><span>class</span><span>,</span> <span>RuntimeException</span><span>.</span><span>class</span><span>,</span> <span>ExecutionException</span><span>.</span><span>class</span><span>}</span><span>)</span>\n<span>public</span> <span>void</span> <span>save</span><span>(</span><span>User</span> user<span>)</span><span>{</span>\n   userMapper<span>.</span><span>save</span><span>(</span>user<span>)</span><span>;</span>\n<span>}</span>\n\n<span>@Transactional</span><span>(</span>rollbackFor <span>=</span> <span>{</span><span>Throwable</span><span>.</span><span>class</span><span>,</span> <span>RuntimeException</span><span>.</span><span>class</span><span>,</span> <span>ExecutionException</span><span>.</span><span>class</span><span>}</span><span>)</span>\n<span>public</span> <span>void</span> <span>saveUser</span><span>(</span><span>String</span> userName<span>,</span><span>Strign</span> password<span>)</span><span>{</span>\n   <span>User</span> user <span>=</span> registoryMapper<span>.</span><span>regis</span><span>(</span>userName<span>,</span>password<span>)</span><span>;</span>\n   <span>save</span><span>(</span>user<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>通过上面的学习我们了解到如果是Spring来管理的事务是一个线程对应一个SqlSession。所以说上面伪代码中的两个Mapper\n其实是用的同一个SqlSession,这样才能保证是在同一个事务中。核心代码逻辑就在这里 <code>SqlSessionUtils#getSqlSession</code>。\n从Spring中的事务管理器中获取 <code>SqlSession</code>。是否使用同一个事务，外包给Spring容器去托管。这就给Spring提供了很多可以发挥的空间。\n比如说传播机制等。</p>\n<div><pre><code><span>public</span> <span>static</span> <span>SqlSession</span> <span>getSqlSession</span><span>(</span><span>SqlSessionFactory</span> sessionFactory<span>,</span> <span>ExecutorType</span> executorType<span>,</span>\n      <span>PersistenceExceptionTranslator</span> exceptionTranslator<span>)</span> <span>{</span>\n\n    <span>notNull</span><span>(</span>sessionFactory<span>,</span> NO_SQL_SESSION_FACTORY_SPECIFIED<span>)</span><span>;</span>\n    <span>notNull</span><span>(</span>executorType<span>,</span> NO_EXECUTOR_TYPE_SPECIFIED<span>)</span><span>;</span>\n\n    <span>SqlSessionHolder</span> holder <span>=</span> <span>(</span><span>SqlSessionHolder</span><span>)</span> <span>TransactionSynchronizationManager</span><span>.</span><span>getResource</span><span>(</span>sessionFactory<span>)</span><span>;</span>\n\n    <span>SqlSession</span> session <span>=</span> <span>sessionHolder</span><span>(</span>executorType<span>,</span> holder<span>)</span><span>;</span>\n    <span>if</span> <span>(</span>session <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n      <span>return</span> session<span>;</span>\n    <span>}</span>\n\n    LOGGER<span>.</span><span>debug</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>\"Creating a new SqlSession\"</span><span>)</span><span>;</span>\n    session <span>=</span> sessionFactory<span>.</span><span>openSession</span><span>(</span>executorType<span>)</span><span>;</span>\n\n    <span>registerSessionHolder</span><span>(</span>sessionFactory<span>,</span> executorType<span>,</span> exceptionTranslator<span>,</span> session<span>)</span><span>;</span>\n\n    <span>return</span> session<span>;</span>\n  <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h2 id=\"五、spring中事务的传播方式是如何实现的\"> 五、Spring中事务的传播方式是如何实现的？</h2>\n<table>\n<thead>\n<tr>\n<th>传播方式</th>\n<th>说明</th>\n<th>常用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>TransactionDefinition.PROPAGATION_REQUIRED</td>\n<td>如果存在一个事务，则支持当前事务。如果没有事务则开启</td>\n<td>✅</td>\n</tr>\n<tr>\n<td>TransactionDefinition.PROPAGATION_SUPPORTS</td>\n<td>如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行</td>\n<td></td>\n</tr>\n<tr>\n<td>TransactionDefinition.PROPAGATION_MANDATORY</td>\n<td>如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常</td>\n<td></td>\n</tr>\n<tr>\n<td>TransactionDefinition.PROPAGATION_NEVER</td>\n<td>总是非事务地执行，如果存在一个活动事务，则抛出异常</td>\n<td></td>\n</tr>\n<tr>\n<td>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</td>\n<td>总是非事务地执行，并挂起任何存在的事务</td>\n<td></td>\n</tr>\n<tr>\n<td>TransactionDefinition.PROPAGATION_REQUIRES_NEW</td>\n<td>总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起。</td>\n<td></td>\n</tr>\n<tr>\n<td>TransactionDefinition.PROPAGATION_NESTED</td>\n<td>如果一个活动的事务存在，则运行在一个嵌套的事务中. 如果没有活动事务则按TransactionDefinition.PROPAGATION_REQUIRED 属性执行</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p><strong>思考传播机制如何实现</strong></p>\n<p>首先我们先思考下传播机制是如何实现的,因为我们知道 <code>要保证是同一个事务,那么一定是同一个SqlSession,这样才能保证是同一个事务</code>。\n而如果要新开事务,就要先将当前线程绑定的SqlSession等事务信息,给挂起，那么是如何进行挂起的呢? SqlSession又是如何跟线程绑定的呢?</p>\n<h2 id=\"_5-1-sqlsession是如何跟线程绑定的呢\"> 5.1 SqlSession是如何跟线程绑定的呢?</h2>\n<p>通过TransactionSynchronizationManager中的ThreadLocal跟线程绑定<code>(new NamedThreadLocal&lt;&gt;(&quot;Transactional resources&quot;))</code>。注意: 如果主线程下创建子线程是不能绑定上的。</p>\n<div><pre><code><span>private</span> <span>static</span> <span>void</span> <span>registerSessionHolder</span><span>(</span><span>SqlSessionFactory</span> sessionFactory<span>,</span> <span>ExecutorType</span> executorType<span>,</span>\n      <span>PersistenceExceptionTranslator</span> exceptionTranslator<span>,</span> <span>SqlSession</span> session<span>)</span> <span>{</span>\n        <span>SqlSessionHolder</span> holder <span>=</span> <span>new</span> <span>SqlSessionHolder</span><span>(</span>session<span>,</span> executorType<span>,</span> exceptionTranslator<span>)</span><span>;</span>\n        <span>TransactionSynchronizationManager</span><span>.</span><span>bindResource</span><span>(</span>sessionFactory<span>,</span> holder<span>)</span><span>;</span>\n        <span>TransactionSynchronizationManager</span>\n            <span>.</span><span>registerSynchronization</span><span>(</span><span>new</span> <span>SqlSessionSynchronization</span><span>(</span>holder<span>,</span> sessionFactory<span>)</span><span>)</span><span>;</span>\n        holder<span>.</span><span>setSynchronizedWithTransaction</span><span>(</span><span>true</span><span>)</span><span>;</span>\n        holder<span>.</span><span>requested</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id=\"_5-2-事务是如何嵌套的\"> 5.2 事务是如何嵌套的?</h2>\n<p>答案就在 <code>TransactionAspectSupport#TransactionInfo</code> 中。一个事务注解对应一个TransactionInfo,如果出现嵌套\n就会生成一个事务链。如下图一样。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1655110242000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>当里层的事务处理完成后会执行清理动作,同时在将第一个的事务在进行恢复跟线程绑定。</p>\n<div><pre><code>        <span>private</span> <span>void</span> <span>restoreThreadLocalStatus</span><span>(</span><span>)</span> <span>{</span>\n\t\t\t<span>// Use stack to restore old transaction TransactionInfo.</span>\n\t\t\t<span>// Will be null if none was set.</span>\n\t\t\ttransactionInfoHolder<span>.</span><span>set</span><span>(</span><span>this</span><span>.</span>oldTransactionInfo<span>)</span><span>;</span>\n\t\t<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"_5-3-事务是如何挂起的\"> 5.3 事务是如何挂起的?</h2>\n<p>前面知道每一个 <code>@Transaction</code> 注解会对应一个 <code>TransactionAspectSupport#TransactionInfo</code>。而事务挂起后,会先跟线程进行解绑。\n然后挂起的事务 <code>SuspendedResourcesHolder</code> 会被添加在 <code>TransactionStatus</code> 中。</p>\n<p><strong>挂起的数据保存在哪里</strong></p>\n<div><pre><code><span>protected</span> <span>final</span> <span>class</span> <span>TransactionInfo</span> <span>{</span>\n        <span>// 事务管理器</span>\n\t\t<span>@Nullable</span>\n\t\t<span>private</span> <span>final</span> <span>PlatformTransactionManager</span> transactionManager<span>;</span>\n        <span>// 事务信息</span>\n\t\t<span>@Nullable</span>\n\t\t<span>private</span> <span>final</span> <span>TransactionAttribute</span> transactionAttribute<span>;</span>\n        <span>// 切面点</span>\n\t\t<span>private</span> <span>final</span> <span>String</span> joinpointIdentification<span>;</span>\n\t\t<span>// DefaultTransactionStatus</span>\n\t\t<span>@Nullable</span>\n\t\t<span>private</span> <span>TransactionStatus</span> transactionStatus<span>;</span> \n\t\t<span>@Nullable</span>\n\t\t<span>private</span> <span>TransactionInfo</span> oldTransactionInfo<span>;</span>\n<span>}</span>\n\n<span>public</span> <span>class</span> <span>DefaultTransactionStatus</span> <span>extends</span> <span>AbstractTransactionStatus</span> <span>{</span>\n\t<span>@Nullable</span>\n\t<span>private</span> <span>final</span> <span>Object</span> transaction<span>;</span>\n\t<span>private</span> <span>final</span> <span>boolean</span> newTransaction<span>;</span>\n\t<span>private</span> <span>final</span> <span>boolean</span> newSynchronization<span>;</span>\n\t<span>private</span> <span>final</span> <span>boolean</span> readOnly<span>;</span>\n\t<span>private</span> <span>final</span> <span>boolean</span> debug<span>;</span>\n\t<span>@Nullable</span>\n\t<span>private</span> <span>final</span> <span>Object</span> suspendedResources<span>;</span>\n<span>}</span>\t\t\t\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p><strong>如何进行挂起的</strong></p>\n<p>TransactionSynchronization 事务同步器，为了解决事务的传播方式</p>\n<ul>\n<li>suspend 暂定事务,将事务从当前线程上解绑</li>\n<li>resume  恢复事务,将事务从新恢复到当前线程上</li>\n<li>beforeCommit 触发提交事务，执行commit</li>\n<li>beforeCompletion 事务提交后</li>\n<li>afterCommit 提交后</li>\n<li>afterCompletion 完成后调用</li>\n</ul>\n<p>SqlSessionSynchronization 也是跟当前线程绑定的</p>\n<ul>\n<li>位置 <code>TransactionSynchronizationManager#ThreadLocal&lt;Set&lt;TransactionSynchronization&gt;&gt; synchronizations</code></li>\n</ul>\n<div><pre><code> <span>// 挂起时候,将SqlSessionHolder与当前线程进行解绑</span>\n <span>@Override</span>\n <span>public</span> <span>void</span> <span>suspend</span><span>(</span><span>)</span> <span>{</span>\n   <span>if</span> <span>(</span><span>this</span><span>.</span>holderActive<span>)</span> <span>{</span>\n     LOGGER<span>.</span><span>debug</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>\"Transaction synchronization suspending SqlSession [\"</span> <span>+</span> <span>this</span><span>.</span>holder<span>.</span><span>getSqlSession</span><span>(</span><span>)</span> <span>+</span> <span>\"]\"</span><span>)</span><span>;</span>\n     <span>TransactionSynchronizationManager</span><span>.</span><span>unbindResource</span><span>(</span><span>this</span><span>.</span>sessionFactory<span>)</span><span>;</span>\n   <span>}</span>\n <span>}</span>\n\n <span>/**\n  * 恢复时候重新跟当前线程绑定\n  */</span>\n <span>@Override</span>\n <span>public</span> <span>void</span> <span>resume</span><span>(</span><span>)</span> <span>{</span>\n   <span>if</span> <span>(</span><span>this</span><span>.</span>holderActive<span>)</span> <span>{</span>\n     LOGGER<span>.</span><span>debug</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>\"Transaction synchronization resuming SqlSession [\"</span> <span>+</span> <span>this</span><span>.</span>holder<span>.</span><span>getSqlSession</span><span>(</span><span>)</span> <span>+</span> <span>\"]\"</span><span>)</span><span>;</span>\n     <span>TransactionSynchronizationManager</span><span>.</span><span>bindResource</span><span>(</span><span>this</span><span>.</span>sessionFactory<span>,</span> <span>this</span><span>.</span>holder<span>)</span><span>;</span>\n   <span>}</span>\n <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h2 id=\"_5-4-传播方式具体实现\"> 5.4 传播方式具体实现</h2>\n<p>下面这段代码就是事务注解的切面处理类，Spring事务的所有逻辑和扩展支持都在这里。</p>\n<ul>\n<li><code>TransactionAspectSupport#invokeWithinTransaction</code></li>\n</ul>\n<p><strong>首先我们先看整体的逻辑</strong></p>\n<ol>\n<li>获取当切面上的 <code>@Transaction</code> 注解信息</li>\n<li>根据注解信息找到指定的事务管理器,如果没有执行就使用默认的</li>\n<li>生成事务信息 <code>TransactionInfo</code> 传播机制,事务挂起都在这个类上</li>\n<li>失败执行回滚&amp;成功提交&amp;如果是嵌套事务,从<code>TransactionInfo</code> 中将挂起的事务重新跟线程进行绑定</li>\n</ol>\n<div><div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><div>&nbsp;</div><br><div>&nbsp;</div><br><br><br></div><pre><code><span>protected</span> <span>Object</span> <span>invokeWithinTransaction</span><span>(</span><span>Method</span> method<span>,</span> <span>@Nullable</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> targetClass<span>,</span>\n\t\t\t<span>final</span> <span>InvocationCallback</span> invocation<span>)</span> <span>throws</span> <span>Throwable</span> <span>{</span>\n\n\t\t<span>// If the transaction attribute is null, the method is non-transactional.</span>\n\t\t<span>TransactionAttributeSource</span> tas <span>=</span> <span>getTransactionAttributeSource</span><span>(</span><span>)</span><span>;</span>\n\t\t<span>// 获取被事务注解标记的事务信息</span>\n\t\t<span>final</span> <span>TransactionAttribute</span> txAttr <span>=</span> <span>(</span>tas <span>!=</span> <span>null</span> <span>?</span> tas<span>.</span><span>getTransactionAttribute</span><span>(</span>method<span>,</span> targetClass<span>)</span> <span>:</span> <span>null</span><span>)</span><span>;</span>\n\t\t<span>// 根据事务注解上指定的事务管理器名称,去系统中获取，如果没有就拿系统中默认的事务管理器</span>\n\t\t<span>final</span> <span>PlatformTransactionManager</span> tm <span>=</span> <span>determineTransactionManager</span><span>(</span>txAttr<span>)</span><span>;</span>\n\t\t<span>// 切面拦截点: com.alibaba.purchase.domain.replenish.impl.ReplenishDomainWriteServiceImpl.mockSave</span>\n\t\t<span>final</span> <span>String</span> joinpointIdentification <span>=</span> <span>methodIdentification</span><span>(</span>method<span>,</span> targetClass<span>,</span> txAttr<span>)</span><span>;</span>\n        <span>// 这里只看关系型数据的的事务逻辑。CallbackPreferringPlatformTransactionManager是具有回调性质的事务管理器,多用于处理自定的事务</span>\n\t\t<span>if</span> <span>(</span>txAttr <span>==</span> <span>null</span> <span>||</span> <span>!</span><span>(</span>tm <span>instanceof</span> <span>CallbackPreferringPlatformTransactionManager</span><span>)</span><span>)</span> <span>{</span>\n\t\t\t<span>// Standard transaction demarcation with getTransaction and commit/rollback calls.</span>\n\t\t\t<span>// 获取事务的信息,包含传播方式</span>\n\t\t\t<span>TransactionInfo</span> txInfo <span>=</span> <span>createTransactionIfNecessary</span><span>(</span>tm<span>,</span> txAttr<span>,</span> joinpointIdentification<span>)</span><span>;</span>\n\t\t\t<span>Object</span> retVal <span>=</span> <span>null</span><span>;</span>\n\t\t\t<span>try</span> <span>{</span>\n\t\t\t\t<span>// This is an around advice: Invoke the next interceptor in the chain.</span>\n\t\t\t\t<span>// This will normally result in a target object being invoked.</span>\n\t\t\t\tretVal <span>=</span> invocation<span>.</span><span>proceedWithInvocation</span><span>(</span><span>)</span><span>;</span>\n\t\t\t<span>}</span>\n\t\t\t<span>catch</span> <span>(</span><span>Throwable</span> ex<span>)</span> <span>{</span>\n\t\t\t\t<span>// target invocation exception</span>\n\t\t\t\t<span>completeTransactionAfterThrowing</span><span>(</span>txInfo<span>,</span> ex<span>)</span><span>;</span>\n\t\t\t\t<span>throw</span> ex<span>;</span>\n\t\t\t<span>}</span>\n\t\t\t<span>finally</span> <span>{</span>\n\t\t\t\t<span>cleanupTransactionInfo</span><span>(</span>txInfo<span>)</span><span>;</span>\n\t\t\t<span>}</span>\n\t\t\t<span>commitTransactionAfterReturning</span><span>(</span>txInfo<span>)</span><span>;</span>\n\t\t\t<span>return</span> retVal<span>;</span>\n\t\t<span>}</span>\n<span>}</span>\t\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><p><strong>这里只看传播机制吧。AbstractPlatformTransactionManager#handleExistingTransaction</strong></p>\n<ul>\n<li>TransactionDefinition.PROPAGATION_NEVER 如果存在事务就报错</li>\n<li>TransactionDefinition.PROPAGATION_NOT_SUPPORTED 如果有事务,就挂起(当前事务跟线程解绑)。不使用事务进行执行。</li>\n<li>TransactionDefinition.PROPAGATION_REQUIRES_NEW 当前事务挂起,新开个事务。</li>\n</ul>\n<div><pre><code>     <span>/**\n\t * Create a TransactionStatus for an existing transaction.\n\t */</span>\n\t<span>private</span> <span>TransactionStatus</span> <span>handleExistingTransaction</span><span>(</span>\n\t\t\t<span>TransactionDefinition</span> definition<span>,</span> <span>Object</span> transaction<span>,</span> <span>boolean</span> debugEnabled<span>)</span>\n\t\t\t<span>throws</span> <span>TransactionException</span> <span>{</span>\n        <span>// TransactionDefinition.PROPAGATION_NEVER（总是非事务地执行，如果存在一个活动事务，则抛出异常）就直接阻断报错</span>\n\t\t<span>if</span> <span>(</span>definition<span>.</span><span>getPropagationBehavior</span><span>(</span><span>)</span> <span>==</span> <span>TransactionDefinition</span><span>.</span>PROPAGATION_NEVER<span>)</span> <span>{</span>\n\t\t\t<span>throw</span> <span>new</span> <span>IllegalTransactionStateException</span><span>(</span>\n\t\t\t\t\t<span>\"Existing transaction found for transaction marked with propagation 'never'\"</span><span>)</span><span>;</span>\n\t\t<span>}</span>\n        <span>// TransactionDefinition.PROPAGATION_NOT_SUPPORTED 总是非事务地执行，并挂起任何存在的事务</span>\n\t\t<span>if</span> <span>(</span>definition<span>.</span><span>getPropagationBehavior</span><span>(</span><span>)</span> <span>==</span> <span>TransactionDefinition</span><span>.</span>PROPAGATION_NOT_SUPPORTED<span>)</span> <span>{</span>\n\t\t\t<span>if</span> <span>(</span>debugEnabled<span>)</span> <span>{</span>\n\t\t\t\tlogger<span>.</span><span>debug</span><span>(</span><span>\"Suspending current transaction\"</span><span>)</span><span>;</span>\n\t\t\t<span>}</span>\n\t\t\t<span>Object</span> suspendedResources <span>=</span> <span>suspend</span><span>(</span>transaction<span>)</span><span>;</span>\n\t\t\t<span>boolean</span> newSynchronization <span>=</span> <span>(</span><span>getTransactionSynchronization</span><span>(</span><span>)</span> <span>==</span> SYNCHRONIZATION_ALWAYS<span>)</span><span>;</span>\n\t\t\t<span>// 数据暂存在TransactionSynchronizationManager#synchronizations同步器中</span>\n\t\t\t<span>return</span> <span>prepareTransactionStatus</span><span>(</span>\n\t\t\t\t\tdefinition<span>,</span> <span>null</span><span>,</span> <span>false</span><span>,</span> newSynchronization<span>,</span> debugEnabled<span>,</span> suspendedResources<span>)</span><span>;</span>\n\t\t<span>}</span>\n        <span>// 总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起。</span>\n\t\t<span>if</span> <span>(</span>definition<span>.</span><span>getPropagationBehavior</span><span>(</span><span>)</span> <span>==</span> <span>TransactionDefinition</span><span>.</span>PROPAGATION_REQUIRES_NEW<span>)</span> <span>{</span>\n\t\t\t<span>if</span> <span>(</span>debugEnabled<span>)</span> <span>{</span>\n\t\t\t\tlogger<span>.</span><span>debug</span><span>(</span><span>\"Suspending current transaction, creating new transaction with name [\"</span> <span>+</span>\n\t\t\t\t\t\tdefinition<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\"]\"</span><span>)</span><span>;</span>\n\t\t\t<span>}</span>\n\t\t\t<span>SuspendedResourcesHolder</span> suspendedResources <span>=</span> <span>suspend</span><span>(</span>transaction<span>)</span><span>;</span>\n\t\t\t<span>try</span> <span>{</span>\n\t\t\t\t<span>boolean</span> newSynchronization <span>=</span> <span>(</span><span>getTransactionSynchronization</span><span>(</span><span>)</span> <span>!=</span> SYNCHRONIZATION_NEVER<span>)</span><span>;</span>\n\t\t\t\t<span>DefaultTransactionStatus</span> status <span>=</span> <span>newTransactionStatus</span><span>(</span>\n\t\t\t\t\t\tdefinition<span>,</span> transaction<span>,</span> <span>true</span><span>,</span> newSynchronization<span>,</span> debugEnabled<span>,</span> suspendedResources<span>)</span><span>;</span>\n\t\t\t\t<span>doBegin</span><span>(</span>transaction<span>,</span> definition<span>)</span><span>;</span>\n\t\t\t\t<span>prepareSynchronization</span><span>(</span>status<span>,</span> definition<span>)</span><span>;</span>\n\t\t\t\t<span>return</span> status<span>;</span>\n\t\t\t<span>}</span>\n\t\t\t<span>catch</span> <span>(</span><span>RuntimeException</span> <span>|</span> <span>Error</span> beginEx<span>)</span> <span>{</span>\n\t\t\t\t<span>resumeAfterBeginException</span><span>(</span>transaction<span>,</span> suspendedResources<span>,</span> beginEx<span>)</span><span>;</span>\n\t\t\t\t<span>throw</span> beginEx<span>;</span>\n\t\t\t<span>}</span>\n\t\t<span>}</span>\n        <span>// 如果有事务存在，则运行在一个嵌套的事务中. 如果没有活动事务则按TransactionDefinition.PROPAGATION_REQUIRED 属性执行</span>\n\t\t<span>if</span> <span>(</span>definition<span>.</span><span>getPropagationBehavior</span><span>(</span><span>)</span> <span>==</span> <span>TransactionDefinition</span><span>.</span>PROPAGATION_NESTED<span>)</span> <span>{</span>\n\t\t\t<span>if</span> <span>(</span><span>!</span><span>isNestedTransactionAllowed</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n\t\t\t\t<span>throw</span> <span>new</span> <span>NestedTransactionNotSupportedException</span><span>(</span>\n\t\t\t\t\t\t<span>\"Transaction manager does not allow nested transactions by default - \"</span> <span>+</span>\n\t\t\t\t\t\t<span>\"specify 'nestedTransactionAllowed' property with value 'true'\"</span><span>)</span><span>;</span>\n\t\t\t<span>}</span>\n\t\t\t<span>if</span> <span>(</span>debugEnabled<span>)</span> <span>{</span>\n\t\t\t\tlogger<span>.</span><span>debug</span><span>(</span><span>\"Creating nested transaction with name [\"</span> <span>+</span> definition<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\"]\"</span><span>)</span><span>;</span>\n\t\t\t<span>}</span>\n\t\t\t<span>if</span> <span>(</span><span>useSavepointForNestedTransaction</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n\t\t\t\t<span>// Create savepoint within existing Spring-managed transaction,</span>\n\t\t\t\t<span>// through the SavepointManager API implemented by TransactionStatus.</span>\n\t\t\t\t<span>// Usually uses JDBC 3.0 savepoints. Never activates Spring synchronization.</span>\n\t\t\t\t<span>DefaultTransactionStatus</span> status <span>=</span>\n\t\t\t\t\t\t<span>prepareTransactionStatus</span><span>(</span>definition<span>,</span> transaction<span>,</span> <span>false</span><span>,</span> <span>false</span><span>,</span> debugEnabled<span>,</span> <span>null</span><span>)</span><span>;</span>\n\t\t\t\t<span>// 使用当前事务,并增加当前事务的一次引用。\t\t</span>\n\t\t\t\tstatus<span>.</span><span>createAndHoldSavepoint</span><span>(</span><span>)</span><span>;</span>\n\t\t\t\t<span>return</span> status<span>;</span>\n\t\t\t<span>}</span>\n\t\t\t<span>else</span> <span>{</span>\n\t\t\t\t<span>// Nested transaction through nested begin and commit/rollback calls.</span>\n\t\t\t\t<span>// Usually only for JTA: Spring synchronization might get activated here</span>\n\t\t\t\t<span>// in case of a pre-existing JTA transaction.</span>\n\t\t\t\t<span>// 没有新建一个事务</span>\n\t\t\t\t<span>boolean</span> newSynchronization <span>=</span> <span>(</span><span>getTransactionSynchronization</span><span>(</span><span>)</span> <span>!=</span> SYNCHRONIZATION_NEVER<span>)</span><span>;</span>\n\t\t\t\t<span>DefaultTransactionStatus</span> status <span>=</span> <span>newTransactionStatus</span><span>(</span>\n\t\t\t\t\t\tdefinition<span>,</span> transaction<span>,</span> <span>true</span><span>,</span> newSynchronization<span>,</span> debugEnabled<span>,</span> <span>null</span><span>)</span><span>;</span>\n\t\t\t\t<span>doBegin</span><span>(</span>transaction<span>,</span> definition<span>)</span><span>;</span>\n\t\t\t\t<span>prepareSynchronization</span><span>(</span>status<span>,</span> definition<span>)</span><span>;</span>\n\t\t\t\t<span>return</span> status<span>;</span>\n\t\t\t<span>}</span>\n\t\t<span>}</span>\n\n\t\t<span>// Assumably PROPAGATION_SUPPORTS or PROPAGATION_REQUIRED.</span>\n\t\t<span>if</span> <span>(</span>debugEnabled<span>)</span> <span>{</span>\n\t\t\tlogger<span>.</span><span>debug</span><span>(</span><span>\"Participating in existing transaction\"</span><span>)</span><span>;</span>\n\t\t<span>}</span>\n\t\t<span>if</span> <span>(</span><span>isValidateExistingTransaction</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n\t\t\t<span>if</span> <span>(</span>definition<span>.</span><span>getIsolationLevel</span><span>(</span><span>)</span> <span>!=</span> <span>TransactionDefinition</span><span>.</span>ISOLATION_DEFAULT<span>)</span> <span>{</span>\n\t\t\t\t<span>Integer</span> currentIsolationLevel <span>=</span> <span>TransactionSynchronizationManager</span><span>.</span><span>getCurrentTransactionIsolationLevel</span><span>(</span><span>)</span><span>;</span>\n\t\t\t\t<span>if</span> <span>(</span>currentIsolationLevel <span>==</span> <span>null</span> <span>||</span> currentIsolationLevel <span>!=</span> definition<span>.</span><span>getIsolationLevel</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n\t\t\t\t\t<span>Constants</span> isoConstants <span>=</span> <span>DefaultTransactionDefinition</span><span>.</span>constants<span>;</span>\n\t\t\t\t\t<span>throw</span> <span>new</span> <span>IllegalTransactionStateException</span><span>(</span><span>\"Participating transaction with definition [\"</span> <span>+</span>\n\t\t\t\t\t\t\tdefinition <span>+</span> <span>\"] specifies isolation level which is incompatible with existing transaction: \"</span> <span>+</span>\n\t\t\t\t\t\t\t<span>(</span>currentIsolationLevel <span>!=</span> <span>null</span> <span>?</span>\n\t\t\t\t\t\t\t\t\tisoConstants<span>.</span><span>toCode</span><span>(</span>currentIsolationLevel<span>,</span> <span>DefaultTransactionDefinition</span><span>.</span>PREFIX_ISOLATION<span>)</span> <span>:</span>\n\t\t\t\t\t\t\t\t\t<span>\"(unknown)\"</span><span>)</span><span>)</span><span>;</span>\n\t\t\t\t<span>}</span>\n\t\t\t<span>}</span>\n\t\t\t<span>if</span> <span>(</span><span>!</span>definition<span>.</span><span>isReadOnly</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n\t\t\t\t<span>if</span> <span>(</span><span>TransactionSynchronizationManager</span><span>.</span><span>isCurrentTransactionReadOnly</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n\t\t\t\t\t<span>throw</span> <span>new</span> <span>IllegalTransactionStateException</span><span>(</span><span>\"Participating transaction with definition [\"</span> <span>+</span>\n\t\t\t\t\t\t\tdefinition <span>+</span> <span>\"] is not marked as read-only but existing transaction is\"</span><span>)</span><span>;</span>\n\t\t\t\t<span>}</span>\n\t\t\t<span>}</span>\n\t\t<span>}</span>\n\t\t<span>// </span>\n\t\t<span>boolean</span> newSynchronization <span>=</span> <span>(</span><span>getTransactionSynchronization</span><span>(</span><span>)</span> <span>!=</span> SYNCHRONIZATION_NEVER<span>)</span><span>;</span>\n\t\t<span>return</span> <span>prepareTransactionStatus</span><span>(</span>definition<span>,</span> transaction<span>,</span> <span>false</span><span>,</span> newSynchronization<span>,</span> debugEnabled<span>,</span> <span>null</span><span>)</span><span>;</span>\n\t<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br></div></div><h2 id=\"_5-5-嵌套事务如何知道是否要提交\"> 5.5 嵌套事务如何知道是否要提交</h2>\n<p>当两个Mapper中使用的是同一个SqlSession,那么会不会第二个事务在执行后,就直接commit了呢,此时第一个事务有一次commit。导致异常呢?</p>\n<p>解决方案在这里 <code>DefaultTransactionStatus</code></p>\n<p>第二个事务状态中</p>\n<ul>\n<li>newTransaction = false</li>\n<li>newSynchronization = false\n<img src=\"https://img.springlearn.cn/blog/learn_1655202764000.png\" alt=\"\" loading=\"lazy\"></li>\n</ul>\n<p>而下面代码中会做校验,只需要同步时候才会提交事务。</p>\n<div><pre><code><span>protected</span> <span>final</span> <span>void</span> <span>triggerBeforeCommit</span><span>(</span><span>DefaultTransactionStatus</span> status<span>)</span> <span>{</span>\n\t\t<span>if</span> <span>(</span>status<span>.</span><span>isNewSynchronization</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n\t\t\t<span>if</span> <span>(</span>status<span>.</span><span>isDebug</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n\t\t\t\tlogger<span>.</span><span>trace</span><span>(</span><span>\"Triggering beforeCommit synchronization\"</span><span>)</span><span>;</span>\n\t\t\t<span>}</span>\n\t\t\t<span>TransactionSynchronizationUtils</span><span>.</span><span>triggerBeforeCommit</span><span>(</span>status<span>.</span><span>isReadOnly</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\t\t<span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>第一个事务状态中</p>\n<ul>\n<li>newTransaction = true</li>\n<li>newSynchronization = true\n才会真正的去执行。\n<img src=\"https://img.springlearn.cn/blog/learn_1655203089000.png\" alt=\"\" loading=\"lazy\"></li>\n</ul>\n<h2 id=\"_5-6-这样设计是否线程安全\"> 5.6 这样设计是否线程安全</h2>\n<p>线程安全只有在多线程环境下才会出现。那么这里一定会有多线程问题。而事务是跟线程进行绑定的,所以这里虽然有多线程但是不会有线程安全问题。</p>\n<p>但是这里我们看源码线程绑定时候使用的ThreadLocal,所以你在线程中创建子线程或者是线程中使用线程池,这里的事务都不会共享的。</p>\n",
      "image": "https://img.springlearn.cn/learn_4b3a9611962ebf20587584574ecb05ec.png",
      "date_published": "2022-07-12T12:38:40.000Z",
      "date_modified": "2022-07-12T12:38:40.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Mybatis"
      ]
    },
    {
      "title": "第10篇:Mybatis的插件设计分析",
      "url": "https://java.springlearn.cn/learn/mybatis/%E6%8F%92%E4%BB%B6%E5%88%86%E6%9E%90/",
      "id": "https://java.springlearn.cn/learn/mybatis/%E6%8F%92%E4%BB%B6%E5%88%86%E6%9E%90/",
      "content_html": "<PageBanner/>\n<p>参考文档: <a href=\"https://mybatis.org/mybatis-3/zh/configuration.html#plugins\" target=\"_blank\" rel=\"noopener noreferrer\">官方文档</a></p>\n<h2 id=\"一、-插件设计介绍\"> 一、 插件设计介绍</h2>\n<p>Mybatis 中的插件都是通过代理方式来实现的,通过拦截执行器中指定的方法来达到改变核心执行代码的方式。举一个列子,查询方法核心都是通过 Executor来进行sql执行的。那么我们就可以通过拦截下面的方法来改变核心代码。基本原理就是这样,下面我们在来看 Mybatis 是如何处理插件。</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>Executor</span> <span>{</span>\n\n  <span>ResultHandler</span> NO_RESULT_HANDLER <span>=</span> <span>null</span><span>;</span>\n\n  <span>int</span> <span>update</span><span>(</span><span>MappedStatement</span> ms<span>,</span> <span>Object</span> parameter<span>)</span> <span>throws</span> <span>SQLException</span><span>;</span>\n\n  <span><span>&lt;</span><span>E</span><span>></span></span> <span>List</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>query</span><span>(</span><span>MappedStatement</span> ms<span>,</span> <span>Object</span> parameter<span>,</span> <span>RowBounds</span> rowBounds<span>,</span> <span>ResultHandler</span> resultHandler<span>,</span> <span>CacheKey</span> cacheKey<span>,</span> <span>BoundSql</span> boundSql<span>)</span> <span>throws</span> <span>SQLException</span><span>;</span>\n\n  <span><span>&lt;</span><span>E</span><span>></span></span> <span>List</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>query</span><span>(</span><span>MappedStatement</span> ms<span>,</span> <span>Object</span> parameter<span>,</span> <span>RowBounds</span> rowBounds<span>,</span> <span>ResultHandler</span> resultHandler<span>)</span> <span>throws</span> <span>SQLException</span><span>;</span>\n\n  <span><span>&lt;</span><span>E</span><span>></span></span> <span>Cursor</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>queryCursor</span><span>(</span><span>MappedStatement</span> ms<span>,</span> <span>Object</span> parameter<span>,</span> <span>RowBounds</span> rowBounds<span>)</span> <span>throws</span> <span>SQLException</span><span>;</span>\n  <span>.</span><span>.</span><span>.</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p><img src=\"https://img-blog.csdnimg.cn/20191224102308710.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" loading=\"lazy\"></p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>Interceptor</code></td>\n<td>接口</td>\n<td>插件都需要实现的接口,封装代理执行方法及参数信息</td>\n</tr>\n<tr>\n<td><code>InterceptorChain</code></td>\n<td>类</td>\n<td>拦截链</td>\n</tr>\n<tr>\n<td><code>InvocationHandler</code></td>\n<td>接口</td>\n<td>JDK代理的接口,凡是JDK中的代理都要实现该接口</td>\n</tr>\n<tr>\n<td><code>@Intercepts</code></td>\n<td>注解</td>\n<td>用于声明要代理和 <code>@Signature</code> 配合使用</td>\n</tr>\n<tr>\n<td><code>@Signature</code></td>\n<td>注解</td>\n<td>用于声明要代理拦截的方法</td>\n</tr>\n<tr>\n<td><code>Plugin</code></td>\n<td>类</td>\n<td>代理的具体生成类</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"_1-1-interceptor\"> 1.1 Interceptor</h2>\n<p>插件都需要实现的接口,封装代理执行方法及参数信息</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>Interceptor</span> <span>{</span>\n    <span>// 执行方法体的封装,所有的拦截方法逻辑都在这里面写。</span>\n  <span>Object</span> <span>intercept</span><span>(</span><span>Invocation</span> invocation<span>)</span> <span>throws</span> <span>Throwable</span><span>;</span>\n    <span>// 如果要代理,就用Plugin.wrap(...),如果不代理就原样返回</span>\n  <span>Object</span> <span>plugin</span><span>(</span><span>Object</span> target<span>)</span><span>;</span>\n    <span>// 可以添加配置,主要是xml配置时候可以从xml中读取配置信息到拦截器里面自己解析</span>\n  <span>void</span> <span>setProperties</span><span>(</span><span>Properties</span> properties<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id=\"_1-2-interceptorchain\"> 1.2 InterceptorChain</h2>\n<p>拦截链,为什么需要拦截链,假如我们要对A进行代理, 具体的代理类有B和C。 我们要同时将B和C的逻辑都放到代理类里面，那我们会首先将A和B生成代理类,然后在前面生成代理的基础上将C和前面生成的代理类在生成一个代理对象。这个类就是要做这件事 <code>pluginAll</code></p>\n<div><pre><code><span>public</span> <span>class</span> <span>InterceptorChain</span> <span>{</span>\n\n  <span>private</span> <span>final</span> <span>List</span><span><span>&lt;</span><span>Interceptor</span><span>></span></span> interceptors <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>Interceptor</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n  \n  <span>// 这里target就是A,而List中的Interceptor就相当于B和C,通过循环方式生成统一代理类</span>\n  <span>public</span> <span>Object</span> <span>pluginAll</span><span>(</span><span>Object</span> target<span>)</span> <span>{</span>\n    <span>for</span> <span>(</span><span>Interceptor</span> interceptor <span>:</span> interceptors<span>)</span> <span>{</span>\n      <span>//1. 是否需要代理,需要代理生成代理类放回,不需要原样返回。通过for循环的方式将所有对应的插件整合成一个代理对象</span>\n      target <span>=</span> interceptor<span>.</span><span>plugin</span><span>(</span>target<span>)</span><span>;</span>\n    <span>}</span>\n    <span>return</span> target<span>;</span>\n  <span>}</span>\n  <span>.</span><span>.</span><span>.</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h2 id=\"_1-3-invocationhandler\"> 1.3 InvocationHandler</h2>\n<p>JDK代理的接口,凡是JDK中的代理都要实现该接口。这个比较基础，如果这个不清楚,那么代理就看不懂了。所以就不说了。</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>InvocationHandler</span> <span>{</span>\n      <span>public</span> <span>Object</span> <span>invoke</span><span>(</span><span>Object</span> proxy<span>,</span> <span>Method</span> method<span>,</span> <span>Object</span><span>[</span><span>]</span> args<span>)</span>\n        <span>throws</span> <span>Throwable</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id=\"_1-4-intercepts-和-signature\"> 1.4 <code>@Intercepts</code> 和 <code>@Signature</code></h2>\n<p>这两个注解是配合使用的,用于指定要代理的类和方法。前面①说了,插件的核心逻辑是拦截执行器的方法,那么这里我们看下如何声明要拦截的类和方法。我们看一下分页插件如何声明拦截。</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>type</td>\n<td>就是要拦截的类(Executor/ParameterHandler/ResultSetHandler/StatementHandler)</td>\n</tr>\n<tr>\n<td>method</td>\n<td>要拦截的方法</td>\n</tr>\n<tr>\n<td>args</td>\n<td>要拦截的方法的参数(因为有相同的方法,所以要指定拦截的方法和方法参数)</td>\n</tr>\n</tbody>\n</table>\n<div><pre><code><span>@Intercepts</span><span>(</span><span>@Signature</span><span>(</span>type <span>=</span> <span>Executor</span><span>.</span><span>class</span><span>,</span> method <span>=</span> <span>\"query\"</span><span>,</span> args <span>=</span> <span>{</span> <span>MappedStatement</span><span>.</span><span>class</span><span>,</span> <span>Object</span><span>.</span><span>class</span><span>,</span>\n        <span>RowBounds</span><span>.</span><span>class</span><span>,</span> <span>ResultHandler</span><span>.</span><span>class</span> <span>}</span><span>)</span><span>)</span>\n<span>public</span> <span>class</span> <span>MybatisPagerPlugin</span> <span>implements</span> <span>Interceptor</span> <span>{</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><code>args</code> 要拦截的方法的入参(因为有相同的方法,所以要指定拦截的方法和方法参数)，比如 <code>Executor</code> 中就有2个 <code>query</code> 方法。所以要通过args来确定要拦截哪一个。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20191224111008677.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" loading=\"lazy\"></p>\n<h2 id=\"_1-5-plugin\"> 1.5 Plugin</h2>\n<p>代理的具体生成类,解析 <code>@Intercepts</code> 和 <code>@Signature</code>  注解生成代理。</p>\n<p>我们看几个重要的方法。</p>\n<table>\n<thead>\n<tr>\n<th>方法名</th>\n<th>处理逻辑</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>getSignatureMap</td>\n<td>解析@Intercepts和@Signature,找到要拦截的方法</td>\n</tr>\n<tr>\n<td>getAllInterfaces</td>\n<td>找到代理类的接口,jdk代理必须要有接口</td>\n</tr>\n<tr>\n<td>invoke</td>\n<td>是否需要拦截判断</td>\n</tr>\n</tbody>\n</table>\n<div><pre><code><span>public</span> <span>class</span> <span>Plugin</span> <span>implements</span> <span>InvocationHandler</span> <span>{</span>\n  \n  <span>//解析@Intercepts和@Signature找到要拦截的方法</span>\n  <span>private</span> <span>static</span> <span>Map</span><span><span>&lt;</span><span>Class</span><span>&lt;</span><span>?</span><span>></span><span>,</span> <span>Set</span><span>&lt;</span><span>Method</span><span>></span><span>></span></span> <span>getSignatureMap</span><span>(</span><span>Interceptor</span> interceptor<span>)</span> <span>{</span>\n    <span>Intercepts</span> interceptsAnnotation <span>=</span> interceptor<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getAnnotation</span><span>(</span><span>Intercepts</span><span>.</span><span>class</span><span>)</span><span>;</span>\n    <span>// issue #251</span>\n    <span>if</span> <span>(</span>interceptsAnnotation <span>==</span> <span>null</span><span>)</span> <span>{</span>\n      <span>throw</span> <span>new</span> <span>PluginException</span><span>(</span><span>\"No @Intercepts annotation was found in interceptor \"</span> <span>+</span> interceptor<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>      \n    <span>}</span>\n    <span>Signature</span><span>[</span><span>]</span> sigs <span>=</span> interceptsAnnotation<span>.</span><span>value</span><span>(</span><span>)</span><span>;</span>\n    <span>Map</span><span><span>&lt;</span><span>Class</span><span>&lt;</span><span>?</span><span>></span><span>,</span> <span>Set</span><span>&lt;</span><span>Method</span><span>></span><span>></span></span> signatureMap <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>Class</span><span>&lt;</span><span>?</span><span>></span><span>,</span> <span>Set</span><span>&lt;</span><span>Method</span><span>></span><span>></span></span><span>(</span><span>)</span><span>;</span>\n    <span>for</span> <span>(</span><span>Signature</span> sig <span>:</span> sigs<span>)</span> <span>{</span>\n      <span>Set</span><span><span>&lt;</span><span>Method</span><span>></span></span> methods <span>=</span> signatureMap<span>.</span><span>get</span><span>(</span>sig<span>.</span><span>type</span><span>(</span><span>)</span><span>)</span><span>;</span>\n      <span>if</span> <span>(</span>methods <span>==</span> <span>null</span><span>)</span> <span>{</span>\n        methods <span>=</span> <span>new</span> <span>HashSet</span><span><span>&lt;</span><span>Method</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        signatureMap<span>.</span><span>put</span><span>(</span>sig<span>.</span><span>type</span><span>(</span><span>)</span><span>,</span> methods<span>)</span><span>;</span>\n      <span>}</span>\n      <span>try</span> <span>{</span>\n        <span>//通过方法名和方法参数查找方法</span>\n        <span>Method</span> method <span>=</span> sig<span>.</span><span>type</span><span>(</span><span>)</span><span>.</span><span>getMethod</span><span>(</span>sig<span>.</span><span>method</span><span>(</span><span>)</span><span>,</span> sig<span>.</span><span>args</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        methods<span>.</span><span>add</span><span>(</span>method<span>)</span><span>;</span>\n      <span>}</span> <span>catch</span> <span>(</span><span>NoSuchMethodException</span> e<span>)</span> <span>{</span>\n        <span>throw</span> <span>new</span> <span>PluginException</span><span>(</span><span>\"Could not find method on \"</span> <span>+</span> sig<span>.</span><span>type</span><span>(</span><span>)</span> <span>+</span> <span>\" named \"</span> <span>+</span> sig<span>.</span><span>method</span><span>(</span><span>)</span> <span>+</span> <span>\". Cause: \"</span> <span>+</span> e<span>,</span> e<span>)</span><span>;</span>\n      <span>}</span>\n    <span>}</span>\n    <span>return</span> signatureMap<span>;</span>\n  <span>}</span>\n  \n  <span>//因为是jdk代理所以必须要有接口,如果没有接口,就不会生成代理</span>\n  <span>private</span> <span>static</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span><span>[</span><span>]</span> <span>getAllInterfaces</span><span>(</span><span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> type<span>,</span> <span>Map</span><span><span>&lt;</span><span>Class</span><span>&lt;</span><span>?</span><span>></span><span>,</span> <span>Set</span><span>&lt;</span><span>Method</span><span>></span><span>></span></span> signatureMap<span>)</span> <span>{</span>\n    <span>Set</span><span><span>&lt;</span><span>Class</span><span>&lt;</span><span>?</span><span>></span><span>></span></span> interfaces <span>=</span> <span>new</span> <span>HashSet</span><span><span>&lt;</span><span>Class</span><span>&lt;</span><span>?</span><span>></span><span>></span></span><span>(</span><span>)</span><span>;</span>\n    <span>while</span> <span>(</span>type <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n      <span>for</span> <span>(</span><span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> c <span>:</span> type<span>.</span><span>getInterfaces</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>signatureMap<span>.</span><span>containsKey</span><span>(</span>c<span>)</span><span>)</span> <span>{</span>\n          interfaces<span>.</span><span>add</span><span>(</span>c<span>)</span><span>;</span>\n        <span>}</span>\n      <span>}</span>\n      type <span>=</span> type<span>.</span><span>getSuperclass</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>return</span> interfaces<span>.</span><span>toArray</span><span>(</span><span>new</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span><span>[</span>interfaces<span>.</span><span>size</span><span>(</span><span>)</span><span>]</span><span>)</span><span>;</span>\n  <span>}</span>\n  \n  <span>@Override</span>\n  <span>public</span> <span>Object</span> <span>invoke</span><span>(</span><span>Object</span> proxy<span>,</span> <span>Method</span> method<span>,</span> <span>Object</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>Throwable</span> <span>{</span>\n    <span>try</span> <span>{</span>\n      <span>//执行时候看当前执行的方法是否需要被拦截,如果需要就调用拦截器中的方法</span>\n      <span>Set</span><span><span>&lt;</span><span>Method</span><span>></span></span> methods <span>=</span> signatureMap<span>.</span><span>get</span><span>(</span>method<span>.</span><span>getDeclaringClass</span><span>(</span><span>)</span><span>)</span><span>;</span>\n      <span>if</span> <span>(</span>methods <span>!=</span> <span>null</span> <span>&amp;&amp;</span> methods<span>.</span><span>contains</span><span>(</span>method<span>)</span><span>)</span> <span>{</span>\n        <span>return</span> interceptor<span>.</span><span>intercept</span><span>(</span><span>new</span> <span>Invocation</span><span>(</span>target<span>,</span> method<span>,</span> args<span>)</span><span>)</span><span>;</span>\n      <span>}</span>\n      <span>return</span> method<span>.</span><span>invoke</span><span>(</span>target<span>,</span> args<span>)</span><span>;</span>\n    <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n      <span>throw</span> <span>ExceptionUtil</span><span>.</span><span>unwrapThrowable</span><span>(</span>e<span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br></div></div><h2 id=\"二、问题总结\"> 二、问题总结</h2>\n<h2 id=\"_2-1-插件能拦截那些类\"> 2.1 插件能拦截那些类?</h2>\n<p>前面已经说过了，这里在总结下。这部分的源码在 <code>Configuration</code>。可以看到很简单只有一行。<code>InterceptorChain#pluginAll</code></p>\n<div><pre><code>  <span>public</span> <span>ParameterHandler</span> <span>newParameterHandler</span><span>(</span><span>MappedStatement</span> mappedStatement<span>,</span> <span>Object</span> parameterObject<span>,</span> <span>BoundSql</span> boundSql<span>)</span> <span>{</span>\n    <span>ParameterHandler</span> parameterHandler <span>=</span> mappedStatement<span>.</span><span>getLang</span><span>(</span><span>)</span><span>.</span><span>createParameterHandler</span><span>(</span>mappedStatement<span>,</span> parameterObject<span>,</span> boundSql<span>)</span><span>;</span>\n    parameterHandler <span>=</span> <span>(</span><span>ParameterHandler</span><span>)</span> interceptorChain<span>.</span><span>pluginAll</span><span>(</span>parameterHandler<span>)</span><span>;</span>\n    <span>return</span> parameterHandler<span>;</span>\n  <span>}</span>\n\n  <span>public</span> <span>ResultSetHandler</span> <span>newResultSetHandler</span><span>(</span><span>Executor</span> executor<span>,</span> <span>MappedStatement</span> mappedStatement<span>,</span> <span>RowBounds</span> rowBounds<span>,</span> <span>ParameterHandler</span> parameterHandler<span>,</span>\n      <span>ResultHandler</span> resultHandler<span>,</span> <span>BoundSql</span> boundSql<span>)</span> <span>{</span>\n    <span>ResultSetHandler</span> resultSetHandler <span>=</span> <span>new</span> <span>DefaultResultSetHandler</span><span>(</span>executor<span>,</span> mappedStatement<span>,</span> parameterHandler<span>,</span> resultHandler<span>,</span> boundSql<span>,</span> rowBounds<span>)</span><span>;</span>\n    resultSetHandler <span>=</span> <span>(</span><span>ResultSetHandler</span><span>)</span> interceptorChain<span>.</span><span>pluginAll</span><span>(</span>resultSetHandler<span>)</span><span>;</span>\n    <span>return</span> resultSetHandler<span>;</span>\n  <span>}</span>\n\n  <span>public</span> <span>StatementHandler</span> <span>newStatementHandler</span><span>(</span><span>Executor</span> executor<span>,</span> <span>MappedStatement</span> mappedStatement<span>,</span> <span>Object</span> parameterObject<span>,</span> <span>RowBounds</span> rowBounds<span>,</span> <span>ResultHandler</span> resultHandler<span>,</span> <span>BoundSql</span> boundSql<span>)</span> <span>{</span>\n    <span>StatementHandler</span> statementHandler <span>=</span> <span>new</span> <span>RoutingStatementHandler</span><span>(</span>executor<span>,</span> mappedStatement<span>,</span> parameterObject<span>,</span> rowBounds<span>,</span> resultHandler<span>,</span> boundSql<span>)</span><span>;</span>\n    statementHandler <span>=</span> <span>(</span><span>StatementHandler</span><span>)</span> interceptorChain<span>.</span><span>pluginAll</span><span>(</span>statementHandler<span>)</span><span>;</span>\n    <span>return</span> statementHandler<span>;</span>\n  <span>}</span>\n  \n  <span>public</span> <span>Executor</span> <span>newExecutor</span><span>(</span><span>Transaction</span> transaction<span>,</span> <span>ExecutorType</span> executorType<span>)</span> <span>{</span>\n    executorType <span>=</span> executorType <span>==</span> <span>null</span> <span>?</span> defaultExecutorType <span>:</span> executorType<span>;</span>\n    executorType <span>=</span> executorType <span>==</span> <span>null</span> <span>?</span> <span>ExecutorType</span><span>.</span>SIMPLE <span>:</span> executorType<span>;</span>\n    <span>Executor</span> executor<span>;</span>\n    <span>if</span> <span>(</span><span>ExecutorType</span><span>.</span>BATCH <span>==</span> executorType<span>)</span> <span>{</span>\n      executor <span>=</span> <span>new</span> <span>BatchExecutor</span><span>(</span><span>this</span><span>,</span> transaction<span>)</span><span>;</span>\n    <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>ExecutorType</span><span>.</span>REUSE <span>==</span> executorType<span>)</span> <span>{</span>\n      executor <span>=</span> <span>new</span> <span>ReuseExecutor</span><span>(</span><span>this</span><span>,</span> transaction<span>)</span><span>;</span>\n    <span>}</span> <span>else</span> <span>{</span>\n      executor <span>=</span> <span>new</span> <span>SimpleExecutor</span><span>(</span><span>this</span><span>,</span> transaction<span>)</span><span>;</span>\n    <span>}</span>\n    <span>if</span> <span>(</span>cacheEnabled<span>)</span> <span>{</span>\n      executor <span>=</span> <span>new</span> <span>CachingExecutor</span><span>(</span>executor<span>)</span><span>;</span>\n    <span>}</span>\n    executor <span>=</span> <span>(</span><span>Executor</span><span>)</span> interceptorChain<span>.</span><span>pluginAll</span><span>(</span>executor<span>)</span><span>;</span>\n    <span>return</span> executor<span>;</span>\n  <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><h3 id=\"_2-1-1-parameterhandler\"> 2.1.1 ParameterHandler</h3>\n<p>ParameterHandler的核心方法是setParameters()方法，该方法主要负责调用PreparedStatement的set*()方法为SQL语句绑定实参:\n这里能做到的扩展不多。</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>ParameterHandler</span> <span>{</span>\n  <span>// 对方法的入参进行处理,注意只有在 statementType=\"CALLABLE\" 生效</span>\n  <span>Object</span> <span>getParameterObject</span><span>(</span><span>)</span><span>;</span>\n  <span>// 预处理参数处理</span>\n  <span>void</span> <span>setParameters</span><span>(</span><span>PreparedStatement</span> ps<span>)</span> <span>throws</span> <span>SQLException</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>我们来实现一下,我们插入user信息,通过插件的方式修改入参。</p>\n<div><pre><code>    <span>/**\n     * 注意getParameterObject只会在 statementType=\"CALLABLE\"生效\n     * insert into T_USER (token_id, uid, name)\n     * values (#{tokenId,jdbcType=CHAR}, #{uid,jdbcType=INTEGER}, #{name,jdbcType=CHAR})\n     */</span>\n    <span>@Intercepts</span><span>(</span><span>@Signature</span><span>(</span>type <span>=</span> <span>ParameterHandler</span><span>.</span><span>class</span><span>,</span> method <span>=</span> <span>\"setParameters\"</span><span>,</span> args <span>=</span> <span>{</span><span>PreparedStatement</span><span>.</span><span>class</span><span>}</span><span>)</span><span>)</span>\n    <span>public</span> <span>static</span> <span>class</span> <span>ParameterInterceptor</span> <span>implements</span> <span>Interceptor</span> <span>{</span>\n        <span>@Override</span>\n        <span>public</span> <span>Object</span> <span>intercept</span><span>(</span><span>Invocation</span> invocation<span>)</span> <span>throws</span> <span>Throwable</span> <span>{</span>\n            <span>Object</span> proceed <span>=</span> invocation<span>.</span><span>proceed</span><span>(</span><span>)</span><span>;</span>\n            <span>PreparedStatement</span> preparedStatement <span>=</span> <span>(</span><span>PreparedStatement</span><span>)</span> invocation<span>.</span><span>getArgs</span><span>(</span><span>)</span><span>[</span><span>0</span><span>]</span><span>;</span>\n            <span>// 插入时候修改第三个参数,也就是name = 孙悟空</span>\n            <span>int</span> parameterCount <span>=</span> preparedStatement<span>.</span><span>getParameterMetaData</span><span>(</span><span>)</span><span>.</span><span>getParameterCount</span><span>(</span><span>)</span><span>;</span>\n            <span>if</span> <span>(</span>parameterCount <span>!=</span> <span>0</span><span>)</span> <span>{</span>\n                preparedStatement<span>.</span><span>setString</span><span>(</span><span>3</span><span>,</span> <span>\"孙悟空\"</span><span>)</span><span>;</span>\n            <span>}</span>\n            <span>return</span> proceed<span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>parameterHandler</span><span>(</span><span>)</span> <span>{</span>\n        <span>// 读取配置信息(为什么路径前不用加/,因为是相对路径。maven编译后的资源文件和class文件都是在一个包下,所以不用加/就是当前包目录)</span>\n        <span>InputStream</span> mapperInputStream <span>=</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getContextClassLoader</span><span>(</span><span>)</span><span>.</span><span>getResourceAsStream</span><span>(</span><span>\"mybatisConfig.xml\"</span><span>)</span><span>;</span>\n        <span>// 生成SqlSession工厂,SqlSession从名字上看就是,跟数据库交互的会话信息,负责将sql提交到数据库进行执行</span>\n        <span>SqlSessionFactory</span> sqlSessionFactory <span>=</span> <span>new</span> <span>SqlSessionFactoryBuilder</span><span>(</span><span>)</span><span>.</span><span>build</span><span>(</span>mapperInputStream<span>,</span> <span>\"development\"</span><span>)</span><span>;</span>\n        <span>// 获取Mybatis配置信息</span>\n        <span>Configuration</span> configuration <span>=</span> sqlSessionFactory<span>.</span><span>getConfiguration</span><span>(</span><span>)</span><span>;</span>\n        configuration<span>.</span><span>addInterceptor</span><span>(</span><span>new</span> <span>ParameterInterceptor</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// 参数: autoCommit,从名字上看就是是否自动提交事务</span>\n        <span>SqlSession</span> sqlSession <span>=</span> sqlSessionFactory<span>.</span><span>openSession</span><span>(</span><span>false</span><span>)</span><span>;</span>\n        <span>// 获取Mapper</span>\n        <span>TUserMapper</span> mapper <span>=</span> configuration<span>.</span><span>getMapperRegistry</span><span>(</span><span>)</span><span>.</span><span>getMapper</span><span>(</span><span>TUserMapper</span><span>.</span><span>class</span><span>,</span> sqlSession<span>)</span><span>;</span>\n        <span>TUser</span> tUser <span>=</span> <span>new</span> <span>TUser</span><span>(</span><span>)</span><span>;</span>\n        tUser<span>.</span><span>setName</span><span>(</span><span>\"唐三藏\"</span><span>)</span><span>;</span>\n        tUser<span>.</span><span>setTokenId</span><span>(</span><span>\"testTokenId1\"</span><span>)</span><span>;</span>\n        mapper<span>.</span><span>insert</span><span>(</span>tUser<span>)</span><span>;</span>\n        <span>// 这里虽然设置的名字是唐三藏，但是插件中修改为了孙悟空</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>mapper<span>.</span><span>selectAll</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// 数据插入后，执行查询，然后回滚数据</span>\n        sqlSession<span>.</span><span>rollback</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><h3 id=\"_2-1-2-resultsethandler\"> 2.1.2 ResultSetHandler</h3>\n<p>从名字就可以看出来是对结果集进行处理。这里我们通过插件的方式, 在查询语句中增加一条数据库原本不存在的数据。</p>\n<div><pre><code>    <span>/**\n     * 通过对list集合的数据进行修改,增加一条数据库不存在的数据\n     */</span>\n    <span>@Intercepts</span><span>(</span><span>@Signature</span><span>(</span>type <span>=</span> <span>ResultSetHandler</span><span>.</span><span>class</span><span>,</span> method <span>=</span> <span>\"handleResultSets\"</span><span>,</span> args <span>=</span> <span>{</span><span>Statement</span><span>.</span><span>class</span><span>}</span><span>)</span><span>)</span>\n    <span>public</span> <span>static</span> <span>class</span> <span>ResultSetHandlerInterceptor</span> <span>implements</span> <span>Interceptor</span> <span>{</span>\n        <span>@Override</span>\n        <span>public</span> <span>Object</span> <span>intercept</span><span>(</span><span>Invocation</span> invocation<span>)</span> <span>throws</span> <span>Throwable</span> <span>{</span>\n            <span>Object</span> proceed <span>=</span> invocation<span>.</span><span>proceed</span><span>(</span><span>)</span><span>;</span>\n            <span>if</span> <span>(</span>proceed <span>instanceof</span> <span>List</span><span>)</span> <span>{</span>\n                <span>ArrayList</span><span><span>&lt;</span><span>TUser</span><span>></span></span> newResult <span>=</span> <span>(</span><span>ArrayList</span><span><span>&lt;</span><span>TUser</span><span>></span></span><span>)</span> proceed<span>;</span>\n                <span>TUser</span> tUser <span>=</span> <span>new</span> <span>TUser</span><span>(</span><span>)</span><span>;</span>\n                tUser<span>.</span><span>setName</span><span>(</span><span>\"如来佛祖\"</span><span>)</span><span>;</span>\n                newResult<span>.</span><span>add</span><span>(</span>tUser<span>)</span><span>;</span>\n                proceed <span>=</span> newResult<span>;</span>\n            <span>}</span>\n            <span>return</span> proceed<span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>resultSetHandlerTest</span><span>(</span><span>)</span> <span>{</span>\n        <span>// 读取配置信息(为什么路径前不用加/,因为是相对路径。maven编译后的资源文件和class文件都是在一个包下,所以不用加/就是当前包目录)</span>\n        <span>InputStream</span> mapperInputStream <span>=</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getContextClassLoader</span><span>(</span><span>)</span><span>.</span><span>getResourceAsStream</span><span>(</span><span>\"mybatisConfig.xml\"</span><span>)</span><span>;</span>\n        <span>// 生成SqlSession工厂,SqlSession从名字上看就是,跟数据库交互的会话信息,负责将sql提交到数据库进行执行</span>\n        <span>SqlSessionFactory</span> sqlSessionFactory <span>=</span> <span>new</span> <span>SqlSessionFactoryBuilder</span><span>(</span><span>)</span><span>.</span><span>build</span><span>(</span>mapperInputStream<span>,</span> <span>\"development\"</span><span>)</span><span>;</span>\n        <span>// 获取Mybatis配置信息</span>\n        <span>Configuration</span> configuration <span>=</span> sqlSessionFactory<span>.</span><span>getConfiguration</span><span>(</span><span>)</span><span>;</span>\n        configuration<span>.</span><span>addInterceptor</span><span>(</span><span>new</span> <span>ResultSetHandlerInterceptor</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// 参数: autoCommit,从名字上看就是是否自动提交事务</span>\n        <span>SqlSession</span> sqlSession <span>=</span> sqlSessionFactory<span>.</span><span>openSession</span><span>(</span><span>false</span><span>)</span><span>;</span>\n        <span>// 获取Mapper</span>\n        <span>TUserMapper</span> mapper <span>=</span> configuration<span>.</span><span>getMapperRegistry</span><span>(</span><span>)</span><span>.</span><span>getMapper</span><span>(</span><span>TUserMapper</span><span>.</span><span>class</span><span>,</span> sqlSession<span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>mapper<span>.</span><span>selectAll</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// 数据插入后，执行查询，然后回滚数据</span>\n        sqlSession<span>.</span><span>rollback</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><h3 id=\"_2-1-3-statementhandler\"> 2.1.3 StatementHandler</h3>\n<div><pre><code>    <span>/**\n     * 我们本来是一条查询语句，我们打印下sql信息\n     */</span>\n    <span>@Intercepts</span><span>(</span><span>@Signature</span><span>(</span>type <span>=</span> <span>StatementHandler</span><span>.</span><span>class</span><span>,</span> method <span>=</span> <span>\"query\"</span><span>,</span> args <span>=</span> <span>{</span><span>Statement</span><span>.</span><span>class</span><span>,</span> <span>ResultHandler</span><span>.</span><span>class</span><span>}</span><span>)</span><span>)</span>\n    <span>public</span> <span>static</span> <span>class</span> <span>StatementHandlerInterceptor</span> <span>implements</span> <span>Interceptor</span> <span>{</span>\n\n        <span>@Override</span>\n        <span>public</span> <span>Object</span> <span>intercept</span><span>(</span><span>Invocation</span> invocation<span>)</span> <span>throws</span> <span>Throwable</span> <span>{</span>\n            <span>Object</span> proceed <span>=</span> invocation<span>.</span><span>proceed</span><span>(</span><span>)</span><span>;</span>\n            <span>Object</span><span>[</span><span>]</span> args <span>=</span> invocation<span>.</span><span>getArgs</span><span>(</span><span>)</span><span>;</span>\n            <span>if</span> <span>(</span>args<span>[</span><span>0</span><span>]</span> <span>instanceof</span> <span>ClientPreparedStatement</span><span>)</span> <span>{</span>\n                <span>ClientPreparedStatement</span> statement <span>=</span> <span>(</span><span>ClientPreparedStatement</span><span>)</span> args<span>[</span><span>0</span><span>]</span><span>;</span>\n                <span>if</span> <span>(</span>statement<span>.</span><span>getQuery</span><span>(</span><span>)</span> <span>instanceof</span> <span>ClientPreparedQuery</span><span>)</span> <span>{</span>\n                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>(</span><span>(</span><span>ClientPreparedQuery</span><span>)</span> statement<span>.</span><span>getQuery</span><span>(</span><span>)</span><span>)</span><span>.</span><span>getOriginalSql</span><span>(</span><span>)</span><span>)</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n            <span>return</span> proceed<span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>resultSetHandlerTest</span><span>(</span><span>)</span> <span>{</span>\n        <span>// 读取配置信息(为什么路径前不用加/,因为是相对路径。maven编译后的资源文件和class文件都是在一个包下,所以不用加/就是当前包目录)</span>\n        <span>InputStream</span> mapperInputStream <span>=</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getContextClassLoader</span><span>(</span><span>)</span><span>.</span><span>getResourceAsStream</span><span>(</span><span>\"mybatisConfig.xml\"</span><span>)</span><span>;</span>\n        <span>// 生成SqlSession工厂,SqlSession从名字上看就是,跟数据库交互的会话信息,负责将sql提交到数据库进行执行</span>\n        <span>SqlSessionFactory</span> sqlSessionFactory <span>=</span> <span>new</span> <span>SqlSessionFactoryBuilder</span><span>(</span><span>)</span><span>.</span><span>build</span><span>(</span>mapperInputStream<span>,</span> <span>\"development\"</span><span>)</span><span>;</span>\n        <span>// 获取Mybatis配置信息</span>\n        <span>Configuration</span> configuration <span>=</span> sqlSessionFactory<span>.</span><span>getConfiguration</span><span>(</span><span>)</span><span>;</span>\n        configuration<span>.</span><span>addInterceptor</span><span>(</span><span>new</span> <span>StatementHandlerInterceptor</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// 参数: autoCommit,从名字上看就是是否自动提交事务</span>\n        <span>SqlSession</span> sqlSession <span>=</span> sqlSessionFactory<span>.</span><span>openSession</span><span>(</span><span>false</span><span>)</span><span>;</span>\n        <span>// 获取Mapper</span>\n        <span>TUserMapper</span> mapper <span>=</span> configuration<span>.</span><span>getMapperRegistry</span><span>(</span><span>)</span><span>.</span><span>getMapper</span><span>(</span><span>TUserMapper</span><span>.</span><span>class</span><span>,</span> sqlSession<span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>mapper<span>.</span><span>selectAll</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// 数据插入后，执行查询，然后回滚数据</span>\n        sqlSession<span>.</span><span>rollback</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><h3 id=\"_2-1-4-executor\"> 2.1.4 Executor</h3>\n<p>Executor 是个好东西，从他能获取基本你能想到的所有信息。你可以在这里做sql动态变更、也可以做sql语句分析，同时也可以获取某个Mapper的签名信息。总之功能非常强大。一般的插件都是\n在这里做文章。如下面例子就是动态的修改了sql。</p>\n<div><pre><code>    <span>/**\n     * 动态修改sql信息。\n     * 这里因为我们知道要使用查询语句,所以不做sql分析。如果要学习sql分析请看其他文章\n     */</span>\n    <span>@Intercepts</span><span>(</span><span>@Signature</span><span>(</span>type <span>=</span> <span>Executor</span><span>.</span><span>class</span><span>,</span> method <span>=</span> <span>\"query\"</span><span>,</span>\n            args <span>=</span> <span>{</span><span>MappedStatement</span><span>.</span><span>class</span><span>,</span> <span>Object</span><span>.</span><span>class</span><span>,</span> <span>RowBounds</span><span>.</span><span>class</span><span>,</span> <span>ResultHandler</span><span>.</span><span>class</span><span>}</span><span>)</span><span>)</span>\n    <span>public</span> <span>static</span> <span>class</span> <span>ExecutorInterceptor</span> <span>implements</span> <span>Interceptor</span> <span>{</span>\n        <span>@Override</span>\n        <span>public</span> <span>Object</span> <span>intercept</span><span>(</span><span>Invocation</span> invocation<span>)</span> <span>throws</span> <span>Throwable</span> <span>{</span>\n            <span>Object</span><span>[</span><span>]</span> args <span>=</span> invocation<span>.</span><span>getArgs</span><span>(</span><span>)</span><span>;</span>\n            <span>if</span> <span>(</span>args<span>[</span><span>0</span><span>]</span> <span>instanceof</span> <span>MappedStatement</span><span>)</span> <span>{</span>\n                <span>MappedStatement</span> arg <span>=</span> <span>(</span><span>MappedStatement</span><span>)</span> args<span>[</span><span>0</span><span>]</span><span>;</span>\n                <span>Configuration</span> configuration <span>=</span> arg<span>.</span><span>getConfiguration</span><span>(</span><span>)</span><span>;</span>\n                <span>StaticSqlSource</span> staticSqlSource <span>=</span> <span>new</span> <span>StaticSqlSource</span><span>(</span>configuration<span>,</span> <span>\"select name from T_USER\"</span><span>)</span><span>;</span>\n                <span>Field</span> sqlSourceField <span>=</span> arg<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getDeclaredField</span><span>(</span><span>\"sqlSource\"</span><span>)</span><span>;</span>\n                sqlSourceField<span>.</span><span>setAccessible</span><span>(</span><span>true</span><span>)</span><span>;</span>\n                sqlSourceField<span>.</span><span>set</span><span>(</span>arg<span>,</span> staticSqlSource<span>)</span><span>;</span>\n            <span>}</span>\n            <span>return</span> invocation<span>.</span><span>proceed</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>executor</span><span>(</span><span>)</span> <span>{</span>\n        <span>// 读取配置信息(为什么路径前不用加/,因为是相对路径。maven编译后的资源文件和class文件都是在一个包下,所以不用加/就是当前包目录)</span>\n        <span>InputStream</span> mapperInputStream <span>=</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getContextClassLoader</span><span>(</span><span>)</span><span>.</span><span>getResourceAsStream</span><span>(</span><span>\"mybatisConfig.xml\"</span><span>)</span><span>;</span>\n        <span>// 生成SqlSession工厂,SqlSession从名字上看就是,跟数据库交互的会话信息,负责将sql提交到数据库进行执行</span>\n        <span>SqlSessionFactory</span> sqlSessionFactory <span>=</span> <span>new</span> <span>SqlSessionFactoryBuilder</span><span>(</span><span>)</span><span>.</span><span>build</span><span>(</span>mapperInputStream<span>,</span> <span>\"development\"</span><span>)</span><span>;</span>\n        <span>// 获取Mybatis配置信息</span>\n        <span>Configuration</span> configuration <span>=</span> sqlSessionFactory<span>.</span><span>getConfiguration</span><span>(</span><span>)</span><span>;</span>\n        configuration<span>.</span><span>addInterceptor</span><span>(</span><span>new</span> <span>ExecutorInterceptor</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// 参数: autoCommit,从名字上看就是是否自动提交事务</span>\n        <span>SqlSession</span> sqlSession <span>=</span> sqlSessionFactory<span>.</span><span>openSession</span><span>(</span><span>false</span><span>)</span><span>;</span>\n        <span>// 获取Mapper</span>\n        <span>TUserMapper</span> mapper <span>=</span> configuration<span>.</span><span>getMapperRegistry</span><span>(</span><span>)</span><span>.</span><span>getMapper</span><span>(</span><span>TUserMapper</span><span>.</span><span>class</span><span>,</span> sqlSession<span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>mapper<span>.</span><span>selectAll</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// 数据插入后，执行查询，然后回滚数据</span>\n        sqlSession<span>.</span><span>rollback</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div><h2 id=\"_2-2-如何定义一个拦截器\"> 2.2 如何定义一个拦截器?</h2>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>type</td>\n<td>就是要拦截的类(Executor/ParameterHandler/ResultSetHandler/StatementHandler)</td>\n</tr>\n<tr>\n<td>method</td>\n<td>要拦截的方法</td>\n</tr>\n<tr>\n<td>args</td>\n<td>要拦截的方法的参数(因为有相同的方法,所以要指定拦截的方法和方法参数)</td>\n</tr>\n</tbody>\n</table>\n<div><pre><code>    <span>@Intercepts</span><span>(</span><span>@Signature</span><span>(</span>type <span>=</span> <span>Executor</span><span>.</span><span>class</span><span>,</span> method <span>=</span> <span>\"query\"</span><span>,</span>\n            args <span>=</span> <span>{</span><span>MappedStatement</span><span>.</span><span>class</span><span>,</span> <span>Object</span><span>.</span><span>class</span><span>,</span> <span>RowBounds</span><span>.</span><span>class</span><span>,</span> <span>ResultHandler</span><span>.</span><span>class</span><span>}</span><span>)</span><span>)</span>\n    <span>public</span> <span>static</span> <span>class</span> <span>ExecutorInterceptor</span> <span>implements</span> <span>Interceptor</span> <span>{</span>\n        <span>@Override</span>\n        <span>public</span> <span>Object</span> <span>intercept</span><span>(</span><span>Invocation</span> invocation<span>)</span> <span>throws</span> <span>Throwable</span> <span>{</span>\n            <span>Object</span><span>[</span><span>]</span> args <span>=</span> invocation<span>.</span><span>getArgs</span><span>(</span><span>)</span><span>;</span>\n            <span>if</span> <span>(</span>args<span>[</span><span>0</span><span>]</span> <span>instanceof</span> <span>MappedStatement</span><span>)</span> <span>{</span>\n                <span>MappedStatement</span> arg <span>=</span> <span>(</span><span>MappedStatement</span><span>)</span> args<span>[</span><span>0</span><span>]</span><span>;</span>\n                <span>Configuration</span> configuration <span>=</span> arg<span>.</span><span>getConfiguration</span><span>(</span><span>)</span><span>;</span>\n                <span>StaticSqlSource</span> staticSqlSource <span>=</span> <span>new</span> <span>StaticSqlSource</span><span>(</span>configuration<span>,</span> <span>\"select name from T_USER\"</span><span>)</span><span>;</span>\n                <span>Field</span> sqlSourceField <span>=</span> arg<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getDeclaredField</span><span>(</span><span>\"sqlSource\"</span><span>)</span><span>;</span>\n                sqlSourceField<span>.</span><span>setAccessible</span><span>(</span><span>true</span><span>)</span><span>;</span>\n                sqlSourceField<span>.</span><span>set</span><span>(</span>arg<span>,</span> staticSqlSource<span>)</span><span>;</span>\n            <span>}</span>\n            <span>return</span> invocation<span>.</span><span>proceed</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h2 id=\"_2-3-插件的设计缺陷\"> 2.3 插件的设计缺陷</h2>\n<p><code>InterceptorChain</code> 的设计非常简单，里面就是一个list集合。但是在进行代理的时候，并没有顺序。假设我们要对sql进行代理。</p>\n<i>Not supported content</i>\n<ol>\n<li>第一个插件，我们在sql后加上 <code>where id &gt; 1</code></li>\n<li>第二个插件，我们在sql后机上 <code>limit 10</code></li>\n</ol>\n<p>按照我们设想的最终sql会变成 <code>select * from users where id &gt; 1 limit 10</code></p>\n<p>但是我们知道mybatis是没有顺序的, 那么很可能会出现最终的sql变成 <code>select * from user limit 10 where id &gt; 1</code>，此时就会报错。</p>\n<p>所以我们要注意这里。</p>\n<div><pre><code>  <span>public</span> <span>void</span> <span>addInterceptor</span><span>(</span><span>Interceptor</span> interceptor<span>)</span> <span>{</span>\n    interceptorChain<span>.</span><span>addInterceptor</span><span>(</span>interceptor<span>)</span><span>;</span>\n  <span>}</span>\n  <span>public</span> <span>StatementHandler</span> <span>newStatementHandler</span><span>(</span><span>Executor</span> executor<span>,</span> <span>MappedStatement</span> mappedStatement<span>,</span> <span>Object</span> parameterObject<span>,</span> <span>RowBounds</span> rowBounds<span>,</span> <span>ResultHandler</span> resultHandler<span>,</span> <span>BoundSql</span> boundSql<span>)</span> <span>{</span>\n    <span>StatementHandler</span> statementHandler <span>=</span> <span>new</span> <span>RoutingStatementHandler</span><span>(</span>executor<span>,</span> mappedStatement<span>,</span> parameterObject<span>,</span> rowBounds<span>,</span> resultHandler<span>,</span> boundSql<span>)</span><span>;</span>\n    statementHandler <span>=</span> <span>(</span><span>StatementHandler</span><span>)</span> interceptorChain<span>.</span><span>pluginAll</span><span>(</span>statementHandler<span>)</span><span>;</span>\n    <span>return</span> statementHandler<span>;</span>\n  <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id=\"三、可以借鉴的知识点\"> 三、可以借鉴的知识点</h2>\n<h2 id=\"_3-1-插件的设计模式\"> 3.1 插件的设计模式</h2>\n<p>拦截链 + 插件设计</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Test</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>InterceptorChain</span> chain <span>=</span> <span>new</span> <span>InterceptorChain</span><span>(</span><span>)</span><span>;</span>\n        <span>PrintInterceptor</span> printInterceptor <span>=</span> <span>new</span> <span>PrintInterceptor</span><span>(</span><span>)</span><span>;</span>\n        <span>Properties</span> properties <span>=</span> <span>new</span> <span>Properties</span><span>(</span><span>)</span><span>;</span>\n        properties<span>.</span><span>setProperty</span><span>(</span><span>\"name\"</span><span>,</span><span>\"https://blog.springlearn.cn\"</span><span>)</span><span>;</span>\n        printInterceptor<span>.</span><span>setProperties</span><span>(</span>properties<span>)</span><span>;</span>\n        chain<span>.</span><span>addInterceptor</span><span>(</span>printInterceptor<span>)</span><span>;</span>\n        <span>Animal</span> person <span>=</span> <span>(</span><span>Animal</span><span>)</span> chain<span>.</span><span>pluginAll</span><span>(</span><span>new</span> <span>Person</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>String</span> nihao <span>=</span> person<span>.</span><span>say</span><span>(</span><span>\"nihao\"</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>nihao<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>interface</span> <span>Animal</span><span>{</span>\n        <span>String</span> <span>say</span><span>(</span><span>String</span> message<span>)</span><span>;</span>\n        <span>String</span> <span>say</span><span>(</span><span>String</span> name<span>,</span> <span>String</span> message<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>class</span> <span>Person</span> <span>implements</span> <span>Animal</span> <span>{</span>\n        <span>public</span> <span>String</span> <span>say</span><span>(</span><span>String</span> message<span>)</span> <span>{</span>\n            <span>return</span> message<span>;</span>\n        <span>}</span>\n\n        <span>public</span> <span>String</span> <span>say</span><span>(</span><span>String</span> name<span>,</span> <span>String</span> message<span>)</span> <span>{</span>\n            <span>return</span> name <span>+</span> <span>\" say: \"</span> <span>+</span> message<span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>@Intercepts</span><span>(</span><span>@Signature</span><span>(</span>type <span>=</span> <span>Animal</span><span>.</span><span>class</span><span>,</span> method <span>=</span> <span>\"say\"</span><span>,</span> args <span>=</span> <span>{</span><span>String</span><span>.</span><span>class</span><span>}</span><span>)</span><span>)</span>\n    <span>public</span> <span>static</span> <span>class</span> <span>PrintInterceptor</span> <span>implements</span> <span>Interceptor</span> <span>{</span>\n        <span>private</span> <span>String</span> name<span>;</span>\n\n        <span>@Override</span>\n        <span>public</span> <span>Object</span> <span>intercept</span><span>(</span><span>Invocation</span> invocation<span>)</span> <span>throws</span> <span>Throwable</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>name <span>+</span> <span>\": before print ...\"</span><span>)</span><span>;</span>\n            <span>Object</span> proceed <span>=</span> invocation<span>.</span><span>proceed</span><span>(</span><span>)</span><span>;</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>name <span>+</span> <span>\": after print ...\"</span><span>)</span><span>;</span>\n            <span>return</span> proceed<span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div>",
      "image": "https://img-blog.csdnimg.cn/20191224102308710.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70",
      "date_published": "2022-03-28T15:13:45.000Z",
      "date_modified": "2022-07-12T12:38:40.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Mybatis"
      ]
    },
    {
      "title": "第06篇:Mybatis缓存设计",
      "url": "https://java.springlearn.cn/learn/mybatis/Mybatis%E4%B8%80%E7%BA%A7%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/",
      "id": "https://java.springlearn.cn/learn/mybatis/Mybatis%E4%B8%80%E7%BA%A7%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/",
      "content_html": "<p><a href=\"https://mybatis.net.cn/sqlmap-xml.html#cache\" target=\"_blank\" rel=\"noopener noreferrer\">官方文档</a></p>\n<div><p>提示</p>\n<p>MyBatis 内置了一个强大的事务性查询缓存机制，它可以非常方便地配置和定制。本篇文章，小编将会在最短的时间呢，通过观察源码来深刻了解Mybatis的\n一级二级缓存;然后在说如何定制。</p>\n</div>\n<h2 id=\"一、mybatis-cache设计\"> 一、Mybatis Cache设计</h2>\n<p>在Mybatis中所有的缓存,都是实现自Cache接口。无论是一级缓存还是二级缓存都是实现这个接口。其中一级缓存是本地缓存，二级缓存是一个允许开发者扩展的\n缓存(eg: ehcache/或者内置的很多缓存)。</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>Cache</span> <span>{</span>\n\n  <span>String</span> <span>getId</span><span>(</span><span>)</span><span>;</span>\n\n  <span>void</span> <span>putObject</span><span>(</span><span>Object</span> key<span>,</span> <span>Object</span> value<span>)</span><span>;</span>\n\n  <span>Object</span> <span>getObject</span><span>(</span><span>Object</span> key<span>)</span><span>;</span>\n\n  <span>Object</span> <span>removeObject</span><span>(</span><span>Object</span> key<span>)</span><span>;</span>\n\n  <span>void</span> <span>clear</span><span>(</span><span>)</span><span>;</span>\n\n  <span>int</span> <span>getSize</span><span>(</span><span>)</span><span>;</span>\n\n  <span>default</span> <span>ReadWriteLock</span> <span>getReadWriteLock</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>null</span><span>;</span>\n  <span>}</span>\n\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h2 id=\"二、一级缓存\"> 二、一级缓存</h2>\n<p>一级缓存是本地缓存,其实就是PerpetualCache这类,它的源码也很简单,其实就是一个Map而已。一般面试的经常说一级缓存称为\nSqlSession缓存,我们看其实最终实现是在BaseExecutor进行做的。就这么简单。</p>\n<div><pre><code><span>public</span> <span>abstract</span> <span>class</span> <span>BaseExecutor</span> <span>implements</span> <span>Executor</span> <span>{</span>\n\n    <span>// 一级缓存本地缓存</span>\n    <span>protected</span> <span>PerpetualCache</span> localCache<span>;</span>\n    \n    <span>protected</span> <span>BaseExecutor</span><span>(</span><span>Configuration</span> configuration<span>,</span> <span>Transaction</span> transaction<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>transaction <span>=</span> transaction<span>;</span>\n        <span>this</span><span>.</span>deferredLoads <span>=</span> <span>new</span> <span>ConcurrentLinkedQueue</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        <span>this</span><span>.</span>localCache <span>=</span> <span>new</span> <span>PerpetualCache</span><span>(</span><span>\"LocalCache\"</span><span>)</span><span>;</span>\n    <span>}</span>\n    \n    <span>// 执行查询后添加到一级缓存中</span>\n    <span>private</span> <span><span>&lt;</span><span>E</span><span>></span></span> <span>List</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>queryFromDatabase</span><span>(</span><span>MappedStatement</span> ms<span>,</span> <span>Object</span> parameter<span>,</span> <span>RowBounds</span> rowBounds<span>,</span> <span>ResultHandler</span> resultHandler<span>,</span> <span>CacheKey</span> key<span>,</span> <span>BoundSql</span> boundSql<span>)</span> <span>throws</span> <span>SQLException</span> <span>{</span>\n        <span>List</span><span><span>&lt;</span><span>E</span><span>></span></span> list<span>;</span>\n        localCache<span>.</span><span>putObject</span><span>(</span>key<span>,</span> EXECUTION_PLACEHOLDER<span>)</span><span>;</span>\n        <span>try</span> <span>{</span>\n          list <span>=</span> <span>doQuery</span><span>(</span>ms<span>,</span> parameter<span>,</span> rowBounds<span>,</span> resultHandler<span>,</span> boundSql<span>)</span><span>;</span>\n        <span>}</span> <span>finally</span> <span>{</span>\n          localCache<span>.</span><span>removeObject</span><span>(</span>key<span>)</span><span>;</span>\n        <span>}</span>\n        localCache<span>.</span><span>putObject</span><span>(</span>key<span>,</span> list<span>)</span><span>;</span>\n        <span>if</span> <span>(</span>ms<span>.</span><span>getStatementType</span><span>(</span><span>)</span> <span>==</span> <span>StatementType</span><span>.</span>CALLABLE<span>)</span> <span>{</span>\n          localOutputParameterCache<span>.</span><span>putObject</span><span>(</span>key<span>,</span> parameter<span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> list<span>;</span>\n      <span>}</span>\n<span>}</span>  \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><h2 id=\"三、二级缓存\"> 三、二级缓存</h2>\n<p>二级缓存是基于装饰器模式,它允许开发者自定义缓存的实现,只要实现了Cache接口就行。通过装饰器的设计。\nCachingExecutor从MappedStatement#getCache获取缓存的具体实现，从而进行缓存操作。</p>\n<p>下面代码是看Mybatis是如何进行装饰器的。注意看注释。如果开启缓存,则包装器对Executor进行包装。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Configuration</span> <span>{</span>\n    <span>public</span> <span>Executor</span> <span>newExecutor</span><span>(</span><span>Transaction</span> transaction<span>,</span> <span>ExecutorType</span> executorType<span>)</span> <span>{</span>\n        executorType <span>=</span> executorType <span>==</span> <span>null</span> <span>?</span> defaultExecutorType <span>:</span> executorType<span>;</span>\n        executorType <span>=</span> executorType <span>==</span> <span>null</span> <span>?</span> <span>ExecutorType</span><span>.</span>SIMPLE <span>:</span> executorType<span>;</span>\n        <span>Executor</span> executor<span>;</span>\n        <span>if</span> <span>(</span><span>ExecutorType</span><span>.</span>BATCH <span>==</span> executorType<span>)</span> <span>{</span>\n          executor <span>=</span> <span>new</span> <span>BatchExecutor</span><span>(</span><span>this</span><span>,</span> transaction<span>)</span><span>;</span>\n        <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>ExecutorType</span><span>.</span>REUSE <span>==</span> executorType<span>)</span> <span>{</span>\n          executor <span>=</span> <span>new</span> <span>ReuseExecutor</span><span>(</span><span>this</span><span>,</span> transaction<span>)</span><span>;</span>\n        <span>}</span> <span>else</span> <span>{</span>\n          executor <span>=</span> <span>new</span> <span>SimpleExecutor</span><span>(</span><span>this</span><span>,</span> transaction<span>)</span><span>;</span>\n        <span>}</span>\n        <span>// 如果开启缓存,则包装器对Executor进行包装</span>\n        <span>if</span> <span>(</span>cacheEnabled<span>)</span> <span>{</span>\n          executor <span>=</span> <span>new</span> <span>CachingExecutor</span><span>(</span>executor<span>)</span><span>;</span>\n        <span>}</span>\n        executor <span>=</span> <span>(</span><span>Executor</span><span>)</span> interceptorChain<span>.</span><span>pluginAll</span><span>(</span>executor<span>)</span><span>;</span>\n        <span>return</span> executor<span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>CachingExecutor在实际执行时候从MappedStatement#getCache获取缓存的具体实现，从而进行缓存操作。\n看到查询是先从二级缓存中获取，如果没有获取到就从一级缓存中获取，还没有就查询db。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>CachingExecutor</span> <span>implements</span> <span>Executor</span> <span>{</span>\n\n  <span>@Override</span>\n  <span>public</span> <span><span>&lt;</span><span>E</span><span>></span></span> <span>List</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>query</span><span>(</span><span>MappedStatement</span> ms<span>,</span> <span>Object</span> parameterObject<span>,</span> <span>RowBounds</span> rowBounds<span>,</span> <span>ResultHandler</span> resultHandler<span>,</span> <span>CacheKey</span> key<span>,</span> <span>BoundSql</span> boundSql<span>)</span>\n      <span>throws</span> <span>SQLException</span> <span>{</span>\n    <span>// 从MappedStatement获取Cache</span>\n    <span>Cache</span> cache <span>=</span> ms<span>.</span><span>getCache</span><span>(</span><span>)</span><span>;</span>\n    <span>if</span> <span>(</span>cache <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n      <span>flushCacheIfRequired</span><span>(</span>ms<span>)</span><span>;</span>\n      <span>if</span> <span>(</span>ms<span>.</span><span>isUseCache</span><span>(</span><span>)</span> <span>&amp;&amp;</span> resultHandler <span>==</span> <span>null</span><span>)</span> <span>{</span>\n        <span>ensureNoOutParams</span><span>(</span>ms<span>,</span> boundSql<span>)</span><span>;</span>\n        <span>@SuppressWarnings</span><span>(</span><span>\"unchecked\"</span><span>)</span>\n        <span>List</span><span><span>&lt;</span><span>E</span><span>></span></span> list <span>=</span> <span>(</span><span>List</span><span><span>&lt;</span><span>E</span><span>></span></span><span>)</span> tcm<span>.</span><span>getObject</span><span>(</span>cache<span>,</span> key<span>)</span><span>;</span>\n        <span>if</span> <span>(</span>list <span>==</span> <span>null</span><span>)</span> <span>{</span>\n          list <span>=</span> delegate<span>.</span><span>query</span><span>(</span>ms<span>,</span> parameterObject<span>,</span> rowBounds<span>,</span> resultHandler<span>,</span> key<span>,</span> boundSql<span>)</span><span>;</span>\n          tcm<span>.</span><span>putObject</span><span>(</span>cache<span>,</span> key<span>,</span> list<span>)</span><span>;</span> <span>// issue #578 and #116</span>\n        <span>}</span>\n        <span>return</span> list<span>;</span>\n      <span>}</span>\n    <span>}</span>\n    <span>return</span> delegate<span>.</span><span>query</span><span>(</span>ms<span>,</span> parameterObject<span>,</span> rowBounds<span>,</span> resultHandler<span>,</span> key<span>,</span> boundSql<span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>注意这里可以看到如果指定了要进行缓存，但是没有指定缓存的type默认是 PERPETUAL(PerpetualCache\n)</p>\n<h2 id=\"四、开启二级缓存\"> 四、开启二级缓存</h2>\n<h2 id=\"_4-1-内置二级缓存\"> 4.1 内置二级缓存</h2>\n<ol>\n<li>首先开启配置</li>\n<li>同时在Mapper文件中添加<cache/>标签 (XMLMapperBuilder#cacheElement)</li>\n<li>或者是在Mapper类上添加@CacheNamespace注解(MapperAnnotationBuilder#parseCache)</li>\n</ol>\n<div><pre><code><span>&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?></span>\n<span><span>&lt;!</span><span>DOCTYPE</span> <span>configuration</span>\n        <span>PUBLIC</span> <span>\"-//mybatis.org//DTD Config 3.0//EN\"</span>\n        <span>\"http://mybatis.org/dtd/mybatis-3-config.dtd\"</span><span>></span></span>\n<span><span><span>&lt;</span>configuration</span><span>></span></span>\n    <span>&lt;!-- 指定Mybatis使用log4j --></span>\n    <span><span><span>&lt;</span>settings</span><span>></span></span>\n        <span><span><span>&lt;</span>setting</span> <span>name</span><span><span>=</span><span>\"</span>logImpl<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>LOG4J<span>\"</span></span><span>/></span></span>\n        // 通过 cacheEnabled 进行配置,如果不配置默认是true\n        <span><span><span>&lt;</span>setting</span> <span>name</span><span><span>=</span><span>\"</span>cacheEnabled<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>false<span>\"</span></span><span>/></span></span>\n    <span><span><span>&lt;/</span>settings</span><span>></span></span>\n<span><span><span>&lt;/</span>configuration</span><span>></span></span>\n\n<span>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?></span>\n<span><span>&lt;!</span><span>DOCTYPE</span> <span>mapper</span> <span>PUBLIC</span> <span>\"-//mybatis.org//DTD Mapper 3.0//EN\"</span> <span>\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"</span><span>></span></span>\n<span><span><span>&lt;</span>mapper</span> <span>namespace</span><span><span>=</span><span>\"</span>orm.example.dal.mapper.TUserMapper<span>\"</span></span><span>></span></span>\n    // 添加cache标签\n    <span><span><span>&lt;</span>cache</span><span>/></span></span>\n<span><span><span>&lt;/</span>mapper</span><span>></span></span>    \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">属性</th>\n<th style=\"text-align:left\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">eviction</td>\n<td style=\"text-align:left\">缓存回收策略</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">flushInterval</td>\n<td style=\"text-align:left\">缓存刷新间隔，缓存多长时间刷新一次，默认不清空，设置一个毫秒值</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">readOnly</td>\n<td style=\"text-align:left\">是否只读；true 只读</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">size</td>\n<td style=\"text-align:left\">缓存存放多少个元素</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">type</td>\n<td style=\"text-align:left\">指定自定义缓存的全类名(实现Cache 接口即可)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">blocking</td>\n<td style=\"text-align:left\">若缓存中找不到对应的key，是否会一直blocking，直到有对应的数据进入缓存。</td>\n</tr>\n</tbody>\n</table>\n<p>一共可以使用的二级缓存有以下这些。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1648571791000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_4-2-外置二级缓存\"> 4.2 外置二级缓存</h2>\n<p>只要实现了Cache接口那么Mybatis就会调用这个接口实现进行缓存。下面只说一个思路。如下通过指定EhcacheCache\n就可以将这个二级缓存的能力，交给Mybatis进行调用了。</p>\n<div><pre><code><span><span><span>&lt;</span>cache</span> <span>type</span><span><span>=</span><span>\"</span>org.mybatis.caches.ehcache.EhcacheCache<span>\"</span></span> <span>></span></span> \n      <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>timeToIdleSeconds<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>3600<span>\"</span></span><span>/></span></span>\n      <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>timeToLiveSeconds<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>3600<span>\"</span></span><span>/></span></span>\n      <span>&lt;!-- 同ehcache参数maxElementsInMemory --></span>\n    <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>maxEntriesLocalHeap<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>1000<span>\"</span></span><span>/></span></span>\n    <span>&lt;!-- 同ehcache参数maxElementsOnDisk --></span>\n      <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>maxEntriesLocalDisk<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>10000000<span>\"</span></span><span>/></span></span>\n      <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>memoryStoreEvictionPolicy<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>LRU<span>\"</span></span><span>/></span></span>\n<span><span><span>&lt;/</span>cache</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div>",
      "image": "https://img.springlearn.cn/blog/learn_1648571791000.png",
      "date_published": "2022-03-30T15:42:58.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Mybatis"
      ]
    },
    {
      "title": "第03篇:Mybatis核心类详细介绍",
      "url": "https://java.springlearn.cn/learn/mybatis/%E6%A0%B8%E5%BF%83%E7%B1%BB%E4%BB%8B%E7%BB%8D/",
      "id": "https://java.springlearn.cn/learn/mybatis/%E6%A0%B8%E5%BF%83%E7%B1%BB%E4%BB%8B%E7%BB%8D/",
      "content_html": "<div><p>核心类介绍</p>\n<p>前面我们知道Mybatis的解析原理,知道了在 <code>Configuration</code> 、<code>MapperBuilderAssistant</code> 出现了很多核心的类。\n正是由这些类来实现了,Mybatis的核心功能。所以要想完全搞懂 Mybatis,这些类就必须要进行深入的研究，废话不多少，直接就开始吧。</p>\n</div>\n<p>其实这里面的每个类要都能单独拆出来一篇进行详细说明，但是这里我们只取其精华，知道他的作用，及如何使用。和能借鉴的地方就可以了。</p>\n<h2 id=\"一、configuration\"> 一、Configuration</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">属性</th>\n<th style=\"text-align:left\">解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">TypeAliasRegistry</td>\n<td style=\"text-align:left\">key是一个别名,value是一个class对象</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Properties variables</td>\n<td style=\"text-align:left\">配置文件中占位符的变量配置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">InterceptorChain interceptorChain</td>\n<td style=\"text-align:left\">拦截链,用于拦截方法,实现插件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ObjectFactory objectFactory</td>\n<td style=\"text-align:left\">对象实例化统一的工厂方法</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ObjectWrapperFactory objectWrapperFactory</td>\n<td style=\"text-align:left\">扩展使用，允许用户自定义包装对象ObjectWrapper</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ReflectorFactory reflectorFactory</td>\n<td style=\"text-align:left\">反射工厂,用于生成一个反射信息对象</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Environment environment</td>\n<td style=\"text-align:left\">环境信息包含(事务管理器和数据源)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">TypeHandlerRegistry typeHandlerRegistry</td>\n<td style=\"text-align:left\">数据库返回数据类型转换成Java对象的处理器，或是Java数据类型转换jdbc数据类型的处理器</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">MapperRegistry mapperRegistry</td>\n<td style=\"text-align:left\">Mapper生成的处理类,包含代理的逻辑</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"_1-1-typealiasregistry\"> 1.1 TypeAliasRegistry</h2>\n<blockquote>\n<p>key是别名,value是对应的Class&lt;?&gt;</p>\n</blockquote>\n<p>这个在什么时候用的呢? 前面我们通过解析xml，发现很多的dtd约束，文件的值类型都是 CDATA 即 字符串。 但是这些字符串最终是要解析成指定的字节码的。\n怎么知道字符串对应的是哪个java类呢? 那么这个功能就交给 <code>TypeAliasRegistry</code>。允许你将一个java类注册一个别名。这样你就可以在配置文件中用别名\n来替换java类了。</p>\n<div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>TypeAliasRegistry</span><span>(</span><span>)</span> <span>{</span>\n        <span>TypeAliasRegistry</span> typeAliasRegistry <span>=</span> <span>new</span> <span>TypeAliasRegistry</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>typeAliasRegistry<span>.</span><span>resolveAlias</span><span>(</span><span>\"byte\"</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"_1-2-properties\"> 1.2 Properties</h2>\n<p>这个java类就不用介绍了，在<code>Configuration</code> 就是存储的配置信息，允许你在mybatis中任意地方使用${}进行访问数据。</p>\n<p>比如你可以这样用? 配置一个全局的limit限制数量</p>\n<div><pre><code><span>datasource.driver-class-name</span><span>=</span><span>com.mysql.cj.jdbc.Driver</span>\n<span>datasource.url</span><span>=</span><span>jdbc:mysql://127.0.0.1:3306/test</span>\n<span>datasource.username</span><span>=</span><span>root</span>\n<span>datasource.password</span><span>=</span><span>123456</span>\n<span>datasource.globalLimit</span><span>=</span><span>1000</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span>public</span> <span>interface</span> <span>TUserMapper</span> <span>{</span>\n    <span>@Select</span><span>(</span><span>\"select * from t_user where uid = ${id} limit ${datasource.globalLimit} \"</span><span>)</span>\n    <span>List</span><span><span>&lt;</span><span>TUser</span><span>></span></span> <span>selectById</span><span>(</span><span>Long</span> id<span>)</span><span>;</span>\n<span>}</span>    \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id=\"_1-3-interceptorchain\"> 1.3 InterceptorChain</h2>\n<p>内容较多,开单独的篇幅进行介绍; <a href=\"./插件分析/\">第07篇:Mybatis的插件设计分析</a></p>\n<p>从名字就可以看到是一个拦截链; 主要是实现插件的功能。核心思路是, 通过拦截类的方法来实现插件。</p>\n<p>MyBatis 允许你在映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包括：</p>\n<ul>\n<li>Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)</li>\n<li>ParameterHandler (getParameterObject, setParameters)</li>\n<li>ResultSetHandler (handleResultSets, handleOutputParameters)</li>\n<li>StatementHandler (prepare, parameterize, batch, update, query)</li>\n</ul>\n<div><pre><code><span>public</span> <span>class</span> <span>InterceptorChain</span> <span>{</span>\n\n  <span>private</span> <span>final</span> <span>List</span><span><span>&lt;</span><span>Interceptor</span><span>></span></span> interceptors <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n\n  <span>public</span> <span>Object</span> <span>pluginAll</span><span>(</span><span>Object</span> target<span>)</span> <span>{</span>\n    <span>for</span> <span>(</span><span>Interceptor</span> interceptor <span>:</span> interceptors<span>)</span> <span>{</span>\n      target <span>=</span> interceptor<span>.</span><span>plugin</span><span>(</span>target<span>)</span><span>;</span>\n    <span>}</span>\n    <span>return</span> target<span>;</span>\n  <span>}</span>\n\n  <span>public</span> <span>void</span> <span>addInterceptor</span><span>(</span><span>Interceptor</span> interceptor<span>)</span> <span>{</span>\n    interceptors<span>.</span><span>add</span><span>(</span>interceptor<span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>public</span> <span>List</span><span><span>&lt;</span><span>Interceptor</span><span>></span></span> <span>getInterceptors</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>Collections</span><span>.</span><span>unmodifiableList</span><span>(</span>interceptors<span>)</span><span>;</span>\n  <span>}</span>\n\n<span>}</span>\n\n<span>public</span> <span>interface</span> <span>Interceptor</span> <span>{</span>\n\n  <span>Object</span> <span>intercept</span><span>(</span><span>Invocation</span> invocation<span>)</span> <span>throws</span> <span>Throwable</span><span>;</span>\n\n  <span>default</span> <span>Object</span> <span>plugin</span><span>(</span><span>Object</span> target<span>)</span> <span>{</span>\n    <span>return</span> <span>Plugin</span><span>.</span><span>wrap</span><span>(</span>target<span>,</span> <span>this</span><span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>default</span> <span>void</span> <span>setProperties</span><span>(</span><span>Properties</span> properties<span>)</span> <span>{</span>\n    <span>// NOP</span>\n  <span>}</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><h2 id=\"_1-4-objectfactory-对象工厂\"> 1.4 ObjectFactory 对象工厂</h2>\n<p>在Mybatis中或者说是orm框架中, 使用到反射的地方较多。那么就一定会遇到实例化的问题。具体如何实例化。就是使用对象工厂。\n之所以提供个工厂, 小编个人认为还是为了扩展使用。但是实际中一般不会扩展这个类。因为该有的功能默认的就已经具备了。</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>ObjectFactory</span> <span>{</span>\n  \n  <span>// 配置信息</span>\n  <span>default</span> <span>void</span> <span>setProperties</span><span>(</span><span>Properties</span> properties<span>)</span> <span>{</span><span>}</span>\n  <span>// 根据空构造来实例化</span>\n  <span><span>&lt;</span><span>T</span><span>></span></span> <span>T</span> <span>create</span><span>(</span><span>Class</span><span><span>&lt;</span><span>T</span><span>></span></span> type<span>)</span><span>;</span>\n  <span>// 根据构造参数来实例化</span>\n  <span><span>&lt;</span><span>T</span><span>></span></span> <span>T</span> <span>create</span><span>(</span><span>Class</span><span><span>&lt;</span><span>T</span><span>></span></span> type<span>,</span> <span>List</span><span><span>&lt;</span><span>Class</span><span>&lt;</span><span>?</span><span>></span><span>></span></span> constructorArgTypes<span>,</span> <span>List</span><span><span>&lt;</span><span>Object</span><span>></span></span> constructorArgs<span>)</span><span>;</span>\n  <span>// 判断是否是Collection子类</span>\n  <span><span>&lt;</span><span>T</span><span>></span></span> <span>boolean</span> <span>isCollection</span><span>(</span><span>Class</span><span><span>&lt;</span><span>T</span><span>></span></span> type<span>)</span><span>;</span>\n\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id=\"_1-5-objectwrapperfactory-对象包装工厂\"> 1.5 ObjectWrapperFactory 对象包装工厂</h2>\n<p>他的作用主要是提供外面的扩展，允许用户自己去创建包装对象。实际框架中不会用到这个对象。我们只要知道他的作用是什么行。\n我们重点说一下 ObjectWrapper 。</p>\n<p>ObjectWrapper的主要作用是，提供统一的属性操作方法。主要在MetaObject被使用,如下。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>MetaObject</span> <span>{</span>\n\n  <span>private</span> <span>final</span> <span>Object</span> originalObject<span>;</span>\n  <span>private</span> <span>final</span> <span>ObjectWrapper</span> objectWrapper<span>;</span>\n  <span>private</span> <span>final</span> <span>ObjectFactory</span> objectFactory<span>;</span>\n  <span>private</span> <span>final</span> <span>ObjectWrapperFactory</span> objectWrapperFactory<span>;</span>\n  <span>private</span> <span>final</span> <span>ReflectorFactory</span> reflectorFactory<span>;</span>\n\n  <span>private</span> <span>MetaObject</span><span>(</span><span>Object</span> object<span>,</span> <span>ObjectFactory</span> objectFactory<span>,</span> <span>ObjectWrapperFactory</span> objectWrapperFactory<span>,</span> <span>ReflectorFactory</span> reflectorFactory<span>)</span> <span>{</span>\n    <span>this</span><span>.</span>originalObject <span>=</span> object<span>;</span>\n    <span>this</span><span>.</span>objectFactory <span>=</span> objectFactory<span>;</span>\n    <span>this</span><span>.</span>objectWrapperFactory <span>=</span> objectWrapperFactory<span>;</span>\n    <span>this</span><span>.</span>reflectorFactory <span>=</span> reflectorFactory<span>;</span>\n\n    <span>if</span> <span>(</span>object <span>instanceof</span> <span>ObjectWrapper</span><span>)</span> <span>{</span>\n      <span>this</span><span>.</span>objectWrapper <span>=</span> <span>(</span><span>ObjectWrapper</span><span>)</span> object<span>;</span>\n    <span>}</span> <span>else</span> <span>if</span> <span>(</span>objectWrapperFactory<span>.</span><span>hasWrapperFor</span><span>(</span>object<span>)</span><span>)</span> <span>{</span>\n      <span>this</span><span>.</span>objectWrapper <span>=</span> objectWrapperFactory<span>.</span><span>getWrapperFor</span><span>(</span><span>this</span><span>,</span> object<span>)</span><span>;</span>\n    <span>}</span> <span>else</span> <span>if</span> <span>(</span>object <span>instanceof</span> <span>Map</span><span>)</span> <span>{</span>\n      <span>this</span><span>.</span>objectWrapper <span>=</span> <span>new</span> <span>MapWrapper</span><span>(</span><span>this</span><span>,</span> <span>(</span><span>Map</span><span>)</span> object<span>)</span><span>;</span>\n    <span>}</span> <span>else</span> <span>if</span> <span>(</span>object <span>instanceof</span> <span>Collection</span><span>)</span> <span>{</span>\n      <span>this</span><span>.</span>objectWrapper <span>=</span> <span>new</span> <span>CollectionWrapper</span><span>(</span><span>this</span><span>,</span> <span>(</span><span>Collection</span><span>)</span> object<span>)</span><span>;</span>\n    <span>}</span> <span>else</span> <span>{</span>\n      <span>this</span><span>.</span>objectWrapper <span>=</span> <span>new</span> <span>BeanWrapper</span><span>(</span><span>this</span><span>,</span> object<span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>  \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>我们看到普通的对象,被包装成 ObjectWrapper后就可以使用通用的API来获取和修改对象数值型,以及可以获取属性值的类型信息,如下面的例子。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1648542576000.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>objectWrapper</span><span>(</span><span>)</span><span>{</span>\n        <span>// 读取配置信息(为什么路径前不用加/,因为是相对路径。maven编译后的资源文件和class文件都是在一个包下,所以不用加/就是当前包目录)</span>\n        <span>InputStream</span> mapperInputStream <span>=</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getContextClassLoader</span><span>(</span><span>)</span><span>.</span><span>getResourceAsStream</span><span>(</span><span>\"mybatisConfig.xml\"</span><span>)</span><span>;</span>\n        <span>// 生成SqlSession工厂,SqlSession从名字上看就是,跟数据库交互的会话信息,负责将sql提交到数据库进行执行</span>\n        <span>SqlSessionFactory</span> sqlSessionFactory <span>=</span> <span>new</span> <span>SqlSessionFactoryBuilder</span><span>(</span><span>)</span><span>.</span><span>build</span><span>(</span>mapperInputStream<span>,</span> <span>\"development\"</span><span>)</span><span>;</span>\n        <span>// 获取Mybatis配置信息</span>\n        <span>Configuration</span> configuration <span>=</span> sqlSessionFactory<span>.</span><span>getConfiguration</span><span>(</span><span>)</span><span>;</span>\n        <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span><span>String</span><span>></span></span> map <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        map<span>.</span><span>put</span><span>(</span><span>\"name\"</span><span>,</span><span>\"孙悟空\"</span><span>)</span><span>;</span>\n        <span>MetaObject</span> metaObject <span>=</span> <span>MetaObject</span><span>.</span><span>forObject</span><span>(</span>map<span>,</span> configuration<span>.</span><span>getObjectFactory</span><span>(</span><span>)</span><span>,</span> configuration<span>.</span><span>getObjectWrapperFactory</span><span>(</span><span>)</span><span>,</span> configuration<span>.</span><span>getReflectorFactory</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>metaObject<span>.</span><span>getValue</span><span>(</span><span>\"name\"</span><span>)</span><span>)</span><span>;</span>\n        <span>// 复制</span>\n        metaObject<span>.</span><span>setValue</span><span>(</span><span>\"age\"</span><span>,</span><span>18</span><span>)</span><span>;</span>\n        <span>// {name=孙悟空, age=18}</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>map<span>)</span><span>;</span>\n\n        <span>TUser</span> tUser <span>=</span> <span>new</span> <span>TUser</span><span>(</span><span>)</span><span>;</span>\n        tUser<span>.</span><span>setName</span><span>(</span><span>\"唐三藏\"</span><span>)</span><span>;</span>\n        <span>MetaObject</span> tUserMetaObject <span>=</span> <span>MetaObject</span><span>.</span><span>forObject</span><span>(</span>tUser<span>,</span> configuration<span>.</span><span>getObjectFactory</span><span>(</span><span>)</span><span>,</span> configuration<span>.</span><span>getObjectWrapperFactory</span><span>(</span><span>)</span><span>,</span> configuration<span>.</span><span>getReflectorFactory</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// 唐三藏</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>tUserMetaObject<span>.</span><span>getValue</span><span>(</span><span>\"name\"</span><span>)</span><span>)</span><span>;</span>\n\n        <span>List</span><span><span>&lt;</span><span>TUser</span><span>></span></span> users <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        users<span>.</span><span>add</span><span>(</span>tUser<span>)</span><span>;</span>\n        <span>MetaObject</span> tUserMetaObjects <span>=</span> <span>MetaObject</span><span>.</span><span>forObject</span><span>(</span>users<span>,</span> configuration<span>.</span><span>getObjectFactory</span><span>(</span><span>)</span><span>,</span> configuration<span>.</span><span>getObjectWrapperFactory</span><span>(</span><span>)</span><span>,</span> configuration<span>.</span><span>getReflectorFactory</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        tUserMetaObjects<span>.</span><span>add</span><span>(</span><span>new</span> <span>TUser</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// [TUser(tokenId=null, uid=null, name=唐三藏), TUser(tokenId=null, uid=null, name=null)]</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>tUserMetaObjects<span>.</span><span>getOriginalObject</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><h2 id=\"_1-6-reflectorfactory-反射工厂\"> 1.6 ReflectorFactory 反射工厂</h2>\n<p>从名字看就是反射的工厂，主要是为了生成 Reflector 对象。Reflector 对反射的信息进行了缓存。用的时候直接从缓存中获取。</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>ReflectorFactory</span> <span>{</span>\n\n  <span>boolean</span> <span>isClassCacheEnabled</span><span>(</span><span>)</span><span>;</span>\n\n  <span>void</span> <span>setClassCacheEnabled</span><span>(</span><span>boolean</span> classCacheEnabled<span>)</span><span>;</span>\n\n  <span>Reflector</span> <span>findForClass</span><span>(</span><span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> type<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id=\"_1-7-environment-环境\"> 1.7 Environment 环境</h2>\n<p>这里面的环境属性,是比较重要。因为他直接决定了你要跟那个数据库交互。以及事务如何处理。</p>\n<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>Environment</span> <span>{</span>\n  <span>private</span> <span>final</span> <span>String</span> id<span>;</span>\n  <span>private</span> <span>final</span> <span>TransactionFactory</span> transactionFactory<span>;</span>\n  <span>private</span> <span>final</span> <span>DataSource</span> dataSource<span>;</span>\n<span>}</span>  \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span>private</span> <span>SqlSession</span> <span>openSessionFromDataSource</span><span>(</span><span>ExecutorType</span> execType<span>,</span> <span>TransactionIsolationLevel</span> level<span>,</span> <span>boolean</span> autoCommit<span>)</span> <span>{</span>\n    <span>Transaction</span> tx <span>=</span> <span>null</span><span>;</span>\n    <span>try</span> <span>{</span>\n      <span>final</span> <span>Environment</span> environment <span>=</span> configuration<span>.</span><span>getEnvironment</span><span>(</span><span>)</span><span>;</span>\n      <span>final</span> <span>TransactionFactory</span> transactionFactory <span>=</span> <span>getTransactionFactoryFromEnvironment</span><span>(</span>environment<span>)</span><span>;</span>\n      tx <span>=</span> transactionFactory<span>.</span><span>newTransaction</span><span>(</span>environment<span>.</span><span>getDataSource</span><span>(</span><span>)</span><span>,</span> level<span>,</span> autoCommit<span>)</span><span>;</span>\n      <span>final</span> <span>Executor</span> executor <span>=</span> configuration<span>.</span><span>newExecutor</span><span>(</span>tx<span>,</span> execType<span>)</span><span>;</span>\n      <span>return</span> <span>new</span> <span>DefaultSqlSession</span><span>(</span>configuration<span>,</span> executor<span>,</span> autoCommit<span>)</span><span>;</span>\n    <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n      <span>closeTransaction</span><span>(</span>tx<span>)</span><span>;</span> <span>// may have fetched a connection so lets call close()</span>\n      <span>throw</span> <span>ExceptionFactory</span><span>.</span><span>wrapException</span><span>(</span><span>\"Error opening session.  Cause: \"</span> <span>+</span> e<span>,</span> e<span>)</span><span>;</span>\n    <span>}</span> <span>finally</span> <span>{</span>\n      <span>ErrorContext</span><span>.</span><span>instance</span><span>(</span><span>)</span><span>.</span><span>reset</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h2 id=\"_1-8-typehandlerregistry\"> 1.8 TypeHandlerRegistry</h2>\n<p>TypeHandler + Registry, 从名字来看又是一个类型注册器用于反射使用。看来mybatis中用于反射的工具类是在太多了。那么TypeHandler究竟有什么用呢?\nTypeHandler 是对Statement和ResultSet负责。\nResultSet 是从数据库获取的数据的载体，Statement 是准备向数据库提交数据的载体。TypeHandler 的作用就是\n根据数据类型, 处理跟数据的输入和输出信息。看下面接口。</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>TypeHandler</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>{</span>\n\n  <span>void</span> <span>setParameter</span><span>(</span><span>PreparedStatement</span> ps<span>,</span> <span>int</span> i<span>,</span> <span>T</span> parameter<span>,</span> <span>JdbcType</span> jdbcType<span>)</span> <span>throws</span> <span>SQLException</span><span>;</span>\n\n  <span>/**\n   * Gets the result.\n   *\n   * @param rs\n   *          the rs\n   * @param columnName\n   *          Colunm name, when configuration &lt;code>useColumnLabel&lt;/code> is &lt;code>false&lt;/code>\n   * @return the result\n   * @throws SQLException\n   *           the SQL exception\n   */</span>\n  <span>T</span> <span>getResult</span><span>(</span><span>ResultSet</span> rs<span>,</span> <span>String</span> columnName<span>)</span> <span>throws</span> <span>SQLException</span><span>;</span>\n\n  <span>T</span> <span>getResult</span><span>(</span><span>ResultSet</span> rs<span>,</span> <span>int</span> columnIndex<span>)</span> <span>throws</span> <span>SQLException</span><span>;</span>\n\n  <span>T</span> <span>getResult</span><span>(</span><span>CallableStatement</span> cs<span>,</span> <span>int</span> columnIndex<span>)</span> <span>throws</span> <span>SQLException</span><span>;</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>这里举一个例子，比如name这个字段在数据库是varchar类型,但是java对象中name是一个Name对象。那么如何处理呢?\n我们自定义一个处理器。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>NameTypeHandler</span> <span>implements</span> <span>TypeHandler</span><span><span>&lt;</span><span>Name</span><span>></span></span> <span>{</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>setParameter</span><span>(</span><span>PreparedStatement</span> ps<span>,</span> <span>int</span> i<span>,</span> <span>Name</span> parameter<span>,</span> <span>JdbcType</span> jdbcType<span>)</span> <span>throws</span> <span>SQLException</span> <span>{</span>\n        ps<span>.</span><span>setString</span><span>(</span>i<span>,</span> parameter<span>.</span><span>getFirstName</span><span>(</span><span>)</span> <span>+</span> <span>\"-\"</span> <span>+</span> parameter<span>.</span><span>getSurname</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>Name</span> <span>getResult</span><span>(</span><span>ResultSet</span> rs<span>,</span> <span>String</span> columnName<span>)</span> <span>throws</span> <span>SQLException</span> <span>{</span>\n        <span>String</span> name <span>=</span> rs<span>.</span><span>getString</span><span>(</span>columnName<span>)</span><span>;</span>\n        <span>String</span><span>[</span><span>]</span> split <span>=</span> name<span>.</span><span>split</span><span>(</span><span>\"-\"</span><span>)</span><span>;</span>\n        <span>return</span> <span>new</span> <span>Name</span><span>(</span>split<span>[</span><span>0</span><span>]</span><span>,</span> split<span>[</span><span>1</span><span>]</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>    \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>然后在配置文件中声明注册器,用于将java对象转换成jdbc数据库字段类型。同时也将数据库查询到的jdbc类型转换成java对象。</p>\n<div><pre><code>    <span><span><span>&lt;</span>configuration</span><span>></span></span>\n        <span><span><span>&lt;</span>typeHandlers</span><span>></span></span>\n            <span><span><span>&lt;</span>typeHandler</span> <span>handler</span><span><span>=</span><span>\"</span>orm.example.dal.type.NameTypeHandler<span>\"</span></span> <span>javaType</span><span><span>=</span><span>\"</span>orm.example.dal.model.Name<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>typeHandler</span><span>></span></span>\n        <span><span><span>&lt;/</span>typeHandlers</span><span>></span></span>\n    <span><span><span>&lt;/</span>configuration</span><span>></span></span>    \n    <span><span><span>&lt;</span>mapper</span><span>></span></span>\n         <span><span><span>&lt;</span>insert</span> <span>id</span><span><span>=</span><span>\"</span>insert<span>\"</span></span> <span>parameterType</span><span><span>=</span><span>\"</span>orm.example.dal.model.T2User<span>\"</span></span><span>></span></span>\n            <span>&lt;!--\n              WARNING - @mbggenerated\n              This element is automatically generated by MyBatis Generator, do not modify.\n              This element was generated on Sun Mar 27 23:01:23 CST 2022.\n            --></span>\n            insert into T_USER (token_id, uid, name)\n            values (#{tokenId,jdbcType=CHAR}, #{uid,jdbcType=INTEGER}, #{name,javaType=orm.example.dal.model.Name })\n        <span><span><span>&lt;/</span>insert</span><span>></span></span>\n    <span><span><span>&lt;/</span>mapper</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>我们执行下面代码,可以看到我们将数据类型转换成了jdbc存到了数据库，同时执行查询时候又将jdbc类型转换成了java对象。这就是它的作用。</p>\n<div><div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br></div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>test</span><span>(</span><span>)</span> <span>{</span>\n        <span>// 读取配置信息(为什么路径前不用加/,因为是相对路径。maven编译后的资源文件和class文件都是在一个包下,所以不用加/就是当前包目录)</span>\n        <span>InputStream</span> mapperInputStream <span>=</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getContextClassLoader</span><span>(</span><span>)</span><span>.</span><span>getResourceAsStream</span><span>(</span><span>\"mybatisConfig.xml\"</span><span>)</span><span>;</span>\n        <span>// 生成SqlSession工厂,SqlSession从名字上看就是,跟数据库交互的会话信息,负责将sql提交到数据库进行执行</span>\n        <span>SqlSessionFactory</span> sqlSessionFactory <span>=</span> <span>new</span> <span>SqlSessionFactoryBuilder</span><span>(</span><span>)</span><span>.</span><span>build</span><span>(</span>mapperInputStream<span>,</span> <span>\"development\"</span><span>)</span><span>;</span>\n        <span>// 获取Mybatis配置信息</span>\n        <span>Configuration</span> configuration <span>=</span> sqlSessionFactory<span>.</span><span>getConfiguration</span><span>(</span><span>)</span><span>;</span>\n        configuration<span>.</span><span>getTypeHandlerRegistry</span><span>(</span><span>)</span><span>.</span><span>register</span><span>(</span><span>new</span> <span>NameTypeHandler</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// 参数: autoCommit,从名字上看就是是否自动提交事务</span>\n        <span>SqlSession</span> sqlSession <span>=</span> sqlSessionFactory<span>.</span><span>openSession</span><span>(</span><span>false</span><span>)</span><span>;</span>\n        <span>// 获取Mapper</span>\n        <span>T2UserMapper</span> mapper <span>=</span> configuration<span>.</span><span>getMapperRegistry</span><span>(</span><span>)</span><span>.</span><span>getMapper</span><span>(</span><span>T2UserMapper</span><span>.</span><span>class</span><span>,</span> sqlSession<span>)</span><span>;</span>\n        <span>T2User</span> tUser <span>=</span> <span>new</span> <span>T2User</span><span>(</span><span>)</span><span>;</span>\n        <span>Name</span> name <span>=</span> <span>new</span> <span>Name</span><span>(</span><span>\"孙\"</span><span>,</span><span>\"悟空\"</span><span>)</span><span>;</span>\n        tUser<span>.</span><span>setName</span><span>(</span>name<span>)</span><span>;</span>\n        tUser<span>.</span><span>setTokenId</span><span>(</span><span>\"西天取经\"</span><span>)</span><span>;</span>\n        mapper<span>.</span><span>insert</span><span>(</span>tUser<span>)</span><span>;</span>\n        <span>// 获取插入的数据: T2User(tokenId=西天取经, uid=32, name=Name(surname=悟空, firstName=孙))</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>mapper<span>.</span><span>selectByPrimaryKey</span><span>(</span><span>\"西天取经\"</span><span>)</span><span>)</span><span>;</span>\n        <span>// 数据插入后，执行查询，然后回滚数据</span>\n        sqlSession<span>.</span><span>rollback</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h2 id=\"_1-9-mapperregistry\"> 1.9 MapperRegistry</h2>\n<p>看到Registry又知道了，这货又是一个类似Map的工具类。肯定是跟Mapper有关系。下面代码关键在于13和17行。\nMybatis中获取Mapper对象都是从 MapperRegistry中获取的。</p>\n<ul>\n<li>line(13) <code>new MapperProxyFactory&lt;&gt;(type)</code> 接口生成代理对象</li>\n<li>line(17) <code>MapperAnnotationBuilder</code> 用于解析Mybatis支持的注解,并添加到 <code>Configuration</code></li>\n</ul>\n<p>这两个类比较重要我们开单独的篇幅进行说明。</p>\n<div><div><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br></div><pre><code><span>public</span> <span>class</span> <span>MapperRegistry</span> <span>{</span>\n\n  <span>private</span> <span>final</span> <span>Configuration</span> config<span>;</span>\n  <span>private</span> <span>final</span> <span>Map</span><span><span>&lt;</span><span>Class</span><span>&lt;</span><span>?</span><span>></span><span>,</span> <span>MapperProxyFactory</span><span>&lt;</span><span>?</span><span>></span><span>></span></span> knownMappers <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n  \n  <span>public</span> <span><span>&lt;</span><span>T</span><span>></span></span> <span>void</span> <span>addMapper</span><span>(</span><span>Class</span><span><span>&lt;</span><span>T</span><span>></span></span> type<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>type<span>.</span><span>isInterface</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n      <span>if</span> <span>(</span><span>hasMapper</span><span>(</span>type<span>)</span><span>)</span> <span>{</span>\n        <span>throw</span> <span>new</span> <span>BindingException</span><span>(</span><span>\"Type \"</span> <span>+</span> type <span>+</span> <span>\" is already known to the MapperRegistry.\"</span><span>)</span><span>;</span>\n      <span>}</span>\n      <span>boolean</span> loadCompleted <span>=</span> <span>false</span><span>;</span>\n      <span>try</span> <span>{</span>\n        knownMappers<span>.</span><span>put</span><span>(</span>type<span>,</span> <span>new</span> <span>MapperProxyFactory</span><span><span>&lt;</span><span>></span></span><span>(</span>type<span>)</span><span>)</span><span>;</span>\n        <span>// It's important that the type is added before the parser is run</span>\n        <span>// otherwise the binding may automatically be attempted by the</span>\n        <span>// mapper parser. If the type is already known, it won't try.</span>\n        <span>MapperAnnotationBuilder</span> parser <span>=</span> <span>new</span> <span>MapperAnnotationBuilder</span><span>(</span>config<span>,</span> type<span>)</span><span>;</span>\n        parser<span>.</span><span>parse</span><span>(</span><span>)</span><span>;</span>\n        loadCompleted <span>=</span> <span>true</span><span>;</span>\n      <span>}</span> <span>finally</span> <span>{</span>\n        <span>if</span> <span>(</span><span>!</span>loadCompleted<span>)</span> <span>{</span>\n          knownMappers<span>.</span><span>remove</span><span>(</span>type<span>)</span><span>;</span>\n        <span>}</span>\n      <span>}</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><h2 id=\"_1-10-sqlsession\"> 1.10 SqlSession</h2>\n<p>SqlSession相当于一千个桥梁,负责将方法参数,发送给数据库,并且将数据库返回值组装成方法的返回值。</p>\n<p>在SqlSession中有几个比较重要的类，如下图。他们负责不同的逻辑。\n分别处理入参(ParameterHandler)，处理出参(ResultSetHandler)，生成Jdbc(StatementHandler)，处理缓存相关(Executor)。\n是一个非常重要的一个类。后面我们的学习中会经常看到。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1649170321000.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code><span>public</span> <span>interface</span> <span>SqlSession</span> <span>extends</span> <span>Closeable</span> <span>{</span>\n\n  <span><span>&lt;</span><span>T</span><span>></span></span> <span>T</span> <span>selectOne</span><span>(</span><span>String</span> statement<span>)</span><span>;</span>\n\n  <span><span>&lt;</span><span>T</span><span>></span></span> <span>T</span> <span>selectOne</span><span>(</span><span>String</span> statement<span>,</span> <span>Object</span> parameter<span>)</span><span>;</span>\n\n  <span>int</span> <span>insert</span><span>(</span><span>String</span> statement<span>)</span><span>;</span>\n\n  <span>int</span> <span>insert</span><span>(</span><span>String</span> statement<span>,</span> <span>Object</span> parameter<span>)</span><span>;</span>\n\n  <span>int</span> <span>update</span><span>(</span><span>String</span> statement<span>)</span><span>;</span>\n\n  <span>int</span> <span>update</span><span>(</span><span>String</span> statement<span>,</span> <span>Object</span> parameter<span>)</span><span>;</span>\n\n  <span>int</span> <span>delete</span><span>(</span><span>String</span> statement<span>)</span><span>;</span>\n\n  <span>int</span> <span>delete</span><span>(</span><span>String</span> statement<span>,</span> <span>Object</span> parameter<span>)</span><span>;</span>\n\n  <span>void</span> <span>commit</span><span>(</span><span>)</span><span>;</span>\n\n  <span>void</span> <span>commit</span><span>(</span><span>boolean</span> force<span>)</span><span>;</span>\n\n  <span>void</span> <span>rollback</span><span>(</span><span>)</span><span>;</span>\n\n  <span>void</span> <span>rollback</span><span>(</span><span>boolean</span> force<span>)</span><span>;</span>\n\n  <span>List</span><span><span>&lt;</span><span>BatchResult</span><span>></span></span> <span>flushStatements</span><span>(</span><span>)</span><span>;</span>\n\n  <span>@Override</span>\n  <span>void</span> <span>close</span><span>(</span><span>)</span><span>;</span>\n\n  <span>void</span> <span>clearCache</span><span>(</span><span>)</span><span>;</span>\n\n  <span>Configuration</span> <span>getConfiguration</span><span>(</span><span>)</span><span>;</span>\n\n  <span><span>&lt;</span><span>T</span><span>></span></span> <span>T</span> <span>getMapper</span><span>(</span><span>Class</span><span><span>&lt;</span><span>T</span><span>></span></span> type<span>)</span><span>;</span>\n\n  <span>Connection</span> <span>getConnection</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div><p>我们看增删改查的方法入参无非2个。1个是statement,1个是入参。\n其中statement主要是为了获取 MappedStatement。如下</p>\n<div><pre><code><span>private</span> <span><span>&lt;</span><span>E</span><span>></span></span> <span>List</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>selectList</span><span>(</span><span>String</span> statement<span>,</span> <span>Object</span> parameter<span>,</span> <span>RowBounds</span> rowBounds<span>,</span> <span>ResultHandler</span> handler<span>)</span> <span>{</span>\n    <span>try</span> <span>{</span>\n      <span>MappedStatement</span> ms <span>=</span> configuration<span>.</span><span>getMappedStatement</span><span>(</span>statement<span>)</span><span>;</span>\n      <span>return</span> executor<span>.</span><span>query</span><span>(</span>ms<span>,</span> <span>wrapCollection</span><span>(</span>parameter<span>)</span><span>,</span> rowBounds<span>,</span> handler<span>)</span><span>;</span>\n    <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n      <span>throw</span> <span>ExceptionFactory</span><span>.</span><span>wrapException</span><span>(</span><span>\"Error querying database.  Cause: \"</span> <span>+</span> e<span>,</span> e<span>)</span><span>;</span>\n    <span>}</span> <span>finally</span> <span>{</span>\n      <span>ErrorContext</span><span>.</span><span>instance</span><span>(</span><span>)</span><span>.</span><span>reset</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>另外一个入参是为了组装sql信息。MappedStatement#getBoundSql 获取sql信息。</p>\n<div><pre><code>  <span>@Override</span>\n  <span>public</span> <span><span>&lt;</span><span>E</span><span>></span></span> <span>List</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>query</span><span>(</span><span>MappedStatement</span> ms<span>,</span> <span>Object</span> parameter<span>,</span> <span>RowBounds</span> rowBounds<span>,</span> <span>ResultHandler</span> resultHandler<span>)</span> <span>throws</span> <span>SQLException</span> <span>{</span>\n    <span>BoundSql</span> boundSql <span>=</span> ms<span>.</span><span>getBoundSql</span><span>(</span>parameter<span>)</span><span>;</span>\n    <span>CacheKey</span> key <span>=</span> <span>createCacheKey</span><span>(</span>ms<span>,</span> parameter<span>,</span> rowBounds<span>,</span> boundSql<span>)</span><span>;</span>\n    <span>return</span> <span>query</span><span>(</span>ms<span>,</span> parameter<span>,</span> rowBounds<span>,</span> resultHandler<span>,</span> key<span>,</span> boundSql<span>)</span><span>;</span>\n  <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id=\"二、mapperbuilderassistant\"> 二、MapperBuilderAssistant</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">属性</th>\n<th style=\"text-align:left\">解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">MapperBuilderAssistant</td>\n<td style=\"text-align:left\">Mapper构建辅助工具类(缓存配置)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CacheRefResolver</td>\n<td style=\"text-align:left\">决定如何使用缓存</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ParameterMapping</td>\n<td style=\"text-align:left\">参数映射类</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ResultMapResolver</td>\n<td style=\"text-align:left\">返回值映射</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Map&lt;String, XNode&gt; sqlFragments</td>\n<td style=\"text-align:left\">sql片段</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">MappedStatement</td>\n<td style=\"text-align:left\">Mapper方法的所有信息(出参，入参)</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"_2-1-mapperbuilderassistant\"> 2.1 MapperBuilderAssistant</h2>\n<p>Mapper构建工具类,下面小编列举了几个方法。可以看出来基本都是用于处理sql结果集向java对象转换使用，和对Mapper方法签名分析生成sql的工具。\n下面我们一个一个来看看。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>MapperBuilderAssistant</span> <span>extends</span> <span>BaseBuilder</span> <span>{</span>\n    <span>// 确定使用那个缓存</span>\n    <span>public</span> <span>Cache</span> <span>useCacheRef</span><span>(</span><span>String</span> namespace<span>)</span><span>;</span>\n    <span>// 生成2级缓存对象</span>\n    <span>public</span> <span>Cache</span> <span>useNewCache</span><span>(</span><span>.</span><span>.</span><span>.</span><span>)</span><span>;</span>\n    <span>// 每个参数的信息</span>\n    <span>public</span> <span>ParameterMapping</span> <span>buildParameterMapping</span><span>(</span><span>)</span><span>;</span>\n    <span>// 生成结构集</span>\n    <span>public</span> <span>ResultMap</span> <span>addResultMap</span><span>(</span><span>)</span><span>;</span>\n    <span>// 鉴别器</span>\n    <span>public</span> <span>Discriminator</span> <span>buildDiscriminator</span><span>(</span><span>)</span><span>;</span>\n    <span>// 生成Mapper签名</span>\n    <span>public</span> <span>MappedStatement</span> <span>addMappedStatement</span><span>(</span><span>)</span><span>;</span>\n    <span>// 获取方言处理器</span>\n    <span>public</span> <span>LanguageDriver</span> <span>getLanguageDriver</span><span>(</span><span>Class</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>LanguageDriver</span><span>></span></span> langClass<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id=\"_2-1-1-cache\"> 2.1.1 Cache</h3>\n<p>Mybatis 缓存的接口定义,用于缓存查询sql的结果。Mybatis中一级缓存和二级缓存是一个面试经常会考的问题。这个类我们也单独开一篇私聊。</p>\n<h3 id=\"_2-1-2-parametermapping-resultmapping\"> 2.1.2 ParameterMapping &amp; ResultMapping</h3>\n<p>从名字中能看到就是对Mapper中方法的入参和出参的映射关系类。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>ParameterMapping</span> <span>{</span>\n  <span>private</span> <span>Configuration</span> configuration<span>;</span>\n  <span>private</span> <span>String</span> property<span>;</span>\n  <span>private</span> <span>ParameterMode</span> mode<span>;</span>\n  <span>private</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> javaType <span>=</span> <span>Object</span><span>.</span><span>class</span><span>;</span>\n  <span>private</span> <span>JdbcType</span> jdbcType<span>;</span>\n  <span>private</span> <span>Integer</span> numericScale<span>;</span>\n  <span>private</span> <span>TypeHandler</span><span><span>&lt;</span><span>?</span><span>></span></span> typeHandler<span>;</span>\n  <span>private</span> <span>String</span> resultMapId<span>;</span>\n  <span>private</span> <span>String</span> jdbcTypeName<span>;</span>\n  <span>private</span> <span>String</span> expression<span>;</span>\n<span>}</span>  \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>如图所示,会对方法的每个参数,生成一个 ParameterMapping对象。存储了java类型和db的类型的映射关系。\n<img src=\"https://img.springlearn.cn/blog/learn_1648656572000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_2-1-3-resultmap\"> 2.1.3 ResultMap</h3>\n<p>从名字看就是对jdbc结果集向Mapper返回值的映射关系，用于将jdbc数据重新映射成Java对象。</p>\n<div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>resultSet</span><span>(</span><span>)</span><span>{</span>\n        <span>// 读取配置信息(为什么路径前不用加/,因为是相对路径。maven编译后的资源文件和class文件都是在一个包下,所以不用加/就是当前包目录)</span>\n        <span>InputStream</span> mapperInputStream <span>=</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getContextClassLoader</span><span>(</span><span>)</span><span>.</span><span>getResourceAsStream</span><span>(</span><span>\"mybatisConfig.xml\"</span><span>)</span><span>;</span>\n        <span>// 生成SqlSession工厂,SqlSession从名字上看就是,跟数据库交互的会话信息,负责将sql提交到数据库进行执行</span>\n        <span>SqlSessionFactory</span> sqlSessionFactory <span>=</span> <span>new</span> <span>SqlSessionFactoryBuilder</span><span>(</span><span>)</span><span>.</span><span>build</span><span>(</span>mapperInputStream<span>,</span> <span>\"development\"</span><span>)</span><span>;</span>\n        <span>// 获取Mybatis配置信息</span>\n        <span>Configuration</span> configuration <span>=</span> sqlSessionFactory<span>.</span><span>getConfiguration</span><span>(</span><span>)</span><span>;</span>\n        <span>SqlSession</span> sqlSession <span>=</span> sqlSessionFactory<span>.</span><span>openSession</span><span>(</span><span>false</span><span>)</span><span>;</span>\n        <span>TUserMapper</span> mapper <span>=</span> configuration<span>.</span><span>getMapper</span><span>(</span><span>TUserMapper</span><span>.</span><span>class</span><span>,</span>sqlSession<span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>mapper<span>.</span><span>selectAll</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>MappedStatement</span> mappedStatement <span>=</span> configuration<span>.</span><span>getMappedStatement</span><span>(</span><span>\"orm.example.dal.mapper.TUserMapper.selectAll\"</span><span>)</span><span>;</span>\n        <span>List</span><span><span>&lt;</span><span>ResultMap</span><span>></span></span> resultMaps <span>=</span> mappedStatement<span>.</span><span>getResultMaps</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>resultMaps<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p><img src=\"https://img.springlearn.cn/blog/learn_1648657325000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_2-1-4-languagedriver\"> 2.1.4 LanguageDriver</h3>\n<p>主要用于生成 SqlSource，动态sql(XMLLanguageDriver)或者静态sql(RawLanguageDriver)</p>\n<div><pre><code>\n<span>public</span> <span>interface</span> <span>LanguageDriver</span> <span>{</span>\n \n  <span>ParameterHandler</span> <span>createParameterHandler</span><span>(</span><span>MappedStatement</span> mappedStatement<span>,</span> <span>Object</span> parameterObject<span>,</span> <span>BoundSql</span> boundSql<span>)</span><span>;</span>\n\n  <span>SqlSource</span> <span>createSqlSource</span><span>(</span><span>Configuration</span> configuration<span>,</span> <span>XNode</span> script<span>,</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> parameterType<span>)</span><span>;</span>\n \n  <span>SqlSource</span> <span>createSqlSource</span><span>(</span><span>Configuration</span> configuration<span>,</span> <span>String</span> script<span>,</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> parameterType<span>)</span><span>;</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>动态sql可以处理下面这些标签</p>\n<div><pre><code> <span>private</span> <span>void</span> <span>initNodeHandlerMap</span><span>(</span><span>)</span> <span>{</span>\n    nodeHandlerMap<span>.</span><span>put</span><span>(</span><span>\"trim\"</span><span>,</span> <span>new</span> <span>TrimHandler</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    nodeHandlerMap<span>.</span><span>put</span><span>(</span><span>\"where\"</span><span>,</span> <span>new</span> <span>WhereHandler</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    nodeHandlerMap<span>.</span><span>put</span><span>(</span><span>\"set\"</span><span>,</span> <span>new</span> <span>SetHandler</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    nodeHandlerMap<span>.</span><span>put</span><span>(</span><span>\"foreach\"</span><span>,</span> <span>new</span> <span>ForEachHandler</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    nodeHandlerMap<span>.</span><span>put</span><span>(</span><span>\"if\"</span><span>,</span> <span>new</span> <span>IfHandler</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    nodeHandlerMap<span>.</span><span>put</span><span>(</span><span>\"choose\"</span><span>,</span> <span>new</span> <span>ChooseHandler</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    nodeHandlerMap<span>.</span><span>put</span><span>(</span><span>\"when\"</span><span>,</span> <span>new</span> <span>IfHandler</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    nodeHandlerMap<span>.</span><span>put</span><span>(</span><span>\"otherwise\"</span><span>,</span> <span>new</span> <span>OtherwiseHandler</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    nodeHandlerMap<span>.</span><span>put</span><span>(</span><span>\"bind\"</span><span>,</span> <span>new</span> <span>BindHandler</span><span>(</span><span>)</span><span>)</span><span>;</span>\n  <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id=\"_2-2-cacherefresolver\"> 2.2 CacheRefResolver</h2>\n<p>确定每个Mapper配置的缓存</p>\n<div><pre><code><span>public</span> <span>class</span> <span>CacheRefResolver</span> <span>{</span>\n  <span>private</span> <span>final</span> <span>MapperBuilderAssistant</span> assistant<span>;</span>\n  <span>private</span> <span>final</span> <span>String</span> cacheRefNamespace<span>;</span>\n\n  <span>public</span> <span>CacheRefResolver</span><span>(</span><span>MapperBuilderAssistant</span> assistant<span>,</span> <span>String</span> cacheRefNamespace<span>)</span> <span>{</span>\n    <span>this</span><span>.</span>assistant <span>=</span> assistant<span>;</span>\n    <span>this</span><span>.</span>cacheRefNamespace <span>=</span> cacheRefNamespace<span>;</span>\n  <span>}</span>\n\n  <span>public</span> <span>Cache</span> <span>resolveCacheRef</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> assistant<span>.</span><span>useCacheRef</span><span>(</span>cacheRefNamespace<span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id=\"_2-3-mappedstatement\"> 2.3 MappedStatement</h2>\n<p>可以说关于Mapper所有的信息都在这个类里面,包括sql信息、入参及返回值类型、sql类型（SqlCommandType）、是否使用缓存、\n是否刷新缓存、StatementType类型。</p>\n<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>MappedStatement</span> <span>{</span>\n  <span>// mapper/TUserMapper.xml</span>\n  <span>private</span> <span>String</span> resource<span>;</span>\n  <span>// 全局配置</span>\n  <span>private</span> <span>Configuration</span> configuration<span>;</span>\n  <span>// orm.example.dal.mapper.TUserMapper.insert</span>\n  <span>private</span> <span>String</span> id<span>;</span>\n  <span>// </span>\n  <span>private</span> <span>Integer</span> fetchSize<span>;</span>\n  <span>// 超时时间</span>\n  <span>private</span> <span>Integer</span> timeout<span>;</span>\n  <span>// StatementType.PREPARED</span>\n  <span>private</span> <span>StatementType</span> statementType<span>;</span>\n  <span>// ResultSetType.DEFAULT(-1),</span>\n  <span>private</span> <span>ResultSetType</span> resultSetType<span>;</span>\n  <span>// RawSqlSource</span>\n  <span>private</span> <span>SqlSource</span> sqlSource<span>;</span>\n  <span>private</span> <span>Cache</span> cache<span>;</span>\n  <span>private</span> <span>ParameterMap</span> parameterMap<span>;</span>\n  <span>private</span> <span>List</span><span><span>&lt;</span><span>ResultMap</span><span>></span></span> resultMaps<span>;</span>\n  <span>private</span> <span>boolean</span> flushCacheRequired<span>;</span>\n  <span>private</span> <span>boolean</span> useCache<span>;</span>\n  <span>private</span> <span>boolean</span> resultOrdered<span>;</span>\n  <span>// SqlCommandType（ UNKNOWN, INSERT, UPDATE, DELETE, SELECT, FLUSH）</span>\n  <span>private</span> <span>SqlCommandType</span> sqlCommandType<span>;</span>\n  <span>// 生成id</span>\n  <span>private</span> <span>KeyGenerator</span> keyGenerator<span>;</span>\n  <span>private</span> <span>String</span><span>[</span><span>]</span> keyProperties<span>;</span>\n  <span>private</span> <span>String</span><span>[</span><span>]</span> keyColumns<span>;</span>\n  <span>private</span> <span>boolean</span> hasNestedResultMaps<span>;</span>\n  <span>private</span> <span>String</span> databaseId<span>;</span>\n  <span>private</span> <span>Log</span> statementLog<span>;</span>\n  <span>private</span> <span>LanguageDriver</span> lang<span>;</span>\n  <span>private</span> <span>String</span><span>[</span><span>]</span> resultSets<span>;</span>\n<span>}</span>  \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><p>生成主要有2种方法。</p>\n<ol>\n<li>xml的方式 XMLStatementBuilder</li>\n<li>通过注解的方式 MapperAnnotationBuilder</li>\n</ol>\n<div><pre><code><span>public</span> <span>class</span> <span>XMLMapperBuilder</span> <span>extends</span> <span>BaseBuilder</span> \n    <span>public</span> <span>void</span> <span>parse</span><span>(</span><span>)</span> <span>{</span>\n        <span>// 如果有资源文件先解析xml,并保存到Configuration#addMappedStatement</span>\n        <span>if</span> <span>(</span><span>!</span>configuration<span>.</span><span>isResourceLoaded</span><span>(</span>resource<span>)</span><span>)</span> <span>{</span>\n          <span>// XMLStatementBuilder进行解析</span>\n          <span>configurationElement</span><span>(</span>parser<span>.</span><span>evalNode</span><span>(</span><span>\"/mapper\"</span><span>)</span><span>)</span><span>;</span>\n          configuration<span>.</span><span>addLoadedResource</span><span>(</span>resource<span>)</span><span>;</span>\n          <span>// 同时使用MapperAnnotationBuilder类解析</span>\n          <span>bindMapperForNamespace</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    \n        <span>parsePendingResultMaps</span><span>(</span><span>)</span><span>;</span>\n        <span>parsePendingCacheRefs</span><span>(</span><span>)</span><span>;</span>\n        <span>parsePendingStatements</span><span>(</span><span>)</span><span>;</span>\n      <span>}</span>\n<span>}</span>  \n\n<span>public</span> <span>class</span> <span>MapperAnnotationBuilder</span><span>{</span>\n      <span>// 只有包含了下面注解的方法才会被解析</span>\n      <span>private</span> <span>static</span> <span>final</span> <span>Set</span><span><span>&lt;</span><span>Class</span><span>&lt;</span><span>?</span> <span>extends</span> <span>Annotation</span><span>></span><span>></span></span> statementAnnotationTypes <span>=</span> <span>Stream</span>\n      <span>.</span><span>of</span><span>(</span><span>Select</span><span>.</span><span>class</span><span>,</span> <span>Update</span><span>.</span><span>class</span><span>,</span> <span>Insert</span><span>.</span><span>class</span><span>,</span> <span>Delete</span><span>.</span><span>class</span><span>,</span> <span>SelectProvider</span><span>.</span><span>class</span><span>,</span> <span>UpdateProvider</span><span>.</span><span>class</span><span>,</span>\n          <span>InsertProvider</span><span>.</span><span>class</span><span>,</span> <span>DeleteProvider</span><span>.</span><span>class</span><span>)</span>\n      <span>.</span><span>collect</span><span>(</span><span>Collectors</span><span>.</span><span>toSet</span><span>(</span><span>)</span><span>)</span><span>;</span>\n      \n     <span>public</span>  <span>void</span> <span>parseStatement</span><span>(</span><span>Method</span> method<span>)</span> <span>{</span>\n        <span>final</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> parameterTypeClass <span>=</span> <span>getParameterType</span><span>(</span>method<span>)</span><span>;</span>\n        <span>final</span> <span>LanguageDriver</span> languageDriver <span>=</span> <span>getLanguageDriver</span><span>(</span>method<span>)</span><span>;</span>\n        <span>// 判断是否包含了上面的注解</span>\n        <span>getAnnotationWrapper</span><span>(</span>method<span>,</span> <span>true</span><span>,</span> statementAnnotationTypes<span>)</span>\n        <span>.</span><span>ifPresent</span><span>(</span>statementAnnotation <span>-></span> <span>{</span><span>}</span><span>)</span>\n     <span>}</span>   \n<span>}</span>    \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><p>Mapper配置文件在解析的时候首先,回去解析xml,然后解析注解。如果两种方式都存在那么就会提示错误。</p>\n<div><p>警告</p>\n<p>Caused by: java.lang.IllegalArgumentException: Mapped Statements collection already contains value for orm.example.dal.mapper.TUserMapper.selectAll. please check mapper/TUserMapper.xml and orm/example/dal/mapper/TUserMapper.java (best guess)\nat org.apache.ibatis.session.Configuration<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>St</span><span style=\"margin-right:0.02778em;\">r</span><span>i</span><span>c</span><span style=\"margin-right:0.10903em;\">tM</span><span>a</span><span>p</span><span>.</span><span>p</span><span>u</span><span>t</span><span>(</span><span style=\"margin-right:0.07153em;\">C</span><span>o</span><span>n</span><span style=\"margin-right:0.10764em;\">f</span><span>i</span><span>gu</span><span style=\"margin-right:0.02778em;\">r</span><span>a</span><span>t</span><span>i</span><span>o</span><span>n</span><span>.</span><span>ja</span><span style=\"margin-right:0.03588em;\">v</span><span>a</span><span style=\"margin-right:0.2778em;\"></span><span>:</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1014</span><span>)</span><span>a</span><span>t</span><span style=\"margin-right:0.02778em;\">or</span><span style=\"margin-right:0.03588em;\">g</span><span>.</span><span>a</span><span>p</span><span>a</span><span>c</span><span>h</span><span>e</span><span>.</span><span>iba</span><span>t</span><span>i</span><span>s</span><span>.</span><span>sess</span><span>i</span><span>o</span><span>n</span><span>.</span><span style=\"margin-right:0.07153em;\">C</span><span>o</span><span>n</span><span style=\"margin-right:0.10764em;\">f</span><span>i</span><span>gu</span><span style=\"margin-right:0.02778em;\">r</span><span>a</span><span>t</span><span>i</span><span>o</span><span>n</span></span></span></span>StrictMap.put(Configuration.java:970)</p>\n</div>\n<p>原因就在 StrictMap。</p>\n<div><pre><code><span>public</span> <span>V</span> <span>put</span><span>(</span><span>String</span> key<span>,</span> <span>V</span> value<span>)</span> <span>{</span>\n      <span>if</span> <span>(</span><span>containsKey</span><span>(</span>key<span>)</span><span>)</span> <span>{</span>\n        <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span>name <span>+</span> <span>\" already contains value for \"</span> <span>+</span> key\n            <span>+</span> <span>(</span>conflictMessageProducer <span>==</span> <span>null</span> <span>?</span> <span>\"\"</span> <span>:</span> conflictMessageProducer<span>.</span><span>apply</span><span>(</span><span>super</span><span>.</span><span>get</span><span>(</span>key<span>)</span><span>,</span> value<span>)</span><span>)</span><span>)</span><span>;</span>\n      <span>}</span>\n      <span>if</span> <span>(</span>key<span>.</span><span>contains</span><span>(</span><span>\".\"</span><span>)</span><span>)</span> <span>{</span>\n        <span>final</span> <span>String</span> shortKey <span>=</span> <span>getShortName</span><span>(</span>key<span>)</span><span>;</span>\n        <span>if</span> <span>(</span><span>super</span><span>.</span><span>get</span><span>(</span>shortKey<span>)</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>\n          <span>super</span><span>.</span><span>put</span><span>(</span>shortKey<span>,</span> value<span>)</span><span>;</span>\n        <span>}</span> <span>else</span> <span>{</span>\n          <span>super</span><span>.</span><span>put</span><span>(</span>shortKey<span>,</span> <span>(</span><span>V</span><span>)</span> <span>new</span> <span>Ambiguity</span><span>(</span>shortKey<span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n      <span>}</span>\n      <span>return</span> <span>super</span><span>.</span><span>put</span><span>(</span>key<span>,</span> value<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h2 id=\"三、可以借鉴的知识点\"> 三、可以借鉴的知识点</h2>\n<h2 id=\"_3-1-包装器模式\"> 3.1 包装器模式</h2>\n<p>ObjectWrapper</p>\n<p>ObjectWrapper的主要作用是，提供统一的属性操作方法。主要在MetaObject被使用,如下。</p>\n<div><pre><code>     <span>@Test</span>\n    <span>public</span> <span>void</span> <span>objectWrapper</span><span>(</span><span>)</span> <span>{</span>\n        <span>TUser</span> mock <span>=</span> <span>JMockData</span><span>.</span><span>mock</span><span>(</span><span>TUser</span><span>.</span><span>class</span><span>)</span><span>;</span>\n        <span>MetaObject</span> metaObject <span>=</span> <span>MetaObject</span><span>.</span><span>forObject</span><span>(</span>mock<span>,</span> <span>new</span> <span>DefaultObjectFactory</span><span>(</span><span>)</span><span>,</span> <span>new</span> <span>DefaultObjectWrapperFactory</span><span>(</span><span>)</span><span>,</span> <span>new</span> <span>DefaultReflectorFactory</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>boolean</span> name <span>=</span> metaObject<span>.</span><span>hasGetter</span><span>(</span><span>\"name\"</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span>name<span>)</span> <span>{</span>\n            <span>// iuslA4Xp</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>metaObject<span>.</span><span>getValue</span><span>(</span><span>\"name\"</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span><span>Object</span><span>></span></span> map <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        map<span>.</span><span>put</span><span>(</span><span>\"age\"</span><span>,</span><span>18</span><span>)</span><span>;</span>\n        <span>MetaObject</span> metaMap <span>=</span> <span>MetaObject</span><span>.</span><span>forObject</span><span>(</span>map<span>,</span> <span>new</span> <span>DefaultObjectFactory</span><span>(</span><span>)</span><span>,</span> <span>new</span> <span>DefaultObjectWrapperFactory</span><span>(</span><span>)</span><span>,</span> <span>new</span> <span>DefaultReflectorFactory</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>boolean</span> age <span>=</span> metaMap<span>.</span><span>hasGetter</span><span>(</span><span>\"age\"</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span>age<span>)</span> <span>{</span>\n            <span>// 18 </span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>metaMap<span>.</span><span>getValue</span><span>(</span><span>\"age\"</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h2 id=\"_3-2-metaclass\"> 3.2 MetaClass</h2>\n<p>反射工具类</p>\n<div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>metaClass</span><span>(</span><span>)</span><span>throws</span> <span>Exception</span><span>{</span>\n        <span>MetaClass</span> metaClass <span>=</span> <span>MetaClass</span><span>.</span><span>forClass</span><span>(</span><span>TUser</span><span>.</span><span>class</span><span>,</span> <span>new</span> <span>DefaultReflectorFactory</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>TUser</span> blankUser <span>=</span> <span>new</span> <span>TUser</span><span>(</span><span>)</span><span>;</span>\n        metaClass<span>.</span><span>getSetInvoker</span><span>(</span><span>\"name\"</span><span>)</span><span>.</span><span>invoke</span><span>(</span>blankUser<span>,</span><span>new</span> <span>Object</span><span>[</span><span>]</span><span>{</span><span>\"孙悟空\"</span><span>}</span><span>)</span><span>;</span>\n        <span>// 孙悟空</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>blankUser<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div>",
      "image": "https://img.springlearn.cn/blog/learn_1648542576000.png",
      "date_published": "2022-03-28T15:13:45.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Mybatis"
      ]
    },
    {
      "title": "第01篇:Mybatis学习之环境搭建",
      "url": "https://java.springlearn.cn/learn/mybatis/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/",
      "id": "https://java.springlearn.cn/learn/mybatis/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/",
      "content_html": "<PageBanner/>\n<h2 id=\"一、环境搭建\"> 一、环境搭建</h2>\n<h3 id=\"_1-1-数据库脚本\"> 1.1 数据库脚本</h3>\n<div><pre><code><span>SET</span> NAMES utf8<span>;</span>\n<span>SET</span> FOREIGN_KEY_CHECKS <span>=</span> <span>0</span><span>;</span>\n\n<span>-- ----------------------------</span>\n<span>--  Table structure for `T_USER`</span>\n<span>-- ----------------------------</span>\n<span>DROP</span> <span>TABLE</span> <span>IF</span> <span>EXISTS</span> <span><span>`</span>T_USER<span>`</span></span><span>;</span>\n<span>CREATE</span> <span>TABLE</span> <span><span>`</span>T_USER<span>`</span></span> <span>(</span>\n  <span><span>`</span>uid<span>`</span></span> <span>int</span><span>(</span><span>11</span><span>)</span> <span>NOT</span> <span>NULL</span> <span>AUTO_INCREMENT</span> <span>COMMENT</span> <span>'用户id'</span><span>,</span>\n  <span><span>`</span>name<span>`</span></span> <span>char</span><span>(</span><span>32</span><span>)</span> <span>DEFAULT</span> <span>NULL</span><span>,</span>\n  <span><span>`</span>token_id<span>`</span></span> <span>char</span><span>(</span><span>64</span><span>)</span> <span>NOT</span> <span>NULL</span><span>,</span>\n  <span>PRIMARY</span> <span>KEY</span> <span>(</span><span><span>`</span>uid<span>`</span></span><span>,</span><span><span>`</span>token_id<span>`</span></span><span>)</span>\n<span>)</span> <span>ENGINE</span><span>=</span><span>InnoDB</span> <span>DEFAULT</span> <span>CHARSET</span><span>=</span>utf8<span>;</span>\n\n<span>SET</span> FOREIGN_KEY_CHECKS <span>=</span> <span>1</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id=\"_1-2-pom依赖\"> 1.2 POM依赖</h3>\n<div><pre><code><span><span><span>&lt;</span>plugin</span><span>></span></span>\n    <span><span><span>&lt;</span>groupId</span><span>></span></span>org.mybatis.generator<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n    <span><span><span>&lt;</span>artifactId</span><span>></span></span>mybatis-generator-maven-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n    <span><span><span>&lt;</span>version</span><span>></span></span>1.3.2<span><span><span>&lt;/</span>version</span><span>></span></span>\n    <span><span><span>&lt;</span>configuration</span><span>></span></span>\n        <span><span><span>&lt;</span>configurationFile</span><span>></span></span>${basedir}/src/main/resources/generator/generatorConfig.xml<span><span><span>&lt;/</span>configurationFile</span><span>></span></span>\n        <span><span><span>&lt;</span>overwrite</span><span>></span></span>true<span><span><span>&lt;/</span>overwrite</span><span>></span></span>\n        <span><span><span>&lt;</span>verbose</span><span>></span></span>true<span><span><span>&lt;/</span>verbose</span><span>></span></span>\n    <span><span><span>&lt;/</span>configuration</span><span>></span></span>\n<span><span><span>&lt;/</span>plugin</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id=\"_1-3-执行脚本生成代码\"> 1.3 执行脚本生成代码</h3>\n<p>mysql数据库记得要安装好,如果clone代码下来学习,记得要改成自己的数据库。\n当上面的步骤都完成后,并输入自己的mysql地址和用户信息后。就可以执行下面脚本了。</p>\n<p><code>mvn mybatis-generator:generate</code></p>\n<p>执行后就会生成我们本节要说的所有内容代码了。</p>\n<div><pre><code>➜ tree\n.\n├── LICENSE\n├── README.md\n├── pom.xml\n└── src\n    ├── main\n    │   ├── java\n    │   │   └── orm\n    │   │       └── example\n    │   │           └── dal\n    │   │               ├── mapper\n    │   │               │   └── TUserMapper.java\n    │   │               └── model\n    │   │                   └── TUser.java\n    │   └── resources\n    │       ├── generator\n    │       │   └── generatorConfig.xml\n    │       └── mapper\n    │           └── TUserMapper.xml\n    └── test\n        └── java\n\n13 directories, 7 files\n\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><h2 id=\"二、原生jdbc知识复习\"> 二、原生jdbc知识复习</h2>\n<h2 id=\"_2-1-jdbc是什么\"> 2.1 JDBC是什么？</h2>\n<p>JDBC代表Java数据库连接(Java Database Connectivity)，它是用于Java编程语言和数据库之间的数据库无关连接的标准Java API，换句话说：JDBC是用于在Java语言编程中与数据库连接的API。</p>\n<ol>\n<li>连接到数据库</li>\n<li>创建SQL或MySQL语句</li>\n<li>在数据库中执行SQL或MySQL查询</li>\n<li>查看和修改结果记录</li>\n</ol>\n<h3 id=\"_2-1-1-代码示例\"> 2.1.1 代码示例</h3>\n<div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>jdbc</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>String</span> dbUrl <span>=</span> <span>\"jdbc:mysql://127.0.0.1:3306/test\"</span><span>;</span>\n        <span>String</span> user <span>=</span> <span>\"root\"</span><span>;</span>\n        <span>String</span> pass <span>=</span> <span>\"123456\"</span><span>;</span>\n        <span>Connection</span> connection <span>=</span> <span>DriverManager</span><span>.</span><span>getConnection</span><span>(</span>dbUrl<span>,</span> user<span>,</span> pass<span>)</span><span>;</span>\n        <span>Statement</span> statement <span>=</span> connection<span>.</span><span>createStatement</span><span>(</span><span>)</span><span>;</span>\n        <span>ResultSet</span> resultSet <span>=</span> statement<span>.</span><span>executeQuery</span><span>(</span><span>\"select * from T_User\"</span><span>)</span><span>;</span>\n        <span>while</span> <span>(</span>resultSet<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n            <span>String</span> name <span>=</span> resultSet<span>.</span><span>getString</span><span>(</span><span>\"name\"</span><span>)</span><span>;</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>name<span>)</span><span>;</span>\n        <span>}</span>\n        statement<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n        resultSet<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n        connection<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id=\"_2-2-jdbc知识点\"> 2.2 jdbc知识点</h2>\n<h3 id=\"_2-2-1-jdbc驱动\"> 2.2.1 jdbc驱动</h3>\n<p>通过前面的例子,我们看到我们都是调用 java.sql的包下面的类创建的与数据库交互的工具。那么我们试想一下。\njava怎么知道我们用的数据库是什么呢? 如果不知道他怎么知道如何进行交互呢?</p>\n<p>其实就是 java.sql定义了一系列的接口定义, 由具体的第三方数据库来实现这些定义。从而进行底层的交互。\n这里因为我们使用的是mysql数据库，所以 Connection的具体实现就是mysql的数据驱动类 ConnectionImpl。</p>\n<p>DriverManager 怎么知道我们要用mysql的实现呢? 这里面用到的数据就是java原生的spi能力。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1648648826000.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code> <span>private</span> <span>static</span> <span>void</span> <span>loadInitialDrivers</span><span>(</span><span>)</span> <span>{</span>\n    <span>ServiceLoader</span><span><span>&lt;</span><span>Driver</span><span>></span></span> loadedDrivers <span>=</span> <span>ServiceLoader</span><span>.</span><span>load</span><span>(</span><span>Driver</span><span>.</span><span>class</span><span>)</span><span>;</span>\n    <span>Iterator</span><span><span>&lt;</span><span>Driver</span><span>></span></span> driversIterator <span>=</span> loadedDrivers<span>.</span><span>iterator</span><span>(</span><span>)</span><span>;</span>\n <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>当获得了与数据库的连接后，就可以与数据库进行交互了。 JDBC Statement，CallableStatement和PreparedStatement接口定义了可用于发送SQL或PL/SQL命令，并从数据库接收数据的方法和属性。\n它们还定义了有助于在Java和SQL数据类型的数据类型差异转换的方法。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">接口</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:left\">特点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Statement</td>\n<td style=\"text-align:left\">用于对数据库进行通用访问，在运行时使用静态SQL语句时很有用。 Statement接口不能接受参数。</td>\n<td style=\"text-align:left\">Statement每次的执行都需要编译SQL</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">PreparedStatement</td>\n<td style=\"text-align:left\">当计划要多次使用SQL语句时使用。PreparedStatement接口在运行时接受输入参数。</td>\n<td style=\"text-align:left\">PreparedStatement会预编译，会被缓冲，在缓存区中可以发现预编译的命令，虽然会被再次解析，但不会被再次编译，能够有效提高系统性能</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CallableStatement</td>\n<td style=\"text-align:left\">当想要访问数据库存储过程时使用。CallableStatement接口也可以接受运行时输入参数。</td>\n<td style=\"text-align:left\">CallableStatement支持存储过程</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_2-2-2-statement\"> 2.2.2 Statement</h3>\n<p>Statement对象后，可以使用它来执行一个SQL语句，它有三个执行方法可以执行</p>\n<ul>\n<li>boolean execute (String SQL) ： 如果可以检索到ResultSet对象，则返回一个布尔值true; 否则返回false。使用此方法执行SQLDDL语句或需要使用真正的动态SQL，可使用于执行创建数据库，创建表的SQL语句等等。</li>\n<li>int executeUpdate (String SQL): 返回受SQL语句执行影响的行数。使用此方法执行预期会影响多行的SQL语句，例如:INSERT，UPDATE或DELETE语句。</li>\n<li>ResultSet executeQuery(String SQL)：返回一个ResultSet对象。 当您希望获得结果集时，请使用此方法，就像使用SELECT语句一样。</li>\n</ul>\n<div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>statement</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>String</span> dbUrl <span>=</span> <span>\"jdbc:mysql://127.0.0.1:3306/test\"</span><span>;</span>\n        <span>String</span> user <span>=</span> <span>\"root\"</span><span>;</span>\n        <span>String</span> pass <span>=</span> <span>\"123456\"</span><span>;</span>\n        <span>Connection</span> connection <span>=</span> <span>DriverManager</span><span>.</span><span>getConnection</span><span>(</span>dbUrl<span>,</span> user<span>,</span> pass<span>)</span><span>;</span>\n        connection<span>.</span><span>setAutoCommit</span><span>(</span><span>false</span><span>)</span><span>;</span>\n        <span>Statement</span> statement <span>=</span> connection<span>.</span><span>createStatement</span><span>(</span><span>)</span><span>;</span>\n        <span>// true</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>statement<span>.</span><span>execute</span><span>(</span><span>\"insert into t_user (name,token_id) values ('孙武空','007')\"</span><span>)</span><span>)</span><span>;</span>\n        <span>ResultSet</span> resultSet <span>=</span> statement<span>.</span><span>executeQuery</span><span>(</span><span>\"select * from t_user\"</span><span>)</span><span>;</span>\n        <span>while</span> <span>(</span>resultSet<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n            <span>String</span> name <span>=</span> resultSet<span>.</span><span>getString</span><span>(</span><span>\"name\"</span><span>)</span><span>;</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>name<span>)</span><span>;</span>\n        <span>}</span>\n        connection<span>.</span><span>rollback</span><span>(</span><span>)</span><span>;</span>\n        statement<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n        connection<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h3 id=\"_2-2-3-preparedstatement\"> 2.2.3 PreparedStatement</h3>\n<p>PreparedStatement接口扩展了Statement接口，它添加了比Statement对象更好一些优点的功能。\n此语句可以动态地提供/接受参数。</p>\n<div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>prepareStatement</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>String</span> dbUrl <span>=</span> <span>\"jdbc:mysql://127.0.0.1:3306/test\"</span><span>;</span>\n        <span>String</span> user <span>=</span> <span>\"root\"</span><span>;</span>\n        <span>String</span> pass <span>=</span> <span>\"123456\"</span><span>;</span>\n        <span>Connection</span> connection <span>=</span> <span>DriverManager</span><span>.</span><span>getConnection</span><span>(</span>dbUrl<span>,</span> user<span>,</span> pass<span>)</span><span>;</span>\n        connection<span>.</span><span>setAutoCommit</span><span>(</span><span>false</span><span>)</span><span>;</span>\n        <span>PreparedStatement</span> preparedStatement <span>=</span> connection<span>.</span><span>prepareStatement</span><span>(</span><span>\"insert into t_user (name,token_id) values (?,?)\"</span><span>)</span><span>;</span>\n        preparedStatement<span>.</span><span>setString</span><span>(</span><span>1</span><span>,</span> <span>\"唐三藏\"</span><span>)</span><span>;</span>\n        preparedStatement<span>.</span><span>setString</span><span>(</span><span>2</span><span>,</span> <span>\"tok\"</span><span>)</span><span>;</span>\n        preparedStatement<span>.</span><span>execute</span><span>(</span><span>)</span><span>;</span>\n\n        <span>ResultSet</span> resultSet <span>=</span> preparedStatement<span>.</span><span>executeQuery</span><span>(</span><span>\"select * from t_user\"</span><span>)</span><span>;</span>\n        <span>while</span> <span>(</span>resultSet<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n            <span>String</span> name <span>=</span> resultSet<span>.</span><span>getString</span><span>(</span><span>\"name\"</span><span>)</span><span>;</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>name<span>)</span><span>;</span>\n        <span>}</span>\n        connection<span>.</span><span>rollback</span><span>(</span><span>)</span><span>;</span>\n        preparedStatement<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n        connection<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h3 id=\"_2-2-4-callablestatement\"> 2.2.4 CallableStatement</h3>\n<p>类似Connection对象创建Statement和PreparedStatement对象一样，它还可以使用同样的方式创建CallableStatement对象，该对象将用于执行对数据库存储过程的调用。</p>\n<div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>callableStatement</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>String</span> dbUrl <span>=</span> <span>\"jdbc:mysql://127.0.0.1:3306/test\"</span><span>;</span>\n        <span>String</span> user <span>=</span> <span>\"root\"</span><span>;</span>\n        <span>String</span> pass <span>=</span> <span>\"123456\"</span><span>;</span>\n        <span>Connection</span> connection <span>=</span> <span>DriverManager</span><span>.</span><span>getConnection</span><span>(</span>dbUrl<span>,</span> user<span>,</span> pass<span>)</span><span>;</span>\n        <span>// 1. 创建一个存储过程</span>\n        <span>String</span> call <span>=</span>\n                <span>\"CREATE PROCEDURE delete_matches(IN del_name varchar(64))\\n\"</span> <span>+</span>\n                        <span>\"begin\\n\"</span> <span>+</span>\n                        <span>\"    delete from t_user where name = del_name;\\n\"</span> <span>+</span>\n                        <span>\"end;\"</span><span>;</span>\n        <span>Statement</span> statement <span>=</span> connection<span>.</span><span>createStatement</span><span>(</span><span>)</span><span>;</span>\n        statement<span>.</span><span>execute</span><span>(</span><span>\"DROP PROCEDURE IF EXISTS delete_matches;\"</span><span>)</span><span>;</span>\n        statement<span>.</span><span>execute</span><span>(</span>call<span>)</span><span>;</span>\n\n        <span>// 执行存储过程</span>\n        <span>CallableStatement</span> callableStatement <span>=</span> connection<span>.</span><span>prepareCall</span><span>(</span><span>\"call delete_matches(?)\"</span><span>)</span><span>;</span>\n        callableStatement<span>.</span><span>setString</span><span>(</span><span>1</span><span>,</span> <span>\"孙武空\"</span><span>)</span><span>;</span>\n        callableStatement<span>.</span><span>execute</span><span>(</span><span>)</span><span>;</span>\n\n        <span>// 查询结果检查存储过程是否成功</span>\n        <span>ResultSet</span> resultSet <span>=</span> statement<span>.</span><span>executeQuery</span><span>(</span><span>\"select * from t_user\"</span><span>)</span><span>;</span>\n        <span>while</span> <span>(</span>resultSet<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n            <span>String</span> name <span>=</span> resultSet<span>.</span><span>getString</span><span>(</span><span>\"name\"</span><span>)</span><span>;</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>name<span>)</span><span>;</span>\n        <span>}</span>\n        statement<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n        callableStatement<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n        connection<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><div><p>提示</p>\n<p>jdbc主要提供跟数据库的交互,其主要的类就是上面演示的。通过上面的复习。我们要清楚下面几个类的作用。\n后面我们在学习mybatis时候,我们看mybatis是如何对下面类的封装,从而实现orm映射的。</p>\n</div>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">关键类</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Connection</td>\n<td style=\"text-align:left\">数据库连接</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Statement</td>\n<td style=\"text-align:left\">静态sql执行</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">PreparedStatement</td>\n<td style=\"text-align:left\">预处理sql</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CallableStatement</td>\n<td style=\"text-align:left\">存储过程执行</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ResultSet</td>\n<td style=\"text-align:left\">返回结果集</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"三、抛转引玉\"> 三、抛转引玉</h2>\n<p>前面我们首先搭建了mybaits的开发环境,然后又对jdbc的知识进行了复习。下面我们就开始学习mybait的源码,看mybatis是如何对\njdbc一步一步进行封装从而实现了orm的映射吧。\n首先我们先看下下面演示代码。</p>\n<div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>mapper</span><span>(</span><span>)</span> <span>{</span>\n        <span>// 读取配置信息(为什么路径前不用加/,因为是相对路径。maven编译后的资源文件和class文件都是在一个包下,所以不用加/就是当前包目录)</span>\n        <span>InputStream</span> mapperInputStream <span>=</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getContextClassLoader</span><span>(</span><span>)</span><span>.</span><span>getResourceAsStream</span><span>(</span><span>\"mybatisConfig.xml\"</span><span>)</span><span>;</span>\n        <span>// 生成SqlSession工厂,SqlSession从名字上看就是,跟数据库交互的会话信息,负责将sql提交到数据库进行执行</span>\n        <span>SqlSessionFactory</span> sqlSessionFactory <span>=</span> <span>new</span> <span>SqlSessionFactoryBuilder</span><span>(</span><span>)</span><span>.</span><span>build</span><span>(</span>mapperInputStream<span>,</span> <span>\"development\"</span><span>)</span><span>;</span>\n        <span>// 获取Mybatis配置信息</span>\n        <span>Configuration</span> configuration <span>=</span> sqlSessionFactory<span>.</span><span>getConfiguration</span><span>(</span><span>)</span><span>;</span>\n        <span>// 参数: autoCommit,从名字上看就是是否自动提交事务</span>\n        <span>SqlSession</span> sqlSession <span>=</span> sqlSessionFactory<span>.</span><span>openSession</span><span>(</span><span>false</span><span>)</span><span>;</span>\n        <span>// 获取Mapper</span>\n        <span>TUserMapper</span> mapper <span>=</span> configuration<span>.</span><span>getMapperRegistry</span><span>(</span><span>)</span><span>.</span><span>getMapper</span><span>(</span><span>TUserMapper</span><span>.</span><span>class</span><span>,</span> sqlSession<span>)</span><span>;</span>\n        <span>TUser</span> tUser <span>=</span> <span>new</span> <span>TUser</span><span>(</span><span>)</span><span>;</span>\n        tUser<span>.</span><span>setName</span><span>(</span><span>\"testUser1\"</span><span>)</span><span>;</span>\n        tUser<span>.</span><span>setTokenId</span><span>(</span><span>\"testTokenId1\"</span><span>)</span><span>;</span>\n        mapper<span>.</span><span>insert</span><span>(</span>tUser<span>)</span><span>;</span>\n        <span>// 获取插入的数据</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>mapper<span>.</span><span>selectAll</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// 数据插入后，执行查询，然后回滚数据</span>\n        sqlSession<span>.</span><span>rollback</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>jdbc的原生操作基本已经看不到了。我们已经使用Mybatis实现了与数据库的交互。可以看到并没有看到sql信息。\n因为sql信息都维护在TUserMapper.xml里面,Mybatis帮我们把TUserMapper.xml和TUserMapper建立了关系。\n最终将原本要通过jdbc实现的操作通过代理的方式，并最终通过TUserMapper这个接口进行交互了。</p>\n<p>请问到这里勾起你的好奇心了没有呢? 想不想知道为什么能这样吗? 想不想知道mybaits究竟做了什么,以及是怎么做的呢?\n本系列文章会带你一探究竟。在开始之前我们先指定一下学习目标吧。</p>\n<h2 id=\"_3-1-学习目标制定\"> 3.1 学习目标制定</h2>\n<ul>\n<li>配置文件是如何解析成 <code>Configuration</code> ?</li>\n<li><code>sql</code> 和数据库是如何交互的 <code>SqlSession</code> ?</li>\n<li><code>mapper.xml</code> 和 <code>Mapper</code> 是如何绑定的<code>MapperRegistry</code> ?</li>\n<li><code>Mybatis</code> 是如何做动态代理的 ?</li>\n<li>Mybatis中如何利用插件实现扩展的?</li>\n<li>Jdbc的Statement在Mybatis是如何封装的?</li>\n<li>以及Mybatis中很多好用的工具类.</li>\n</ul>\n<h2 id=\"_3-2-学习后我们能得到什么\"> 3.2 学习后我们能得到什么</h2>\n<ul>\n<li>从配置文件解析中我们能学会,如果解析占位符。并将占位符填充真实数据。</li>\n<li>通过对 <code>SqlSession</code> 的学习,我们会了解到Mybatis的缓存设计,批处理任务,事务等操作。</li>\n<li>通过对 <code>MapperRegistry</code> 的学习, 我们会了解到如何实现 <code>orm(对象关系映射)</code> 框架。</li>\n<li>我们会收货很多设计的思路，而思路决定出路。</li>\n</ul>\n",
      "image": "https://img.springlearn.cn/blog/learn_1648648826000.png",
      "date_published": "2022-03-28T15:13:45.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Mybatis"
      ]
    },
    {
      "title": "Get新技能,Java实现文件监控",
      "url": "https://java.springlearn.cn/learn/other/java-watch-file/",
      "id": "https://java.springlearn.cn/learn/other/java-watch-file/",
      "content_html": "<p><strong>作者: 八阿哥的剑</strong></p>\n<p><em>博客: https://springlearn.cn</em></p>\n<div><p>一日一句毒鸡汤</p>\n<p>问世间钱为何物，只叫人生死相许。！😄</p>\n</div>\n<h2 id=\"java原生版本监控\"> Java原生版本监控</h2>\n<div><pre><code><span>public</span> <span>class</span> <span>JavaWatchAPI</span> <span>{</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>//第一步：取得WatchService</span>\n        <span>WatchService</span> watchService <span>=</span> <span>FileSystems</span><span>.</span><span>getDefault</span><span>(</span><span>)</span><span>.</span><span>newWatchService</span><span>(</span><span>)</span><span>;</span>\n        <span>//第二步：确定要监控的路径</span>\n        <span>Path</span> path <span>=</span> <span>Paths</span><span>.</span><span>get</span><span>(</span><span>\"/Users/liuxin/Github/nobug-learn-project/nobug-learn-01/src/main/java\"</span><span>)</span><span>;</span>\n\n        <span>//第三步：为本路径绑定WatchService，并确定监控的事件</span>\n        path<span>.</span><span>register</span><span>(</span>\n                watchService<span>,</span>\n                <span>// StandardWatchEventKinds.ENTRY_CREATE—当有新文件时触发。可能是创建了一个新文件</span>\n                <span>StandardWatchEventKinds</span><span>.</span>ENTRY_CREATE<span>,</span>\n                <span>// StandardWatchEventKinds.ENTRY_DELETE—当文件被删除、移动或重命名时触发</span>\n                <span>StandardWatchEventKinds</span><span>.</span>ENTRY_DELETE<span>,</span>\n                <span>// StandardWatchEventKinds.ENTRY_MODIFY—当文件被修改时触发。</span>\n                <span>StandardWatchEventKinds</span><span>.</span>ENTRY_MODIFY<span>)</span><span>;</span>\n        <span>// StandardWatchEventKinds.OVERFLOW—触发表示丢失或丢弃的事件。</span>\n        <span>WatchKey</span> key <span>=</span> <span>null</span><span>;</span>\n        <span>while</span> <span>(</span><span>(</span>key <span>=</span> watchService<span>.</span><span>take</span><span>(</span><span>)</span><span>)</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n            <span>for</span> <span>(</span><span>WatchEvent</span><span><span>&lt;</span><span>?</span><span>></span></span> event <span>:</span> key<span>.</span><span>pollEvents</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"事件\"</span> <span>+</span> event<span>.</span><span>kind</span><span>(</span><span>)</span> <span>+</span> <span>\"发生了，文件是：\"</span> <span>+</span> event<span>.</span><span>context</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>}</span>\n            key<span>.</span><span>reset</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><h2 id=\"common-io-工具包监控\"> Common IO 工具包监控</h2>\n<div><pre><code><span>package</span> <span>cn<span>.</span>github<span>.</span>chinesszz</span><span>;</span>\n\n<span>import</span> <span>org<span>.</span>apache<span>.</span>commons<span>.</span>io<span>.</span>filefilter<span>.</span></span><span>FileFilterUtils</span><span>;</span>\n<span>import</span> <span>org<span>.</span>apache<span>.</span>commons<span>.</span>io<span>.</span>monitor<span>.</span></span><span>FileAlterationListener</span><span>;</span>\n<span>import</span> <span>org<span>.</span>apache<span>.</span>commons<span>.</span>io<span>.</span>monitor<span>.</span></span><span>FileAlterationMonitor</span><span>;</span>\n<span>import</span> <span>org<span>.</span>apache<span>.</span>commons<span>.</span>io<span>.</span>monitor<span>.</span></span><span>FileAlterationObserver</span><span>;</span>\n<span>import</span> <span>org<span>.</span>junit<span>.</span></span><span>Test</span><span>;</span>\n\n<span>import</span> <span>java<span>.</span>io<span>.</span></span><span>File</span><span>;</span>\n<span>import</span> <span>java<span>.</span>util<span>.</span>concurrent<span>.</span></span><span>TimeUnit</span><span>;</span>\n\n<span>/**\n * @author liuxin\n * 2021/11/9 8:55 下午\n */</span>\n<span>public</span> <span>class</span> <span>CommonIOAPI</span> <span>{</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>File</span> directory <span>=</span> <span>new</span> <span>File</span><span>(</span><span>\"/Users/liuxin/Github/nobug-learn-project/nobug-learn-01/src/main/java\"</span><span>)</span><span>;</span>\n        <span>// 轮询间隔 5 秒</span>\n        <span>long</span> interval <span>=</span> <span>TimeUnit</span><span>.</span>SECONDS<span>.</span><span>toMillis</span><span>(</span><span>5</span><span>)</span><span>;</span>\n        <span>// 创建一个文件观察器用于处理文件的格式</span>\n        <span>FileAlterationObserver</span> observer <span>=</span> <span>new</span> <span>FileAlterationObserver</span><span>(</span>directory<span>,</span> <span>FileFilterUtils</span><span>.</span><span>and</span><span>(</span>\n                <span>FileFilterUtils</span><span>.</span><span>fileFileFilter</span><span>(</span><span>)</span><span>,</span> <span>FileFilterUtils</span><span>.</span><span>suffixFileFilter</span><span>(</span><span>\".txt\"</span><span>)</span><span>,</span>\n                <span>FileFilterUtils</span><span>.</span><span>prefixFileFilter</span><span>(</span><span>\"lx\"</span><span>)</span><span>)</span><span>)</span><span>;</span>\n        <span>// 设置文件变化监听器</span>\n        observer<span>.</span><span>addListener</span><span>(</span><span>new</span> <span>MyFileListener</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>FileAlterationMonitor</span> monitor <span>=</span> <span>new</span> <span>FileAlterationMonitor</span><span>(</span>interval<span>,</span> observer<span>)</span><span>;</span>\n        monitor<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>1</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>watchDir</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>File</span> directory <span>=</span> <span>new</span> <span>File</span><span>(</span><span>\"/Users/liuxin/Github/nobug-learn-project/nobug-learn-01/src/main/java\"</span><span>)</span><span>;</span>\n        <span>FileAlterationObserver</span> fileAlterationObserver <span>=</span> <span>new</span> <span>FileAlterationObserver</span><span>(</span>directory<span>,</span> <span>FileFilterUtils</span><span>.</span><span>and</span><span>(</span>\n                <span>FileFilterUtils</span><span>.</span><span>directoryFileFilter</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>\n        <span>long</span> interval <span>=</span> <span>TimeUnit</span><span>.</span>SECONDS<span>.</span><span>toMillis</span><span>(</span><span>5</span><span>)</span><span>;</span>\n        <span>// 设置文件变化监听器</span>\n        fileAlterationObserver<span>.</span><span>addListener</span><span>(</span><span>new</span> <span>MyFileListener</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>FileAlterationMonitor</span> monitor <span>=</span> <span>new</span> <span>FileAlterationMonitor</span><span>(</span>interval<span>,</span> fileAlterationObserver<span>)</span><span>;</span>\n        monitor<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        <span>while</span> <span>(</span><span>true</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>static</span> <span>final</span> <span>class</span> <span>MyFileListener</span> <span>implements</span> <span>FileAlterationListener</span> <span>{</span>\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>onStart</span><span>(</span><span>FileAlterationObserver</span> fileAlterationObserver<span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"monitor start scan files..\"</span><span>)</span><span>;</span>\n        <span>}</span>\n\n\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>onDirectoryCreate</span><span>(</span><span>File</span> file<span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>file<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\" director created.\"</span><span>)</span><span>;</span>\n        <span>}</span>\n\n\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>onDirectoryChange</span><span>(</span><span>File</span> file<span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>file<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\" director changed.\"</span><span>)</span><span>;</span>\n        <span>}</span>\n\n\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>onDirectoryDelete</span><span>(</span><span>File</span> file<span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>file<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\" director deleted.\"</span><span>)</span><span>;</span>\n        <span>}</span>\n\n\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>onFileCreate</span><span>(</span><span>File</span> file<span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>file<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\" created.\"</span><span>)</span><span>;</span>\n        <span>}</span>\n\n\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>onFileChange</span><span>(</span><span>File</span> file<span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>file<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\" changed.\"</span><span>)</span><span>;</span>\n        <span>}</span>\n\n\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>onFileDelete</span><span>(</span><span>File</span> file<span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>file<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\" deleted.\"</span><span>)</span><span>;</span>\n        <span>}</span>\n\n\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>onStop</span><span>(</span><span>FileAlterationObserver</span> fileAlterationObserver<span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"monitor stop scanning..\"</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br></div></div>",
      "date_published": "2021-12-21T05:46:37.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "第02篇:Mybatis配置文件解析",
      "url": "https://java.springlearn.cn/learn/mybatis/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/",
      "id": "https://java.springlearn.cn/learn/mybatis/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/",
      "content_html": "<PageBanner/>\n<h2 id=\"一、配置文件分析\"> 一、配置文件分析</h2>\n<div><p>文件分析</p>\n<p>在上一篇的代码中,我们看到了一个非常重要文件,这里我们先来人肉分析看,然后看下代码是如何解析的,毕竟代码也是人写的。\n思路决定出路,我们如果有思路,然后在看源码会更加的具有分析的能动性。</p>\n</div>\n<i>Not supported content</i>\n<div><div><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>mapper</span><span>(</span><span>)</span> <span>{</span>\n        <span>// 读取配置信息(为什么路径前不用加/,因为是相对路径。maven编译后的资源文件和class文件都是在一个包下,所以不用加/就是当前包目录)</span>\n        <span>InputStream</span> mapperInputStream <span>=</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getContextClassLoader</span><span>(</span><span>)</span><span>.</span><span>getResourceAsStream</span><span>(</span><span>\"mybatisConfig.xml\"</span><span>)</span><span>;</span>\n        <span>// 生成SqlSession工厂,SqlSession从名字上看就是,跟数据库交互的会话信息,负责将sql提交到数据库进行执行</span>\n        <span>SqlSessionFactory</span> sqlSessionFactory <span>=</span> <span>new</span> <span>SqlSessionFactoryBuilder</span><span>(</span><span>)</span><span>.</span><span>build</span><span>(</span>mapperInputStream<span>,</span> <span>\"development\"</span><span>)</span><span>;</span>\n        <span>// 获取Mybatis配置信息</span>\n        <span>Configuration</span> configuration <span>=</span> sqlSessionFactory<span>.</span><span>getConfiguration</span><span>(</span><span>)</span><span>;</span>\n        <span>// 参数: autoCommit,从名字上看就是是否自动提交事务</span>\n        <span>SqlSession</span> sqlSession <span>=</span> sqlSessionFactory<span>.</span><span>openSession</span><span>(</span><span>false</span><span>)</span><span>;</span>\n        <span>// 获取Mapper</span>\n        <span>TUserMapper</span> mapper <span>=</span> configuration<span>.</span><span>getMapperRegistry</span><span>(</span><span>)</span><span>.</span><span>getMapper</span><span>(</span><span>TUserMapper</span><span>.</span><span>class</span><span>,</span> sqlSession<span>)</span><span>;</span>\n        <span>TUser</span> tUser <span>=</span> <span>new</span> <span>TUser</span><span>(</span><span>)</span><span>;</span>\n        tUser<span>.</span><span>setName</span><span>(</span><span>\"testUser1\"</span><span>)</span><span>;</span>\n        tUser<span>.</span><span>setTokenId</span><span>(</span><span>\"testTokenId1\"</span><span>)</span><span>;</span>\n        mapper<span>.</span><span>insert</span><span>(</span>tUser<span>)</span><span>;</span>\n        <span>// 获取插入的数据</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>mapper<span>.</span><span>selectAll</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// 数据插入后，执行查询，然后回滚数据</span>\n        sqlSession<span>.</span><span>rollback</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h3 id=\"_1-1-mybatisconfig-xml\"> 1.1 mybatisConfig.xml</h3>\n<div><p>注意看高亮行</p>\n<ol>\n<li>line(4) dtd文件是xml的约束文件,用于约束 <code>xml</code> 标签中属性</li>\n<li>line(8) properties标签,指定了配置信息文件是 <code>application.properties</code></li>\n<li>line(11-13) mybatis的配置信息</li>\n<li>line(15-27) mybatis支持多环境配置</li>\n<li>line(30-32) 映射文件</li>\n</ol>\n</div>\n<p>基于上面的行，我们来讲解。</p>\n<div><div><br><br><br><div>&nbsp;</div><br><br><br><div>&nbsp;</div><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br></div><pre><code><span>&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?></span>\n<span><span>&lt;!</span><span>DOCTYPE</span> <span>configuration</span>\n        <span>PUBLIC</span> <span>\"-//mybatis.org//DTD Config 3.0//EN\"</span>\n        <span>\"http://mybatis.org/dtd/mybatis-3-config.dtd\"</span><span>></span></span>\n<span><span><span>&lt;</span>configuration</span><span>></span></span>\n\n    <span>&lt;!-- 指定properties配置文件， 我这里面配置的是数据库相关 --></span>\n    <span><span><span>&lt;</span>properties</span> <span>resource</span><span><span>=</span><span>\"</span>application.properties<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>properties</span><span>></span></span>\n\n    <span>&lt;!-- 指定Mybatis使用log4j --></span>\n    <span><span><span>&lt;</span>settings</span><span>></span></span>\n        <span><span><span>&lt;</span>setting</span> <span>name</span><span><span>=</span><span>\"</span>logImpl<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>LOG4J<span>\"</span></span><span>/></span></span>\n    <span><span><span>&lt;/</span>settings</span><span>></span></span>\n\n    <span><span><span>&lt;</span>environments</span> <span>default</span><span><span>=</span><span>\"</span>development<span>\"</span></span><span>></span></span>\n        <span><span><span>&lt;</span>environment</span> <span>id</span><span><span>=</span><span>\"</span>development<span>\"</span></span><span>></span></span>\n            <span><span><span>&lt;</span>transactionManager</span> <span>type</span><span><span>=</span><span>\"</span>JDBC<span>\"</span></span><span>/></span></span>\n            <span><span><span>&lt;</span>dataSource</span> <span>type</span><span><span>=</span><span>\"</span>POOLED<span>\"</span></span><span>></span></span>\n                <span>&lt;!-- 上面指定了数据库配置文件， 配置文件里面也是对应的这四个属性 --></span>\n                <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>driver<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>${datasource.driver-class-name}<span>\"</span></span><span>/></span></span>\n                <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>url<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>${datasource.url}<span>\"</span></span><span>/></span></span>\n                <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>username<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>${datasource.username}<span>\"</span></span><span>/></span></span>\n                <span><span><span>&lt;</span>property</span> <span>name</span><span><span>=</span><span>\"</span>password<span>\"</span></span> <span>value</span><span><span>=</span><span>\"</span>${datasource.password}<span>\"</span></span><span>/></span></span>\n\n            <span><span><span>&lt;/</span>dataSource</span><span>></span></span>\n        <span><span><span>&lt;/</span>environment</span><span>></span></span>\n    <span><span><span>&lt;/</span>environments</span><span>></span></span>\n\n    <span>&lt;!-- 映射文件，mybatis精髓， 后面才会细讲 --></span>\n    <span><span><span>&lt;</span>mappers</span><span>></span></span>\n        <span><span><span>&lt;</span>mapper</span> <span>resource</span><span><span>=</span><span>\"</span>mapper/TUserMapper.xml<span>\"</span></span><span>/></span></span>\n    <span><span><span>&lt;/</span>mappers</span><span>></span></span>\n\n<span><span><span>&lt;/</span>configuration</span><span>></span></span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><h2 id=\"二、知识点讲解\"> 二、知识点讲解</h2>\n<h2 id=\"_2-1-xml约束文件dtd\"> 2.1 xml约束文件dtd</h2>\n<p>为什么要学习dtd约束文件呢? 当你学会dtd约束文件后,你就知道这个标签有那些属性，知道标签及子标签信息。\n当有一天你要写开源框架的时候,你也可以来定义你自己的配置文件规则。这部分知识了解就行。不需要死记硬背。\n因为记住也基本没啥用,只要做到看到了认识，需要用了知道去哪里抄代码学习就够了。</p>\n<h3 id=\"_2-1-1-元素-属性-属性值\"> 2.1.1 元素 &amp; 属性 &amp; 属性值</h3>\n<p><a href=\"https://www.w3school.com.cn/dtd/index.asp\" target=\"_blank\" rel=\"noopener noreferrer\">dtd文件</a></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">域</th>\n<th style=\"text-align:left\">示例</th>\n<th style=\"text-align:left\">语法</th>\n<th style=\"text-align:left\">例子</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">元素</td>\n<td style=\"text-align:left\">声明根元素标签</td>\n<td style=\"text-align:left\"><code>&lt;!ELEMENT 元素名称 (元素内容)&gt;</code></td>\n<td style=\"text-align:left\"><code>&lt;!ELEMENT students(student)&gt;</code>,元素students有一个student</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">元素</td>\n<td style=\"text-align:left\">空元素</td>\n<td style=\"text-align:left\"><code>&lt;!ELEMENT 元素名称 EMPTY&gt;</code></td>\n<td style=\"text-align:left\"><code>&lt;br /&gt;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">元素</td>\n<td style=\"text-align:left\">元素只出现一次</td>\n<td style=\"text-align:left\"><code>&lt;!ELEMENT 元素名称 (子元素名称)&gt;</code></td>\n<td style=\"text-align:left\"><code>&lt;!ELEMENT students(student)&gt;</code>,元素students至少有一个student</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">元素</td>\n<td style=\"text-align:left\">元素最少出现一次</td>\n<td style=\"text-align:left\"><code>&lt;!ELEMENT 元素名称 (子元素名称+)&gt;</code></td>\n<td style=\"text-align:left\"><code>&lt;!ELEMENT students(student+)&gt;</code>,元素students最少有一个student</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">元素</td>\n<td style=\"text-align:left\">声明出现零次或多次的元素</td>\n<td style=\"text-align:left\"><code>&lt;!ELEMENT 元素名称 (子元素名称*)&gt;</code></td>\n<td style=\"text-align:left\"><code>&lt;!ELEMENT students(student*)&gt;</code>,元素students可以有多个student,也可以一个没有</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">元素</td>\n<td style=\"text-align:left\">声明“非.../既...”类型的内容</td>\n<td style=\"text-align:left\"><code>&lt;!ELEMENT note (to,from,header,(message|body))&gt;</code></td>\n<td style=\"text-align:left\"><code>&lt;!ELEMENT student(name,age,(boy|girl))&gt;</code>,元素student有一个name和age标签,有一个boy或者girl标签</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">元素</td>\n<td style=\"text-align:left\">声明混合型的内容</td>\n<td style=\"text-align:left\"><code>&lt;!ELEMENT note (#PCDATA|to|from|header|message)*&gt;</code></td>\n<td style=\"text-align:left\"><code>&lt;!ELEMENT note (#PCDATA|to|from|header|message)*&gt;</code>&quot;note&quot; 元素可包含出现零次或多次的 PCDATA、&quot;to&quot;、&quot;from&quot;、&quot;header&quot; 或者 &quot;message&quot;</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">属性</td>\n<td style=\"text-align:left\">属性声明</td>\n<td style=\"text-align:left\"><code>&lt;!ATTLIST 元素名称 属性名称 属性类型 默认值&gt;</code></td>\n<td style=\"text-align:left\"><code>&lt;!ATTLIST payment type CDATA &quot;check&quot;&gt;</code>,payment有一个属性type,类型为字符类型,默认值check</td>\n</tr>\n</tbody>\n</table>\n<p><code>&lt;!ATTLIST 元素名称 属性名称 属性类型 默认值&gt;</code></p>\n<p><strong>值类型</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">CDATA</td>\n<td style=\"text-align:left\">值为字符数据 (character data)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">(en1</td>\n<td style=\"text-align:left\">en2</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ID</td>\n<td style=\"text-align:left\">值为唯一的 id</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">IDREF</td>\n<td style=\"text-align:left\">值为另外一个元素的 id</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">IDREFS</td>\n<td style=\"text-align:left\">值为其他 id 的列表</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">NMTOKEN</td>\n<td style=\"text-align:left\">值为合法的 XML 名称</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">NMTOKENS</td>\n<td style=\"text-align:left\">值是一个实体</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ENTITIES</td>\n<td style=\"text-align:left\">值是一个实体列表</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">NOTATION</td>\n<td style=\"text-align:left\">此值是符号的名称</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">xml:</td>\n<td style=\"text-align:left\">值是一个预定义的 XML 值</td>\n</tr>\n</tbody>\n</table>\n<p><strong>默认值参数可使用下列值</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">值</td>\n<td style=\"text-align:left\">属性的默认值</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">#REQUIRED</td>\n<td style=\"text-align:left\">属性值是必需的</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">#IMPLIED</td>\n<td style=\"text-align:left\">属性不是必需的</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">#FIXED value</td>\n<td style=\"text-align:left\">属性值是固定的</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"_2-2-configuration标签分析\"> 2.2 configuration标签分析</h2>\n<p>前面我们知道了dtd约束文件,我们就可以看下,configuration标签一共有那些子标签及属性信息了。</p>\n<p><a href=\"http://mybatis.org/dtd/mybatis-3-config.dtd\" target=\"_blank\" rel=\"noopener noreferrer\">mybatis-3-config.dtd</a></p>\n<p>通过分析dtd文件,我们知道有那些子标签及属性信息。内容比较长。但是不是很重要。这里只要知道就行。</p>\n<p>后面我们看如何使用代码来解析这些标签。</p>\n<p><img src=\"/blog/img/Mybatis配置标签.svg\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_2-3-mybatis配置解析核心逻辑\"> 2.3 Mybatis配置解析核心逻辑</h2>\n<div><p>思路决定出路</p>\n<ul>\n<li>line(6) <code>sqlSessionFactory.getConfiguration()</code></li>\n</ul>\n<p>由此来看所有的解析都是在SqlSessionFactoryBuilder进行完成的.\n具体的解析xml代码我们不研究，这里我们只要搞清楚它的调用关系,及实现的代码在哪里即可。如果这里\n看懂，其实都会得到一个结论。就是mybaits的源码是比较简单的,因为他的配置是比较集中的，无论是xml方式或者是注解方式。\n最终所有的配置信息都在 <code>Configuration</code> 类中。</p>\n</div>\n<div><div><br><br><br><br><br><div>&nbsp;</div><br><br><br><br></div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>configuration</span><span>(</span><span>)</span> <span>{</span>\n        <span>// 读取配置信息(为什么路径前不用加/,因为是相对路径。maven编译后的资源文件和class文件都是在一个包下,所以不用加/就是当前包目录)</span>\n        <span>InputStream</span> mapperInputStream <span>=</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getContextClassLoader</span><span>(</span><span>)</span><span>.</span><span>getResourceAsStream</span><span>(</span><span>\"mybatisConfig.xml\"</span><span>)</span><span>;</span>\n        <span>// 生成SqlSession工厂,SqlSession从名字上看就是,跟数据库交互的会话信息,负责将sql提交到数据库进行执行</span>\n        <span>SqlSessionFactory</span> sqlSessionFactory <span>=</span> <span>new</span> <span>SqlSessionFactoryBuilder</span><span>(</span><span>)</span><span>.</span><span>build</span><span>(</span>mapperInputStream<span>,</span> <span>\"development\"</span><span>)</span><span>;</span>\n        <span>// 获取Mybatis配置信息,由此来看所有的解析都是在SqlSessionFactoryBuilder进行完成的.</span>\n        <span>Configuration</span> configuration <span>=</span> sqlSessionFactory<span>.</span><span>getConfiguration</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"_2-3-1-new-sqlsessionfactorybuilder-build\"> 2.3.1 new SqlSessionFactoryBuilder().build</h3>\n<p>这里可以看到就是核心类就是使用 <code>XMLConfigBuilder</code> 进行解析。下面我们就主要分析 <code>XMLConfigBuilder</code></p>\n<div><pre><code><span>public</span> <span>SqlSessionFactory</span> <span>build</span><span>(</span><span>InputStream</span> inputStream<span>,</span> <span>String</span> environment<span>,</span> <span>Properties</span> properties<span>)</span> <span>{</span>\n    <span>try</span> <span>{</span>\n      <span>XMLConfigBuilder</span> parser <span>=</span> <span>new</span> <span>XMLConfigBuilder</span><span>(</span>inputStream<span>,</span> environment<span>,</span> properties<span>)</span><span>;</span>\n      <span>return</span> <span>build</span><span>(</span>parser<span>.</span><span>parse</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n      <span>throw</span> <span>ExceptionFactory</span><span>.</span><span>wrapException</span><span>(</span><span>\"Error building SqlSession.\"</span><span>,</span> e<span>)</span><span>;</span>\n    <span>}</span> <span>finally</span> <span>{</span>\n      <span>ErrorContext</span><span>.</span><span>instance</span><span>(</span><span>)</span><span>.</span><span>reset</span><span>(</span><span>)</span><span>;</span>\n      <span>try</span> <span>{</span>\n        inputStream<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n      <span>}</span> <span>catch</span> <span>(</span><span>IOException</span> e<span>)</span> <span>{</span>\n        <span>// Intentionally ignore. Prefer previous error.</span>\n      <span>}</span>\n    <span>}</span>\n  <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id=\"_2-3-2-核心配置类解析-xmlconfigbuilder\"> 2.3.2 核心配置类解析(XMLConfigBuilder)</h3>\n<div><p>重点关注</p>\n<ol>\n<li>line(8), 我们看到核心解析类是 <code>XPathParser parser = new XPathParser()</code></li>\n<li>line(17), 标签的解析都在 <code>parseConfiguration</code></li>\n<li>line(17), 思考下为什么先解析 <code>propertiesElement(root.evalNode(&quot;properties&quot;))</code></li>\n</ol>\n</div>\n<div><div><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><pre><code><span>public</span> <span>class</span> <span>XMLConfigBuilder</span> <span>extends</span> <span>BaseBuilder</span> <span>{</span>\n\n  <span>private</span> <span>boolean</span> parsed<span>;</span>\n  <span>private</span> <span>final</span> <span>XPathParser</span> parser<span>;</span>\n  <span>private</span> <span>String</span> environment<span>;</span>\n  <span>private</span> <span>final</span> <span>ReflectorFactory</span> localReflectorFactory <span>=</span> <span>new</span> <span>DefaultReflectorFactory</span><span>(</span><span>)</span><span>;</span>\n  \n  <span>public</span> <span>Configuration</span> <span>parse</span><span>(</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>parsed<span>)</span> <span>{</span>\n      <span>throw</span> <span>new</span> <span>BuilderException</span><span>(</span><span>\"Each XMLConfigBuilder can only be used once.\"</span><span>)</span><span>;</span>\n    <span>}</span>\n    parsed <span>=</span> <span>true</span><span>;</span>\n    <span>parseConfiguration</span><span>(</span>parser<span>.</span><span>evalNode</span><span>(</span><span>\"/configuration\"</span><span>)</span><span>)</span><span>;</span>\n    <span>return</span> configuration<span>;</span>\n  <span>}</span>\n  \n  <span>private</span> <span>void</span> <span>parseConfiguration</span><span>(</span><span>XNode</span> root<span>)</span> <span>{</span>\n    <span>try</span> <span>{</span>\n      <span>// issue #117 read properties first</span>\n      <span>propertiesElement</span><span>(</span>root<span>.</span><span>evalNode</span><span>(</span><span>\"properties\"</span><span>)</span><span>)</span><span>;</span>\n      <span>Properties</span> settings <span>=</span> <span>settingsAsProperties</span><span>(</span>root<span>.</span><span>evalNode</span><span>(</span><span>\"settings\"</span><span>)</span><span>)</span><span>;</span>\n      <span>loadCustomVfs</span><span>(</span>settings<span>)</span><span>;</span>\n      <span>loadCustomLogImpl</span><span>(</span>settings<span>)</span><span>;</span>\n      <span>typeAliasesElement</span><span>(</span>root<span>.</span><span>evalNode</span><span>(</span><span>\"typeAliases\"</span><span>)</span><span>)</span><span>;</span>\n      <span>pluginElement</span><span>(</span>root<span>.</span><span>evalNode</span><span>(</span><span>\"plugins\"</span><span>)</span><span>)</span><span>;</span>\n      <span>objectFactoryElement</span><span>(</span>root<span>.</span><span>evalNode</span><span>(</span><span>\"objectFactory\"</span><span>)</span><span>)</span><span>;</span>\n      <span>objectWrapperFactoryElement</span><span>(</span>root<span>.</span><span>evalNode</span><span>(</span><span>\"objectWrapperFactory\"</span><span>)</span><span>)</span><span>;</span>\n      <span>reflectorFactoryElement</span><span>(</span>root<span>.</span><span>evalNode</span><span>(</span><span>\"reflectorFactory\"</span><span>)</span><span>)</span><span>;</span>\n      <span>settingsElement</span><span>(</span>settings<span>)</span><span>;</span>\n      <span>// read it after objectFactory and objectWrapperFactory issue #631</span>\n      <span>environmentsElement</span><span>(</span>root<span>.</span><span>evalNode</span><span>(</span><span>\"environments\"</span><span>)</span><span>)</span><span>;</span>\n      <span>databaseIdProviderElement</span><span>(</span>root<span>.</span><span>evalNode</span><span>(</span><span>\"databaseIdProvider\"</span><span>)</span><span>)</span><span>;</span>\n      <span>typeHandlerElement</span><span>(</span>root<span>.</span><span>evalNode</span><span>(</span><span>\"typeHandlers\"</span><span>)</span><span>)</span><span>;</span>\n      <span>mapperElement</span><span>(</span>root<span>.</span><span>evalNode</span><span>(</span><span>\"mappers\"</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n      <span>throw</span> <span>new</span> <span>BuilderException</span><span>(</span><span>\"Error parsing SQL Mapper Configuration. Cause: \"</span> <span>+</span> e<span>,</span> e<span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>  \n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div><p>看到上面代码是不是就恍然大悟了，原来配置文件的标签都是在这里解析呀。这里的主要思路就是将xml解析成Java对象然后放到\nConfiguration中。具体任何实现呢? 感兴趣可以自己研究下。</p>\n<h3 id=\"_2-3-3-configuration属性介绍\"> 2.3.3 Configuration属性介绍</h3>\n<p>那么这些数据最终哪里会使用呢，我们专门留一片文章, 详细分析。这里先看看Configuration内部都有那些关键的配置类把。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">属性</th>\n<th style=\"text-align:left\">解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">TypeAliasRegistry</td>\n<td style=\"text-align:left\">key是一个别名,value是一个class对象</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Properties variables</td>\n<td style=\"text-align:left\">配置文件中占位符的变量配置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">InterceptorChain interceptorChain</td>\n<td style=\"text-align:left\">拦截链,用于拦截方法,实现插件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ObjectFactory objectFactory</td>\n<td style=\"text-align:left\">对象实例化统一的工厂方法,我们不用都反射来实例化了</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ObjectWrapperFactory objectWrapperFactory</td>\n<td style=\"text-align:left\">包装对象后为其提供统一的属性操作方法。我们不用通过反射来修改对象属性值了</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ReflectorFactory reflectorFactory</td>\n<td style=\"text-align:left\">反射工厂,用于生成一个反射信息对象,具有缓存的作用</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Environment environment</td>\n<td style=\"text-align:left\">环境信息包含(事务管理器和数据源)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">TypeHandlerRegistry typeHandlerRegistry</td>\n<td style=\"text-align:left\">主要处理jdbc的返回数据，转换成Java对象</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">MapperRegistry mapperRegistry</td>\n<td style=\"text-align:left\">Mapper生成的处理类,包含代理的逻辑</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_2-3-4-mapper-xml-解析\"> 2.3.4 Mapper.xml 解析</h3>\n<p><strong>XMLMapperBuilder</strong></p>\n<p>解析Mapper对应的xml配置文件,这里面包含了sql的信息。</p>\n<p>mapper的dtd约束文件更多,可以参考: https://mybatis.org/mybatis-3/zh/sqlmap-xml.html#</p>\n<div><pre><code>    <span>&lt;!-- 映射文件，mybatis精髓， 后面才会细讲 --></span>\n    <span><span><span>&lt;</span>mappers</span><span>></span></span>\n        <span><span><span>&lt;</span>mapper</span> <span>resource</span><span><span>=</span><span>\"</span>mapper/TUserMapper.xml<span>\"</span></span><span>/></span></span>\n    <span><span><span>&lt;/</span>mappers</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><img src=\"/blog/img/Mapper.svg\" alt=\"\" loading=\"lazy\"></p>\n<p>这里就要介绍一个重要的类的，<code>MapperBuilderAssistant</code> Mapper构建辅助工具类。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">属性</th>\n<th style=\"text-align:left\">解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">MapperBuilderAssistant</td>\n<td style=\"text-align:left\">Mapper构建辅助工具类(缓存配置)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CacheRefResolver</td>\n<td style=\"text-align:left\">决定如何使用缓存</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ParameterMapping</td>\n<td style=\"text-align:left\">当sql中使用到了#{}占位符时候,负责填充sql参数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ResultMapResolver</td>\n<td style=\"text-align:left\">返回值映射</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Map&lt;String, XNode&gt; sqlFragments</td>\n<td style=\"text-align:left\">sql片段</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">MappedStatement</td>\n<td style=\"text-align:left\">Mapper方法的所有信息(出参，入参，及sql信息等)</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"_2-4-mybatis可以借鉴的知识点\"> 2.4 Mybatis可以借鉴的知识点</h2>\n<h3 id=\"_2-4-1-占位符解析逻辑\"> 2.4.1 占位符解析逻辑</h3>\n<p>在第一篇的时候我们说过，从配置文件解析中我们能学会,如果解析占位符。并将占位符填充真实数据。这里我们就具体说下是如何解析。\n还记得前面让思考下为什么先解析 <code>propertiesElement(root.evalNode(&quot;properties&quot;))</code>。</p>\n<p>答案就是为了先读取变量信息，方便后面给依赖的信息，给填充值。</p>\n<p>我们直接说答案: 具体谁来做了这个事情，从职责划分上来看，这个其实还是属于xml文件解析。所以是 <code>XPathParser parser</code>\nXPathParser中填充上变量信息，这样XPathParser在解析的时候会自动将 <code>${}</code> 填充上真实的数据。</p>\n<div><pre><code>    <span>// 执行后,会解析properties标签,并且将属性赋值给XPathParser</span>\n    <span>propertiesElement</span><span>(</span>root<span>.</span><span>evalNode</span><span>(</span><span>\"properties\"</span><span>)</span><span>)</span><span>;</span>\n    parser<span>.</span><span>setVariables</span><span>(</span>defaults<span>)</span><span>;</span>\n    configuration<span>.</span><span>setVariables</span><span>(</span>defaults<span>)</span><span>;</span>\n\n    <span>// XPathParser 生成节点时候,属性信息会提前处理。</span>\n    <span>public</span> <span>XNode</span><span>(</span><span>XPathParser</span> xpathParser<span>,</span> <span>Node</span> node<span>,</span> <span>Properties</span> variables<span>)</span> <span>{</span>\n       <span>this</span><span>.</span>xpathParser <span>=</span> xpathParser<span>;</span>\n       <span>this</span><span>.</span>node <span>=</span> node<span>;</span>\n       <span>this</span><span>.</span>name <span>=</span> node<span>.</span><span>getNodeName</span><span>(</span><span>)</span><span>;</span>\n       <span>this</span><span>.</span>variables <span>=</span> variables<span>;</span>\n       <span>this</span><span>.</span>attributes <span>=</span> <span>parseAttributes</span><span>(</span>node<span>)</span><span>;</span>\n       <span>this</span><span>.</span>body <span>=</span> <span>parseBody</span><span>(</span>node<span>)</span><span>;</span>\n     <span>}</span>\n     <span>// 发现是占位符，就从变量中读取。</span>\n     <span>// ${datasource.driver-class-name} 替换成变量值里面的数据。</span>\n     <span>public</span> <span>static</span> <span>String</span> <span>parse</span><span>(</span><span>String</span> string<span>,</span> <span>Properties</span> variables<span>)</span> <span>{</span>\n       <span>VariableTokenHandler</span> handler <span>=</span> <span>new</span> <span>VariableTokenHandler</span><span>(</span>variables<span>)</span><span>;</span>\n       <span>GenericTokenParser</span> parser <span>=</span> <span>new</span> <span>GenericTokenParser</span><span>(</span><span>\"${\"</span><span>,</span> <span>\"}\"</span><span>,</span> handler<span>)</span><span>;</span>\n       <span>return</span> parser<span>.</span><span>parse</span><span>(</span>string<span>)</span><span>;</span>\n     <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h3 id=\"_2-4-2-mybatis-resources-工具\"> 2.4.2 Mybatis Resources 工具</h3>\n<p>可以从配置文件中或者网络中解析配置，生成 <code>Resources</code> 对象</p>\n<div><pre><code>      <span>String</span> resource <span>=</span> context<span>.</span><span>getStringAttribute</span><span>(</span><span>\"resource\"</span><span>)</span><span>;</span>\n      <span>if</span> <span>(</span>resource <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n        defaults<span>.</span><span>putAll</span><span>(</span><span>Resources</span><span>.</span><span>getResourceAsProperties</span><span>(</span>resource<span>)</span><span>)</span><span>;</span>\n      <span>}</span> <span>else</span> <span>if</span> <span>(</span>url <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n        defaults<span>.</span><span>putAll</span><span>(</span><span>Resources</span><span>.</span><span>getUrlAsProperties</span><span>(</span>url<span>)</span><span>)</span><span>;</span>\n      <span>}</span>\n      parser<span>.</span><span>setVariables</span><span>(</span>defaults<span>)</span><span>;</span>\n      configuration<span>.</span><span>setVariables</span><span>(</span>defaults<span>)</span><span>;</span>\n      \n      <span>// 从资源中获取流</span>\n      <span>InputStream</span> inputStream <span>=</span> <span>Resources</span><span>.</span><span>getResourceAsStream</span><span>(</span>resource<span>)</span>\n      <span>// 从url中获取流</span>\n      <span>InputStream</span> inputStream <span>=</span> <span>Resources</span><span>.</span><span>getUrlAsStream</span><span>(</span>url<span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id=\"_2-4-3-mybatis-propertyparser-占位符解析\"> 2.4.3 Mybatis PropertyParser 占位符解析</h3>\n<div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>propertyParser</span><span>(</span><span>)</span> <span>{</span>\n        <span>Properties</span> variables <span>=</span> <span>new</span> <span>Properties</span><span>(</span><span>)</span><span>;</span>\n        variables<span>.</span><span>put</span><span>(</span><span>\"datasource.driver-class-name\"</span><span>,</span> <span>\"com.mysql.cj.jdbc.Driver\"</span><span>)</span><span>;</span>\n        <span>// 变量中有就从变量中获取 参数信息: com.mysql.cj.jdbc.Driver</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>PropertyParser</span><span>.</span><span>parse</span><span>(</span><span>\"参数信息: ${datasource.driver-class-name}\"</span><span>,</span> variables<span>)</span><span>)</span><span>;</span>\n        <span>// 变量中没有就直接返回key datasource.url</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>PropertyParser</span><span>.</span><span>parse</span><span>(</span><span>\"datasource.url\"</span><span>,</span> variables<span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"_2-4-4-反射工厂-reflectorfactory\"> 2.4.4 反射工厂 ReflectorFactory</h3>\n<p>在Mybatis中使用到的反射地方蛮多的，那么都知道反射是相对比较耗时间，那么我们来看Mybatis是如何利用反射工厂来提高反射的性能的?</p>\n<p>缓存，对要使用的Class类，做反射并保存起来, 生成的对象是 <code>Reflector</code>。</p>\n<p><code>ReflectorFactory reflectorFactory = new DefaultReflectorFactory();</code></p>\n<div><pre><code><span>public</span> <span>interface</span> <span>ReflectorFactory</span> <span>{</span>\n\n  <span>boolean</span> <span>isClassCacheEnabled</span><span>(</span><span>)</span><span>;</span>\n\n  <span>void</span> <span>setClassCacheEnabled</span><span>(</span><span>boolean</span> classCacheEnabled<span>)</span><span>;</span>\n\n  <span>Reflector</span> <span>findForClass</span><span>(</span><span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> type<span>)</span><span>;</span>\n<span>}</span>\n\n<span>public</span> <span>class</span> <span>Reflector</span> <span>{</span>\n\n  <span>private</span> <span>final</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> type<span>;</span>\n  <span>private</span> <span>final</span> <span>String</span><span>[</span><span>]</span> readablePropertyNames<span>;</span>\n  <span>private</span> <span>final</span> <span>String</span><span>[</span><span>]</span> writablePropertyNames<span>;</span>\n  <span>private</span> <span>final</span> <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Invoker</span><span>></span></span> setMethods <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n  <span>private</span> <span>final</span> <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Invoker</span><span>></span></span> getMethods <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n  <span>private</span> <span>final</span> <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Class</span><span>&lt;</span><span>?</span><span>></span><span>></span></span> setTypes <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n  <span>private</span> <span>final</span> <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Class</span><span>&lt;</span><span>?</span><span>></span><span>></span></span> getTypes <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n  <span>private</span> <span>Constructor</span><span><span>&lt;</span><span>?</span><span>></span></span> defaultConstructor<span>;</span>\n\n  <span>private</span> <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> caseInsensitivePropertyMap <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p><img src=\"https://img.springlearn.cn/blog/learn_1648446512000.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>reflector</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>ReflectorFactory</span> reflectorFactory <span>=</span> <span>new</span> <span>DefaultReflectorFactory</span><span>(</span><span>)</span><span>;</span>\n        <span>Reflector</span> forClass <span>=</span> reflectorFactory<span>.</span><span>findForClass</span><span>(</span><span>TUser</span><span>.</span><span>class</span><span>)</span><span>;</span>\n        <span>TUser</span> user <span>=</span> <span>(</span><span>TUser</span><span>)</span> forClass<span>.</span><span>getDefaultConstructor</span><span>(</span><span>)</span><span>.</span><span>newInstance</span><span>(</span><span>)</span><span>;</span>\n        forClass<span>.</span><span>getSetInvoker</span><span>(</span><span>\"uid\"</span><span>)</span><span>.</span><span>invoke</span><span>(</span>user<span>,</span> <span>new</span> <span>Object</span><span>[</span><span>]</span><span>{</span><span>1</span><span>}</span><span>)</span><span>;</span>\n        forClass<span>.</span><span>getSetInvoker</span><span>(</span><span>\"name\"</span><span>)</span><span>.</span><span>invoke</span><span>(</span>user<span>,</span> <span>new</span> <span>Object</span><span>[</span><span>]</span><span>{</span><span>\"孙悟空\"</span><span>}</span><span>)</span><span>;</span>\n        forClass<span>.</span><span>getSetInvoker</span><span>(</span><span>\"tokenId\"</span><span>)</span><span>.</span><span>invoke</span><span>(</span>user<span>,</span> <span>new</span> <span>Object</span><span>[</span><span>]</span><span>{</span><span>\"tokenId\"</span><span>}</span><span>)</span><span>;</span>\n        <span>// 1</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>forClass<span>.</span><span>getGetInvoker</span><span>(</span><span>\"uid\"</span><span>)</span><span>.</span><span>invoke</span><span>(</span>user<span>,</span> <span>new</span> <span>Object</span><span>[</span><span>]</span><span>{</span><span>}</span><span>)</span><span>)</span><span>;</span>\n        <span>// 孙悟空</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>forClass<span>.</span><span>getGetInvoker</span><span>(</span><span>\"name\"</span><span>)</span><span>.</span><span>invoke</span><span>(</span>user<span>,</span> <span>new</span> <span>Object</span><span>[</span><span>]</span><span>{</span><span>}</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id=\"_2-4-5-异常上下文设计-errorcontext\"> 2.4.5 异常上下文设计 ErrorContext</h3>\n<ol>\n<li>在代码执行的过程中,将关键信息通过 <code>ErrorContext.instance().message()</code> 保存进去。利用到了线程隔离的知识。</li>\n<li><code>ErrorContext.instance()</code> 是利用 <code>ThreadLocal</code> 进行线程隔离。</li>\n<li>异常打印后,进行 <code>reset</code> 重置。</li>\n</ol>\n<div><pre><code> <span>public</span> <span>int</span> <span>update</span><span>(</span><span>String</span> statement<span>,</span> <span>Object</span> parameter<span>)</span> <span>{</span>\n    <span>try</span> <span>{</span>\n      dirty <span>=</span> <span>true</span><span>;</span>\n      <span>MappedStatement</span> ms <span>=</span> configuration<span>.</span><span>getMappedStatement</span><span>(</span>statement<span>)</span><span>;</span>\n      <span>return</span> executor<span>.</span><span>update</span><span>(</span>ms<span>,</span> <span>wrapCollection</span><span>(</span>parameter<span>)</span><span>)</span><span>;</span>\n    <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n      <span>throw</span> <span>wrapException</span><span>(</span><span>\"Error updating database.  Cause: \"</span> <span>+</span> e<span>,</span> e<span>)</span><span>;</span>\n    <span>}</span> <span>finally</span> <span>{</span>\n      <span>// 完成之后异常上下文进行重置</span>\n      <span>ErrorContext</span><span>.</span><span>instance</span><span>(</span><span>)</span><span>.</span><span>reset</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n  \n  <span>// 将异常上线文中报错的错误都打印出来。</span>\n  <span>public</span> <span>static</span> <span>RuntimeException</span> <span>wrapException</span><span>(</span><span>String</span> message<span>,</span> <span>Exception</span> e<span>)</span> <span>{</span>\n    <span>return</span> <span>new</span> <span>PersistenceException</span><span>(</span><span>ErrorContext</span><span>.</span><span>instance</span><span>(</span><span>)</span><span>.</span><span>message</span><span>(</span>message<span>)</span><span>.</span><span>cause</span><span>(</span>e<span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>,</span> e<span>)</span><span>;</span>\n  <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div>",
      "image": "https://java.springlearn.cn/blog/img/Mybatis配置标签.svg",
      "date_published": "2022-03-28T15:13:45.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Mybatis"
      ]
    },
    {
      "title": "八阿哥的剑",
      "url": "https://java.springlearn.cn/learn/other/bug/",
      "id": "https://java.springlearn.cn/learn/other/bug/",
      "content_html": "<p><strong>作者: 八阿哥的剑</strong></p>\n<p><em>博客: https://springlearn.cn</em></p>\n<div><p>一日一句毒鸡汤</p>\n<p>问世间钱为何物，只叫人生死相许。！😄</p>\n</div>\n<h2 id=\"java原生版本监控\"> Java原生版本监控</h2>\n<div><pre><code><span>public</span> <span>class</span> <span>JavaWatchAPI</span> <span>{</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>//第一步：取得WatchService</span>\n        <span>WatchService</span> watchService <span>=</span> <span>FileSystems</span><span>.</span><span>getDefault</span><span>(</span><span>)</span><span>.</span><span>newWatchService</span><span>(</span><span>)</span><span>;</span>\n        <span>//第二步：确定要监控的路径</span>\n        <span>Path</span> path <span>=</span> <span>Paths</span><span>.</span><span>get</span><span>(</span><span>\"/Users/liuxin/Github/nobug-learn-project/nobug-learn-01/src/main/java\"</span><span>)</span><span>;</span>\n\n        <span>//第三步：为本路径绑定WatchService，并确定监控的事件</span>\n        path<span>.</span><span>register</span><span>(</span>\n                watchService<span>,</span>\n                <span>// StandardWatchEventKinds.ENTRY_CREATE—当有新文件时触发。可能是创建了一个新文件</span>\n                <span>StandardWatchEventKinds</span><span>.</span>ENTRY_CREATE<span>,</span>\n                <span>// StandardWatchEventKinds.ENTRY_DELETE—当文件被删除、移动或重命名时触发</span>\n                <span>StandardWatchEventKinds</span><span>.</span>ENTRY_DELETE<span>,</span>\n                <span>// StandardWatchEventKinds.ENTRY_MODIFY—当文件被修改时触发。</span>\n                <span>StandardWatchEventKinds</span><span>.</span>ENTRY_MODIFY<span>)</span><span>;</span>\n        <span>// StandardWatchEventKinds.OVERFLOW—触发表示丢失或丢弃的事件。</span>\n        <span>WatchKey</span> key <span>=</span> <span>null</span><span>;</span>\n        <span>while</span> <span>(</span><span>(</span>key <span>=</span> watchService<span>.</span><span>take</span><span>(</span><span>)</span><span>)</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n            <span>for</span> <span>(</span><span>WatchEvent</span><span><span>&lt;</span><span>?</span><span>></span></span> event <span>:</span> key<span>.</span><span>pollEvents</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"事件\"</span> <span>+</span> event<span>.</span><span>kind</span><span>(</span><span>)</span> <span>+</span> <span>\"发生了，文件是：\"</span> <span>+</span> event<span>.</span><span>context</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>}</span>\n            key<span>.</span><span>reset</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><h2 id=\"common-io-工具包监控\"> Common IO 工具包监控</h2>\n<div><pre><code><span>package</span> <span>cn<span>.</span>github<span>.</span>chinesszz</span><span>;</span>\n\n<span>import</span> <span>org<span>.</span>apache<span>.</span>commons<span>.</span>io<span>.</span>filefilter<span>.</span></span><span>FileFilterUtils</span><span>;</span>\n<span>import</span> <span>org<span>.</span>apache<span>.</span>commons<span>.</span>io<span>.</span>monitor<span>.</span></span><span>FileAlterationListener</span><span>;</span>\n<span>import</span> <span>org<span>.</span>apache<span>.</span>commons<span>.</span>io<span>.</span>monitor<span>.</span></span><span>FileAlterationMonitor</span><span>;</span>\n<span>import</span> <span>org<span>.</span>apache<span>.</span>commons<span>.</span>io<span>.</span>monitor<span>.</span></span><span>FileAlterationObserver</span><span>;</span>\n<span>import</span> <span>org<span>.</span>junit<span>.</span></span><span>Test</span><span>;</span>\n\n<span>import</span> <span>java<span>.</span>io<span>.</span></span><span>File</span><span>;</span>\n<span>import</span> <span>java<span>.</span>util<span>.</span>concurrent<span>.</span></span><span>TimeUnit</span><span>;</span>\n\n<span>/**\n * @author liuxin\n * 2021/11/9 8:55 下午\n */</span>\n<span>public</span> <span>class</span> <span>CommonIOAPI</span> <span>{</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>File</span> directory <span>=</span> <span>new</span> <span>File</span><span>(</span><span>\"/Users/liuxin/Github/nobug-learn-project/nobug-learn-01/src/main/java\"</span><span>)</span><span>;</span>\n        <span>// 轮询间隔 5 秒</span>\n        <span>long</span> interval <span>=</span> <span>TimeUnit</span><span>.</span>SECONDS<span>.</span><span>toMillis</span><span>(</span><span>5</span><span>)</span><span>;</span>\n        <span>// 创建一个文件观察器用于处理文件的格式</span>\n        <span>FileAlterationObserver</span> observer <span>=</span> <span>new</span> <span>FileAlterationObserver</span><span>(</span>directory<span>,</span> <span>FileFilterUtils</span><span>.</span><span>and</span><span>(</span>\n                <span>FileFilterUtils</span><span>.</span><span>fileFileFilter</span><span>(</span><span>)</span><span>,</span> <span>FileFilterUtils</span><span>.</span><span>suffixFileFilter</span><span>(</span><span>\".txt\"</span><span>)</span><span>,</span>\n                <span>FileFilterUtils</span><span>.</span><span>prefixFileFilter</span><span>(</span><span>\"lx\"</span><span>)</span><span>)</span><span>)</span><span>;</span>\n        <span>// 设置文件变化监听器</span>\n        observer<span>.</span><span>addListener</span><span>(</span><span>new</span> <span>MyFileListener</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>FileAlterationMonitor</span> monitor <span>=</span> <span>new</span> <span>FileAlterationMonitor</span><span>(</span>interval<span>,</span> observer<span>)</span><span>;</span>\n        monitor<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>1</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>watchDir</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>File</span> directory <span>=</span> <span>new</span> <span>File</span><span>(</span><span>\"/Users/liuxin/Github/nobug-learn-project/nobug-learn-01/src/main/java\"</span><span>)</span><span>;</span>\n        <span>FileAlterationObserver</span> fileAlterationObserver <span>=</span> <span>new</span> <span>FileAlterationObserver</span><span>(</span>directory<span>,</span> <span>FileFilterUtils</span><span>.</span><span>and</span><span>(</span>\n                <span>FileFilterUtils</span><span>.</span><span>directoryFileFilter</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>\n        <span>long</span> interval <span>=</span> <span>TimeUnit</span><span>.</span>SECONDS<span>.</span><span>toMillis</span><span>(</span><span>5</span><span>)</span><span>;</span>\n        <span>// 设置文件变化监听器</span>\n        fileAlterationObserver<span>.</span><span>addListener</span><span>(</span><span>new</span> <span>MyFileListener</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>FileAlterationMonitor</span> monitor <span>=</span> <span>new</span> <span>FileAlterationMonitor</span><span>(</span>interval<span>,</span> fileAlterationObserver<span>)</span><span>;</span>\n        monitor<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        <span>while</span> <span>(</span><span>true</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>static</span> <span>final</span> <span>class</span> <span>MyFileListener</span> <span>implements</span> <span>FileAlterationListener</span> <span>{</span>\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>onStart</span><span>(</span><span>FileAlterationObserver</span> fileAlterationObserver<span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"monitor start scan files..\"</span><span>)</span><span>;</span>\n        <span>}</span>\n\n\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>onDirectoryCreate</span><span>(</span><span>File</span> file<span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>file<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\" director created.\"</span><span>)</span><span>;</span>\n        <span>}</span>\n\n\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>onDirectoryChange</span><span>(</span><span>File</span> file<span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>file<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\" director changed.\"</span><span>)</span><span>;</span>\n        <span>}</span>\n\n\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>onDirectoryDelete</span><span>(</span><span>File</span> file<span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>file<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\" director deleted.\"</span><span>)</span><span>;</span>\n        <span>}</span>\n\n\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>onFileCreate</span><span>(</span><span>File</span> file<span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>file<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\" created.\"</span><span>)</span><span>;</span>\n        <span>}</span>\n\n\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>onFileChange</span><span>(</span><span>File</span> file<span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>file<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\" changed.\"</span><span>)</span><span>;</span>\n        <span>}</span>\n\n\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>onFileDelete</span><span>(</span><span>File</span> file<span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>file<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\" deleted.\"</span><span>)</span><span>;</span>\n        <span>}</span>\n\n\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>onStop</span><span>(</span><span>FileAlterationObserver</span> fileAlterationObserver<span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"monitor stop scanning..\"</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br></div></div>",
      "date_published": "2021-12-21T05:46:37.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Zookeeper实践",
      "url": "https://java.springlearn.cn/learn/other/zookeeper/",
      "id": "https://java.springlearn.cn/learn/other/zookeeper/",
      "content_html": "<h2 id=\"一、zookeeper介绍\"> 一、Zookeeper介绍</h2>\n<h2 id=\"_1-1-配置管理\"> 1.1 配置管理</h2>\n<p>在我们的应用中除了代码外，还有一些就是各种配置。比如数据库连接等。一般我们都是使用配置文件的方式，在代码中引入这些配置文件。但是当我们只有一种配置，只有一台服务器，并且不经常修改的时候，使用配置文件是一个很好的做法，但是如果我们配置非常多，有很多服务器都需要这个配置，而且还可能是动态的话使用配置文件就不是个好主意了。这个时候往往需要寻找一种集中管理配置的方法，我们在这个集中的地方修改了配置，所有对这个配置感兴趣的都可以获得变更。比如我们可以把配置放在数据库里，然后所有需要配置的服务都去这个数据库读取配置。</p>\n<h2 id=\"_1-2-名字服务\"> 1.2 名字服务</h2>\n<p>名字服务这个就很好理解了。比如为了通过网络访问一个系统，我们得知道对方的IP地址，但是IP地址对人非常不友好，这个时候我们就需要使用域名来访问。但是计算机是不能是别域名的。怎么办呢？如果我们每台机器里都备有一份域名到IP地址的映射，这个倒是能解决一部分问题，但是如果域名对应的IP发生变化了又该怎么办呢？于是我们有了DNS这个东西。我们只需要访问一个大家熟知的(known)的点，它就会告诉你这个域名对应的IP是什么。在我们的应用中也会存在很多这类问题，特别是在我们的服务特别多的时候，如果我们在本地保存服务的地址的时候将非常不方便，但是如果我们只需要访问一个大家都熟知的访问点，这里提供统一的入口，那么维护起来将方便得多了。\n分布式锁</p>\n<h2 id=\"_1-3-集群管理\"> 1.3 集群管理</h2>\n<p>在分布式的集群中，经常会由于各种原因，比如硬件故障，软件故障，网络问题，有些节点会进进出出。有新的节点加入进来，也有老的节点退出集群。这个时候，集群中其他机器需要感知到这种变化，然后根据这种变化做出对应的决策。比如我们是一个分布式存储系统，有一个中央控制节点负责存储的分配，当有新的存储进来的时候我们要根据现在集群目前的状态来分配存储节点。这个时候我们就需要动态感知到集群目前的状态。还有，比如一个分布式的SOA架构中，服务是一个集群提供的，当消费者访问某个服务时，就需要采用某种机制发现现在有哪些节点可以提供该服务(这也称之为服务发现，比如Alibaba开源的SOA框架Dubbo就采用了Zookeeper作为服务发现的底层机制)。还有开源的Kafka队列就采用了Zookeeper作为Cosnumer的上下线管理。</p>\n<h2 id=\"二、本地安装运行\"> 二、本地安装运行</h2>\n<h2 id=\"_2-1-mac环境部署\"> 2.1 Mac环境部署</h2>\n<div><pre><code>// 查询\nbrew search zookeeper\n// 安装\nbrew install zookeeper\n// 运行\nbrew services start zookeeper\n// 运行成功了\n==&gt; Successfully started `zookeeper` (label: homebrew.mxcl.zookeeper)\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id=\"_2-2-windows环境部署\"> 2.2 Windows环境部署</h2>\n<ol>\n<li><a href=\"http://mirror.bit.edu.cn/apache/zookeeper/zookeeper-3.4.12/\" target=\"_blank\" rel=\"noopener noreferrer\">下载安装包</a></li>\n<li>运行 <code>启动zkServer.sh | zkServer.cmd</code></li>\n</ol>\n<h2 id=\"三、项目实践\"> 三、项目实践</h2>\n<h2 id=\"_3-1-引入依赖\"> 3.1 引入依赖</h2>\n<div><pre><code>        <span>&lt;!-- 对zookeeper的底层api的一些封装 --></span>\n        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>org.apache.curator<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>curator-framework<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n            <span><span><span>&lt;</span>version</span><span>></span></span>2.12.0<span><span><span>&lt;/</span>version</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n\n        <span>&lt;!-- 提供一些客户端的操作，例如重试策略等 --></span>\n        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>org.apache.curator<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>curator-client<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n            <span><span><span>&lt;</span>version</span><span>></span></span>2.13.0<span><span><span>&lt;/</span>version</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n\n\n        <span>&lt;!-- 封装了一些高级特性，如：Cache事件监听、选举、分布式锁、分布式计数器、分布式Barrier等 --></span>\n        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>org.apache.curator<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>curator-recipes<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n            <span><span><span>&lt;</span>version</span><span>></span></span>2.12.0<span><span><span>&lt;/</span>version</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h2 id=\"_3-2-curator-api\"> 3.2 Curator API</h2>\n<div><p>相关信息</p>\n<p>Curator是Netflix公司开源的一套zookeeper客户端框架，解决了很多Zookeeper客户端非常底层的细节开发工作，包括连接重连、反复注册Watcher和NodeExistsException异常等等。Patrixck Hunt（Zookeeper）以一句“Guava is to Java that Curator to Zookeeper”给Curator予高度评价。</p>\n</div>\n<p><mark>Curator包含了几个包：</mark></p>\n<ul>\n<li>curator-framework：对zookeeper的底层api的一些封装</li>\n<li>curator-client：提供一些客户端的操作，例如重试策略等</li>\n<li>curator-recipes：封装了一些高级特性，如：Cache事件监听、选举、分布式锁、分布式计数器、分布式Barrier等</li>\n</ul>\n<h3 id=\"_3-2-1-创建会话\"> 3.2.1 创建会话</h3>\n<p>1.使用静态工程方法创建客户端</p>\n<div><pre><code>RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);\nCuratorFramework client =\nCuratorFrameworkFactory.newClient(\n                        connectionInfo,\n                        5000,\n                        3000,\n                        retryPolicy);\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><strong>newClient静态工厂方法包含四个主要参数：</strong></p>\n<table>\n<thead>\n<tr>\n<th>参数名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>connectionString</td>\n<td>服务器列表，格式host1:port1,host2:port2,...</td>\n</tr>\n<tr>\n<td>retryPolicy</td>\n<td>重试策略,内建有四种重试策略,也可以自行实现RetryPolicy接口</td>\n</tr>\n<tr>\n<td>sessionTimeoutMs</td>\n<td>会话超时时间，单位毫秒，默认60000ms</td>\n</tr>\n<tr>\n<td>connectionTimeoutMs</td>\n<td>连接创建超时时间，单位毫秒，默认60000ms</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<p>2.使用Fluent风格的Api创建会话\n核心参数变为流式设置，一个列子如下</p>\n<div><pre><code>RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);\n        CuratorFramework client =\n        CuratorFrameworkFactory.builder()\n                .connectString(connectionInfo)\n                .sessionTimeoutMs(5000)\n                .connectionTimeoutMs(5000)\n                .retryPolicy(retryPolicy)\n                .build();。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><hr>\n<p>3.创建包含隔离命名空间的会话\n为了实现不同的Zookeeper业务之间的隔离，需要为每个业务分配一个独立的命名空间（NameSpace），即指定一个Zookeeper的根路径（官方术语：为Zookeeper添加“Chroot”特性）。例如（下面的例子）当客户端指定了独立命名空间为“/base”，那么该客户端对Zookeeper上的数据节点的操作都是基于该目录进行的。通过设置Chroot可以将客户端应用与Zookeeper服务端的一课子树相对应，在多个应用共用一个Zookeeper集群的场景下，这对于实现不同应用之间的相互隔离十分有意义。</p>\n<div><pre><code>RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);\n        CuratorFramework client =\n        CuratorFrameworkFactory.builder()\n                .connectString(connectionInfo)\n                .sessionTimeoutMs(5000)\n                .connectionTimeoutMs(5000)\n                .retryPolicy(retryPolicy)\n                .namespace(&quot;base&quot;)\n                .build();\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><ol start=\"4\">\n<li>启动客户端\n当创建会话成功，得到client的实例然后可以直接调用其start( )方法：</li>\n</ol>\n<p><code>client.start();</code></p>\n<h3 id=\"_3-2-2-添加监听器\"> 3.2.2 添加监听器</h3>\n<div><pre><code><span>/**\n   * 只能监听某一个节点的变化\n   *\n   * @throws Exception\n   */</span>\n  <span>@Test</span>\n  <span>public</span> <span>void</span> <span>nodeCacheListenerTest</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n    <span>ExponentialBackoffRetry</span> exponentialBackoffRetry <span>=</span> <span>new</span> <span>ExponentialBackoffRetry</span><span>(</span><span>1000</span><span>,</span> <span>3</span><span>)</span><span>;</span>\n    <span>CuratorFramework</span> client <span>=</span> <span>CuratorFrameworkFactory</span><span>.</span><span>newClient</span><span>(</span>connect_info<span>,</span>\n      exponentialBackoffRetry<span>)</span><span>;</span>\n    client<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n    client<span>.</span><span>usingNamespace</span><span>(</span><span>\"dubboz\"</span><span>)</span><span>;</span>\n\n    <span>final</span> <span>NodeCache</span> cache <span>=</span> <span>new</span> <span>NodeCache</span><span>(</span>client<span>,</span> ROOT_PATH<span>)</span><span>;</span>\n\n    <span>NodeCacheListener</span> listener <span>=</span> <span>new</span> <span>NodeCacheListener</span><span>(</span><span>)</span> <span>{</span>\n      <span>public</span> <span>void</span> <span>nodeChanged</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>ChildData</span> data <span>=</span> cache<span>.</span><span>getCurrentData</span><span>(</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span><span>null</span> <span>!=</span> data<span>)</span> <span>{</span>\n          <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"节点数据：\"</span> <span>+</span> <span>new</span> <span>String</span><span>(</span>cache<span>.</span><span>getCurrentData</span><span>(</span><span>)</span><span>.</span><span>getData</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span> <span>else</span> <span>{</span>\n          <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"节点被删除!\"</span><span>)</span><span>;</span>\n        <span>}</span>\n      <span>}</span>\n    <span>}</span><span>;</span>\n    cache<span>.</span><span>getListenable</span><span>(</span><span>)</span><span>.</span><span>addListener</span><span>(</span>listener<span>)</span><span>;</span>\n    cache<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n\n    client<span>.</span><span>create</span><span>(</span><span>)</span><span>.</span><span>creatingParentsIfNeeded</span><span>(</span><span>)</span><span>.</span><span>forPath</span><span>(</span>ROOT_PATH<span>)</span><span>;</span>\n    client<span>.</span><span>setData</span><span>(</span><span>)</span><span>.</span><span>forPath</span><span>(</span>ROOT_PATH<span>,</span> <span>\"01\"</span><span>.</span><span>getBytes</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>100</span><span>)</span><span>;</span>\n    client<span>.</span><span>setData</span><span>(</span><span>)</span><span>.</span><span>forPath</span><span>(</span>ROOT_PATH<span>,</span> <span>\"02\"</span><span>.</span><span>getBytes</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>100</span><span>)</span><span>;</span>\n    client<span>.</span><span>delete</span><span>(</span><span>)</span><span>.</span><span>deletingChildrenIfNeeded</span><span>(</span><span>)</span><span>.</span><span>forPath</span><span>(</span>ROOT_PATH<span>)</span><span>;</span>\n    <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>1000</span> <span>*</span> <span>2</span><span>)</span><span>;</span>\n    cache<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n    client<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"OK!\"</span><span>)</span><span>;</span>\n  <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div>",
      "date_published": "2022-05-24T13:52:50.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "程序猿到底有没有必要买一台阿里云服务器",
      "url": "https://java.springlearn.cn/learn/other/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E5%88%B0%E5%BA%95%E6%9C%89%E6%B2%A1%E6%9C%89%E5%BF%85%E8%A6%81%E4%B9%B0%E4%B8%80%E5%8F%B0%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/",
      "id": "https://java.springlearn.cn/learn/other/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E5%88%B0%E5%BA%95%E6%9C%89%E6%B2%A1%E6%9C%89%E5%BF%85%E8%A6%81%E4%B9%B0%E4%B8%80%E5%8F%B0%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/",
      "content_html": "<p><img src=\"https://img-blog.csdnimg.cn/2019122518192512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" loading=\"lazy\"></p>\n<p><strong>做为一名程序猿多多少少每天都在跟服务器打交道,尤其是后端的小伙伴,那么你是否也有这样的想法呢 ?</strong></p>\n<h3 id=\"一、个人服务器究竟能做什么\"> 一、个人服务器究竟能做什么?</h3>\n<h4 id=\"_1-搭建个人博客\"> 1. 搭建个人博客</h4>\n<p>软件开发这个行业,知识技术日新月异,作为一名合格专注的程序猿每天都会浏览各种各样的技术网站,在这里我们排出一些大的技术博客网站,我们也经常会看到很多个人的技术博主。一般拥有个人博客网站的都是在某一个领域有很深认识的大牛,会经常把自己的学到的知识积累下来,分享给大家。那么如果要搭建自己的个人博客就必须要有一台个人服务器啦。 但是排出一种情况就是有些个人博主会把自己的博客部署在 <code>gitlab</code> 或者<code>github</code>、<code>coding</code> 的静态Pages上,然后通过域名<code>CNAME</code> 的方式访问, 像小编我自己之前也是用后面这种情况,可以免费部署自己的个人博客。但是唯一缺点就是访问太慢了。</p>\n<p><strong>下面就是小编我自己的个人网站,主要做Java后端的知识分享(非营利性哦)</strong>\n<a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://img-blog.csdnimg.cn/20191225183752474.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" loading=\"lazy\"></a></p>\n<h4 id=\"_2-搭建个人知识库\"> 2. 搭建个人知识库</h4>\n<p>做为技术人,我们每天都要处理各种各样的数据,有公司数据、有个人数据、或者碎片的知识点、API信息、备忘录信息等。相信每个开发者都会有这个需求吧，一般我们可以使用 <code>有道云笔记</code> 、 <code>印象笔记</code>。 小编使用的是前者，但是突然有一段时间不能用了,原因当然不是有道云挂了, 而是很多公司为了信息安全禁止员工登陆这种网站,\n比如云盘类网站, 当然就包括上面的。这个时候当我们访问上面的网站时候就会被公司后台记录，或者是直接就访问不到。这个时候我们就要考虑搭建一个人知识库了。小编现在用的是 <code>showdoc</code>。 非常简单。</p>\n<p>登陆服务器安装 <code>docker</code> 运行下面命令即可</p>\n<div><pre><code><span>docker</span> pull xd2idwf5.mirror.aliyuncs.com/star7th/showdoc<span>;</span>\n<span>docker</span> tag xd2idwf5.mirror.aliyuncs.com/star7th/showdoc:latest star7th/showdoc:latest<span>;</span>\n<span>mkdir</span> showdoc_data<span>;</span>\n<span>mkdir</span> showdoc_data/html<span>;</span>\n<span>chmod</span>  -R <span>777</span> showdoc_data<span>;</span>\n<span>docker</span> run -d --name showdoc -p <span>6666</span>:80 -v /root/showdoc_data/html:/var/www/html/      star7th/showdoc\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><strong>下面是小编的个人知识库</strong></p>\n<p><a href=\"http://doc.springlearn.cn\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://img-blog.csdnimg.cn/20191225184550675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" loading=\"lazy\"></a></p>\n<h4 id=\"_3-搭建个人网盘\"> 3. 搭建个人网盘</h4>\n<p>网盘的用处只有一个就是存储文件,市面上的产品之前有很多但是近两年很多都倒闭了,不过现在还有 <code>百度网盘</code>依然坚挺。但是(太...慢了)。 那么我们就自己来搭建一个吧。小编使用的网盘是 <code>Seafile</code></p>\n<p>Seafile是一个开源、专业、可靠的云存储平台；解决文件集中存储、共享和跨平台访问等问题，除了一般网盘所提供的云存储以及共享功能外，Seafile还提供消息通信。 具体安装也不难。\n<img src=\"https://img-blog.csdnimg.cn/20191225185205331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" loading=\"lazy\"></p>\n<h4 id=\"_4-部署个人应用\"> 4. 部署个人应用</h4>\n<p>这个需求应该是购买服务器的最终目的，就是部署自己的服务, 小编就是部署的自己的博客应用。 使用nginx作为方向代理。不得不说使用自己服务器就是比免费的速度快。</p>\n<p>http://blog.springlearn.cn/ 响应在5毫秒内\nhttp://www.hanframework.com/ 免费的响应在400毫秒内</p>\n<p>虽然都不到1秒,但是具体使用时候用户体验差距还是很大的。可以自己体验下。\n<img src=\"https://img-blog.csdnimg.cn/20191225185514458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" loading=\"lazy\"></p>\n<h3 id=\"二、购买了服务器你还需要哪些知识储备\"> 二、购买了服务器你还需要哪些知识储备</h3>\n<h4 id=\"_1-服务器ssh登录\"> 1. 服务器ssh登录</h4>\n<p>当我们购买了服务器我们有两种登陆方式</p>\n<ol>\n<li>用户名和密码登陆</li>\n<li>秘钥登陆\n这两种登陆都离不开 <code>ssh</code> 命令</li>\n</ol>\n<p><strong>第一种</strong>\n<code>ssh root@127.32.32.122</code> 然后输入用户密码</p>\n<p><strong>第二种</strong>\n<code>ssh aliyun</code>  直接就访问</p>\n<p>对于如何配置小编就不说了,百度搜索就很多答案,如果不想搜索或者有问题，可以给小编私信。小编给你解决。</p>\n<h4 id=\"_2-服务器器安全组配置\"> 2. 服务器器安全组配置</h4>\n<p>安全组这个概念,如果没有购买过服务器的应该不是很清楚,其实就是防火墙的意思。当我们购买了阿里/百度/腾讯/华为/七牛之类的服务器，在后台都有一个安全组管理的。一个入站,一个出站端端口配置。 这个要注意,如果不配置的话，你是访问不到你的端口的\n<img src=\"https://img-blog.csdnimg.cn/20191225190257549.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" loading=\"lazy\"></p>\n<h4 id=\"_3-域名配置\"> 3. 域名配置</h4>\n<p>我们可以选择一个自己心仪的域名, 一般域名很便宜一年<code>三十</code> 左右。但是别钻牛角尖, 天价的域名也很多。</p>\n<p>域名配置主要是域名转发之类的。</p>\n<ol>\n<li>第一种情况: 如果要将域名配置到一台服务器上使用，那么这种情况域名必须要备案，备案一般服务商会帮我们备案，我们只要提供认证信息,一般一周内可以下来。</li>\n<li>第二种情况: 如果我们没有服务器我们也可以购买一个域名,我们在配置域名转发的时候,可以不指定服务器,而是转发到一个CNAEM别名上也可以使用。</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/20191225191224799.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" loading=\"lazy\"></p>\n<h4 id=\"_4-部署应用\"> 4. 部署应用</h4>\n<p>不会做饭的老司机不是好的厨师,同样只会写代码,不会部署的程序猿不是合格的程序猿。😸。</p>\n<p>部署应用我们可以使用 <code>docker</code> + <code>nginx或apache</code> 。 具体 <code>nginx</code> 和 <code>docker</code> 的使用网上很多就不细说了，如果你要购买服务器这些都是你要储备的知识点。</p>\n<h3 id=\"三、购买服务器要注意什么\"> 三、购买服务器要注意什么</h3>\n<h4 id=\"_1-价格\"> 1. 价格</h4>\n<p>作为软件开发者,能免费的东西绝对不花钱, 上面的各种场景,其实我们都可以使用免费的来替代。 除了部署应用。那么我们就研究下价格。 一般运营商的套路都是年底大甩卖。所以年中和年头不是购买服务器的时间, 一般都在 <code>双十一</code> 、<code>双十二</code>期间会大降价。\n关于价格对比的我们就以<code>2核4G</code>的服务器作为对比, 因为这个配置就能满足我们的需求。 那么我们就看看运营商的价格，因为是双十二期间,所以阿里云最近在搞活动,所以阿里云目前我看是最低的，新用户3年只要799。【如果不是新用户可以用其他人账号买,小编就是用自己家人账号买的】</p>\n<ol>\n<li>七牛云2核4g三年 ￥1767.61</li>\n<li>腾讯云2核4g三年 ￥3897</li>\n<li>华为云2核4g三年 ￥6,440.70</li>\n<li>阿里云2核4g三年 ￥1807.2(常规价) ￥799(活动价格)</li>\n</ol>\n<p><a href=\"https://www.aliyun.com/minisite/goods?userCode=oab21mxz\" target=\"_blank\" rel=\"noopener noreferrer\">活动优惠券领取</a>\n<img src=\"https://img-blog.csdnimg.cn/20191225192246879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" loading=\"lazy\">\n<img src=\"https://img-blog.csdnimg.cn/20191225192305678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" loading=\"lazy\">\n<img src=\"https://img-blog.csdnimg.cn/20191225192332835.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" loading=\"lazy\">\n<img src=\"https://img-blog.csdnimg.cn/2019122519235837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" loading=\"lazy\"></p>\n<h4 id=\"_2-售后-本人真实体验不是喷子-不是职业黑\"> 2. 售后(本人真实体验不是喷子,不是职业黑)</h4>\n<p>服务器一般什么情况下会有售后呢?\n当出现服务器 <code>cpu</code> 飙高, 流量异常被恶意攻击的时候,就考验售后了。我们就看服务商的工单回复速度。因为小编就用过阿里云和七牛云所以就对比下两家的工单体验吧。</p>\n<ol>\n<li>阿里云无论回复速度还是质量都满意。</li>\n<li>七牛云回复慢就算了，一个问题给我转几个人,每次让我重新再问一遍(没地方吐槽,就在这里吧)</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/20191225192754639.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" loading=\"lazy\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20191225192935155.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" loading=\"lazy\"></p>\n<p><strong>时间到,下班了... 喜欢小编的可以关注一下,持续为你分享干货知识</strong></p>\n",
      "image": "https://img-blog.csdnimg.cn/2019122518192512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lc3NhZ2VfbHg=,size_16,color_FFFFFF,t_70",
      "date_published": "2021-12-21T05:46:37.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "一致性hash问题",
      "url": "https://java.springlearn.cn/learn/other/%E4%B8%80%E8%87%B4%E6%80%A7hash%E9%97%AE%E9%A2%98/",
      "id": "https://java.springlearn.cn/learn/other/%E4%B8%80%E8%87%B4%E6%80%A7hash%E9%97%AE%E9%A2%98/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/learn_aecfc8e243edb199c726728413b1522c.gif\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"一、介绍\"> 一、介绍</h2>\n<p>一致性哈希主要解决的问题,是互联网中的热点问题,及当cache环境改变,能动态感知,避免继续向已经坏掉的空间,插入新值.</p>\n<h2 id=\"二、不一致会有什么问题\"> 二、不一致会有什么问题?</h2>\n<h2 id=\"_2-1-缓存的例子\"> 2.1 缓存的例子</h2>\n<p>有 N 个 cache 服务器（后面简称 cache ），那么如何将一个对象 object 映射到 N 个 cache 上呢，你很可能会采用类似下面的通用方法计算 object 的 hash</p>\n<p>求余算法: hash(Object) % N</p>\n<p>有多个cache: cache[0] cache[1] cache[2] cache[3], 然后要</p>\n<ul>\n<li>\n<p>put 4%4 insert 到cache[0]=A</p>\n</li>\n<li>\n<p>put 1%4 insert 到cache[1]=B</p>\n</li>\n<li>\n<p>put 2%4 insert 到cache[2]=C</p>\n</li>\n<li>\n<p>put 3%4 insert 到cache[3]=D</p>\n</li>\n</ul>\n<p>假如cache[0] A节点突然挂了,此时获取cache[0]会有问题,put 5%3(本来4个节点-1一个节点) insert cache[2] ,之前是插入C,但是之后cache[2]=D,此时,一台错误会对全局产生影响.(因为cache的位置都发生了变化),这样就不能维护hash算法的单调性,可能之前已经插入了,但是后面就要覆盖.</p>\n<p><del>cache[0]=A</del></p>\n<ul>\n<li>cache[0]=B</li>\n<li>cache[1]=C</li>\n<li>cache[2]=D</li>\n</ul>\n<h2 id=\"_2-3-数据迁移例子\"> 2.3 数据迁移例子</h2>\n<p>假如有10条数据，3个节点，如果按照取模的方式。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1652926998000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>总结: 数据在增加了一个节点后，3,4,5,6,7,8,9都需要做搬迁，成本太高了</p>\n<p>那么采用一致性hash后怎么样呢?</p>\n<h3 id=\"_2-3-1-一致性hash如何处理\"> 2.3.1 一致性hash如何处理?</h3>\n<p>对 a b c 分别做哈希映射</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1652927183000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>当大于228都存203节点,于是就维护了一个圆形,即所有数据都能找到其节点了</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1652927207000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>当新加入节点d,可以算出d的hash</p>\n<p><mark>node d: 216</mark></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1652927238000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>对数据进行迁移(其实只影响209~216之间的数,即达到了我们的目的)</p>\n<h2 id=\"三、总结\"> 三、总结</h2>\n<p><code>一致性hash的算法，就是不去确定唯一的下标，而是将节点先形成一个hash环,每次获取当前hash最近的节点。这样就算挂了一个节点，影响也是最小的</code>。</p>\n",
      "image": "https://img.springlearn.cn/learn_aecfc8e243edb199c726728413b1522c.gif",
      "date_published": "2022-05-22T07:02:41.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "重剑无锋大巧不工",
      "url": "https://java.springlearn.cn/learn/other/%E9%87%8D%E5%89%91%E6%97%A0%E9%94%8B%E5%A4%A7%E5%B7%A7%E4%B8%8D%E5%B7%A5/",
      "id": "https://java.springlearn.cn/learn/other/%E9%87%8D%E5%89%91%E6%97%A0%E9%94%8B%E5%A4%A7%E5%B7%A7%E4%B8%8D%E5%B7%A5/",
      "content_html": "",
      "date_published": "2021-12-21T05:46:37.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Alfred添加工作流",
      "url": "https://java.springlearn.cn/learn/project/alfred/create-alfred/",
      "id": "https://java.springlearn.cn/learn/project/alfred/create-alfred/",
      "content_html": "<h2 id=\"_1-创建一个新的workflow\"> 1. 创建一个新的Workflow</h2>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1651661121000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_2-使用编辑器打开文件夹创建项目\"> 2. 使用编辑器打开文件夹创建项目</h2>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1651661168000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_3-安装alfred-workflow工作\"> 3. 安装Alfred-workflow工作</h2>\n<div><pre><code>npm install &quot;alfred-workflow-nodejs&quot;\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"_4-使用bash启动脚本\"> 4. 使用bash启动脚本</h2>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1651661238000.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1651661121000.png",
      "date_published": "2022-05-08T04:06:59.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "如何学会复盘",
      "url": "https://java.springlearn.cn/learn/other/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%BC%9A%E5%A4%8D%E7%9B%98/",
      "id": "https://java.springlearn.cn/learn/other/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%BC%9A%E5%A4%8D%E7%9B%98/",
      "content_html": "<p><a href=\"https://mp.weixin.qq.com/s/skP5pXvjsepvoOTMRmGEFw\" target=\"_blank\" rel=\"noopener noreferrer\">不懂复盘，再努力都是低水平重复</a></p>\n<h2 id=\"一、复盘三角\"> 一、复盘三角</h2>\n<p>“复盘三角”，也就是记录、反思、提炼这三个动作。</p>\n<h3 id=\"_1-1-记录\"> 1.1 记录</h3>\n<p>一天过完以后，把你当天或者过往一天的主要发生记录下来，遇到了什么人，谈了什么话，做了什么事，情绪怎么样……</p>\n<p>刚开始的时候，最好老老实实把一整天能记录的都记录下来，作为一种刻意练习，作为一种基本功的修炼。</p>\n<p>有很多人会怀疑，说记录会不会是在浪费时间，其背后的意思，实际上是想有一个取巧的办法，能不花时间也有反思的成果，我目前的看法是，别想多了，还是老老实实、扎硬寨打呆仗。</p>\n<p>为什么要如实记录？因为我们的大脑不一定靠谱，大脑自己会编造事实，事后就变成了“我以为”，实际上不是真相。记忆有时候是会骗人的。</p>\n<p>当我们有一些我们无法接受的情况发生时，如果我们很痛苦的话，大脑就倾向于抹掉那一部分或者掩盖、改写一部分，好让自己变得舒服一点。</p>\n<h3 id=\"_1-2-反思\"> 1.2 反思</h3>\n<p>就某个点、某件事慢慢进行剖析，比如为什么有这种情绪？为什么不愉快，发生了什么？为什么发生？我的判断是什么？我为什么会有这种判断？这种判断是一时的还是一种固有的模式？怎么做，才能避免？</p>\n<h3 id=\"_1-3-提炼\"> 1.3 提炼</h3>\n<p>复盘到最后，提炼形成行动指南，用以指导自己的行动。</p>\n<p>提炼很简单，就是形成一句话，复盘到最后，你要找到一句话，用这句话作为你的行动指南，作为你的方法论，作为你的原则和价值观，然后再去践行出来。</p>\n<p>提炼也不简单，这句话要求有触发效应，能够在一个场景当中有效的指引自己，当你一想到这句话，就会让自己的行为有所改变。</p>\n<p>我们的行为处事要有一套指引体系，要有一套指南。我们要用这些东西去逐渐规范、干预、调整自己的行为，用这些东西去重塑一个不同的自己。</p>\n<p>这些指南、指引，实际上就是一些所谓的原则。史蒂芬·柯维的7个习惯就是7个原则，稻盛和夫的六项精进也是6个原则。</p>\n<p>但这些原则是史蒂芬·柯维、稻盛和夫的，不是你的，虽然你很认同，但是它不一定能指导你的实践，你需要转化成自己的，拥有自己的原则。</p>\n<p>就像达利欧在《原则》当中所指出的，“最重要的事情是总结出你自己的原则，最好将其写下来，尤其是在你与其他人共事的情况下。”</p>\n<p>提炼这个步骤就是直接指向原则，这一步就是为了生产我们工作和生活的原则的。提炼的标准最好是：自己的语言，够具体，一句话，记得住，用得上。</p>\n<h2 id=\"二、好的复盘长什么样\"> 二、好的复盘长什么样？</h2>\n<h3 id=\"_2-1-好的复盘首先都是-过电影\"> 2.1 好的复盘首先都是“过电影”</h3>\n<p>所谓“过电影”，就是对过去发生的事情一幕幕进行回顾。一天结束以后，先把一天的主要经历过一遍，今天到底发生了什么，今天到底过得怎么样，需要做到心里有数，掌握一定的素材，搞清事实状况，然后才能梳理出个所以然。</p>\n<h3 id=\"_2-2-复自己的盘\"> 2.2 复自己的盘</h3>\n<p>复盘需要指向自己，如果复盘来复盘去，找到的都是别人的问题，看到的都是别人的毛病，那就不叫复盘，那叫批评大会、抱怨大会、吐槽大会。</p>\n<p>所以还差一个东西，就是自我批评。有一个词叫反求诸己，这才是真正意义上的复盘。</p>\n<h3 id=\"_2-3-复盘给自己看\"> 2.3 复盘给自己看</h3>\n<p>当你写复盘的时候，不要想着写给别人看，本着这样的心态去写，自己面对自己。</p>\n<h3 id=\"_2-4-复盘自己的痛苦\"> 2.4 复盘自己的痛苦</h3>\n<p>《原则》的作者达利欧有一个公式：痛苦+反思=进步。没有经历足够的痛苦，没有痛彻心扉，反思通常也会停留于表面，不会那么深刻。\n所以，当你经历痛苦的时候，最好把痛苦记录下来。当然，这种时候还不是反思的最佳时刻，因为你很难保持头脑清醒。最好是在痛苦之后，进行回顾和反思。</p>\n<h3 id=\"_2-5-好的复盘会指向并加速行动\"> 2.5 好的复盘会指向并加速行动</h3>\n<p>我们判断一个复盘好不好，不是看你的复盘的文字写得好不好，而是看复盘之后，你有没有采取相应的行动，有没有取得相应的成果。复盘不是目的，而是达成目的的一种手段。</p>\n<h3 id=\"_2-6-好的复盘需要不断质疑\"> 2.6 好的复盘需要不断质疑</h3>\n<p>复盘也需要更多的质疑。质疑什么？质疑自己的基本假设，自己的判断标准。</p>\n<p>这一点是最难的，首先，你要能看到自己行为处事背后的原则和标准，其次，你要能够对这些原则和标准进行自我质疑。这不是一日之功，这才是复盘中最难突破的地方。</p>\n<h2 id=\"三、复盘的三个标准\"> 三、复盘的三个标准</h2>\n<h3 id=\"_3-1-能反观\"> 3.1 能反观</h3>\n<p>很多人在参加一项培训之后会要求自己进行复盘，但他们更多所做的动作其实叫复习，把学到的东西再过一遍，看看老师讲了什么、做了什么练习或者最触动自己的是什么。</p>\n<p>他们更多所做的是记忆或者说强化记忆的行为，从复盘的角度来看，只是完成了反观的一部分工作——反回头去看。</p>\n<p>不过，这还不彻底，还要去看看所学的内容如何和自己的工作相结合，如何去落地和应用，从而让自己的工作效率和成果有所改变。还要对照学习的内容，看自己有哪些优势和不足，找出差距，然后才能有机会弥补差距。</p>\n<p>这就是“能反观”。</p>\n<h3 id=\"_3-2-会反思\"> 3.2 会反思</h3>\n<p>“能反观”之外，还要做到“会反思”。根据史蒂芬·柯维的“观为得”模型，想法决定行为，行为决定结果。也就是所谓的“观”决定“为”，“为”决定“得”。</p>\n<p>反思就是从结果倒推，去看看我们当初到底都做了什么，有哪些行为，然后再去看我们所有行为背后的想法，为什么要这样去做，为什么有这些行为，原因是什么，背后的信念假设、思维模式是什么。</p>\n<div><pre><code>比如家里来了客人，作为家长，你希望自己的女儿将玩具和客人的孩子分享，但是你的孩子的表现令你非常失望，她把玩具据为己有，一点也不愿意分享。你刚开始还好言相劝，慢慢变成了言语威胁，最后竟演变成了打骂，家里立刻变得乌烟瘴气。\n\n\n\n从结果倒推，家里气氛不好，发生了什么呢？原来是你打了孩子。你为什么要打孩子呢？因为她不愿意分享，你觉得非常没有礼貌。\n\n\n\n再去倒推“观”的层面，你会发现孩子不配合，让自己在客人面前失了面子。要把玩具跟别人分享，这是你的需求，不是孩子的需求。\n\n\n\n再倒推，你可能会发现自己很虚伪，孩子却很真实；你可能会发现，孩子只有先学会拥有，才能学会分享；你可能会发现，自己之前对待孩子的方式有问题，你让孩子养成了吃独食的习惯，没有学会分享；你可能会发现，自己一直也是这样，跟人交往不愿多付出，只是一味索取，所以孩子也不知道什么叫付出和分享，等等等等。\n\n\n\n最后你一定会在自己身上发现很多问题，这个过程，就是反思，我们用的是“得-为-观”倒推的方法。\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h3 id=\"_3-3-有反省\"> 3.3 有反省</h3>\n<p>一般的复盘，最多到这里就截止了，实际上，更高层面的复盘，还要有反省。</p>\n<p>有了反省，自己反观、反思出来的问题，才能得到真正的解决，你的固有模式才有可能被调整，你的“木马程序”才有可能被清除。</p>\n<p>反省是从事上，回到心上，去看自己的起心动念，去除恶念、保持善念。</p>\n",
      "date_published": "2022-01-04T17:14:21.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Mac 效率工具必备神器Alfred插件开发",
      "url": "https://java.springlearn.cn/learn/project/alfred/",
      "id": "https://java.springlearn.cn/learn/project/alfred/",
      "content_html": "<div><p>如果你还不了解 [Alfred](https://www.alfredapp.com/)</p>\n<p>本文默认你已经知道 Alfred的情况下,进行插件的开发。我们可以编写\n自动化工作流，在工作中帮助我们提高工作效率。</p>\n</div>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1651658394000.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1651658394000.png",
      "date_published": "2022-05-08T04:06:59.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "软实力之沟通篇",
      "url": "https://java.springlearn.cn/learn/outsite/%E6%B2%9F%E9%80%9A%E8%BD%AF%E5%AE%9E%E5%8A%9B/",
      "id": "https://java.springlearn.cn/learn/outsite/%E6%B2%9F%E9%80%9A%E8%BD%AF%E5%AE%9E%E5%8A%9B/",
      "content_html": "<blockquote>\n<p>无论作为程序员还是技术leader，沟通，在我们的工作中起了很大的作用。每个人都会说话，但是会沟通之道的却不是太多，不信你往下看。为了增加代入感，全文都以第一人称“我”来叙述。因为有些案例出自朋友身上。</p>\n</blockquote>\n<p>我把他们分为三大类别：</p>\n<h2 id=\"一、向上沟通\"> 一、向上沟通</h2>\n<h2 id=\"_1-1-雷区一-所有问题都自己扛\"> 1.1 雷区一：所有问题都自己扛！</h2>\n<p>在我还是个刚刚转岗的 PM 小菜鸟时，我负责管理一个项目，代号叫“KK”，这个项目是为公司的战略项目提供底层支撑的。在跟进这个项目的前几个月里，我跟技术负责人阿仑配合得还算默契。但是，我发现他有个特点，就是所有问题，都自己扛。</p>\n<p>距离里程碑发布只剩一周了，但在测试时，我们还在不断地发现新的 Bug。以目前的进度和剩余 Bug 的潜在影响来看，按原计划上线，质量风险很高。这天，开站会时，我请团队中的每个人，在白板上画出自己的发布信心指数。总体来看，情况非常不乐观。</p>\n<p>我跟阿仑一起做好当天的安排之后，特意提醒他：“现在的情况不是很好，我们最好跟方雷提前报备一下。”我说的方雷，是这个项目的发起人，也是阿仑的上级。阿仑没有应声，转而找旁边的开发，开始讨论别的问题了。我心里很着急，但也只好作罢。实际上，我的担忧并不是空穴来风。方雷曾经在很多个场合强调过，KK 是今年的重点，稳定性更是重中之重。最近几次线上出问题，我们团队没少挨骂。这次的上线风险这么高，要不要及时告诉方雷呢？\n我在方雷的办公室门前，绕了两个弯，各种纠结顾虑，再一想到方雷那严厉的神情，就打起了退堂鼓。最终，我什么都没说，就离开了。新版本最后还是如期上线了，但我却并没有因此感到轻松。且不说遗留 Bug 的潜在风险，由于时间紧张，我们连线上监控都没做到位，也没时间充分考虑应急预案和演练。</p>\n<p>正当团队全力补漏的时候，线上还是出事了：底层依赖的第三方服务报错，导致很多线上用户请求失败。大晚上接到客户侧的紧急电话，我们才知道出了事。第二天，方雷在邮件里，劈头盖脸就责骂了我们一顿：“之前我一再强调监控，结果已经预见到的问题，你们都没有做应对，这是非常严重的人为事故！”</p>\n<p>看到这里，你觉得我冤不冤呢？其实，我明明知道这样上线会有很大问题，也明白现阶段最好的应对方式是什么，甚至还在心中打了无数的底稿，可以说服方雷调整上线计划。可是，当我站在方雷的办公室门口时，却死活迈不出自己心里的那道坎，这个“坎”究竟是什么呢？首先是层级差在无形之中给我带来的心理压力，包括方雷平日里强硬的作风，都让我有点怵，不自觉就想躲开。</p>\n<p>其次，都快上线了，项目还有这么多问题，作为项目经理，我也是有很大责任的。另外，因为阿仑不想去汇报，如果我汇报了，我会觉得像打小报告，不仗义。实际上，做好一次紧急问题的汇报沟通，并不是什么难事。但是，迈过自己内心的那道坎，主动大胆的发起沟通，是做好向上沟通的第一步。事实上，我们首先必须要明确，这类严重影响稳定性的问题，已经不属于可以自己扛的级别了，必须要让上级知晓的。</p>\n<p>明确了这一点，处理方式可以有很多种。比如，跟阿仑深入探讨下项目的处境，尝试说服他一起去找方雷。即便他不去，我也可以跟他说明自己的判断和接下来的行动，因为客观暴露风险，合理应对，这本身就是项目经理的职责所在。当然，我也可以尝试用邮件的形式，发一封项目风险告警，客观描述现在的风险和影响，提醒方雷特别关注，等等。</p>\n<p>这里的关键是，不管通过什么途径，我们必须时刻从大局出发，让这些项目关键信息，及时有效地流动，保障及时有效的决策。当真正重要、紧急的事情发生时，直接打电话或走过去敲门，确保第一时间沟通，才是更合适的做法。记住，你不需要所有问题，都自己扛。</p>\n<h2 id=\"_1-2-雷区二-只知道吐槽-不知道争取\"> 1.2 雷区二：只知道吐槽，不知道争取</h2>\n<p>在 KK 项目组，连续加班是常有的事，半夜 2 点爬起来升级，也是家常便饭。即便我们的工作强度已经这么高了，线上仍然问题不断，项目组从上到下都压力很大。在如此“恶劣”的生存环境中，团队成员彼此之间就好比“难兄难弟”，私底下经常一起吃饭。当然，少不了的，就是一起“吐槽”。</p>\n<p>某个周末，又是一次通宵上线，我们忙到凌晨 4 点多钟，结果更新之后，出现了个突发情况，按照流程果断回退了。第二天，在定位解决问题后，又重新来过。在连续了两个通宵之后，项目得以成功上线，但团队却撑不住了。在看不到尽头的艰苦境况中，吐槽似乎成了最有效的排解压力的方式。比如，我们可能经常听到这样的吐槽：“出了问题挨骂”“没出问题是应该的”……\n刚开始，我也会跟着吐槽几句，因为我也一样，拼死拼活却得不到认可。可是，除了私下吐吐苦水，又能做什么呢？你看，这就是我踩过的第二个“坑”。当团队和管理层之间关系紧张时，很多项目经理会特别容易掉进一个误区，那就是，尽自己的努力帮团队解决问题，脏活累活都自己来。这样的“老好人”，在团队中会有很好的人缘，但是，跟着大家一起吐槽，似乎并不能带给团队真正的帮助。特别是当你同时受到高层压力的驱使，被迫去快速拿结果时，就很容易演变成“夹心饼”，吃苦受累，最后反而落得两头埋怨。</p>\n<p>那么，破局的点在哪里呢？答案就是，把“夹心饼”变成“连接器”，成为高层干系人与团队之间紧密联系的纽带。事实上，经过层层汇报，高层干系人能够得到的一线团队的信息，相当有限。很多自上而下的决策，如果不能根据一线反馈，及时调整的话，就很容易走形，偏离本意。作为项目经理，当需要高层重视和支持的事件发生时，该出手时就得出手，引发高层关注，把团队最一手的相关动态信息及时传递给他，争取高层必要的支持，而不是跟着团队一起吐槽。</p>\n<p>所以，这一次，我立刻想到了方雷！我应该让他听到团队的声音，让他意识到，长期这样下去的严重影响。而且，他才是解开这个困境的最合适的人。事实表明，方雷的介入，大大提升了团队士气。</p>\n<h2 id=\"_1-3-雷区三-抓不住重点-给不出方案\"> 1.3 雷区三：抓不住重点，给不出方案</h2>\n<p>某次会议散会之后，我叫住了他。我说：“我们团队最近加班很严重，已经连轴工作好几天了，这样下去，恐怕会……”我的话还没说完，方雷就毫不客气地打断了我，说：“现在这些年轻人，加几天班，就叫苦叫累的，想当年，我加班可多了去了……（此处省略一万字）”</p>\n<p>你看，在得到方雷的支持之前，我又踩了一个“坑”，也就是我想说的第 3 个误区：抓不住重点，给不出方案。“团队现在加班很严重”“团队任务不及时更新”“某某工作不主动、总是迟到”……如果你只是这样反映问题，只是说这里不好、那里不好，却没有告诉他，为什么要关注这个问题的话，你的意见不仅不会得到重视，甚至还会产生反效果。</p>\n<p>高层干系人的时间往往很宝贵，所以，在沟通之前，做好充分的准备，是必不可少的。你要反映的问题，与高层干系人的核心关注点是否相匹配，这是能否引起其关注并进一步行动的关键所在。在向高层干系人提问题的同时，一定要给他一个明确的“点”，让他知道，为什么要关注这个问题。实际上，抓住了对方真正的核心关注点，你才能在后续的沟通中，更加有针对性地进行高效管理。</p>\n<p>虽然我很了解方雷的脾气，但还是被刚刚这架势吓住了。还好，我提前就有所准备了。于是，我打开电脑，把准备好的数据摆在方雷面前，说：“你知道，我们的线上质量是容不得半点闪失的。这是我们团队前两个月的连续加班记录。“有人曾经做过统计，连续加班三周，人的身体、心理、情绪都会降到谷底。现在团队已经连续加班和通宵两个月了。再加上每次上线的心理压力，这样下去，恐怕会很容易犯错。昨天这次上线，团队吸取了教训，最终还是很平稳的，也算是这么长时间以来一次小小的胜利了！我在想，我们是不是应该简单庆祝下，帮大家先从心理上减减压，鼓舞下士气，也好有一个新的开始？”</p>\n<p>我一口气说完了事先准备好的“台词”，方雷先是有些吃惊，但他很快认可了我的判断。他说：“确实，我们得想办法鼓励下大家，而且一定要及时！”我灵机一动，接着说：“嗯！我看今天就是一个很好的时机。我们正打算下午开复盘会，我这就去准备些零食饮料，可以的话，请你到场跟大家讲两句话吧！”在复盘会上，方雷显然事先认真准备过。他从这个项目对大部门的重要性，讲到对大家的辛苦付出的感谢，再到绩效及奖励措施上的承诺。看得出来，他不太习惯公开说这么多鼓励的话，气氛稍有些诡异。</p>\n<h2 id=\"二、跨部门沟通\"> 二、跨部门沟通</h2>\n<p>其实，人类社会的很多冲突，都始于“边界”二字。比如，部门与部门之间存在边界，所以就有了“部门墙”。别看只是跨了个部门，各项沟通的复杂度就会直线上升。</p>\n<p>为啥呢？不是“自己人”了啊。那么，我们该如何应对跨部门沟通的问题呢？我跟你分享两种方法。</p>\n<p>一.约法三章，先说清楚</p>\n<p>我们先来看看第一种：约法三章。既然不是自己人，那就要分清楚哪些事情该我干，哪些该你干。那么，该如何约法三章呢？</p>\n<h2 id=\"_2-1-第一步-建立君子协定\"> 2.1 第一步：建立君子协定</h2>\n<p>在合作前，你要跟对方建立合约，明确合作目标、合作事项、双方各自的需求和责任、时间进度要求、风险及责任人。建立合约时，要由双方负责人进行邮件确认，公开做出正式的承诺。</p>\n<p>需要注意的是，在刚开始合作时，建立稳定的预期是关键，双方责任及进度要求，必须要得到公开确认。否则，这些问题如果不明不白的话，就会给后续工作带来极大的隐患。</p>\n<h2 id=\"_2-2-第二步-建立机制\"> 2.2 第二步：建立机制</h2>\n<p>万万不要以为，签完合约就万事大吉了。曾经，我们就遇到这样的情况：眼看着要到联调的 Deadline 了，对方的任务还没完成。我问了对方之后，才知道，说好的功能接口不能准时交付了。他们给出了很多原因，比如，工作比想象得复杂，还有人员休产假、离职等等。</p>\n<p>在项目进行中，各种情况都有可能发生，只有及时获知、甚至是提前预知风险，才能让项目始终保持可控。合作建立之后，需要建立常规的沟通机制来持续推动。比如，项目信息开放共享，每周在固定的时间开碰头会，双方相关人员交流工作进展及风险情况。更进一步的话，你还可以借助标准的任务管理和文档管理工具，对项目任务和文档做到统一的流程化管理，在过程中确保及时地跟进检查。</p>\n<p>常规机制及工具搭建好之后，在运行过程中，你还需要经常自检，确认下流程上是否有疏忽的地方。比如，是否存在“三不管”地带？每个依赖任务的职责是否明确，责任是否具体到个人？如果你发现了模糊地带的存在，要及时明确需要共同协作的内容是什么，该由哪个部门、哪个人负责，做到权责分明和分工合理，避免后期出现相互推诿、扯皮的情况。</p>\n<h2 id=\"_2-3-第三步-解决问题\"> 2.3 第三步：解决问题</h2>\n<p>通过周期检查，我们可以及时发现问题。但是，如果事先约定好了，并做了周期检查，对方负责的事情还是出问题了，该怎么办呢？有同学会说：“找他们领导！”在跨部门沟通中，打出领导牌，的确会起到一定的作用。但是，这张牌属于“王炸”，不到特别时刻，不要随便拿出来用。在找领导之前，建议你先自己摸清楚状况，尽快启动风险应对机制，确定问题处理方案，比如改变方案、调整时间、增加资源、减少范围等。</p>\n<p>另外，你要把问题和相应的决议结果抄送给双方的负责人，让双方清楚问题对整体项目的影响及调整方案。同时，你还要明确的是，今后要采取哪些预防措施，以避免问题的再次发生。那么，什么时候该找领导呢？我曾经就遇到过一种情况：两边的领导已经达成了正式的约定，但是，不是每个牵涉进去的协作方都会立马配合。</p>\n<p>原因有很多，比如，这个部门的 KPI 早就定义好了，目前上面的领导虽然认可了合作方案，但是没改 KPI，原来的目标依然有效。对于这部分新增的工作，他们要额外投人去做。因此，他们非常担心，虽然增加了工作量，但产出却不受领导的重视。类似这种会影响合作落地的根本机制问题，你就需要引入双方的领导，来一起研究解决方案。比如，在双方的绩效考核指标中，加入跨部门利益的指标，来强化这种目标和利益的捆绑，让双方真正把劲往一处使。</p>\n<p><strong>打开边界，一起想办法</strong></p>\n<p>“约法三章”，可以说是最为常见的一种跨部门沟通的应对方式。接下来，我们再来看看第二种方法：打开边界，一起想办法。尽管不是自己人，咱还是要把对方当成自己人看待，好，就一起好；出了问题，大家就一起扛。为什么说跨部门沟通还需要打开边界呢？我给你分享一个我经历过的项目，你就明白了。</p>\n<p>X 项目是一个非常典型的跨部门、跨职能的大型项目集，项目组人员接近两百个，涉及到的跨职能小组就有 12 个。由于技术复杂性，各模块之间的依赖和耦合很强，再加上各业务模块都有自己的目标和优先级，跨部门沟通的成本很高。在这样的背景下，每个业务模块都反馈说：“跨部门协调这个事，太难了。”一个很小的改进，可能就需要交互、前端、中间层、后端、各模块的测试都参与其中。即使只是组织一个会议，要想把人叫齐，都颇费周折。这种跨部门的协作，已经融入到每一天的工作中了。这时，“约法三章”的沟通方式，显然已经不适合我们了。那怎么办呢？</p>\n<p><strong>首先，要建立统一、清晰的节奏感</strong></p>\n<p>你需要结合不同业务模块的功能、相互之间的依赖关系，来为各个业务模块设计统一的交付节奏，也就是根据项目中的关键依赖，把交付时间错开排布。比如，在 X 项目中，我们在每个月固定设置了四个发布窗口，分别是 5 号、10 号、15 号和 20 号。接着，根据这 12 个模块的先后依赖关系，我们把它们安排在不同的窗口进行发布。在此之前，这些模块的发布时间都是自行定义的，现在，每月有了统一的规划和交付节奏，协同复杂度降低了很多，因为彼此之间有了稳定的交付预期和协同基准。</p>\n<p>需要注意的是，节奏的设定没有固定模式可循，你需要在自己的情境中，尝试总结规律，并把它们固化下来。有一个指示性的指标，就是重新设定节奏之后，如果跨部门协调的问题明显变少了，那么，当前这个节奏就是更合适的。</p>\n<p>其次，想要打开边界，你还需要主动往前一步</p>\n<p>对于这个项目集里的 12 个子业务模块来说，每个模块既可能是底层服务的用户，同时又是上层服务的依赖方，彼此互为上下游。在这样的情况下，如果没有彼此的通力合作，那就谁也做不好。曾经，我见过两个部门的负责人来来回回地在邮件里争吵，据理力争地互怼。后来，因为实在无法直接沟通了，他们就跟我说：“给我们加个项目经理吧。”</p>\n<p>在了解了需求之后，我发现，每个模块的日子都不好过，要么是被需求的反复弄得焦头烂额，一肚子怨气，说：“明明之前都约定好了，需求还是说变就变。我辛辛苦苦做出来了，说不用就不用，全白搭了。”要么是被频繁的依赖问题折磨得陷入“水深火热”的境地，纷纷吐槽：“底层服务又出问题，害我挨用户一顿臭骂。整天出问题，真是拿我们当小白鼠。”</p>\n<p>不管是哪一方，每个人都盯着别人的问题，同时捂住自己的问题。像这样的情况，就算是再放 10 个项目经理，估计都很难从整体上改善局面。那么，该怎么办呢？在和项目集的高层领导一起深入地剖析了现状之后，我们都认为，“头痛医头，脚痛医脚”的方式，并不是我们想要寻求的解决方案。\n我们把真正的担当解释为“上敬老，下爱小”。什么意思呢？上敬老，是说对于用户方，你要去主动深挖用户方的需求及业务背景，走在用户前面；下爱小，是指对于依赖方，你要全面监控、必要容错、并帮助它不断改进。通过这次的深入讨论，我们认识到，只有各个模块都往前走一步，才能够引发系统的改善。与其去责怪对方，不如跟他一起找到合作共赢的方式，最终让所有人获益。每次主动往前一步，最终必将体现到工作的长期效果上，从而形成持久化差异。</p>\n<h2 id=\"三、向下沟通\"> 三、向下沟通</h2>\n<p>在做项目管理的前几年时间里，我经常会听到一种声音：“项目经理无权无势，不就是个打杂的吗？”老实说，刚开始从小白起步时，我也经常有这样的困惑。没有权力，却要承担很大的责任，还得让别人愿意听我的，互相配合着把事情做好，难度真的非常高。但正因为这样，我们项目管理部的项目经理们，在这些磨练中，个个都发展出了一身武艺。这其中最厉害的一项本事，叫作“非职权领导力”。在大量的实践中，我逐步总结梳理出了非职权领导力的六力模型。“六力”分别是执行力、信息力、感知力、透明力、影响力和整合力，这六力是层层递进的关系，代表了非职权领导力发展之路上的六个层次。</p>\n<h2 id=\"_3-1-执行力\"> 3.1 执行力</h2>\n<p>执行力是非职权领导力的根基，俗称“靠谱”，这是项目经理的立身之本。我们判断一个人是否靠谱，往往是在说这个人是否具有两个特征：主动担责和有始有终。</p>\n<ul>\n<li>主动担责</li>\n</ul>\n<p>管好自己的一亩三分地，并非就是执行力好。比如，我见过很多策划，在写好策划案之后就甩手不管了。但是，我曾遇到过这样一位策划，他不仅把自己的本职工作做得很出色，还会帮忙给所有策划制作一张总进度表，即时同步信息，汇报进展。如果中间过程出现了问题，比如开发跟测试发生了冲突，他也会主动想办法协调解决，推进项目落地。</p>\n<p>一段时间后，他被 Leader 点名表扬，很快从几个同级中脱颖而出，得到了晋升。我问他：“你为啥做这么多事？”他笑笑说：“也没啥，我就是很想看到整个产品都做得很好，不能忍受有些环节出了问题没人管，没人上，那就我上呗。”所以，你看，执行力的第一层，并没有什么神奇的，你首先需要跳出自己的小圈圈，主动承担更大的责任，而不是眼睁睁地看着项目出现问题，放手不管。</p>\n<ul>\n<li>有始有终</li>\n</ul>\n<p>言必信，行必果。交给你的任何事情，都有始有终。当很多人都只是在完成任务时，如果你懂得闭环的重要性，势必会事半功倍！当时，我在团队中发起了一项“零 Bug”的改进活动，后来因为一些原因没有坚持做下去。她在了解了情况之后，很严厉地跟我说：“作为一个项目经理，你发起的任何一件事都要有‘Close’的动作。你既然跟团队讲过要做这件事，现在不做了，就算自认为原因再合理，都需要给大家一个交待，而不是不声不响地就停止了。”</p>\n<p>实际上，一个有始有终的闭环，意味着你要对自己的每一个行为负责，清楚地了解为什么做，目标是什么，做完之后效果是怎样的，还有什么问题，以后要做哪些改进。如果中途有变化，也要及时跟相关方明确说明调整或取消的原因是什么。一屋不扫，何以扫天下？执行力可以说是你能够影响他人，继而具备非职权领导力的根本。</p>\n<h2 id=\"_3-2-信息力\"> 3.2 信息力</h2>\n<p>在大数据时代，谁掌握着数据和信息，谁就拥有更强大的力量和权力。由于自身的职责和信息渠道的便利，项目管理人员会很容易成为团队中拥有最大信息量的人。大到全局的战略、项目的初衷和发展方向、决策的起因和前后变迁，小到每个团队每天在干什么，都尽在项目管理人员的掌控之中。因此，项目经理就好比是项目信息的交换中心。</p>\n<p>我曾遇到过一个项目经理，他就拥有这种神通广大的信息力。不只是项目组里，甚至是公司里上上下下发生的事情，他都能第一时间获悉。所以，遇到拿不定主意的事情时，我经常向他打听消息。有一次，我忍不住问他：“你到底是怎么做到的？”他说：“没什么神秘的，我这个就是好奇心强，而且比较热心。我对别人很感兴趣，就会经常跟大家多聊几句，不管聊的东西有没有用，我都记得清清楚楚。而且，我还特别喜欢帮助别人。比如，我觉得某个机会适合某某，我就会推荐他去试试看。久而久之，大家就会主动给我提供信息，让我帮忙出谋划策，所以我就成了最有信息力的人啦！”</p>\n<p>当然，信息力可不只是掌握简单的八卦，而是要让流动的信息汇聚起来。作为初学者，你可以通过信息互通机制和平台来帮助自己做到这一点。比如，周会、站会、周报、邮件列表、通讯群，甚至是各类数据平台，都可以成为信息力的承载。除此之外，能够让非正式信息自动流向你，就属于内功的范畴了。在与人交往与合作时，好奇、关心、真诚、友善……这些特质都会帮助你构建起信任基础。连接多了，覆盖面广了，自然会形成规模效应和网络效应，这时就会产生信息力的红利了。</p>\n<h2 id=\"_3-3-感知力\"> 3.3 感知力</h2>\n<p>感知力建立在信息力的基础之上，不同的是，感知力是对“冰山下”隐性信息的敏锐度。这种对系统敏锐的感知判断，俗称“闻味道”。感知力是日积月累的功力，但也并不是什么深奥的功夫，你也可以做得到，重点就是平常在开会时，你要多练习、多观察。</p>\n<p>举个例子，某业务负责人请我给他的管理层做一次共创会，请大家根据总体规划，各个角色共同定义下半年各自的工作重点。拿到这个需求之后，我先跟几个管理者开了一次沟通会。会后，我找到这位负责人，跟他同步了我对管理团队的观察，并且提出了我的共创方案：“在这次共创之前，我们必须先有个复盘环节，否则，以咱们团队现在的这种合作状态，根本没法很好地共创。咱们得提前准备，我需要你的大力配合。”\n他很快就认可了我的方案，并且惊讶地问我：“你是怎么做到在这么的短时间内捕捉到这么多复杂的背景信息的？”你可能也很好奇，事实上，这就是感知力在现实场景中的运用。要想培养感知力，你需要经历三个层次。\n第一层：现象层。这一层观察的焦点，是在“冰山上”的行为。比如，你观察到开发和产品在会上吵起来了，这时，你注意到的是行为，还不是真正的感知。</p>\n<p>第二层：意图层。这一层观察的焦点，是在“冰山下”行为背后的真正意图。具体要怎么做呢？最简单的是，多问几个为什么。比如，他们为什么会吵起来，各自想要达成什么目标。仔细思考之后，你会发现，原来技术已经对于产品的频繁变更忍无可忍了，技术 Leader 有很大的压力，想要为受苦受难的开发们出头；而产品的意图也很直接，他们的想法是：“业务 KPI 在那儿摆着，咱能不能别那么磨叽？快速推进不行吗？”观察到这一层，你就很接近冲突的根源了。</p>\n<p>第三层：感受层。你要试着从这些现象和意图中，去感受每个人的状态和需要。你会发现，开发的核心感受显然是愤怒；产品直接承担着业务指标带来的高压，老大的想法又一直在变，技术的不配合让他们受到双面夹击，早已是苦不堪言，核心感受是苦涩。</p>\n<p>体会到这些之后，你会发现，如果不事先处理好这些强烈的感受，这些人是根本没有办法在一起很好地进行共创的。于是，在共创开始前，我安排了一个之前提到过的复盘环节，就是让每个成员画出自己从项目启动以来的状态、经历，并把其中的“高光时刻”和“至暗时刻”分享给大家。当天，这位负责人第一个发言，跟大家分享了开创新业务以来自己的坎坷经历。他的开放和坦诚让大家一下子轻松了许多。接着，轮到产品，她提到了刚上线就被苹果推荐的成就和喜悦，同时又分享了最近“两头受夹板气”的惨痛经历。开发同学则拿出自己的画，说自己自始至终都是“压力山大”，从来都没轻松过……就这样，大家开始一点点地敞开了心扉。</p>\n<p>那些平时看不到的真实一面，被集体看见和理解之后，团队内部淤积的压力也终于得到了释放。于是，大家开始聚焦在共创下一步真正有效的解决方案。总之，要想培养感知力，就要在日常的观察之中下功夫。从关注行为，到关注行为背后的意图，再到关注意图背后个体的核心感受和深层需要，最后着眼于团队中的气场和互动品质。</p>\n<h2 id=\"_3-4-透明力\"> 3.4 透明力</h2>\n<p>信息力和感知力是对环境的观察、观察、再观察。你需要注意的是，这些观察的结果只有透明出来，才能发挥效用。你要想办法把你看到的问题可视化，让决策者和团队都能看到这些问题。这就是我经常说到的透明的力量。</p>\n<p>我在一个团队中经常听到这样的声音：“搞什么需求评审、交互评审？要做什么先说好，然后就别再来烦我了。让我安静地写会儿代码，不行吗？”于是，这些评审会能不开就不开。结果，在 Deadline 之前，需求稿、设计稿和技术方案的问题不断爆发，要熬上好几个通宵，才能保证版本的正常发布.但是到了下一个版本，情况依然如此，循环往复。</p>\n<p>经过仔细了解，我发现，如果在早期投入精力的话，这些导致发布延期的大多数问题都是可以有效避免的，发布的风险也会大大降低。实际上，定位问题并不难，但是要想解决这个问题就很难了。因为这个团队三四年来一直都是这样，他们早就已经习惯这种模式了。想要引发改变，不是仅凭一人之力就可以做得到的。要打破这个恶性循环，就一定得让大家真正地看见问题，并且从心底里达成共识。</p>\n<p>我教你两个透明化呈现的方法：一个是“分析−思考−看见”，一个是“目睹−感受−看见”。前者走脑，是指借助数据、事实、逻辑分析等，调动头脑的智慧，创造共识；后者走心，是指运用图片、视频、故事等形象化的元素，调动情绪的力量，创造共鸣。如果你能结合起来用，效果会更好。</p>\n<p>在一次版本总结回顾时，我给大家讲了一个“熊猫大侠”的故事。这位“熊猫大侠”是一个苦兮兮的程序员，他有着熊猫一样的黑眼圈，他的黑眼圈是怎么来的呢？我以这个问题为切入点，以故事的形式带领大家回顾了整个版本进行过程中的一幕幕场景，从上个版本结束时的“累觉不爱”，需求评审会上的睡意朦胧，讲到提测前对设计方案的争执不下，最后到上线前的“兵荒马乱”。“熊猫大侠”的故事，使团队成员深度地看到了项目的现状，并产生了共鸣。接着，我晒出了各种过程数据，包括需求变更率、需求和设计问题发生的阶段及成本、各阶段等待时间、研发负荷度等，邀请团队一起来想办法解开 Deadline 的“魔咒”。</p>\n<p>看见这些事实和数据之后，大家才真正地意识到早期那些看似无聊的评审工作的重要性。除此之外，团队还进一步定义了各角色的协作规则，以达到更合理的节奏。最后，在团队的共同努力下，我们进一步建立了基于过程数据的效能改进机制，各角色的协同状况得到了持续的改善。所以，你看，想要改善什么，就把什么透明化！在走脑的同时又要走心，让团队的所有人都看见问题，调动起集体的关注力和改变的动力。这样的话，这种透明的力量就会自然地推动变化的发生。</p>\n<h2 id=\"_3-5-影响力\"> 3.5 影响力</h2>\n<p>项目经理无权无势，行走江湖，靠的是大家肯买你的账。能让他人买账的这种影响力，对个体来说，就是说服力；对群体来说，就是感染力。人们通常认为，要想提升影响力，一定要能讲，会讲。但很有意思的是，影响力的真正秘诀却在于“听”，而不是“讲”。\n我曾经跟一位产品总监合作，他本人聪明又强势，属于公认的特别难搞的类型。有一次，他主动跟我说：“别人跟我讲话，我向来只听两句就忍不住想打断，但是你说的话，我几乎全都听完了。”他之所以会这样说，并不是因为我的表达能力比别人强、我的逻辑更清晰、我的话更有道理，而是因为在他讲话的时候，我做到了真正的听。跟其他人相比，我更懂他的逻辑，我明白他是出于什么样的考虑，才会那么说、那么做的。我给他提的每一条建议都是建立在我对他的理解之上的，所以才能被他听进去。</p>\n<p>不听，是一切沟通问题的根源。要想增强你的影响力，你需要先培养“听”的能力。那么，该怎么培养这种能力呢？我给你分享一个小技巧。你可以找一位项目中的成员，请他聊一聊，在最近的工作中，他有没有什么高兴或者烦恼的事。在听他说话的时候，你一定不要打断他，也不需要特意去想自己该怎么回应。你只要简单地把注意力放在对方身上，清空你的思绪，打开你的所有感官，留心去体会对方的状态和需求就可以了。试着保持至少五分钟的专注，并在结束后记录自己的体会。</p>\n<p>同时，我鼓励你跟对方分享一下，在刚刚的对话中，你留意到了什么。另外，你也可以跟他沟通下，有没有什么事情是你可以帮他一起做的。实际上，在真正有说服力的对话中，恰恰并不存在什么“一定要去说服”的想法，这又是一个有意思的悖论。实际上，只有当你真诚地抱着想要了解和倾听对方的愿望，放下对自己的想法的执着时，你才能留意到对方真正的需要。这样自然的交流分享，反而更容易产生碰撞，引发共振。如果你能够在你的每次工作对话中有意识地坚持运用这个小练习，半年之后，你的影响力就能够得到很大的提升。</p>\n<h2 id=\"_3-6-整合力\"> 3.6 整合力</h2>\n<p>在一个业务团队中，除了总负责人之外，项目经理往往是唯一站在全局层面的人。毕竟，其他人都各有各的职责分工。在这样的定位之下，项目经理一定要成为一个“多面手”。因此，优秀的全局整合能力非常关键。简单来说，整合力就是把互相分离的部分连接在一起，使它们发挥出整体作用的力量。一群优秀的人结合在一起，也并不一定能成为一个优秀的团队，不一定能真的做成一个业务。作为项目经理，整合力就意味着你要去主动发现项目组中的各类风险和问题，综合运用各种能力，跨部门、跨角色地整合资源，以实现全链条的共同目标。</p>\n<p>关于整合力，我定义了两个“凡是”：凡是能促进业务良性运作的，凡是能促进团队健康发展的，都是整合管理的范畴。举个例子，我身边有个项目曾经遭遇到了发展上的瓶颈，军心溃散，士气低落，这时，我就变身成了教练，借助教练技术，给业务负责人及核心团队“照镜子”，帮助他们看到限制他们的模式到底是什么，促发团队进行深度思考和交流，共同梳理出当前局面之下最好的思路和打法，从而帮助团队更好地走出困境。所以，你看，所谓的整合力，就是不受限于你自己的角色、从头到尾把事做成的能力。这种整合力来源于你对项目环境的观察和感知，最后要落地到全局层面的行动中去。</p>\n<p>在“六力模型”中，执行力是从现在的“行”开始，想要影响别人，就要先做好自己，走出自己的小圈圈，去承担更大的职责，并且把你在日常执行中遇到的每一个问题，都视为一个开启新循环的机会。信息力和感知力是指你要不断拓展自己对环境的准确认知和把握，观察、观察、再观察，从复杂的系统中找到一个恰当的发力点，通过把它有效地透明出来，让集体共同看见，从而获取新的共识，也就是新知。最后，你还需要通过影响力和整合力去践行这个新知，反向影响和改造环境，最终推进新知的有效落地。</p>\n",
      "date_published": "2022-06-16T13:10:16.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "软实力"
      ]
    },
    {
      "title": "Alfred-workflow-js",
      "url": "https://java.springlearn.cn/learn/project/alfred/alfred-worflow-js/",
      "id": "https://java.springlearn.cn/learn/project/alfred/alfred-worflow-js/",
      "content_html": "<h2 id=\"_1-基本运行\"> 1. 基本运行</h2>\n<div><pre><code><span>var</span> AlfredNode <span>=</span> <span>require</span><span>(</span><span>'alfred-workflow-nodejs'</span><span>)</span><span>;</span>\n<span>var</span> actionHandler <span>=</span> AlfredNode<span>.</span>actionHandler<span>;</span>\n<span>var</span> workflow <span>=</span> AlfredNode<span>.</span>workflow<span>;</span>\n<span>var</span> Item <span>=</span> AlfredNode<span>.</span>Item<span>;</span>\n \n<span>(</span><span>function</span> <span>main</span><span>(</span><span>)</span> <span>{</span>\n    actionHandler<span>.</span><span>onAction</span><span>(</span><span>\"action1\"</span><span>,</span> <span>function</span><span>(</span><span>query</span><span>)</span> <span>{</span>\n        <span>// your code to handle action 1 here</span>\n    <span>}</span><span>)</span><span>;</span>\n    actionHandler<span>.</span><span>onAction</span><span>(</span><span>\"action2\"</span><span>,</span> <span>function</span><span>(</span><span>query</span><span>)</span> <span>{</span>\n        <span>// your code to handle action 2 here</span>\n    <span>}</span><span>)</span><span>;</span>\n    \n    actionHandler<span>.</span><span>onMenuItemSelected</span><span>(</span><span>\"action2\"</span><span>,</span> <span>function</span><span>(</span><span>query<span>,</span> selectedTitle<span>,</span> selectedData</span><span>)</span> <span>{</span>\n        <span>// your code to handle manu item selected of action 2 here</span>\n    <span>}</span><span>)</span><span>;</span>\n \n    AlfredNode<span>.</span><span>run</span><span>(</span><span>)</span><span>;</span>\n<span>}</span><span>)</span><span>(</span><span>)</span><span>;</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h2 id=\"_2-日志打印\"> 2. 日志打印</h2>\n<div><pre><code>console.warn(&quot;action1, 参数:&quot; + query)\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"_3-菜单\"> 3. 菜单</h2>\n<p>使用脚本当使用tab键,会进行跳转的操作。</p>\n<div><pre><code>\n    <span>//输入tab键会把上一个选中的参数翻到这里</span>\n    actionHandler<span>.</span><span>onMenuItemSelected</span><span>(</span><span>\"action1\"</span><span>,</span> <span>function</span> <span>(</span><span>query<span>,</span> title<span>,</span> data</span><span>)</span> <span>{</span>\n        console<span>.</span><span>warn</span><span>(</span><span>\"data:\"</span> <span>+</span> data<span>)</span>\n        console<span>.</span><span>warn</span><span>(</span><span>\"title:\"</span> <span>+</span> title<span>)</span>\n        console<span>.</span><span>warn</span><span>(</span><span>\"query:\"</span> <span>+</span> query<span>)</span>\n\n        <span>var</span> item1 <span>=</span> <span>new</span> <span>Item</span><span>(</span><span>{</span>\n            <span>title</span><span>:</span> <span>\"Item 1 of \"</span> <span>+</span> title<span>,</span>\n            <span>arg</span><span>:</span> <span>\"item 1 of \"</span> <span>+</span> title <span>+</span> <span>\" which has alias \"</span><span>,</span>\n            <span>subtitle</span><span>:</span> <span>\"data\"</span><span>,</span> <span>// we can get data of selected item</span>\n            <span>valid</span><span>:</span> <span>true</span>\n        <span>}</span><span>)</span><span>;</span>\n\n        <span>var</span> item2 <span>=</span> <span>new</span> <span>Item</span><span>(</span><span>{</span>\n            <span>title</span><span>:</span> <span>\"Item 2 of \"</span> <span>+</span> title<span>,</span>\n            <span>arg</span><span>:</span> <span>\"item 2 of \"</span> <span>+</span> title <span>+</span> <span>\" which has alias \"</span><span>,</span>\n            <span>subtitle</span><span>:</span> data<span>,</span>\n            <span>valid</span><span>:</span> <span>true</span>\n        <span>}</span><span>)</span><span>;</span>\n\n        workflow<span>.</span><span>addItem</span><span>(</span>item1<span>)</span><span>;</span>\n        workflow<span>.</span><span>addItem</span><span>(</span>item2<span>)</span><span>;</span>\n\n\n        <span>var</span> item3 <span>=</span> <span>new</span> <span>Item</span><span>(</span><span>{</span>\n            <span>title</span><span>:</span> <span>\"Item 3 of \"</span> <span>+</span> storage<span>.</span><span>get</span><span>(</span><span>\"key1\"</span><span>)</span><span>,</span>\n            <span>arg</span><span>:</span> <span>\"item 3 of \"</span> <span>+</span> title <span>+</span> <span>\" which has alias \"</span><span>,</span>\n            <span>subtitle</span><span>:</span> data<span>,</span>\n            <span>valid</span><span>:</span> <span>true</span>\n        <span>}</span><span>)</span><span>;</span>\n        workflow<span>.</span><span>addItem</span><span>(</span>item3<span>)</span><span>;</span>\n\n        <span>var</span> item4 <span>=</span> <span>new</span> <span>Item</span><span>(</span><span>{</span>\n            <span>title</span><span>:</span> <span>\"Item 4 of \"</span> <span>+</span> storage<span>.</span><span>get</span><span>(</span><span>\"key2\"</span><span>)</span><span>.</span>name<span>,</span>\n            <span>arg</span><span>:</span> <span>\"item 4 of \"</span> <span>+</span> title <span>+</span> <span>\" which has alias \"</span><span>,</span>\n            <span>subtitle</span><span>:</span> data<span>,</span>\n            <span>valid</span><span>:</span> <span>true</span>\n        <span>}</span><span>)</span><span>;</span>\n        workflow<span>.</span><span>addItem</span><span>(</span>item4<span>)</span><span>;</span>\n\n        workflow<span>.</span><span>feedback</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><h2 id=\"_4-使用本地缓存进行curd\"> 4. 使用本地缓存进行CURD</h2>\n<div><pre><code>\n<span>var</span> AlfredNode <span>=</span> <span>require</span><span>(</span><span>'alfred-workflow-nodejs'</span><span>)</span><span>;</span>\n<span>var</span> actionHandler <span>=</span> AlfredNode<span>.</span>actionHandler<span>;</span>\n<span>var</span> workflow <span>=</span> AlfredNode<span>.</span>workflow<span>;</span>\n<span>var</span> Item <span>=</span> AlfredNode<span>.</span>Item<span>;</span>\nworkflow<span>.</span><span>setName</span><span>(</span><span>\"example-alfred-workflow-using-nodejs\"</span><span>)</span><span>;</span>\n<span>//类似本地的缓存</span>\n<span>var</span> storage <span>=</span> AlfredNode<span>.</span>storage<span>;</span>\n\n\n\n<span>var</span> storage <span>=</span> AlfredNode<span>.</span>storage<span>;</span>\nstorge<span>.</span><span>set</span><span>(</span><span>\"key\"</span><span>,</span> <span>\"value\"</span><span>)</span><span>;</span>\nstorage<span>.</span><span>set</span><span>(</span><span>\"key\"</span><span>,</span> <span>{</span><span>name</span><span>:</span> <span>\"node\"</span><span>}</span><span>,</span> <span>1000</span><span>)</span><span>;</span>\nstorage<span>.</span><span>get</span><span>(</span><span>\"key\"</span><span>)</span><span>;</span>\nstorage<span>.</span><span>remove</span><span>(</span><span>\"key\"</span><span>)</span><span>;</span>\nstorage<span>.</span><span>clear</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h2 id=\"_5-获取alfred-workflow中的配置\"> 5. 获取Alfred-workflow中的配置</h2>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1605443439000.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>\n <span>//获取系统外部配置</span>\n console<span>.</span><span>warn</span><span>(</span><span>\"系统环境变量:\"</span> <span>+</span> utils<span>.</span>envVars<span>.</span><span>get</span><span>(</span><span>\"outSetting\"</span><span>)</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"_6-异常图标\"> 6. 异常图标</h2>\n<p>可以是图片地址，也可以是系统icns地址</p>\n<p>(ACCOUNT, BURN, CLOCK, COLOR, EJECT, ERROR, FAVORITE, GROUP, HELP, HOME, INFO, NETWORK, NOTE, SETTINGS, SWIRL, SWITCH, SYNC, TRASH, USER, WARNING, WEB)</p>\n<div><pre><code>\nicon: AlfredNode.ICONS.INFO\n\nicon: AlfredNode.ICONS.ERROR\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id=\"_7-传递给下一个的变量\"> 7. 传递给下一个的变量</h2>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1605444141000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1605444173000.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>AlfredNode.utils.generateVars({arg: &#39;xyz&#39;, variables: {key: value}};\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h2 id=\"_8-获取mac的钥匙串\"> 8. 获取mac的钥匙串</h2>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1605444750000.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code> var settings = AlfredNode.settings;\n        // 将账户密码添加到钥匙串\n        settings.setPassword(&quot;alfred-liuxin&quot;, &quot;password&quot;);\n        // 获取mac的钥匙串中的,密码\n        settings.getPassword(&quot;alfred-liuxin&quot;, function(error, password){\n            console.warn(&quot;获取密码:&quot; + password);\n        });\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id=\"_9-自动黏贴app中\"> 9. 自动黏贴APP中</h2>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1605446383000.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1605443439000.png",
      "date_published": "2022-05-08T04:06:59.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "基于命令行的Java脚手架",
      "url": "https://java.springlearn.cn/learn/project/jmvn/",
      "id": "https://java.springlearn.cn/learn/project/jmvn/",
      "content_html": "<div><p>jmvn</p>\n<p>现阶段SpringBoot + Maven多模块是构建Java后台项目的标准格式，但是Maven多模块和成熟的Java项目结构搭建起来也是比较费力的。\n对于一个老鸟来说可能需要5分钟,但是对于一个小白或者是非专业认识,可能需要更长的时间。\n这里提供一个命令行交互式的构建工具，希望能解决这种简单重复的工作。\njmvn就是为了解决这问题诞生的, 一个快速构建Maven多模块应用的构建工具 <a href=\"https://github.com/lxchinesszz/mvn-cli\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://img.shields.io/badge/-jmvn-green?style=for-the-badge&amp;logo=appveyor\" alt=\"\" loading=\"lazy\"></a>\n它不仅能提供快速构建项目的能力，同时也能快速的安装数据模型生成Java对象,同时也可能快速导出数据库表结构信息，生成表结构文档。</p>\n</div>\n<h2 id=\"背景-目标\"> 背景 &amp; 目标</h2>\n<p>目标打造一个简单好用的 Java 服务脚手架工具，让任何没有开发经验的同学都能快速构建一个可以运行的项目</p>\n<p>工具围绕几个方面进行开发, 力求在以下方面提高开发的工作效率, 同时同过脚手架的方式从一开始就统一下项目结构和模型。</p>\n<ul>\n<li>深度定制 (定制公司标准的项目结构)</li>\n<li>快速构建标准的Maven多模块服务</li>\n<li>支持数据库模型快速安装 (一次配置终生使用, 多快好省)</li>\n<li>数据库模型文档一键导出 (每次表结构变更, 快速导出最新表文档)</li>\n</ul>\n<h2 id=\"一、介绍-introduce\"> 一、介绍 | Introduce</h2>\n<p>快速构建支持SpringBoot的Maven多模块应用,启动及快速打包部署</p>\n<ul>\n<li>支持Maven多模块构建、</li>\n<li>数据库模型安装、</li>\n<li>数据库模型导出),</li>\n<li>统一项目规范,</li>\n<li>提高工作效率,</li>\n<li>可进行深度定制。</li>\n</ul>\n<h2 id=\"二、快速安装-fast-installation\"> 二、快速安装 | Fast installation</h2>\n<h2 id=\"_2-1-node环境安装\"> 2.1 Node环境安装</h2>\n<CodeGroup>\n<CodeGroupItem title=\"Window\">\n<div><pre><code>https://nodejs.org/dist/v14.15.5/node-v14.15.5-x64.msi\n</code></pre>\n<div><span>1</span><br></div></div></CodeGroupItem>\n<CodeGroupItem title=\"Mac\" active>\n<div><pre><code>https://nodejs.org/dist/v15.9.0/node-v15.9.0.pkg\n</code></pre>\n<div><span>1</span><br></div></div></CodeGroupItem>\n</CodeGroup>\n<h2 id=\"_2-2-安装\"> 2.2 安装</h2>\n<div><pre><code>➜ npm i jmvn -g\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"三、功能介绍\"> 三、功能介绍</h2>\n<h2 id=\"_3-1-快速构建-to-quickly-build\"> 3.1 快速构建 | To quickly build</h2>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1650116393000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_3-1-1-命令行构建项目-command-line-build\"> 3.1.1 命令行构建项目 | Command line build</h3>\n<div><pre><code>ℹ Build:shop/shop-web/src/main/java/com/github/shop/web/\nℹ Build:shop/shop-web/src/main/resources/\nℹ Build:shop/shop-web/src/main/java/com/github/shop/web/\nℹ MavenHooks webPath:shop/shop-web/src/main/java/com/github/shop/web/\n✔ Build: Add SpringBoot Config:shop/shop-web/src/main/resources/application.yml\nℹ Build:shop/shop-service/src/main/java/com/github/shop/service/\nℹ Build:shop/shop-service/src/main/resources/\nℹ Build:shop/shop-service/src/main/java/com/github/shop/service/\nℹ MavenHooks servicePath:shop/shop-service/src/main/java/com/github/shop/service/\nℹ Build:shop/shop-domain/src/main/java/com/github/shop/domain/\nℹ Build:shop/shop-domain/src/main/resources/\nℹ Build:shop/shop-domain/src/main/java/com/github/shop/domain/\nℹ MavenHooks domainPath:shop/shop-domain/src/main/java/com/github/shop/domain/\nℹ Build:shop/shop-dal/src/main/java/com/github/shop/dal/\nℹ Build:shop/shop-dal/src/main/resources/\nℹ Build:shop/shop-dal/src/main/java/com/github/shop/dal/\nℹ MavenHooks dalPath:shop/shop-dal/src/main/java/com/github/shop/dal/\nℹ Build:shop/shop-integration/src/main/java/com/github/shop/integration/\nℹ Build:shop/shop-integration/src/main/resources/\nℹ Build:shop/shop-integration/src/main/java/com/github/shop/integration/\nℹ MavenHooks integrationPath:shop/shop-integration/src/main/java/com/github/shop/integration/\nℹ Build:shop/shop-config/src/main/java/com/github/shop/config/\nℹ Build:shop/shop-config/src/main/resources/\nℹ Build:shop/shop-config/src/main/java/com/github/shop/config/\nℹ MavenHooks configPath:shop/shop-config/src/main/java/com/github/shop/config/\nℹ Build:shop/shop-common/src/main/java/com/github/shop/common/\nℹ Build:shop/shop-common/src/main/resources/\nℹ Build:shop/shop-common/src/main/java/com/github/shop/common/\nℹ MavenHooks commonPath:shop/shop-common/src/main/java/com/github/shop/common/\n✔ GitIgnore before\n   __  ____   ___  __    _______   ____\n  /  |/  / | / / |/ /___/ ___/ /  /  _/\n / /|_/ /| |/ /    /___/ /__/ /___/ /\n/_/  /_/ |___/_/|_/    \\___/____/___/  Application shop Build Success\n\n✔ 🚀 JMVN CLI v1.0.6\n┌────────┬────────┬──────────┬────────────────┬──────────────────────────────────────┬────────┐\n│ 项目名 │ 作者   │ 项目版本 │ SpringBoot版本 │ 描述                                 │ 端口号 │\n├────────┼────────┼──────────┼────────────────┼──────────────────────────────────────┼────────┤\n│ shop   │ 周杰伦 │ 1.0.0    │ 0.5.1-RELEASE  │ 一个基于SpringBoot的商城项目后台服务 │ 10086  │\n└────────┴────────┴──────────┴────────────────┴──────────────────────────────────────┴────────┘\n✔ GitIgnore invoke\n✔ GitIgnore after\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><h2 id=\"_3-2-安装数据库库模型-install-the-database-library-model\"> 3.2 安装数据库库模型 | Install the database library model</h2>\n<h3 id=\"_3-2-1-配置安装信息-configure-installation-information\"> 3.2.1 配置安装信息 | Configure installation information#</h3>\n<ul>\n<li>配置项目开发数据库地址</li>\n<li>配置模型命名规则及安装目录</li>\n</ul>\n<div><pre><code><span>{</span>\n  <span>\"dbConfig\"</span><span>:</span> <span>{</span>\n    <span>\"host\"</span><span>:</span> <span>\"10.*.*.121\"</span><span>,</span>\n    <span>\"user\"</span><span>:</span> <span>\"o*test\"</span><span>,</span>\n    <span>\"password\"</span><span>:</span> <span>\"9G****RZ\"</span><span>,</span>\n    <span>\"database\"</span><span>:</span> <span>\"***\"</span>\n  <span>}</span><span>,</span>\n  <span>\"models\"</span><span>:</span> <span>[</span>\n    <span>{</span>\n      <span>\"suffix\"</span><span>:</span> <span>\"DO\"</span><span>,</span>\n      <span>\"tableName\"</span><span>:</span> <span>[</span>\n        <span>\"w_order\"</span><span>,</span>\n        <span>\"w_push_order\"</span>\n      <span>]</span><span>,</span>\n      <span>\"path\"</span><span>:</span> <span>\"scm-dao/src/main/java/com/idanchuang/scm/dao/entity/Do\"</span>\n    <span>}</span>\n  <span>]</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h3 id=\"_3-2-2-执行命令-execute-the-command\"> 3.2.2 执行命令 | Execute the command</h3>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1650116518000.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>➜ jmvn\nJMVN CLI v1.0.6\nUsage: jmvn [options] [command]\n\n快速构建支持SpringBoot的Maven多模块应用\n\nOptions:\n  -V, --version        output the version number\n  -h, --help           display help for command\n\nCommands:\n  init                 创建一个新的Maven多模块项目\n  install|i [options]  安装数据模型\n  export [options]     导出数据模型 (支持命令行模式 &amp; 交互模式)\n  help [command]       display help for command\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h2 id=\"_3-3-导出数据模型文档-export-data-model-documents\"> 3.3 导出数据模型文档 | Export data model documents</h2>\n<p>为了方便我们写技术文档, 支持直接导出成 markdown 格式文档。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1650116581000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"四、发布记录-release-record\"> 四、发布记录 | Release record</h2>\n<p><strong>1.0.1</strong></p>\n<p>构建服务\n支持注册命令</p>\n<p><strong>1.0.2</strong></p>\n<p>代码精简及优化\n版本检测及升级</p>\n<p><strong>1.0.3</strong></p>\n<p>fix端口号映射问题</p>\n<p><strong>1.0.4</strong></p>\n<p>优化版本检测,在网络差场景的用户体验</p>\n<h2 id=\"五、定制-custom\"> 五、定制 | Custom</h2>\n<p>为了达到深度定制的能力, 你所看到的一切都是可配置的。在模块每一层创建的同时也提供了钩子方法。允许你在钩子节点去做定制开发 。\n<strong><a href=\"https://github.com/lxchinesszz/mvn-cli/blob/master/action/MavenHooks.js\" target=\"_blank\" rel=\"noopener noreferrer\">MavenHooks.js</a></strong></p>\n<p>欢迎感兴趣的小伙伴一起参与开发, 🚀 <code>call me！</code></p>\n<p>微信: <code>lxchinesszz</code>\n邮箱: <code>lxchinesszz@163.com</code></p>\n<h2 id=\"六、扩展知识-expand-the-knowledge\"> 六、扩展知识 | Expand the knowledge</h2>\n<p><a href=\"/learn/design/Java代码规范全部奉上/\">代码命名规范参考建议</a></p>\n<p>项目结构设计支持配置, 在配置前请确定你的编程方法论和价值观。以下文档仅供参考。也是当前工具所保持的价值观。</p>\n<h2 id=\"_6-1-分层命名-hierarchical-naming\"> 6.1 分层命名 | Hierarchical naming</h2>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1650116968000.png\" alt=\"\" loading=\"lazy\">\n明确业务分层架构，定义领取模型, 编程不迷茫</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1650116958000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_6-2-数据模型规范-data-model-specification\"> 6.2 数据模型规范 | Data model specification</h2>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1650117078000.png\" alt=\"\" loading=\"lazy\">\n迪米特法则: 不要和陌生人说话,数据模型之间保持最少的了解 迪米特法则: 不要和陌生人说话,数据模型之间保持最少的了</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1650117093000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"七、插件开发-plug-in-development\"> 七、插件开发 | Plug-in development</h2>\n<p>脚手架工具会将在每个 Maven Module 创建过程中去发出不同对应的事件, 插件开发者可以不同的事件类型来开发插件。</p>\n<h2 id=\"_7-1-事件类型-the-event-type\"> 7.1 事件类型 | The event type</h2>\n<table>\n<thead>\n<tr>\n<th>事件类型</th>\n<th>事件说明</th>\n<th>环境信息</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>BUILD_BEFORE</td>\n<td>构建前触发</td>\n<td>-</td>\n</tr>\n<tr>\n<td>BUILD_WEB</td>\n<td>构建web层触发</td>\n<td>{ projectConfig: Object, currentPath: '' }</td>\n</tr>\n<tr>\n<td>BUILD_SERVICE</td>\n<td>构建service层触发</td>\n<td>{ projectConfig: Object, currentPath: '' }</td>\n</tr>\n<tr>\n<td>BUILD_DOMAIN</td>\n<td>构建domain层触发</td>\n<td>{ projectConfig: Object, currentPath: '' }</td>\n</tr>\n<tr>\n<td>BUILD_DAL</td>\n<td>构建dal层触发</td>\n<td>{ projectConfig: Object, currentPath: '' }</td>\n</tr>\n<tr>\n<td>BUILD_INTEGRATION</td>\n<td>构建integration层触发</td>\n<td>{ projectConfig: Object, currentPath: '' }</td>\n</tr>\n<tr>\n<td>BUILD_CONFIG</td>\n<td>构建config层触发</td>\n<td>{ projectConfig: Object, currentPath: '' }</td>\n</tr>\n<tr>\n<td>BUILD_COMMON</td>\n<td>构建common通用层触发</td>\n<td>{ projectConfig: Object, currentPath: '' }</td>\n</tr>\n<tr>\n<td>BUILD_COMPLETE</td>\n<td>构建完成触发</td>\n<td>{ &quot;namespace&quot;:Array[7], &quot;config&quot;:Object, &quot;dbConfig&quot;:Object, &quot;models&quot;:Array[1], &quot;projectConfig&quot;:Object }</td>\n</tr>\n<tr>\n<td>BUILD_JAVA_RESOURCE</td>\n<td>构建java资源文件时候触发</td>\n<td>{ projectConfig: Object, currentPath: '' }</td>\n</tr>\n<tr>\n<td>BUILD_JAVA_WEB_RESOURCE</td>\n<td>构建java, Web资源文件时候触发</td>\n<td>{ projectConfig: Object, currentPath: '' }</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"_7-2-插件生命周期函数-life-cycle-function\"> 7.2 插件生命周期函数 | Life cycle function</h2>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1650117675000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_7-3-插件开发示例-the-sample\"> 7.3 插件开发示例 | The sample</h2>\n<h3 id=\"_7-3-1-创建目录-create-a-directory\"> 7.3.1 创建目录 | Create a directory</h3>\n<p><code>plugins</code> 目录下创建插件子目录</p>\n<h3 id=\"_7-3-2-实现插件生命周期函数-write-a-function\"> 7.3.2 实现插件生命周期函数 | Write a function</h3>\n<p>插件支持before、invoke、error、after。插件的核心逻辑在invoke，可以直接实现该方法即可。</p>\n<p>所有的声明周期函数都有且只有一个入参，但是不同事件入参信息是不一样的，可以参考 7.1 事件类型, 参数说明。</p>\n<div><pre><code><span>// 方式1: 仅仅实现核心逻辑,不关注生命周期函数</span>\n<span>new</span> <span>Plugin</span><span>(</span><span>'GitIgnore'</span><span>,</span> <span>'GitIgnore创建'</span><span>,</span> PluginEventType<span>.</span><span>BUILD_COMPLETE</span><span>,</span> <span>new</span> <span>GitAction</span><span>(</span><span>)</span><span>.</span>createGitIgnoreFile<span>)</span><span>;</span>\n\n<span>// 方式2: 通过方法重写方式实现,生命周期方法</span>\n<span>let</span> plugin2 <span>=</span> <span>new</span> <span>Plugin</span><span>(</span><span>'GitIgnore'</span><span>,</span> <span>'GitIgnore创建'</span><span>,</span> PluginEventType<span>.</span><span>BUILD_COMPLETE</span><span>)</span><span>;</span>\n\nplugin2<span>.</span><span>before</span> <span>=</span> <span>function</span><span>(</span><span>envConfig</span><span>)</span><span>{</span>\n\tconsole<span>.</span><span>log</span><span>(</span><span>'插件before'</span><span>)</span>\n<span>}</span>\n\nplugin2<span>.</span><span>after</span>  <span>=</span> <span>function</span><span>(</span><span>envConfig</span><span>)</span><span>{</span>\n\tconsole<span>.</span><span>log</span><span>(</span><span>'插件before'</span><span>)</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id=\"_7-3-3-注册开发好的插件-to-register-the-plugin\"> 7.3.3 注册开发好的插件 | To register the plugin</h3>\n<p><code>plugins.Install.js</code>  进行注册</p>\n<div><pre><code><span>/**\n * 定义插件\n *\n * before->invoke->success->after\n * error异常捕捉执行\n * @param name 插件名称\n * @param desc 插件说明\n * @param type 插件类型\n * @param action 插件核心逻辑\n * @constructor\n */</span>\n<span>function</span> <span>Plugin</span><span>(</span><span>name<span>,</span> desc<span>,</span> type<span>,</span> action</span><span>)</span> <span>{</span><span>}</span>\n\n<span>// 注册一个git忽略文件插件,接受maven构建完成事件</span>\nPlugins<span>.</span><span>register</span><span>(</span><span>new</span> <span>Plugin</span><span>(</span><span>'GitIgnore'</span><span>,</span> <span>'GitIgnore创建'</span><span>,</span> PluginEventType<span>.</span><span>BUILD_COMPLETE</span><span>,</span> <span>new</span> <span>GitAction</span><span>(</span><span>)</span><span>.</span>createGitIgnoreFile<span>)</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id=\"_7-3-4-完整的参数入参-parameters-for-details\"> 7.3.4 完整的参数入参 | Parameters for details</h3>\n<ul>\n<li>项目名称 <code>tests</code> 为例</li>\n</ul>\n<div><pre><code><span>{</span>\n    <span>\"namespace\"</span><span>:</span><span>[</span>\n        <span>{</span>\n            <span>\"type\"</span><span>:</span><span>\"web\"</span><span>,</span>\n            <span>\"path\"</span><span>:</span><span>\"tests/tests-web/src/main/java/com/idanchuang/tests/web/\"</span><span>,</span>\n            <span>\"packagePath\"</span><span>:</span><span>\"com/idanchuang/tests/web\"</span>\n        <span>}</span><span>,</span>\n        <span>{</span>\n            <span>\"type\"</span><span>:</span><span>\"service\"</span><span>,</span>\n            <span>\"path\"</span><span>:</span><span>\"tests/tests-service/src/main/java/com/idanchuang/tests/service/\"</span><span>,</span>\n            <span>\"packagePath\"</span><span>:</span><span>\"com/idanchuang/tests/service\"</span>\n        <span>}</span><span>,</span>\n        <span>{</span>\n            <span>\"type\"</span><span>:</span><span>\"domain\"</span><span>,</span>\n            <span>\"path\"</span><span>:</span><span>\"tests/tests-domain/src/main/java/com/idanchuang/tests/domain/\"</span><span>,</span>\n            <span>\"packagePath\"</span><span>:</span><span>\"com/idanchuang/tests/domain\"</span>\n        <span>}</span><span>,</span>\n        <span>{</span>\n            <span>\"type\"</span><span>:</span><span>\"dal\"</span><span>,</span>\n            <span>\"path\"</span><span>:</span><span>\"tests/tests-dal/src/main/java/com/idanchuang/tests/dal/\"</span><span>,</span>\n            <span>\"packagePath\"</span><span>:</span><span>\"com/idanchuang/tests/dal\"</span>\n        <span>}</span><span>,</span>\n        <span>{</span>\n            <span>\"type\"</span><span>:</span><span>\"integration\"</span><span>,</span>\n            <span>\"path\"</span><span>:</span><span>\"tests/tests-integration/src/main/java/com/idanchuang/tests/integration/\"</span><span>,</span>\n            <span>\"packagePath\"</span><span>:</span><span>\"com/idanchuang/tests/integration\"</span>\n        <span>}</span><span>,</span>\n        <span>{</span>\n            <span>\"type\"</span><span>:</span><span>\"config\"</span><span>,</span>\n            <span>\"path\"</span><span>:</span><span>\"tests/tests-config/src/main/java/com/idanchuang/tests/config/\"</span><span>,</span>\n            <span>\"packagePath\"</span><span>:</span><span>\"com/idanchuang/tests/config\"</span>\n        <span>}</span><span>,</span>\n        <span>{</span>\n            <span>\"type\"</span><span>:</span><span>\"common\"</span><span>,</span>\n            <span>\"path\"</span><span>:</span><span>\"tests/tests-common/src/main/java/com/idanchuang/tests/common/\"</span><span>,</span>\n            <span>\"packagePath\"</span><span>:</span><span>\"com/idanchuang/tests/common\"</span>\n        <span>}</span>\n    <span>]</span><span>,</span>\n    <span>\"config\"</span><span>:</span><span>{</span>\n        <span>\"_projectName\"</span><span>:</span><span>\"tests\"</span><span>,</span>\n        <span>\"_web\"</span><span>:</span><span>\"web\"</span><span>,</span>\n        <span>\"_biz\"</span><span>:</span><span>\"service\"</span><span>,</span>\n        <span>\"_domain\"</span><span>:</span><span>\"domain\"</span><span>,</span>\n        <span>\"_dal\"</span><span>:</span><span>\"dal\"</span><span>,</span>\n        <span>\"_integration\"</span><span>:</span><span>\"integration\"</span><span>,</span>\n        <span>\"_config\"</span><span>:</span><span>\"config\"</span><span>,</span>\n        <span>\"_common\"</span><span>:</span><span>\"common\"</span><span>,</span>\n        <span>\"_groupId\"</span><span>:</span><span>\"com.idanchuang\"</span><span>,</span>\n        <span>\"_projectVersion\"</span><span>:</span><span>\"1.0.0\"</span><span>,</span>\n        <span>\"_projectDescription\"</span><span>:</span><span>\"description\"</span><span>,</span>\n        <span>\"_springBootVersion\"</span><span>:</span><span>\"0.5.1-RELEASE\"</span>\n    <span>}</span><span>,</span>\n    <span>\"projectConfig\"</span><span>:</span><span>{</span>\n        <span>\"projectName\"</span><span>:</span><span>\"tests\"</span><span>,</span>\n        <span>\"web\"</span><span>:</span><span>\"web\"</span><span>,</span>\n        <span>\"biz\"</span><span>:</span><span>\"service\"</span><span>,</span>\n        <span>\"domain\"</span><span>:</span><span>\"domain\"</span><span>,</span>\n        <span>\"dal\"</span><span>:</span><span>\"dal\"</span><span>,</span>\n        <span>\"integration\"</span><span>:</span><span>\"integration\"</span><span>,</span>\n        <span>\"config\"</span><span>:</span><span>\"config\"</span><span>,</span>\n        <span>\"common\"</span><span>:</span><span>\"common\"</span><span>,</span>\n        <span>\"groupId\"</span><span>:</span><span>\"com.idanchuang\"</span><span>,</span>\n        <span>\"projectVersion\"</span><span>:</span><span>\"1.0.0\"</span><span>,</span>\n        <span>\"mavenSurefireJavaVersion\"</span><span>:</span><span>\"1.8\"</span><span>,</span>\n        <span>\"projectDescription\"</span><span>:</span><span>\"description\"</span><span>,</span>\n        <span>\"springBootVersion\"</span><span>:</span><span>\"0.5.1-RELEASE\"</span><span>,</span>\n        <span>\"port\"</span><span>:</span><span>\"8081\"</span><span>,</span>\n        <span>\"projectAuthor\"</span><span>:</span><span>\"mvn-cli\"</span><span>,</span>\n        <span>\"modelFlag\"</span><span>:</span><span>true</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br></div></div><h2 id=\"_7-4-插件测试-plug-in-test\"> 7.4 插件测试 | Plug-in Test</h2>\n<p>配置完成即可进行 <code>debug</code></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1650117812000.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://img.shields.io/badge/-jmvn-green?style=for-the-badge&logo=appveyor",
      "date_published": "2022-04-26T15:44:59.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "快速安装",
      "url": "https://java.springlearn.cn/learn/project/jmvn/introduction-install/",
      "id": "https://java.springlearn.cn/learn/project/jmvn/introduction-install/",
      "content_html": "<Djt/>\n<h2 id=\"node环境安装\"> Node环境安装</h2>\n<CodeGroup>\n<CodeGroupItem title=\"Window\">\n<div><pre><code>https://nodejs.org/dist/v14.15.5/node-v14.15.5-x64.msi\n</code></pre>\n<div><span>1</span><br></div></div></CodeGroupItem>\n<CodeGroupItem title=\"Mac\" active>\n<div><pre><code>https://nodejs.org/dist/v15.9.0/node-v15.9.0.pkg\n</code></pre>\n<div><span>1</span><br></div></div></CodeGroupItem>\n</CodeGroup>\n<h2 id=\"命令安装\"> 命令安装</h2>\n<div><pre><code>npm i jmvn -g\n</code></pre>\n<div><span>1</span><br></div></div>",
      "date_published": "2022-04-26T15:44:59.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "数据模型导出",
      "url": "https://java.springlearn.cn/learn/project/jmvn/jmvn-export/",
      "id": "https://java.springlearn.cn/learn/project/jmvn/jmvn-export/",
      "content_html": "<div><p>jmvn export 数据模型导出</p>\n<p><code>jmvn</code> 另一个好用的功能就是数据导出，这个功能的主要用处是，在写技术方案时候将数据模型输出到文档中。支持markdown语法。</p>\n</div>\n<h2 id=\"自动读取配置进行导出\"> 自动读取配置进行导出</h2>\n<p>如果你已经在配置文件中了dbConfig相关信息，则会自动读取配置信息。你只需要输入要导出的表名即可。</p>\n<div><pre><code><span>{</span>\n  <span>\"namespace\"</span><span>:</span> <span>[</span>\n  <span>]</span><span>,</span>\n  <span>\"config\"</span><span>:</span> <span>{</span><span>}</span><span>,</span>\n  <span>\"dbConfig\"</span><span>:</span> <span>{</span>\n    <span>\"host\"</span><span>:</span> <span>\"10.80.20.8\"</span><span>,</span>\n    <span>\"user\"</span><span>:</span> <span>\"abm_dev\"</span><span>,</span>\n    <span>\"password\"</span><span>:</span> <span>\"pOj*4Z%^izKy0o23o8aH\"</span><span>,</span>\n    <span>\"database\"</span><span>:</span> <span>\"pms_dev\"</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id=\"根据命令提示完成导出\"> 根据命令提示完成导出</h2>\n<p>如果你没有在配置文件中添加dbConfig相关信息，请根据命令提示来进行完成导出。</p>\n<p><img src=\"https://img.springlearn.cn/learn_53218775085b88f319e37ca3811c5cd7.gif\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"纯命令方式导出\"> 纯命令方式导出</h2>\n<p>如果你在配置文件中已经添加了dbConfig相关信息，但是又不想使用这个进行导出。则可以在命令后添加 <code>-c</code> 以强制使用输入参数来进行导出。</p>\n<div><pre><code>jmvn export -c -m -h 10.80.20.8 -u abm_dev -p &#39;pOj*4Z%^izKy0o23o8aH&#39; -t replenish_order -db pms_dev\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"查看导出帮助文档\"> 查看导出帮助文档</h3>\n<div><pre><code>➜ jmvn help export                                                                                   \nJMVN CLI v1.0.6\nUsage: jmvn export [options]\n\n导出数据模型 (支持命令行模式 &amp; 交互模式)\n\nOptions:\n  -c, --commanded [String]  命令行模式运行\n  -m, --markdown [String]   导出markdown格式\n  -h, --host [String]       数据库[host]\n  -u, --user [String]       数据库登陆用户\n  -p, --password [String]   登陆密码(明文请注意安全)\n  -t, --tables [String]     要导出的表模型(支持,分隔)\n  -db, --database [String]  指定要导出的库\n  --help                    display help for command\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div>",
      "image": "https://img.springlearn.cn/learn_53218775085b88f319e37ca3811c5cd7.gif",
      "date_published": "2022-04-26T15:44:59.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "数据模型安装",
      "url": "https://java.springlearn.cn/learn/project/jmvn/jmvn-install/",
      "id": "https://java.springlearn.cn/learn/project/jmvn/jmvn-install/",
      "content_html": "<div><p>jmvn instll 数据安装</p>\n<p><code>jmvn</code> 一个好用的功能就是支持数据安装，这个功能是我比较喜欢的。因为在项目\n中开发过程中，经常会出现,表结构进行变更，可能是增加些表注释，增加个字段。这个时候就要同步来\n修改数据模型。是比较繁琐的。当你尝试过 <code>jmvn install</code> 功能后，这个问题就能彻底解决了。\n只需要运行 <code>jmvn install</code> 命令，数据模型就会同步更改。</p>\n</div>\n<h2 id=\"配置如下\"> 配置如下</h2>\n<p>在你的项目 <code>.jmvn.json</code> 中添加如下。<code>jmvn</code> 会读取 <code>dbConfig</code> 中数据库的配置。\n写入到 <code>models</code> 中指定的目录 <code>path</code>。</p>\n<div><pre><code><span>{</span>\n  <span>\"namespace\"</span><span>:</span> <span>[</span>\n  <span>]</span><span>,</span>\n  <span>\"config\"</span><span>:</span> <span>{</span><span>}</span><span>,</span>\n  <span>\"dbConfig\"</span><span>:</span> <span>{</span>\n    <span>\"host\"</span><span>:</span> <span>\"10.*.*.8\"</span><span>,</span>\n    <span>\"user\"</span><span>:</span> <span>\"root\"</span><span>,</span>\n    <span>\"password\"</span><span>:</span> <span>\"123456\"</span><span>,</span>\n    <span>\"database\"</span><span>:</span> <span>\"test\"</span>\n  <span>}</span><span>,</span>\n  <span>\"models\"</span><span>:</span> <span>[</span>\n    <span>{</span>\n      <span>\"suffix\"</span><span>:</span> <span>\"DO\"</span><span>,</span>\n      <span>\"tableName\"</span><span>:</span> <span>[</span>\n        <span>\"user\"</span><span>,</span>\n        <span>\"user_detail\"</span>\n      <span>]</span><span>,</span>\n      <span>\"path\"</span><span>:</span> <span>\"example-dal/src/main/java/com/example/dal/entity\"</span>\n    <span>}</span>\n  <span>]</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>你可以在models中使用suffix添加Java文件的后缀名。\neg: user表，最终写成java文件为 UserDO</p>\n",
      "date_published": "2022-04-26T15:44:59.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "工具介绍",
      "url": "https://java.springlearn.cn/learn/project/jmvn/introduction/",
      "id": "https://java.springlearn.cn/learn/project/jmvn/introduction/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/learn_600dd8ab8ca8e139c8bc37f5fc1b5801.gif\" alt=\"\" loading=\"lazy\"></p>\n<p>目标打造一个简单好用的 Java 服务脚手架工具，让任何没有开发经验的同学都能快速构建一个可以运行的项目</p>\n<p>工具围绕几个方面进行开发, 力求在以下方面提高开发的工作效率, 同时通过脚手架的方式从一开始就统一下项目结构和模型。</p>\n<ul>\n<li>深度定制 (定制公司标准的项目结构)</li>\n<li>快速构建标准的Maven多模块服务</li>\n<li>支持数据库模型快速安装 (一次配置终生使用, 多快好省)</li>\n<li>数据库模型文档一键导出 (每次表结构变更, 快速导出最新表文档)</li>\n</ul>\n<h2 id=\"介绍\"> 介绍</h2>\n<p>快速构建支持SpringBoot的Maven多模块应用,启动及快速打包部署</p>\n<ul>\n<li>支持Maven多模块构建、</li>\n<li>数据库模型安装、</li>\n<li>数据库模型导出),</li>\n<li>统一项目规范,</li>\n<li>提高工作效率,</li>\n<li>可进行深度定制。</li>\n</ul>\n",
      "image": "https://img.springlearn.cn/learn_600dd8ab8ca8e139c8bc37f5fc1b5801.gif",
      "date_published": "2022-04-26T15:44:59.000Z",
      "date_modified": "2022-04-26T15:44:59.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "创建项目",
      "url": "https://java.springlearn.cn/learn/project/jmvn/jmvn-init/",
      "id": "https://java.springlearn.cn/learn/project/jmvn/jmvn-init/",
      "content_html": "<div><p>jmvn init</p>\n<p>快到你无法想象，丝滑的感觉</p>\n</div>\n<h2 id=\"使用命令快速创建项目\"> 使用命令快速创建项目</h2>\n<p>你可以方便的使用工具创建基于SpringBoot的Maven多模块应用，如下示例。</p>\n<p><img src=\"https://img.springlearn.cn/learn_600dd8ab8ca8e139c8bc37f5fc1b5801.gif\" alt=\"\" loading=\"lazy\"></p>\n<p>项目创建后会自动生成一个配置文件。默认项目的结构如下。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1650473598000.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code><span>{</span>\n  <span>\"namespace\"</span><span>:</span><span>[</span>\n    <span>{</span>\n      <span>\"type\"</span><span>:</span><span>\"web\"</span><span>,</span>\n      <span>\"path\"</span><span>:</span><span>\"example/example-web/src/main/java/com/github/example/web/\"</span><span>,</span>\n      <span>\"packagePath\"</span><span>:</span><span>\"com/github/example/web\"</span>\n    <span>}</span><span>,</span>\n    <span>{</span>\n      <span>\"type\"</span><span>:</span><span>\"service\"</span><span>,</span>\n      <span>\"path\"</span><span>:</span><span>\"example/example-service/src/main/java/com/github/example/service/\"</span><span>,</span>\n      <span>\"packagePath\"</span><span>:</span><span>\"com/github/example/service\"</span>\n    <span>}</span><span>,</span>\n    <span>{</span>\n      <span>\"type\"</span><span>:</span><span>\"domain\"</span><span>,</span>\n      <span>\"path\"</span><span>:</span><span>\"example/example-domain/src/main/java/com/github/example/domain/\"</span><span>,</span>\n      <span>\"packagePath\"</span><span>:</span><span>\"com/github/example/domain\"</span>\n    <span>}</span><span>,</span>\n    <span>{</span>\n      <span>\"type\"</span><span>:</span><span>\"dal\"</span><span>,</span>\n      <span>\"path\"</span><span>:</span><span>\"example/example-dal/src/main/java/com/github/example/dal/\"</span><span>,</span>\n      <span>\"packagePath\"</span><span>:</span><span>\"com/github/example/dal\"</span>\n    <span>}</span><span>,</span>\n    <span>{</span>\n      <span>\"type\"</span><span>:</span><span>\"integration\"</span><span>,</span>\n      <span>\"path\"</span><span>:</span><span>\"example/example-integration/src/main/java/com/github/example/integration/\"</span><span>,</span>\n      <span>\"packagePath\"</span><span>:</span><span>\"com/github/example/integration\"</span>\n    <span>}</span><span>,</span>\n    <span>{</span>\n      <span>\"type\"</span><span>:</span><span>\"config\"</span><span>,</span>\n      <span>\"path\"</span><span>:</span><span>\"example/example-config/src/main/java/com/github/example/config/\"</span><span>,</span>\n      <span>\"packagePath\"</span><span>:</span><span>\"com/github/example/config\"</span>\n    <span>}</span><span>,</span>\n    <span>{</span>\n      <span>\"type\"</span><span>:</span><span>\"common\"</span><span>,</span>\n      <span>\"path\"</span><span>:</span><span>\"example/example-common/src/main/java/com/github/example/common/\"</span><span>,</span>\n      <span>\"packagePath\"</span><span>:</span><span>\"com/github/example/common\"</span>\n    <span>}</span>\n  <span>]</span><span>,</span>\n  <span>\"config\"</span><span>:</span><span>{</span>\n\n  <span>}</span><span>,</span>\n  <span>\"dbConfig\"</span><span>:</span><span>{</span>\n    <span>\"host\"</span><span>:</span><span>\"\"</span><span>,</span>\n    <span>\"user\"</span><span>:</span><span>\"\"</span><span>,</span>\n    <span>\"password\"</span><span>:</span><span>\"\"</span><span>,</span>\n    <span>\"database\"</span><span>:</span><span>\"\"</span>\n  <span>}</span><span>,</span>\n  <span>\"models\"</span><span>:</span><span>[</span>\n    <span>{</span>\n      <span>\"suffix\"</span><span>:</span><span>\"DO\"</span><span>,</span>\n      <span>\"tableName\"</span><span>:</span><span>[</span>\n\n      <span>]</span><span>,</span>\n      <span>\"path\"</span><span>:</span><span>\"\"</span>\n    <span>}</span>\n  <span>]</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br></div></div><h2 id=\"手动添加配置文件\"> 手动添加配置文件</h2>\n<p>当你项目已经创建完成，但是想要使用的情况下, 你是可以通过配置的方式来支持的。</p>\n<p>首先在项目的根目录创建文件 <code>.jmvn.json</code></p>\n<div><pre><code><span>{</span>\n  <span>\"namespace\"</span><span>:</span> <span>[</span>\n  <span>]</span><span>,</span>\n  <span>\"config\"</span><span>:</span> <span>{</span><span>}</span><span>,</span>\n  <span>\"dbConfig\"</span><span>:</span> <span>{</span>\n    <span>\"host\"</span><span>:</span> <span>\"10.*.*.8\"</span><span>,</span>\n    <span>\"user\"</span><span>:</span> <span>\"root\"</span><span>,</span>\n    <span>\"password\"</span><span>:</span> <span>\"123456\"</span><span>,</span>\n    <span>\"database\"</span><span>:</span> <span>\"test\"</span>\n  <span>}</span><span>,</span>\n  <span>\"models\"</span><span>:</span> <span>[</span>\n    <span>{</span>\n      <span>\"suffix\"</span><span>:</span> <span>\"DO\"</span><span>,</span>\n      <span>\"tableName\"</span><span>:</span> <span>[</span>\n        <span>\"user\"</span><span>,</span>\n        <span>\"user_detail\"</span>\n      <span>]</span><span>,</span>\n      <span>\"path\"</span><span>:</span> <span>\"example-dal/src/main/java/com/example/dal/entity\"</span>\n    <span>}</span>\n  <span>]</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div>",
      "image": "https://img.springlearn.cn/learn_600dd8ab8ca8e139c8bc37f5fc1b5801.gif",
      "date_published": "2022-04-26T15:44:59.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "插件开发",
      "url": "https://java.springlearn.cn/learn/project/jmvn/jmvn-plugin/",
      "id": "https://java.springlearn.cn/learn/project/jmvn/jmvn-plugin/",
      "content_html": "<div><p>jmvn instll 数据安装</p>\n<p><code>jmvn</code> 一个好用的功能就是支持数据安装，这个功能是我比较喜欢的。因为在项目\n中开发过程中，经常会出现,表结构进行变更，可能是增加些表注释，增加个字段。这个时候就要同步来\n修改数据模型。是比较繁琐的。当你尝试过 <code>jmvn install</code> 功能后，这个问题就能彻底解决了。\n只需要运行 <code>jmvn install</code> 命令，数据模型就会同步更改。</p>\n</div>\n<h2 id=\"配置如下\"> 配置如下</h2>\n<p>在你的项目 <code>.jmvn.json</code> 中添加如下。<code>jmvn</code> 会读取 <code>dbConfig</code> 中数据库的配置。\n写入到 <code>models</code> 中指定的目录 <code>path</code>。</p>\n<div><pre><code><span>{</span>\n  <span>\"namespace\"</span><span>:</span> <span>[</span>\n  <span>]</span><span>,</span>\n  <span>\"config\"</span><span>:</span> <span>{</span><span>}</span><span>,</span>\n  <span>\"dbConfig\"</span><span>:</span> <span>{</span>\n    <span>\"host\"</span><span>:</span> <span>\"10.*.*.8\"</span><span>,</span>\n    <span>\"user\"</span><span>:</span> <span>\"root\"</span><span>,</span>\n    <span>\"password\"</span><span>:</span> <span>\"123456\"</span><span>,</span>\n    <span>\"database\"</span><span>:</span> <span>\"test\"</span>\n  <span>}</span><span>,</span>\n  <span>\"models\"</span><span>:</span> <span>[</span>\n    <span>{</span>\n      <span>\"suffix\"</span><span>:</span> <span>\"DO\"</span><span>,</span>\n      <span>\"tableName\"</span><span>:</span> <span>[</span>\n        <span>\"user\"</span><span>,</span>\n        <span>\"user_detail\"</span>\n      <span>]</span><span>,</span>\n      <span>\"path\"</span><span>:</span> <span>\"example-dal/src/main/java/com/example/dal/entity\"</span>\n    <span>}</span>\n  <span>]</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>你可以在models中使用suffix添加Java文件的后缀名。\neg: user表，最终写成java文件为 UserDO</p>\n",
      "date_published": "2022-04-26T15:44:59.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "JVM调优",
      "url": "https://java.springlearn.cn/learn/project/jvm/",
      "id": "https://java.springlearn.cn/learn/project/jvm/",
      "content_html": "<p><a href=\"https://github.com/lxchinesszz/learn-example/blob/master/learn-jvm/src/test/java/learn/jvm\" target=\"_blank\" rel=\"noopener noreferrer\">示例代码地址</a></p>\n<h2 id=\"一、jvm内存介绍\"> 一、JVM内存介绍</h2>\n<p>我们在学习JVM的内存管理的时候,我们的思维要跳出Java的局限。我们要这么理解。我们写的Java代码，是运行在JVM上的。\n如果让你来实现JVM那么。你会怎么处理呢?</p>\n<ul>\n<li>公共部分(堆heap)\n<ul>\n<li><code>Class字节码</code>是公共的,是共享的,所有线程都要认识字节码。</li>\n<li><code>new的对象</code>是公共的,也是共享的,所有线程要都能认识这些实例对象,能读取到实例的数据。</li>\n</ul>\n</li>\n<li>私有部分 (栈stock)\n<ul>\n<li>Java中每个线程的执行中的代码，及代码中的局部变量等信息是私有的。每个线程之间都要维护一份。</li>\n<li>JVM虚拟栈和本地方法栈。</li>\n<li>代码是怎么执行的,当然是一行一行执行。那么这一行一行的代码是放在哪里的呢? 是放在栈里面的。Java代码是在JVM来执行的。\n所以这个栈，我们称为<code>JVM虚拟栈</code>。</li>\n<li>JVM中有些方法是调用其他语言实现的, 会使用<code>本地方法栈</code>。</li>\n<li>那么谁来读取栈里面的数据,来出栈执行呢? 这叫做<code>PC寄存区</code>。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"_1-1-堆空间\"> 1.1 堆空间</h2>\n<p><a href=\"/learn/project/jvm/JVM参数配置说明/\">JVM参数配置说明</a></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1654183539000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_1-1-1-堆上信息\"> 1.1.1 堆上信息</h3>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1654188805000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><code>new</code> 出来的对象都在堆上。当堆的内存不足，会触发gc。<a href=\"/\">GC策略</a>。</p>\n<h3 id=\"_1-1-2-堆的相关配置\"> 1.1.2 堆的相关配置</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">配置参数</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:left\">示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>-Xmx</code></td>\n<td style=\"text-align:left\">设置最大堆大小。</td>\n<td style=\"text-align:left\"><code>-Xmx3550m</code>，设置JVM最大可用内存为3550 MB。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-Xms</code></td>\n<td style=\"text-align:left\">设置JVM初始内存。</td>\n<td style=\"text-align:left\"><code>-Xms3550m</code>，设置JVM初始内存为3550 MB。此值建议与<code>-Xmx</code>相同，避免每次垃圾回收完成后JVM重新分配内存。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-Xmn2g</code></td>\n<td style=\"text-align:left\">设置年轻代大小。</td>\n<td style=\"text-align:left\"><code>-Xmn2g</code>，设置年轻代大小为2 GB。整个JVM内存大小=年轻代大小+年老代大小+持久代大小。持久代一般固定大小为64 MB，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-XX:NewRatio=n</code></td>\n<td style=\"text-align:left\">设置年轻代和年老代的比值。</td>\n<td style=\"text-align:left\"><code>-XX:NewRatio=4</code>，设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。如果设置为4，那么年轻代与年老代所占比值为1:4，年轻代占整个堆栈的1/5。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-XX:SurvivorRatio=n</code></td>\n<td style=\"text-align:left\">年轻代中Eden区与两个Survivor区的比值。</td>\n<td style=\"text-align:left\"><code>-XX:SurvivorRatio=4</code>，设置年轻代中Eden区与Survivor区的大小比值。如果设置为4，那么两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-XX:MaxPermSize=n</code></td>\n<td style=\"text-align:left\">设置持久代大小。(JDK8以移除)</td>\n<td style=\"text-align:left\"><code>-XX:MaxPermSize=16m</code>，设置持久代大小为16 MB。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-XX:MaxTenuringThreshold=n</code></td>\n<td style=\"text-align:left\">设置垃圾最大年龄。</td>\n<td style=\"text-align:left\"><code>-XX:MaxTenuringThreshold=0</code>，设置垃圾最大年龄。如果设置为0，那么年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，提高了效率。如果将此值设置为较大值，那么年轻代对象会在Survivor区进行多次复制，增加了对象在年轻代的存活时间，增加在年轻代即被回收的概率。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_1-1-3-常见问题\"> 1.1.3 常见问题</h3>\n<ul>\n<li>大对象，无法释放，导致内存移除。\n<strong>堆上的问题是比较容易排查的,可以通过工具把堆的信息给dump下来,然后就能直接定位到大对象,并通过调用链路定位到具体的代码,后面会介绍工具</strong></li>\n</ul>\n<h2 id=\"_1-2-非堆空间\"> 1.2 非堆空间</h2>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1654188048000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_1-2-1-非堆上的信息\"> 1.2.1 非堆上的信息</h3>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1654188805000.png\" alt=\"\" loading=\"lazy\"></p>\n<ul>\n<li><code>Thread</code> 配置线程的栈大小，决定了你调用链的深度。</li>\n<li><code>Metaspace</code> 可加载类的信息大小</li>\n</ul>\n<h3 id=\"_1-2-2-相关配置\"> 1.2.2 相关配置</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">配置参数</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:left\">示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>-Xss</code></td>\n<td style=\"text-align:left\">设置线程的栈大小。</td>\n<td style=\"text-align:left\"><code>-Xss128k</code>，设置每个线程的栈大小为128 KB。<strong>说明</strong> JDK 5.0版本以后每个线程栈大小为1 MB，JDK 5.0以前版本每个线程栈大小为256 KB。请依据应用的线程所需内存大小进行调整。在相同物理内存下，减小该值可以生成更多的线程。但是操作系统对一个进程内的线程个数有一定的限制，无法无限生成，一般在3000个~5000个。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-XX:MaxMetaspace=n</code></td>\n<td style=\"text-align:left\">设置元空间大小。</td>\n<td style=\"text-align:left\"><code>-XX:MaxMetaspace=16m</code>，设置元空间大小为16 MB。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"二、工具介绍\"> 二、工具介绍</h2>\n<h2 id=\"_2-1-原生命令\"> 2.1 原生命令</h2>\n<h2 id=\"_2-2-二方可视化分析\"> 2.2 二方可视化分析</h2>\n<h3 id=\"_2-2-1-idea-插件visualgc\"> 2.2.1 idea 插件VisualGC</h3>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1654189397000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1654189362000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_2-2-2-jprofile\"> 2.2.2 JProfile</h3>\n<p><a href=\"https://www.ej-technologies.com/products/jprofiler/overview.html\" target=\"_blank\" rel=\"noopener noreferrer\">JProfile</a></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1654189623000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_2-2-3-arthas\"> 2.2.3 Arthas</h3>\n<p><a href=\"https://arthas.aliyun.com/zh-cn/\" target=\"_blank\" rel=\"noopener noreferrer\">Arthas</a></p>\n<p><strong>Arthas功能是比较强大的,非常适合用于排查些疑难问题</strong></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1654189757000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_2-3-gc日志学习\"> 2.3 GC日志学习</h2>\n<ul>\n<li>开启GC日志参数 <code>-XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:+PrintGCDateStamps</code></li>\n</ul>\n<h3 id=\"_2-3-1-年轻代gc\"> 2.3.1 年轻代GC</h3>\n<ul>\n<li>首先是年轻代GC</li>\n</ul>\n<div><pre><code>2022-06-03T00:13:48.801-0800: \n0.369: \n[GC (Allocation Failure) \n[PSYoungGen: 7168K-&gt;1513K(8704K)] 7168K-&gt;4097K(49664K), 0.0183816 secs] \n[Times: user=0.02 sys=0.01, real=0.02 secs] \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>\n<li><code>2022-06-03T00:13:48.801-0800</code> -XX:+PrintGCDateStamps 打印日期</li>\n<li><code>0.369</code> -XX:+PrintGCDateStamps JVM启动到当前日期的总时长的时间戳形式</li>\n<li><code>[GC (Allocation Failure)</code> GC 原因(Allocation Failure) 分配失败\n<ul>\n<li><mark>Allocation Failure</mark> 分配失败</li>\n<li><mark>Metadata GC Threshold</mark> 元空间不足</li>\n<li><mark>Last ditch collection</mark> 元空间GC后,仍然不足,即触发</li>\n</ul>\n</li>\n<li><code>PSYoungGen</code> 年轻代GC</li>\n<li><code>Times</code> 耗时统计\n<ul>\n<li><code>user</code> 表示GC线程执行所使用的CPU总时间</li>\n<li><code>sys</code> 进程在内核态消耗的CPU时间</li>\n<li><code>real</code> 程序从开始到结束所用的时钟时间,这个时间接近 sys + user</li>\n</ul>\n</li>\n</ul>\n<p><strong>由于多核的原因,一般的GC事件中, real time是小于sys + user time的,因为一般是多个线程并发的去做GC,所以real time是要小于systuser time的</strong></p>\n<h3 id=\"_2-3-2-老年代gc\"> 2.3.2 老年代GC</h3>\n<p>老年代执行的是 Full GC，Full GC执行的时候，不止回收老年代，还会回收新生代和元数据空间</p>\n<div><pre><code>2022-06-03T00:22:27.829-0800:\n0.798: \n[Full GC (Allocation Failure) \n[PSYoungGen: 0K-&gt;0K(8704K)] \n[ParOldGen: 36024K-&gt;36006K(40960K)] 36024K-&gt;36006K(49664K), \n[Metaspace: 3078K-&gt;3078K(1056768K)], 0.2006976 secs] \n[Times: user=1.11 sys=0.01, real=0.21 secs] \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><ul>\n<li><code>2022-06-03T00:13:48.801-0800</code> -XX:+PrintGCDateStamps 打印日期</li>\n<li><code>0.369</code> -XX:+PrintGCDateStamps JVM启动到当前日期的总时长的时间戳形式</li>\n<li><code>[Full GC (Allocation Failure)</code> GC 原因(Allocation Failure) 分配失败\n<ul>\n<li><mark>Allocation Failure</mark> 分配失败</li>\n<li><mark>Metadata GC Threshold</mark> 元空间不足</li>\n<li><mark>Last ditch collection</mark> 元空间GC后,仍然不足,即触发</li>\n</ul>\n</li>\n<li><code>PSYoungGen</code> 年轻代GC</li>\n<li><code>ParOldGen</code> 老年代GC</li>\n<li><code>Metaspace</code> 元空间或者叫方法区GC</li>\n<li><code>Times</code> 耗时统计\n<ul>\n<li><code>user</code> 表示GC线程执行所使用的CPU总时间</li>\n<li><code>sys</code> 进程在内核态消耗的CPU时间</li>\n<li><code>real</code> 程序从开始到结束所用的时钟时间,这个时间接近 sys + user</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"三、场景分析\"> 三、场景分析</h2>\n<h2 id=\"_3-1-堆空间导致oom\"> 3.1 堆空间导致OOM</h2>\n<h3 id=\"_3-1-1-模拟堆栈\"> 3.1.1 模拟堆栈</h3>\n<ul>\n<li><code>HeapOverflowTest</code></li>\n<li><code>StackOverflowTest</code></li>\n</ul>\n<h3 id=\"_3-1-2-现象\"> 3.1.2 现象</h3>\n<ol>\n<li>频繁进行fu gc</li>\n<li>应用吞吐量下降</li>\n<li>应用rt上升</li>\n<li>方法调用报错<strong>OutOfMemoryError : Java heap space</strong></li>\n</ol>\n<h3 id=\"_3-1-3-解决方案\"> 3.1.3 解决方案</h3>\n<ol>\n<li><code>jps</code> 找到应用 <code>pid</code></li>\n<li>把堆信息dump下来 <code>jmap -dump:format=b,file=heap.hprof ${pid}</code></li>\n<li>打开JProfile 打开文件,直接看到大对象是哪个。</li>\n</ol>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1654191631000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_3-2-cpu飙升\"> 3.2 CPU飙升</h2>\n<p>CPU飙升,可能是有线程一直在占用CPU。发生了死锁，发生了死循环之类的。这些情况是有问题的。\n但是当你的机器流量比较大时候,同样也会导致CPU飙升,此时可能就需要加机器来进行解决。或者仅限限流。下面\n只说有问题的场景,如何查看线程状态。</p>\n<h3 id=\"_3-2-1-模拟异常\"> 3.2.1 模拟异常</h3>\n<div><pre><code><span>public</span> <span>class</span> CPU <span>{</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>10</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>\n                <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>\n\n                <span>}</span>\n            <span>}</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id=\"_3-2-2-现象\"> 3.2.2 现象</h3>\n<ul>\n<li>系统卡顿,吞吐量下降</li>\n<li>如果没有限制启动参数,可能会导致宿主机也非常卡段,引用占用了很大CPU</li>\n</ul>\n<h3 id=\"_3-2-3-解决方案\"> 3.2.3 解决方案</h3>\n<ol>\n<li>找到那些线程在阻塞 <code>jstack $PID</code></li>\n<li>如下片段发现线程都是 <code>BLOCKED</code> 状态, 调用点都在 <code>CPU.java:18</code></li>\n</ol>\n<div><pre><code>&quot;Thread-497&quot; #508 prio=5 os_prio=31 tid=0x00007f88f58a0000 nid=0x41903 waiting for monitor entry [0x0000000326ea5000]\n   java.lang.Thread.State: BLOCKED (on object monitor)\n\tat java.io.PrintStream.println(PrintStream.java:735)\n\t- waiting to lock &lt;0x00000007bce02720&gt; (a java.io.PrintStream)\n\tat learn.jvm.CPU.lambda$main$0(CPU.java:18)\n\tat learn.jvm.CPU$$Lambda$1/189568618.run(Unknown Source)\n\tat java.lang.Thread.run(Thread.java:748)\n\n&quot;Thread-496&quot; #507 prio=5 os_prio=31 tid=0x00007f88f589f800 nid=0x41a03 waiting for monitor entry [0x0000000326da2000]\n   java.lang.Thread.State: BLOCKED (on object monitor)\n\tat java.io.PrintStream.println(PrintStream.java:735)\n\t- waiting to lock &lt;0x00000007bce02720&gt; (a java.io.PrintStream)\n\tat learn.jvm.CPU.lambda$main$0(CPU.java:18)\n\tat learn.jvm.CPU$$Lambda$1/189568618.run(Unknown Source)\n\tat java.lang.Thread.run(Thread.java:748)\n\n&quot;Thread-495&quot; #506 prio=5 os_prio=31 tid=0x00007f8905034000 nid=0x41c03 waiting for monitor entry [0x0000000326c9f000]\n   java.lang.Thread.State: BLOCKED (on object monitor)\n\tat java.io.PrintStream.println(PrintStream.java:735)\n\t- waiting to lock &lt;0x00000007bce02720&gt; (a java.io.PrintStream)\n\tat learn.jvm.CPU.lambda$main$0(CPU.java:18)\n\tat learn.jvm.CPU$$Lambda$1/189568618.run(Unknown Source)\n\tat java.lang.Thread.run(Thread.java:748)\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><div><p>Arthas</p>\n<p>当然如果你安装了 <code>Arthas</code></p>\n<p>你可以 <code>thread -n 3</code> 打印出最忙的三个线程  <a href=\"https://arthas.gitee.io/thread.html#cpu\" target=\"_blank\" rel=\"noopener noreferrer\">thread</a>.\n直接输入cpu使用量</p>\n<p>thread -b, 找出当前阻塞其他线程的线程</p>\n</div>\n<div><pre><code>&quot;Thread-8&quot; Id=19 cpuUsage=89.17% deltaTime=188ms time=17319ms RUNNABLE\n    at learn.jvm.CPU.lambda$main$0(CPU.java:13)\n    at learn.jvm.CPU$$Lambda$1/500977346.run(Unknown Source)\n    at java.lang.Thread.run(Thread.java:748)\n\n\n&quot;Thread-1&quot; Id=12 cpuUsage=85.62% deltaTime=180ms time=17296ms RUNNABLE\n    at learn.jvm.CPU.lambda$main$0(CPU.java:13)\n    at learn.jvm.CPU$$Lambda$1/500977346.run(Unknown Source)\n    at java.lang.Thread.run(Thread.java:748)\n\n\n&quot;Thread-3&quot; Id=14 cpuUsage=84.42% deltaTime=178ms time=17315ms RUNNABLE\n    at learn.jvm.CPU.lambda$main$0(CPU.java:13)\n    at learn.jvm.CPU$$Lambda$1/500977346.run(Unknown Source)\n    at java.lang.Thread.run(Thread.java:748)\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h2 id=\"_3-3-非堆空间导致oom\"> 3.3 非堆空间导致OOM</h2>\n<h3 id=\"_3-3-1-模拟异常\"> 3.3.1 模拟异常</h3>\n<p>启动参数: <code>-XX:MetaspaceSize=120m -XX:MaxMetaspaceSize=120m -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:/Users/liuxin/Github/learn-example/logs/gc.log</code></p>\n<div><pre><code><span>public</span> <span>class</span> <span>MetaspaceOverflowTest</span> <span>{</span>\n\n    <span>/**\n     * 查看元空间配置\n     * java -XX:+PrintFlagsFinal -version | grep Metaspace\n     * 方法区是JVM规范。\n     * - 永久代和元空间是实现\n     * 元空间调优规则:\n     * 1. 最大最小设置成一样大\n     * 防止内存抖动\n     *\n     * @param args -XX:MetaspaceSize=20m\n     *             -XX:MaxMetaspaceSize=20m\n     *             java.lang.OutOfMemoryError-->Metaspace\n     */</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n<span>//        while (true) {</span>\n            <span>Sleeps</span><span>.</span><span>sleep</span><span>(</span><span>0.2</span><span>)</span><span>;</span>\n            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>200</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n                <span>Enhancer</span> enhancer <span>=</span> <span>new</span> <span>Enhancer</span><span>(</span><span>)</span><span>;</span>\n                enhancer<span>.</span><span>setSuperclass</span><span>(</span><span>MetaspaceOverflowTest</span><span>.</span><span>class</span><span>)</span><span>;</span>\n                enhancer<span>.</span><span>setUseCache</span><span>(</span><span>false</span><span>)</span><span>;</span>\n                enhancer<span>.</span><span>setCallback</span><span>(</span><span>new</span> <span>MethodInterceptor</span><span>(</span><span>)</span> <span>{</span>\n                    <span>@Override</span>\n                    <span>public</span> <span>Object</span> <span>intercept</span><span>(</span><span>Object</span> o<span>,</span> <span>Method</span> method<span>,</span> <span>Object</span><span>[</span><span>]</span> objects<span>,</span> <span>MethodProxy</span> methodProxy<span>)</span> <span>throws</span> <span>Throwable</span> <span>{</span>\n                        <span>return</span> methodProxy<span>.</span><span>invokeSuper</span><span>(</span>objects<span>,</span> args<span>)</span><span>;</span>\n                    <span>}</span>\n                <span>}</span><span>)</span><span>;</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"create InstanceKlass...\"</span><span>)</span><span>;</span>\n                enhancer<span>.</span><span>create</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n<span>//        }</span>\n        <span>while</span> <span>(</span><span>true</span><span>)</span><span>;</span>\n        <span>//  java.lang.OutOfMemoryError-->Metaspace</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><h3 id=\"_3-3-2-现象\"> 3.3.2 现象</h3>\n<p>当你收到运维告警,或者是明显感觉到系统吞吐量下降,甚至会有oom异常的时候,首先先去看下 GC日志，找到GC的原因。下面看下非堆空间溢出导致的GC日志,并配上前面的GC日志学习。来\n排查下问题。</p>\n<div><pre><code>CommandLine flags: -XX:CompressedClassSpaceSize=12582912 -XX:InitialHeapSize=268435456 -XX:MaxHeapSize=4294967296 -XX:MaxMetaspaceSize=20971520 -XX:MetaspaceSize=20971520 -XX:+PrintGC -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC \n2022-06-20T18:12:26.411-0800: 1.749: [GC (Allocation Failure) [PSYoungGen: 65536K-&gt;3006K(76288K)] 65536K-&gt;3006K(251392K), 0.0233877 secs] [Times: user=0.06 sys=0.02, real=0.02 secs] \n2022-06-20T18:12:26.960-0800: 2.298: [GC (Allocation Failure) [PSYoungGen: 68542K-&gt;3264K(141824K)] 68542K-&gt;3272K(316928K), 0.0194187 secs] [Times: user=0.08 sys=0.02, real=0.02 secs] \n2022-06-20T18:12:27.824-0800: 3.162: `[GC (Allocation Failure)` [PSYoungGen: 134336K-&gt;5264K(141824K)] 134344K-&gt;5280K(316928K), 0.0145565 secs] [Times: user=0.06 sys=0.02, real=0.01 secs] \n2022-06-20T18:12:28.526-0800: 3.864: [GC (Allocation Failure) [PSYoungGen: 136336K-&gt;6928K(272896K)] 136352K-&gt;6952K(448000K), 0.0198281 secs] [Times: user=0.09 sys=0.03, real=0.02 secs] \n2022-06-20T18:12:29.252-0800: 4.590: [GC (Metadata GC Threshold) [PSYoungGen: 187304K-&gt;8848K(272896K)] 187328K-&gt;8880K(448000K), 0.0217320 secs] [Times: user=0.10 sys=0.02, real=0.02 secs] \n2022-06-20T18:12:29.274-0800: 4.612: [Full GC (Metadata GC Threshold) [PSYoungGen: 8848K-&gt;0K(272896K)] [ParOldGen: 32K-&gt;8685K(86016K)] 8880K-&gt;8685K(358912K), [Metaspace: 20088K-&gt;20088K(1069056K)], 0.0245986 secs] [Times: user=0.10 sys=0.01, real=0.02 secs] \n2022-06-20T18:12:29.299-0800: 4.637: [GC (Last ditch collection) [PSYoungGen: 0K-&gt;0K(476160K)] 8685K-&gt;8685K(562176K), 0.0005319 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] \n2022-06-20T18:12:29.300-0800: 4.638: [Full GC (Last ditch collection) [PSYoungGen: 0K-&gt;0K(476160K)] [ParOldGen: 8685K-&gt;3731K(155648K)] 8685K-&gt;3731K(631808K), [Metaspace: 20088K-&gt;20088K(1069056K)], 0.0187273 secs] [Times: user=0.07 sys=0.01, real=0.01 secs] \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>从面的GC日志中我们能找到些GC原因,通过前面的学习。我们可以判断出来。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1655720314000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>属于非堆空间造成的OOM。</p>\n<h3 id=\"_3-3-3-解决方案\"> 3.3.3 解决方案</h3>\n<ol>\n<li>排查看应用中是否有动态创建Class的地方</li>\n<li>添加元空间大小(如果应用配置限制元空间大小,还出现了这样的问题,一般一定是程序中有bug导致)</li>\n</ol>\n",
      "image": "https://img.springlearn.cn/blog/learn_1654183539000.png",
      "date_published": "2022-05-29T13:46:15.000Z",
      "date_modified": "2022-07-09T04:36:00.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "JVM内存模型",
      "url": "https://java.springlearn.cn/learn/project/jvm/JVM/",
      "id": "https://java.springlearn.cn/learn/project/jvm/JVM/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/learn_1654432506000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>我们在学习JVM的内存管理的时候,我们的思维要跳出Java的局限。我们要这么理解。我们写的Java代码，是运行在JVM上的。\n如果让你来实现JVM那么。你会怎么处理呢?</p>\n<ol>\n<li>什么是公共部分,什么是私有部分?</li>\n</ol>\n<ul>\n<li>公共部分(堆heap)\n<ul>\n<li>Class字节码是公共的,是共享的,所有线程都要认识字节码。</li>\n<li>new的对象是公共的,也是共享的,所有线程要都能认识这些实例对象,能读取到实例的数据。</li>\n</ul>\n</li>\n<li>私有部分 (栈stock)\n<ul>\n<li>Java中每个线程的执行中的代码，及代码中的局部变量等信息是私有的。每个线程之间都要维护一份。</li>\n<li>JVM虚拟栈和本地方法栈。</li>\n<li>代码是怎么执行的,当然是一行一行执行。那么这一行一行的代码是放在哪里的呢? 是放在栈里面的。Java代码是在JVM来执行的。\n所以这个栈，我们称为JVM虚拟栈。</li>\n<li>JVM中有些方法是调用其他语言实现的, 会使用本地方法栈。</li>\n<li>那么谁来读取栈里面的数据,来出栈执行呢? 这叫做PC寄存区。</li>\n</ul>\n</li>\n</ul>\n<ol start=\"2\">\n<li>\n<p>这些区域的内存是如何划分的呢?</p>\n</li>\n<li>\n<p>传说中的GC的内存回收策略?</p>\n</li>\n</ol>\n<p>https://arthas.gitee.io/jad.html jad命令</p>\n<p>打开arthas 找到类 <code>[arthas@87476]$ sc sun.reflect.GeneratedMethodAccessor*</code> 扫描动态生成的类。</p>\n<p>反编译看下反射类中的代码</p>\n<p>元空间使用 https://xiaogenban1993.github.io/20.04/%E7%BB%BC%E8%BF%B0_%E5%86%85%E5%AD%98.html</p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1654432506000.png",
      "date_published": "2022-06-16T13:10:16.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "HTTP协议使用示例",
      "url": "https://java.springlearn.cn/learn/project/mojito/HTTP%E5%8D%8F%E8%AE%AE%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/",
      "id": "https://java.springlearn.cn/learn/project/mojito/HTTP%E5%8D%8F%E8%AE%AE%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/",
      "content_html": "<h1 id=\"mojito-framework\"> Mojito Framework</h1>\n<p><strong>使用示例</strong>: <code>com.hanframework.mojito.config.HttpInstallerTest</code></p>\n<h2 id=\"一、构建一个非阻塞http服务端\"> 一、构建一个非阻塞HTTP服务端</h2>\n<p><code>Installer</code> 可以轻松构建HTTP服务端,只要编写 <code>BusinessHandler</code> 服务端业务处理器即可。</p>\n<ul>\n<li>startAsync 非阻塞构建</li>\n<li>start 阻塞构建</li>\n</ul>\n<div><pre><code>    <span>/**\n     * 构建http服务端\n     */</span>\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>testHttpServer</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n\n        <span>Installer</span><span>.</span><span>httpServer</span><span>(</span><span>(</span>channel<span>,</span> request<span>)</span> <span>-></span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"请求地址:\"</span> <span>+</span> request<span>.</span><span>getRequestURI</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"请求头\"</span> <span>+</span> request<span>.</span><span>getHeaders</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"请求参数:\"</span> <span>+</span> request<span>.</span><span>getRequestParams</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"请求body:\"</span> <span>+</span> request<span>.</span><span>getBody</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>return</span> <span>HttpResponseFacade</span><span>.</span><span>HTML</span><span>(</span><span>\"&lt;h1>Hello&lt;/h1>\"</span><span>)</span><span>;</span>\n        <span>}</span><span>)</span><span>.</span><span>startAsync</span><span>(</span><span>8080</span><span>)</span><span>;</span>\n\n        <span>testHttpClient</span><span>(</span><span>)</span><span>;</span>\n\n        <span>okHttpClientTest</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h2 id=\"二、构建http客户端\"> 二、构建HTTP客户端</h2>\n<h3 id=\"_1-使用第三方包构建客户端\"> 1. 使用第三方包构建客户端</h3>\n<p>前面说了，HTTP是基于标准的HTTP协议,所以市面上的HttpClient都是支持的。如下使用 <code>OkHttpClient</code> 构建一个GET请求。</p>\n<div><pre><code>    <span>private</span> <span>void</span> <span>okHttpClientTest</span><span>(</span><span>)</span> <span>{</span>\n        <span>OkHttpClient</span> okHttpClient <span>=</span> <span>new</span> <span>OkHttpClient</span><span>(</span><span>)</span><span>;</span>\n        <span>Request</span> request <span>=</span> <span>new</span> <span>Builder</span><span>(</span><span>)</span><span>.</span><span>url</span><span>(</span><span>\"http://127.0.0.1:8080\"</span><span>)</span><span>.</span><span>get</span><span>(</span><span>)</span><span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>\n        <span>try</span> <span>(</span><span>Response</span> response <span>=</span> okHttpClient<span>.</span><span>newCall</span><span>(</span>request<span>)</span><span>.</span><span>execute</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n            <span>if</span> <span>(</span><span>!</span>response<span>.</span><span>isSuccessful</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n                <span>// ... handle failed request</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"发送失败\"</span><span>)</span><span>;</span>\n            <span>}</span> <span>else</span> <span>{</span>\n                <span>String</span> responseBody <span>=</span> response<span>.</span><span>body</span><span>(</span><span>)</span><span>.</span><span>string</span><span>(</span><span>)</span><span>;</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"OkHttpClient处理返回:\"</span> <span>+</span> responseBody<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>IOException</span> e<span>)</span> <span>{</span>\n            <span>// ... handle IO exception</span>\n        <span>}</span>\n    <span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id=\"_2-使用框架构建客户端\"> 2. 使用框架构建客户端</h3>\n<p>因为HTTP默认的请求类是 <code>HttpRequestFacade</code> 所以必须使用 <code>HttpRequestBuilder</code> 来进行构建请求。</p>\n<ul>\n<li>connect 建立连接</li>\n<li>close   关闭连接</li>\n</ul>\n<p><strong>注意:</strong>\nhttp数据无状态协议,如果要保持连接要在请求头中指定。\n<code>addHeader(HttpHeaders.Names.CONNECTION, HttpHeaders.Values.KEEP_ALIVE)</code></p>\n<div><pre><code>    <span>/**\n     * 支持长连接\n     *\n     * @throws Exception 异常\n     */</span>\n    <span>private</span> <span>void</span> <span>testHttpClient</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>Client</span><span><span>&lt;</span><span>HttpRequestFacade</span><span>,</span> <span>HttpResponseFacade</span><span>></span></span> httpClient <span>=</span> <span>Installer</span><span>.</span><span>httpClient</span><span>(</span><span>)</span><span>;</span>\n        httpClient<span>.</span><span>connect</span><span>(</span><span>\"127.0.0.1\"</span><span>,</span> <span>8080</span><span>)</span><span>;</span>\n        <span>URI</span> uri <span>=</span> <span>new</span> <span>URI</span><span>(</span><span>\"/user/get\"</span><span>)</span><span>;</span>\n        <span>HttpRequestBuilder</span> httpRequestBuilder <span>=</span> <span>new</span> <span>HttpRequestBuilder</span><span>(</span><span>)</span>\n                <span>.</span><span>GET</span><span>(</span>uri<span>)</span>\n                <span>//设置长连接</span>\n                <span>.</span><span>addHeader</span><span>(</span><span>HttpHeaders<span>.</span>Names</span><span>.</span>CONNECTION<span>,</span> <span>HttpHeaders<span>.</span>Values</span><span>.</span>KEEP_ALIVE<span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>10</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            <span>HttpRequestFacade</span> httpRequestFacade <span>=</span> httpRequestBuilder<span>.</span><span>wrapBuild</span><span>(</span><span>)</span><span>;</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"request-id-request-\"</span> <span>+</span> i <span>+</span> <span>\"-\"</span> <span>+</span> httpRequestFacade<span>.</span><span>getId</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>MojitoFuture</span><span><span>&lt;</span><span>HttpResponseFacade</span><span>></span></span> httpResponseFacadeMojitoFuture <span>=</span> httpClient<span>.</span><span>sendAsync</span><span>(</span>httpRequestFacade<span>)</span><span>;</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"request-id-response-\"</span> <span>+</span> i <span>+</span> <span>\"-\"</span> <span>+</span> httpResponseFacadeMojitoFuture<span>.</span><span>get</span><span>(</span><span>)</span><span>.</span><span>getId</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n        httpClient<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div>",
      "date_published": "2022-08-22T01:35:49.000Z",
      "date_modified": "2022-08-22T01:35:49.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "mojito"
      ]
    },
    {
      "title": "Mojito介绍",
      "url": "https://java.springlearn.cn/learn/project/mojito/",
      "id": "https://java.springlearn.cn/learn/project/mojito/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/dd74eb95dc1ea6c3d0a5ea341f2f62cf.png\" alt=\"\" loading=\"lazy\"></p>\n<p><a href=\"https://mojito.springlearn.cn\" target=\"_blank\" rel=\"noopener noreferrer\">Mojito Framework</a></p>\n<p>名字以周杰伦新专辑《Mojito》命名。</p>\n<h3 id=\"一、为什么要写这个项目-🥳\"> 一、为什么要写这个项目？🥳</h3>\n<h4 id=\"原因1\"> 原因1</h4>\n<p>其实小编个人,比较热衷于造轮子。在造轮子的过程中，设计到的通信一直都是一个问题，在SpringBoot的环境下，不得不引入<code>actuator</code>模块,进行端点构建。\n虽然SpringBoot升级到2版本之后<a href=\"https://blog.springlearn.cn/posts/40046/\" target=\"_blank\" rel=\"noopener noreferrer\">WebEndpoint</a>会更加方便,但是感觉还是比较复杂,以使我在关于业务逻辑的同时，还要去适配\nWebEndpoint的编程方式。于是就有了,构建一个简单方便的通信层框架。因为Java的Socket编程API不够友好,所以小编在Socket编程上选择Netty进行封装。</p>\n<h4 id=\"原因2\"> 原因2</h4>\n<p>作为开发者,无论我们写什么业务,最终都会通过web接口暴露进行通信。传统的方式是我们引入一个\nweb容器,比如tomcat、jboss等等。</p>\n<p>在分布式环境下，我们使用到的通信框架，如dubbo、hsf、springcloud之类也离不开通信。这些是已经造好的轮子,但是我只需要轮子中的⛓链条,只要通信层。所以就将通信层\n给抽离出来，并提供更加简单的API.</p>\n<h3 id=\"二、主要运用在什么地方-🚀\"> 二、主要运用在什么地方？🚀</h3>\n<p>mojito的定位是通信层框架,其本质是基于Netty进行二次封装,提供更加简单的API,方便开发者进行调用。\n如果你要写一个通信类的组件，但是又不希望引入web容器，或者rpc之类的框架。此时mojito就是最佳选择,因为它提供非常简单API可以快速的构建通信模块,代码量缺只有一点点的样子。当然如果你对Netty比较熟悉,也可以直接使用Netty进行开发。</p>\n<div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>serverTest</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>Mojito</span><span>.</span><span>server</span><span>(</span><span>RpcUserRequest</span><span>.</span><span>class</span><span>,</span> <span>RpcUserResponse</span><span>.</span><span>class</span><span>)</span>\n                <span>//这里接受客户端的请求,并返回一个相应</span>\n                <span>.</span><span>serverHandler</span><span>(</span><span>(</span>channel<span>,</span> rpcRequest<span>)</span> <span>-></span> <span>new</span> <span>RpcUserResponse</span><span>(</span><span>\"服务端返回: \"</span> <span>+</span> rpcRequest<span>.</span>message<span>)</span><span>)</span>\n                <span>.</span><span>create</span><span>(</span><span>)</span>\n                <span>.</span><span>start</span><span>(</span><span>12306</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div>",
      "image": "https://img.springlearn.cn/blog/dd74eb95dc1ea6c3d0a5ea341f2f62cf.png",
      "date_published": "2022-08-22T01:35:49.000Z",
      "date_modified": "2022-08-22T01:35:49.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "mojito"
      ]
    },
    {
      "title": "RPC协议使用示例",
      "url": "https://java.springlearn.cn/learn/project/mojito/RPC%E5%8D%8F%E8%AE%AE%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/",
      "id": "https://java.springlearn.cn/learn/project/mojito/RPC%E5%8D%8F%E8%AE%AE%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/",
      "content_html": "<p>Welcome to the mojito wiki!</p>\n<h1 id=\"rpc协议使用示例\"> RPC协议使用示例</h1>\n<p><strong>使用示例</strong>: <code>com.hanframework.mojito.config.Installer2Test</code></p>\n<h2 id=\"一、构件一个rpc协议的服务端\"> 一、构件一个RPC协议的服务端</h2>\n<p><code>Installer</code> 可以轻松构建服务端,只要编写 <code>BusinessHandler</code> 服务端业务处理器即可。</p>\n<ul>\n<li>startAsync 非阻塞构建</li>\n<li>start 阻塞构建</li>\n</ul>\n<div><pre><code>\n   <span>@Test</span>\n    <span>public</span> <span>void</span> <span>serverTest</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>Installer</span><span>.</span><span>server</span><span>(</span><span>RpcUserRequest</span><span>.</span><span>class</span><span>,</span> <span>RpcUserResponse</span><span>.</span><span>class</span><span>)</span>\n                <span>//这里接受客户端的请求,并返回一个相应</span>\n                <span>.</span><span>serverHandler</span><span>(</span><span>(</span>channel<span>,</span> rpcRequest<span>)</span> <span>-></span> <span>new</span> <span>RpcUserResponse</span><span>(</span><span>\"服务端返回: \"</span> <span>+</span> rpcRequest<span>.</span>message<span>)</span><span>)</span>\n                <span>.</span><span>create</span><span>(</span><span>)</span>\n                <span>.</span><span>startAsync</span><span>(</span><span>12306</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id=\"二、构建http客户端\"> 二、构建HTTP客户端</h2>\n<p>同样使用 <code>Installer</code> 快速构建客户端</p>\n<div><pre><code>    <span>public</span> <span>void</span> <span>clientTest</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>Client</span><span><span>&lt;</span><span>RpcUserRequest</span><span>,</span> <span>RpcUserResponse</span><span>></span></span> client <span>=</span> <span>Installer</span><span>.</span><span>client</span><span>(</span><span>RpcUserRequest</span><span>.</span><span>class</span><span>,</span> <span>RpcUserResponse</span><span>.</span><span>class</span><span>)</span>\n                <span>.</span><span>connect</span><span>(</span><span>\"127.0.0.1\"</span><span>,</span> <span>12306</span><span>)</span><span>;</span>\n        <span>MojitoFuture</span><span><span>&lt;</span><span>RpcUserResponse</span><span>></span></span> mojitoFuture <span>=</span> client<span>.</span><span>sendAsync</span><span>(</span><span>new</span> <span>RpcUserRequest</span><span>(</span><span>\"关注微信公众号:程序猿升级课\"</span><span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"返回结果:\"</span> <span>+</span> mojitoFuture<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div>",
      "date_published": "2022-08-22T01:35:49.000Z",
      "date_modified": "2022-08-22T01:35:49.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "mojito"
      ]
    },
    {
      "title": "JVM参数配置说明",
      "url": "https://java.springlearn.cn/learn/project/jvm/JVM%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/",
      "id": "https://java.springlearn.cn/learn/project/jvm/JVM%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/",
      "content_html": "<p><a href=\"https://help.aliyun.com/document_detail/193455.html\" target=\"_blank\" rel=\"noopener noreferrer\">参考地址</a></p>\n<h2 id=\"一、内存容量调优参数\"> 一、内存容量调优参数</h2>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1654141304000.png\" alt=\"\" loading=\"lazy\"></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">配置参数</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:left\">示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>-Xmx</code></td>\n<td style=\"text-align:left\">设置最大堆大小。</td>\n<td style=\"text-align:left\"><code>-Xmx3550m</code>，设置JVM最大可用内存为3550 MB。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-Xms</code></td>\n<td style=\"text-align:left\">设置JVM初始内存。</td>\n<td style=\"text-align:left\"><code>-Xms3550m</code>，设置JVM初始内存为3550 MB。此值建议与<code>-Xmx</code>相同，避免每次垃圾回收完成后JVM重新分配内存。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-Xmn2g</code></td>\n<td style=\"text-align:left\">设置年轻代大小。</td>\n<td style=\"text-align:left\"><code>-Xmn2g</code>，设置年轻代大小为2 GB。整个JVM内存大小=年轻代大小+年老代大小+持久代大小。持久代一般固定大小为64 MB，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-Xss</code></td>\n<td style=\"text-align:left\">设置线程的栈大小。</td>\n<td style=\"text-align:left\"><code>-Xss128k</code>，设置每个线程的栈大小为128 KB。<strong>说明</strong> JDK 5.0版本以后每个线程栈大小为1 MB，JDK 5.0以前版本每个线程栈大小为256 KB。请依据应用的线程所需内存大小进行调整。在相同物理内存下，减小该值可以生成更多的线程。但是操作系统对一个进程内的线程个数有一定的限制，无法无限生成，一般在3000个~5000个。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-XX:NewRatio=n</code></td>\n<td style=\"text-align:left\">设置年轻代和年老代的比值。</td>\n<td style=\"text-align:left\"><code>-XX:NewRatio=4</code>，设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。如果设置为4，那么年轻代与年老代所占比值为1:4，年轻代占整个堆栈的1/5。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-XX:SurvivorRatio=n</code></td>\n<td style=\"text-align:left\">年轻代中Eden区与两个Survivor区的比值。</td>\n<td style=\"text-align:left\"><code>-XX:SurvivorRatio=4</code>，设置年轻代中Eden区与Survivor区的大小比值。如果设置为4，那么两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-XX:MaxPermSize=n</code></td>\n<td style=\"text-align:left\">设置持久代大小。</td>\n<td style=\"text-align:left\"><code>-XX:MaxPermSize=16m</code>，设置持久代大小为16 MB。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-XX:MaxTenuringThreshold=n</code></td>\n<td style=\"text-align:left\">设置垃圾最大年龄。</td>\n<td style=\"text-align:left\"><code>-XX:MaxTenuringThreshold=0</code>，设置垃圾最大年龄。如果设置为0，那么年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，提高了效率。如果将此值设置为较大值，那么年轻代对象会在Survivor区进行多次复制，增加了对象在年轻代的存活时间，增加在年轻代即被回收的概率。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"二、gc回收调优\"> 二、GC回收调优</h2>\n<h2 id=\"_2-1-吞吐量优先的gc典型配置参数\"> 2.1 吞吐量优先的GC典型配置参数</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">配置参数</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:left\">示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>-XX:+UseParallelGC</code></td>\n<td style=\"text-align:left\">选择垃圾收集器为并行收集器。</td>\n<td style=\"text-align:left\"><code>-Xmx3800m -Xms3800m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20</code>，<code>-XX:+UseParallelGC</code>此配置仅对年轻代有效，即在示例配置下，年轻代使用并发收集，而年老代仍旧使用串行收集。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-XX:ParallelGCThreads</code></td>\n<td style=\"text-align:left\">配置并行收集器的线程数，即同时多少个线程一起进行垃圾回收。<strong>说明</strong> 此值建议配置与处理器数目相等。</td>\n<td style=\"text-align:left\"><code>-Xmx3800m -Xms3800m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20</code>，<code>-XX:ParallelGCThreads=20</code>表示配置并行收集器的线程数为20个。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-XX:+UseParallelOldGC</code></td>\n<td style=\"text-align:left\">配置年老代垃圾收集方式为并行收集。<strong>说明</strong> JDK 6.0支持对年老代并行收集。</td>\n<td style=\"text-align:left\"><code>-Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20 -XX:+UseParallelOldGC</code>，<code>-XX:+UseParallelOldGC</code>表示对年老代进行并行收集。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-XX:MaxGCPauseMillis</code></td>\n<td style=\"text-align:left\">设置每次年轻代垃圾回收的最长时间，如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值。</td>\n<td style=\"text-align:left\"><code>-Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:MaxGCPauseMillis=100</code>，<code>-XX:MaxGCPauseMillis=100</code>设置每次年轻代垃圾回收的最长时间为100 ms。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-XX:+UseAdaptiveSizePolicy</code></td>\n<td style=\"text-align:left\">设置此选项后，并行收集器自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低响应时该间或者收集频率，该值建议使用并行收集器时，并且一直打开。</td>\n<td style=\"text-align:left\"><code>-Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:MaxGCPauseMillis=100 -XX:+UseAdaptiveSizePolicy</code></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"_2-2-响应时间优先的gc典型配置参数\"> 2.2 响应时间优先的GC典型配置参数</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">配置参数</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:left\">示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>-XX:+UseConcMarkSweepGC</code></td>\n<td style=\"text-align:left\">设置年老代为并发收集。<strong>说明</strong> 配置了<code>-XX:+UseConcMarkSweepGC</code>，建议年轻代大小使用<code>-Xmn</code>设置。</td>\n<td style=\"text-align:left\"><code>-Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:ParallelGCThreads=20 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-XX:+UseParNewGC</code></td>\n<td style=\"text-align:left\">设置年轻代为并行收集。可与CMS收集同时使用。JDK 5.0以上版本，JVM根据系统配置自行设置，无需再设置此值。</td>\n<td style=\"text-align:left\"><code>-Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:ParallelGCThreads=20 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-XX:CMSFullGCsBeforeCompaction</code></td>\n<td style=\"text-align:left\">由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩、整理。</td>\n<td style=\"text-align:left\"><code>-Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseConcMarkSweepGC -XX:CMSFullGCsBeforeCompaction=5 -XX:+UseCMSCompactAtFullCollection</code>，<code>-XX:CMSFullGCsBeforeCompaction=5</code>，表示运行GC5次后对内存空间进行压缩、整理。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-XX:+UseCMSCompactAtFullCollection</code></td>\n<td style=\"text-align:left\">打开对年老代的压缩。<strong>说明</strong> 该值可能会影响性能，但是可以消除碎片。</td>\n<td style=\"text-align:left\"><code>-Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseConcMarkSweepGC -XX:CMSFullGCsBeforeCompaction=5 -XX:+UseCMSCompactAtFullCollection</code></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"三、gc辅助参数\"> 三、GC辅助参数</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">配置参数</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>-XX:+PrintGC</code></td>\n<td style=\"text-align:left\">用于输出GC日志。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-XX:+PrintGCDetails</code></td>\n<td style=\"text-align:left\">用于输出GC日志。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-XX:+PrintGCTimeStamps</code></td>\n<td style=\"text-align:left\">用于输出GC时间戳（JVM启动到当前日期的总时长的时间戳形式）。示例如下：<code>0.855: [GC (Allocation Failure) [PSYoungGen: 33280K-&gt;5118K(38400K)] 33280K-&gt;5663K(125952K), 0.0067629 secs] [Times: user=0.01 sys=0.01, real=0.00 secs]</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-XX:+PrintGCDateStamps</code></td>\n<td style=\"text-align:left\">用于输出GC时间戳（日期形式）。示例如下：<code>2022-01-27T16:22:20.885+0800: 0.299: [GC pause (G1 Evacuation Pause) (young), 0.0036685 secs]</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-XX:+PrintHeapAtGC</code></td>\n<td style=\"text-align:left\">在进行GC前后打印出堆的信息。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>-Xloggc:../logs/gc.log</code></td>\n<td style=\"text-align:left\">日志文件的输出路径。</td>\n</tr>\n</tbody>\n</table>\n",
      "image": "https://img.springlearn.cn/blog/learn_1654141304000.png",
      "date_published": "2022-06-16T13:10:16.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Spring声明式事务的实现方案?",
      "url": "https://java.springlearn.cn/learn/project/mojito/%E5%8D%8F%E8%AE%AE/",
      "id": "https://java.springlearn.cn/learn/project/mojito/%E5%8D%8F%E8%AE%AE/",
      "content_html": "<h1 id=\"protocol协议篇设计思路\"> Protocol协议篇设计思路</h1>\n<h2 id=\"一、概述\"> 一、概述</h2>\n<p>协议即约定,最简单理解就是服务端按照什么样的规则来解析TCP通道传输来的二进制数据。</p>\n<p>框架中协议提供了HTTP/HTTPS/MOJITO三种。其中HTTP/HTTPS准确来说其实就是一种,标准的HTTP协议。如果采用HTTP协议的话，不仅可以使用框架生成的Client同时也可以使用\n市面上任何的HttpClient框架。</p>\n<p>eg:</p>\n<ul>\n<li>OkHttp</li>\n<li>HttpClient</li>\n<li>Unirest</li>\n</ul>\n<h2 id=\"二、设计\"> 二、设计</h2>\n<p>框架中协议的接口类是 <code>Protocol&lt;R extends RpcProtocolHeader, V extends RpcProtocolHeader&gt;</code>。</p>\n<ul>\n<li>泛型 <code>R</code> 为请求数据模型</li>\n<li>泛型 <code>V</code> 为响应数据模型</li>\n</ul>\n<p><code>Protocol</code> 是一个比较核心的类贯穿始终。因为核心的组件都放在了 <code>Protocol</code> 类中，这样的设计目的是为了让框架看起来简单。主要的思想借鉴与 <code>Mybatis</code> 中的 <code>Configuration</code> 所有的核心配置都放在其中，让人一看便懂,快速了解架构,进行二次开发。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1600953756000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_1-通道编码器\"> 1. 通道编码器</h3>\n<p>面向TCP编程,网络中数据都是二进制数据。客户端会将Java数据模型,按照一定的格式转换成二进制数据经过TCP协议传输给服务端。</p>\n<h3 id=\"_2-通道解码器\"> 2. 通道解码器</h3>\n<p>服务端根据约定的格式(可以理解这个约定就是协议),通过通道解码器将二进制数据重新转换成Java数据模型。</p>\n<h3 id=\"_3-api交换器\"> 3. API交换器</h3>\n<p>框架底层是基于 <code>Netty</code> 进行开发, <code>ExchangeChannelHandler</code> 负责将 <code>Netty</code> 的 <code>API</code> 转换成框架 <code>API</code> ,目的是对原生 <code>Netty</code> 的网络通道 <code>Channel</code> 进行增强。同时降低学习成本。</p>\n<h3 id=\"_4-服务端处理器\"> 4. 服务端处理器</h3>\n<p>服务端是对客户端传来的数据进行处理的, 这里是由开发者来编程的业务处理器。</p>\n<h3 id=\"_5-客户端处理器\"> 5. 客户端处理器</h3>\n<p>通信的连接默认都是长连接，如何处理长连接中数据交互所对应的关系，主要就是在这里实现的,框架内置处理器。在发送数据时候会在本地保存一个发送的唯一码，服务端响应时候会告诉我们\n对应的唯一码，从而完成异步通知。</p>\n<p><strong>长连接通道中会有很多数据包在其中传输,如果不给每个数据包一个唯一的标志，那么客户端在接受到服务端的响应时候就不知道对应的是那个发送请求。</strong></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1600954759000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>解决办法: 给每个数据包加上唯一的标识头，当客户端收到服务端响应时候就知道是对应的那个请求了</strong></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1600954859000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>这个标志头在框架中就是 <code>RpcProtocolHeader</code>。 其组成部分: 协议类型(byte) + 序列化类型(byte) + 请求类型(byte) + id(String)</p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1600953756000.png",
      "date_published": "2022-08-22T01:35:49.000Z",
      "date_modified": "2022-08-22T01:35:49.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "SpringBoot"
      ]
    },
    {
      "title": "第01篇:手写JavaRPC框架之思路分析",
      "url": "https://java.springlearn.cn/learn/project/mojito/%E7%AC%AC01%E7%AF%87:%E6%89%8B%E5%86%99JavaRPC%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90/",
      "id": "https://java.springlearn.cn/learn/project/mojito/%E7%AC%AC01%E7%AF%87:%E6%89%8B%E5%86%99JavaRPC%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/8d93a4aaf770ccc367e4bcc40513ff1b.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者</strong>: 西魏陶渊明</p>\n<p><strong>博客</strong>: <a href=\"https://blog.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.springlearn.cn/</a></p>\n<blockquote>\n<p>天下代码一大抄, 抄来抄去有提高, 看你会抄不会抄！</p>\n</blockquote>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/10e3b1ba78ed2cd6afb33928df91a52f.gif\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"一、前言\"> 一、前言</h2>\n<p>如果不是因为热爱，我不会这样；如果不是为了，涨点粉丝，我不会这样；\n如果不是为了几两散碎银子，我更不会这样。</p>\n<p>以前的文章开场太过严肃，太过专业。就像大学老师上课，只知道讲课。不知道互动。这样\n效果太差，写的没意思，读者更是没意思。大数据分析还以为你是抄的，还不给你推荐热门 😭。</p>\n<p>不然就改变一下风格吧，从本系列文章开始，小编就要放飞 ✈️ 自我，随心 ❤️ 而动。希望在分享，总结自己掌握的知识点的同时，能给各位客官带来一点小小的收获。小编尽量全力输出干货，如果看完感觉还行的话，希望能多多关注。你的关注，就是我进步的最大动力。如果看完，感觉就这? 可以留言讨论。接受各位看官的批评和意见。共同学习共同进步。</p>\n<h2 id=\"二、目标\"> 二、目标</h2>\n<p>本系列文章的总体目标是从零实现一个RPC框架，我们将从TCP通信协议开始，\n一步一步实操，将socket 二进制数据流一步一步变成Java可以认识的数据类型，\n从而最终实现RPC远程通信，并可以集成在Spring中,同时也可以支持SpringBoot的自动化配置。最终我们会将项目发布到全球Maven仓库, 让大家都可以下载学习。</p>\n<p>本系列文章主要知识点以思维导图的方式，展示在下图=面，内容只会多不会少。干货较多，对于初级的同学可以收藏起来慢慢看。毕竟一口也吃不了一个胖子。但是不能没有信心。</p>\n<p>正如小编的口头禅: 写代码和写文章是一样一样的。</p>\n<p><strong>天下代码一大抄，抄来抄去有提高，看你会抄不会抄。</strong></p>\n<p><img src=\"https://img.springlearn.cn/blog/7bdbd93d0e2d1b9bd0c150e119ae665a.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"三、思路分析\"> 三、思路分析</h2>\n<h2 id=\"_3-1-什么是rpc框架\"> 3.1 什么是RPC框架</h2>\n<p>我们在要写RPC框架，我们先思考下RPC是什么? 白话点就是一个远程通信的工具而已。\n他可以让开发者像调用本地方法一样，方便的调用远程的方法。</p>\n<p>目前市面上的RPC框架主要有下面这些</p>\n<ul>\n<li>dubbo</li>\n<li>grpc</li>\n<li>feign</li>\n</ul>\n<p>可能对于银行和传统国企可能偏爱国产的dubbo框架，可能会涉及到国家安全吧，而对于互联网公司更多的会使用SpringCloud的全家桶。那么不管他们使用的其中的哪一款，其实这些框架都是能做到，让开发者像调用本地方法一样实现远程方法的调用的。</p>\n<p>可以实现远程调用的呢? 答案当然就是利用socket通信了。而socket底层通信\n都是基于tcp/ip协议实现的。所以以上这三款的</p>\n<h2 id=\"_3-2-通信框架的区别\"> 3.2  通信框架的区别</h2>\n<ul>\n<li>dubbo</li>\n<li>grpc</li>\n<li>feign</li>\n</ul>\n<p><strong>共同点:</strong></p>\n<ul>\n<li>都是基于tcp/ip协议来实现通信</li>\n<li>都屏蔽底层通信细节，使开发者只用关心自己的业务即可</li>\n</ul>\n<p><strong>不同点:</strong></p>\n<ul>\n<li>grpc和feign都是基于tcp协议更上层的http协议来实现的</li>\n<li>dubbo是基于tcp协议上自己重新实现了一套自己的规则，而这个规则就是dubbo协议。</li>\n</ul>\n<p>dubbo协议因为是直接基于tcp协议定制的，所以可能性能会更加的好。能实现更多的底层的特性，比如说长连接。而其他两款是基于http协议来进行封装的，正因为它的这个特性，所以只是http客户端都可以进行调用，更适合跨平台，跨语言。因为不管是什么语言，都支持http协议。但是他的性能可能就相对没有dubbo好，综上所述他们各有胜负。现在主要比的就是看谁的生态比较好，谁的周边扩展更加丰富。</p>\n<h2 id=\"_3-3-rpc底层实现\"> 3.3 RPC底层实现</h2>\n<p>前面我们说了，RPC框架是一个，可以让程序猿像调用本地方法一样实现远程方法调用的一个工具。其实这句话就说出了主要的答案。</p>\n<p><img src=\"https://img.springlearn.cn/blog/7f72d53f64e4181913a662abc2b37143.png\" alt=\"远程调用 = 计算机通信屏蔽细节 = 动态代理\" loading=\"lazy\"></p>\n<p>既然知道了他的大概实现，那么其实思路就有了。我们第一步就是使用Java语言来实现底层\n的通信能力建设，然后在这个基础上进行二次封装，最终通过动态代理的形式，将底层通信的细节给屏蔽起来。如此就能实现一个RPC协议了。</p>\n<p>思路就是这个思路。\n<img src=\"https://img.springlearn.cn/blog/e9c48572c567ba6fdd6a5a3fbe603f24.png\" alt=\"\" loading=\"lazy\"></p>\n<p>所以本系列文章的第一部分，就是先完成通信层的建设，使用Java实现一个通用的底层协议，实现通信能力。</p>\n<p><img src=\"https://img.springlearn.cn/blog/07fa03c0a8f866bb365cb43e85b05317.png\" alt=\"\" loading=\"lazy\"></p>\n<p>说着很简单，但是实现通信可没有那么简单哦。接下来我们面临一系列网络通信中的难题。比如说Java的通信API表难用，网络通信中还有黏包拆包等问题。但是没关系，这些坑小编已经踩过了，跟着小编的思路一步一步做。相信事半必能功倍。</p>\n",
      "image": "https://img.springlearn.cn/blog/8d93a4aaf770ccc367e4bcc40513ff1b.png",
      "date_published": "2022-08-22T01:35:49.000Z",
      "date_modified": "2022-08-22T01:35:49.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "mojito"
      ]
    },
    {
      "title": "第02篇:手写JavaRPC框架之设计思路",
      "url": "https://java.springlearn.cn/learn/project/mojito/%E7%AC%AC02%E7%AF%87:%E6%89%8B%E5%86%99JavaRPC%E6%A1%86%E6%9E%B6%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/",
      "id": "https://java.springlearn.cn/learn/project/mojito/%E7%AC%AC02%E7%AF%87:%E6%89%8B%E5%86%99JavaRPC%E6%A1%86%E6%9E%B6%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/",
      "content_html": "<p><img src=\"https://img-blog.csdnimg.cn/img_convert/9f4a43fd785d69552fbe2f0463b3bd72.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p>天下代码一大抄, 抄来抄去有提高, 看你会抄不会抄！</p>\n</blockquote>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/10e3b1ba78ed2cd6afb33928df91a52f.gif\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"一、前言\"> 一、前言</h2>\n<p>隔壁老李又在喷我了: &quot;完犊子了，小编这绝对是为了骗粉丝，而水的一篇文章，到了第二篇竟然还没有开始写代码，又是一篇纯概念文章&quot;。</p>\n<p><strong>我也想写代码，但是在没有讲清楚思路之前，一定不要上来就蛮干</strong>，不然就毫无设计可言了。小编向各位观众老爷保证，下一篇文章绝对上代码。</p>\n<p>本篇文章非常重要，这是我们本系列文章中的重中之重，本篇文章的主要内容就是设计我们自己的通信协议及架构，可以这样说如果没有了本篇文章的内容，就不可能实现RPC。因为RPC的最基本要求就是能实现远程通信。本篇文章是讲述通信层的设计思路，下一篇就是实战的编写。(ps: 其实下一篇比较好写，因为代码我早就写完了嘻嘻，而这一篇竟然酝酿了一周还写的...不忍直视)</p>\n<h2 id=\"二、目标\"> 二、目标</h2>\n<p>本篇文章主要会围绕以下三方面展开叙述，希望在通读全篇后，大家都能在脑子中形成对这三个方面的认识，因为下面的三个方面是通信层搭建的主要指导思想。</p>\n<p><img src=\"https://img.springlearn.cn/blog/84baeb78cd51f010734381a55106c4d5.png\" alt=\"\" loading=\"lazy\"></p>\n<ol>\n<li>设计我们自己的通信协议</li>\n<li>确定我们的通信层的架构</li>\n<li>确定我们的工程结构</li>\n</ol>\n<h3 id=\"_2-1-为什么我们要设计自己的通信协议呢\"> 2.1 为什么我们要设计自己的通信协议呢?</h3>\n<p>上一篇我们也说了，实现RPC可以基于http也可以基于tcp。他们各有各的好处，如果是基于http其实我们的挑战就相对比较小一些，因为实现http的协议已经是在太多了，我们只用通过代理进行层层封装即可，而我们之所以要自己实现通信协议就是。</p>\n<p><img src=\"https://img.springlearn.cn/blog/93db862c16863e2929f8f3fdef2f4fbf.png\" alt=\"\" loading=\"lazy\">\n作为Java程序猿还是要对底层通信协议的具体实现有点了解的。如果不了解的话也没关系，你只要知道他是二进制数据就可以了。<strong>我们一步一步通过代码编写将二进制数据转换成我们Java语言能够认识的数据就好了</strong>。如果这个过程你学会了，那么一通百通，http如何实现的其实大概也能知道猜到一点。</p>\n<h3 id=\"_2-2-为什么要讲通信层的架构\"> 2.2 为什么要讲通信层的架构？</h3>\n<p><strong>怎么理解架构？</strong></p>\n<p>作为一个有经验的开发者，都会清楚，我们写代码就如同写文章。好的代码一定是思路清晰的，思路清晰的代码耦合性一定是很少的。我们举一个例子，最近大环境不好，大厂裁员较多，很多小伙伴都要面试吧，就举一个面试的问题，通过这个例子来解释下什么是架构。</p>\n<ul>\n<li>面试官说: 同学做一下自我介绍吧。</li>\n</ul>\n<p>首先我们不能懵啊，如果懵了就说明没有头绪了，这样就容易讲乱，没有头绪在开发过程中的体现就是代码写的杂乱。比如你在介绍家乡的时候突然穿插了一下爱好，而在讲爱好的时候，又穿插的讲了一下家乡。这样就会导致主题不分明，听者会感觉会乱。所以这里我们就需要 <strong>单一职责</strong>。首先定义清楚你的讲话的结构，然后每个结构点就一个职责。</p>\n<p>如下我们设计的面试架构是这些点:</p>\n<p>姓名，家乡，大学，专业，兴趣爱好，单位职称 .</p>\n<p>下面我们只用实现每个点的内容(主题清晰)，最终将他组装成完成的自我介绍回答;</p>\n<div><pre><code><span>// 姓名，家乡，大学，专业，兴趣爱好，单位职称 </span>\n<span>public</span> <span>interface</span> <span>Introduce</span><span>{</span>\n     <span>// 这是一个介绍类,负责介绍自己</span>\n     <span>public</span> <span>void</span> <span>introduce</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n<span>public</span> <span>class</span> <span>XiaoMing</span> <span>implements</span> <span>Introduce</span><span>{</span>\n\n     <span>// 将任务进行拆分,拆分的维度是逻辑顺序,然后抽离出方法,抽离的维度是单一职责。</span>\n     <span>// 这样的好处是工能化,模块化,便于复用。</span>\n     <span>public</span> <span>void</span> <span>introduce</span><span>(</span><span>)</span><span>{</span>\n         <span>sout</span><span>(</span><span>\"我叫小明\"</span><span>)</span><span>;</span>\n         <span>// 主题介绍家乡</span>\n         <span>introduceHometown</span><span>(</span><span>)</span><span>;</span>\n         <span>// 主题介绍学校</span>\n         <span>introduceSchool</span><span>(</span><span>)</span><span>;</span>\n         <span>// 主题介绍专业</span>\n         <span>introduceMajor</span><span>(</span><span>)</span><span>;</span>\n         <span>// 主题介绍兴趣爱好</span>\n         <span>introduceInterest</span><span>(</span><span>)</span><span>;</span>\n         <span>sout</span><span>(</span><span>\"从业xx年,目前在公司的职称是xxx\"</span><span>)</span><span>;</span>\n     <span>}</span>\n     \n    <span>private</span> <span>void</span> <span>introduceHometown</span><span>(</span><span>)</span><span>{</span>\n         <span>sout</span><span>(</span><span>\"我的老家是河南南阳\"</span><span>)</span>\n         <span>sout</span><span>(</span><span>\"我的家乡就坐落在河南南阳邓州市\"</span><span>)</span>\n         <span>sout</span><span>(</span><span>\"邓州市一个美丽的城市,是中国邓姓的发源地\"</span><span>)</span>\n         <span>sout</span><span>(</span><span>\"邓州也是河南境内人口最多的一个县级城市\"</span><span>)</span>\n     <span>}</span>\n     \n     <span>private</span> <span>void</span> <span>introduceSchool</span><span>(</span><span>)</span><span>{</span>\n         <span>sout</span><span>(</span><span>\"我大学是在河南大学\"</span><span>)</span>\n         <span>sout</span><span>(</span>\"河南大学简称河大，是一所位于中国河南省开封市涵盖文、史、哲、经、管、\n         法、理、工、医、农、教育、艺术等<span>12</span>个学科门类的省部共建型综合性公立大学。\"<span>)</span>\n     <span>}</span>\n     \n     <span>private</span> <span>void</span> <span>introduceMajor</span><span>(</span><span>)</span><span>{</span>\n         <span>sout</span><span>(</span><span>\"我的专业是计算机与信息工程\"</span><span>)</span>\n     <span>}</span>\n     \n     <span>private</span> <span>void</span> <span>introduceInterest</span><span>(</span><span>)</span><span>{</span>\n         <span>sout</span><span>(</span><span>\"我的个人爱好是写博客、打游戏、做美食、偶会也会跑跑步\"</span><span>)</span>\n     <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><p>有没有发现单一职责的设计，会很大程度提高我们的代码利用率呢? 我们要的就是这个效果，所以我们再开始编码之前，最好提前定义清楚我们的架构是怎么样的。</p>\n<p>上面的例子，不知道小编有没有给大家解释清楚，但是总归我们的目的，是要在设计的时候就要<strong>明确责任划分，尽可能的单一职责</strong>。尽可能的解耦。</p>\n<blockquote>\n<p>要想设计一个好的框架，首先一定要有一个好的架构设计。这一点我们可以直接参考dubbo的设计架构。</p>\n</blockquote>\n<p><img src=\"https://img-blog.csdnimg.cn/396bb113af4142e68e5ec42641d3ee7d.png\" alt=\"在这里插入图片描述\" loading=\"lazy\">\n上半部分不用看，我们只用看通信层就好了。</p>\n<ul>\n<li>serialize 序列化层，负责将二进制数据转成Java认识的数据类型</li>\n<li>transport 传输层，负责发送和接受数据</li>\n<li>exchange 转换成，通信层和业务逻辑层转换的地方。</li>\n<li>protocol 协议层，告诉serialize用什么协议来encode和decode数据的</li>\n</ul>\n<p>所以说，<strong>天下代码一大抄，抄来抄去有提高，就看你会抄不会抄了</strong>。\n我们的设计就主要参考dubbo来了。</p>\n<h3 id=\"_2-3-工程结构设计\"> 2.3 工程结构设计</h3>\n<p><img src=\"https://img.springlearn.cn/blog/752095b0de45bc72e7b12a88ec4d48e8.png\" alt=\"\" loading=\"lazy\"></p>\n<p>目前市面上的框架基本上都是自己来定制通信层，而通信层基本也不会单独的提供出去。但是本系列小编希望是通信层和业务能分开。通信层可以做RPC也可以利用通信层去实现消息队列或者是web容器。所以因为这个设计，就要求我们的项目能单独的去发布。所以我们整体的项目结构是由三个部分组成的，如下。</p>\n<p><img src=\"https://img.springlearn.cn/blog/e48f78a0091a911b5c8aecec3d528541.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"三、核心知识点\"> 三、核心知识点</h2>\n<h3 id=\"_3-1-通信层协议定义\"> 3.1 通信层协议定义</h3>\n<p><strong>什么是协议呢?</strong></p>\n<p>其实就是规则，我们按照什么样的方式将二进制数据转换成Java对象。</p>\n<p>如下图，我们的一条数据会分为4个部分</p>\n<ol>\n<li>第一部分占用一个字节是协议标记，用来标记是http协议还是自定义协议。</li>\n<li>第二部分占用一个字节是序列化标记，用来确定我们的真实报文使用什么来进行序列化和反序列化。</li>\n<li>第三部分占用四个字节，用来表示数据的字节长度，确定真实报文的长度。</li>\n<li>第四部分长度不固定，是真实的传输数据。最终会通过第二部分将这些二进制数据转换成Java对象。</li>\n</ol>\n<p><img src=\"https://img.springlearn.cn/blog/18634a291755ae51cd4e6ef64b0a8ac8.png\" alt=\"\" loading=\"lazy\">\n以上就是我们定义的数据解析协议，通过上面的规则将二进制数据，转换成Java对象。</p>\n<p><strong>读到这里你有没有一点收获呢?</strong></p>\n<p>有没有发现，其实协议的概念，其实很简单，就是一个规则或者说是约定。能让彼此都互相认识的一个约定。</p>\n<p>在本系列中，我们会自定义一个协议，同时也会兼容支持http协议。如果感兴趣，就跟着小编一起coding吧。</p>\n<h3 id=\"_3-2-通信层架构设计\"> 3.2 通信层架构设计</h3>\n<p>前面说了，我们是站在巨人的肩膀上的，根据dubbo的设计思路和我们的目标，我们也来画一张图。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1600333949000.png\" alt=\"在这里插入图片描述\" loading=\"lazy\">\n我们的最终架构如上图。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">包</th>\n<th style=\"text-align:left\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">serialize</td>\n<td style=\"text-align:left\">序列化协议层,包含了多种序列化协议</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">codec</td>\n<td style=\"text-align:left\">数据解码器和编码器的具体实现层</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">exchange</td>\n<td style=\"text-align:left\">API交换层,业务层API和通信层API交换数据的地方，负责将业务数据转换成二进制数据发送，也负责将二进制数据转换成业务数据返回</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">model</td>\n<td style=\"text-align:left\">基础数据模型</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">business</td>\n<td style=\"text-align:left\">提供给开发者用来实现业务的api</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">api</td>\n<td style=\"text-align:left\">Fluent 风格的api, 这种风格的好处是不需要记住接下来的步骤和方法</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_3-3-工程结构\"> 3.3 工程结构</h3>\n<p><img src=\"https://img.springlearn.cn/blog/752095b0de45bc72e7b12a88ec4d48e8.png\" alt=\"\" loading=\"lazy\"></p>\n<p>为了符合前面我们定的目标，所以我们要有一个大的工程。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">项目名</th>\n<th style=\"text-align:left\">职责</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">mojito-net</td>\n<td style=\"text-align:left\">底层通信模块</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">mojito-rpc</td>\n<td style=\"text-align:left\">rpc模块</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">mojito-spring-boot-starter</td>\n<td style=\"text-align:left\">springboot自动化配置</td>\n</tr>\n</tbody>\n</table>\n<p>由此我们的项目诞生了。下一篇我们就开始手撸代码吧。</p>\n<div><pre><code>.\n├── README.md\n├── mojito-net\n│   ├── pom.xml\n│   └── src\n│       ├── main\n│       │   ├── java\n│       │   └── resources\n│       └── test\n│           └── java\n├── mojito-rpc\n│   ├── pom.xml\n│   └── src\n│       ├── main\n│       │   ├── java\n│       │   └── resources\n│       └── test\n│           └── java\n├── mojito-spring-boot-starter\n│   ├── pom.xml\n│   └── src\n│       ├── main\n│       │   ├── java\n│       │   └── resources\n│       └── test\n│           └── java\n└── pom.xml\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div>",
      "image": "https://img-blog.csdnimg.cn/img_convert/9f4a43fd785d69552fbe2f0463b3bd72.png",
      "date_published": "2022-08-22T01:35:49.000Z",
      "date_modified": "2022-08-22T01:35:49.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "mojito"
      ]
    },
    {
      "title": "第03篇:手写JavaRPC框架之搞定序列化",
      "url": "https://java.springlearn.cn/learn/project/mojito/%E7%AC%AC03%E7%AF%87:%E6%89%8B%E5%86%99JavaRPC%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%90%9E%E5%AE%9A%E5%BA%8F%E5%88%97%E5%8C%96/",
      "id": "https://java.springlearn.cn/learn/project/mojito/%E7%AC%AC03%E7%AF%87:%E6%89%8B%E5%86%99JavaRPC%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%90%9E%E5%AE%9A%E5%BA%8F%E5%88%97%E5%8C%96/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/f18e12cc1d0c57c16e6d6cb258fe746c.png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p>天下代码一大抄, 抄来抄去有提高, 看你会抄不会抄！</p>\n</blockquote>\n<p><img src=\"https://img.springlearn.cn/blog/8f3392b9badb093f9e1a6472b4a98487.gif\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"一、前言\"> 一、前言</h2>\n<p>天下代码一大抄, 抄来抄去有提高, 看你会抄不会抄！从本篇开始后面的所有章节都是实战环节,每节一个小目标,最终我们实现完整的JavaRPC的框架,然后发布maven仓库,感兴趣的同学可以下载研究。大家如果想要获取源码的话可以私信: RPC,自动回复仓库地址。</p>\n<p>其实这些东西并没有什么难度，只要从头到尾跟着我们一起coding，其实就会发现不过如此。所以就算是新手也不要有心里负担。还是那句话: &quot;天下代码一大抄, 抄来抄去有提高, 看你会抄不会抄&quot;。主要的是思想，而不是死记硬背。所以我们来主要来学习设计思想，具体的代码，收藏用的时候看下就好了。</p>\n<p>下面我们废话就不多少，直接开始吧。</p>\n<h2 id=\"二、目标\"> 二、目标</h2>\n<h3 id=\"_2-1-目标介绍\"> 2.1 目标介绍</h3>\n<p>RPC框架中最基础的一个功能就是通讯，而通讯的本质就是发送方将数据转换成二进制的数据流，然后通过网络管道将数据发送给服务方，服务方在通过读取管道中的二进制数据最终将数据从二进制转换成Java对象，然后供Java系统处理，处理完成后再将Java结果对象转换成二进制数据通过管道发送回去。</p>\n<p><img src=\"https://img.springlearn.cn/blog/70b0a4323f80010510da069e00929af9.png\" alt=\"\" loading=\"lazy\"></p>\n<p>这里有两个重点，第一个是网络通信，就是图中的网路连接管道，第二个是管道中的二进制数据。本篇文章我们先研究后者，就是通过代码将Java对象转换成二进制数据。因为通信比较难，内容也较多，所以我们先易后难，难的放到下一篇文章在说。</p>\n<p><strong>这里有两个术语: 序列化和反序列化</strong></p>\n<p>如下实例User类，转换成二进制数据就是一个数组。这个Java对象转换二进制数据的过程叫做序列化。\n而二进制数据转换成Java对象的过程叫做反序列化。</p>\n<p><img src=\"https://img.springlearn.cn/blog/81cf177405be228573207ef58bf95425.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_2-2-两个小目标\"> 2.2 两个小目标</h3>\n<ul>\n<li>第一个目标就是我们实现多种序列化的能力。</li>\n<li>第二个目标是来选择一个最优的序列化方案。</li>\n</ul>\n<p>为什么说要选择最优的序列化方案呢? 因为我们要适配下面这两种场景。</p>\n<ol>\n<li>第一种是对性能要有比较高的，这种情况就要求我们序列化和反序列的速度要足够快</li>\n<li>第二种就是对内存和空间要有比较高的，就要求我们的序列化后的数据要足够的小。</li>\n</ol>\n<p>下面就开始Coding了。</p>\n<h2 id=\"三、设计\"> 三、设计</h2>\n<h3 id=\"_3-1-工程结构\"> 3.1 工程结构</h3>\n<p>首先我们根据上一篇文章中定义的项目分层结构，先把需要的所有层给创建出来。然后实现序列化。</p>\n<div><pre><code>mojito/mojito-net/src/main/java/cn/lxchinesszz/mojito on  master [!+?] \n.\n├── api\n├── business\n├── codec\n├── exception\n│   ├── BusinessServerHandlerException.java\n│   ├── DeserializeException.java\n│   ├── HttpsTokenFileException.java\n│   ├── ProtocolException.java\n│   ├── RemotingException.java\n│   ├── SerializeException.java\n│   └── SignatureException.java\n├── exchange\n└── serialize\n    ├── AbstractSerializer.java\n    ├── Serializer.java\n    └── impl\n        ├── Hession2ObjectSerializer.java\n        ├── HessionObjectSerializer.java\n        ├── NettyCompactObjectSerializer.java\n        ├── NettyObjectSerializer.java\n        └── ProtostuffObjectSerializer.java\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h3 id=\"_3-2-代码结构\"> 3.2 代码结构</h3>\n<p>首先我们先定义接口，为什么定义接口呢? 方便后面的扩展。\n接口也非常的简单就三个方法。</p>\n<p><img src=\"https://img.springlearn.cn/blog/519c51c51f1ac52200ed099ec2e21bf4.png\" alt=\"\" loading=\"lazy\"></p>\n<ol>\n<li>负责将任意对象转换成二进制数组</li>\n<li>将二进制数组转成Object对象</li>\n<li>将二进制数组转换成指定的Java对象</li>\n</ol>\n<p>UML图设计</p>\n<p><img src=\"https://img.springlearn.cn/blog/766a961a5b806a72922da75af14ca165.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_3-3-实现\"> 3.3 实现</h3>\n<ul>\n<li>ProtostuffObjectSerializer\n使用谷歌开源的序列化库,特点占用极小。</li>\n</ul>\n<div><pre><code><span>public</span> <span>class</span> <span>ProtostuffObjectSerializer</span> <span>extends</span> <span>AbstractSerializer</span> <span>{</span>\n\n    <span>/**\n     * 线程数会有限制,不会无穷大的使用\n     */</span>\n    <span>private</span> <span>static</span> <span>final</span> <span>ThreadLocal</span><span><span>&lt;</span><span>LinkedBuffer</span><span>></span></span> BUFFER <span>=</span> <span>InheritableThreadLocal</span><span>.</span><span>withInitial</span><span>(</span><span>(</span><span>)</span> <span>-></span>\n            <span>LinkedBuffer</span><span>.</span><span>allocate</span><span>(</span><span>LinkedBuffer</span><span>.</span>DEFAULT_BUFFER_SIZE<span>)</span><span>)</span><span>;</span>\n\n    <span>@Override</span>\n    <span>@SuppressWarnings</span><span>(</span><span>\"unchecked\"</span><span>)</span>\n    <span>public</span> <span>byte</span><span>[</span><span>]</span> <span>doSerialize</span><span>(</span><span>Object</span> dataObject<span>)</span> <span>throws</span> <span>SerializeException</span> <span>{</span>\n        <span>// // RuntimeSchema 懒加载内置缓存,所以我们不用在缓存了</span>\n        <span>Schema</span><span><span>&lt;</span><span>Object</span><span>></span></span> schema <span>=</span> <span>(</span><span>Schema</span><span><span>&lt;</span><span>Object</span><span>></span></span><span>)</span> <span>RuntimeSchema</span><span>.</span><span>getSchema</span><span>(</span>dataObject<span>.</span><span>getClass</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>LinkedBuffer</span> linkedBuffer <span>=</span> BUFFER<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>\n        <span>byte</span><span>[</span><span>]</span> bytes <span>=</span> <span>ProtostuffIOUtil</span><span>.</span><span>toByteArray</span><span>(</span>dataObject<span>,</span> schema<span>,</span> linkedBuffer<span>)</span><span>;</span>\n        linkedBuffer<span>.</span><span>clear</span><span>(</span><span>)</span><span>;</span>\n        <span>return</span> bytes<span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>Object</span> <span>doDeserialize</span><span>(</span><span>byte</span><span>[</span><span>]</span> data<span>)</span> <span>throws</span> <span>DeserializeException</span> <span>{</span>\n        <span>throw</span> <span>new</span> <span>UnsupportedOperationException</span><span>(</span><span>getClass</span><span>(</span><span>)</span> <span>+</span> <span>\"必须指定反序列化类型\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span><span>&lt;</span><span>T</span><span>></span></span> <span>T</span> <span>deserialize</span><span>(</span><span>byte</span><span>[</span><span>]</span> data<span>,</span> <span>Class</span><span><span>&lt;</span><span>T</span><span>></span></span> dataType<span>)</span> <span>throws</span> <span>DeserializeException</span> <span>{</span>\n        <span>return</span> <span>schema</span><span>(</span>data<span>,</span> dataType<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span><span>&lt;</span><span>T</span><span>></span></span> <span>T</span> <span>schema</span><span>(</span><span>byte</span><span>[</span><span>]</span> data<span>,</span> <span>Class</span><span><span>&lt;</span><span>T</span><span>></span></span> dataType<span>)</span> <span>throws</span> <span>DeserializeException</span> <span>{</span>\n        <span>try</span> <span>{</span>\n            <span>Schema</span><span><span>&lt;</span><span>T</span><span>></span></span> schema <span>=</span> <span>RuntimeSchema</span><span>.</span><span>getSchema</span><span>(</span>dataType<span>)</span><span>;</span>\n            <span>T</span> dataTypeObj <span>=</span> dataType<span>.</span><span>newInstance</span><span>(</span><span>)</span><span>;</span>\n            <span>ProtostuffIOUtil</span><span>.</span><span>mergeFrom</span><span>(</span>data<span>,</span> dataTypeObj<span>,</span> schema<span>)</span><span>;</span>\n            <span>return</span> dataTypeObj<span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>InstantiationException</span> <span>|</span> <span>IllegalAccessException</span> e<span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>DeserializeException</span><span>(</span>e<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><ul>\n<li>NettyCompactObjectSerializer\nNetty原生支持的序列化协议</li>\n</ul>\n<div><pre><code><span>public</span> <span>class</span> <span>NettyCompactObjectSerializer</span> <span>extends</span> <span>AbstractSerializer</span> <span>{</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>byte</span><span>[</span><span>]</span> <span>doSerialize</span><span>(</span><span>Object</span> dataObject<span>)</span> <span>throws</span> <span>SerializeException</span> <span>{</span>\n        <span>try</span> <span>(</span><span>ByteArrayOutputStream</span> dataArr <span>=</span> <span>new</span> <span>ByteArrayOutputStream</span><span>(</span><span>)</span><span>;</span>\n             <span>CompactObjectOutputStream</span> oeo <span>=</span> <span>new</span> <span>CompactObjectOutputStream</span><span>(</span>dataArr<span>)</span><span>)</span> <span>{</span>\n            oeo<span>.</span><span>writeObject</span><span>(</span>dataObject<span>)</span><span>;</span>\n            oeo<span>.</span><span>flush</span><span>(</span><span>)</span><span>;</span>\n            <span>return</span> dataArr<span>.</span><span>toByteArray</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>IOException</span> e<span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>SerializeException</span><span>(</span>e<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>Object</span> <span>doDeserialize</span><span>(</span><span>byte</span><span>[</span><span>]</span> data<span>)</span> <span>throws</span> <span>DeserializeException</span> <span>{</span>\n        <span>Object</span> o<span>;</span>\n        <span>try</span> <span>(</span><span>CompactObjectInputStream</span> odi <span>=</span> <span>new</span> <span>CompactObjectInputStream</span><span>(</span><span>new</span> <span>ByteArrayInputStream</span><span>(</span>data<span>)</span><span>,</span> <span>ClassResolvers</span><span>.</span><span>cacheDisabled</span><span>(</span><span>null</span><span>)</span><span>)</span><span>)</span> <span>{</span>\n            o <span>=</span> odi<span>.</span><span>readObject</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>ClassNotFoundException</span> <span>|</span> <span>IOException</span> e<span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>DeserializeException</span><span>(</span>e<span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> o<span>;</span>\n    <span>}</span>\n    \n    <span>private</span> <span>static</span> <span>class</span> <span>CompactObjectOutputStream</span> <span>extends</span> <span>ObjectOutputStream</span> <span>{</span>\n\n        <span>static</span> <span>final</span> <span>int</span> TYPE_FAT_DESCRIPTOR <span>=</span> <span>0</span><span>;</span>\n        <span>static</span> <span>final</span> <span>int</span> TYPE_THIN_DESCRIPTOR <span>=</span> <span>1</span><span>;</span>\n\n        <span>CompactObjectOutputStream</span><span>(</span><span>OutputStream</span> out<span>)</span> <span>throws</span> <span>IOException</span> <span>{</span>\n            <span>super</span><span>(</span>out<span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>@Override</span>\n        <span>protected</span> <span>void</span> <span>writeStreamHeader</span><span>(</span><span>)</span> <span>throws</span> <span>IOException</span> <span>{</span>\n            <span>writeByte</span><span>(</span>STREAM_VERSION<span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>@Override</span>\n        <span>protected</span> <span>void</span> <span>writeClassDescriptor</span><span>(</span><span>ObjectStreamClass</span> desc<span>)</span> <span>throws</span> <span>IOException</span> <span>{</span>\n            <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> clazz <span>=</span> desc<span>.</span><span>forClass</span><span>(</span><span>)</span><span>;</span>\n            <span>if</span> <span>(</span>clazz<span>.</span><span>isPrimitive</span><span>(</span><span>)</span> <span>||</span> clazz<span>.</span><span>isArray</span><span>(</span><span>)</span> <span>||</span> clazz<span>.</span><span>isInterface</span><span>(</span><span>)</span> <span>||</span>\n                    desc<span>.</span><span>getSerialVersionUID</span><span>(</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>\n                <span>write</span><span>(</span>TYPE_FAT_DESCRIPTOR<span>)</span><span>;</span>\n                <span>super</span><span>.</span><span>writeClassDescriptor</span><span>(</span>desc<span>)</span><span>;</span>\n            <span>}</span> <span>else</span> <span>{</span>\n                <span>write</span><span>(</span>TYPE_THIN_DESCRIPTOR<span>)</span><span>;</span>\n                <span>writeUTF</span><span>(</span>desc<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>/**\n     * 压缩\n     */</span>\n    <span>private</span> <span>static</span> <span>class</span> <span>CompactObjectInputStream</span> <span>extends</span> <span>ObjectInputStream</span> <span>{</span>\n\n        <span>static</span> <span>final</span> <span>int</span> TYPE_FAT_DESCRIPTOR <span>=</span> <span>0</span><span>;</span>\n\n        <span>static</span> <span>final</span> <span>int</span> TYPE_THIN_DESCRIPTOR <span>=</span> <span>1</span><span>;</span>\n\n        <span>private</span> <span>final</span> <span>ClassResolver</span> classResolver<span>;</span>\n\n        <span>CompactObjectInputStream</span><span>(</span><span>InputStream</span> in<span>,</span> <span>ClassResolver</span> classResolver<span>)</span> <span>throws</span> <span>IOException</span> <span>{</span>\n            <span>super</span><span>(</span>in<span>)</span><span>;</span>\n            <span>this</span><span>.</span>classResolver <span>=</span> classResolver<span>;</span>\n        <span>}</span>\n\n        <span>@Override</span>\n        <span>protected</span> <span>void</span> <span>readStreamHeader</span><span>(</span><span>)</span> <span>throws</span> <span>IOException</span> <span>{</span>\n            <span>int</span> version <span>=</span> <span>readByte</span><span>(</span><span>)</span> <span>&amp;</span> <span>0xFF</span><span>;</span>\n            <span>if</span> <span>(</span>version <span>!=</span> STREAM_VERSION<span>)</span> <span>{</span>\n                <span>throw</span> <span>new</span> <span>StreamCorruptedException</span><span>(</span>\n                        <span>\"Unsupported version: \"</span> <span>+</span> version<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n\n        <span>@Override</span>\n        <span>protected</span> <span>ObjectStreamClass</span> <span>readClassDescriptor</span><span>(</span><span>)</span>\n                <span>throws</span> <span>IOException</span><span>,</span> <span>ClassNotFoundException</span> <span>{</span>\n            <span>int</span> type <span>=</span> <span>read</span><span>(</span><span>)</span><span>;</span>\n            <span>if</span> <span>(</span>type <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>\n                <span>throw</span> <span>new</span> <span>EOFException</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n            <span>switch</span> <span>(</span>type<span>)</span> <span>{</span>\n                <span>case</span> TYPE_FAT_DESCRIPTOR<span>:</span>\n                    <span>return</span> <span>super</span><span>.</span><span>readClassDescriptor</span><span>(</span><span>)</span><span>;</span>\n                <span>case</span> TYPE_THIN_DESCRIPTOR<span>:</span>\n                    <span>String</span> className <span>=</span> <span>readUTF</span><span>(</span><span>)</span><span>;</span>\n                    <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> clazz <span>=</span> classResolver<span>.</span><span>resolve</span><span>(</span>className<span>)</span><span>;</span>\n                    <span>return</span> <span>ObjectStreamClass</span><span>.</span><span>lookupAny</span><span>(</span>clazz<span>)</span><span>;</span>\n                <span>default</span><span>:</span>\n                    <span>throw</span> <span>new</span> <span>StreamCorruptedException</span><span>(</span>\n                            <span>\"Unexpected class descriptor type: \"</span> <span>+</span> type<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n\n        <span>@Override</span>\n        <span>protected</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> <span>resolveClass</span><span>(</span><span>ObjectStreamClass</span> desc<span>)</span> <span>throws</span> <span>IOException</span><span>,</span> <span>ClassNotFoundException</span> <span>{</span>\n            <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> clazz<span>;</span>\n            <span>try</span> <span>{</span>\n                clazz <span>=</span> classResolver<span>.</span><span>resolve</span><span>(</span>desc<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>}</span> <span>catch</span> <span>(</span><span>ClassNotFoundException</span> ignored<span>)</span> <span>{</span>\n                clazz <span>=</span> <span>super</span><span>.</span><span>resolveClass</span><span>(</span>desc<span>)</span><span>;</span>\n            <span>}</span>\n\n            <span>return</span> clazz<span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br></div></div><ul>\n<li>HessionObjectSerializer\n基于Hession序列化协议的封装</li>\n</ul>\n<div><pre><code><span>public</span> <span>class</span> <span>HessionObjectSerializer</span> <span>extends</span> <span>AbstractSerializer</span> <span>{</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>byte</span><span>[</span><span>]</span> <span>doSerialize</span><span>(</span><span>Object</span> dataObject<span>)</span> <span>throws</span> <span>SerializeException</span> <span>{</span>\n        <span>HessianOutput</span> oeo <span>=</span> <span>null</span><span>;</span>\n        <span>try</span> <span>(</span><span>ByteArrayOutputStream</span> dataArr <span>=</span> <span>new</span> <span>ByteArrayOutputStream</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n            oeo <span>=</span> <span>new</span> <span>HessianOutput</span><span>(</span>dataArr<span>)</span><span>;</span>\n            oeo<span>.</span><span>writeObject</span><span>(</span>dataObject<span>)</span><span>;</span>\n            oeo<span>.</span><span>flush</span><span>(</span><span>)</span><span>;</span>\n            <span>return</span> dataArr<span>.</span><span>toByteArray</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>IOException</span> e<span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>SerializeException</span><span>(</span>e<span>)</span><span>;</span>\n        <span>}</span> <span>finally</span> <span>{</span>\n            <span>if</span> <span>(</span>oeo <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n                <span>try</span> <span>{</span>\n                    oeo<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n                <span>}</span> <span>catch</span> <span>(</span><span>IOException</span> e<span>)</span> <span>{</span>\n                    <span>throw</span> <span>new</span> <span>SerializeException</span><span>(</span>e<span>)</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>Object</span> <span>doDeserialize</span><span>(</span><span>byte</span><span>[</span><span>]</span> data<span>)</span> <span>throws</span> <span>DeserializeException</span> <span>{</span>\n        <span>Object</span> o<span>;</span>\n        <span>HessianInput</span> odi <span>=</span> <span>new</span> <span>HessianInput</span><span>(</span><span>new</span> <span>ByteArrayInputStream</span><span>(</span>data<span>)</span><span>)</span><span>;</span>\n        <span>try</span> <span>{</span>\n            o <span>=</span> odi<span>.</span><span>readObject</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>IOException</span> e<span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>DeserializeException</span><span>(</span>e<span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> o<span>;</span>\n    <span>}</span>\n\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><ul>\n<li>Hession2ObjectSerializer\n对Hession2序列化的封装</li>\n</ul>\n<div><pre><code><span>public</span> <span>class</span> <span>Hession2ObjectSerializer</span> <span>extends</span> <span>AbstractSerializer</span> <span>{</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>byte</span><span>[</span><span>]</span> <span>doSerialize</span><span>(</span><span>Object</span> dataObject<span>)</span> <span>throws</span> <span>SerializeException</span> <span>{</span>\n        <span>ByteArrayOutputStream</span> dataArr <span>=</span> <span>new</span> <span>ByteArrayOutputStream</span><span>(</span><span>)</span><span>;</span>\n        <span>Hessian2Output</span> oeo <span>=</span> <span>null</span><span>;</span>\n        <span>try</span> <span>{</span>\n            oeo <span>=</span> <span>new</span> <span>Hessian2Output</span><span>(</span>dataArr<span>)</span><span>;</span>\n            oeo<span>.</span><span>writeObject</span><span>(</span>dataObject<span>)</span><span>;</span>\n            oeo<span>.</span><span>flush</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>IOException</span> e<span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>SerializeException</span><span>(</span>e<span>)</span><span>;</span>\n        <span>}</span> <span>finally</span> <span>{</span>\n            <span>if</span> <span>(</span>oeo <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n                <span>try</span> <span>{</span>\n                    oeo<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n                <span>}</span> <span>catch</span> <span>(</span><span>IOException</span> e<span>)</span> <span>{</span>\n                    <span>throw</span> <span>new</span> <span>SerializeException</span><span>(</span>e<span>)</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> dataArr<span>.</span><span>toByteArray</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>Object</span> <span>doDeserialize</span><span>(</span><span>byte</span><span>[</span><span>]</span> data<span>)</span> <span>throws</span> <span>DeserializeException</span> <span>{</span>\n        <span>Object</span> o<span>;</span>\n        <span>Hessian2Input</span> odi <span>=</span> <span>new</span> <span>Hessian2Input</span><span>(</span><span>new</span> <span>ByteArrayInputStream</span><span>(</span>data<span>)</span><span>)</span><span>;</span>\n        <span>try</span> <span>{</span>\n            o <span>=</span> odi<span>.</span><span>readObject</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>IOException</span> e<span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>DeserializeException</span><span>(</span>e<span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> o<span>;</span>\n    <span>}</span>\n    \n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><p>如果有优化的建议，希望多多评论，指点一二。以上代码已上传，代码较多就不这里展示。感兴趣的同学可以访问下面链接，查看代码。</p>\n<p><a href=\"https://github.com/lxchinesszz/mojito/tree/master/mojito-net/src/main/java/cn/lxchinesszz/mojito/serialize\" target=\"_blank\" rel=\"noopener noreferrer\">仓库实现</a></p>\n<h2 id=\"四、性能分析\"> 四、性能分析</h2>\n<h3 id=\"_4-1-性能分析\"> 4.1 性能分析</h3>\n<p>那么以上这几种序列化协议那种速度最好呢?</p>\n<p>首先我们先看序列化的速度对比。</p>\n<p>使用20个线程，预热3秒，执行5秒对比下吞吐量及内存使用。这里我们只截图排名第一的实现。具体的对比数据已放在github上面，感兴趣的可以自己拉下来看下。</p>\n<p><img src=\"https://img.springlearn.cn/blog/c840802c5053f6f068aaca6978f16317.png\" alt=\"\" loading=\"lazy\"></p>\n<ul>\n<li>ProtostuffObjectSerializer 吞吐量\t10,774,518 / s</li>\n<li>Hession2ObjectSerializer 吞吐量\t3,200,559 / s</li>\n<li>HessionObjectSerializer 吞吐量\t3,307,595 / s</li>\n<li>NettyCompactObjectSerializer 吞吐量\t874,793 / s</li>\n</ul>\n<p>从上面中的数据我们能看出Protostuff是遥遥领先,这得益于提前把数据类型,提前进行了处理并缓存，其次是友好的API涉及,可以让我们避免频繁生成堆空间。</p>\n<p><img src=\"https://img.springlearn.cn/blog/b120424dd518e8586c3f6cc0d2ce08cd.png\" alt=\"\" loading=\"lazy\"></p>\n<p>更多详细的数据对比，可以点下面链接查看。</p>\n<p><a href=\"https://img.springlearn.cn/learn_05ff80a9fa21590abbf09c0608a76028.html\" target=\"_blank\" rel=\"noopener noreferrer\">详细数据</a></p>\n<h3 id=\"_4-2-序列化长度\"> 4.2 序列化长度</h3>\n<p>前面Protostuff在性能上是遥遥领先,那么在数据压缩比例上究竟谁能胜出呢？ 相对于前面性能测试，这种大小测试是比较容易测试, 我们直接执行下面代码，查看结果。</p>\n<div><pre><code>    <span>@Test</span>\n    <span>@DisplayName</span><span>(</span><span>\"序列化数据大小对比\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>test7</span><span>(</span><span>)</span> <span>{</span>\n        <span>ProtostuffObjectSerializer</span> nettyObjectSerializer <span>=</span> <span>new</span> <span>ProtostuffObjectSerializer</span><span>(</span><span>)</span><span>;</span>\n        <span>byte</span><span>[</span><span>]</span> jay <span>=</span> nettyObjectSerializer<span>.</span><span>serialize</span><span>(</span><span>new</span> <span>UserSerializable</span><span>(</span><span>\"周杰伦\"</span><span>,</span> <span>42</span><span>)</span><span>)</span><span>;</span>\n        <span>ColorConsole</span><span>.</span><span>colorPrintln</span><span>(</span><span>\"{},序列化数据长度:{}\"</span><span>,</span> <span>\"Protostuff\"</span><span>,</span> jay<span>.</span>length<span>)</span><span>;</span>\n\n        <span>ColorConsole</span><span>.</span><span>colorPrintln</span><span>(</span><span>\"{},序列化数据长度:{}\"</span><span>,</span> <span>\"Hession2\"</span><span>,</span>\n                <span>new</span> <span>Hession2ObjectSerializer</span><span>(</span><span>)</span><span>.</span><span>serialize</span><span>(</span><span>new</span> <span>UserSerializable</span><span>(</span><span>\"周杰伦\"</span><span>,</span> <span>42</span><span>)</span><span>)</span><span>.</span>length<span>)</span><span>;</span>\n\n        <span>ColorConsole</span><span>.</span><span>colorPrintln</span><span>(</span><span>\"{},序列化数据长度:{}\"</span><span>,</span> <span>\"Hession\"</span><span>,</span>\n                <span>new</span> <span>HessionObjectSerializer</span><span>(</span><span>)</span><span>.</span><span>serialize</span><span>(</span><span>new</span> <span>UserSerializable</span><span>(</span><span>\"周杰伦\"</span><span>,</span> <span>42</span><span>)</span><span>)</span><span>.</span>length<span>)</span><span>;</span>\n\n        <span>ColorConsole</span><span>.</span><span>colorPrintln</span><span>(</span><span>\"{},序列化数据长度:{}\"</span><span>,</span> <span>\"NettyCompact\"</span><span>,</span>\n                <span>new</span> <span>NettyCompactObjectSerializer</span><span>(</span><span>)</span><span>.</span><span>serialize</span><span>(</span><span>new</span> <span>UserSerializable</span><span>(</span><span>\"周杰伦\"</span><span>,</span> <span>42</span><span>)</span><span>)</span><span>.</span>length<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">实现类</th>\n<th style=\"text-align:left\">长度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ProtostuffObjectSerializer</td>\n<td style=\"text-align:left\">13字节</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Hession2ObjectSerializer</td>\n<td style=\"text-align:left\">88字节</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">HessionObjectSerializer</td>\n<td style=\"text-align:left\">98字节</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">NettyCompactObjectSerializer</td>\n<td style=\"text-align:left\">132字节</td>\n</tr>\n</tbody>\n</table>\n<p>还是Protostuff大幅度领先,那么我们的默认序列化协议就使用了吧。是不是很简单呢?</p>\n<h2 id=\"五、总结\"> 五、总结</h2>\n<p><img src=\"https://img.springlearn.cn/blog/70b0a4323f80010510da069e00929af9.png\" alt=\"\" loading=\"lazy\"></p>\n<p>通过这一节的实现,我们已经可以使用序列化工具,将Java对象转换成二进制数据了，那么下一篇我们就来实现如果创建网络连接管道吧。</p>\n<p>那么你准备好跟我一起Coding了吗?</p>\n<p><img src=\"https://img.springlearn.cn/blog/dcdc576db14dda19819196a4dba05a21.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://img.springlearn.cn/blog/f18e12cc1d0c57c16e6d6cb258fe746c.png",
      "date_published": "2022-08-22T01:35:49.000Z",
      "date_modified": "2022-08-22T01:35:49.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "mojito"
      ]
    },
    {
      "title": "第05篇:手写JavaRPC框架之执行层思路",
      "url": "https://java.springlearn.cn/learn/project/mojito/%E7%AC%AC05%E7%AF%87:%E6%89%8B%E5%86%99JavaRPC%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%89%A7%E8%A1%8C%E5%B1%82%E6%80%9D%E8%B7%AF/",
      "id": "https://java.springlearn.cn/learn/project/mojito/%E7%AC%AC05%E7%AF%87:%E6%89%8B%E5%86%99JavaRPC%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%89%A7%E8%A1%8C%E5%B1%82%E6%80%9D%E8%B7%AF/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/d0e05f0a0f96e2399aefe0e8fe00e23c.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者:</strong> 西魏陶渊明</p>\n<p><strong>博客:</strong> https://blog.springlearn.cn/</p>\n<blockquote>\n<p>天下代码一大抄, 抄来抄去有提高, 看你会抄不会抄！</p>\n</blockquote>\n<p><img src=\"https://img.springlearn.cn/blog/8f3392b9badb093f9e1a6472b4a98487.gif\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"一、思路分析\"> 一、思路分析</h2>\n<p><img src=\"https://img.springlearn.cn/blog/fe6f42fd58fad7a1ca190f66c730405b.png\" alt=\"\" loading=\"lazy\"></p>\n<p>通过前四篇文章的一起 Coding, 我们已经完成了 30%的工作,即完成了一个通信层的搭建。在不依赖任何 web 容器的情况下,可以实现服务之间的通信工作。就像下面这样。</p>\n<p><strong>客户端&amp;服务端通信</strong></p>\n<div><pre><code>    <span>/**\n     * @author liuxin\n     * 个人博客：https://java.springlearn.cn\n     * 公众号：西魏陶渊明  ｛关注获取学习源码｝\n     * 2022/8/11 23:12\n     */</span>\n    <span>@Test</span>\n    <span>@DisplayName</span><span>(</span><span>\"构建服务端【阻塞方式】\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>server</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n       <span>Mojito</span><span>.</span><span>server</span><span>(</span><span>RpcRequest</span><span>.</span><span>class</span><span>,</span> <span>RpcResponse</span><span>.</span><span>class</span><span>)</span>\n                <span>// 业务层,读取请求对象,返回结果</span>\n                <span>.</span><span>businessHandler</span><span>(</span><span>(</span>channelContext<span>,</span> request<span>)</span> <span>-></span> <span>new</span> <span>RpcResponse</span><span>(</span><span>)</span><span>)</span>\n                <span>.</span><span>create</span><span>(</span><span>)</span><span>.</span><span>start</span><span>(</span><span>666</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Test</span>\n    <span>@DisplayName</span><span>(</span><span>\"构建客户端【同步方式】\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>clientSync</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span><span>{</span>\n        <span>Client</span><span><span>&lt;</span><span>RpcRequest</span><span>,</span> <span>RpcResponse</span><span>></span></span> client <span>=</span> <span>Mojito</span><span>.</span><span>client</span><span>(</span><span>RpcRequest</span><span>.</span><span>class</span><span>,</span> <span>RpcResponse</span><span>.</span><span>class</span><span>)</span>\n                <span>.</span><span>connect</span><span>(</span><span>\"127.0.0.1\"</span><span>,</span> <span>6666</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>client<span>.</span><span>send</span><span>(</span><span>new</span> <span>RpcRequest</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>这只是完成了通信, 就好比,两台服务器之间建立了沟通管道,但是究竟怎么用这个管道呢? 如何将客户端的请求参数发送到服务端的服务器上执行结果,并返回给客户端呢? 这就是本篇文章要讨论的话题。</p>\n<p><img src=\"https://img.springlearn.cn/blog/70b0a4323f80010510da069e00929af9.png\" alt=\"\" loading=\"lazy\"></p>\n<p>暂且我们把这一层叫做 RPC 执行层吧。按照老套路,在真正开始 Coding 之前,我们先梳理一下逻辑,画一个最基础的图。</p>\n<p><img src=\"https://img.springlearn.cn/blog/e159fc7ffa56083fdbb9b81048b9c5ee.png\" alt=\"\" loading=\"lazy\"></p>\n<ul>\n<li>左边客户端一个方法, 有 4 个服务端的实现。</li>\n<li>右边某个服务端有一个具体的实现。</li>\n</ul>\n<p>左边客户端的接口,通过代理的方式,将客户端的参数通过网络管道传输给某台服务端的本地进行执行。执行后获取结果,返回给客户端的调用方。而这些都是通过代理的方式实现的,所以开发者就好像调用本地方法一样。实现一次远程方法的调用。</p>\n<p>以上是最最基础的远程调用的过程,但是如果就这的话就太基础了,下面我们会在这个基础上去做更多的事情。</p>\n<h3 id=\"_1-1-客户端实现思路\"> 1.1 客户端实现思路</h3>\n<p>RPC 服务,服务端会给客户端提供一个 API 包,这个包里面没有具体的实现,但是客户端能直接进行调用。学习 Java 的都知道接口是不能实例化的,但是为什么服务端给我们的 API,我们能直接调用呢? 当然是代理了。所以我们要学的第一个东西,就是学会代理。</p>\n<ol>\n<li>使用代理实现接口的实例化。【代理是我们必须要掌握的】</li>\n</ol>\n<p>但是代理层里面怎么做呢?</p>\n<ol start=\"2\">\n<li>代理层将要调用的远程类和当前的客户端的参数,进行封装,然后通过通信层发送给服务端进行直接,然后拿到结果返回。这里面可能就设计到异步转同步的问题,但是没关系我们通信层直接就提供了实现。</li>\n</ol>\n<p>以上就是客户端最基础的功能了。但是我们不满足于此, 市面上 RPC 框架有的功能,我们也要有。比如那些呢?\n负载均衡、容错策略、事件广播我们也要有。那么他们究竟怎么做的呢?</p>\n<ol start=\"3\">\n<li>\n<p>负载均衡,我们看上面客户端的图,会发现这个服务有 4 个实现 [<code>172.168.10.1</code>,<code>172.168.10.2</code>,<code>172.168.10.3</code>,<code>172.168.10.4</code>],说明服务端可能是集群部署的。那么既然有 4 个实例,我们就不能尽管这，一个 ip 进行进行调用,那么如何尽量让每个实例都能收到请求呢? 这就是负载均衡。</p>\n</li>\n<li>\n<p>容错策略,当我们调用一台实例出错了,直接报错? 还是重试一下请求？或者是换一个实例在请求呢? 这就是容错策略。甚至我们还可以实现一个熔断器。</p>\n</li>\n</ol>\n<p><img src=\"https://img.springlearn.cn/blog/9d8ac7a0fcfb51c2951a93a86f7a3961.png\" alt=\"\" loading=\"lazy\"></p>\n<p>这里不会设计也没关系,我们会抄,哦,不对是借鉴。以下是dubbo的容错策略。</p>\n<p><img src=\"https://img.springlearn.cn/blog/ba911f5f18960a64e512665ffa0f09e0.png\" alt=\"\" loading=\"lazy\"></p>\n<ol start=\"5\">\n<li>既然客户端有这个服务的所有实例信息,那么是不是不仅可以进行点对点的请求，还是能进行广播呢。\n如下右图,同一个请求,如果发现是广播模式,就不在负载均衡的选其中的一个进行执行,而是每个都进行通知。</li>\n</ol>\n<p><img src=\"https://img.springlearn.cn/blog/bf08e6ff0fd9428f810b39174b8c51ed.png\" alt=\"\" loading=\"lazy\"></p>\n<p>这五点就是客户端要具备的基础能力。除此之外客户端还要有断线重连, 自动剔除无效的链接的功能。极端情况也还要考虑当注册中心也挂了,无法找到服务端地址的场景,本地是不是也要维护一个服务连接的注册表。</p>\n<h3 id=\"_1-2-服务端实现思路\"> 1.2 服务端实现思路</h3>\n<p>服务端我们就可以参考 Web 容器的思路，比如 Servle 如何处理请求呢? http 过来就是一个 url,如何匹配到要执行的方法的呢?</p>\n<ol>\n<li>服务启动将 API 实现保存到 Map 接口中。</li>\n<li>服务收到请求,Dispatch 根据请求信息从 map 中获取执行器。</li>\n<li>通过反射获取执行结果,返回给调用方。</li>\n</ol>\n<p><img src=\"https://img.springlearn.cn/blog/cb8c0658eee15b5b8a5790fa5bb621ef.png\" alt=\"\" loading=\"lazy\"></p>\n<p>同时将自己的信息注册到注册中心,让客户端能注册中心发现自己。</p>\n<p><img src=\"https://img.springlearn.cn/blog/3ec7c0abdc42dd28e81a1d48a9ec41dc.png\" alt=\"\" loading=\"lazy\"></p>\n<p>好了我们实现代码的大概思路就是这些,后面我们会一步一会去实现上面我们所说的功能。下面我们来看下\n如果要实现上面的思路,还需要那些技术储备和软实力吧。</p>\n<h2 id=\"二、技术储备\"> 二、技术储备</h2>\n<p>要实现上面的想法,究竟需要哪些技术储备呢? 最基础的就是代理了。除此之外还要有架构设计能力。</p>\n<h3 id=\"_2-1-代理模式\"> 2.1 代理模式</h3>\n<p>上面我们所说的负载均衡，容错策略，广播都要在代理中实现。</p>\n<h4 id=\"_2-1-1-jdk-代理\"> 2.1.1 JDK 代理</h4>\n<p>JDK 代理必须要实现接口,第二个参数是接口数组,第三个参数是<code>InvocationHandler</code>。属于比较基础的内容。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>ProxyFactory</span> <span>{</span>\n\n    <span>public</span> <span>interface</span> <span>User</span> <span>{</span>\n        <span>String</span> <span>queryName</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>User</span> user <span>=</span> <span>(</span><span>User</span><span>)</span> <span>Proxy</span><span>.</span><span>newProxyInstance</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getContextClassLoader</span><span>(</span><span>)</span><span>,</span> <span>new</span> <span>Class</span><span>[</span><span>]</span><span>{</span><span>User</span><span>.</span><span>class</span><span>}</span><span>,</span> <span>new</span> <span>InvocationHandler</span><span>(</span><span>)</span> <span>{</span>\n            <span>@Override</span>\n            <span>public</span> <span>Object</span> <span>invoke</span><span>(</span><span>Object</span> proxy<span>,</span> <span>Method</span> method<span>,</span> <span>Object</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>Throwable</span> <span>{</span>\n                <span>if</span> <span>(</span>method<span>.</span><span>getName</span><span>(</span><span>)</span><span>.</span><span>equals</span><span>(</span><span>\"queryName\"</span><span>)</span><span>)</span> <span>{</span>\n                    <span>return</span> <span>\"Jay\"</span><span>;</span>\n                <span>}</span> <span>else</span> <span>{</span>\n                    <span>return</span> <span>null</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>user<span>.</span><span>queryName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h4 id=\"_2-1-2-cglib-代理\"> 2.1.2 Cglib 代理</h4>\n<p>Cglib 代理,代理类不用有接口。</p>\n<div><pre><code>    <span>public</span> <span>static</span> <span>class</span> <span>Person</span> <span>{</span>\n\n        <span>public</span> <span>String</span> <span>queryName</span><span>(</span><span>)</span> <span>{</span>\n            <span>return</span> <span>\"jay\"</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>Person</span> person <span>=</span> <span>(</span><span>Person</span><span>)</span> <span>Enhancer</span><span>.</span><span>create</span><span>(</span><span>Person</span><span>.</span><span>class</span><span>,</span> <span>new</span> <span>MethodInterceptor</span><span>(</span><span>)</span> <span>{</span>\n            <span>@Override</span>\n            <span>public</span> <span>Object</span> <span>intercept</span><span>(</span><span>Object</span> o<span>,</span> <span>Method</span> method<span>,</span> <span>Object</span><span>[</span><span>]</span> objects<span>,</span> <span>MethodProxy</span> methodProxy<span>)</span> <span>throws</span> <span>Throwable</span> <span>{</span>\n                <span>if</span> <span>(</span>method<span>.</span><span>getName</span><span>(</span><span>)</span><span>.</span><span>equals</span><span>(</span><span>\"queryName\"</span><span>)</span><span>)</span> <span>{</span>\n                    <span>return</span> <span>\"代理:Jay\"</span><span>;</span>\n                <span>}</span> <span>else</span> <span>{</span>\n                    <span>return</span> <span>null</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>person<span>.</span><span>queryName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h3 id=\"_2-2-负载均衡策略\"> 2.2 负载均衡策略</h3>\n<h4 id=\"_2-2-1-随机算法\"> 2.2.1 随机算法</h4>\n<div><pre><code><span>public</span> <span>static</span> <span>String</span> <span>random</span><span>(</span><span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> services<span>)</span> <span>{</span>\n        <span>Random</span> random <span>=</span> <span>new</span> <span>Random</span><span>(</span><span>)</span><span>;</span>\n        <span>String</span><span>[</span><span>]</span> addressArr <span>=</span> services<span>.</span><span>toArray</span><span>(</span><span>new</span> <span>String</span><span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>\n        <span>// random</span>\n        <span>return</span> addressArr<span>[</span>random<span>.</span><span>nextInt</span><span>(</span>services<span>.</span><span>size</span><span>(</span><span>)</span><span>)</span><span>]</span><span>;</span>\n <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h4 id=\"_2-2-2-轮训算法\"> 2.2.2 轮训算法</h4>\n<div><pre><code><span>public</span> <span>class</span> <span>RoundBalanceTest</span> <span>{</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> services <span>=</span> <span>Arrays</span><span>.</span><span>asList</span><span>(</span><span>\"service1\"</span><span>,</span> <span>\"service2\"</span><span>,</span> <span>\"service3\"</span><span>)</span><span>;</span>\n        <span>XxlBalanceTest</span><span>.</span><span>manyRoute</span><span>(</span>i <span>-></span> <span>{</span>\n            <span>// 请求次数,取模。serviceKey 可以更细粒度的控制轮训</span>\n            <span>ColorConsole</span><span>.</span><span>colorPrintln</span><span>(</span><span>\"轮训负载({}):{}\"</span><span>,</span> i<span>,</span> <span>round</span><span>(</span>services<span>)</span><span>)</span><span>;</span>\n        <span>}</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>private</span> <span>static</span> <span>final</span> <span>AtomicInteger</span> atomicInteger <span>=</span> <span>new</span> <span>AtomicInteger</span><span>(</span><span>)</span><span>;</span>\n\n    <span>private</span> <span>static</span> <span>String</span> <span>round</span><span>(</span><span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> services<span>)</span> <span>{</span>\n        <span>int</span> count <span>=</span> atomicInteger<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span>count <span>>=</span> <span>Integer</span><span>.</span>MAX_VALUE<span>)</span> <span>{</span>\n            atomicInteger<span>.</span><span>set</span><span>(</span><span>0</span><span>)</span><span>;</span>\n        <span>}</span>\n        atomicInteger<span>.</span><span>incrementAndGet</span><span>(</span><span>)</span><span>;</span>\n        <span>String</span><span>[</span><span>]</span> toArray <span>=</span> services<span>.</span><span>toArray</span><span>(</span><span>new</span> <span>String</span><span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>\n        <span>return</span> toArray<span>[</span>count <span>%</span> toArray<span>.</span>length<span>]</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h4 id=\"_2-2-3-加权算法\"> 2.2.3 加权算法</h4>\n<p>加权算法的有很多的变异算法, 可以通过配置的方式，也可以通过某种策略动态的给每台服务器进行加权，从而来提高被轮训到的次数。 这里说两种网上常见的实现。</p>\n<p><strong>简单加权算法</strong>\n一个简单暴力的加权算法,如下图。按照权重，重新构建集合。然后再将集合进行取模轮训即可。即可实现一个最简单 的加权算法。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1652884737000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>代码实现也是比较简单的,如下代码。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>WeightBalanceTest</span> <span>{</span>\n\n    <span>private</span> <span>static</span> <span>class</span> <span>Server</span> <span>{</span>\n\n        <span>private</span> <span>String</span> host<span>;</span>\n\n        <span>private</span> <span>Integer</span> port<span>;</span>\n\n        <span>public</span> <span>Server</span><span>(</span><span>String</span> host<span>,</span> <span>Integer</span> port<span>)</span> <span>{</span>\n            <span>this</span><span>.</span>host <span>=</span> host<span>;</span>\n            <span>this</span><span>.</span>port <span>=</span> port<span>;</span>\n        <span>}</span>\n\n        <span>@Override</span>\n        <span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span>\n            <span>return</span> <span>\"Server{\"</span> <span>+</span>\n                    <span>\"host='\"</span> <span>+</span> host <span>+</span> <span>'\\''</span> <span>+</span>\n                    <span>\", port=\"</span> <span>+</span> port <span>+</span>\n                    <span>'}'</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>private</span> <span>static</span> <span>final</span> <span>AtomicInteger</span> atomicInteger <span>=</span> <span>new</span> <span>AtomicInteger</span><span>(</span><span>)</span><span>;</span>\n\n    <span>public</span> <span>static</span> <span>Server</span> <span>round</span><span>(</span><span>List</span><span><span>&lt;</span><span>Server</span><span>></span></span> services<span>)</span> <span>{</span>\n        <span>int</span> count <span>=</span> atomicInteger<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span>count <span>>=</span> <span>Integer</span><span>.</span>MAX_VALUE<span>)</span> <span>{</span>\n            atomicInteger<span>.</span><span>set</span><span>(</span><span>0</span><span>)</span><span>;</span>\n        <span>}</span>\n        atomicInteger<span>.</span><span>incrementAndGet</span><span>(</span><span>)</span><span>;</span>\n        <span>Server</span><span>[</span><span>]</span> toArray <span>=</span> services<span>.</span><span>toArray</span><span>(</span><span>new</span> <span>Server</span><span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>\n        <span>return</span> toArray<span>[</span>count <span>%</span> toArray<span>.</span>length<span>]</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>Map</span><span><span>&lt;</span><span>Server</span><span>,</span> <span>Integer</span><span>></span></span> confWeight <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        confWeight<span>.</span><span>put</span><span>(</span><span>new</span> <span>Server</span><span>(</span><span>\"127.0.0.1\"</span><span>,</span> <span>80</span><span>)</span><span>,</span> <span>2</span><span>)</span><span>;</span>\n        confWeight<span>.</span><span>put</span><span>(</span><span>new</span> <span>Server</span><span>(</span><span>\"127.0.0.1\"</span><span>,</span> <span>81</span><span>)</span><span>,</span> <span>3</span><span>)</span><span>;</span>\n        confWeight<span>.</span><span>put</span><span>(</span><span>new</span> <span>Server</span><span>(</span><span>\"127.0.0.1\"</span><span>,</span> <span>82</span><span>)</span><span>,</span> <span>5</span><span>)</span><span>;</span>\n\n        <span>List</span><span><span>&lt;</span><span>Server</span><span>></span></span> servers <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>Map<span>.</span>Entry</span><span><span>&lt;</span><span>Server</span><span>,</span> <span>Integer</span><span>></span></span> entity <span>:</span> confWeight<span>.</span><span>entrySet</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n            <span>Server</span> server <span>=</span> entity<span>.</span><span>getKey</span><span>(</span><span>)</span><span>;</span>\n            <span>Integer</span> weight <span>=</span> entity<span>.</span><span>getValue</span><span>(</span><span>)</span><span>;</span>\n            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> weight<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n                servers<span>.</span><span>add</span><span>(</span>server<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>Loops</span><span>.</span><span>loop</span><span>(</span><span>10</span><span>,</span> i <span>-></span> <span>{</span>\n            <span>ColorConsole</span><span>.</span><span>colorPrintln</span><span>(</span><span>\"第{}次,权重轮训{}\"</span><span>,</span> i<span>,</span> <span>round</span><span>(</span>servers<span>)</span><span>)</span><span>;</span>\n        <span>}</span><span>)</span><span>;</span>\n    <span>}</span>\n\n<span>}</span>\n第<span>0</span>次<span>,</span>权重轮训<span>Server</span><span>{</span>host<span>=</span>'<span>127.0</span><span>.0</span><span>.1</span>'<span>,</span> port<span>=</span><span>80</span><span>}</span>\n第<span>1</span>次<span>,</span>权重轮训<span>Server</span><span>{</span>host<span>=</span>'<span>127.0</span><span>.0</span><span>.1</span>'<span>,</span> port<span>=</span><span>80</span><span>}</span>\n第<span>2</span>次<span>,</span>权重轮训<span>Server</span><span>{</span>host<span>=</span>'<span>127.0</span><span>.0</span><span>.1</span>'<span>,</span> port<span>=</span><span>82</span><span>}</span>\n第<span>3</span>次<span>,</span>权重轮训<span>Server</span><span>{</span>host<span>=</span>'<span>127.0</span><span>.0</span><span>.1</span>'<span>,</span> port<span>=</span><span>82</span><span>}</span>\n第<span>4</span>次<span>,</span>权重轮训<span>Server</span><span>{</span>host<span>=</span>'<span>127.0</span><span>.0</span><span>.1</span>'<span>,</span> port<span>=</span><span>82</span><span>}</span>\n第<span>5</span>次<span>,</span>权重轮训<span>Server</span><span>{</span>host<span>=</span>'<span>127.0</span><span>.0</span><span>.1</span>'<span>,</span> port<span>=</span><span>82</span><span>}</span>\n第<span>6</span>次<span>,</span>权重轮训<span>Server</span><span>{</span>host<span>=</span>'<span>127.0</span><span>.0</span><span>.1</span>'<span>,</span> port<span>=</span><span>82</span><span>}</span>\n第<span>7</span>次<span>,</span>权重轮训<span>Server</span><span>{</span>host<span>=</span>'<span>127.0</span><span>.0</span><span>.1</span>'<span>,</span> port<span>=</span><span>81</span><span>}</span>\n第<span>8</span>次<span>,</span>权重轮训<span>Server</span><span>{</span>host<span>=</span>'<span>127.0</span><span>.0</span><span>.1</span>'<span>,</span> port<span>=</span><span>81</span><span>}</span>\n第<span>9</span>次<span>,</span>权重轮训<span>Server</span><span>{</span>host<span>=</span>'<span>127.0</span><span>.0</span><span>.1</span>'<span>,</span> port<span>=</span><span>81</span><span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br></div></div><p>但这样还是不均匀的, 相同的 ip 可能被连续的访问到其实就没有做到负载均衡。</p>\n<p><strong>平滑加权算法</strong></p>\n<p>主要解决上面那种不平滑的方案。这种方案是由 nginx (opens new window)提出来的。 算法的数学原理。</p>\n<ul>\n<li>最大权重，减总权重</li>\n<li>当前权重加上原权重\n如下权重变化。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>轮数</th>\n<th>选择前的当前权重</th>\n<th>选择节点</th>\n<th>选择后的当前权重</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>{5, 1, 1}</td>\n<td>a</td>\n<td>{-2, 1, 1}</td>\n</tr>\n<tr>\n<td>2</td>\n<td>{3, 2, 2}</td>\n<td>a</td>\n<td>{-4, 2, 2}</td>\n</tr>\n<tr>\n<td>3</td>\n<td>{1, 3, 3}</td>\n<td>b</td>\n<td>{1, -4, 3}</td>\n</tr>\n<tr>\n<td>4</td>\n<td>{6, -3, 4}</td>\n<td>a</td>\n<td>{-1, -3, 4}</td>\n</tr>\n<tr>\n<td>5</td>\n<td>{4, -2, 5}</td>\n<td>c</td>\n<td>{4, -2, -2}</td>\n</tr>\n<tr>\n<td>6</td>\n<td>{9, -1, -1}</td>\n<td>a</td>\n<td>{2, -1, -1}</td>\n</tr>\n<tr>\n<td>7</td>\n<td>{7, 0, 0}</td>\n<td>a</td>\n<td>{0, 0, 0}</td>\n</tr>\n</tbody>\n</table>\n<p>下面我们通过代码来实现。</p>\n<ul>\n<li>首先我们定义出服务器模型, <code>weight</code> 是初始配置的权重，<code>currentWeight</code> 是计算后的权重。</li>\n<li>初始值 <code>weight = currentWeight</code></li>\n</ul>\n<div><pre><code>    <span>@Data</span>\n    <span>@AllArgsConstructor</span>\n    <span>@ToString</span>\n    <span>@EqualsAndHashCode</span>\n    <span>private</span> <span>static</span> <span>class</span> <span>Server</span> <span>{</span>\n        <span>private</span> <span>String</span> host<span>;</span>\n        <span>private</span> <span>Integer</span> port<span>;</span>\n        <span>// 初始化权重</span>\n        <span>private</span> <span>Integer</span> weight<span>;</span>\n        <span>// 计算后的当前权重</span>\n        <span>private</span> <span>Integer</span> currentWeight<span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>然后我们根据算法的核心点来选择节点。这里我们先不考虑性能只说思路，有了思路在自己来优化代码。</p>\n<ol>\n<li><mark>line(3-6)</mark> 首先获取总权重</li>\n<li><mark>line(8-14)</mark> 然后获取当前最大权重的节点</li>\n<li><mark>line(16-21)</mark> 重新计算权重(<code>主要使用算法的思想</code>)\n<ul>\n<li>当前最大权重节点，重新计算权重。当前权重 = 当前权重 - 总权重 + 原始权重</li>\n<li>其他节点，重新计算权重。当前权重 = 当前权重 + 原始权重</li>\n</ul>\n</li>\n</ol>\n<div><div><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br></div><pre><code>    <span>public</span> <span>static</span> <span>Server</span> <span>selectServer</span><span>(</span><span>List</span><span><span>&lt;</span><span>Server</span><span>></span></span> servers<span>)</span> <span>{</span>\n        <span>// 获取总权重</span>\n        <span>Integer</span> totalWeight <span>=</span> <span>0</span><span>;</span>\n        <span>for</span> <span>(</span><span>Server</span> server <span>:</span> servers<span>)</span> <span>{</span>\n            totalWeight <span>+=</span> server<span>.</span><span>getWeight</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>// 根据权重从小到大排序</span>\n        <span>List</span><span><span>&lt;</span><span>Server</span><span>></span></span> sortByCurrentWeight <span>=</span> servers<span>.</span><span>stream</span><span>(</span><span>)</span><span>.</span><span>sorted</span><span>(</span><span>Comparator</span><span>.</span><span>comparing</span><span>(</span><span>Server</span><span>::</span><span>getCurrentWeight</span><span>)</span><span>)</span>\n                <span>.</span><span>collect</span><span>(</span><span>Collectors</span><span>.</span><span>toList</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// 集合反转,从大到小排序</span>\n        <span>Collections</span><span>.</span><span>reverse</span><span>(</span>sortByCurrentWeight<span>)</span><span>;</span>\n        <span>// 当前最大权重</span>\n        <span>Server</span> maxWeightServer <span>=</span> sortByCurrentWeight<span>.</span><span>get</span><span>(</span><span>0</span><span>)</span><span>;</span>\n        <span>// 重新计算权重</span>\n        <span>for</span> <span>(</span><span>Server</span> server <span>:</span> servers<span>)</span> <span>{</span>\n            <span>if</span> <span>(</span>server<span>.</span><span>equals</span><span>(</span>maxWeightServer<span>)</span><span>)</span> <span>{</span>\n                server<span>.</span><span>setCurrentWeight</span><span>(</span>server<span>.</span><span>getCurrentWeight</span><span>(</span><span>)</span> <span>-</span> totalWeight<span>)</span><span>;</span>\n            <span>}</span>\n            server<span>.</span><span>setCurrentWeight</span><span>(</span>server<span>.</span><span>getCurrentWeight</span><span>(</span><span>)</span> <span>+</span> server<span>.</span><span>getWeight</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> maxWeightServer<span>;</span>\n    <span>}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>可以看到非常的平滑均匀，每个 ip 都会被分散。</p>\n<div><pre><code>第0次,平滑权重轮训WeightBalanceTest2.Server(host=127,0,0,1, port=8080, weight=4, currentWeight=1)\n第1次,平滑权重轮训WeightBalanceTest2.Server(host=127,0,0,1, port=8081, weight=2, currentWeight=-1)\n第2次,平滑权重轮训WeightBalanceTest2.Server(host=127,0,0,1, port=8080, weight=4, currentWeight=2)\n第3次,平滑权重轮训WeightBalanceTest2.Server(host=127,0,0,1, port=8082, weight=1, currentWeight=-2)\n第4次,平滑权重轮训WeightBalanceTest2.Server(host=127,0,0,1, port=8080, weight=4, currentWeight=3)\n第5次,平滑权重轮训WeightBalanceTest2.Server(host=127,0,0,1, port=8081, weight=2, currentWeight=0)\n第6次,平滑权重轮训WeightBalanceTest2.Server(host=127,0,0,1, port=8080, weight=4, currentWeight=4)\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>很难想象,手写一个 RPC 框架,执行层所需要的技术储备只有这些而已。可以看出来，重要的是思路，思路决定出路。好了,下面我们就来实现这些思路吧。</p>\n<p>那么你准备好跟我一起 Coding 了吗?</p>\n<p><img src=\"https://img.springlearn.cn/blog/dcdc576db14dda19819196a4dba05a21.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://img.springlearn.cn/blog/d0e05f0a0f96e2399aefe0e8fe00e23c.png",
      "date_published": "2022-09-04T13:51:11.000Z",
      "date_modified": "2022-09-04T13:51:11.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "mojito"
      ]
    },
    {
      "title": "Home",
      "url": "https://java.springlearn.cn/learn/",
      "id": "https://java.springlearn.cn/learn/",
      "content_html": "<Djt/>\n<p><img src=\"https://img.springlearn.cn/blog/a982515ed6df23c14bd77c4e6585ff57.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"\"> <i>Not supported content</i> <i>Not supported content</i>  <i>Not supported content</i> <i>Not supported content</i>  <i>Not supported content</i></h2>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1648909278000.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://img.springlearn.cn/blog/a982515ed6df23c14bd77c4e6585ff57.png",
      "date_published": "2021-12-21T05:46:37.000Z",
      "date_modified": "2022-08-22T01:35:49.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "SpringBoot脚手架【web版本】",
      "url": "https://java.springlearn.cn/learn/project/pangu/",
      "id": "https://java.springlearn.cn/learn/project/pangu/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/b8f74de10af99991e3fc73632eeeb190.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>公众号</strong>: 西魏陶渊明<br/>\n<strong>CSDN</strong>: <a href=\"https://springlearn.blog.csdn.net/?type=blog\" target=\"_blank\" rel=\"noopener noreferrer\">https://springlearn.blog.csdn.net</a><br/></p>\n<blockquote>\n<p>天下代码一大抄, 抄来抄去有提高, 看你会抄不会抄！</p>\n</blockquote>\n<p><img src=\"https://img.springlearn.cn/blog/8f3392b9badb093f9e1a6472b4a98487.gif\" alt=\"\" loading=\"lazy\"></p>\n<p><a href=\"https://github.com/lxchinesszz/pangu-plus\" target=\"_blank\" rel=\"noopener noreferrer\">Gitbub</a></p>\n<h2 id=\"前言\"> 前言</h2>\n<h3 id=\"背景\"> 背景</h3>\n<p>现状1:  乱   同部门项目结构定义各自为战, 没有一个标准化的项目结构\n现状2: 繁    项目定义没有技术难度，且都是这种重复工作劳动, 感觉繁不胜繁</p>\n<p>“删繁就简三秋树，领异标新二月花。”  删繁就简，开辟新路</p>\n<h3 id=\"价值\"> 价值</h3>\n<p>提高生产效率  &amp; 统一标准规范 &amp; 基于标准规范提供通用能力 &amp; 提高影响力</p>\n<p><img src=\"https://img.springlearn.cn/blog/8a43d49b4e8c81c73d781ba427d23179.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"一、spring的设计思路\"> 一、Spring的设计思路</h2>\n<h3 id=\"_1-1-自动装箱\"> 1.1 自动装箱</h3>\n<p>只需要引入<groupId>io.spring.initializr</groupId>相关配置，就具备的脚手架的能力。看起来挺简单的。\n但是, 等等。Spring只提供单一模块的脚手架应用, 这显然不服务我们实际生产的项目结构。要深度定制化开发才能符合我们项目生产结构。\n既然如此我们为啥还要用Spring的框架呢? 两个原因。</p>\n<ol>\n<li>Spring脚手架提供了一个标准的api, 没办法,先入为主，除非美国说要制裁我们。</li>\n<li>Spring的模板的操作提供了面向对象的编程方式，比如我们修改Maven的POM和依赖的信息, 都有面向对象的API方式调用。</li>\n</ol>\n<h2 id=\"二、-一个实际的构建流程是什么样的\"> 二、 一个实际的构建流程是什么样的?</h2>\n<p>https://start.spring.io/starter.zip?type=maven-project&amp;language=java&amp;bootVersion=2.5.2.RELEASE&amp;baseDir=demo&amp;groupId=com.example&amp;artifactId=demo&amp;name=demo&amp;description=Demo%20project%20for%20Spring%20Boot&amp;packageName=com.example.demo&amp;packaging=jar&amp;javaVersion=11&amp;dependencies=session</p>\n<p>依赖中只引入了一个Session。</p>\n<h3 id=\"_2-1-构建的原信息来自哪里\"> 2.1 构建的原信息来自哪里</h3>\n<p>先回答问题,来自于application.yml。这里你可以配置要支持的java版本, Language类型等等\n简单点你在页面看到的都是配置的。</p>\n<h3 id=\"_2-2-spring如何接受到信息\"> 2.2 Spring如何接受到信息</h3>\n<p>Spring提供了一个抽象接口, 和一个限定反省类。<code>ProjectRequest</code> 。 没错你想的没错，页面看到的配置信息都在ProjectRequest 有对应的字段来接受。</p>\n<div><pre><code>public abstract class ProjectGenerationController&lt;R extends ProjectRequest&gt;{}\n</code></pre>\n<div><span>1</span><br></div></div><p>实现抽象类，然后注册成一个Bean。 那么就会自动的替换了系统本来已经提供的默认实现。实现原理就是@ConditionalOnMissingBean</p>\n<h3 id=\"_2-3-配置信息如何最终被解析\"> 2.3 配置信息如何最终被解析</h3>\n<p>前面的请求最中会被转发到 ProjectGenerationInvoker 来代为处理，简单来说就是我们的业务Service。\n关键类来了，请注意:  ProjectDescription。\n这个类会被全局使用, 包含了项目创建的所有信息,包括依赖信息等。那这个时候问题就来了，前端关于依赖只传了一个session, 我们是如何知道这个session所对应的groupId等坐标信息的呢? 看这里\nProjectRequestToDescriptionConverter, 废话不多数，直接看代码。主要观察注释。自己思考。</p>\n<div><pre><code>// 一个请求信息, 一个metadata，这一看就是所有的配置信息\npublic void convert(ProjectRequest request, MutableProjectDescription description, InitializrMetadata metadata) {\n   validate(request, metadata);\n   Version platformVersion = getPlatformVersion(request, metadata);\n   // 根据请求信息去搜索依赖，根据id-&gt;session 就找到 这个session所对应的坐标。\n   List&lt;Dependency&gt; resolvedDependencies = getResolvedDependencies(request, platformVersion, metadata);\n   validateDependencyRange(platformVersion, resolvedDependencies);\n\n   description.setApplicationName(request.getApplicationName());\n   description.setArtifactId(request.getArtifactId());\n   ...\n   resolvedDependencies.forEach((dependency) -&gt; description.addDependency(dependency.getId(),\n         MetadataBuildItemMapper.toDependency(dependency)));\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id=\"_2-4-如果构建maven的模块呢\"> 2.4 如果构建Maven的模块呢?</h3>\n<p><code>ProjectAssetGenerator&lt;T&gt; projectAssetGenerator</code>。经过重重的信息添加, 最终到这里了，这里是我们要进行二次开发的严重地区。</p>\n<h4 id=\"_2-4-1-先看下原始代码\"> 2.4.1 先看下原始代码</h4>\n<p>这里会构建一个单一的模块信息, 这里大家有没有发现点什么?</p>\n<ul>\n<li>ProjectDescription 怎么变成了一个Bean ？</li>\n<li>ProjectContributor 也是一个Bean？</li>\n<li>系统提供了那些ProjectContributor，都是干什么的? 后面我们要基于这个扩展</li>\n</ul>\n<div><pre><code>  public Path generate(ProjectGenerationContext context) throws IOException {\n      ProjectDescription description = context.getBean(ProjectDescription.class);\n      Path projectRoot = resolveProjectDirectoryFactory(context).createProjectDirectory(description);\n      Path projectDirectory = initializerProjectDirectory(projectRoot, description);\n      List&lt;ProjectContributor&gt; contributors = context.getBeanProvider(ProjectContributor.class).orderedStream()\n      .collect(Collectors.toList());\n      for (ProjectContributor contributor : contributors) {\n      contributor.contribute(projectDirectory);\n      }\n      return projectRoot;\n  }\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>问题解答:</p>\n<ol>\n<li>ProjectDescription 怎么变成了一个Bean\nSpring会基于每次的请求,生成ProjectDescription。同时将其注册成为一个Bean。(可以自己去找)</li>\n<li>ProjectContributor 也是一个Bean？\nProjectContributor是提供的一个扩展点, 只有一个方法就是一个目录文件, 由上代码可知,这个目录就是项目目录。 Eg: ascm目录。 (所以如果我们要扩展这里就不能在用根目录了)</li>\n</ol>\n<p><code>void contribute(Path projectRoot) throws IOException;</code></p>\n<ol start=\"3\">\n<li>系统提供了那些ProjectContributor。</li>\n<li>MainSourceCodeCustomizer 看名字就是生成Spring引导类的扩展</li>\n<li>TestSourceCodeProjectContributor  看名字就是生成Spring测试引导类的扩展</li>\n<li>WebFoldersContributor 看名字就是生成web相关目录, 如果发现依赖中有web就...</li>\n<li>ApplicationPropertiesContributor 看名字就是生成配置文件</li>\n<li>HelpDocumentProjectContributor 看名字就是生成帮助文档</li>\n<li>MavenBuildProjectContributor 看名字好像看不出来，其实就是生成pom文件</li>\n<li>MavenWrapperContributor 看名字好像也看不出来，其实就是生成mvnw.cmd 这个没用的东西</li>\n<li>GitIgnoreContributor  看名字 就是生成忽略的目录</li>\n</ol>\n<p>不展开了，代码非常简单。（这句话你别信, 流程很简单，但是细节很丰富, 字越少事越大）</p>\n<div><pre><code>// 流程代码, 可以看到就是实现了MainSourceCodeCustomizer。就是填充启动类代码的代码。\nclass ServletInitializerContributor implements\n      MainSourceCodeCustomizer&lt;TypeDeclaration, CompilationUnit&lt;TypeDeclaration&gt;, SourceCode&lt;TypeDeclaration, CompilationUnit&lt;TypeDeclaration&gt;&gt;&gt; {\n\n \n   @Override\n   public void customize(SourceCode&lt;TypeDeclaration, CompilationUnit&lt;TypeDeclaration&gt;&gt; sourceCode) {\n      CompilationUnit&lt;TypeDeclaration&gt; compilationUnit = sourceCode.createCompilationUnit(this.packageName,\n            &quot;ServletInitializer&quot;);\n      TypeDeclaration servletInitializer = compilationUnit.createTypeDeclaration(&quot;ServletInitializer&quot;);\n      servletInitializer.extend(this.initializerClassName);\n      customizeServletInitializer(servletInitializer);\n   }\n\n   @SuppressWarnings(&quot;unchecked&quot;)\n   private void customizeServletInitializer(TypeDeclaration servletInitializer) {\n      List&lt;ServletInitializerCustomizer&lt;?&gt;&gt; customizers = this.servletInitializerCustomizers.orderedStream()\n            .collect(Collectors.toList());\n      LambdaSafe.callbacks(ServletInitializerCustomizer.class, customizers, servletInitializer)\n            .invoke((customizer) -&gt; customizer.customize(servletInitializer));\n   }\n\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>细节代码，可以看到是面向对象的编程方式。我们不需要使用模板来自己写了。</p>\n<div><pre><code>@Bean\nServletInitializerCustomizer&lt;JavaTypeDeclaration&gt; javaServletInitializerCustomizer(\n      ProjectDescription description) {\n   return (typeDeclaration) -&gt; {\n      typeDeclaration.modifiers(Modifier.PUBLIC);\n      JavaMethodDeclaration configure = JavaMethodDeclaration.method(&quot;configure&quot;)\n            .modifiers(Modifier.PROTECTED)\n            .returning(&quot;org.springframework.boot.builder.SpringApplicationBuilder&quot;)\n            .parameters(new Parameter(&quot;org.springframework.boot.builder.SpringApplicationBuilder&quot;,\n                  &quot;application&quot;))\n            .body(new JavaReturnStatement(new JavaMethodInvocation(&quot;application&quot;, &quot;sources&quot;,\n                  description.getApplicationName() + &quot;.class&quot;)));\n      configure.annotate(Annotation.name(&quot;java.lang.Override&quot;));\n      typeDeclaration.addMethodDeclaration(configure);\n   };\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>但是从中我们学习到的知识是，对于多模块核心模块我们会使用到</p>\n<ul>\n<li>MainSourceCodeCustomizer 看名字就是生成Spring引导类的扩展</li>\n<li>TestSourceCodeProjectContributor  看名字就是生成Spring测试引导类的扩展</li>\n<li>WebFoldersContributor 看名字就是生成web相关目录, 如果发现依赖中有web就...</li>\n<li>ApplicationPropertiesContributor 看名字就是生成配置文件\n对于父目录</li>\n<li>HelpDocumentProjectContributor 这里要替换成我们自己的模板要进行二次开发</li>\n<li>MavenBuildProjectContributor 二次开发，不能用系统提供的Maven信息., 因为系统提供的是单模块的pom</li>\n<li>MavenWrapperContributor 感觉没啥用</li>\n<li>GitIgnoreContributor  改动比较小，不改也没关系</li>\n</ul>\n<h4 id=\"_2-4-2-改动后的代码-支持多模块\"> 2.4.2 改动后的代码，支持多模块</h4>\n<p>MavenModuleFactory 将单一模块转换成多模块，并为每个模块生成一个执行方法。\n其实就是将原来的代码, 封装到每个Module里面，然后填充上自己的扩展信息。</p>\n<div><pre><code>public Path generate(ProjectGenerationContext context) throws IOException {\n    ProjectDescription description = context.getBean(ProjectDescription.class);\n    Path projectRoot = resolveProjectDirectoryFactory(context).createProjectDirectory(description);\n    // 1. 先创建项目根目录\n    Path projectDirectory = initializerProjectDirectory(projectRoot, description);\n    // 2. 构建依赖关系\n    MavenModuleFactory mavenModuleFactory = new MavenModuleFactory(context, projectDirectory);\n    List&lt;ModuleGeneratorExecute&gt; modules = mavenModuleFactory.getModule();\n    for (ModuleGeneratorExecute module : modules) {\n        module.generator();\n    }\n    return projectRoot;\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>抽象出多模块的实体。</p>\n<p><img src=\"https://img.springlearn.cn/blog/45de2b1a0567e0f3a5c6aa872544a773.png\" alt=\"\" loading=\"lazy\"></p>\n<p>Module和Module是关联关系, 所以看到Module和AbstractModuleTemplate直接由一个组合的虚线关系。</p>\n<p><img src=\"https://img.springlearn.cn/blog/3df53e4f6f20506c089010a357dc17ac.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_2-5-文件生成\"> 2.5 文件生成</h3>\n<p>到这里文件已经生成了，已经在服务端生成了一个具有Maven结构的项目。但这个时候他是在服务起的\n某个随机的目录下面的，就需要在将其转换成二进制数据, 传给前端。到此流程结束。</p>\n<h2 id=\"三、二次开发提供的扩展点\"> 三、二次开发提供的扩展点</h2>\n<h3 id=\"_3-1-为某个模块定制pom信息。\"> 3.1 为某个模块定制POM信息。</h3>\n<p>将用户选择的的依赖信息, 转移到具体某个Module上。具体要转移什么由你决定。</p>\n<div><pre><code>public interface MavenModuleBuildCustomizer {\n\n    /**\n     * 初始时候,moduleMavenBuild是没有任何信息的,需要开发者\n     * 自定义的将parentMavenBuild的信息,同步到parentMavenBuild\n     *\n     * @param parentMavenBuild 全局的maven配置信息\n     * @param moduleMavenBuild 每个module配置\n     */\n    void customize(MavenBuild parentMavenBuild, MavenBuild moduleMavenBuild);\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id=\"_3-2-为某个模块创建目录\"> 3.2 为某个模块创建目录</h3>\n<p>可以参考 <code>MainSourceCodeCustomizer</code> 的实现方案，如果用面向对象的方式生成代码，也可以参照\nGitIgnoreContributor的方式, 直接通过模板文件来生成文件。</p>\n<div><pre><code>public interface ProjectContributor extends Ordered {\n\n   /**\n    * Contribute additional resources to the project in the specified root directory.\n    * @param projectRoot the root directory of the project\n    * @throws IOException if contributing a resource failed\n    */\n   void contribute(Path projectRoot) throws IOException;\n\n   @Override\n   default int getOrder() {\n      return 0;\n   }\n\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h2 id=\"四、前端定制\"> 四、前端定制</h2>\n<p><img src=\"https://img.springlearn.cn/blog/49e9c4466a948891f6bc24d1909ce05d.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_4-1-原数据信息\"> 4.1 原数据信息</h3>\n<ul>\n<li>Spring的版本信息和依赖等相关信息, 可以通过配置方式来解决</li>\n<li>代码配置，供应链可以共建,  需要自己去开发需要往每个模块要写的内容。</li>\n</ul>\n<h2 id=\"五、扩展点\"> 五、扩展点</h2>\n<p>对Module进行扩展,可以往Module的pom文件中添加信息\n<img src=\"https://img.springlearn.cn/blog/26ea572ed526229b3c14b73f6ffc7343.png\" alt=\"\" loading=\"lazy\">\n对Module进行扩展,可以向指定的包中添加信息</p>\n<p><img src=\"https://img.springlearn.cn/blog/f44e44f2678ec2e5745996ee8691b794.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://img.springlearn.cn/blog/b8f74de10af99991e3fc73632eeeb190.png",
      "date_published": "2023-02-08T06:41:30.000Z",
      "date_modified": "2023-02-08T06:41:30.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "匆匆那年",
      "url": "https://java.springlearn.cn/learn/school/students/",
      "id": "https://java.springlearn.cn/learn/school/students/",
      "content_html": "<ol>\n<li>介绍下自己的学习情况</li>\n<li>大学生的迷茫不是问题，问题要如何正确面对</li>\n<li>大学生要知道学习</li>\n</ol>\n",
      "date_published": "2021-12-21T05:46:37.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "第04篇:手写JavaRPC框架之搞定网络通信",
      "url": "https://java.springlearn.cn/learn/project/mojito/%E7%AC%AC04%E7%AF%87:%E6%89%8B%E5%86%99JavaRPC%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%90%9E%E5%AE%9A%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/",
      "id": "https://java.springlearn.cn/learn/project/mojito/%E7%AC%AC04%E7%AF%87:%E6%89%8B%E5%86%99JavaRPC%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%90%9E%E5%AE%9A%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/26890ec0ad52a3b8bb3c0470c43c95a5.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者:</strong> 西魏陶渊明</p>\n<p><strong>博客:</strong> https://blog.springlearn.cn/</p>\n<blockquote>\n<p>天下代码一大抄, 抄来抄去有提高, 看你会抄不会抄！</p>\n</blockquote>\n<p><img src=\"https://img.springlearn.cn/blog/8f3392b9badb093f9e1a6472b4a98487.gif\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"一、前言\"> 一、前言</h2>\n<ul>\n<li>听说你Sql写的很溜，那么你知道服务端的Sql是如何被传输到SQL服务器执行的吗?</li>\n<li>听说你10分钟能写两个接口，那你知道数据是如何在两个系统中通讯的吗?</li>\n<li>听说你微服务玩的很熟练,那你知道微服务的基础是什么吗?</li>\n</ul>\n<p>可以这样说，我们写的任何系统都离不开通讯，离不开网络编程，就没有现在我们发达的互联网世界。就没有什么分布式，没有什么微服务。所以由此可见网络编程是非常基础的知识。</p>\n<p>但是我们思考下，<code>有多少同学真正使用过Java网络通信的API了呢</code>? 相信百分之80的小伙伴可能都没用过? 为什么呢? 因为我们站在巨人的肩膀上, 底层的代码都被层层的封装起来了,为了使我们能专注于业务的开发。这虽然提高了我们的开发效率。但是呢? 从另一个方面讲,他不利于我们的技术成长,使我们只会用，而不去思考为什么这么用。逐渐沦为CRUD Body。</p>\n<p>个人如果想成长，想打破这种现状, 那么网络通信是一定要掌握的，当你掌握了这些，才算掌握了一点核心技术。当你掌握了这些，才能收获一些不一样的东西，看问题的维度又会有所提升。</p>\n<p>本系列文章, 我们会一起来写RPC框架,而网络通讯是必要要掌握的知识,如果说以前你不懂,那么没关系跟着小编来Coding。我们一起来从0到1搭建一个网络通信层,然后以此为基础实现一个Java RPC框架吧。</p>\n<h2 id=\"二、目标\"> 二、目标</h2>\n<h3 id=\"_2-1-目标介绍\"> 2.1 目标介绍</h3>\n<p><img src=\"https://img.springlearn.cn/blog/8a2630c9ab3f4e155e02c2f11d4ce632.png\" alt=\"\" loading=\"lazy\"></p>\n<p>本篇文章是我们的第四篇，内容主要是实现网络通讯。通信层框架主要使用的是Netty进行实现, 说到Netty可能很多同学都没有用过。而要想实现通讯Netty就必须要知道，所以本篇内容篇幅较多。</p>\n<ul>\n<li>第一个目标,快速学习Netty的架构,掌握Netty 核心的API,最终唯我所用。</li>\n<li>第二个目标,使用Netty完成我们的通信层。</li>\n</ul>\n<p>内容非常的硬核,难度指数比较大,也主要是偏向于实战。请专注学习,内容中如果有差错,欢迎提出。小编会积极回复,并改正。</p>\n<h2 id=\"三、netty-api-学习\"> 三、Netty API 学习</h2>\n<p><img src=\"https://img.springlearn.cn/blog/70b0a4323f80010510da069e00929af9.png\" alt=\"\" loading=\"lazy\"></p>\n<p>前面第三篇我们学习了搞定序列化,在上一篇中我们介绍了这幅图,序列化就是将数据转换成二进制数据,在网络管道中传输。今天开头还是这一张图, 不过今天要说的不在是里面的数据,而是要研究下如何来构建一个通信的管道。本篇文章我们要利用Netty搭建一个网络管道。</p>\n<p><img src=\"https://img.springlearn.cn/blog/625f13664d5fcbe898413cfc4884ac5f.png\" alt=\"\" loading=\"lazy\"></p>\n<p>这张图是对第一张图的一个细化，可以看到在这个管道的里面有一个双向的数据流【双工】。</p>\n<p>客服端向服务端发送数据，服务端也可以同时向客户端发送数据。这个过程叫做全双工。为什么呢? 因为这个管道是TCP管道。我们所知道的Dubbo也是在此基础上实现的。所以说dubbo和http是平级的关系。</p>\n<ul>\n<li>一个inbound入栈方向，负责将二进制数据转换成Java对象</li>\n<li>一个outbound出库方向，负责将Java对象转换成二进制对象</li>\n</ul>\n<h3 id=\"_3-1-channelpipeline-网络管道\"> 3.1 ChannelPipeline 网络管道</h3>\n<p>上面的那个管道在Netty中就是 <code>ChannelPipeline</code>, <code>ChannelPipeline</code> 是Netty 中一个非常重要的组件,我们说的管道,就可以理解成是这个类，在这个管道中有两个方向的流向。如下</p>\n<ul>\n<li>ChannelInboundHandler   入栈</li>\n<li>ChannelOutboundHandler  出栈</li>\n</ul>\n<p>只有管道还不行，要对管道中流动的数据进行处理。怎么来处理呢? 就是 <code>ChannelHandler</code></p>\n<h3 id=\"_3-2-channelhandler-管道处理器\"> 3.2 ChannelHandler 管道处理器</h3>\n<p><code>ChannelHandle</code> 通道处理器是最顶层接口, <code>ChannelHandler</code> 和 <code>ChannelPipeline</code> 的关系,好比这张图。</p>\n<p><code>ChannelPipeline</code> 相当于是管道,而 <code>ChannelHandler</code> 相当于管道中的每个拦路虎, 通过对数据的拦截,然后进行处理。下面这张图比较形象。</p>\n<p><img src=\"https://img.springlearn.cn/blog/064c7be3d1767d991e0fc467ad9d123f.png\" alt=\"\" loading=\"lazy\"></p>\n<p><code>Netty</code> 要想学的好, <code>ChannelHandler</code> 学习不能少,下面是 <code>Netty</code> 中 <code>ChannelHandler</code> 的类关系图。想要处理数据只用继承这其中的一些类就可以了。</p>\n<p><img src=\"https://img.springlearn.cn/blog/5aefc5608f7d907c36fb247257affc6d.png\" alt=\"\" loading=\"lazy\"></p>\n<p>请记住这张图,我们下面会利用这些管道处理器来实现我们的网络通信。</p>\n<h3 id=\"_3-3-入栈管道解码器\"> 3.3 入栈管道解码器</h3>\n<blockquote>\n<p>编码器本质上就是一个 <code>ChannelHandler</code>, 所以上图我们也能看出来它是实现了 <code>ChannelHandler</code>的。</p>\n</blockquote>\n<p>二进制数据转换成Java对象就要我们来搞一个入栈的解码器,通过上面的图我们知道Netty给我们提供了一个\n入栈方向的类。<code>ByteToMessageDecoder</code>。那么我们就先实现他,直接看代码。</p>\n<div><pre><code>/**\n * 请求解码器负责将二进制数据转换成能处理的协议\n * 个人博客：https://java.springlearn.cn\n * 公众号：西魏陶渊明  ｛关注获取学习源码｝\n */\n@Slf4j\npublic abstract class ChannelDecoder extends ByteToMessageDecoder {\n\n    /**\n     * 解码方法\n     *\n     * @param ctx 通道上下文信息\n     * @param in  网络传过来的信息(注意粘包和拆包问题)\n     * @param out in中的数据转换成对象调用out.add方法\n     * @throws Exception 未知异常\n     */\n    @Override\n    public void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception {\n        doDecode(ctx, in, out);\n    }\n\n\n    /**\n     * 解码方法\n     *\n     * @param ctx 通道上下文信息\n     * @param in  网络传过来的信息(注意粘包和拆包问题)\n     * @param out in中的数据转换成对象调用out.add方法\n     * @throws Exception 未知异常\n     */\n    protected abstract void doDecode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception;\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><ul>\n<li>\n<p>doDecode 方法,通过读取ByteBuf中数据,然后经过的<strong>规则处理,就是协议处理,然后反序列化成Java对象</strong>,然后调用out.add()。</p>\n</li>\n<li>\n<p>这个规则处理，就是协议，我们在本系列文章的第二篇,就说了我们的协议是什么,如下这张图。那么我们就按照这个规则来解析数据吧。</p>\n</li>\n</ul>\n<p><img src=\"https://img.springlearn.cn/blog/18634a291755ae51cd4e6ef64b0a8ac8.png\" alt=\"\" loading=\"lazy\"></p>\n<ul>\n<li>实际上这里我们还要面对黏包和拆包的问题。什么是黏包和拆包呢？</li>\n</ul>\n<h3 id=\"_3-4-黏包和拆包及解决方案\"> 3.4 黏包和拆包及解决方案</h3>\n<p>我们举一个例子,前两天某某国前首相安老三,遇到刺客了。这时候你很悲伤想发一个说说: 只要人没事就好。</p>\n<p><strong>拆包:</strong></p>\n<p>只要人没事就好 = 只要人没 + 事就好。\n<img src=\"https://img.springlearn.cn/blog/ffc187f8f60e18c0ac897034f3e8960f.png\" alt=\"\" loading=\"lazy\"></p>\n<p>就是形容一条完整的数据报文,因为某些原因,数据被分成多段进行传输了,当你读取数据的时候,读到的不是完整的数据，而是一半的数据。此时意思就比较尴尬了。只要人没，事就好 😂。</p>\n<p><strong>黏包:</strong></p>\n<p><img src=\"https://img.springlearn.cn/blog/5f4bdcf9294c387b03c9d89dc1a08383.png\" alt=\"\" loading=\"lazy\"></p>\n<p>两条报文,连在一起发送了。导致了意思大变样。</p>\n<p>就是数据都在网络管道中传输，但是我们服务定位每个报文的长度，导致了读取的数据就是混乱的。</p>\n<p>那么拆包和黏包的问题我们都知道了,下面直接说解决方案吧。在Netty中有如下解决方案。</p>\n<p><img src=\"https://img.springlearn.cn/blog/5c524dee4dd0fb65d9f031bae5cd8030.png\" alt=\"\" loading=\"lazy\"></p>\n<ol>\n<li>LineBasedFrameDecoder</li>\n</ol>\n<p>遇到了换行符，就当做是一条完整的消息</p>\n<div><pre><code>    <span>@Test</span>\n    <span>@DisplayName</span><span>(</span><span>\"使用换行符分隔符\"</span><span>)</span>\n    <span>void</span> <span>lineBasedFrameDecoder</span><span>(</span><span>)</span> <span>{</span>\n        <span>int</span> maxLength <span>=</span> <span>100</span><span>;</span>\n        <span>ByteBuf</span> buffer <span>=</span> <span>ByteBufAllocator</span><span>.</span>DEFAULT<span>.</span><span>buffer</span><span>(</span><span>)</span><span>;</span>\n        buffer<span>.</span><span>writeBytes</span><span>(</span><span>\"hello world\\nhello\\nworld\\n\"</span><span>.</span><span>getBytes</span><span>(</span><span>StandardCharsets</span><span>.</span>UTF_8<span>)</span><span>)</span><span>;</span>\n        <span>EmbeddedChannel</span> channel <span>=</span> <span>new</span> <span>EmbeddedChannel</span><span>(</span><span>new</span> <span>LoggingHandler</span><span>(</span><span>LogLevel</span><span>.</span>DEBUG<span>)</span><span>,</span>\n                <span>new</span> <span>LineBasedFrameDecoder</span><span>(</span>maxLength<span>)</span><span>,</span>\n                <span>new</span> <span>ChannelInboundHandlerAdapter</span><span>(</span><span>)</span> <span>{</span>\n                    <span>@Override</span>\n                    <span>public</span> <span>void</span> <span>channelRead</span><span>(</span><span>ChannelHandlerContext</span> ctx<span>,</span> <span>Object</span> msg<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n                        <span>ByteBuf</span> buf <span>=</span> <span>(</span><span>(</span><span>ByteBuf</span><span>)</span> msg<span>)</span><span>;</span>\n                        <span>String</span> content <span>=</span> buf<span>.</span><span>toString</span><span>(</span><span>StandardCharsets</span><span>.</span>UTF_8<span>)</span><span>;</span>\n                        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>content<span>)</span><span>;</span>\n                    <span>}</span>\n                <span>}</span><span>)</span><span>;</span>\n<span>//        hello world</span>\n<span>//        hello </span>\n<span>//        world</span>\n        channel<span>.</span><span>writeInbound</span><span>(</span><span>ByteBufAllocator</span><span>.</span>DEFAULT<span>.</span><span>buffer</span><span>(</span><span>)</span><span>.</span><span>writeBytes</span><span>(</span>buffer<span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><ol start=\"2\">\n<li>DelimiterBasedFrameDecoder</li>\n</ol>\n<p>遇到了分隔符，就当做是一条完整的消息,分隔符可以自定义。我们可以指定多个分隔符,如下示例。</p>\n<div><pre><code>    <span>@Test</span>\n    <span>@DisplayName</span><span>(</span><span>\"自定义换行符分隔符\"</span><span>)</span>\n    <span>void</span> <span>delimiterBasedFrameDecoder</span><span>(</span><span>)</span> <span>{</span>\n        <span>int</span> maxLength <span>=</span> <span>100</span><span>;</span>\n        <span>ByteBuf</span> buffer <span>=</span> <span>ByteBufAllocator</span><span>.</span>DEFAULT<span>.</span><span>buffer</span><span>(</span><span>)</span><span>;</span>\n        buffer<span>.</span><span>writeBytes</span><span>(</span><span>\"hello world\\nhello\\rworld\\\\\"</span><span>.</span><span>getBytes</span><span>(</span><span>StandardCharsets</span><span>.</span>UTF_8<span>)</span><span>)</span><span>;</span>\n        <span>ByteBuf</span> delimeter1 <span>=</span> <span>Unpooled</span><span>.</span><span>buffer</span><span>(</span><span>)</span><span>.</span><span>writeBytes</span><span>(</span><span>\"\\n\"</span><span>.</span><span>getBytes</span><span>(</span><span>StandardCharsets</span><span>.</span>UTF_8<span>)</span><span>)</span><span>;</span>\n        <span>ByteBuf</span> delimeter2 <span>=</span> <span>Unpooled</span><span>.</span><span>buffer</span><span>(</span><span>)</span><span>.</span><span>writeBytes</span><span>(</span><span>\"\\r\"</span><span>.</span><span>getBytes</span><span>(</span><span>StandardCharsets</span><span>.</span>UTF_8<span>)</span><span>)</span><span>;</span>\n        <span>ByteBuf</span> delimeter3 <span>=</span> <span>Unpooled</span><span>.</span><span>buffer</span><span>(</span><span>)</span><span>.</span><span>writeBytes</span><span>(</span><span>\"\\\\\"</span><span>.</span><span>getBytes</span><span>(</span><span>StandardCharsets</span><span>.</span>UTF_8<span>)</span><span>)</span><span>;</span>\n        <span>EmbeddedChannel</span> channel <span>=</span> <span>new</span> <span>EmbeddedChannel</span><span>(</span><span>new</span> <span>LoggingHandler</span><span>(</span><span>LogLevel</span><span>.</span>DEBUG<span>)</span><span>,</span>\n                <span>new</span> <span>DelimiterBasedFrameDecoder</span><span>(</span>maxLength<span>,</span> delimeter1<span>,</span> delimeter2<span>,</span> delimeter3<span>)</span><span>,</span>\n                <span>new</span> <span>ChannelInboundHandlerAdapter</span><span>(</span><span>)</span> <span>{</span>\n                    <span>@Override</span>\n                    <span>public</span> <span>void</span> <span>channelRead</span><span>(</span><span>ChannelHandlerContext</span> ctx<span>,</span> <span>Object</span> msg<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n                        <span>ByteBuf</span> buf <span>=</span> <span>(</span><span>(</span><span>ByteBuf</span><span>)</span> msg<span>)</span><span>;</span>\n                        <span>String</span> content <span>=</span> buf<span>.</span><span>toString</span><span>(</span><span>StandardCharsets</span><span>.</span>UTF_8<span>)</span><span>;</span>\n                        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>content<span>)</span><span>;</span>\n                    <span>}</span>\n                <span>}</span><span>)</span><span>;</span>\n<span>//        hello world</span>\n<span>//        hello</span>\n<span>//        world</span>\n        channel<span>.</span><span>writeInbound</span><span>(</span><span>ByteBufAllocator</span><span>.</span>DEFAULT<span>.</span><span>buffer</span><span>(</span><span>)</span><span>.</span><span>writeBytes</span><span>(</span>buffer<span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><ol start=\"3\">\n<li>FixedLengthFrameDecoder</li>\n</ol>\n<p>固定长度对消息进行拆分</p>\n<div><pre><code>    <span>@Test</span>\n    <span>@DisplayName</span><span>(</span><span>\"固定长度进行拆解\"</span><span>)</span>\n    <span>void</span> <span>fixedLengthFrameDecoder</span><span>(</span><span>)</span> <span>{</span>\n        <span>//这里每条消息设置的固定长度是5</span>\n        <span>EmbeddedChannel</span> channel <span>=</span> <span>new</span> <span>EmbeddedChannel</span><span>(</span><span>new</span> <span>LoggingHandler</span><span>(</span><span>LogLevel</span><span>.</span>DEBUG<span>)</span><span>,</span> <span>new</span> <span>FixedLengthFrameDecoder</span><span>(</span><span>5</span><span>)</span><span>,</span>\n                <span>new</span> <span>ChannelInboundHandlerAdapter</span><span>(</span><span>)</span> <span>{</span>\n                    <span>@Override</span>\n                    <span>public</span> <span>void</span> <span>channelRead</span><span>(</span><span>ChannelHandlerContext</span> ctx<span>,</span> <span>Object</span> msg<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n                        <span>ByteBuf</span> buf <span>=</span> <span>(</span><span>(</span><span>ByteBuf</span><span>)</span> msg<span>)</span><span>;</span>\n                        <span>String</span> content <span>=</span> buf<span>.</span><span>toString</span><span>(</span><span>StandardCharsets</span><span>.</span>UTF_8<span>)</span><span>;</span>\n                        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>content<span>)</span><span>;</span>\n                    <span>}</span>\n                <span>}</span><span>)</span><span>;</span>\n<span>//        hello</span>\n<span>//        world</span>\n<span>//        welco</span>\n        channel<span>.</span><span>writeInbound</span><span>(</span><span>ByteBufAllocator</span><span>.</span>DEFAULT<span>.</span><span>buffer</span><span>(</span><span>)</span><span>.</span><span>writeBytes</span><span>(</span><span>\"helloworldwelcome\"</span><span>.</span><span>getBytes</span><span>(</span><span>StandardCharsets</span><span>.</span>UTF_8<span>)</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><ol start=\"4\">\n<li>LengthFieldBasedFrameDecoder</li>\n</ol>\n<p>消息分为两部分，一部分为消息头部，一部分为实际的消息体。其中消息头部是固定长度的，消息体是可变的，且消息头部一般会包含一个Length字段。</p>\n<div><pre><code>    <span>@Test</span>\n    <span>@DisplayName</span><span>(</span><span>\"动态获取长度报文\"</span><span>)</span>\n    <span>void</span> <span>lengthFieldBasedFrameDecoder</span><span>(</span><span>)</span> <span>{</span>\n        <span>ByteBuf</span> buffer <span>=</span> <span>ByteBufAllocator</span><span>.</span>DEFAULT<span>.</span><span>buffer</span><span>(</span><span>)</span><span>;</span>\n        <span>byte</span><span>[</span><span>]</span> bytes <span>=</span> <span>\"hello world\"</span><span>.</span><span>getBytes</span><span>(</span><span>StandardCharsets</span><span>.</span>UTF_8<span>)</span><span>;</span>\n        <span>// 11</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>bytes<span>.</span>length<span>)</span><span>;</span>\n        <span>// 4字节</span>\n        buffer<span>.</span><span>writeInt</span><span>(</span>bytes<span>.</span>length<span>)</span><span>;</span>\n        <span>// 真正的数据</span>\n        buffer<span>.</span><span>writeBytes</span><span>(</span>bytes<span>)</span><span>;</span>\n        <span>// 最大包长100字节</span>\n        <span>int</span> maxFrameLength <span>=</span> <span>100</span><span>;</span>\n        <span>// 从0开始,说明开头就是长度</span>\n        <span>int</span> lengthFieldOffset <span>=</span> <span>0</span><span>;</span>\n        <span>// 0 说明, 报文是有长度+真实数据组成的,没有其他的东西</span>\n        <span>int</span> lengthAdjustment <span>=</span> <span>0</span><span>;</span>\n        <span>// 跳过长度的字节，因为是int,所以是4字节</span>\n        <span>int</span> initialBytesToStrip <span>=</span> <span>4</span><span>;</span>\n        <span>EmbeddedChannel</span> channel <span>=</span> <span>new</span> <span>EmbeddedChannel</span><span>(</span><span>new</span> <span>LoggingHandler</span><span>(</span><span>LogLevel</span><span>.</span>DEBUG<span>)</span><span>,</span>\n                <span>new</span> <span>LengthFieldBasedFrameDecoder</span><span>(</span>maxFrameLength<span>,</span> lengthFieldOffset<span>,</span> <span>4</span><span>,</span> lengthAdjustment<span>,</span> initialBytesToStrip<span>)</span><span>,</span>\n                <span>new</span> <span>ChannelInboundHandlerAdapter</span><span>(</span><span>)</span> <span>{</span>\n                    <span>@Override</span>\n                    <span>public</span> <span>void</span> <span>channelRead</span><span>(</span><span>ChannelHandlerContext</span> ctx<span>,</span> <span>Object</span> msg<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n                        <span>ByteBuf</span> buf <span>=</span> <span>(</span><span>(</span><span>ByteBuf</span><span>)</span> msg<span>)</span><span>;</span>\n                        <span>String</span> content <span>=</span> buf<span>.</span><span>toString</span><span>(</span><span>StandardCharsets</span><span>.</span>UTF_8<span>)</span><span>;</span>\n                        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>content<span>)</span><span>;</span>\n                    <span>}</span>\n                <span>}</span><span>)</span><span>;</span>\n        channel<span>.</span><span>writeInbound</span><span>(</span><span>ByteBufAllocator</span><span>.</span>DEFAULT<span>.</span><span>buffer</span><span>(</span><span>)</span><span>.</span><span>writeBytes</span><span>(</span>buffer<span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p>好了，其实知道了问题产生的原因和已有的解决方案,我们也可以自己重新实现一个拆包和解包的方案,本篇文章我们就会自己来实现一个,具体的思路就是如下。</p>\n<p><img src=\"https://img.springlearn.cn/blog/a2c1c8bbf671ff14ca696b3f3f859991.png\" alt=\"\" loading=\"lazy\"></p>\n<p>看起来思路是不是很简单? 底层的API可不简单哦,记得自己看代码,建议拉下来自己走走。</p>\n<h3 id=\"_3-5-入栈管道处理器\"> 3.5 入栈管道处理器</h3>\n<p><img src=\"https://img.springlearn.cn/blog/3f44224aef8f9ce7a44cc43c88fa75db.png\" alt=\"\" loading=\"lazy\">\n二进制数据经过前面的解码器,就会转换成Object对象。此时我们下一个处理器就可以直接处理这个Object对象了。此时我们可以来继承 <code>SimpleChannelInboundHandler</code>。自定义一个泛型。如下示例。我们演示下二进制数据转Java对象,并传给我们的业务处理器。</p>\n<ul>\n<li>fillProtocol 首先我们按照我们定义的规则来，生成二进制数据流。</li>\n<li>然后解析成Java对象,并传给我们的处理器。</li>\n</ul>\n<div><pre><code>  <span>/**\n   * 请求解码器负责将二进制数据转换成能处理的协议\n   * 虫洞栈：https://java.springlearn.cn\n   * 公众号：西魏陶渊明  ｛关注获取学习源码｝\n   */</span>\n  <span>private</span> <span>ByteBuf</span> <span>fillProtocol</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>ByteBuf</span> buffer <span>=</span> <span>ByteBufAllocator</span><span>.</span>DEFAULT<span>.</span><span>buffer</span><span>(</span><span>)</span><span>;</span>\n        <span>RpcRequest</span> rpcRequest <span>=</span> <span>new</span> <span>RpcRequest</span><span>(</span><span>)</span><span>;</span>\n        <span>//1. 获取协议类型(1个字节)</span>\n        buffer<span>.</span><span>writeByte</span><span>(</span>rpcRequest<span>.</span><span>getProtocolType</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>//2. 获取序列化类型(1个字节)</span>\n        buffer<span>.</span><span>writeByte</span><span>(</span>rpcRequest<span>.</span><span>getSerializationType</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>//3. 根据序列化类型找到数据转换器生成二进制数据</span>\n        <span>Serializer</span> serializer <span>=</span> <span>SerializeEnum</span><span>.</span>\n                <span>ofByType</span><span>(</span>rpcRequest<span>.</span><span>getSerializationType</span><span>(</span><span>)</span><span>)</span>\n                <span>.</span><span>getSerialize</span><span>(</span><span>)</span><span>.</span><span>newInstance</span><span>(</span><span>)</span><span>;</span>\n        <span>byte</span><span>[</span><span>]</span> data <span>=</span> serializer<span>.</span><span>serialize</span><span>(</span>rpcRequest<span>)</span><span>;</span>\n        <span>//4. 写入报文长度(4个字节)</span>\n        buffer<span>.</span><span>writeInt</span><span>(</span>data<span>.</span>length<span>)</span><span>;</span>\n        <span>//5. 写入报文内容(数组)</span>\n        buffer<span>.</span><span>writeBytes</span><span>(</span>data<span>)</span><span>;</span>\n        <span>return</span> buffer<span>;</span>\n    <span>}</span>\n\n    <span>@Test</span>\n    <span>@DisplayName</span><span>(</span><span>\"SimpleChannelInboundHandler自动匹配支持的Java对象\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>test</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>// 根据自定义协议生成二进制数据流</span>\n        <span>ByteBuf</span> byteBuf <span>=</span> <span>fillProtocol</span><span>(</span><span>)</span><span>;</span>\n        <span>EmbeddedChannel</span> channel <span>=</span> <span>new</span> <span>EmbeddedChannel</span><span>(</span><span>new</span> <span>LoggingHandler</span><span>(</span><span>LogLevel</span><span>.</span>DEBUG<span>)</span><span>,</span>\n                <span>new</span> <span>ChannelInitializer</span><span><span>&lt;</span><span>EmbeddedChannel</span><span>></span></span><span>(</span><span>)</span> <span>{</span>\n                    <span>@Override</span>\n                    <span>protected</span> <span>void</span> <span>initChannel</span><span>(</span><span>EmbeddedChannel</span> ch<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n                        <span>ChannelPipeline</span> pipeline <span>=</span> ch<span>.</span><span>pipeline</span><span>(</span><span>)</span><span>;</span>\n                        pipeline<span>.</span><span>addLast</span><span>(</span><span>\"a handler\"</span><span>,</span> <span>new</span> <span>MojitoChannelDecoder</span><span>(</span><span>\"mojito\"</span><span>)</span><span>)</span><span>;</span>\n                        pipeline<span>.</span><span>addLast</span><span>(</span><span>\"b handler\"</span><span>,</span><span>// 自定义一个String类型的</span>\n                                <span>new</span> <span>SimpleChannelInboundHandler</span><span><span>&lt;</span><span>RpcRequest</span><span>></span></span><span>(</span><span>)</span> <span>{</span>\n                                    <span>@Override</span>\n                                    <span>protected</span> <span>void</span> <span>channelRead0</span><span>(</span><span>ChannelHandlerContext</span> ctx<span>,</span> <span>RpcRequest</span> msg<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n                                        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"RpcRequest:\"</span> <span>+</span> msg<span>)</span><span>;</span>\n                                        <span>// 向下传播</span>\n                                        ctx<span>.</span><span>fireChannelRead</span><span>(</span>msg<span>)</span><span>;</span>\n                                    <span>}</span>\n                                <span>}</span><span>)</span><span>;</span>\n                        pipeline<span>.</span><span>addLast</span><span>(</span><span>\"c handler\"</span><span>,</span> <span>new</span> <span>SimpleChannelInboundHandler</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>(</span><span>)</span> <span>{</span>\n                            <span>@Override</span>\n                            <span>protected</span> <span>void</span> <span>channelRead0</span><span>(</span><span>ChannelHandlerContext</span> ctx<span>,</span> <span>Integer</span> msg<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n                                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Integer:\"</span> <span>+</span> msg<span>)</span><span>;</span>\n                            <span>}</span>\n                        <span>}</span><span>)</span><span>;</span>\n                    <span>}</span>\n                <span>}</span><span>)</span><span>;</span>\n        channel<span>.</span><span>writeInbound</span><span>(</span><span>ByteBufAllocator</span><span>.</span>DEFAULT<span>.</span><span>buffer</span><span>(</span><span>)</span><span>.</span><span>writeBytes</span><span>(</span>byteBuf<span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br></div></div><ul>\n<li>b handler 的泛型是RpcRequest,二进制数据经过MojitoChannelDecoder将数据转换成RpcRequest对象,此时就会进到b handler。</li>\n<li>而在b handler中我们继续调用方法向下传播数据。<code>ctx.fireChannelRead(msg)</code>。会发现c handler并没有执行,为什么呢? 因为SimpleChannelInboundHandler有一个特性,就是只有数据类型为自己定义的泛型的时候才会进入。</li>\n</ul>\n<p>如下源码也比较简单，这个特性我们可以抄一下, 可以用到我们需要的地方。</p>\n<p><code>TypeParameterMatcher.find(this, SimpleChannelInboundHandler.class, &quot;I&quot;);</code></p>\n<p>读取泛型类型。</p>\n<div><pre><code><span>public</span> <span>abstract</span> <span>class</span> <span>SimpleChannelInboundHandler</span><span><span>&lt;</span><span>I</span><span>></span></span> <span>extends</span> <span>ChannelInboundHandlerAdapter</span> <span>{</span>\n\n     <span>private</span> <span>final</span> <span>TypeParameterMatcher</span> matcher<span>;</span>\n \n     <span>protected</span> <span>SimpleChannelInboundHandler</span><span>(</span><span>boolean</span> autoRelease<span>)</span> <span>{</span>\n        matcher <span>=</span> <span>TypeParameterMatcher</span><span>.</span><span>find</span><span>(</span><span>this</span><span>,</span> <span>SimpleChannelInboundHandler</span><span>.</span><span>class</span><span>,</span> <span>\"I\"</span><span>)</span><span>;</span>\n        <span>this</span><span>.</span>autoRelease <span>=</span> autoRelease<span>;</span>\n    <span>}</span>\n <span>public</span> <span>boolean</span> <span>acceptInboundMessage</span><span>(</span><span>Object</span> msg<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>return</span> matcher<span>.</span><span>match</span><span>(</span>msg<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>channelRead</span><span>(</span><span>ChannelHandlerContext</span> ctx<span>,</span> <span>Object</span> msg<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>boolean</span> release <span>=</span> <span>true</span><span>;</span>\n        <span>try</span> <span>{</span>\n            <span>if</span> <span>(</span><span>acceptInboundMessage</span><span>(</span>msg<span>)</span><span>)</span> <span>{</span>\n                <span>@SuppressWarnings</span><span>(</span><span>\"unchecked\"</span><span>)</span>\n                <span>I</span> imsg <span>=</span> <span>(</span><span>I</span><span>)</span> msg<span>;</span>\n                <span>channelRead0</span><span>(</span>ctx<span>,</span> imsg<span>)</span><span>;</span>\n            <span>}</span> <span>else</span> <span>{</span>\n                release <span>=</span> <span>false</span><span>;</span>\n                ctx<span>.</span><span>fireChannelRead</span><span>(</span>msg<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span> <span>finally</span> <span>{</span>\n            <span>if</span> <span>(</span>autoRelease <span>&amp;&amp;</span> release<span>)</span> <span>{</span>\n                <span>ReferenceCountUtil</span><span>.</span><span>release</span><span>(</span>msg<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><p>好了，到这里我们的入栈流程就说完了。下面我们说出栈的流程。</p>\n<h3 id=\"_3-6-出栈管道处理器\"> 3.6 出栈管道处理器</h3>\n<p><img src=\"https://img.springlearn.cn/blog/c4836bafa453bfd215ee4a1bd40a404b.png\" alt=\"\" loading=\"lazy\"></p>\n<p>通过前面我们对 <code>ChannelHandler</code> 的了解,如果我们要写出栈的处理器,其实就是要继承 <code>ChannelOutboundHandlerAdapter</code> 。以下面这个例子,我们写一个 <code>RpcResponse</code> 对象。</p>\n<ul>\n<li>a handler 是编码器,负责将 <code>RpcResponse</code> 对象转成二进制数据</li>\n<li>b handler 是出栈处理器, 而里面的Object类型的msg究竟是二进制数据呢？ 还是 <code>RpcResponse</code>呢? 这个就要看出栈执行器的位置了。</li>\n</ul>\n<p>这个问题,后面在3.7就能找到答案。</p>\n<div><pre><code>    <span>@Test</span>\n    <span>@DisplayName</span><span>(</span><span>\"出栈处理器\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>testOutbound</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>EmbeddedChannel</span> channel <span>=</span> <span>new</span> <span>EmbeddedChannel</span><span>(</span><span>new</span> <span>LoggingHandler</span><span>(</span><span>LogLevel</span><span>.</span>DEBUG<span>)</span><span>,</span>\n                <span>new</span> <span>ChannelInitializer</span><span><span>&lt;</span><span>EmbeddedChannel</span><span>></span></span><span>(</span><span>)</span> <span>{</span>\n                    <span>@Override</span>\n                    <span>protected</span> <span>void</span> <span>initChannel</span><span>(</span><span>EmbeddedChannel</span> ch<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n                        <span>ChannelPipeline</span> pipeline <span>=</span> ch<span>.</span><span>pipeline</span><span>(</span><span>)</span><span>;</span>\n                        pipeline<span>.</span><span>addLast</span><span>(</span><span>\"a handler\"</span><span>,</span> <span>new</span> <span>MojitoChannelEncoder</span><span>(</span><span>\"mojito\"</span><span>)</span><span>)</span><span>;</span>\n                        pipeline<span>.</span><span>addLast</span><span>(</span><span>\"b handler\"</span><span>,</span> <span>new</span> <span>ChannelOutboundHandlerAdapter</span><span>(</span><span>)</span> <span>{</span>\n                            <span>@Override</span>\n                            <span>public</span> <span>void</span> <span>write</span><span>(</span><span>ChannelHandlerContext</span> ctx<span>,</span> <span>Object</span> msg<span>,</span> <span>ChannelPromise</span> promise<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n                                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Write:\"</span> <span>+</span> msg<span>)</span><span>;</span>\n                                <span>super</span><span>.</span><span>write</span><span>(</span>ctx<span>,</span> msg<span>,</span> promise<span>)</span><span>;</span>\n                            <span>}</span>\n                        <span>}</span><span>)</span><span>;</span>\n                    <span>}</span>\n                <span>}</span><span>)</span><span>;</span>\n        <span>RpcResponse</span> rpcResponse <span>=</span> <span>new</span> <span>RpcResponse</span><span>(</span><span>)</span><span>;</span>\n        channel<span>.</span><span>writeOutbound</span><span>(</span>rpcResponse<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h3 id=\"_3-7-处理器顺序\"> 3.7 处理器顺序</h3>\n<p><img src=\"https://img.springlearn.cn/blog/0cc9f9936d794711885b5a3a2c9e68ce.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>  <span>ChannelPipeline</span> p <span>=</span> <span>.</span><span>.</span><span>.</span><span>;</span>\n  p<span>.</span><span>addLast</span><span>(</span><span>\"1\"</span><span>,</span> <span>new</span> <span>InboundHandlerA</span><span>(</span><span>)</span><span>)</span><span>;</span>\n  p<span>.</span><span>addLast</span><span>(</span><span>\"2\"</span><span>,</span> <span>new</span> <span>InboundHandlerB</span><span>(</span><span>)</span><span>)</span><span>;</span>\n  p<span>.</span><span>addLast</span><span>(</span><span>\"3\"</span><span>,</span> <span>new</span> <span>OutboundHandlerA</span><span>(</span><span>)</span><span>)</span><span>;</span>\n  p<span>.</span><span>addLast</span><span>(</span><span>\"4\"</span><span>,</span> <span>new</span> <span>OutboundHandlerB</span><span>(</span><span>)</span><span>)</span><span>;</span>\n  p<span>.</span><span>addLast</span><span>(</span><span>\"5\"</span><span>,</span> <span>new</span> <span>InboundOutboundHandlerX</span><span>(</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ul>\n<li>入栈:  1 -&gt; 2 -&gt; 5</li>\n<li>出栈:  5 -&gt; 4 -&gt; 3</li>\n</ul>\n<p>所以由此得出,3.5 Write的地方,会打印 <code>RpcResponse</code> 对象。</p>\n<p>好了,到这里Netty的核心API其实就学习完了,了解了这些就算入门了。下面我们看如何来组装这些API吧。</p>\n<h3 id=\"_3-8-服务端引导类\"> 3.8 服务端引导类</h3>\n<p>通过前面的学习,我们已经知道在Netty 中如何将二进制数据转换成Java对象,并进行业务处理,然后在将业务数据通过出栈处理器器转换成二进制数据返回了。那么我们现在来看下如何用Netty构建一个服务端吧。\n直接上代码。</p>\n<div><pre><code>    <span>/**\n     * @author liuxin\n     * 个人博客：https://java.springlearn.cn\n     * 公众号：西魏陶渊明  ｛关注获取学习源码｝\n     * 2022/8/11 23:12\n     */</span>\n    <span>@Test</span>\n    <span>@DisplayName</span><span>(</span><span>\"构建一个服务端\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>testServer</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>ServerBootstrap</span> serverBootstrap <span>=</span> <span>new</span> <span>ServerBootstrap</span><span>(</span><span>)</span><span>;</span>\n        <span>// io 线程一个进行轮训即可</span>\n        <span>NioEventLoopGroup</span> bossGroup <span>=</span> <span>new</span> <span>NioEventLoopGroup</span><span>(</span><span>1</span><span>,</span> <span>new</span> <span>NamedThreadFactory</span><span>(</span><span>\"boss\"</span><span>)</span><span>)</span><span>;</span>\n        <span>// 业务处理线程组, CPU线程数 + 1 即可: (同一个核心同一时刻只能执行一个任务,所以创建多了也没用,建议给N+1个)</span>\n        <span>NioEventLoopGroup</span> workGroup <span>=</span> <span>new</span> <span>NioEventLoopGroup</span><span>(</span>\n                <span>Runtime</span><span>.</span><span>getRuntime</span><span>(</span><span>)</span><span>.</span><span>availableProcessors</span><span>(</span><span>)</span> <span>+</span> <span>1</span><span>,</span> <span>new</span> <span>NamedThreadFactory</span><span>(</span><span>\"work\"</span><span>)</span><span>)</span><span>;</span>\n        serverBootstrap<span>.</span><span>group</span><span>(</span>bossGroup<span>,</span> workGroup<span>)</span>\n                <span>.</span><span>childHandler</span><span>(</span><span>new</span> <span>ChannelInitializer</span><span><span>&lt;</span><span>SocketChannel</span><span>></span></span><span>(</span><span>)</span> <span>{</span>\n                    <span>@Override</span>\n                    <span>protected</span> <span>void</span> <span>initChannel</span><span>(</span><span>SocketChannel</span> ch<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n                        <span>// 我们的管道信息信息就在这里</span>\n                        <span>ChannelPipeline</span> pipeline <span>=</span> ch<span>.</span><span>pipeline</span><span>(</span><span>)</span><span>;</span>\n\n                    <span>}</span>\n                <span>}</span><span>)</span><span>.</span><span>channel</span><span>(</span><span>OSinfo</span><span>.</span><span>isLinux</span><span>(</span><span>)</span> <span>?</span> <span>EpollServerSocketChannel</span><span>.</span><span>class</span> <span>:</span> <span>NioServerSocketChannel</span><span>.</span><span>class</span><span>)</span><span>;</span>\n        <span>ChannelFuture</span> sync <span>=</span> serverBootstrap<span>.</span><span>bind</span><span>(</span><span>8080</span><span>)</span><span>.</span><span>sync</span><span>(</span><span>)</span><span>;</span>\n        sync<span>.</span><span>addListener</span><span>(</span><span>(</span><span>ChannelFutureListener</span><span>)</span> future <span>-></span> <span>{</span>\n            <span>if</span> <span>(</span>future<span>.</span><span>isSuccess</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"端口绑定成功\"</span><span>)</span><span>;</span>\n            <span>}</span> <span>else</span> <span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"端口绑定失败:\"</span> <span>+</span> future<span>.</span><span>cause</span><span>(</span><span>)</span><span>.</span><span>getCause</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n        <span>Channel</span> channel <span>=</span> sync<span>.</span><span>channel</span><span>(</span><span>)</span><span>;</span>\n        <span>// 添加一个关闭时间监听器</span>\n        channel<span>.</span><span>closeFuture</span><span>(</span><span>)</span><span>.</span><span>addListener</span><span>(</span><span>(</span><span>ChannelFutureListener</span><span>)</span> future <span>-></span> <span>{</span>\n            <span>if</span> <span>(</span>future<span>.</span><span>isSuccess</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"服务关闭成功\"</span><span>)</span><span>;</span>\n            <span>}</span> <span>else</span> <span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"服务关闭失败:\"</span> <span>+</span> future<span>.</span><span>cause</span><span>(</span><span>)</span><span>.</span><span>getCause</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n        channel<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><h3 id=\"_3-9-客户端引导类\"> 3.9 客户端引导类</h3>\n<p>这里我们为了测试,我们先构建一个服务端,然后构建一个客户端然后进行访问。我们看服务端的输出。</p>\n<ul>\n<li>构建服务端打印请求连接和释放连接事件</li>\n</ul>\n<div><pre><code>    <span>/**\n     * 请求解码器负责将二进制数据转换成能处理的协议\n     * 虫洞栈：https://java.springlearn.cn\n     * 公众号：西魏陶渊明  ｛关注获取学习源码｝\n     */</span>\n    <span>@Test</span>\n    <span>@DisplayName</span><span>(</span><span>\"构建一个服务端\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>testServer</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>ServerBootstrap</span> serverBootstrap <span>=</span> <span>new</span> <span>ServerBootstrap</span><span>(</span><span>)</span><span>;</span>\n        <span>// io 线程一个进行轮训即可</span>\n        <span>NioEventLoopGroup</span> bossGroup <span>=</span> <span>new</span> <span>NioEventLoopGroup</span><span>(</span><span>1</span><span>,</span> <span>new</span> <span>NamedThreadFactory</span><span>(</span><span>\"boss\"</span><span>)</span><span>)</span><span>;</span>\n        <span>// 业务处理线程组, CPU线程数 + 1 即可: (同一个核心同一时刻只能执行一个任务,所以创建多了也没用,建议给N+1个)</span>\n        <span>NioEventLoopGroup</span> workGroup <span>=</span> <span>new</span> <span>NioEventLoopGroup</span><span>(</span>\n                <span>Runtime</span><span>.</span><span>getRuntime</span><span>(</span><span>)</span><span>.</span><span>availableProcessors</span><span>(</span><span>)</span> <span>+</span> <span>1</span><span>,</span> <span>new</span> <span>NamedThreadFactory</span><span>(</span><span>\"work\"</span><span>)</span><span>)</span><span>;</span>\n        serverBootstrap<span>.</span><span>group</span><span>(</span>bossGroup<span>,</span> workGroup<span>)</span>\n                <span>.</span><span>childHandler</span><span>(</span><span>new</span> <span>ChannelInitializer</span><span><span>&lt;</span><span>SocketChannel</span><span>></span></span><span>(</span><span>)</span> <span>{</span>\n                    <span>@Override</span>\n                    <span>protected</span> <span>void</span> <span>initChannel</span><span>(</span><span>SocketChannel</span> ch<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n                        <span>// 设置我们的管道信息</span>\n                        <span>ChannelPipeline</span> pipeline <span>=</span> ch<span>.</span><span>pipeline</span><span>(</span><span>)</span><span>;</span>\n                        pipeline<span>.</span><span>addLast</span><span>(</span><span>new</span> <span>ChannelInboundHandlerAdapter</span><span>(</span><span>)</span> <span>{</span>\n                            <span>@Override</span>\n                            <span>public</span> <span>void</span> <span>channelActive</span><span>(</span><span>ChannelHandlerContext</span> ctx<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n                                <span>Channel</span> channel <span>=</span> ctx<span>.</span><span>channel</span><span>(</span><span>)</span><span>;</span>\n                                <span>SocketAddress</span> socketAddress <span>=</span> channel<span>.</span><span>remoteAddress</span><span>(</span><span>)</span><span>;</span>\n                                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"收到了一个链接:\"</span> <span>+</span> socketAddress<span>)</span><span>;</span>\n                                ctx<span>.</span><span>fireChannelActive</span><span>(</span><span>)</span><span>;</span>\n                            <span>}</span>\n\n                            <span>@Override</span>\n                            <span>public</span> <span>void</span> <span>channelInactive</span><span>(</span><span>ChannelHandlerContext</span> ctx<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n                                <span>Channel</span> channel <span>=</span> ctx<span>.</span><span>channel</span><span>(</span><span>)</span><span>;</span>\n                                <span>SocketAddress</span> socketAddress <span>=</span> channel<span>.</span><span>remoteAddress</span><span>(</span><span>)</span><span>;</span>\n                                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>socketAddress <span>+</span> <span>\":关闭连接\"</span><span>)</span><span>;</span>\n                            <span>}</span>\n                        <span>}</span><span>)</span><span>;</span>\n                    <span>}</span>\n                <span>}</span><span>)</span><span>.</span><span>channel</span><span>(</span><span>OSinfo</span><span>.</span><span>isLinux</span><span>(</span><span>)</span> <span>?</span> <span>EpollServerSocketChannel</span><span>.</span><span>class</span> <span>:</span> <span>NioServerSocketChannel</span><span>.</span><span>class</span><span>)</span><span>;</span>\n        <span>ChannelFuture</span> sync <span>=</span> serverBootstrap<span>.</span><span>bind</span><span>(</span><span>8080</span><span>)</span><span>.</span><span>sync</span><span>(</span><span>)</span><span>;</span>\n        sync<span>.</span><span>addListener</span><span>(</span><span>(</span><span>ChannelFutureListener</span><span>)</span> future <span>-></span> <span>{</span>\n            <span>if</span> <span>(</span>future<span>.</span><span>isSuccess</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"端口绑定成功\"</span><span>)</span><span>;</span>\n            <span>}</span> <span>else</span> <span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"端口绑定失败:\"</span> <span>+</span> future<span>.</span><span>cause</span><span>(</span><span>)</span><span>.</span><span>getCause</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n        <span>Channel</span> channel <span>=</span> sync<span>.</span><span>channel</span><span>(</span><span>)</span><span>;</span>\n        <span>// 添加一个关闭时间监听器</span>\n        channel<span>.</span><span>closeFuture</span><span>(</span><span>)</span><span>.</span><span>addListener</span><span>(</span><span>(</span><span>ChannelFutureListener</span><span>)</span> future <span>-></span> <span>{</span>\n            <span>if</span> <span>(</span>future<span>.</span><span>isSuccess</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"服务关闭成功\"</span><span>)</span><span>;</span>\n            <span>}</span> <span>else</span> <span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"服务关闭失败:\"</span> <span>+</span> future<span>.</span><span>cause</span><span>(</span><span>)</span><span>.</span><span>getCause</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>.</span><span>sync</span><span>(</span><span>)</span><span>;</span>\n        channel<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br></div></div><ul>\n<li>构建客户端</li>\n</ul>\n<div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>testClient</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>NioEventLoopGroup</span> workGroup <span>=</span> <span>new</span> <span>NioEventLoopGroup</span><span>(</span>\n                <span>Runtime</span><span>.</span><span>getRuntime</span><span>(</span><span>)</span><span>.</span><span>availableProcessors</span><span>(</span><span>)</span> <span>+</span> <span>1</span><span>,</span> <span>new</span> <span>NamedThreadFactory</span><span>(</span><span>\"work\"</span><span>)</span><span>)</span><span>;</span>\n        <span>Bootstrap</span> clientBootstrap <span>=</span> <span>new</span> <span>Bootstrap</span><span>(</span><span>)</span><span>;</span>\n        clientBootstrap<span>.</span><span>group</span><span>(</span>workGroup<span>)</span><span>;</span>\n        clientBootstrap<span>.</span><span>channel</span><span>(</span><span>NioSocketChannel</span><span>.</span><span>class</span><span>)</span><span>;</span>\n        clientBootstrap<span>.</span><span>option</span><span>(</span><span>ChannelOption</span><span>.</span>TCP_NODELAY<span>,</span> <span>false</span><span>)</span><span>;</span>\n        clientBootstrap<span>.</span><span>handler</span><span>(</span><span>new</span> <span>ChannelInitializer</span><span><span>&lt;</span><span>SocketChannel</span><span>></span></span><span>(</span><span>)</span> <span>{</span>\n            <span>@Override</span>\n            <span>protected</span> <span>void</span> <span>initChannel</span><span>(</span><span>SocketChannel</span> ch<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n                <span>// 设置我们的管道</span>\n                <span>ChannelPipeline</span> pipeline <span>=</span> ch<span>.</span><span>pipeline</span><span>(</span><span>)</span><span>;</span>\n                <span>// 客户端要将我们发出的Java对象转换成二进制对象输入</span>\n                <span>// 客户端要将服务端发送的二进制对象转换成Java对象</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n        <span>ChannelFuture</span> channelFuture <span>=</span> clientBootstrap<span>.</span><span>connect</span><span>(</span><span>\"127.0.0.1\"</span><span>,</span> <span>8080</span><span>)</span><span>.</span><span>sync</span><span>(</span><span>)</span><span>;</span>\n        channelFuture<span>.</span><span>channel</span><span>(</span><span>)</span><span>.</span><span>write</span><span>(</span><span>\"HelloWord\"</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>服务端控制台输出:</p>\n<ul>\n<li>端口绑定成功</li>\n<li>收到了一个链接:/127.0.0.1:55732</li>\n<li>/127.0.0.1:55732:关闭连接</li>\n</ul>\n<h3 id=\"_3-10-netty-学习总结\"> 3.10 Netty 学习总结</h3>\n<p>好了，我们一口气吧 <code>Netty</code> 的API都学习了,知识点有点多,大家可以看着图来理解。这里学习Netty是因为我们要用Netty来构建一个网络通道。用于我们开发RPC框架，这点知识已经够用了。但是需要注意的是 <code>Netty</code> 并不仅仅只有这些知识点。Netty 为什么这么快? 吞吐量这么高? 值得我们学习的知识点还有很多。这个后面我们单独再来说,本篇文章我们就了解这么多就够用了。下面我们终于可以开始自己的Coding了。</p>\n<h2 id=\"四、通信层搭建\"> 四、通信层搭建</h2>\n<p><img src=\"https://img.springlearn.cn/blog/f1c1e75211b9630f4123ad8903d8b68d.png\" alt=\"\" loading=\"lazy\"></p>\n<ul>\n<li><a href=\"https://springlearn.blog.csdn.net/article/details/125901044\" target=\"_blank\" rel=\"noopener noreferrer\">第01篇:手写JavaRPC框架之思路分析</a></li>\n<li><a href=\"https://springlearn.blog.csdn.net/article/details/125903177\" target=\"_blank\" rel=\"noopener noreferrer\">第02篇:手写JavaRPC框架之设计思路</a></li>\n<li><a href=\"https://springlearn.blog.csdn.net/article/details/126151001\" target=\"_blank\" rel=\"noopener noreferrer\">第03篇: 手写JavaRPC框架之搞定序列化</a></li>\n</ul>\n<p>通过前三篇的学习及上面对Netty的学习,相信上图中关于底层通信的所有知识点都已经了解了吧。那么下面就开始编程了。来一步一步完成我们的通信层。</p>\n<h3 id=\"_4-1-工程结构\"> 4.1 工程结构</h3>\n<p><img src=\"https://img.springlearn.cn/blog/89d3ec5f95d4ef4642d9f32ce1616c79.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_4-2-架构设计\"> 4.2 架构设计</h3>\n<p><img src=\"https://img.springlearn.cn/blog/dd74eb95dc1ea6c3d0a5ea341f2f62cf.png\" alt=\"\" loading=\"lazy\"></p>\n<p>所谓的架构其实就会对于Netty 管道中的处理逻辑和分层。</p>\n<ul>\n<li>Config API 其实就是我们的Fluent风格的API</li>\n<li>Business   就是我们提供给开发者用来实现业务的接口</li>\n<li>Model      是我们原型开发者自定义自己的数据传输模型,前提是要集成 <code>ProtocolHeader</code></li>\n<li>Exchange   用于屏蔽Netty原生众多的API,通过封装只暴露我们需要感知的API</li>\n<li>Codec      提供自定义的解码器和编码器,同时也能支持HTTP的协议</li>\n<li>Serialize  底层的序列化实现</li>\n</ul>\n<h3 id=\"_4-3-服务端\"> 4.3 服务端</h3>\n<p><img src=\"https://img.springlearn.cn/blog/364d595434aed6cd9de163930cb9f09b.png\" alt=\"\" loading=\"lazy\"></p>\n<ol>\n<li>首先我们定义出 <code>Server</code> 接口,为了尽量让职责单一。我们将配置方法和核心的能力分开，又定义了\n提供配置的 <code>ConfigurableServer</code>。 这块代码我们就是抄的Spring的ApplicationContext的设计。设计的好处是,接口隔离原则,即一个类与其他类保留最少的关系。这样说可能还不好理解。我们思考下\nServer集成了ConfigurableServer。假如说我们把所有的接口定义都放在Server中。当我们要把配置的信息,暴露给外面的时候,只能将Server给提供出去,但是Server中有那么多的非配置的方法,是不是都被外部所感知到了呢? 解决办法就是将接口细化, 给外部只提供ConfigurableServer。这样外部就看不到Server中所有的方法,就不会被困扰。</li>\n</ol>\n<div><pre><code>  <span>// 给外面提供的接口能力太大了,他不关心的提供出来就是困扰。</span>\n  <span>public</span> <span>void</span> <span>customerConfig</span><span>(</span><span>Server</span> server<span>)</span><span>;</span>\n  <span>// 提供的都是我想要的,一起都是刚刚好。</span>\n  <span>public</span> <span>void</span> <span>customerConfig</span><span>(</span><span>ConfigurableServer</span> confServer<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ol start=\"2\">\n<li>\n<p>目前我们是使用Netty通信框架进行的实现,但是为了以后可以支持其他的通信框架,我们定义了抽象模板类 <code>AbstractServer</code>。在模板类型,只定义统一的创建服务端的流程。而具体的细节,交给了抽象方法。如果说后面我们不使用Netty来,我们的改动也是最小的。</p>\n</li>\n<li>\n<p><code>NettyServer</code> 继承了 <code>AbstractServer</code> 实现了其定义的抽象方法,具体的负责创建服务。</p>\n</li>\n</ol>\n<p>代码如下,更多细节可以到下载代码学习。</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>ConfigurableServer</span><span><span>&lt;</span><span>T</span> <span>extends</span> <span>Server</span><span>&lt;</span><span>?</span><span>></span><span>></span></span> <span>{</span>\n\n    <span>/**\n     * 给网络通道注册二进制处理协议\n     *\n     * @param protocol 协议\n     */</span>\n    <span>void</span> <span>registryProtocol</span><span>(</span><span>Protocol</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>ProtocolHeader</span><span>,</span> <span>?</span> <span>extends</span> <span>ProtocolHeader</span><span>></span></span> protocol<span>)</span><span>;</span>\n\n    <span>/**\n     * 注册钩子程序\n     */</span>\n    <span>void</span> <span>registryHooks</span><span>(</span><span>Runnable</span> hookTask<span>)</span><span>;</span>\n\n    <span>/**\n     * 协议信息\n     *\n     * @return Protocol\n     */</span>\n    <span>Protocol</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>ProtocolHeader</span><span>,</span> <span>?</span> <span>extends</span> <span>ProtocolHeader</span><span>></span></span> <span>getProtocol</span><span>(</span><span>)</span><span>;</span>\n\n    <span>/**\n     * 这里我们提供一个Server初始化的方法,为什么呢?\n     * 目前我们的服务端是使用NettyServer,我们也支持其他的通信框架。因为可能初始化方法不一样.\n     * 所以我们将具体的实现作为一个泛型。让具体的实现来自己定义自己的初始化方法\n     *\n     * @param initializer 初始化接口\n     */</span>\n    <span>void</span> <span>initializer</span><span>(</span><span>ServerInitializer</span><span><span>&lt;</span><span>T</span><span>></span></span> initializer<span>)</span><span>;</span>\n<span>}</span>\n\n<span>public</span> <span>interface</span> <span>Server</span><span><span>&lt;</span><span>T</span> <span>extends</span> <span>Server</span><span>&lt;</span><span>?</span><span>></span><span>></span></span> <span>extends</span> <span>ConfigurableServer</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>{</span>\n\n    <span>/**\n     * 启动服务\n     *\n     * @param port 服务端口号\n     */</span>\n    <span>void</span> <span>start</span><span>(</span><span>int</span> port<span>)</span><span>;</span>\n\n    <span>/**\n     * 非阻塞启动\n     *\n     * @param port 端口\n     */</span>\n    <span>void</span> <span>startAsync</span><span>(</span><span>int</span> port<span>)</span><span>;</span>\n\n    <span>/**\n     * 关闭服务\n     */</span>\n    <span>void</span> <span>close</span><span>(</span><span>)</span><span>;</span>\n\n    <span>/**\n     * 服务器端口\n     *\n     * @return int\n     */</span>\n    <span>int</span> <span>getPort</span><span>(</span><span>)</span><span>;</span>\n\n    <span>/**\n     * 是否运行中\n     *\n     * @return boolean\n     */</span>\n    <span>boolean</span> <span>isRun</span><span>(</span><span>)</span><span>;</span>\n\n<span>}</span>\n\n<span>/**\n * @author liuxin\n * 2022/8/10 22:16\n */</span>\n<span>public</span> <span>abstract</span> <span>class</span> <span>AbstractServer</span><span><span>&lt;</span><span>T</span> <span>extends</span> <span>Server</span><span>&lt;</span><span>?</span><span>></span><span>></span></span> <span>implements</span> <span>Server</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>{</span>\n\n    <span>private</span> <span>ServerInitializer</span><span><span>&lt;</span><span>T</span><span>></span></span> serverInitializer<span>;</span>\n\n    <span>private</span> <span>Integer</span> port<span>;</span>\n\n    <span>private</span> <span>final</span> <span>AtomicBoolean</span> runningState <span>=</span> <span>new</span> <span>AtomicBoolean</span><span>(</span><span>false</span><span>)</span><span>;</span>\n\n    <span>private</span> <span>Protocol</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>ProtocolHeader</span><span>,</span> <span>?</span> <span>extends</span> <span>ProtocolHeader</span><span>></span></span> protocol<span>;</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>registryProtocol</span><span>(</span><span>Protocol</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>ProtocolHeader</span><span>,</span> <span>?</span> <span>extends</span> <span>ProtocolHeader</span><span>></span></span> protocol<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>protocol <span>=</span> protocol<span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>registryHooks</span><span>(</span><span>Runnable</span> hookTask<span>)</span> <span>{</span>\n        <span>ThreadHookTools</span><span>.</span><span>addHook</span><span>(</span><span>new</span> <span>Thread</span><span>(</span>hookTask<span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>Protocol</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>ProtocolHeader</span><span>,</span> <span>?</span> <span>extends</span> <span>ProtocolHeader</span><span>></span></span> <span>getProtocol</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> protocol<span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>initializer</span><span>(</span><span>ServerInitializer</span><span><span>&lt;</span><span>T</span><span>></span></span> initializer<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>serverInitializer <span>=</span> initializer<span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>ServerInitializer</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>getServerInitializer</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> serverInitializer<span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>start</span><span>(</span><span>int</span> port<span>)</span> <span>{</span>\n        <span>checked</span><span>(</span><span>)</span><span>;</span>\n        <span>activeAndCreateServer</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>\n            <span>this</span><span>.</span>port <span>=</span> port<span>;</span>\n            <span>doCreateServer</span><span>(</span>port<span>,</span> <span>false</span><span>)</span><span>;</span>\n        <span>}</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>private</span> <span>void</span> <span>checked</span><span>(</span><span>)</span> <span>{</span>\n        <span>if</span> <span>(</span><span>Objects</span><span>.</span><span>isNull</span><span>(</span>protocol<span>)</span><span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>RuntimeException</span><span>(</span><span>\"Protocol不能为空,请Server#registryProtocol\"</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>if</span> <span>(</span><span>Objects</span><span>.</span><span>isNull</span><span>(</span>serverInitializer<span>)</span><span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>RuntimeException</span><span>(</span><span>\"Protocol不能为空,请Server#initializer\"</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>private</span> <span>void</span> <span>activeAndCreateServer</span><span>(</span><span>LambdaExecute</span> execute<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span><span>isRun</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>RuntimeException</span><span>(</span><span>\"运行中\"</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>if</span> <span>(</span>runningState<span>.</span><span>compareAndSet</span><span>(</span><span>false</span><span>,</span> <span>true</span><span>)</span><span>)</span> <span>{</span>\n            <span>try</span> <span>{</span>\n                execute<span>.</span><span>execute</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span> <span>catch</span> <span>(</span><span>Throwable</span> t<span>)</span> <span>{</span>\n                runningState<span>.</span><span>compareAndSet</span><span>(</span><span>true</span><span>,</span> <span>false</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>private</span> <span>void</span> <span>closeAndDestroyServer</span><span>(</span><span>LambdaExecute</span> execute<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span><span>isRun</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n            <span>if</span> <span>(</span>runningState<span>.</span><span>compareAndSet</span><span>(</span><span>true</span><span>,</span> <span>false</span><span>)</span><span>)</span> <span>{</span>\n                execute<span>.</span><span>execute</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>startAsync</span><span>(</span><span>int</span> port<span>)</span> <span>{</span>\n        <span>activeAndCreateServer</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>\n            <span>this</span><span>.</span>port <span>=</span> port<span>;</span>\n            <span>doCreateServer</span><span>(</span>port<span>,</span> <span>true</span><span>)</span><span>;</span>\n        <span>}</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>close</span><span>(</span><span>)</span> <span>{</span>\n        <span>closeAndDestroyServer</span><span>(</span><span>this</span><span>::</span><span>doDestroyServer</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>int</span> <span>getPort</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>this</span><span>.</span>port<span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>boolean</span> <span>isRun</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> runningState<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>abstract</span> <span>void</span> <span>doCreateServer</span><span>(</span><span>int</span> port<span>,</span> <span>boolean</span> async<span>)</span><span>;</span>\n\n    <span>public</span> <span>abstract</span> <span>void</span> <span>doDestroyServer</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>@Slf4j</span>\n<span>public</span> <span>class</span> <span>NettyServer</span> <span>extends</span> <span>AbstractServer</span><span><span>&lt;</span><span>NettyServer</span><span>></span></span> <span>{</span>\n\n    <span>private</span> <span>final</span> <span>ServerBootstrap</span> serverBootstrap <span>=</span> <span>new</span> <span>ServerBootstrap</span><span>(</span><span>)</span><span>;</span>\n\n    <span>private</span> <span>Channel</span> serverChannel<span>;</span>\n\n    <span>private</span> <span>EventLoopGroup</span> bossGroup<span>;</span>\n\n    <span>private</span> <span>EventLoopGroup</span> workerGroup<span>;</span>\n\n    <span>private</span> <span>static</span> <span>final</span> <span>int</span> DEFAULT_EVENT_THREADS <span>=</span> <span>Math</span><span>.</span><span>min</span><span>(</span><span>Runtime</span><span>.</span><span>getRuntime</span><span>(</span><span>)</span><span>.</span><span>availableProcessors</span><span>(</span><span>)</span> <span>+</span> <span>1</span><span>,</span> <span>32</span><span>)</span><span>;</span>\n\n    <span>public</span> <span>ServerBootstrap</span> <span>getServerBootstrap</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>this</span><span>.</span>serverBootstrap<span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>@SneakyThrows</span>\n    <span>public</span> <span>void</span> <span>doCreateServer</span><span>(</span><span>int</span> port<span>,</span> <span>boolean</span> async<span>)</span> <span>{</span>\n        <span>// 1. io线程数 = cpu * 2</span>\n        bossGroup <span>=</span> <span>new</span> <span>NioEventLoopGroup</span><span>(</span><span>1</span><span>,</span> <span>new</span> <span>NamedThreadFactory</span><span>(</span><span>\"mojito-boss\"</span><span>,</span> <span>true</span><span>)</span><span>)</span><span>;</span>\n        <span>// 2. 业务线程数 = cpu + 1</span>\n        workerGroup <span>=</span> <span>new</span> <span>NioEventLoopGroup</span><span>(</span>DEFAULT_EVENT_THREADS<span>,</span> <span>new</span> <span>NamedThreadFactory</span><span>(</span><span>\"mojito-work\"</span><span>,</span> <span>true</span><span>)</span><span>)</span><span>;</span>\n        serverBootstrap<span>.</span><span>group</span><span>(</span>bossGroup<span>,</span> workerGroup<span>)</span>\n                <span>.</span><span>childOption</span><span>(</span><span>ChannelOption</span><span>.</span>TCP_NODELAY<span>,</span> <span>true</span><span>)</span>\n                <span>.</span><span>childOption</span><span>(</span><span>ChannelOption</span><span>.</span>SO_KEEPALIVE<span>,</span> <span>true</span><span>)</span>\n                <span>.</span><span>option</span><span>(</span><span>ChannelOption</span><span>.</span>SO_BACKLOG<span>,</span> <span>128</span><span>)</span>\n                <span>.</span><span>handler</span><span>(</span><span>new</span> <span>LoggingHandler</span><span>(</span><span>LogLevel</span><span>.</span>INFO<span>)</span><span>)</span>\n                <span>.</span><span>channel</span><span>(</span><span>OSinfo</span><span>.</span><span>isLinux</span><span>(</span><span>)</span> <span>?</span> <span>EpollServerSocketChannel</span><span>.</span><span>class</span> <span>:</span> <span>NioServerSocketChannel</span><span>.</span><span>class</span><span>)</span>\n                <span>.</span><span>localAddress</span><span>(</span>port<span>)</span><span>.</span><span>option</span><span>(</span><span>ChannelOption</span><span>.</span>CONNECT_TIMEOUT_MILLIS<span>,</span> <span>10000</span><span>)</span><span>;</span>\n        <span>getServerInitializer</span><span>(</span><span>)</span><span>.</span><span>initializer</span><span>(</span><span>this</span><span>)</span><span>;</span>\n        <span>// 3. 阻塞绑定端口</span>\n        <span>ChannelFuture</span> bindFuture <span>=</span> serverBootstrap<span>.</span><span>bind</span><span>(</span><span>)</span><span>.</span><span>addListener</span><span>(</span><span>(</span><span>ChannelFutureListener</span><span>)</span> channelFuture <span>-></span> <span>{</span>\n            <span>if</span> <span>(</span>channelFuture<span>.</span><span>isSuccess</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n                log<span>.</span><span>info</span><span>(</span><span>Banner</span><span>.</span><span>print</span><span>(</span><span>\"麻烦给我的爱人来一杯Mojito,我喜欢阅读她微醺时的眼眸！\"</span><span>,</span> <span>Ansi<span>.</span>Color</span><span>.</span>RED<span>)</span><span>)</span><span>;</span>\n                log<span>.</span><span>info</span><span>(</span><span>\"Mojito启动成功,端口号:\"</span> <span>+</span> port<span>)</span><span>;</span>\n            <span>}</span> <span>else</span> <span>{</span>\n                <span>Throwable</span> cause <span>=</span> channelFuture<span>.</span><span>cause</span><span>(</span><span>)</span><span>;</span>\n                <span>throw</span> <span>new</span> <span>RuntimeException</span><span>(</span>cause<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>.</span><span>sync</span><span>(</span><span>)</span><span>;</span>\n        serverChannel <span>=</span> bindFuture<span>.</span><span>channel</span><span>(</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span>async<span>)</span> <span>{</span>\n            log<span>.</span><span>info</span><span>(</span><span>\"异步服务启动成功\"</span><span>)</span><span>;</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            serverChannel<span>.</span><span>closeFuture</span><span>(</span><span>)</span><span>.</span><span>sync</span><span>(</span><span>)</span><span>;</span>\n            log<span>.</span><span>info</span><span>(</span><span>\"阻塞服务启动成功\"</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>doDestroyServer</span><span>(</span><span>)</span> <span>{</span>\n        workerGroup<span>.</span><span>shutdownGracefully</span><span>(</span><span>)</span><span>;</span>\n        bossGroup<span>.</span><span>shutdownGracefully</span><span>(</span><span>)</span><span>;</span>\n        serverChannel<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n    \n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br><span>135</span><br><span>136</span><br><span>137</span><br><span>138</span><br><span>139</span><br><span>140</span><br><span>141</span><br><span>142</span><br><span>143</span><br><span>144</span><br><span>145</span><br><span>146</span><br><span>147</span><br><span>148</span><br><span>149</span><br><span>150</span><br><span>151</span><br><span>152</span><br><span>153</span><br><span>154</span><br><span>155</span><br><span>156</span><br><span>157</span><br><span>158</span><br><span>159</span><br><span>160</span><br><span>161</span><br><span>162</span><br><span>163</span><br><span>164</span><br><span>165</span><br><span>166</span><br><span>167</span><br><span>168</span><br><span>169</span><br><span>170</span><br><span>171</span><br><span>172</span><br><span>173</span><br><span>174</span><br><span>175</span><br><span>176</span><br><span>177</span><br><span>178</span><br><span>179</span><br><span>180</span><br><span>181</span><br><span>182</span><br><span>183</span><br><span>184</span><br><span>185</span><br><span>186</span><br><span>187</span><br><span>188</span><br><span>189</span><br><span>190</span><br><span>191</span><br><span>192</span><br><span>193</span><br><span>194</span><br><span>195</span><br><span>196</span><br><span>197</span><br><span>198</span><br><span>199</span><br><span>200</span><br><span>201</span><br><span>202</span><br><span>203</span><br><span>204</span><br><span>205</span><br><span>206</span><br><span>207</span><br><span>208</span><br><span>209</span><br><span>210</span><br><span>211</span><br><span>212</span><br><span>213</span><br><span>214</span><br><span>215</span><br><span>216</span><br><span>217</span><br><span>218</span><br><span>219</span><br><span>220</span><br><span>221</span><br><span>222</span><br><span>223</span><br><span>224</span><br><span>225</span><br><span>226</span><br><span>227</span><br><span>228</span><br><span>229</span><br><span>230</span><br><span>231</span><br><span>232</span><br><span>233</span><br><span>234</span><br></div></div><h3 id=\"_4-4-客户端\"> 4.4 客户端</h3>\n<p><img src=\"https://img.springlearn.cn/blog/991deadc0c04cca92bfc3f3d88d60a35.png\" alt=\"\" loading=\"lazy\"></p>\n<p>服务端的设计和客户端的设计是一样的,依赖抽象不依赖细节。架构设计只是定义好流程,具体是什么框架来实现底层的通信,就交给最底层的细节。</p>\n<ul>\n<li>客户端有几个核心的地方</li>\n</ul>\n<ol>\n<li>连接服务器</li>\n<li>发送数据(同步&amp;异步)</li>\n<li>断线重连(<strong>放在优化的时候讲</strong>)</li>\n<li>异步转同步问题</li>\n</ol>\n<div><pre><code>\n<span>/**\n * @author liuxin\n * 2022/8/5 23:12\n */</span>\n<span>public</span> <span>interface</span> <span>ConfigurableClient</span><span><span>&lt;</span>REQ <span>extends</span> <span>ProtocolHeader</span><span>,</span> RES <span>extends</span> <span>ProtocolHeader</span><span>,</span> <span>T</span> <span>extends</span> <span>Client</span><span>&lt;</span>REQ<span>,</span> RES<span>></span><span>></span></span> <span>{</span>\n\n    <span>/**\n     * 给网络通道注册二进制处理协议\n     *\n     * @param protocol 协议\n     */</span>\n    <span>void</span> <span>registryProtocol</span><span>(</span><span>Protocol</span><span><span>&lt;</span>REQ<span>,</span> RES<span>></span></span> protocol<span>)</span><span>;</span>\n\n    <span>/**\n     * 协议信息\n     *\n     * @return Protocol\n     */</span>\n    <span>Protocol</span><span><span>&lt;</span>REQ<span>,</span> RES<span>></span></span> <span>getProtocol</span><span>(</span><span>)</span><span>;</span>\n\n    <span>/**\n     * 注册钩子程序\n     */</span>\n    <span>void</span> <span>registryHooks</span><span>(</span><span>Runnable</span> hookTask<span>)</span><span>;</span>\n\n    <span>/**\n     * 这里我们提供一个Server初始化的方法,为什么呢?\n     * 目前我们的服务端是使用NettyServer,我们也支持其他的通信框架。因为可能初始化方法不一样.\n     * 所以我们将具体的实现作为一个泛型。让具体的实现来自己定义自己的初始化方法\n     *\n     * @param initializer 初始化接口\n     */</span>\n    <span>void</span> <span>initializer</span><span>(</span><span>ClientInitializer</span> initializer<span>)</span><span>;</span>\n\n    <span>/**\n     * 客户端初始化扩展\n     *\n     * @return ClientInitializer\n     */</span>\n    <span>ClientInitializer</span><span><span>&lt;</span><span>Client</span><span>&lt;</span>REQ<span>,</span> RES<span>></span><span>></span></span> <span>getClientInitializer</span><span>(</span><span>)</span><span>;</span>\n\n<span>}</span>\n\n<span>/**\n * @author liuxin\n * 个人博客：https://java.springlearn.cn\n * 公众号：西魏陶渊明  ｛关注获取学习源码｝\n * 2022/8/5 23:12\n */</span>\n<span>public</span> <span>interface</span> <span>Client</span><span><span>&lt;</span>REQ <span>extends</span> <span>ProtocolHeader</span><span>,</span> RES <span>extends</span> <span>ProtocolHeader</span><span>></span></span> <span>extends</span> <span>ConfigurableClient</span><span><span>&lt;</span>REQ<span>,</span> RES<span>,</span> <span>Client</span><span>&lt;</span>REQ<span>,</span> RES<span>></span><span>></span></span> <span>{</span>\n\n\n    <span>/**\n     * 建立连接\n     *\n     * @param host 连接地址\n     * @param port 连接端口\n     */</span>\n    <span>void</span> <span>connect</span><span>(</span><span>String</span> host<span>,</span> <span>Integer</span> port<span>)</span><span>;</span>\n\n    <span>/**\n     * 发送消息\n     *\n     * @param req 请求体\n     * @return 异步结果\n     */</span>\n    <span>MojitoFuture</span><span><span>&lt;</span>RES<span>></span></span> <span>send</span><span>(</span><span>REQ</span> req<span>)</span><span>;</span>\n\n    <span>/**\n     * 关闭连接\n     */</span>\n    <span>void</span> <span>close</span><span>(</span><span>)</span><span>;</span>\n\n\n    <span>/**\n     * 是否连接\n     *\n     * @return boolean\n     */</span>\n    <span>boolean</span> <span>isRun</span><span>(</span><span>)</span><span>;</span>\n\n    <span>/**\n     * 是否连接\n     *\n     * @return boolean\n     */</span>\n    <span>boolean</span> <span>isConnected</span><span>(</span><span>)</span><span>;</span>\n\n\n<span>}</span>\n<span>/**\n * @author liuxin\n * 个人博客：https://java.springlearn.cn\n * 公众号：西魏陶渊明  ｛关注获取学习源码｝\n * 2022/8/5 23:12\n */</span>\n<span>public</span> <span>abstract</span> <span>class</span> <span>AbstractClient</span><span><span>&lt;</span>REQ <span>extends</span> <span>ProtocolHeader</span><span>,</span> RES <span>extends</span> <span>ProtocolHeader</span><span>></span></span> <span>implements</span> <span>Client</span><span><span>&lt;</span>REQ<span>,</span> RES<span>></span></span> <span>{</span>\n\n\n    <span>/**\n     * 将要连接的远程地址\n     */</span>\n    <span>private</span> <span>String</span> remoteHost<span>;</span>\n\n    <span>/**\n     * 将要连接的远程端口\n     */</span>\n    <span>private</span> <span>int</span> remotePort<span>;</span>\n\n    <span>private</span> <span>Protocol</span><span><span>&lt;</span>REQ<span>,</span> RES<span>></span></span> protocol<span>;</span>\n\n    <span>private</span> <span>ClientInitializer</span><span><span>&lt;</span><span>Client</span><span>&lt;</span>REQ<span>,</span> RES<span>></span><span>></span></span> clientInitializer<span>;</span>\n\n    <span>private</span> <span>final</span> <span>AtomicBoolean</span> running <span>=</span> <span>new</span> <span>AtomicBoolean</span><span>(</span><span>false</span><span>)</span><span>;</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>connect</span><span>(</span><span>String</span> host<span>,</span> <span>Integer</span> port<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span><span>!</span>running<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n            <span>this</span><span>.</span>remoteHost <span>=</span> host<span>;</span>\n            <span>this</span><span>.</span>remotePort <span>=</span> port<span>;</span>\n        <span>}</span>\n        <span>try</span> <span>{</span>\n            <span>if</span> <span>(</span>running<span>.</span><span>compareAndSet</span><span>(</span><span>false</span><span>,</span> <span>true</span><span>)</span><span>)</span> <span>{</span>\n                <span>doConnect</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>Throwable</span> t<span>)</span> <span>{</span>\n            t<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            running<span>.</span><span>compareAndSet</span><span>(</span><span>true</span><span>,</span> <span>false</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>MojitoFuture</span><span><span>&lt;</span>RES<span>></span></span> <span>send</span><span>(</span><span>REQ</span> req<span>)</span> <span>{</span>\n        <span>return</span> <span>doSend</span><span>(</span>req<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>close</span><span>(</span><span>)</span> <span>{</span>\n        <span>doClose</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>int</span> <span>getRemotePort</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> remotePort<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>String</span> <span>getRemoteHost</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> remoteHost<span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>Protocol</span><span><span>&lt;</span>REQ<span>,</span> RES<span>></span></span> <span>getProtocol</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>this</span><span>.</span>protocol<span>;</span>\n    <span>}</span>\n\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>registryProtocol</span><span>(</span><span>Protocol</span><span><span>&lt;</span>REQ<span>,</span> RES<span>></span></span> protocol<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>protocol <span>=</span> protocol<span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>registryHooks</span><span>(</span><span>Runnable</span> hookTask<span>)</span> <span>{</span>\n        <span>ThreadHookTools</span><span>.</span><span>addHook</span><span>(</span><span>new</span> <span>Thread</span><span>(</span>hookTask<span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>initializer</span><span>(</span><span>ClientInitializer</span> initializer<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>clientInitializer <span>=</span> initializer<span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>boolean</span> <span>isRun</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> running<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>ClientInitializer</span><span><span>&lt;</span><span>Client</span><span>&lt;</span>REQ<span>,</span> RES<span>></span><span>></span></span> <span>getClientInitializer</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> clientInitializer<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>abstract</span> <span>void</span> <span>doConnect</span><span>(</span><span>)</span><span>;</span>\n\n    <span>public</span> <span>abstract</span> <span>void</span> <span>doClose</span><span>(</span><span>)</span><span>;</span>\n\n    <span>public</span> <span>abstract</span> <span>MojitoFuture</span><span><span>&lt;</span>RES<span>></span></span> <span>doSend</span><span>(</span><span>REQ</span> req<span>)</span><span>;</span>\n<span>}</span>\n\n<span>/**\n * @author liuxin\n * 个人博客：https://java.springlearn.cn\n * 公众号：西魏陶渊明  ｛关注获取学习源码｝\n * 2022/8/5 23:12\n */</span>\n<span>@Slf4j</span>\n<span>public</span> <span>class</span> <span>NettyClient</span><span><span>&lt;</span>REQ <span>extends</span> <span>ProtocolHeader</span><span>,</span> RES <span>extends</span> <span>ProtocolHeader</span><span>></span></span> <span>extends</span> <span>AbstractClient</span><span><span>&lt;</span>REQ<span>,</span> RES<span>></span></span> <span>{</span>\n\n    <span>private</span> <span>final</span> <span>Bootstrap</span> clientBootstrap <span>=</span> <span>new</span> <span>Bootstrap</span><span>(</span><span>)</span><span>;</span>\n\n    <span>private</span> <span>final</span> <span>EventLoopGroup</span> workerGroup <span>=</span> <span>new</span> <span>NioEventLoopGroup</span><span>(</span><span>)</span><span>;</span>\n\n    <span>private</span> <span>DefaultEnhanceChannel</span> enhanceChannel<span>;</span>\n\n    <span>@Override</span>\n    <span>@SneakyThrows</span>\n    <span>public</span> <span>void</span> <span>doConnect</span><span>(</span><span>)</span> <span>{</span>\n        clientBootstrap<span>.</span><span>group</span><span>(</span>workerGroup<span>)</span><span>;</span>\n        clientBootstrap<span>.</span><span>channel</span><span>(</span><span>NioSocketChannel</span><span>.</span><span>class</span><span>)</span><span>;</span>\n        clientBootstrap<span>.</span><span>option</span><span>(</span><span>ChannelOption</span><span>.</span>TCP_NODELAY<span>,</span> <span>false</span><span>)</span><span>;</span>\n        <span>getClientInitializer</span><span>(</span><span>)</span><span>.</span><span>initializer</span><span>(</span><span>this</span><span>)</span><span>;</span>\n        <span>ChannelFuture</span> channelFuture <span>=</span> clientBootstrap<span>.</span><span>connect</span><span>(</span><span>getRemoteHost</span><span>(</span><span>)</span><span>,</span> <span>getRemotePort</span><span>(</span><span>)</span><span>)</span><span>.</span><span>sync</span><span>(</span><span>)</span><span>;</span>\n        enhanceChannel <span>=</span> <span>DefaultEnhanceChannel</span><span>.</span><span>getOrAddChannel</span><span>(</span>channelFuture<span>.</span><span>channel</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>Bootstrap</span> <span>getClientBootstrap</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> clientBootstrap<span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>doClose</span><span>(</span><span>)</span> <span>{</span>\n        workerGroup<span>.</span><span>shutdownGracefully</span><span>(</span><span>)</span><span>;</span>\n        enhanceChannel<span>.</span><span>disconnected</span><span>(</span><span>)</span><span>;</span>\n        log<span>.</span><span>info</span><span>(</span><span>\"Client 关闭成功\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>MojitoFuture</span><span><span>&lt;</span>RES<span>></span></span> <span>doSend</span><span>(</span><span>REQ</span> req<span>)</span> <span>{</span>\n        <span>// 这里我们也设置,断线重连,后面优化</span>\n        <span>return</span> <span>getProtocol</span><span>(</span><span>)</span><span>.</span><span>getClientPromiseHandler</span><span>(</span><span>)</span><span>.</span><span>sendAsync</span><span>(</span>enhanceChannel<span>,</span> req<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>boolean</span> <span>isConnected</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>Objects</span><span>.</span><span>nonNull</span><span>(</span>enhanceChannel<span>)</span> <span>&amp;&amp;</span> enhanceChannel<span>.</span><span>isConnected</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br><span>135</span><br><span>136</span><br><span>137</span><br><span>138</span><br><span>139</span><br><span>140</span><br><span>141</span><br><span>142</span><br><span>143</span><br><span>144</span><br><span>145</span><br><span>146</span><br><span>147</span><br><span>148</span><br><span>149</span><br><span>150</span><br><span>151</span><br><span>152</span><br><span>153</span><br><span>154</span><br><span>155</span><br><span>156</span><br><span>157</span><br><span>158</span><br><span>159</span><br><span>160</span><br><span>161</span><br><span>162</span><br><span>163</span><br><span>164</span><br><span>165</span><br><span>166</span><br><span>167</span><br><span>168</span><br><span>169</span><br><span>170</span><br><span>171</span><br><span>172</span><br><span>173</span><br><span>174</span><br><span>175</span><br><span>176</span><br><span>177</span><br><span>178</span><br><span>179</span><br><span>180</span><br><span>181</span><br><span>182</span><br><span>183</span><br><span>184</span><br><span>185</span><br><span>186</span><br><span>187</span><br><span>188</span><br><span>189</span><br><span>190</span><br><span>191</span><br><span>192</span><br><span>193</span><br><span>194</span><br><span>195</span><br><span>196</span><br><span>197</span><br><span>198</span><br><span>199</span><br><span>200</span><br><span>201</span><br><span>202</span><br><span>203</span><br><span>204</span><br><span>205</span><br><span>206</span><br><span>207</span><br><span>208</span><br><span>209</span><br><span>210</span><br><span>211</span><br><span>212</span><br><span>213</span><br><span>214</span><br><span>215</span><br><span>216</span><br><span>217</span><br><span>218</span><br><span>219</span><br><span>220</span><br><span>221</span><br><span>222</span><br><span>223</span><br><span>224</span><br><span>225</span><br><span>226</span><br><span>227</span><br><span>228</span><br><span>229</span><br><span>230</span><br><span>231</span><br><span>232</span><br><span>233</span><br><span>234</span><br><span>235</span><br><span>236</span><br><span>237</span><br><span>238</span><br><span>239</span><br></div></div><h3 id=\"_4-5-异步转同步\"> 4.5 异步转同步</h3>\n<p>socket通信发送数据,什么时候回复都可以。甚至可以客户端一直发，而服务端不进行回复。而我们的RPC框架更像一问一答,发送请求后,需要立马就收到回复。每个请求都要对应一个响应,这就需要我们进行特殊的设计来完成,这样的需求。</p>\n<p>我们的思路就是实现,Jdk的Future,并给他添加上监听器的功能。因为我们主要是学习,所以不要怕麻烦,不要怕重新造轮子。下面我们开始实现它。</p>\n<div><pre><code>mojito/mojito-net/src/main/java/cn/lxchinesszz/mojito/future on  master [!+?] \n➜ tree                 \n.\n├── MojitoFuture.java\n├── Promise.java\n└── listener\n    ├── MojitoListener.java\n    └── MojitoListeners.java\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><ul>\n<li>定义接口 <code>Promise</code>。承诺,这个接口一定会告诉你成功或者失败。这样的设计Js上运用是最多的。</li>\n</ul>\n<div><pre><code><span>public</span> <span>interface</span> <span>Promise</span><span><span>&lt;</span><span>V</span><span>></span></span> <span>{</span>\n\n    <span>/**\n     * 是否成功\n     *\n     * @return boolean\n     */</span>\n    <span>boolean</span> <span>isSuccess</span><span>(</span><span>)</span><span>;</span>\n\n    <span>/**\n     * 设置成功表示\n     *\n     * @param data 数据\n     */</span>\n    <span>void</span> <span>setSuccess</span><span>(</span><span>V</span> data<span>)</span><span>;</span>\n\n    <span>/**\n     * 设置失败标识\n     *\n     * @param cause 异常\n     */</span>\n    <span>void</span> <span>setFailure</span><span>(</span><span>Throwable</span> cause<span>)</span><span>;</span>\n\n    <span>/**\n     * 添加监听器\n     *\n     * @param listener 监听器\n     */</span>\n    <span>void</span> <span>addListeners</span><span>(</span><span>MojitoListener</span><span><span>&lt;</span><span>V</span><span>></span></span> listener<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><ul>\n<li>实现核心方法</li>\n</ul>\n<p>这里需要注意的就是多线程的可见性和多线程的原子性问题以及如何实现线程等待。如果这部分不太容易理解，建议可以先多了解点关于线程安全的知识点。然后回过头在来看。</p>\n<ul>\n<li><a href=\"https://springlearn.blog.csdn.net/article/details/125824854\" target=\"_blank\" rel=\"noopener noreferrer\">Java并发编程之Condition条件锁</a></li>\n<li><a href=\"https://springlearn.blog.csdn.net/article/details/125824300\" target=\"_blank\" rel=\"noopener noreferrer\">Java多线程编程之线程安全感</a></li>\n<li><a href=\"https://springlearn.blog.csdn.net/article/details/125824392\" target=\"_blank\" rel=\"noopener noreferrer\">Java并发编程之原子操作</a></li>\n</ul>\n<div><pre><code><span>public</span> <span>class</span> <span>MojitoFuture</span><span><span>&lt;</span><span>V</span><span>></span></span> <span>implements</span> <span>Promise</span><span><span>&lt;</span><span>V</span><span>></span></span><span>,</span> <span>Future</span><span><span>&lt;</span><span>V</span><span>></span></span> <span>{</span>\n\n    <span>/**\n     * volatile 多线程保证可见性\n     */</span>\n    <span>private</span> <span>volatile</span> <span>V</span> result<span>;</span>\n    \n     <span>/**\n     * AtomicReferenceFieldUpdater 多线程保证操作的原子性\n     */</span>\n    <span>@SuppressWarnings</span><span>(</span><span>\"rawtypes\"</span><span>)</span>\n    <span>private</span> <span>static</span> <span>final</span> <span>AtomicReferenceFieldUpdater</span><span><span>&lt;</span><span>MojitoFuture</span><span>,</span> <span>Object</span><span>></span></span> RESULT_UPDATER <span>=</span>\n            <span>AtomicReferenceFieldUpdater</span><span>.</span><span>newUpdater</span><span>(</span><span>MojitoFuture</span><span>.</span><span>class</span><span>,</span> <span>Object</span><span>.</span><span>class</span><span>,</span> <span>\"result\"</span><span>)</span><span>;</span>\n            \n    <span>/**\n     * 当前承诺的监听器\n     */</span>\n    <span>private</span> <span>final</span> <span>List</span><span><span>&lt;</span><span>MojitoListener</span><span>&lt;</span><span>V</span><span>></span><span>></span></span> listeners <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n\n    <span>/**\n     * 是否被撤销了\n     */</span>\n    <span>private</span> <span>boolean</span> cancelled <span>=</span> <span>false</span><span>;</span>\n\n    <span>/**\n     * 并发锁\n     */</span>\n    <span>private</span> <span>final</span> <span>ReentrantLock</span> lock <span>=</span> <span>new</span> <span>ReentrantLock</span><span>(</span><span>)</span><span>;</span>\n\n    <span>/**\n     * get 阻塞条件,用于完成时候唤醒get阻塞线程\n     */</span>\n    <span>private</span> <span>final</span> <span>Condition</span> condition <span>=</span> lock<span>.</span><span>newCondition</span><span>(</span><span>)</span><span>;</span>\n\n    <span>/**\n     * get超时阻塞条件,,用于完成时候唤醒get阻塞线程\n     */</span>\n    <span>private</span> <span>final</span> <span>Condition</span> timeoutCondition <span>=</span> lock<span>.</span><span>newCondition</span><span>(</span><span>)</span><span>;</span>\n    \n    <span>/**\n     * 原子操作\n     *\n     * @param objResult 数据\n     * @return boolean\n     */</span>\n    <span>private</span> <span>boolean</span> <span>setValue0</span><span>(</span><span>Object</span> objResult<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>RESULT_UPDATER<span>.</span><span>compareAndSet</span><span>(</span><span>this</span><span>,</span> <span>null</span><span>,</span> objResult<span>)</span> <span>||</span>\n                RESULT_UPDATER<span>.</span><span>compareAndSet</span><span>(</span><span>this</span><span>,</span> EMPTY<span>,</span> objResult<span>)</span><span>)</span> <span>{</span>\n            <span>return</span> <span>true</span><span>;</span>\n        <span>}</span>\n        <span>return</span> <span>false</span><span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>boolean</span> <span>isSuccess</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>isDone</span><span>(</span><span>)</span> <span>&amp;&amp;</span> result <span>!=</span> EMPTY<span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>setSuccess</span><span>(</span><span>V</span> data<span>)</span> <span>{</span>\n        <span>boolean</span> updateSuccess<span>;</span>\n        <span>try</span> <span>{</span>\n            lock<span>.</span><span>lock</span><span>(</span><span>)</span><span>;</span>\n            updateSuccess <span>=</span> <span>setValue0</span><span>(</span>data<span>)</span><span>;</span>\n            condition<span>.</span><span>signalAll</span><span>(</span><span>)</span><span>;</span>\n            timeoutCondition<span>.</span><span>signalAll</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span> <span>finally</span> <span>{</span>\n            lock<span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>if</span> <span>(</span>updateSuccess<span>)</span> <span>{</span>\n            <span>for</span> <span>(</span><span>MojitoListener</span><span><span>&lt;</span><span>V</span><span>></span></span> listener <span>:</span> listeners<span>)</span> <span>{</span>\n                listener<span>.</span><span>onSuccess</span><span>(</span>data<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>setFailure</span><span>(</span><span>Throwable</span> cause<span>)</span> <span>{</span>\n        <span>boolean</span> updateSuccess<span>;</span>\n        <span>try</span> <span>{</span>\n            lock<span>.</span><span>lock</span><span>(</span><span>)</span><span>;</span>\n            updateSuccess <span>=</span> <span>setValue0</span><span>(</span>EMPTY<span>)</span><span>;</span>\n            condition<span>.</span><span>signalAll</span><span>(</span><span>)</span><span>;</span>\n            timeoutCondition<span>.</span><span>signalAll</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span> <span>finally</span> <span>{</span>\n            lock<span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>if</span> <span>(</span>updateSuccess<span>)</span> <span>{</span>\n            <span>for</span> <span>(</span><span>MojitoListener</span><span><span>&lt;</span><span>V</span><span>></span></span> listener <span>:</span> listeners<span>)</span> <span>{</span>\n                listener<span>.</span><span>onThrowable</span><span>(</span>cause<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n\n\n    <span>@Override</span>\n    <span>public</span> <span>boolean</span> <span>cancel</span><span>(</span><span>boolean</span> mayInterruptIfRunning<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>cancelled <span>=</span> mayInterruptIfRunning<span>;</span>\n        <span>return</span> <span>false</span><span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>boolean</span> <span>isCancelled</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> cancelled<span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>boolean</span> <span>isDone</span><span>(</span><span>)</span> <span>{</span>\n        <span>// 只要不等于空,说明就是有结果了,不管成功或者失败</span>\n        <span>return</span> result <span>!=</span> <span>null</span><span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>V</span> <span>get</span><span>(</span><span>)</span> <span>throws</span> <span>InterruptedException</span><span>,</span> <span>ExecutionException</span> <span>{</span>\n        lock<span>.</span><span>lock</span><span>(</span><span>)</span><span>;</span>\n        <span>try</span> <span>{</span>\n            <span>if</span> <span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>isInterrupted</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n                <span>throw</span> <span>new</span> <span>InterruptedException</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span> <span>else</span> <span>{</span>\n                <span>// 如果没有完成并且没有撤销</span>\n                <span>if</span> <span>(</span><span>!</span><span>isDone</span><span>(</span><span>)</span> <span>&amp;&amp;</span> <span>!</span><span>isCancelled</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n                    <span>// 释放线程,任务在这里阻塞,等待完成时候释放.</span>\n                    condition<span>.</span><span>await</span><span>(</span><span>)</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span> <span>finally</span> <span>{</span>\n            lock<span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> <span>isSuccess</span><span>(</span><span>)</span> <span>?</span> result <span>:</span> <span>null</span><span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>V</span> <span>get</span><span>(</span><span>long</span> timeout<span>,</span> <span>TimeUnit</span> unit<span>)</span> <span>throws</span> <span>InterruptedException</span><span>,</span> <span>ExecutionException</span><span>,</span> <span>TimeoutException</span> <span>{</span>\n        lock<span>.</span><span>lock</span><span>(</span><span>)</span><span>;</span>\n        <span>try</span> <span>{</span>\n            <span>if</span> <span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>isInterrupted</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n                <span>throw</span> <span>new</span> <span>InterruptedException</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span> <span>else</span> <span>{</span>\n                <span>// 如果没有完成并且没有撤销</span>\n                <span>if</span> <span>(</span><span>!</span><span>isDone</span><span>(</span><span>)</span> <span>&amp;&amp;</span> <span>!</span><span>isCancelled</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n                    <span>// 释放线程,任务在这里阻塞,等待完成时候释放.</span>\n                    <span>boolean</span> await <span>=</span> timeoutCondition<span>.</span><span>await</span><span>(</span>timeout<span>,</span> unit<span>)</span><span>;</span>\n                    <span>if</span> <span>(</span><span>!</span>await<span>)</span> <span>{</span>\n                        <span>throw</span> <span>new</span> <span>TimeoutException</span><span>(</span><span>)</span><span>;</span>\n                    <span>}</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span> <span>finally</span> <span>{</span>\n            lock<span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> <span>isSuccess</span><span>(</span><span>)</span> <span>?</span> result <span>:</span> <span>null</span><span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>addListeners</span><span>(</span><span>MojitoListener</span><span><span>&lt;</span><span>V</span><span>></span></span> listener<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>listeners<span>.</span><span>add</span><span>(</span>listener<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br><span>135</span><br><span>136</span><br><span>137</span><br><span>138</span><br><span>139</span><br><span>140</span><br><span>141</span><br><span>142</span><br><span>143</span><br><span>144</span><br><span>145</span><br><span>146</span><br><span>147</span><br><span>148</span><br><span>149</span><br><span>150</span><br><span>151</span><br><span>152</span><br><span>153</span><br><span>154</span><br><span>155</span><br><span>156</span><br><span>157</span><br><span>158</span><br></div></div><h3 id=\"_4-6-fluent-api\"> 4.6 Fluent API</h3>\n<p>好了,前面我们快速的学习了Netty的API,后面我们使用了Netty来实现了我们的底层通信能力。但是这里还是太复杂了,最后我们要为这些复杂的对象,设计一套简单的使用API。API的风格决定使用 <code>Fluent API</code></p>\n<blockquote>\n<p>fluent-API 是一种面向对象的 API，其设计主要基于方法链。\n这个概念由​Eric Evans​和​Martin Fowler​于 2005 年创建，旨在通过创建特定领域语言 ( DSL )来提高代码可读性。</p>\n</blockquote>\n<p>在实践中，创建一个流畅的 API，<code>就是不需要记住接下来的步骤或方法</code>，一切都是那么的自然和连续,下一步的动作，就好像它是一个<code>选项菜单</code>,让我们的选择。</p>\n<p>关键词: <strong>自然连续</strong>，<strong>无需记住</strong></p>\n<p>这里面主要是对Java泛型的利用,主要实现在这里,基本都是泛型,所以要好好看。建议获取源码,运行走走。</p>\n<div><pre><code>mojito/mojito-net/src/main/java/cn/lxchinesszz/mojito/fluent on  master [»!?] \n➜ tree               \n.\n├── AbstractFactory.java\n├── ConfigurableFactory.java\n├── Factory.java\n└── Mojito.java\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>下面我们来展示,来看下这个API,是否合乎你的心意呢?</p>\n<ol>\n<li>服务端</li>\n</ol>\n<div><pre><code><span>class</span> <span>MojitoTest</span><span>{</span>\n    <span>/**\n     * @author liuxin\n     * 个人博客：https://java.springlearn.cn\n     * 公众号：西魏陶渊明  ｛关注获取学习源码｝\n     * 2022/8/11 23:12\n     */</span>\n    <span>@Test</span>\n    <span>@DisplayName</span><span>(</span><span>\"构建服务端【阻塞方式】\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>server</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>Server</span><span><span>&lt;</span><span>?</span><span>></span></span> server <span>=</span> <span>Mojito</span><span>.</span><span>server</span><span>(</span><span>RpcRequest</span><span>.</span><span>class</span><span>,</span> <span>RpcResponse</span><span>.</span><span>class</span><span>)</span>\n                <span>// 业务层,读取请求对象,返回结果</span>\n                <span>.</span><span>businessHandler</span><span>(</span><span>(</span>channelContext<span>,</span> request<span>)</span> <span>-></span> <span>new</span> <span>RpcResponse</span><span>(</span><span>)</span><span>)</span>\n                <span>.</span><span>create</span><span>(</span><span>)</span><span>;</span>\n        server<span>.</span><span>start</span><span>(</span><span>6666</span><span>)</span><span>;</span>\n    <span>}</span>\n    \n    <span>/**\n     * @author liuxin\n     * 个人博客：https://java.springlearn.cn\n     * 公众号：西魏陶渊明  ｛关注获取学习源码｝\n     * 2022/8/11 23:12\n     */</span>\n    <span>@Test</span>\n    <span>@DisplayName</span><span>(</span><span>\"构建服务端【非阻塞方式】\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>serverAsync</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>Server</span><span><span>&lt;</span><span>?</span><span>></span></span> server <span>=</span> <span>Mojito</span><span>.</span><span>server</span><span>(</span><span>RpcRequest</span><span>.</span><span>class</span><span>,</span> <span>RpcResponse</span><span>.</span><span>class</span><span>)</span>\n                <span>// 业务层,读取请求对象,返回结果</span>\n                <span>.</span><span>businessHandler</span><span>(</span><span>(</span>channelContext<span>,</span> request<span>)</span> <span>-></span> <span>new</span> <span>RpcResponse</span><span>(</span><span>)</span><span>)</span>\n                <span>.</span><span>create</span><span>(</span><span>)</span><span>;</span>\n        server<span>.</span><span>startAsync</span><span>(</span><span>6666</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>    \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><ol start=\"2\">\n<li>客户端</li>\n</ol>\n<p>支持同步和异步两种方式</p>\n<div><pre><code>   <span>/**\n     * @author liuxin\n     * 个人博客：https://java.springlearn.cn\n     * 公众号：西魏陶渊明  ｛关注获取学习源码｝\n     * 2022/8/11 23:12\n     */</span>\n    <span>@Test</span>\n    <span>@DisplayName</span><span>(</span><span>\"构建客户端【异步方式】\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>clientAsync</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>// 构建连接</span>\n        <span>Client</span><span><span>&lt;</span><span>RpcRequest</span><span>,</span> <span>RpcResponse</span><span>></span></span> client <span>=</span> <span>Mojito</span><span>.</span><span>client</span><span>(</span><span>RpcRequest</span><span>.</span><span>class</span><span>,</span> <span>RpcResponse</span><span>.</span><span>class</span><span>)</span>\n                <span>.</span><span>connect</span><span>(</span><span>\"127.0.0.1\"</span><span>,</span> <span>6666</span><span>)</span><span>;</span>\n\n        <span>MojitoFuture</span><span><span>&lt;</span><span>RpcResponse</span><span>></span></span> sendFuture <span>=</span> client<span>.</span><span>sendAsync</span><span>(</span><span>new</span> <span>RpcRequest</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        sendFuture<span>.</span><span>addListeners</span><span>(</span><span>new</span> <span>MojitoListener</span><span><span>&lt;</span><span>RpcResponse</span><span>></span></span><span>(</span><span>)</span> <span>{</span>\n            <span>@Override</span>\n            <span>public</span> <span>void</span> <span>onSuccess</span><span>(</span><span>RpcResponse</span> result<span>)</span> <span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"收到结果:\"</span> <span>+</span> result<span>)</span><span>;</span>\n            <span>}</span>\n\n            <span>@Override</span>\n            <span>public</span> <span>void</span> <span>onThrowable</span><span>(</span><span>Throwable</span> throwable<span>)</span> <span>{</span>\n                <span>System</span><span>.</span>err<span>.</span><span>println</span><span>(</span><span>\"处理失败:\"</span> <span>+</span> throwable<span>.</span><span>getMessage</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n        <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>join</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * @author liuxin\n     * 个人博客：https://java.springlearn.cn\n     * 公众号：西魏陶渊明  ｛关注获取学习源码｝\n     * 2022/8/11 23:12\n     */</span>\n    <span>@Test</span>\n    <span>@DisplayName</span><span>(</span><span>\"构建客户端【同步方式】\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>clientSync</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span><span>{</span>\n        <span>Client</span><span><span>&lt;</span><span>RpcRequest</span><span>,</span> <span>RpcResponse</span><span>></span></span> client <span>=</span> <span>Mojito</span><span>.</span><span>client</span><span>(</span><span>RpcRequest</span><span>.</span><span>class</span><span>,</span> <span>RpcResponse</span><span>.</span><span>class</span><span>)</span>\n                <span>.</span><span>connect</span><span>(</span><span>\"127.0.0.1\"</span><span>,</span> <span>6666</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>client<span>.</span><span>send</span><span>(</span><span>new</span> <span>RpcRequest</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><ol start=\"3\">\n<li>启动演示</li>\n</ol>\n<p>当看到下面的Logo说明服务已经启动成功了。</p>\n<div><pre><code> ___      ___     ______      ___  __  ___________  ______    \n|&quot;  \\    /&quot;  |   /    &quot; \\    |&quot;  ||&quot; \\(&quot;     _   &quot;)/    &quot; \\   \n \\   \\  //   |  // ____  \\   ||  |||  |)__/  \\\\__/// ____  \\  \n /\\\\  \\/.    | /  /    ) :)  |:  ||:  |   \\\\_ /  /  /    ) :) \n|: \\.        |(: (____/ //___|  / |.  |   |.  | (: (____/ //  \n|.  \\    /:  | \\        //  :|_/ )/\\  |\\  \\:  |  \\        /   \n|___|\\__/|___|  \\&quot;_____/(_______/(__\\_|_)  \\__|   \\&quot;_____/   \n\n :: Mojito ::                                     \n麻烦给我的爱人来一杯Mojito,我喜欢阅读她微醺时的眼眸！\n22:53:44.652 [mojito-boss-thread-1] INFO cn.lxchinesszz.mojito.server.netty.NettyServer - Mojito启动成功,端口号:6666\n22:53:44.653 [mojito-boss-thread-1] INFO io.netty.handler.logging.LoggingHandler - [id: 0x7fc4d842, L:/0:0:0:0:0:0:0:0:6666] ACTIVE\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>Fluent API 风格是自然联系的,仿佛就跟菜单一样,根本不需要去记API。一起都是那么的自然。</p>\n<h2 id=\"五、总结\"> 五、总结</h2>\n<p>本篇文章爆肝了11天, 因为只有晚上下班,回来才有时间来思考总结。所以进度有点慢。</p>\n<p>文章前部分介绍 <code>Netty API</code>,后半部分介绍基于 <code>Netty</code> 来设计我们的通信层。最终通过\n<code>Fluent API</code> 的风格,将复杂的代码,通过简单的API给暴露了出来。</p>\n<p>但是做到这一步只能说是完成了需求,后面我们还要做压测和调优。</p>\n<ol>\n<li>是否可以使用多线程?</li>\n<li>耗时对象是否可以进行池化?</li>\n<li>序列化为什么还没有支持 <code>Protostuff</code>?</li>\n<li>各种异常场景是否都捕捉到了,给出清晰的提示?</li>\n<li>能否提供更多的扩展功能?</li>\n</ol>\n<p><code>mojito-net</code> 只能做RPC吗? 难道不能做一个简单的 <code>web</code>容器? 难道不能实现一个<code>mq</code> 吗?</p>\n<p>😊 那么你准备好跟我一起Coding了吗?，如果喜欢麻烦点个关注。</p>\n<p><img src=\"https://img.springlearn.cn/blog/dcdc576db14dda19819196a4dba05a21.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://img.springlearn.cn/blog/26890ec0ad52a3b8bb3c0470c43c95a5.png",
      "date_published": "2022-08-22T01:35:49.000Z",
      "date_modified": "2022-08-22T01:35:49.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "mojito"
      ]
    },
    {
      "title": "幻灯片页",
      "url": "https://java.springlearn.cn/learn/slides/",
      "id": "https://java.springlearn.cn/learn/slides/",
      "content_html": "\n<i>Not supported content</i>",
      "image": "https://java.springlearn.cn/logo.svg",
      "date_published": "2021-12-21T05:46:37.000Z",
      "date_modified": "2021-12-21T05:46:37.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Spring EL表达式使用指南",
      "url": "https://java.springlearn.cn/learn/spring/EL/",
      "id": "https://java.springlearn.cn/learn/spring/EL/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/learn_1610710891000.png\" alt=\"\" loading=\"lazy\"></p>\n<Djt/>\n<blockquote>\n<p>好久没有发现这么好的文章了,今天逛头条发现了一篇好文章,在这里转载一下\n大家可以学习一下,文章原文地址见参考。希望支持原作者,在头条点一个关注。</p>\n</blockquote>\n<h2 id=\"一、概述\"> 一、概述</h2>\n<p>Spring表达式语言全称为“Spring Expression Language”，缩写为“SpEL”。是一个支持查询，并在运行时操纵一个对象图功能、是一门强大的表达式语言。SpEL是单独模块，只依赖于core模块，可以被独立使用、运行。</p>\n<p><strong>参考文章</strong></p>\n<p><a href=\"https://docs.spring.io/spring-integration/docs/5.3.0.RELEASE/reference/html/spel.html#spel\" target=\"_blank\" rel=\"noopener noreferrer\">SpringEpel</a></p>\n<p><a href=\"https://www.toutiao.com/i6911604368844292620/\" target=\"_blank\" rel=\"noopener noreferrer\">玩转SpEL</a></p>\n<h2 id=\"二、作用\"> 二、作用</h2>\n<h3 id=\"_2-1-基本表达式\"> 2.1 基本表达式</h3>\n<p>字面量表达式、关系，逻辑与算数运算表达式、字符串连接及截取表达式、三目运算、正则表达式、括号优先级表达式；</p>\n<h3 id=\"_2-2-类相关表达式\"> 2.2 类相关表达式</h3>\n<p>类类型表达式、类实例化、instanceof表达式、变量定义及引用、赋值表达式、自定义函数、对象属性存取及安全导航表达式、对象方法调用、Bean引用；</p>\n<h3 id=\"_2-3-集合相关表达式\"> 2.3 集合相关表达式</h3>\n<p>内联List、内联数组、集合，字典访问、列表，字典，数组修改、集合投影、集合选择；不支持多维内联数组初始化；不支持内联字典定义；</p>\n<h3 id=\"_2-4-其他表达式\"> 2.4 其他表达式</h3>\n<p>模板表达式。</p>\n<h2 id=\"三、主要类\"> 三、主要类</h2>\n<h3 id=\"_3-1-expressionparser\"> 3.1 ExpressionParser</h3>\n<p>表达式解析器接口，包含了(Expression) parseExpression(String), (Expression) parseExpression(String, ParserContext)两个接口方法</p>\n<h3 id=\"_3-2-parsercontext\"> 3.2 ParserContext</h3>\n<p>解析器上下文接口，主要是对解析器Token的抽象类，包含3个方法：getExpressionPrefix,getExpressionSuffix和isTemplate，就是表示表达式从什么符号开始什么符号结束，是否是作为模板（包含字面量和表达式）解析。</p>\n<h3 id=\"_3-3-expression\"> 3.3 Expression</h3>\n<p>表达式的抽象，是经过解析后的字符串表达式的形式表示。通过expressionInstance.getValue方法，可以获取表示式的值。也可以通过调用getValue(EvaluationContext)，从评估（evaluation)上下文中获取表达式对于当前上下文的值</p>\n<h3 id=\"_3-4-evaluationcontext\"> 3.4 EvaluationContext</h3>\n<p>估值上下文接口，只有一个setter方法：<code>setVariable(String, Object)</code>，通过调用该方法，可以为evaluation提供上下文变量</p>\n<h2 id=\"四、案例运用\"> 四、案例运用</h2>\n<h3 id=\"_4-1-基础的hello\"> 4.1 基础的Hello</h3>\n<div><pre><code>@Test\npublic void baseTest() {\n// 字符串表达式\n    String exp = &quot;Hello , #{ #username }&quot;;\n    // 表达式解析器\n    ExpressionParser parser = new SpelExpressionParser();\n    // 表达式上下文\n    EvaluationContext context = new StandardEvaluationContext();\n    context.setVariable(&quot;username&quot;, &quot;纹银三百两&quot;);\n    // 解析\n    Expression expression = parser.parseExpression(exp, new TemplateParserContext());\n    System.out.println(expression.getValue(context, String.class));\n  }\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>基础结果：</p>\n<div><pre><code>Hello , 纹银三百两\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"_4-2-关系运算符\"> 4.2 关系运算符</h3>\n<div><pre><code>//true\nboolean trueValue1 = parser.parseExpression(&quot;2 == 2&quot;).getValue(Boolean.class);\n//false\nboolean falseValue1 = parser.parseExpression(&quot;2 &lt; -5.0&quot;).getValue(Boolean.class);\n//true\nboolean trueValue2 = parser.parseExpression(&quot;&#39;black&#39; &lt; &#39;block&#39;&quot;).getValue(Boolean.class);\n//false，字符xyz是否为int类型\nboolean falseValue2 = parser.parseExpression(&quot;&#39;xyz&#39; instanceof T(int)&quot;).getValue(Boolean.class);\n//true，正则是否匹配\nboolean trueValue3 =parser.parseExpression(&quot;&#39;5.00&#39; matches &#39;^-?\\\\d+(\\\\.\\\\d{2})?$&#39;&quot;).getValue(Boolean.class);\n//false\nboolean falseValue3=parser.parseExpression(&quot;&#39;5.0067&#39; matches &#39;^-?\\\\d+(\\\\.\\\\d{2})?$&#39;&quot;).getValue(Boolean.class);\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id=\"_4-3-逻辑运算符\"> 4.3 逻辑运算符</h3>\n<div><pre><code>// -- AND 与运算 --\n//false \nboolean falseValue4 = parser.parseExpression(&quot;true and false&quot;).getValue(Boolean.class);\n // -- OR 或运算--\n//true\nboolean trueValue5 = parser.parseExpression(&quot;true or false&quot;).getValue(Boolean.class);\n//false\nboolean falseValue5 = parser.parseExpression(&quot;!true&quot;).getValue(Boolean.class);\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id=\"_4-4-算术运算符\"> 4.4 算术运算符</h3>\n<div><pre><code>// Addition\nint two = parser.parseExpression(&quot;1 + 1&quot;).getValue(Integer.class); // 2\nString testString =\nparser.parseExpression(&quot;&#39;test&#39; + &#39; &#39; + &#39;string&#39;&quot;).getValue(String.class); // &#39;test string&#39;\n// Subtraction\nint four = parser.parseExpression(&quot;1 - -3&quot;).getValue(Integer.class); // 4\ndouble d = parser.parseExpression(&quot;1000.00 - 1e4&quot;).getValue(Double.class); // -9000\n// Multiplication\nint six = parser.parseExpression(&quot;-2 * -3&quot;).getValue(Integer.class); // 6\ndouble twentyFour = parser.parseExpression(&quot;2.0 * 3e0 * 4&quot;).getValue(Double.class); // 24.0\n// Division\nint minusTwo = parser.parseExpression(&quot;6 / -3&quot;).getValue(Integer.class); // -2\ndouble one = parser.parseExpression(&quot;8.0 / 4e0 / 2&quot;).getValue(Double.class); // 1.0\n// Modulus\nint three = parser.parseExpression(&quot;7 % 4&quot;).getValue(Integer.class); // 3\nint one = parser.parseExpression(&quot;8 / 5 % 2&quot;).getValue(Integer.class); // 1\n// Operator precedence\nint minusTwentyOne = parser.parseExpression(&quot;1+2-3*8&quot;).getValue(Integer.class); // -21\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h2 id=\"五、组合使用\"> 五、组合使用</h2>\n<div><pre><code>@Test\n  public void expressionTest() {\n    String exp = &quot;1 between {1, 2} and 1&gt;2&quot;;\n    ExpressionParser parser = new SpelExpressionParser();\n    Expression expression = parser.parseExpression(exp);\n    //false\n    System.out.println(expression.getValue(boolean.class));\n  }\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id=\"六、操作类\"> 六、操作类</h2>\n<h3 id=\"_6-1-类类型\"> 6.1 类类型</h3>\n<div><pre><code>@Test\npublic void classTypeTest() {\n    ExpressionParser parser = new SpelExpressionParser();\n    //java.lang包类访问\n    Class&lt;String&gt; result1 = parser.parseExpression(&quot;T(String)&quot;).getValue(Class.class);\n    //class java.lang.String\n    System.out.println(result1);\n\n    //其他包类访问\n    String expression2 = &quot;T(spel.SpElTest)&quot;;\n    Class&lt;SpElTest&gt; value = parser.parseExpression(expression2).getValue(Class.class);\n    //true\n    System.out.println(value == SpElTest.class);\n\n    //类静态字段访问\n    int result3 = parser.parseExpression(&quot;T(Integer).MAX_VALUE&quot;).getValue(int.class);\n    //true\n    System.out.println(result3 == Integer.MAX_VALUE);\n\n    //类静态方法调用\n    int result4 = parser.parseExpression(&quot;T(Integer).parseInt(&#39;1&#39;)&quot;).getValue(int.class);\n    //1\n    System.out.println(result4);\n  }\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h3 id=\"_6-2-自定义函数\"> 6.2 自定义函数</h3>\n<div><pre><code>/**\n   * 两数之和\n   */\npublic static Integer add(Integer x, Integer y) {\n    return x + y;\n  }\n\n@Test\npublic void functionTest() throws NoSuchMethodException {\n    // 表达式\n    String exp = &quot;#{ #add(4,5)}&quot;;\n    // 表达式上下文\n    StandardEvaluationContext context = new StandardEvaluationContext();\n    Method add = SpElTest.class.getDeclaredMethod(&quot;add&quot;, Integer.class, Integer.class);\n    context.registerFunction(&quot;add&quot;, add);\n    // 表达式解析器\n    ExpressionParser parser = new SpelExpressionParser();\n    // 解析\n    Expression expression = parser.parseExpression(exp, new TemplateParserContext());\n    // 9\n    System.out.println(expression.getValue(context, Integer.class));\n  }\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h3 id=\"_6-3-类属性\"> 6.3 类属性</h3>\n<div><pre><code> @Test\n  public void assignTest() {\n    String exp = &quot;username: #{#user.username},age: #{#user.age}&quot;;\n    StandardEvaluationContext context = new StandardEvaluationContext();\n    Person person = new Person()\n        .setUsername(&quot;纹银三百两&quot;)\n        .setAge(23);\n    context.setVariable(&quot;user&quot;, person);\n    ExpressionParser parser = new SpelExpressionParser();\n    Expression expression = parser.parseExpression(exp, new TemplateParserContext());\n    //username: 纹银三百两,age: 23\n    System.out.println(expression.getValue(context, String.class));\n  }\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id=\"七、模板表达式\"> 七、模板表达式</h2>\n<p>指定模板 <code>%{ }</code></p>\n<div><pre><code>@Test\npublic void templateTest() {\n    SpelExpressionParser parser = new SpelExpressionParser();\n    ParserContext context = new TemplateParserContext(&quot;%{&quot;, &quot;}&quot;);\n    Expression expression = parser.parseExpression(&quot;你好:%{#name},正在学习:%{#lesson}，加油、奋斗！！！&quot;, context);\n    EvaluationContext evaluationContext = new StandardEvaluationContext();\n    evaluationContext.setVariable(&quot;name&quot;, &quot;纹银三百两&quot;);\n    evaluationContext.setVariable(&quot;lesson&quot;, &quot;spring高手系列。&quot;);\n    String value = expression.getValue(evaluationContext, String.class);\n    //你好:纹银三百两,正在学习:spring高手系列。加油、奋斗！！！\n    System.out.println(value);\n  }\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id=\"八、规则引擎\"> 八、规则引擎</h2>\n<h3 id=\"_8-1-背景\"> 8.1 背景</h3>\n<p>假设人员注册信息(姓名、年龄、性别），自定义其中规则，如下：</p>\n<p>李家好汉（李姓，男，且满18岁）\n豆蔻少女（13-15岁，女性）</p>\n<h3 id=\"_8-2-实现\"> 8.2 实现</h3>\n<div><pre><code>@Test\n  public void ruleTest() {\n    Person person1 = new Person().setUsername(&quot;小龙女&quot;).setAge(14).setSex(1);\n    checkRule(FastJsonUtil.parseMap(JSON.toJSONString(person1)));\n    Person person2 = new Person().setUsername(&quot;张三&quot;).setAge(18).setSex(0);\n    checkRule(FastJsonUtil.parseMap(JSON.toJSONString(person2)));\n    Person person3 = new Person().setUsername(&quot;李四&quot;).setAge(20).setSex(0);\n    checkRule(FastJsonUtil.parseMap(JSON.toJSONString(person3)));\n\n  }\n\n  /**\n   * 规则check\n   *\n   * @param exp 参数map\n   */\n  private static void checkRule(Map&lt;String, Object&gt; exp) {\n    ExpressionParser parser = new SpelExpressionParser();\n    //规则容器\n    Map&lt;String, String&gt; ruleMap = Maps.newHashMap();\n    String rule1 = &quot;( #username.contains({&#39;李&#39;}) and  #age &gt; 18 and #sex == 0 )&quot;;\n    ruleMap.put(&quot;李家好汉&quot;, rule1);\n    String rule2 = &quot;( #age between {13,15} and #sex == 1 )&quot;;\n    ruleMap.put(&quot;豆蔻少女&quot;, rule2);\n    EvaluationContext spElContext = getSpElContext(exp);\n    ruleMap.keySet().forEach(key -&gt; {\n      String ruleV = ruleMap.get(key);\n      Boolean isPass = parser.parseExpression(ruleV).getValue(spElContext, Boolean.class);\n      if (Objects.nonNull(isPass) &amp;&amp; isPass) {\n        System.out.println(&quot;username:【&quot; + exp.get(&quot;username&quot;) + &quot;】,命中规则:【&quot; + key+&quot;】&quot;);\n      }\n\n    });\n  }\n\n  /**\n   * 解析表达式需要的上下文，透传请求参数\n   *\n   * @param param 参数\n   * @return 返回结果\n   */\n  private static EvaluationContext getSpElContext(Map&lt;String, Object&gt; param) {\n    StandardEvaluationContext evaluationContext = new StandardEvaluationContext();\n    for (Entry&lt;String, Object&gt; entry : param.entrySet()) {\n      if (entry.getValue() != null) {\n        evaluationContext.setVariable(entry.getKey(), entry.getValue());\n      }\n    }\n    return evaluationContext;\n  }\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br></div></div><p><strong>结果：</strong></p>\n<div><pre><code>username:【小龙女】,命中规则:【豆蔻少女】\nusername:【李四】,命中规则:【李家好汉】\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h2 id=\"九、总结\"> 九、总结</h2>\n<p>Spring EL表达式，作为JAVA的内置语言，十分强大。主要可以用来做表达式解析，或者规则链路，且可以操作函数方法；从而达到一种动态的链路规则解析效果。</p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1610710891000.png",
      "date_published": "2022-04-12T17:26:01.000Z",
      "date_modified": "2023-02-08T03:23:43.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Spring Framework"
      ]
    },
    {
      "title": "Spring Boot Endpoint监控端点扩展",
      "url": "https://java.springlearn.cn/learn/spring/Endpoint%E7%9B%91%E6%8E%A7%E7%AB%AF%E7%82%B9%E6%89%A9%E5%B1%95/",
      "id": "https://java.springlearn.cn/learn/spring/Endpoint%E7%9B%91%E6%8E%A7%E7%AB%AF%E7%82%B9%E6%89%A9%E5%B1%95/",
      "content_html": "<div><p>提示</p>\n<p>什么是端点? 端点就是SpringBoot通过web或者jmx的方式向外部暴露应用的信息,或者上下文的信息。SpringCloud-Admin就是根据此技术来进行实现的。他们用到的技术就是@Endpoint，而不是通过自己@GetMapping之类进行实现的。下面小编就带大家一起来学习端点的使用。学会本文后在利用前面我们讲过的autoconfigure的自动化配置后，你就可以开发更高级的SpringBoot应用(非业务系统)。本教程将带你从业务系统开发者转变为研发系统开发者。</p>\n</div>\n<p>用过SpringBoot的同学可能知道，SpringBoot有很多监控端点,比如当我们引入健康监控组件</p>\n<div><pre><code><span><span><span>&lt;</span>dependency</span><span>></span></span>\n  <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n  <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-starter-actuator<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n  <span><span><span>&lt;</span>version</span><span>></span></span>2.6.7<span><span><span>&lt;/</span>version</span><span>></span></span>\n<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>系统就会自动暴露出许多,web端口供外部调用，获取应用的信息，或者上下文的信息。</p>\n<p><img src=\"https://img.springlearn.cn/learn_010cf865b5c13bd4a2c855dbf383a81d.jpg\" alt=\"image-20190308191019856\" loading=\"lazy\"></p>\n<h2 id=\"一、如何定义端点\"> 一、如何定义端点</h2>\n<p>可以使用<code>@Endpoint</code>,<code>@WebEndpoint</code>,<code>@JmxEndpoint</code>,或者<code>EndpointWebExtension</code>来实现HTTP方式的端点,可以是传统SpringMVC也可以是最新的<code>Spring WebFlux</code></p>\n<ul>\n<li>\n<p><code>@Endpoint</code>相当于<code>@WebEndpoint</code>和<code>@JmxEndpoint</code>的整合。web和jmx方式都支持</p>\n</li>\n<li>\n<p><code>@WebEndpoint</code> 只会生成web的方式的端点监控</p>\n</li>\n</ul>\n<p><img src=\"https://img.springlearn.cn/learn_b2c367712133b4affaf175b38eaad3cc.jpg\" alt=\"image-20190308190517126\" loading=\"lazy\"></p>\n<ul>\n<li><code>JmxEndpoint</code> 只会生成Jmx的方式监控</li>\n</ul>\n<p><img src=\"https://img.springlearn.cn/learn_6490cd4917d5633fbbe9b205eb191dde.jpg\" alt=\"image-20190308183731989\" loading=\"lazy\"></p>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>HTTP method</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>@ReadOperation</code></td>\n<td><code>GET</code></td>\n</tr>\n<tr>\n<td><code>@WriteOperation</code></td>\n<td><code>POST</code></td>\n</tr>\n<tr>\n<td><code>@DeleteOperation</code></td>\n<td><code>DELETE</code></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"二、路径规则\"> 二、路径规则</h2>\n<p>默认的基础路径是<code>/actuator</code>,如果一个端点配置的路径是<code>sessions</code>,那么它的全路径就是<code>/actuator/sessions</code></p>\n<div><pre><code><span>@Component</span>\n<span>@WebEndpoint</span><span>(</span>id <span>=</span> <span>\"sessions\"</span><span>)</span>\n<span>public</span> <span>class</span> <span>MyHealthEndpoint</span> <span>{</span>\n  <span>@ReadOperation</span>\n  <span>public</span> <span>Info</span> <span>get</span><span>(</span><span>@Selector</span> <span>String</span> name<span>)</span> <span>{</span>\n    <span>return</span> <span>new</span> <span>Info</span><span>(</span>name<span>,</span> <span>\"23\"</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><code>@Selector</code> 的含义是让这个路径变成<code>/actuator/sessions/{name}</code> 我们能从路径上获取一个入参。</p>\n<h2 id=\"三、相关配置\"> 三、相关配置</h2>\n<h3 id=\"_3-1-自定义管理端点路径\"> 3.1 自定义管理端点路径</h3>\n<p><code>management.endpoints.web.base-path = /manage</code></p>\n<p>此配置会将<code>/actuator/sessions/{name}</code>转换成<code>/manage/sessions/{name}</code></p>\n<h3 id=\"_3-2-自定义管理服务器地址\"> 3.2 自定义管理服务器地址</h3>\n<p>默认端口和应用的端口是一致的,但是也可以通过配置的方式改变端口</p>\n<div><pre><code>management.server.port = 8081\nmanagement.server.address = 127.0.0.1\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"_3-3-激活端点\"> 3.3 激活端点</h3>\n<div><pre><code>//激活所有的端点的web方式请求\nmanagement.endpoints.web.exposure.include=*\n//关闭端点web方式\nmanagement.endpoints.web.exposure.exclude=env,beans\n//激活所有的JMX方式请求\nmanagement.endpoints.jmx.exposure.include=*\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id=\"_3-4-跨域方式请求\"> 3.4 跨域方式请求</h3>\n<div><pre><code>//允许跨域的网址\nmanagement.endpoints.web.cors.allowed-origins=http://example.com\n//允许跨域的方法\nmanagement.endpoints.web.cors.allowed-methods=GET,POST\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id=\"四、总结\"> 四、总结</h2>\n<p>最后我们来总结。\n其实@WebEndpoint 就相当于<code>声明成一个@RestController</code>的控制类而请求方法分别被下面注解代替。</p>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>HTTP method</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>@ReadOperation</code></td>\n<td><code>GET</code></td>\n</tr>\n<tr>\n<td><code>@WriteOperation</code></td>\n<td><code>POST</code></td>\n</tr>\n<tr>\n<td><code>@DeleteOperation</code></td>\n<td><code>DELETE</code></td>\n</tr>\n</tbody>\n</table>\n",
      "image": "https://img.springlearn.cn/learn_010cf865b5c13bd4a2c855dbf383a81d.jpg",
      "date_published": "2022-05-22T07:02:41.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "SpringBoot"
      ]
    },
    {
      "title": "Spring 启蒙",
      "url": "https://java.springlearn.cn/learn/spring/",
      "id": "https://java.springlearn.cn/learn/spring/",
      "content_html": "<div><p>为什么是春天？</p>\n<p>Spring 让每个人都可以更快、更轻松、更安全地编写 Java。Spring 对速度、简单性和生产力的关注使其成为世界上最受欢迎的Java 框架。</p>\n</div>\n<p><img src=\"https://img.springlearn.cn/blog/1c861b137fedd470229042b05bc85d97.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://img.springlearn.cn/blog/1c861b137fedd470229042b05bc85d97.png",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-09-04T13:51:11.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "AOP 使用指南",
      "url": "https://java.springlearn.cn/learn/spring/AOP/",
      "id": "https://java.springlearn.cn/learn/spring/AOP/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/learn_1593954110000.png\" alt=\"\" loading=\"lazy\"></p>\n<PageBanner/>\n<h2 id=\"\"> <a href=\"https://github.com/lxchinesszz/spring-learning\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://img.shields.io/badge/源码-AOP-green\" alt=\"\" loading=\"lazy\"></a></h2>\n<h2 id=\"一、常用注解\"> 一、常用注解</h2>\n<table>\n<thead>\n<tr>\n<th>注解</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>@Before</td>\n<td>前置通知, 在方法执行之前执行</td>\n</tr>\n<tr>\n<td>@After</td>\n<td>后置通知, 在方法执行之后执行</td>\n</tr>\n<tr>\n<td>@AfterRunning</td>\n<td>返回通知 在方法返回结果之后执行</td>\n</tr>\n<tr>\n<td>@AfterThrowing</td>\n<td>异常通知在方法抛出异常之后</td>\n</tr>\n<tr>\n<td>@Around</td>\n<td>环绕通知, 围绕着方法执行</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2 id=\"二、切面表达式\"> 二、切面表达式</h2>\n<table>\n<thead>\n<tr>\n<th>注解</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>within</td>\n<td>拦截指定类及指定包下所有的类</td>\n</tr>\n<tr>\n<td>@within</td>\n<td>拦截被指定注解修饰的类</td>\n</tr>\n<tr>\n<td>this</td>\n<td>拦截指定的类型</td>\n</tr>\n<tr>\n<td>args</td>\n<td>拦截指定参数类型的方法</td>\n</tr>\n<tr>\n<td>@annotation</td>\n<td>拦截带指定注解的方法</td>\n</tr>\n<tr>\n<td>@args</td>\n<td>拦截方法入参被中@args指定的注解(入参只能有一个)</td>\n</tr>\n<tr>\n<td>execution</td>\n<td>表达式详情见下文</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2 id=\"三、api使用案例\"> 三、API使用案例</h2>\n<h2 id=\"_3-1-within\"> 3.1 within</h2>\n<h3 id=\"a-api说明\"> a. API说明</h3>\n<ol>\n<li>精确匹配类名</li>\n<li>模糊匹配包中所有的类</li>\n<li>模糊匹配包中所有的带Impl后缀的</li>\n</ol>\n<h3 id=\"b-目录\"> b. 目录</h3>\n<div><pre><code>└── WithinMatchProcessor\n    ├── AopWithinMatchProcessor.java\n    ├── CokeImpl.java\n    ├── Water.java\n    └── readme.md\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"c-拦截代码\"> c. 拦截代码</h3>\n<div><pre><code><span>@Aspect</span>\n<span>@Component</span>\n<span>public</span> <span>class</span> <span>AopWithinMatchProcessor</span> <span>{</span>\n\n    <span>/**\n     * 精确匹配类名\n     */</span>\n    <span>@Pointcut</span><span>(</span><span>\"within(spring.learning.aop.WithinMatchProcessor.Water)\"</span><span>)</span>\n    <span>private</span> <span>void</span> <span>matchClassName</span><span>(</span><span>)</span> <span>{</span>\n    <span>}</span>\n\n    <span>/**\n     * 模糊匹配包中所有的类\n     */</span>\n    <span>@Pointcut</span><span>(</span><span>\"within(spring.learning.aop.WithinMatchProcessor.*)\"</span><span>)</span>\n    <span>private</span> <span>void</span> <span>matchAllClassFromPackage</span><span>(</span><span>)</span> <span>{</span>\n    <span>}</span>\n\n    <span>/**\n     * 模糊匹配包中所有的带Impl后缀的\n     */</span>\n    <span>@Pointcut</span><span>(</span><span>\"within(spring.learning.aop.WithinMatchProcessor.*Impl)\"</span><span>)</span>\n    <span>private</span> <span>void</span> <span>matchClassFromPackage</span><span>(</span><span>)</span> <span>{</span>\n    <span>}</span>\n\n\n    <span>@Before</span><span>(</span><span>\"matchClassName()\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>beforeMatchClassName</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"--------精确匹配类名-------\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Before</span><span>(</span><span>\"matchAllClassFromPackage()\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>beforeMatchAllClassFormPackage</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"--------模糊匹配包中所有的类-------\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Before</span><span>(</span><span>\"matchClassFromPackage()\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>beforeMatchClassFromPackage</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"--------模糊匹配包中所有的带Impl后缀的-------\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><h2 id=\"_3-2-within\"> 3.2 @within</h2>\n<h3 id=\"a-api说明-2\"> a. API说明</h3>\n<p>拦截被指定注解标注的类</p>\n<h3 id=\"b-目录-2\"> b. 目录</h3>\n<div><pre><code>├── AnnotationWithinMatchProcessor\n│   ├── AopAnnotationWithinMatchProcessor.java\n│   ├── Log.java\n│   ├── Sprite.java\n│   └── readme.md\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id=\"c-拦截代码-2\"> c. 拦截代码</h3>\n<div><pre><code><span>@Log</span><span>(</span>tag <span>=</span> <span>\"SpriteLog\"</span><span>)</span>\n<span>@Component</span>\n<span>public</span> <span>class</span> <span>Sprite</span> <span>{</span>\n\n    <span>public</span> <span>void</span> <span>drink</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"空参数\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>drink</span><span>(</span><span>Integer</span> age<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"age\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n\n    <span>public</span> <span>String</span> <span>name</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>\"Sprite.name\"</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>toCalculate</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>0</span> <span>/</span> <span>0</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>@Aspect</span>\n<span>@Component</span>\n<span>public</span> <span>class</span> <span>AopAnnotationWithinMatchProcessor</span> <span>{</span>\n\n\n    <span>/**\n     * 注意可以将注解,放到参数中,此时@within()会将参数入参名去找到注解的类型\n     * 凡是被Log标记的类,都会被拦截\n     *\n     * @param spriteLog 注解\n     */</span>\n    <span>@Before</span><span>(</span><span>\"@within(spriteLog)\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>beforeAnnotationMatch</span><span>(</span><span>Log</span> spriteLog<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"--------拦截被Log修饰类的所有方法\"</span> <span>+</span> spriteLog<span>.</span><span>tag</span><span>(</span><span>)</span> <span>+</span> <span>\"-------\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n\n    <span>/**\n     * 返回值\n     *\n     * @param value     返回值\n     * @param spriteLog 注解\n     */</span>\n    <span>@AfterReturning</span><span>(</span>value <span>=</span> <span>\"@within(spriteLog)\"</span><span>,</span> returning <span>=</span> <span>\"value\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>afterReturningAnnotationMatch</span><span>(</span><span>String</span> value<span>,</span> <span>Log</span> spriteLog<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"afterReturningAnnotationMatch返回值:\"</span> <span>+</span> value <span>+</span> <span>\",注解:\"</span> <span>+</span> spriteLog<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 拦截异常\n     *\n     * @param e         异常\n     * @param spriteLog 拦截日志\n     */</span>\n    <span>@AfterThrowing</span><span>(</span>value <span>=</span> <span>\"@within(spriteLog)\"</span><span>,</span> throwing <span>=</span> <span>\"e\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>AfterThrowingAnnotationMatch</span><span>(</span><span>Exception</span> e<span>,</span> <span>Log</span> spriteLog<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>e<span>.</span><span>getMessage</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br></div></div><h2 id=\"_3-3-this\"> 3.3 this</h2>\n<h3 id=\"a-api说明-3\"> a. API说明</h3>\n<p>拦截指定的类</p>\n<h3 id=\"b-目录-3\"> b. 目录</h3>\n<div><pre><code>├── ThisMatchProcessor\n│   ├── AopThisMatchProcessor.java\n│   ├── ThisPerson.java\n│   └── readme.md\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"c-拦截代码-3\"> c. 拦截代码</h3>\n<div><pre><code><span>@Aspect</span>\n<span>@Component</span>\n<span>public</span> <span>class</span> <span>AopThisMatchProcessor</span> <span>{</span>\n\n    <span>@Before</span><span>(</span>value <span>=</span> <span>\"this(ThisPerson)\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>thisMatch</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"--------------ThisPerson------------\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id=\"_3-4-args\"> 3.4 args</h2>\n<h3 id=\"a-api说明-4\"> a. API说明</h3>\n<div><pre><code><span>@Component</span>\n<span>public</span> <span>class</span> <span>Person</span> <span>{</span>\n\n    <span>public</span> <span>String</span> <span>info</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>\n        <span>return</span> <span>\"姓名：\"</span> <span>+</span> name<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>String</span> <span>info</span><span>(</span><span>String</span> name<span>,</span> <span>Integer</span> age<span>)</span> <span>{</span>\n        <span>return</span> <span>\"姓名：\"</span> <span>+</span> name <span>+</span> <span>\",年龄:\"</span> <span>+</span> age<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>Person类中有两个info方法,但是入参不一样,假如要拦截指定入参的方法时候,就可以使用args</p>\n<h3 id=\"b-目录-4\"> b. 目录</h3>\n<div><pre><code>├── ArgsMatchProcessor\n│   ├── AopArgsMatchProcessor.java\n│   ├── Person.java\n│   └── readme.md\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"c-拦截代码-4\"> c. 拦截代码</h3>\n<p>可以看到args 和 within可以通过&amp;&amp;来进行,联合匹配。另外可以通过returning方法指定方法的返回值。但是注意，类型要和要拦截的方法的返回类型匹配。否则会报错。</p>\n<div><pre><code><span>@Aspect</span>\n<span>@Component</span>\n<span>public</span> <span>class</span> <span>AopArgsMatchProcessor</span> <span>{</span>\n\n    <span>@AfterReturning</span><span>(</span>value <span>=</span> <span>\"within(Person) &amp;&amp; args(name,age)\"</span><span>,</span> returning <span>=</span> <span>\"value\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>beforeArgs</span><span>(</span><span>Integer</span> age<span>,</span> <span>String</span> name<span>,</span> <span>String</span> value<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"拦截器逻辑----------------------------\"</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"入参name:\"</span> <span>+</span> name<span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"入参age:\"</span> <span>+</span> age<span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"返回值:\"</span> <span>+</span> value<span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"拦截器逻辑----------------------------\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id=\"_3-5-annotation\"> 3.5 @annotation</h2>\n<h3 id=\"a-api说明-5\"> a. API说明</h3>\n<p>拦截被指定注解标记的方法。</p>\n<h3 id=\"b-目录-5\"> b. 目录</h3>\n<div><pre><code>├── AnnotationMethodMatchProcessor\n│   ├── AopAnnotationMethodMatchProcessor.java\n│   ├── LogMethod.java\n│   └── Main.java\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"c-代码\"> c. 代码</h3>\n<div><pre><code><span>@Aspect</span>\n<span>@Component</span>\n<span>public</span> <span>class</span> <span>AopAnnotationMethodMatchProcessor</span> <span>{</span>\n\n\n    <span>@Before</span><span>(</span>value <span>=</span> <span>\"@annotation(logMethod) &amp;&amp; args(args)\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>annotationMethodMatch</span><span>(</span><span>LogMethod</span> logMethod<span>,</span> <span>String</span> args<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"注解方法匹配\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id=\"_3-6-args\"> 3.6 @args</h2>\n<h3 id=\"a-api说明-6\"> a. API说明</h3>\n<p>拦截方法中入参被@args指定注解的方法。</p>\n<h3 id=\"b-目录-6\"> b. 目录</h3>\n<div><pre><code>├── AnnotationArgsMatchProcessor\n│   ├── AopAnnotationArgsMatchProcessor.java\n│   ├── Apple.java\n│   ├── Fruit.java\n│   ├── Orange.java\n│   └── Teacher.java\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id=\"c-代码-2\"> c. 代码</h3>\n<p>注意当出现以下异常说明aop声明的拦截范围太广泛了，导致了一些不能拦截的类被拦截从而报错了，此时只用缩小拦截的范围即可</p>\n<div><pre><code> Cannot subclass final class org.springframework.boot.autoconfigure.AutoConfigurationPackages$BasePackages\n</code></pre>\n<div><span>1</span><br></div></div><p>缩小拦截范围如下使用this拦截指定类型</p>\n<div><pre><code><span>@Aspect</span>\n<span>@Component</span>\n<span>public</span> <span>class</span> <span>AopAnnotationArgsMatchProcessor</span> <span>{</span>\n\n    <span>@Before</span><span>(</span>value <span>=</span> <span>\"@args(fruit) &amp;&amp; this(Teacher)\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>annotationMethodMatch</span><span>(</span><span>Fruit</span> fruit<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"拦截被Fruit+tag:\"</span><span>+</span>fruit<span>.</span><span>tag</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id=\"_3-7-execution\"> 3.7 execution</h2>\n<h3 id=\"a-api说明-7\"> a. API说明</h3>\n<p>execution()是最常用的切点函数，其语法如下所示：</p>\n<p><code>execution(&lt;修饰符模式&gt;? &lt;返回类型模式&gt; &lt;方法名模式&gt;(&lt;参数模式&gt;) &lt;异常模式&gt;?) 除了返回类型模式、方法名模式和参数模式外，其它项都是可选的</code></p>\n<table>\n<thead>\n<tr>\n<th>表达式</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>execution(public * *(..))</td>\n<td>匹配所有目标类的public方法</td>\n</tr>\n<tr>\n<td>execution(* *Test(..))</td>\n<td>匹配目标类所有以To为后缀的方法</td>\n</tr>\n<tr>\n<td>execution(<em>spring.learning.Water.</em>(..))</td>\n<td>匹配Water接口所有方法</td>\n</tr>\n<tr>\n<td>execution(<em>spring.learning.Water+.</em>(..))</td>\n<td>匹配Water接口以及实现类中所有方法(包括Water接口中没有的方法)</td>\n</tr>\n<tr>\n<td>execution(* spring.learning.*(..))</td>\n<td>匹配spring.learning包下所有的类所有方法</td>\n</tr>\n<tr>\n<td>execution(* spring.learning..*(..))</td>\n<td>匹配spring.learning包及其子孙包下所有的类所有方法</td>\n</tr>\n<tr>\n<td>execution(* spring..*.<em>Dao.find</em>(..))</td>\n<td>匹配包名前缀为spring的任何包下类名后缀为Dao的方法，方法名必须以find为前缀</td>\n</tr>\n<tr>\n<td>execution(* info(String,Integer))</td>\n<td>匹配info方法中,第一个参数是String,第二个Integer的方法</td>\n</tr>\n<tr>\n<td>execution(* info(String,*)))</td>\n<td>匹配info方法中,第一个参数是String,第二个任意类型</td>\n</tr>\n<tr>\n<td>execution(* info(String,..)))</td>\n<td>匹配info方法中,第一个参数是String,后面任意参数</td>\n</tr>\n<tr>\n<td>execution(* info(Object+)))</td>\n<td>匹配info方法中,方法拥有一个入参，且入参是Object类型或该类的子类</td>\n</tr>\n</tbody>\n</table>\n",
      "image": "https://img.springlearn.cn/blog/learn_1593954110000.png",
      "date_published": "2022-04-05T16:29:39.000Z",
      "date_modified": "2023-02-08T03:23:43.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Spring Framework"
      ]
    },
    {
      "title": "FactoryBean接口实例化",
      "url": "https://java.springlearn.cn/learn/spring/FactoryBean%E6%8E%A5%E5%8F%A3%E5%AE%9E%E4%BE%8B%E5%8C%96/",
      "id": "https://java.springlearn.cn/learn/spring/FactoryBean%E6%8E%A5%E5%8F%A3%E5%AE%9E%E4%BE%8B%E5%8C%96/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/eaf9d1d2bf5c8df466b3376235db919a.jpg\" alt=\"文章头\" loading=\"lazy\"></p>\n<blockquote>\n<p>Java编程规范中声明,Java接口类是不能直接实例化的,但是我们在平时的开发中经常会遇到只声明接口就可以直接使用的。</p>\n</blockquote>\n<p>eg:</p>\n<ol>\n<li>Mybatis中只用使用<code>@MapperScan</code>声明要扫描的Mapper接口类就可以直接从Spring中获取使用,进行操作数据库</li>\n<li>Dubbo中只要用Dubbo提供的<code>@Service</code>注解,同样可以直接从Spring中获取使用进行远程调用。</li>\n</ol>\n<p><strong>那么以上这些功能在Spring中是如何实现的呢?</strong></p>\n<p>由此就引出本篇主要介绍的接口<code>FactoryBean</code></p>\n<div><pre><code>\n<span>public</span> <span>interface</span> <span>FactoryBean</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>{</span>\n    <span>@Nullable</span>\n    <span>T</span> <span>getObject</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span><span>;</span>\n\n    <span>@Nullable</span>\n    <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> <span>getObjectType</span><span>(</span><span>)</span><span>;</span>\n\n    <span>default</span> <span>boolean</span> <span>isSingleton</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>true</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>在Spring中当发现一个Bean的类型是<code>FactoryBean</code>,此时实例化时候就会执行,该对象的<code>getObject()</code>方法从而来进行实例化。那么如何获取真实<code>FactoryBean</code>呢?只需要在实例化的Bean的name前面加<code>&amp;</code>符号才是获取真正<code>FactoryBean</code>的实例对象。</p>\n<p>Java编程规范中声明,Java接口类是不能直接实例化的,Spring实现接口的实例化操作,本质上只是调用<code>FactoryBean</code>的<code>getObject()</code>方法,而真正的实例化操作,还是有开发者来实现的。以我们常见的使用框架为例。<code>MyBatis</code> and <code>Dubbo</code></p>\n<ul>\n<li>MyBatis中实现FactoryBean的类<code>MapperFactoryBean</code></li>\n<li>Dubbo中实现FactoryBean的类<code>ReferenceBean</code></li>\n</ul>\n<p>在此我们以MyBatis为例,讲述MyBatis是如何实现FactoryBean来实现接口实例化操作的。\n对Spring的源码有研究的同学知道,在Spring中Bean的读取会生成BeanDefinition对象,实例化实际就是找到Bean对象的BeanDefinition对象,然后根据\nBeanDefinition信息来实例的。那么在这里我们首先要看下MyBatis是如何为接口生成BeanDefinition对象的吧。</p>\n<p>我们一起看下<code>ImportBeanDefinitionRegistrar</code>接口。ImportBeanDefinitionRegistrar接口就是允许开发者来根据开发者的规则来生成BeanDefinition的并注册到<code>BeanDefinitionRegistry</code>中。因为Spring默认是根据自己的规则去生成BeanDefinition的，但是这里也提供了一个切口,供开发者使用。</p>\n<div><pre><code>\n<span>public</span> <span>interface</span> <span>ImportBeanDefinitionRegistrar</span> <span>{</span>\n    <span>public</span> <span>void</span> <span>registerBeanDefinitions</span><span>(</span>\n            <span>AnnotationMetadata</span> importingClassMetadata<span>,</span> <span>BeanDefinitionRegistry</span> registry<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>MyBatis中<code>MapperScannerRegistrar</code>实现了<code>ImportBeanDefinitionRegistrar</code>。扫描Mapper接口所在的包,为每个接口生成特定的BeanDefinition</p>\n<h4 id=\"mapperscannerregistrar\"> MapperScannerRegistrar</h4>\n<div><pre><code> <span>public</span> <span>void</span> <span>registerBeanDefinitions</span><span>(</span><span>AnnotationMetadata</span> importingClassMetadata<span>,</span> <span>BeanDefinitionRegistry</span> registry<span>)</span> <span>{</span>\n    <span>//扫描Mapper接口所在的包</span>\n    <span>AnnotationAttributes</span> annoAttrs <span>=</span> <span>AnnotationAttributes</span><span>.</span><span>fromMap</span><span>(</span>importingClassMetadata<span>.</span><span>getAnnotationAttributes</span><span>(</span><span>MapperScan</span><span>.</span><span>class</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>\n    <span>ClassPathMapperScanner</span> scanner <span>=</span> <span>new</span> <span>ClassPathMapperScanner</span><span>(</span>registry<span>)</span><span>;</span>\n    <span>.</span><span>.</span><span>.</span><span>.</span>\n    <span>//为每个接口生成特定的BeanDefinition </span>\n    scanner<span>.</span><span>doScan</span><span>(</span><span>StringUtils</span><span>.</span><span>toStringArray</span><span>(</span>basePackages<span>)</span><span>)</span><span>;</span>\n  <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id=\"classpathmapperscanner\"> ClassPathMapperScanner</h3>\n<p>在doScan方法为每个标记的Mapper接口生成一个BeanName。而实例化工厂都指定为<code>MapperFactoryBean</code>。只用调用其<code>getObject()</code>方法即可完成接口的实例化。</p>\n<div><pre><code><span>public</span> <span>Set</span><span><span>&lt;</span><span>BeanDefinitionHolder</span><span>></span></span> <span>doScan</span><span>(</span><span>String</span><span>.</span><span>.</span><span>.</span> basePackages<span>)</span> <span>{</span>\n    <span>Set</span><span><span>&lt;</span><span>BeanDefinitionHolder</span><span>></span></span> beanDefinitions <span>=</span> <span>super</span><span>.</span><span>doScan</span><span>(</span>basePackages<span>)</span><span>;</span>\n\n    <span>if</span> <span>(</span>beanDefinitions<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n      logger<span>.</span><span>warn</span><span>(</span><span>\"No MyBatis mapper was found in '\"</span> <span>+</span> <span>Arrays</span><span>.</span><span>toString</span><span>(</span>basePackages<span>)</span> <span>+</span> <span>\"' package. Please check your configuration.\"</span><span>)</span><span>;</span>\n    <span>}</span> <span>else</span> <span>{</span>\n      <span>//开始配置自己的规则</span>\n      <span>processBeanDefinitions</span><span>(</span>beanDefinitions<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>return</span> beanDefinitions<span>;</span>\n  <span>}</span>\n  <span>private</span> <span>void</span> <span>processBeanDefinitions</span><span>(</span><span>Set</span><span><span>&lt;</span><span>BeanDefinitionHolder</span><span>></span></span> beanDefinitions<span>)</span> <span>{</span>\n    <span>GenericBeanDefinition</span> definition<span>;</span>\n    <span>for</span> <span>(</span><span>BeanDefinitionHolder</span> holder <span>:</span> beanDefinitions<span>)</span> <span>{</span>\n      definition <span>=</span> <span>(</span><span>GenericBeanDefinition</span><span>)</span> holder<span>.</span><span>getBeanDefinition</span><span>(</span><span>)</span><span>;</span>\n      <span>//设置每个Bean的工厂类，MapperFactoryBean</span>\n      definition<span>.</span><span>setBeanClass</span><span>(</span><span>this</span><span>.</span>mapperFactoryBean<span>.</span><span>getClass</span><span>(</span><span>)</span><span>)</span><span>;</span>\n      <span>.</span><span>.</span><span>.</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>我们举一个例子</p>\n<div><pre><code>@Mapper\npublic interface TUserMapper {\n\n    int insert(TUser record);\n\n    List&lt;TUser&gt; selectAll();\n\n    TUser selectOne(@Param(&quot;id&quot;) Integer id);\n\n    TUser selectByName(@Param(&quot;name&quot;) String name);\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>这里BeanDefinition的名字就是<code>TUserMapper</code>，而工厂方法就是<code>MapperFactoryBean</code>。如下伪代码,getBean(&quot;TUserMapper&quot;),就是调用<code>MapperFactoryBean.getObject()</code>,而<code>getBean(&quot;&amp;TUserMapper&quot;)</code>才是获取<code>MapperFactoryBean</code>的实例。</p>\n<div><pre><code>    @Test\n    public void factoryBeanTest(){\n        System.out.println(applicationContextTools.getApp().getBean(&quot;&amp;TUserMapper&quot;));\n        //org.mybatis.spring.mapper.MapperFactoryBean@3ab6678b\n    }\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"我们如何定制自己的解析的注解呢\"> 我们如何定制自己的解析的注解呢?</h3>\n<p>编写一个类似于<code>MapperScan</code>的注解类,<code>MyMapperScan</code>。</p>\n<p><strong>注意:</strong> 自定义的注解只能声明在配置类上才有效，配置类就是一定要被<code>@Configuration</code>修饰。</p>\n<div><pre><code><span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>\n<span>@Target</span><span>(</span><span>ElementType</span><span>.</span>TYPE<span>)</span>\n<span>@Documented</span>\n<span>@Import</span><span>(</span><span>MyMapperScannerRegistrar</span><span>.</span><span>class</span><span>)</span>\n<span>public</span> <span>@interface</span> <span>MyMapperScan</span> <span>{</span>\n    <span>String</span> <span>value</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>public</span> <span>class</span> <span>MyMapperScannerRegistrar</span> <span>implements</span> <span>ImportBeanDefinitionRegistrar</span> <span>{</span>\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>registerBeanDefinitions</span><span>(</span><span>AnnotationMetadata</span> importingClassMetadata<span>,</span> <span>BeanDefinitionRegistry</span> registry<span>)</span> <span>{</span>\n        <span>AnnotationAttributes</span> annoAttrs <span>=</span> <span>AnnotationAttributes</span><span>.</span><span>fromMap</span><span>(</span>importingClassMetadata<span>.</span><span>getAnnotationAttributes</span><span>(</span><span>MyMapperScan</span><span>.</span><span>class</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>\n        <span>String</span> value <span>=</span> annoAttrs<span>.</span><span>getString</span><span>(</span><span>\"value\"</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>value<span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"配置类:\"</span><span>+</span>importingClassMetadata<span>.</span><span>getClassName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h4 id=\"验证\"> 验证</h4>\n<div><pre><code>@Configuration\n@MyMapperScan(value = &quot;ConfigBean&quot;)\npublic class ConfigBean {\n}\n\n@SpringBootApplication //被@Configuration修饰就等同于配置类\n@MyMapperScan(value = &quot;test&quot;)\n@MapperScan(value = &quot;orm.example.dal.mapper&quot;)\npublic class LxchinesszzMybatisStudyApplication {\n    public static void main(String[] args) {\n        new SpringApplicationBuilder().web(WebApplicationType.NONE).run(args);\n    }\n\n}\n\nConfigBean\n配置类:orm.example.ConfigBean\ntest\n配置类:orm.example.LxchinesszzMybatisStudyApplication\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div>",
      "image": "https://img.springlearn.cn/eaf9d1d2bf5c8df466b3376235db919a.jpg",
      "date_published": "2022-06-16T13:10:16.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Spring"
      ]
    },
    {
      "title": "Spring循环依赖",
      "url": "https://java.springlearn.cn/learn/spring/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/",
      "id": "https://java.springlearn.cn/learn/spring/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/learn_1647108921000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>作者: 八阿哥的剑</strong></p>\n<p><em>博客: https://springlearn.cn</em></p>\n<div><p>一日一句毒鸡汤</p>\n<p>问世间钱为何物，只叫人生死相许。！😄</p>\n</div>\n<p>写文章不容易，如果感觉还行，请点个关注，点关注不迷路。</p>\n<h2 id=\"一、什么是循环依赖\"> 一、什么是循环依赖</h2>\n<p>这种简单的问题，直接伪代码吧。</p>\n<div><pre><code><span>@Service</span>\n<span>public</span> <span>class</span> <span>A</span> <span>{</span>\n    <span>@Autowired</span>\n    <span>private</span> <span>B</span> b<span>;</span>\n<span>}</span>\n\n<span>@Service</span>\n<span>public</span> <span>class</span> <span>B</span> <span>{</span>\n    <span>@Autowired</span>\n    <span>private</span> <span>A</span> a<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>我中有你，你中有我。</p>\n<h2 id=\"二、解决循环依赖思路\"> 二、解决循环依赖思路</h2>\n<p>思路其实非常简单还是用伪代码来说明</p>\n<div><pre><code><span>A</span> a <span>=</span> <span>new</span> <span>A</span><span>(</span><span>)</span><span>;</span>\n<span>B</span> b <span>=</span> <span>new</span> <span>B</span><span>(</span><span>)</span><span>;</span>\na<span>.</span><span>setB</span><span>(</span>b<span>)</span><span>;</span>\nb<span>.</span><span>setA</span><span>(</span>a<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>思路就是这么简单，先分别把A和B给实例化。\n这时候实例化的A和B仅仅是完成了实例化,内部的属性其实都没有。\n只有当执行了3、4行才算正常完成。</p>\n<div><div><br><br><div>&nbsp;</div><div>&nbsp;</div><br></div><pre><code><span>A</span> a <span>=</span> <span>new</span> <span>A</span><span>(</span><span>)</span><span>;</span>\n<span>B</span> b <span>=</span> <span>new</span> <span>B</span><span>(</span><span>)</span><span>;</span>\na<span>.</span><span>setB</span><span>(</span>b<span>)</span><span>;</span>\nb<span>.</span><span>setA</span><span>(</span>a<span>)</span><span>;</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>通过上面的代码我们总结下，要想实现循环注入。首先要满足第一个条件。</p>\n<ol>\n<li><strong>能被实例化</strong></li>\n</ol>\n<ul>\n<li>有空构造</li>\n<li>或有构造且构造参数满足能被实例化。</li>\n</ul>\n<p>好了，知道这点就成了，相信让你来实现循环注入，应该也可以了吧。其实就这么简单 ?</p>\n<p>那我们来看Spring如何来实现的。相信看完你就头大了。但是没关系，基本原理你已经知道了。\n带着这个思路来看Spring的源码就简单了。</p>\n<h2 id=\"三、spring如何解决循环依赖\"> 三、Spring如何解决循环依赖</h2>\n<p>首先我们要知道Spring中的bean, 有两种形式。</p>\n<ul>\n<li>第一种是单例。所谓单例就是容器中这个类，只会存在一个实例。不管你调用了多少次 <code>getBean(String beanName)</code> 返回的都是一个实例(因为每次都从缓存中获取的实例)。</li>\n<li>第二种是原型。所谓原型就是容器中这个类，没有缓存。每次都是新建一个Bean。</li>\n</ul>\n<p>在这里我们思考下，如果要你来实现循环注入，以上两种模式。你能用那一个?\n要想实现循环注入，即这个Bean必须要有一个缓存的地方。不然每次都是创建，虽然能完成实例化，但是实例化后，需要注入的 <code>bean</code> 无法实现注入，就会陷入死循环。</p>\n<p>这里第二个必要因素就出来了。</p>\n<p><mark>2. 必须要是单例</mark></p>\n<p>好了，知道这么多我们开始看源码吧。</p>\n<h3 id=\"_3-1-spring中创建bean的步骤\"> 3.1 Spring中创建Bean的步骤</h3>\n<ul>\n<li>实例化，createBeanInstance，就是new了个对象。</li>\n<li>属性注入，populateBean， 就是 set 一些属性值。</li>\n<li>初始化，initializeBean，执行一些 aware 接口中的方法，initMethod，AOP代理等</li>\n</ul>\n<h3 id=\"_3-2-循环依赖三层缓存\"> 3.2 循环依赖三层缓存</h3>\n<p>注意看细节，每个缓存的数据类型是什么? 后面要考。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1647104251000.png\" alt=\"\" loading=\"lazy\"></p>\n<ul>\n<li>一级缓存 <code>Map&lt;String, Object&gt; singletonObjects</code>\n<ul>\n<li>如果等于空，或者当前单例正在创建中(即只完成了实例化)。就从二级缓存中获取。</li>\n</ul>\n</li>\n<li>二级缓存 <code>Map&lt;String, Object&gt; earlySingletonObjects</code>\n<ul>\n<li>如果等于空，就从三级缓存中获取。</li>\n</ul>\n</li>\n<li>三级缓存 <code>Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories</code>\n<ul>\n<li>创建Bean的一个工厂，允许容器中定义特殊的，生成Bean的方法。使用 <code>addSingletonFactory</code></li>\n</ul>\n</li>\n</ul>\n<p>其实要想实现循环依赖只用2个缓存就行。三级缓存的意义是为了完成某些功能。至于什么功能呢? 这里先不说后面看流程。</p>\n<div><div><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><pre><code><span>protected</span> <span>Object</span> <span>getSingleton</span><span>(</span><span>String</span> beanName<span>,</span> <span>boolean</span> allowEarlyReference<span>)</span> <span>{</span>\n\t\t<span>Object</span> singletonObject <span>=</span> <span>this</span><span>.</span>singletonObjects<span>.</span><span>get</span><span>(</span>beanName<span>)</span><span>;</span>\n\t\t<span>if</span> <span>(</span>singletonObject <span>==</span> <span>null</span> <span>&amp;&amp;</span> <span>isSingletonCurrentlyInCreation</span><span>(</span>beanName<span>)</span><span>)</span> <span>{</span>\n\t\t\t<span>synchronized</span> <span>(</span><span>this</span><span>.</span>singletonObjects<span>)</span> <span>{</span>\n\t\t\t\tsingletonObject <span>=</span> <span>this</span><span>.</span>earlySingletonObjects<span>.</span><span>get</span><span>(</span>beanName<span>)</span><span>;</span>\n\t\t\t\t<span>if</span> <span>(</span>singletonObject <span>==</span> <span>null</span> <span>&amp;&amp;</span> allowEarlyReference<span>)</span> <span>{</span>\n\t\t\t\t\t<span>ObjectFactory</span><span><span>&lt;</span><span>?</span><span>></span></span> singletonFactory <span>=</span> <span>this</span><span>.</span>singletonFactories<span>.</span><span>get</span><span>(</span>beanName<span>)</span><span>;</span>\n\t\t\t\t\t<span>if</span> <span>(</span>singletonFactory <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n\t\t\t\t\t\tsingletonObject <span>=</span> singletonFactory<span>.</span><span>getObject</span><span>(</span><span>)</span><span>;</span>\n\t\t\t\t\t\t<span>this</span><span>.</span>earlySingletonObjects<span>.</span><span>put</span><span>(</span>beanName<span>,</span> singletonObject<span>)</span><span>;</span>\n\t\t\t\t\t\t<span>this</span><span>.</span>singletonFactories<span>.</span><span>remove</span><span>(</span>beanName<span>)</span><span>;</span>\n\t\t\t\t\t<span>}</span>\n\t\t\t\t<span>}</span>\n\t\t\t<span>}</span>\n\t\t<span>}</span>\n\t\t<span>return</span> singletonObject<span>;</span>\n\t<span>}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>好我们知道有这两个缓存就继续往下看源码。当 <code>getSingleton</code> 是 <code>null</code>。继续往下走。其他源码就跳过了，不是本篇的主要内容，我们只看\n解决循环依赖的核心代码。</p>\n<ul>\n<li>doCreateBean#createBeanInstance 先实现实例化。</li>\n<li>当前bean是单例,不会添加到二级缓存，直接就添加到三级缓存中,注意这里不是添加的Bean，而是生成Bean的工厂方法 <code>ObjectFactory(#getEarlyBeanReference)</code>。</li>\n</ul>\n<div><div><br><br><br><br><br><br><br><div>&nbsp;</div><br><br></div><pre><code>\t   <span>boolean</span> earlySingletonExposure <span>=</span> <span>(</span>mbd<span>.</span><span>isSingleton</span><span>(</span><span>)</span> <span>&amp;&amp;</span> <span>this</span><span>.</span>allowCircularReferences <span>&amp;&amp;</span>\n\t\t\t\t<span>isSingletonCurrentlyInCreation</span><span>(</span>beanName<span>)</span><span>)</span><span>;</span>\n\t\t<span>if</span> <span>(</span>earlySingletonExposure<span>)</span> <span>{</span>\n\t\t\t<span>if</span> <span>(</span>logger<span>.</span><span>isTraceEnabled</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n\t\t\t\tlogger<span>.</span><span>trace</span><span>(</span><span>\"Eagerly caching bean '\"</span> <span>+</span> beanName <span>+</span>\n\t\t\t\t\t\t<span>\"' to allow for resolving potential circular references\"</span><span>)</span><span>;</span>\n\t\t\t<span>}</span>\n\t\t\t<span>addSingletonFactory</span><span>(</span>beanName<span>,</span> <span>(</span><span>)</span> <span>-></span> <span>getEarlyBeanReference</span><span>(</span>beanName<span>,</span> mbd<span>,</span> bean<span>)</span><span>)</span><span>;</span>\n\t\t<span>}</span> \n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><ul>\n<li>doCreateBean#populateBean 实现属性注入</li>\n</ul>\n<p>以上面的代码的例子，A创建时候被加入到了三级缓存中，然后继续执行 <code>populateBean</code>。发现要依赖B。然后依次从缓存中\n来找这个A。最终在三级缓存中读取到了B。然后实现注入。这里三级缓存中的 <code>Bean</code>。 有可能只是完成了 <code>new</code>。但是容器\n不管，先完成循环注入。至于注入的东西是否是完全品还是半成品不关心，因为都是单例所以，后面在注入属性也没关系。\n这里我们知道单例的用处了吧。试想一下，如果不是单例模式，而是原型模式。那么bean就必须是完全品，不然就陷入了死循环。</p>\n<p>下面我们还用伪代码的方式再来说一篇实现思路。</p>\n<div><pre><code><span>// createBeanInstance先实例化，然后加入到三级缓存中</span>\n<span>A</span> a <span>=</span> <span>new</span> <span>A</span><span>(</span><span>)</span><span>;</span>\n<span>// a在执行populateBean的时候，发现要注入属性B，于是就使用getBean。</span>\n<span>// getBean(b) 执行createBeanInstance先实例化</span>\n<span>B</span> b <span>=</span> <span>new</span> <span>B</span><span>(</span><span>)</span><span>;</span>\n<span>// 然后加入到三级缓存中，b在执行populateBean注入属性值的时候。发现也依赖了A。</span>\n<span>// 然后从缓存中找到办成品A。于是乎B的注入就完成，然后再执行B的init方法。</span>\nb<span>.</span><span>setA</span><span>(</span>a<span>)</span><span>;</span>\n<span>// B完成后,则返回到A的populateBean也注入了B。然后在执行A的init方法</span>\na<span>.</span><span>setB</span><span>(</span>b<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>到这里就完成了循环注入，这里有点绕，小编画了一个图，大家跟着序号来看，然后好好理解下。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1647104949000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>通过这个图其实我们能发现一个问题。B此时从三级缓存中拿到的A是一个半成品的A。\n假如B在执行初始化方法的时候,依赖A的populateBean注入的属性。那么此时一定会拿不到的。\n下面写点伪代码，说一下这个问题。</p>\n<h3 id=\"_3-3-发现点问题\"> 3.3 发现点问题</h3>\n<h4 id=\"_3-3-1-半成品问题-1\"> 3.3.1 半成品问题-1</h4>\n<div><pre><code><span>@Component</span>\n<span>public</span> <span>class</span> <span>A</span> <span>implements</span> <span>InitializingBean</span> <span>{</span>\n\n    <span>@Autowired</span>\n    <span>private</span> <span>B</span> b<span>;</span>\n\n    <span>@Value</span><span>(</span><span>\"${a.name}\"</span><span>)</span>\n    <span>private</span> <span>String</span> name<span>;</span>\n\n    <span>public</span> <span>String</span> <span>getName</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> name<span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>afterPropertiesSet</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"A:\"</span> <span>+</span> b<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>@Component</span>\n<span>public</span> <span>class</span> <span>B</span> <span>implements</span> <span>InitializingBean</span> <span>{</span>\n\n    <span>@Autowired</span>\n    <span>private</span> <span>A</span> a<span>;</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>afterPropertiesSet</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"B:\"</span> <span>+</span> a<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p><img src=\"https://img.springlearn.cn/blog/learn_1647105136000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>通过上图我们知道B会先执行初始化，而这里B的初始化 <mark>(图例8)</mark> 会依赖A的参数注入 <mark>(图例4)</mark> 。而B在执行初始化的时候。A(图例4没有完全完成注入)并没有完成属性注入。\n那么我们此时在拿到A的getName一定是空的。</p>\n<p><strong>以上代码执行就是:</strong></p>\n<div><pre><code><span>B</span><span>:</span><span>null</span>\n<span>A</span><span>:</span><span><span>com<span>.</span>example<span>.</span>demo<span>.</span></span>B</span><span>@38aa816f</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h4 id=\"_3-3-2-半成品问题-2\"> 3.3.2 半成品问题-2</h4>\n<p>A的BeanPostProcessor没有执行,那么假如我们想要对A进行方法代理。B在执行初始化的时候,调用A的 <code>getName</code>。会成功代理上吗?</p>\n<div><pre><code><span>@Component</span>\n<span>public</span> <span>class</span> <span>A</span> <span>implements</span> <span>InitializingBean</span> <span>{</span>\n\n    <span>@Autowired</span>\n    <span>private</span> <span>B</span> b<span>;</span>\n\n    <span>private</span> <span>final</span> <span>String</span> name <span>=</span> <span>\"孙悟空\"</span><span>;</span>\n\n    <span>public</span> <span>String</span> <span>getName</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> name<span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>afterPropertiesSet</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"A:\"</span> <span>+</span> b<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n<span>@Component</span>\n<span>public</span> <span>class</span> <span>B</span> <span>implements</span> <span>InitializingBean</span> <span>{</span>\n\n    <span>@Autowired</span>\n    <span>private</span> <span>A</span> a<span>;</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>afterPropertiesSet</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"B:\"</span> <span>+</span> a<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n<span>@Aspect</span>\n<span>@Component</span>\n<span>public</span> <span>class</span> <span>AopConfig</span> <span>{</span>\n\n    <span>/**\n     * 精确匹配类名\n     */</span>\n    <span>@Pointcut</span><span>(</span><span>\"within(A)\"</span><span>)</span>\n    <span>private</span> <span>void</span> <span>matchClass</span><span>(</span><span>)</span> <span>{</span>\n    <span>}</span>\n\n    <span>@Before</span><span>(</span><span>\"matchClass()\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>beforeMatchClassName</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"--------精确匹配类名-------\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><p><strong>执行结果:</strong></p>\n<div><pre><code><span>--</span><span>--</span><span>--</span><span>--</span>精确匹配类名<span>--</span><span>--</span><span>--</span><span>-</span>\n<span>B</span><span>:</span>孙悟空\n<span>A</span><span>:</span><span><span>com<span>.</span>example<span>.</span>demo<span>.</span></span>B</span><span>@5e01a982</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>发现疑问了吗? 前面我们说了,在执行B图例8的时候(b的初始化方法)，A图例9并没有执行，那为什么这里会代理成功呢?\n<img src=\"https://img.springlearn.cn/blog/learn_1647105949000.png\" alt=\"\" loading=\"lazy\"></p>\n<div><p>答案揭晓</p>\n<p>这里在添加缓存的时候，并不是直接把实例添加到缓存中的。\n而是将图例9的逻辑，封装到\nObjectFactory的方式添加到缓存中的。\nObjectFactory#getObject时候执行了Bean\n的处理。(AOP代理等)</p>\n</div>\n<p><strong>注意: 这里并不是把所有的处理器都包装到ObjectFactory方法中,而是有选择的使用,只有实现了SmartInstantiationAwareBeanPostProcessor接口\n才会放到里面。</strong></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1647106252000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>答案就在这里，这里执行了。一些特殊逻辑的处理器。当实现了 <code>SmartInstantiationAwareBeanPostProcessor</code> 接口。\n就可以提前对那些半成品的Bean进行处理。</p>\n<div><div><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br></div><pre><code><span>protected</span> <span>Object</span> <span>getEarlyBeanReference</span><span>(</span><span>String</span> beanName<span>,</span> <span>RootBeanDefinition</span> mbd<span>,</span> <span>Object</span> bean<span>)</span> <span>{</span>\n\t\t<span>Object</span> exposedObject <span>=</span> bean<span>;</span>\n\t\t<span>if</span> <span>(</span><span>!</span>mbd<span>.</span><span>isSynthetic</span><span>(</span><span>)</span> <span>&amp;&amp;</span> <span>hasInstantiationAwareBeanPostProcessors</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n\t\t\t<span>for</span> <span>(</span><span>SmartInstantiationAwareBeanPostProcessor</span> bp <span>:</span> <span>getBeanPostProcessorCache</span><span>(</span><span>)</span><span>.</span>smartInstantiationAware<span>)</span> <span>{</span>\n\t\t\t\texposedObject <span>=</span> bp<span>.</span><span>getEarlyBeanReference</span><span>(</span>exposedObject<span>,</span> beanName<span>)</span><span>;</span>\n\t\t\t<span>}</span>\n\t\t<span>}</span>\n\t\t<span>return</span> exposedObject<span>;</span>\n\t<span>}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>比如AOP的实现类。\n<img src=\"https://img.springlearn.cn/blog/learn_1647106893000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>这里我们在思考一个问题。A半成品的时候被AOP代理了一次，那么当A在执行Bean处理器的时候岂不是有要被代理一次吗?</p>\n<p>AbstractAutoProxyCreator#getEarlyBeanReference</p>\n<p>第一次代理时候会被加到缓存中。</p>\n<div><pre><code>    <span>public</span> <span>Object</span> <span>getEarlyBeanReference</span><span>(</span><span>Object</span> bean<span>,</span> <span>String</span> beanName<span>)</span> <span>{</span>\n        <span>Object</span> cacheKey <span>=</span> <span>this</span><span>.</span><span>getCacheKey</span><span>(</span>bean<span>.</span><span>getClass</span><span>(</span><span>)</span><span>,</span> beanName<span>)</span><span>;</span>\n        <span>this</span><span>.</span>earlyProxyReferences<span>.</span><span>put</span><span>(</span>cacheKey<span>,</span> bean<span>)</span><span>;</span>\n        <span>return</span> <span>this</span><span>.</span><span>wrapIfNecessary</span><span>(</span>bean<span>,</span> beanName<span>,</span> cacheKey<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>第二次时候在执行AOP后置处理器,会先判断缓存,如果缓存中存在就不在处理了。</p>\n<div><pre><code>   <span>public</span> <span>Object</span> <span>postProcessAfterInitialization</span><span>(</span><span>@Nullable</span> <span>Object</span> bean<span>,</span> <span>String</span> beanName<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>bean <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n            <span>Object</span> cacheKey <span>=</span> <span>this</span><span>.</span><span>getCacheKey</span><span>(</span>bean<span>.</span><span>getClass</span><span>(</span><span>)</span><span>,</span> beanName<span>)</span><span>;</span>\n            <span>if</span> <span>(</span><span>this</span><span>.</span>earlyProxyReferences<span>.</span><span>remove</span><span>(</span>cacheKey<span>)</span> <span>!=</span> bean<span>)</span> <span>{</span>\n                <span>return</span> <span>this</span><span>.</span><span>wrapIfNecessary</span><span>(</span>bean<span>,</span> beanName<span>,</span> cacheKey<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n\n        <span>return</span> bean<span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id=\"四、知识点总结\"> 四、知识点总结</h2>\n<h3 id=\"_4-1-满足循环依赖的条件是什么\"> 4.1 满足循环依赖的条件是什么?</h3>\n<ol>\n<li>必须是单例模式</li>\n<li>循环依赖类,必须能实例化(空构造,或构造参数满足循环依赖条件)</li>\n</ol>\n<h3 id=\"_4-2-循环依赖可能导致什么问题\"> 4.2 循环依赖可能导致什么问题?</h3>\n<p>在执行初始化的时候，如果初始化方法，依赖循环来的属性注入参数，可能导致获取不到数据信息的情况</p>\n<p>如上面问题1。</p>\n<h3 id=\"_4-3-为什么要用三级缓存而不是二级缓存\"> 4.3 为什么要用三级缓存而不是二级缓存?</h3>\n<p>为了满足Spring声明周期方法,即对半成品的B进行提前生命周期处理。如实现AOP。</p>\n<h2 id=\"五、开放性问题\"> 五、开放性问题</h2>\n<p>只使用一级缓存，和三级缓存是否就能解决循环依赖，并且满足bean一些特殊逻辑处理呢（eg:aop）?</p>\n<div><div><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><pre><code><span>protected</span> <span>Object</span> <span>getSingleton</span><span>(</span><span>String</span> beanName<span>,</span> <span>boolean</span> allowEarlyReference<span>)</span> <span>{</span>\n\t\t<span>// Quick check for existing instance without full singleton lock</span>\n\t\t<span>Object</span> singletonObject <span>=</span> <span>this</span><span>.</span>singletonObjects<span>.</span><span>get</span><span>(</span>beanName<span>)</span><span>;</span>\n\t\t<span>if</span> <span>(</span>singletonObject <span>==</span> <span>null</span> <span>&amp;&amp;</span> <span>isSingletonCurrentlyInCreation</span><span>(</span>beanName<span>)</span><span>)</span> <span>{</span>\n\t\t\tsingletonObject <span>=</span> <span>this</span><span>.</span>earlySingletonObjects<span>.</span><span>get</span><span>(</span>beanName<span>)</span><span>;</span>\n\t\t\t<span>if</span> <span>(</span>singletonObject <span>==</span> <span>null</span> <span>&amp;&amp;</span> allowEarlyReference<span>)</span> <span>{</span>\n\t\t\t\t<span>synchronized</span> <span>(</span><span>this</span><span>.</span>singletonObjects<span>)</span> <span>{</span>\n\t\t\t\t\t<span>// Consistent creation of early reference within full singleton lock</span>\n\t\t\t\t\tsingletonObject <span>=</span> <span>this</span><span>.</span>singletonObjects<span>.</span><span>get</span><span>(</span>beanName<span>)</span><span>;</span>\n\t\t\t\t\t<span>if</span> <span>(</span>singletonObject <span>==</span> <span>null</span><span>)</span> <span>{</span>\n\t\t\t\t\t\tsingletonObject <span>=</span> <span>this</span><span>.</span>earlySingletonObjects<span>.</span><span>get</span><span>(</span>beanName<span>)</span><span>;</span>\n\t\t\t\t\t\t<span>if</span> <span>(</span>singletonObject <span>==</span> <span>null</span><span>)</span> <span>{</span>\n\t\t\t\t\t\t\t<span>ObjectFactory</span><span><span>&lt;</span><span>?</span><span>></span></span> singletonFactory <span>=</span> <span>this</span><span>.</span>singletonFactories<span>.</span><span>get</span><span>(</span>beanName<span>)</span><span>;</span>\n\t\t\t\t\t\t\t<span>if</span> <span>(</span>singletonFactory <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n\t\t\t\t\t\t\t\tsingletonObject <span>=</span> singletonFactory<span>.</span><span>getObject</span><span>(</span><span>)</span><span>;</span>\n\t\t\t\t\t\t\t\t<span>this</span><span>.</span>earlySingletonObjects<span>.</span><span>put</span><span>(</span>beanName<span>,</span> singletonObject<span>)</span><span>;</span>\n\t\t\t\t\t\t\t\t<span>this</span><span>.</span>singletonFactories<span>.</span><span>remove</span><span>(</span>beanName<span>)</span><span>;</span>\n\t\t\t\t\t\t\t<span>}</span>\n\t\t\t\t\t\t<span>}</span>\n\t\t\t\t\t<span>}</span>\n\t\t\t\t<span>}</span>\n\t\t\t<span>}</span>\n\t\t<span>}</span>\n\t\t<span>return</span> singletonObject<span>;</span>\n\t<span>}</span>\n\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>小编回答:  仅仅使用1级缓存和3级缓存完全可以的。</p>\n<p>之所以使用2级缓存是因为三级缓存是ObjectFactory#getObject()。是每次都从工厂里面去拿。而使用了2级缓存，仅仅是为了提高性能。\n而设计的。所以一单这个单例Bean完成后。会里面把二级和三级缓存给移除掉。</p>\n<div><pre><code><span>protected</span> <span>void</span> <span>addSingleton</span><span>(</span><span>String</span> beanName<span>,</span> <span>Object</span> singletonObject<span>)</span> <span>{</span>\n\t\t<span>synchronized</span> <span>(</span><span>this</span><span>.</span>singletonObjects<span>)</span> <span>{</span>\n\t\t\t<span>this</span><span>.</span>singletonObjects<span>.</span><span>put</span><span>(</span>beanName<span>,</span> singletonObject<span>)</span><span>;</span>\n\t\t\t<span>this</span><span>.</span>singletonFactories<span>.</span><span>remove</span><span>(</span>beanName<span>)</span><span>;</span>\n\t\t\t<span>this</span><span>.</span>earlySingletonObjects<span>.</span><span>remove</span><span>(</span>beanName<span>)</span><span>;</span>\n\t\t\t<span>this</span><span>.</span>registeredSingletons<span>.</span><span>add</span><span>(</span>beanName<span>)</span><span>;</span>\n\t\t<span>}</span>\n\t<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div>",
      "image": "https://img.springlearn.cn/blog/learn_1647108921000.png",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Spring"
      ]
    },
    {
      "title": "动态绑定配置",
      "url": "https://java.springlearn.cn/learn/spring/Spring%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E9%85%8D%E7%BD%AE/",
      "id": "https://java.springlearn.cn/learn/spring/Spring%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E9%85%8D%E7%BD%AE/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/learn_1652957155000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"一、如何实现动态配置\"> 一、如何实现动态配置</h2>\n<p>在Spring体系下,如果实现了ConfigurationProperties则会自动刷新。而如果只使用<code>@Value</code>的方法,要加上 <code>@RefreshScope</code> 才能实现。\n本篇文章我们来分别研究下他们的原理。然后在来看看其他的方案是如何做的吧。</p>\n<h2 id=\"二、实现原理\"> 二、实现原理</h2>\n<h2 id=\"_2-1-configurationproperties\"> 2.1 @ConfigurationProperties</h2>\n<p>所有被<code>@ConfigurationProperties</code>修饰的类都会被ConfigurationPropertiesBeans处理</p>\n<ol>\n<li>实现<code>BeanPostProcessor</code>处理器，初始化时候判断是否被<code>@ConfigurationProperties</code>修饰,如果是就保存到<code>ConfigurationPropertiesBeans#beans属性中</code></li>\n</ol>\n<div><pre><code>    <span>public</span> <span>Object</span> <span>postProcessBeforeInitialization</span><span>(</span><span>Object</span> bean<span>,</span> <span>String</span> beanName<span>)</span>\n\t\t\t<span>throws</span> <span>BeansException</span> <span>{</span>\n\t\t<span>// 1. 如果已经被RefreshScope修饰了,也会自动更新就不用在处理了。 \t</span>\n\t\t<span>if</span> <span>(</span><span>isRefreshScoped</span><span>(</span>beanName<span>)</span><span>)</span> <span>{</span>\n\t\t\t<span>return</span> bean<span>;</span>\n\t\t<span>}</span>\n\t\t<span>ConfigurationProperties</span> annotation <span>=</span> <span>AnnotationUtils</span>\n\t\t\t\t<span>.</span><span>findAnnotation</span><span>(</span>bean<span>.</span><span>getClass</span><span>(</span><span>)</span><span>,</span> <span>ConfigurationProperties</span><span>.</span><span>class</span><span>)</span><span>;</span>\n\t\t<span>if</span> <span>(</span>annotation <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n\t\t\t<span>this</span><span>.</span>beans<span>.</span><span>put</span><span>(</span>beanName<span>,</span> bean<span>)</span><span>;</span>\n\t\t<span>}</span>\n\t\t<span>else</span> <span>if</span> <span>(</span><span>this</span><span>.</span>metaData <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n\t\t\tannotation <span>=</span> <span>this</span><span>.</span>metaData<span>.</span><span>findFactoryAnnotation</span><span>(</span>beanName<span>,</span>\n\t\t\t\t\t<span>ConfigurationProperties</span><span>.</span><span>class</span><span>)</span><span>;</span>\n\t\t\t<span>if</span> <span>(</span>annotation <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n\t\t\t\t<span>this</span><span>.</span>beans<span>.</span><span>put</span><span>(</span>beanName<span>,</span> bean<span>)</span><span>;</span>\n\t\t\t<span>}</span>\n\t\t<span>}</span>\n\t\t<span>return</span> bean<span>;</span>\n\t<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><ol start=\"2\">\n<li>ConfigurationPropertiesRebinder 实现 <code>EnvironmentChangeEvent</code> 变更事件, 当收到EnvironmentChangeEvent事件\n会重新触发绑定事件。需要绑定的bean就从ConfigurationPropertiesBeans#beans属性中获取。</li>\n</ol>\n<p>具体的实现类 <code>ConfigurationPropertiesRebinder</code></p>\n<ol>\n<li>先调用销毁方法</li>\n<li>然后重新初始化</li>\n</ol>\n<div><pre><code>    <span>// 接受事件</span>\n    <span>public</span> <span>void</span> <span>onApplicationEvent</span><span>(</span><span>EnvironmentChangeEvent</span> event<span>)</span> <span>{</span>\n\t\t<span>if</span> <span>(</span><span>this</span><span>.</span>applicationContext<span>.</span><span>equals</span><span>(</span>event<span>.</span><span>getSource</span><span>(</span><span>)</span><span>)</span>\n\t\t\t\t<span>// Backwards compatible</span>\n\t\t\t\t<span>||</span> event<span>.</span><span>getKeys</span><span>(</span><span>)</span><span>.</span><span>equals</span><span>(</span>event<span>.</span><span>getSource</span><span>(</span><span>)</span><span>)</span><span>)</span> <span>{</span>\n\t\t\t<span>rebind</span><span>(</span><span>)</span><span>;</span>\n\t\t<span>}</span>\n\t<span>}</span>\n\t<span>// 重新绑定</span>\n    <span>public</span> <span>boolean</span> <span>rebind</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>\n\t\t<span>if</span> <span>(</span><span>!</span><span>this</span><span>.</span>beans<span>.</span><span>getBeanNames</span><span>(</span><span>)</span><span>.</span><span>contains</span><span>(</span>name<span>)</span><span>)</span> <span>{</span>\n\t\t\t<span>return</span> <span>false</span><span>;</span>\n\t\t<span>}</span>\n\t\t<span>if</span> <span>(</span><span>this</span><span>.</span>applicationContext <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n\t\t\t<span>try</span> <span>{</span>\n\t\t\t\t<span>Object</span> bean <span>=</span> <span>this</span><span>.</span>applicationContext<span>.</span><span>getBean</span><span>(</span>name<span>)</span><span>;</span>\n\t\t\t\t<span>if</span> <span>(</span><span>AopUtils</span><span>.</span><span>isAopProxy</span><span>(</span>bean<span>)</span><span>)</span> <span>{</span>\n\t\t\t\t\tbean <span>=</span> <span>ProxyUtils</span><span>.</span><span>getTargetObject</span><span>(</span>bean<span>)</span><span>;</span>\n\t\t\t\t<span>}</span>\n\t\t\t\t<span>if</span> <span>(</span>bean <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n\t\t\t\t\t<span>this</span><span>.</span>applicationContext<span>.</span><span>getAutowireCapableBeanFactory</span><span>(</span><span>)</span>\n\t\t\t\t\t\t\t<span>.</span><span>destroyBean</span><span>(</span>bean<span>)</span><span>;</span>\n\t\t\t\t\t<span>this</span><span>.</span>applicationContext<span>.</span><span>getAutowireCapableBeanFactory</span><span>(</span><span>)</span>\n\t\t\t\t\t\t\t<span>.</span><span>initializeBean</span><span>(</span>bean<span>,</span> name<span>)</span><span>;</span>\n\t\t\t\t\t<span>return</span> <span>true</span><span>;</span>\n\t\t\t\t<span>}</span>\n\t\t\t<span>}</span>\n\t\t\t<span>catch</span> <span>(</span><span>RuntimeException</span> e<span>)</span> <span>{</span>\n\t\t\t\t<span>this</span><span>.</span>errors<span>.</span><span>put</span><span>(</span>name<span>,</span> e<span>)</span><span>;</span>\n\t\t\t\t<span>throw</span> e<span>;</span>\n\t\t\t<span>}</span>\n\t\t\t<span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n\t\t\t\t<span>this</span><span>.</span>errors<span>.</span><span>put</span><span>(</span>name<span>,</span> e<span>)</span><span>;</span>\n\t\t\t\t<span>throw</span> <span>new</span> <span>IllegalStateException</span><span>(</span><span>\"Cannot rebind to \"</span> <span>+</span> name<span>,</span> e<span>)</span><span>;</span>\n\t\t\t<span>}</span>\n\t\t<span>}</span>\n\t\t<span>return</span> <span>false</span><span>;</span>\n\t<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br></div></div><h2 id=\"_2-2-refreshscope\"> 2.2 @RefreshScope</h2>\n<p><code>@RefreshScope</code> 的原理相对流程较长，首先他需要你将类用 <code>@RefreshScope</code>来修饰。</p>\n<ol>\n<li>首先明确那些是被修饰的<code>AnnotatedBeanDefinitionReader#registerBean</code>。</li>\n</ol>\n<div><pre><code><span><span>&lt;</span><span>T</span><span>></span></span> <span>void</span> <span>doRegisterBean</span><span>(</span><span>Class</span><span><span>&lt;</span><span>T</span><span>></span></span> annotatedClass<span>,</span> <span>@Nullable</span> <span>Supplier</span><span><span>&lt;</span><span>T</span><span>></span></span> instanceSupplier<span>,</span> <span>@Nullable</span> <span>String</span> name<span>,</span>\n\t\t\t<span>@Nullable</span> <span>Class</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>Annotation</span><span>></span></span><span>[</span><span>]</span> qualifiers<span>,</span> <span>BeanDefinitionCustomizer</span><span>.</span><span>.</span><span>.</span> definitionCustomizers<span>)</span> <span>{</span>\n\n\t\t<span>AnnotatedGenericBeanDefinition</span> abd <span>=</span> <span>new</span> <span>AnnotatedGenericBeanDefinition</span><span>(</span>annotatedClass<span>)</span><span>;</span>\n\t\t<span>if</span> <span>(</span><span>this</span><span>.</span>conditionEvaluator<span>.</span><span>shouldSkip</span><span>(</span>abd<span>.</span><span>getMetadata</span><span>(</span><span>)</span><span>)</span><span>)</span> <span>{</span>\n\t\t\t<span>return</span><span>;</span>\n\t\t<span>}</span>\n\n\t\tabd<span>.</span><span>setInstanceSupplier</span><span>(</span>instanceSupplier<span>)</span><span>;</span>\n\t\t<span>ScopeMetadata</span> scopeMetadata <span>=</span> <span>this</span><span>.</span>scopeMetadataResolver<span>.</span><span>resolveScopeMetadata</span><span>(</span>abd<span>)</span><span>;</span>\n\t\tabd<span>.</span><span>setScope</span><span>(</span>scopeMetadata<span>.</span><span>getScopeName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\t\t<span>.</span><span>.</span><span>.</span>\n\t\t<span>BeanDefinitionHolder</span> definitionHolder <span>=</span> <span>new</span> <span>BeanDefinitionHolder</span><span>(</span>abd<span>,</span> beanName<span>)</span><span>;</span>\n\t\t<span>// 创建bean描述信息 beanClass = ScopedProxyFactoryBean</span>\n\t\t<span>// ScopedProxyCreator#createScopedProxy->ScopedProxyUtils#createScopedProxy</span>\n\t\tdefinitionHolder <span>=</span> <span>AnnotationConfigUtils</span><span>.</span><span>applyScopedProxyMode</span><span>(</span>scopeMetadata<span>,</span> definitionHolder<span>,</span> <span>this</span><span>.</span>registry<span>)</span><span>;</span>\n\t\t<span>BeanDefinitionReaderUtils</span><span>.</span><span>registerBeanDefinition</span><span>(</span>definitionHolder<span>,</span> <span>this</span><span>.</span>registry<span>)</span><span>;</span>\n\n<span>}</span>\t\t\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><ol start=\"2\">\n<li>被Scope修饰的beanClass都是ScopedProxyFactoryBean\n<ul>\n<li>GenericScope 实现BeanFactoryPostProcessor 会提前将RefreshScope注册到BeanFactory中</li>\n<li>beanFactory.registerScope(this.name, this)</li>\n<li>当执行完上面 AbstractBeanFactory#scopes属性中就有值了。对于RefreshScope name = refresh</li>\n</ul>\n</li>\n</ol>\n<div><pre><code><span>public</span> <span>class</span> <span>GenericScope</span> <span>implements</span> <span>Scope</span><span>,</span> <span>BeanFactoryPostProcessor</span><span>,</span>\n\t\t<span>BeanDefinitionRegistryPostProcessor</span><span>,</span> <span>DisposableBean</span> <span>{</span>\n\n<span>}</span>\n<span>public</span> <span>class</span> <span>RefreshScope</span> <span>extends</span> <span>GenericScope</span> <span>implements</span> <span>ApplicationContextAware</span><span>,</span>\n\t\t<span>ApplicationListener</span><span><span>&lt;</span><span>ContextRefreshedEvent</span><span>></span></span><span>,</span> <span>Ordered</span> <span>{</span>\t\n<span>}</span>\t\t\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><ol start=\"3\">\n<li>当getBean时候,对于域对象会有特殊的处理逻辑,会调用 <code>Scope#get(String name, ObjectFactory&lt;?&gt; objectFactory)</code></li>\n</ol>\n<div><pre><code>\t<span>protected</span> <span><span>&lt;</span><span>T</span><span>></span></span> <span>T</span> <span>doGetBean</span><span>(</span><span>final</span> <span>String</span> name<span>,</span> <span>@Nullable</span> <span>final</span> <span>Class</span><span><span>&lt;</span><span>T</span><span>></span></span> requiredType<span>,</span>\n\t\t\t<span>@Nullable</span> <span>final</span> <span>Object</span><span>[</span><span>]</span> args<span>,</span> <span>boolean</span> typeCheckOnly<span>)</span> <span>throws</span> <span>BeansException</span> <span>{</span>\n\t\t\t<span>.</span><span>.</span><span>.</span>\n\t\t\t\t<span>// 创建单例逻辑</span>\n\t\t\t\t<span>if</span> <span>(</span>mbd<span>.</span><span>isSingleton</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n\t\t\t\t\t<span>.</span><span>.</span><span>.</span>\n\t\t\t\t\tbean <span>=</span> <span>getObjectForBeanInstance</span><span>(</span>sharedInstance<span>,</span> name<span>,</span> beanName<span>,</span> mbd<span>)</span><span>;</span>\n\t\t\t\t<span>}</span>\n\t\t\t\t<span>// 创建原型逻辑</span>\n\t\t\t\t<span>else</span> <span>if</span> <span>(</span>mbd<span>.</span><span>isPrototype</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n\t\t\t\t\t<span>.</span><span>.</span><span>.</span>\n\t\t\t\t\tbean <span>=</span> <span>getObjectForBeanInstance</span><span>(</span>prototypeInstance<span>,</span> name<span>,</span> beanName<span>,</span> mbd<span>)</span><span>;</span>\n\t\t\t\t<span>}</span>\n\t\t\t\t<span>else</span> <span>{</span>\n\t\t\t\t    <span>// 创建域对象</span>\n\t\t\t\t    <span>// refresh</span>\n\t\t\t\t\t<span>String</span> scopeName <span>=</span> mbd<span>.</span><span>getScope</span><span>(</span><span>)</span><span>;</span>\n\t\t\t\t\t<span>// RefreshScope</span>\n\t\t\t\t\t<span>final</span> <span>Scope</span> scope <span>=</span> <span>this</span><span>.</span>scopes<span>.</span><span>get</span><span>(</span>scopeName<span>)</span><span>;</span>\n\t\t\t\t\t<span>if</span> <span>(</span>scope <span>==</span> <span>null</span><span>)</span> <span>{</span>\n\t\t\t\t\t\t<span>throw</span> <span>new</span> <span>IllegalStateException</span><span>(</span><span>\"No Scope registered for scope name '\"</span> <span>+</span> scopeName <span>+</span> <span>\"'\"</span><span>)</span><span>;</span>\n\t\t\t\t\t<span>}</span>\n\t\t\t\t\t<span>try</span> <span>{</span>\n\t\t\t\t\t\t<span>Object</span> scopedInstance <span>=</span> scope<span>.</span><span>get</span><span>(</span>beanName<span>,</span> <span>(</span><span>)</span> <span>-></span> <span>{</span>\n\t\t\t\t\t\t\t<span>beforePrototypeCreation</span><span>(</span>beanName<span>)</span><span>;</span>\n\t\t\t\t\t\t\t<span>try</span> <span>{</span>\n\t\t\t\t\t\t\t\t<span>return</span> <span>createBean</span><span>(</span>beanName<span>,</span> mbd<span>,</span> args<span>)</span><span>;</span>\n\t\t\t\t\t\t\t<span>}</span>\n\t\t\t\t\t\t\t<span>finally</span> <span>{</span>\n\t\t\t\t\t\t\t\t<span>afterPrototypeCreation</span><span>(</span>beanName<span>)</span><span>;</span>\n\t\t\t\t\t\t\t<span>}</span>\n\t\t\t\t\t\t<span>}</span><span>)</span><span>;</span>\n\t\t\t\t\t\tbean <span>=</span> <span>getObjectForBeanInstance</span><span>(</span>scopedInstance<span>,</span> name<span>,</span> beanName<span>,</span> mbd<span>)</span><span>;</span>\n\t\t\t\t\t<span>}</span>\n\t\t\t\t<span>}</span>\n\t\t\t<span>}</span>\n\t\t<span>}</span>\n\t\t<span>return</span> <span>(</span><span>T</span><span>)</span> bean<span>;</span>\n\t<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div><div><pre><code><span>public</span> <span>interface</span> <span>Scope</span> <span>{</span>\n\t<span>Object</span> <span>get</span><span>(</span><span>String</span> name<span>,</span> <span>ObjectFactory</span><span><span>&lt;</span><span>?</span><span>></span></span> objectFactory<span>)</span><span>;</span> \n<span>}</span>\n<span>public</span> <span>class</span> <span>GenericScope</span> <span>implements</span> <span>Scope</span><span>,</span> <span>BeanFactoryPostProcessor</span><span>,</span>\n\t\t<span>BeanDefinitionRegistryPostProcessor</span><span>,</span> <span>DisposableBean</span> <span>{</span><span>}</span>\n<span>public</span> <span>class</span> <span>RefreshScope</span> <span>extends</span> <span>GenericScope</span> <span>implements</span> <span>ApplicationContextAware</span><span>,</span>\n\t\t<span>ApplicationListener</span><span><span>&lt;</span><span>ContextRefreshedEvent</span><span>></span></span><span>,</span> <span>Ordered</span> <span>{</span><span>}</span>\t\t\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><ol start=\"4\">\n<li>RefreshEventListener 接受事件，触发刷新操作</li>\n</ol>\n<div><pre><code><span>public</span> <span>class</span> <span>RefreshEventListener</span> <span>implements</span> <span>SmartApplicationListener</span> <span>{</span>\n    <span>private</span> <span>ContextRefresher</span> refresh<span>;</span>\n    <span>@Override</span>\n\t<span>public</span> <span>void</span> <span>onApplicationEvent</span><span>(</span><span>ApplicationEvent</span> event<span>)</span> <span>{</span>\n\t\t<span>if</span> <span>(</span>event <span>instanceof</span> <span>ApplicationReadyEvent</span><span>)</span> <span>{</span>\n\t\t\t<span>handle</span><span>(</span><span>(</span><span>ApplicationReadyEvent</span><span>)</span> event<span>)</span><span>;</span>\n\t\t<span>}</span>\n\t\t<span>else</span> <span>if</span> <span>(</span>event <span>instanceof</span> <span>RefreshEvent</span><span>)</span> <span>{</span>\n\t\t\t<span>handle</span><span>(</span><span>(</span><span>RefreshEvent</span><span>)</span> event<span>)</span><span>;</span>\n\t\t<span>}</span>\n\t<span>}</span>\n\n\t<span>public</span> <span>void</span> <span>handle</span><span>(</span><span>ApplicationReadyEvent</span> event<span>)</span> <span>{</span>\n\t\t<span>this</span><span>.</span>ready<span>.</span><span>compareAndSet</span><span>(</span><span>false</span><span>,</span> <span>true</span><span>)</span><span>;</span>\n\t<span>}</span>\n\n\t<span>public</span> <span>void</span> <span>handle</span><span>(</span><span>RefreshEvent</span> event<span>)</span> <span>{</span>\n\t\t<span>if</span> <span>(</span><span>this</span><span>.</span>ready<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span> <span>{</span> <span>// don't handle events before app is ready</span>\n\t\t\tlog<span>.</span><span>debug</span><span>(</span><span>\"Event received \"</span> <span>+</span> event<span>.</span><span>getEventDesc</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\t\t\t<span>Set</span><span><span>&lt;</span><span>String</span><span>></span></span> keys <span>=</span> <span>this</span><span>.</span>refresh<span>.</span><span>refresh</span><span>(</span><span>)</span><span>;</span>\n\t\t\tlog<span>.</span><span>info</span><span>(</span><span>\"Refresh keys changed: \"</span> <span>+</span> keys<span>)</span><span>;</span>\n\t\t<span>}</span>\n\t<span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><ol start=\"5\">\n<li>ContextRefresher#refresh\n<ol>\n<li>refreshEnvironment刷新环境</li>\n<li>调用RefreshScope#refreshAll</li>\n</ol>\n</li>\n</ol>\n<div><pre><code><span>public</span> <span>class</span> <span>ContextRefresher</span> <span>{</span>\n   <span>public</span> <span>synchronized</span> <span>Set</span><span><span>&lt;</span><span>String</span><span>></span></span> <span>refresh</span><span>(</span><span>)</span> <span>{</span>\n\t\t<span>Set</span><span><span>&lt;</span><span>String</span><span>></span></span> keys <span>=</span> <span>refreshEnvironment</span><span>(</span><span>)</span><span>;</span>\n\t\t<span>this</span><span>.</span>scope<span>.</span><span>refreshAll</span><span>(</span><span>)</span><span>;</span>\n\t\t<span>return</span> keys<span>;</span>\n\t<span>}</span>\n\n\t<span>public</span> <span>synchronized</span> <span>Set</span><span><span>&lt;</span><span>String</span><span>></span></span> <span>refreshEnvironment</span><span>(</span><span>)</span> <span>{</span>\n\t\t<span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Object</span><span>></span></span> before <span>=</span> <span>extract</span><span>(</span>\n\t\t\t\t<span>this</span><span>.</span>context<span>.</span><span>getEnvironment</span><span>(</span><span>)</span><span>.</span><span>getPropertySources</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\t\t<span>addConfigFilesToEnvironment</span><span>(</span><span>)</span><span>;</span>\n\t\t<span>Set</span><span><span>&lt;</span><span>String</span><span>></span></span> keys <span>=</span> <span>changes</span><span>(</span>before<span>,</span>\n\t\t\t\t<span>extract</span><span>(</span><span>this</span><span>.</span>context<span>.</span><span>getEnvironment</span><span>(</span><span>)</span><span>.</span><span>getPropertySources</span><span>(</span><span>)</span><span>)</span><span>)</span><span>.</span><span>keySet</span><span>(</span><span>)</span><span>;</span>\n\t\t<span>this</span><span>.</span>context<span>.</span><span>publishEvent</span><span>(</span><span>new</span> <span>EnvironmentChangeEvent</span><span>(</span><span>this</span><span>.</span>context<span>,</span> keys<span>)</span><span>)</span><span>;</span>\n\t\t<span>return</span> keys<span>;</span>\n\t<span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><ol start=\"6\">\n<li>RefreshScope#refreshAll\n会将容器中的bean给销毁。\n而ScopedProxyFactoryBean中getObject是一个代理对象。带代理类每次都从容器中获取。而容器前面已经将被RefreshScope修饰的类给销毁了\n测试拿到的对象就是重新从容器中生成的。</li>\n</ol>\n<div><pre><code><span>public</span> <span>class</span> <span>ScopedProxyFactoryBean</span> <span>extends</span> <span>ProxyConfig</span>\n\t\t<span>implements</span> <span>FactoryBean</span><span><span>&lt;</span><span>Object</span><span>></span></span><span>,</span> <span>BeanFactoryAware</span><span>,</span> <span>AopInfrastructureBean</span> <span>{</span>\n\t<span>private</span> <span>Object</span> proxy<span>;</span>\t\n\t<span>private</span> <span>final</span> <span>SimpleBeanTargetSource</span> scopedTargetSource <span>=</span> <span>new</span> <span>SimpleBeanTargetSource</span><span>(</span><span>)</span><span>;</span>\n\t<span>@Override</span>\n\t<span>public</span> <span>void</span> <span>setBeanFactory</span><span>(</span><span>BeanFactory</span> beanFactory<span>)</span> <span>{</span>\n        <span>.</span><span>.</span><span>.</span>\n\t\t<span>ProxyFactory</span> pf <span>=</span> <span>new</span> <span>ProxyFactory</span><span>(</span><span>)</span><span>;</span>\n\t\tpf<span>.</span><span>copyFrom</span><span>(</span><span>this</span><span>)</span><span>;</span>\n\t\tpf<span>.</span><span>setTargetSource</span><span>(</span><span>this</span><span>.</span>scopedTargetSource<span>)</span><span>;</span>\n\t\t<span>this</span><span>.</span>proxy <span>=</span> pf<span>.</span><span>getProxy</span><span>(</span>cbf<span>.</span><span>getBeanClassLoader</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\t<span>}</span>\n<span>}</span>\t\t\n\n<span>public</span> <span>class</span> <span>SimpleBeanTargetSource</span> <span>extends</span> <span>AbstractBeanFactoryBasedTargetSource</span> <span>{</span>\n\t<span>@Override</span>\n\t<span>public</span> <span>Object</span> <span>getTarget</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n\t\t<span>return</span> <span>getBeanFactory</span><span>(</span><span>)</span><span>.</span><span>getBean</span><span>(</span><span>getTargetBeanName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\t<span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h2 id=\"三、其他方案\"> 三、其他方案</h2>\n<p>因为我们项目中用的是阿波罗，那我们只看阿波罗是如何来做的吧。\n在阿波罗只用使用@Value就行了</p>\n<h2 id=\"_3-1-先扫描-value注解\"> 3.1 先扫描@Value注解</h2>\n<p>将被@Value修饰的Bean和配置key先生成一个<code>SpringValue</code>对象然后注册到<code>SpringValueRegistry</code>中</p>\n<div><pre><code><span>public</span> <span>class</span> <span>SpringValueProcessor</span> <span>extends</span> <span>ApolloProcessor</span> <span>implements</span> <span>BeanFactoryPostProcessor</span><span>,</span> <span>BeanFactoryAware</span> <span>{</span>\n   <span>protected</span> <span>void</span> <span>processField</span><span>(</span><span>Object</span> bean<span>,</span> <span>String</span> beanName<span>,</span> <span>Field</span> field<span>)</span> <span>{</span>\n       <span>// register @Value on field</span>\n       <span>Value</span> value <span>=</span> field<span>.</span><span>getAnnotation</span><span>(</span><span>Value</span><span>.</span><span>class</span><span>)</span><span>;</span>\n       <span>if</span> <span>(</span>value <span>==</span> <span>null</span><span>)</span> <span>{</span>\n         <span>return</span><span>;</span>\n       <span>}</span>\n       <span>Set</span><span><span>&lt;</span><span>String</span><span>></span></span> keys <span>=</span> placeholderHelper<span>.</span><span>extractPlaceholderKeys</span><span>(</span>value<span>.</span><span>value</span><span>(</span><span>)</span><span>)</span><span>;</span>\n   \n       <span>if</span> <span>(</span>keys<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n         <span>return</span><span>;</span>\n       <span>}</span>\n   \n       <span>for</span> <span>(</span><span>String</span> key <span>:</span> keys<span>)</span> <span>{</span>\n         <span>SpringValue</span> springValue <span>=</span> <span>new</span> <span>SpringValue</span><span>(</span>key<span>,</span> value<span>.</span><span>value</span><span>(</span><span>)</span><span>,</span> bean<span>,</span> beanName<span>,</span> field<span>,</span> <span>false</span><span>)</span><span>;</span>\n         springValueRegistry<span>.</span><span>register</span><span>(</span>beanFactory<span>,</span> key<span>,</span> springValue<span>)</span><span>;</span>\n         logger<span>.</span><span>debug</span><span>(</span><span>\"Monitoring {}\"</span><span>,</span> springValue<span>)</span><span>;</span>\n       <span>}</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h2 id=\"_3-2-找到需要更新的bean\"> 3.2 找到需要更新的Bean</h2>\n<p>接受到配置变更事件后,遍历本地变更的配置key，然后将本次key关联需要变更的Bean,从<code>springValueRegistry</code>中找到。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>AutoUpdateConfigChangeListener</span> <span>implements</span> <span>ConfigChangeListener</span><span>{</span>\n   <span>@Override</span>\n  <span>public</span> <span>void</span> <span>onChange</span><span>(</span><span>ConfigChangeEvent</span> changeEvent<span>)</span> <span>{</span>\n    <span>Set</span><span><span>&lt;</span><span>String</span><span>></span></span> keys <span>=</span> changeEvent<span>.</span><span>changedKeys</span><span>(</span><span>)</span><span>;</span>\n    <span>if</span> <span>(</span><span>CollectionUtils</span><span>.</span><span>isEmpty</span><span>(</span>keys<span>)</span><span>)</span> <span>{</span>\n      <span>return</span><span>;</span>\n    <span>}</span>\n    <span>for</span> <span>(</span><span>String</span> key <span>:</span> keys<span>)</span> <span>{</span>\n      <span>// 1. check whether the changed key is relevant</span>\n      <span>Collection</span><span><span>&lt;</span><span>SpringValue</span><span>></span></span> targetValues <span>=</span> springValueRegistry<span>.</span><span>get</span><span>(</span>beanFactory<span>,</span> key<span>)</span><span>;</span>\n      <span>if</span> <span>(</span>targetValues <span>==</span> <span>null</span> <span>||</span> targetValues<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n        <span>continue</span><span>;</span>\n      <span>}</span>\n\n      <span>// 2. update the value</span>\n      <span>for</span> <span>(</span><span>SpringValue</span> val <span>:</span> targetValues<span>)</span> <span>{</span>\n        <span>updateSpringValue</span><span>(</span>val<span>)</span><span>;</span>\n      <span>}</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h2 id=\"_3-3-通过反射的方法注入\"> 3.3 通过反射的方法注入</h2>\n<div><pre><code><span>public</span> <span>class</span> <span>SpringValue</span> <span>{</span>\n   <span>public</span> <span>void</span> <span>update</span><span>(</span><span>Object</span> newVal<span>)</span> <span>throws</span> <span>IllegalAccessException</span><span>,</span> <span>InvocationTargetException</span> <span>{</span>\n       <span>if</span> <span>(</span><span>isField</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n         <span>injectField</span><span>(</span>newVal<span>)</span><span>;</span>\n       <span>}</span> <span>else</span> <span>{</span>\n         <span>injectMethod</span><span>(</span>newVal<span>)</span><span>;</span>\n       <span>}</span>\n     <span>}</span>\n    <span>private</span> <span>void</span> <span>injectField</span><span>(</span><span>Object</span> newVal<span>)</span> <span>throws</span> <span>IllegalAccessException</span> <span>{</span>\n       <span>Object</span> bean <span>=</span> beanRef<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>\n       <span>if</span> <span>(</span>bean <span>==</span> <span>null</span><span>)</span> <span>{</span>\n         <span>return</span><span>;</span>\n       <span>}</span>\n       <span>boolean</span> accessible <span>=</span> field<span>.</span><span>isAccessible</span><span>(</span><span>)</span><span>;</span>\n       field<span>.</span><span>setAccessible</span><span>(</span><span>true</span><span>)</span><span>;</span>\n       field<span>.</span><span>set</span><span>(</span>bean<span>,</span> newVal<span>)</span><span>;</span>\n       field<span>.</span><span>setAccessible</span><span>(</span>accessible<span>)</span><span>;</span>\n     <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>非常简单，高效。相比使用@RefreshScope是不是清爽多了呢?</p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1652957155000.png",
      "date_published": "2022-05-22T07:02:41.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Spring"
      ]
    },
    {
      "title": "Web接口资源是如何保存起来的?",
      "url": "https://java.springlearn.cn/learn/spring/Web%E6%8E%A5%E5%8F%A3%E8%B5%84%E6%BA%90%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98%E8%B5%B7%E6%9D%A5%E7%9A%84/",
      "id": "https://java.springlearn.cn/learn/spring/Web%E6%8E%A5%E5%8F%A3%E8%B5%84%E6%BA%90%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98%E8%B5%B7%E6%9D%A5%E7%9A%84/",
      "content_html": "<h2 id=\"前言\"> 前言</h2>\n<p>在我们使用 <code>SpringBoot</code> 开发中,我们定义一接口是下面这样的</p>\n<div><pre><code>@RestController\npublic class UserController{\n    \n    @GetMapping( name = &quot;/getUserName&quot;)\n    public String getUserName(){\n        return &quot;Hello World&quot;;\n    }\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>这时候我们思考一个问题,我们在浏览器上只输入了一个URL地址,怎么就能访问到这个接口的呢？于是乎就引出了\n今天我们要讨论的话题。Spring中的Web接口资源是如何保存起来的?</p>\n<h2 id=\"一、spring中的web接口资源是如何保存起来的\"> 一、Spring中的Web接口资源是如何保存起来的?</h2>\n<p>在我们学习之前我们可以先自己来进行思考一下。处理逻辑是什么样的？</p>\n<ul>\n<li>Spring容器解析 <code>@RequestMapping</code> 注解。当然这个注解又派生了其他的注解比如。</li>\n</ul>\n<div><pre><code>@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@RequestMapping(method = RequestMethod.POST)\npublic @interface PostMapping {}\n\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@RequestMapping(method = RequestMethod.PUT)\npublic @interface PutMapping {}\n\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@RequestMapping(method = RequestMethod.GET)\npublic @interface GetMapping {}\n\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@RequestMapping(method = RequestMethod.DELETE)\npublic @interface DeleteMapping {}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><ul>\n<li>我们猜测Spring源码中一定会对<code>@RestController</code> 和 <code>@Controller</code>标记的类,里面的每个\nMethod进行处理,判断是否包含了上面的注解。注解那么多Spring肯定不会这样一个一个去处理。我们可以看到\n上面的注解都使用了<code>@AliasFor</code>注解。其中奥妙就在这里。看下面例子代码。</li>\n<li>我们猜测Spring肯定对这些Method判断是否有<code>@RequestMapping</code>有注解。</li>\n</ul>\n<h3 id=\"_1-aliasfor使用\"> 1. @AliasFor使用</h3>\n<div><pre><code>@RestController\npublic class PostController {\n\n    @ApiOperation(value = &quot;查询Bbs所有文章&quot;)\n    @PostMapping(value = &quot;/query/bbs/posts&quot;, produces = MediaType.APPLICATION_JSON_VALUE)\n    public Result&lt;PostAllResponse&gt; queryBbsPostAll(@RequestBody PostAllSelectRequest postAllSelectRequest) {\n        return postBiz.queryBbsPostAll(postAllSelectRequest);\n    }\n\n    public static void main(String[] args) {\n        Method queryBbsPostAll = ClassUtils.getMethod(PostController.class, &quot;queryBbsPostAll&quot;,PostAllSelectRequest.class);\n        PostMapping annotation = AnnotationUtils.findAnnotation(queryBbsPostAll, PostMapping.class);\n        ///query/bbs/posts\n        System.out.println(StringUtils.arrayToCommaDelimitedString(annotation.value()));\n        //application/json\n        System.out.println(StringUtils.arrayToCommaDelimitedString(annotation.produces()));\n        //是否包含RequestMapping: true\n        System.out.println(&quot;是否包含RequestMapping: &quot;+AnnotatedElementUtils.hasAnnotation(queryBbsPostAll,RequestMapping.class));\n\n        RequestMapping mergedAnnotation = AnnotatedElementUtils.getMergedAnnotation(queryBbsPostAll, RequestMapping.class);\n        ///query/bbs/posts\n        System.out.println(StringUtils.arrayToCommaDelimitedString(mergedAnnotation.value()));\n    }\n}\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p>可以看到只要使用下面代码就能把被<code>@PostMapping</code>等等的注解都涵盖了。</p>\n<div><pre><code>System.out.println(&quot;是否包含RequestMapping: &quot;+AnnotatedElementUtils.hasAnnotation(queryBbsPostAll,RequestMapping.class));\nRequestMapping mergedAnnotation = AnnotatedElementUtils.getMergedAnnotation(queryBbsPostAll, RequestMapping.class);\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"_2-解析请求method\"> 2. 解析请求Method</h3>\n<p><code>AbstractHandlerMethodMapping</code> 实现 <code>InitializingBean</code>。在当前 <code>Bean</code>初始化时候会执行</p>\n<p><code>afterPropertiesSet -&gt; initHandlerMethods</code></p>\n<p>从这里开始解析Web资源类的信息。请小伙伴们看下面的截图,截图中源码已经把类名也截上了,方便小伙伴们自己在根据截图看一遍源码。</p>\n<div><pre><code>public abstract class AbstractHandlerMethodMapping&lt;T&gt; extends AbstractHandlerMapping implements InitializingBean {\n\n    @Override\n    public void afterPropertiesSet() {\n        initHandlerMethods();\n    }\n    \n    /**\n\t * Scan beans in the ApplicationContext, detect and register handler methods.\n\t * @see #getCandidateBeanNames()\n\t * @see #processCandidateBean\n\t * @see #handlerMethodsInitialized\n\t */\n    protected void initHandlerMethods() {\n        for (String beanName : getCandidateBeanNames()) {\n            if (!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) {\n                processCandidateBean(beanName);\n            }\n        }\n        handlerMethodsInitialized(getHandlerMethods());\n    }\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p><strong>RequestMappingHandlerMapping解析Method上的RequestMapping信息</strong></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596563456000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>isHandler 方法判断是否是web资源类。 当一个类被标记了 <code>@Controller 或者@RequestMapping</code>。 注意 <code>@RestController</code> 是<code>@Controller</code>的派生类。所以这里只用判断 <code>@Controller 或者@RequestMapping</code>就行了。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596563605000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>detectHandlerMethods方法就是真正开始解析Method的逻辑。通过解析Method上的 <code>@RequestMapping</code>或者其他派生的注解。生成请求信息。\n注意这个请求信息里面也是有很多逻辑的不过不是本篇讨论的重点,就不说了。稍微提一下。根据规则来匹配url逻辑就在这里面。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596563872000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>这里我们能看到源码里拿到了Method并拿到了执行这个Method的实例Bean。在这里封装成了HandlerMethod并注册到了MappingRegistry中。\n<img src=\"https://img.springlearn.cn/blog/learn_1596564039000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>在注册的过程中把RequestMapping中的路径信息同事也放到一个urlLookup中。key是url,value是Mapping信息。\n<img src=\"https://img.springlearn.cn/blog/learn_1596564246000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>到这里其实我们就把本篇的议题就说明清楚了。下面我们在看下SpringWeb是如何将http请求信息路由到具体的HandlerMethod的吧。</p>\n<h3 id=\"_3-最后串一下流程\"> 3. 最后串一下流程</h3>\n<p>看了前面的截图,我们知道Spring是如何把这些Web资源信息给保存起来的了。然后就看是<code>DispatcherServlet</code>的逻辑了。</p>\n<p>首先<code>DispatcherServlet</code> 是一个Servlet。Servlet相信大家都都知道就不重点说原理。 我们直接看\n<code>doService</code> -&gt; <code>doDispatch</code> 方法</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1596564523000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>根据请求路径,找到从Mapping信息,然后根据Mapping信息匹配到具体的HandlerMethod。 ok本篇内容就到这里。谢谢大家。\n<img src=\"https://img.springlearn.cn/blog/learn_1596565589000.png\" alt=\"\" loading=\"lazy\">\n<img src=\"https://img.springlearn.cn/blog/learn_1596564759000.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1596563456000.png",
      "date_published": "2022-05-22T07:02:41.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "SpringBoot"
      ]
    },
    {
      "title": "第01篇:搞定Spring容器管理",
      "url": "https://java.springlearn.cn/learn/spring/core01/",
      "id": "https://java.springlearn.cn/learn/spring/core01/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/b8f74de10af99991e3fc73632eeeb190.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>公众号</strong>: 西魏陶渊明<br/>\n<strong>CSDN</strong>: <a href=\"https://springlearn.blog.csdn.net/?type=blog\" target=\"_blank\" rel=\"noopener noreferrer\">https://springlearn.blog.csdn.net</a><br/></p>\n<blockquote>\n<p>天下代码一大抄, 抄来抄去有提高, 看你会抄不会抄！</p>\n</blockquote>\n<p><img src=\"https://img.springlearn.cn/blog/8f3392b9badb093f9e1a6472b4a98487.gif\" alt=\"\" loading=\"lazy\"></p>\n<p>@[TOC]</p>\n<h2 id=\"一、前言\"> 一、前言</h2>\n<p><img src=\"https://img.springlearn.cn/blog/1c861b137fedd470229042b05bc85d97.png\" alt=\"\" loading=\"lazy\"></p>\n<p><code>Spring</code> 是 <code>java</code> 开发者,永远绕不开的结。<code>Spring</code> 是非常值得开发者来学习的, 以目前 <code>Spring</code> 在 <code>java</code> 领域的统治性地位, 可以说学 <code>java</code> 就是在学 <code>Spring</code>。但是作为新入门的开发人员,甚至说是有一定工作经验的同学,面对如此庞大的框架,都不一定是充分掌握了所有的知识点。因为大多数人的学习,都不是系统的学习,都是片面的。以经验为主。本系列专题的主要目的就是,一起系统的来学习一下Spring这个框架, 以一个六年经验的老鸟的视角里,来重学Spring。通过直接阅读 Spring的官方文档来获取一手知识。</p>\n<p>因为内容较多,建议收藏学习。</p>\n<h2 id=\"二、beanfactory-工厂\"> 二、BeanFactory 工厂</h2>\n<p><img src=\"https://img.springlearn.cn/blog/0d795a24e1b06ffc172762ae82e18241.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_2-1-什么是bean\"> 2.1 什么是Bean ?</h2>\n<p>平时我们来创建对象, 一般都是 new。如果这个对象里有一个属性, 那么就需要我来进行set,赋值。但是如果要有10个属性呢? 你也要自己来赋值吗? 那不累死个人嘛。Spring的解决方案就是, 这么重的活, 开发者不用关心了，都交给我来处理吧。那么Spring是如何来处理的呢? 对,就是<code>BeanFactory</code>,Spring通过 BeanFactory的方式帮实现对象的实例化。那么所有被Spring管理的对象,我们就可以理解成Bean对象。</p>\n<p>凡是有属性和方法的对象都是Bean对象,凡是被Spring管理的Bean对象就是Spring Bean对象。</p>\n<h2 id=\"_2-2-如何使用bean工厂\"> 2.2 如何使用Bean工厂</h2>\n<ul>\n<li>方式一直接使用代码自动注入</li>\n</ul>\n<div><pre><code><span>@Component</span>\n<span>public</span> <span>class</span> <span>SpringIocTest</span><span>{</span>\n\n    <span>@Autowired</span>\n    <span>private</span> <span>BeanFactory</span> beanFactory<span>;</span>\n<span>}</span>    \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ul>\n<li>方式二使用BeanFactoryAware注入</li>\n</ul>\n<div><pre><code><span>@Component</span>\n<span>public</span> <span>class</span> <span>SpringIocTest</span> <span>implements</span> <span>BeanFactoryAware</span> <span>{</span>\n\n    <span>private</span> <span>BeanFactory</span> beanFactory<span>;</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>setBeanFactory</span><span>(</span><span>BeanFactory</span> beanFactory<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>beanFactory <span>=</span> beanFactory<span>;</span>\n    <span>}</span>\n<span>}</span>    \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id=\"_2-3-beanfactory的体系\"> 2.3 BeanFactory的体系</h2>\n<p>在 <code>Spring</code> 中 <code>BeanFactory</code> 是一个非常重要的组件, 要想搞清楚 <code>Spring</code>, 一定要先搞清楚 <code>BeanFactory</code>\n的体系,这里我们详细来解释下 BeanFactory的体系。</p>\n<p><img src=\"https://img.springlearn.cn/blog/13a8f0f36ab6b4da0b1e678c5365ef4e.png\" alt=\"\" loading=\"lazy\"></p>\n<p>看这张图,密密麻麻的都是,但是我们不要担心,实际我们不用关心这么多。大部分人都是因为看到了这里,给劝退了, 下面给大家精简一下。希望对你有所帮助。</p>\n<p><img src=\"https://img.springlearn.cn/blog/2e34a842a68200398d70b8d6c0283c17.png\" alt=\"\" loading=\"lazy\"></p>\n<p>我们只关心上面这张图就好了，但是看类还是比较多，为什么呢? 因为Spring定义BeanFactory接口比较细，每个接口的维度都很细维度。但是我们能看到最底层的实现,是实现了所有接口的功能。下面我们以此来解释每个接口的功能。来窥探一下Spring中BeanFactory的体系。非常的全，建议大家可以收藏一下，没必要死记硬背。如果不理解的话，背下来也没有什么的用。</p>\n<p>下面分享，希望对大家有点用。</p>\n<h3 id=\"_2-3-1-beanfactory\"> 2.3.1 BeanFactory</h3>\n<p>最顶层的接口，提供了根据Bean名称获取Bean的最基础的能力。详细可以看下面的注释说明。接口没有任何实现,只是做定义。</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>BeanFactory</span> <span>{</span>\n\n\t<span>// 如果要获取FactoryBean,那么要的Bean的名称前加 &amp;</span>\n\t<span>String</span> FACTORY_BEAN_PREFIX <span>=</span> <span>\"&amp;\"</span><span>;</span>\n\n\t<span>// 根据名称获取实例,如果没有就抛异常,结果是Object类型</span>\n\t<span>Object</span> <span>getBean</span><span>(</span><span>String</span> name<span>)</span> <span>throws</span> <span>BeansException</span><span>;</span>\n\n\t<span>// 跟前者一样,不同是结果是泛型类型,会自动帮我们转换类型</span>\n\t<span><span>&lt;</span><span>T</span><span>></span></span> <span>T</span> <span>getBean</span><span>(</span><span>String</span> name<span>,</span> <span>Class</span><span><span>&lt;</span><span>T</span><span>></span></span> requiredType<span>)</span> <span>throws</span> <span>BeansException</span><span>;</span>\n\n\t<span>// 允许指定显式构造函数参数,很少会用</span>\n\t<span>Object</span> <span>getBean</span><span>(</span><span>String</span> name<span>,</span> <span>Object</span><span>.</span><span>.</span><span>.</span> args<span>)</span> <span>throws</span> <span>BeansException</span><span>;</span>\n\n\t<span>// 根据类型获取Bean实例,如果找到了多个类型,则会报错</span>\n\t<span><span>&lt;</span><span>T</span><span>></span></span> <span>T</span> <span>getBean</span><span>(</span><span>Class</span><span><span>&lt;</span><span>T</span><span>></span></span> requiredType<span>)</span> <span>throws</span> <span>BeansException</span><span>;</span>\n\n\t<span>// 根据类型获取实例,并显式构造函数参数</span>\n\t<span><span>&lt;</span><span>T</span><span>></span></span> <span>T</span> <span>getBean</span><span>(</span><span>Class</span><span><span>&lt;</span><span>T</span><span>></span></span> requiredType<span>,</span> <span>Object</span><span>.</span><span>.</span><span>.</span> args<span>)</span> <span>throws</span> <span>BeansException</span><span>;</span>\n\n\t<span>// 根据类型获取Bean的生成对象,这里并不是直接获取了Bean的实例</span>\n\t<span><span>&lt;</span><span>T</span><span>></span></span> <span>ObjectProvider</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>getBeanProvider</span><span>(</span><span>Class</span><span><span>&lt;</span><span>T</span><span>></span></span> requiredType<span>)</span><span>;</span>\n\n\t<span>// 跟前者大同小异</span>\n\t<span><span>&lt;</span><span>T</span><span>></span></span> <span>ObjectProvider</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>getBeanProvider</span><span>(</span><span>ResolvableType</span> requiredType<span>)</span><span>;</span>\n\n\t<span>// 判断是否保存这个名字的实例</span>\n\t<span>boolean</span> <span>containsBean</span><span>(</span><span>String</span> name<span>)</span><span>;</span>\n\n\t<span>// 判断是否单例</span>\n\t<span>boolean</span> <span>isSingleton</span><span>(</span><span>String</span> name<span>)</span> <span>throws</span> <span>NoSuchBeanDefinitionException</span><span>;</span>\n\n\t<span>// 判断是否是原型模式</span>\n\t<span>boolean</span> <span>isPrototype</span><span>(</span><span>String</span> name<span>)</span> <span>throws</span> <span>NoSuchBeanDefinitionException</span><span>;</span>\n\n\t<span>// bean名称和类型是否匹配</span>\n\t<span>boolean</span> <span>isTypeMatch</span><span>(</span><span>String</span> name<span>,</span> <span>ResolvableType</span> typeToMatch<span>)</span> <span>throws</span> <span>NoSuchBeanDefinitionException</span><span>;</span>\n\n\t<span>// bean名称和类型是否匹配</span>\n\t<span>boolean</span> <span>isTypeMatch</span><span>(</span><span>String</span> name<span>,</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> typeToMatch<span>)</span> <span>throws</span> <span>NoSuchBeanDefinitionException</span><span>;</span>\n\n\t<span>// 获取名称的类型</span>\n\t<span>@Nullable</span>\n\t<span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> <span>getType</span><span>(</span><span>String</span> name<span>)</span> <span>throws</span> <span>NoSuchBeanDefinitionException</span><span>;</span>\n\n\t<span>// 根据名称获取类型,FactoryBean比较特殊,allowFactoryBeanIn   // it是说,是否也要算FactoryBean,一般情况用true</span>\n\t<span>@Nullable</span>\n\t<span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> <span>getType</span><span>(</span><span>String</span> name<span>,</span> <span>boolean</span> allowFactoryBeanInit<span>)</span> <span>throws</span> <span>NoSuchBeanDefinitionException</span><span>;</span>\n\n\t<span>// bean声明的别名，如果没有则为空数组</span>\n\t<span>String</span><span>[</span><span>]</span> <span>getAliases</span><span>(</span><span>String</span> name<span>)</span><span>;</span>\n\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br></div></div><h3 id=\"_2-3-2-hierarchicalbeanfactory\"> 2.3.2 HierarchicalBeanFactory</h3>\n<p><strong>Hierarchical翻译:</strong> 分层</p>\n<p>HierarchicalBeanFactory的意思是具有层次关系,这个BeanFactory可以创建一个BeanFactory,那么是否可以根据这个BeanFactory知道是谁创建他的呢? 这个接口就是干这个事情的。</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>HierarchicalBeanFactory</span> <span>extends</span> <span>BeanFactory</span> <span>{</span>\n\n\t<span>// 返回当前工厂的父工厂</span>\n\t<span>@Nullable</span>\n\t<span>BeanFactory</span> <span>getParentBeanFactory</span><span>(</span><span>)</span><span>;</span>\n\n\t<span>// 返回当工厂是否包含这个bean,不从父工厂中去获取</span>\n\t<span>boolean</span> <span>containsLocalBean</span><span>(</span><span>String</span> name<span>)</span><span>;</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id=\"_2-3-3-listablebeanfactory\"> 2.3.3 ListableBeanFactory</h3>\n<ul>\n<li>一个接口可能会有多个实现,每个实现都是一个Bean。所以根据一个类型可能会获取多个Bean的实例。</li>\n<li>一个工厂会有很多的Bean,能不能一下获取工厂所有的Bean呢?</li>\n</ul>\n<p>这个工厂名字定义的很有意思，Listable, List 所以大多接口是返回集合。你不信,你看下面展示。</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>ListableBeanFactory</span> <span>extends</span> <span>BeanFactory</span> <span>{</span>\n\n\t<span>// 是否包含BeanDefinition,BeanDefinition是bean实例化的基   // 本信息。</span>\n\t<span>boolean</span> <span>containsBeanDefinition</span><span>(</span><span>String</span> beanName<span>)</span><span>;</span>\n\n\t<span>// 获取BeanDefinition的数量</span>\n\t<span>int</span> <span>getBeanDefinitionCount</span><span>(</span><span>)</span><span>;</span>\n\n\t<span>// 获取BeanDefinition的名称</span>\n\t<span>String</span><span>[</span><span>]</span> <span>getBeanDefinitionNames</span><span>(</span><span>)</span><span>;</span>\n\n\t<span>// 根据类型,获取这个类型的所有Bean的名称</span>\n\t<span>String</span><span>[</span><span>]</span> <span>getBeanNamesForType</span><span>(</span><span>ResolvableType</span> type<span>)</span><span>;</span>\n\n\t<span>// 根据类型获取bean的名称,包含非单例的,允许初始化</span>\n\t<span>String</span><span>[</span><span>]</span> <span>getBeanNamesForType</span><span>(</span><span>ResolvableType</span> type<span>,</span> <span>boolean</span> includeNonSingletons<span>,</span> <span>boolean</span> allowEagerInit<span>)</span><span>;</span>\n\n\t<span>// 根据类型,获取这个类型的所有Bean的名称</span>\n\t<span>String</span><span>[</span><span>]</span> <span>getBeanNamesForType</span><span>(</span><span>@Nullable</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> type<span>)</span><span>;</span>\n\n\t<span>// 根据类型获取bean的名称,包含非单例的,允许初始化</span>\n\t<span>String</span><span>[</span><span>]</span> <span>getBeanNamesForType</span><span>(</span><span>@Nullable</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> type<span>,</span> <span>boolean</span> includeNonSingletons<span>,</span> <span>boolean</span> allowEagerInit<span>)</span><span>;</span>\n\n\t<span>// 根据类型获取Bean的字典,key是名称 value是实例</span>\n\t<span><span>&lt;</span><span>T</span><span>></span></span> <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>T</span><span>></span></span> <span>getBeansOfType</span><span>(</span><span>@Nullable</span> <span>Class</span><span><span>&lt;</span><span>T</span><span>></span></span> type<span>)</span> <span>throws</span> <span>BeansException</span><span>;</span>\n\n\t<span>// 根据类型获取Bean的字典(包含非单例),key是名称 value是实例</span>\n\t<span><span>&lt;</span><span>T</span><span>></span></span> <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>T</span><span>></span></span> <span>getBeansOfType</span><span>(</span><span>@Nullable</span> <span>Class</span><span><span>&lt;</span><span>T</span><span>></span></span> type<span>,</span> <span>boolean</span> includeNonSingletons<span>,</span> <span>boolean</span> allowEagerInit<span>)</span>\n\t\t\t<span>throws</span> <span>BeansException</span><span>;</span>\n\n\t<span>// 获取被当前注解修饰的Bean的名称,只获取名称不实例化,支持注解派   // 生的方式</span>\n\t<span>String</span><span>[</span><span>]</span> <span>getBeanNamesForAnnotation</span><span>(</span><span>Class</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>Annotation</span><span>></span></span> annotationType<span>)</span><span>;</span>\n\n\t<span>// 获取被该注解修饰的bean，key是名称,value是实例。</span>\n\t<span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Object</span><span>></span></span> <span>getBeansWithAnnotation</span><span>(</span><span>Class</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>Annotation</span><span>></span></span> annotationType<span>)</span> <span>throws</span> <span>BeansException</span><span>;</span>\n\n\t<span>// 获取当前名称Bean的,当前注解的信息</span>\n\t<span>@Nullable</span>\n\t<span><span>&lt;</span><span>A</span> <span>extends</span> <span>Annotation</span><span>></span></span> <span>A</span> <span>findAnnotationOnBean</span><span>(</span><span>String</span> beanName<span>,</span> <span>Class</span><span><span>&lt;</span><span>A</span><span>></span></span> annotationType<span>)</span>\n\t\t\t<span>throws</span> <span>NoSuchBeanDefinitionException</span><span>;</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><h3 id=\"_2-3-4-configurablebeanfactory\"> 2.3.4 ConfigurableBeanFactory</h3>\n<p>这个工厂，是最容易看出他的用途的，名字一个看就是跟配置相关的。</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>ConfigurableBeanFactory</span> <span>extends</span> <span>HierarchicalBeanFactory</span><span>,</span> <span>SingletonBeanRegistry</span> <span>{</span>\n\n\t<span>// 单例:一个容器只都存在实例</span>\n\t<span>String</span> SCOPE_SINGLETON <span>=</span> <span>\"singleton\"</span><span>;</span>\n\n\t<span>// 原型:每次getBean一次生成一个实例</span>\n\t<span>String</span> SCOPE_PROTOTYPE <span>=</span> <span>\"prototype\"</span><span>;</span>\n\n\t<span>// 设置他的父工厂</span>\n\t<span>void</span> <span>setParentBeanFactory</span><span>(</span><span>BeanFactory</span> parentBeanFactory<span>)</span> <span>throws</span> <span>IllegalStateException</span><span>;</span>\n\n\t<span>// 设置类加载器以用于加载 bean 类。默认是线程上下文类加载器。</span>\n\t<span>void</span> <span>setBeanClassLoader</span><span>(</span><span>@Nullable</span> <span>ClassLoader</span> beanClassLoader<span>)</span><span>;</span>\n\n\t<span>// 返回此工厂的类加载器以加载 bean 类</span>\n\t<span>@Nullable</span>\n\t<span>ClassLoader</span> <span>getBeanClassLoader</span><span>(</span><span>)</span><span>;</span>\n\n\t<span>// 指定用于类型匹配目的的临时 ClassLoader。默认为无</span>\n\t<span>void</span> <span>setTempClassLoader</span><span>(</span><span>@Nullable</span> <span>ClassLoader</span> tempClassLoader<span>)</span><span>;</span>\n\n\t<span>// 获取临时的类加载器</span>\n\t<span>@Nullable</span>\n\t<span>ClassLoader</span> <span>getTempClassLoader</span><span>(</span><span>)</span><span>;</span>\n\n\t<span>// 设置是否缓存 bean 元数据，例如给定的 bean 定义（以合并方式）和解析的 bean 类。默认开启。</span>\n\t<span>void</span> <span>setCacheBeanMetadata</span><span>(</span><span>boolean</span> cacheBeanMetadata<span>)</span><span>;</span>\n\n\t<span>// 返回是否缓存 bean 元数据</span>\n\t<span>boolean</span> <span>isCacheBeanMetadata</span><span>(</span><span>)</span><span>;</span>\n\n\t<span>// bean 定义值中的表达式指定解析策略。</span>\n  <span>// 默认是 StandardBeanExpressionResolver。</span>\n\t<span>void</span> <span>setBeanExpressionResolver</span><span>(</span><span>@Nullable</span> <span>BeanExpressionResolver</span> resolver<span>)</span><span>;</span>\n\n\t<span>// 获取解析类型 StandardBeanExpressionResolver</span>\n\t<span>@Nullable</span>\n\t<span>BeanExpressionResolver</span> <span>getBeanExpressionResolver</span><span>(</span><span>)</span><span>;</span>\n\n\t<span>// 设置转换层统一的API,后面有专门章节说这个体系。</span>\n\t<span>void</span> <span>setConversionService</span><span>(</span><span>@Nullable</span> <span>ConversionService</span> conversionService<span>)</span><span>;</span>\n\n\t<span>// 获取转换API</span>\n\t<span>@Nullable</span>\n\t<span>ConversionService</span> <span>getConversionService</span><span>(</span><span>)</span><span>;</span>\n\n\t<span>// 给工厂添加一个属性设置的注册器,实际用的不多,但是有必要去了解,后面也会介绍</span>\n\t<span>void</span> <span>addPropertyEditorRegistrar</span><span>(</span><span>PropertyEditorRegistrar</span> registrar<span>)</span><span>;</span>\n\n\t<span>// 为给定类型的所有属性注册给定的自定义属性编辑器。在工厂配置期间调用。</span>\n\t<span>void</span> <span>registerCustomEditor</span><span>(</span><span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> requiredType<span>,</span> <span>Class</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>PropertyEditor</span><span>></span></span> propertyEditorClass<span>)</span><span>;</span>\n\n\t<span>// BeanFactory 中注册的自定义编辑器初始化给定的 PropertyEditorRegistry</span>\n\t<span>void</span> <span>copyRegisteredEditorsTo</span><span>(</span><span>PropertyEditorRegistry</span> registry<span>)</span><span>;</span>\n\n\t<span>// 设置类型转换器</span>\n\t<span>void</span> <span>setTypeConverter</span><span>(</span><span>TypeConverter</span> typeConverter<span>)</span><span>;</span>\n\n\t<span>// 获取类型转换器</span>\n\t<span>TypeConverter</span> <span>getTypeConverter</span><span>(</span><span>)</span><span>;</span>\n\n\t<span>// 添加字符串解析器。</span>\n\t<span>void</span> <span>addEmbeddedValueResolver</span><span>(</span><span>StringValueResolver</span> valueResolver<span>)</span><span>;</span>\n\n\t<span>// 是否有字符串解析器</span>\n\t<span>boolean</span> <span>hasEmbeddedValueResolver</span><span>(</span><span>)</span><span>;</span>\n\n\t<span>// 解析数据</span>\n\t<span>@Nullable</span>\n\t<span>String</span> <span>resolveEmbeddedValue</span><span>(</span><span>String</span> value<span>)</span><span>;</span>\n\n\t<span>// 添加一个新的 BeanPostProcessor，它将应用于此工厂创建的 bean。在工厂配置期间调用。</span>\n  <span>// 非系统定义的处理器，都可以使用Order进行排序</span>\n  <span>// 这是一个非常重要的Bean处理器</span>\n\t<span>void</span> <span>addBeanPostProcessor</span><span>(</span><span>BeanPostProcessor</span> beanPostProcessor<span>)</span><span>;</span>\n\n\t<span>// 处理器的个人</span>\n\t<span>int</span> <span>getBeanPostProcessorCount</span><span>(</span><span>)</span><span>;</span>\n\n\t<span>// 注册由给定 Scope 实现支持的给定范围</span>\n  <span>// 这里稍微解释下什么是Scope,就比如Session内有效或者是Request内有效</span>\n\t<span>void</span> <span>registerScope</span><span>(</span><span>String</span> scopeName<span>,</span> <span>Scope</span> scope<span>)</span><span>;</span>\n\n\t<span>// 返回所有当前注册范围的名称,不会公开诸如“singleton”和“prototype”之类的内置作用域</span>\n\t<span>String</span><span>[</span><span>]</span> <span>getRegisteredScopeNames</span><span>(</span><span>)</span><span>;</span>\n\n\t<span>// 获取域的域对象</span>\n\t<span>@Nullable</span>\n\t<span>Scope</span> <span>getRegisteredScope</span><span>(</span><span>String</span> scopeName<span>)</span><span>;</span>\n\n\t<span>// 提供与该工厂相关的安全访问控制上下文。</span>\n\t<span>AccessControlContext</span> <span>getAccessControlContext</span><span>(</span><span>)</span><span>;</span>\n\n\t<span>// 拷贝当Bean工厂的配置</span>\n\t<span>void</span> <span>copyConfigurationFrom</span><span>(</span><span>ConfigurableBeanFactory</span> otherFactory<span>)</span><span>;</span>\n\n\t<span>// 给bean注册一个别名</span>\n\t<span>void</span> <span>registerAlias</span><span>(</span><span>String</span> beanName<span>,</span> <span>String</span> alias<span>)</span> <span>throws</span> <span>BeanDefinitionStoreException</span><span>;</span>\n\n\t<span>// 解析在此工厂中注册的所有别名目标名称和别名，并将给定的 StringValueResolver 应用于它们。</span>\n\t<span>void</span> <span>resolveAliases</span><span>(</span><span>StringValueResolver</span> valueResolver<span>)</span><span>;</span>\n\n\t<span>// 返回给定 bean 名称的合并 BeanDefinition，如有必要，将子 bean 定义与其父合并。</span>\n\t<span>BeanDefinition</span> <span>getMergedBeanDefinition</span><span>(</span><span>String</span> beanName<span>)</span> <span>throws</span> <span>NoSuchBeanDefinitionException</span><span>;</span>\n\n\t<span>// 是否是FactoryBean</span>\n\t<span>boolean</span> <span>isFactoryBean</span><span>(</span><span>String</span> name<span>)</span> <span>throws</span> <span>NoSuchBeanDefinitionException</span><span>;</span>\n\n\t<span>// 设置当前Bean正在创建中。仅供容器内部会使用。</span>\n\t<span>void</span> <span>setCurrentlyInCreation</span><span>(</span><span>String</span> beanName<span>,</span> <span>boolean</span> inCreation<span>)</span><span>;</span>\n\n\t<span>// 当前Bean是否创建中</span>\n\t<span>boolean</span> <span>isCurrentlyInCreation</span><span>(</span><span>String</span> beanName<span>)</span><span>;</span>\n\n\t<span>// 为给定的 bean 注册一个依赖 bean</span>\n\t<span>void</span> <span>registerDependentBean</span><span>(</span><span>String</span> beanName<span>,</span> <span>String</span> dependentBeanName<span>)</span><span>;</span>\n\n\t<span>// 返回依赖于指定 bean 的所有 bean 的名称</span>\n\t<span>String</span><span>[</span><span>]</span> <span>getDependentBeans</span><span>(</span><span>String</span> beanName<span>)</span><span>;</span>\n\n\t<span>// 获取当前Bean依赖的Bean</span>\n\t<span>String</span><span>[</span><span>]</span> <span>getDependenciesForBean</span><span>(</span><span>String</span> beanName<span>)</span><span>;</span>\n\n\t<span>// 销毁bean</span>\n\t<span>void</span> <span>destroyBean</span><span>(</span><span>String</span> beanName<span>,</span> <span>Object</span> beanInstance<span>)</span><span>;</span>\n\n\t<span>// 销毁当前目标作用域中的指定作用域bean（如果有）</span>\n\t<span>void</span> <span>destroyScopedBean</span><span>(</span><span>String</span> beanName<span>)</span><span>;</span>\n\n\t<span>// 销毁单例</span>\n\t<span>void</span> <span>destroySingletons</span><span>(</span><span>)</span><span>;</span>\n\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br></div></div><h3 id=\"_2-3-5-autowirecapablebeanfactory\"> 2.3.5 AutowireCapableBeanFactory</h3>\n<p>Autowire是不是看着很熟,提供自动注入的方法。</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>AutowireCapableBeanFactory</span> <span>extends</span> <span>BeanFactory</span> <span>{</span>\n\n\t<span>// 不需要自动装配</span>\n\t<span>int</span> AUTOWIRE_NO <span>=</span> <span>0</span><span>;</span>\n\n\t<span>// 表示按名称自动装配 bean 属性的常量</span>\n\t<span>int</span> AUTOWIRE_BY_NAME <span>=</span> <span>1</span><span>;</span>\n\n\t<span>// 按照类型来自动装配</span>\n\t<span>int</span> AUTOWIRE_BY_TYPE <span>=</span> <span>2</span><span>;</span>\n\n\t<span>// 指示自动装配可以满足的最贪婪构造函数的常量</span>\n\t<span>int</span> AUTOWIRE_CONSTRUCTOR <span>=</span> <span>3</span><span>;</span>\n\n\t<span>//</span>\n\t<span>@Deprecated</span>\n\t<span>int</span> AUTOWIRE_AUTODETECT <span>=</span> <span>4</span><span>;</span>\n\n\t<span>// 5.1 才有的。初始化现有 bean 实例时的“原始实例”约定的后缀：附加到完全限定的 bean 类名，例如“com.mypackage.MyClass.ORIGINAL”，以强制返回给定的实例，即没有代理等。</span>\n\t<span>String</span> ORIGINAL_INSTANCE_SUFFIX <span>=</span> <span>\".ORIGINAL\"</span><span>;</span>\n\n\n\t<span>//-------------------------------------------------------------------------</span>\n\t<span>// 创建和填充bean 实例的方法</span>\n\t<span>//-------------------------------------------------------------------------</span>\n\n\t<span>// 创建bean</span>\n\t<span><span>&lt;</span><span>T</span><span>></span></span> <span>T</span> <span>createBean</span><span>(</span><span>Class</span><span><span>&lt;</span><span>T</span><span>></span></span> beanClass<span>)</span> <span>throws</span> <span>BeansException</span><span>;</span>\n\n\t<span>// 自动装配bean</span>\n\t<span>void</span> <span>autowireBean</span><span>(</span><span>Object</span> existingBean<span>)</span> <span>throws</span> <span>BeansException</span><span>;</span>\n\n\t<span>// 给一个空实例,也能进行填充。</span>\n\t<span>Object</span> <span>configureBean</span><span>(</span><span>Object</span> existingBean<span>,</span> <span>String</span> beanName<span>)</span> <span>throws</span> <span>BeansException</span><span>;</span>\n\n\n\t<span>//-------------------------------------------------------------------------</span>\n\t<span>// 对 bean 生命周期进行细粒度控制的专用方法</span>\n\t<span>//-------------------------------------------------------------------------</span>\n\n\t\n\t<span>Object</span> <span>createBean</span><span>(</span><span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> beanClass<span>,</span> <span>int</span> autowireMode<span>,</span> <span>boolean</span> dependencyCheck<span>)</span> <span>throws</span> <span>BeansException</span><span>;</span>\n  \n\t<span>Object</span> <span>autowire</span><span>(</span><span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> beanClass<span>,</span> <span>int</span> autowireMode<span>,</span> <span>boolean</span> dependencyCheck<span>)</span> <span>throws</span> <span>BeansException</span><span>;</span>\n  \n\t<span>void</span> <span>autowireBeanProperties</span><span>(</span><span>Object</span> existingBean<span>,</span> <span>int</span> autowireMode<span>,</span> <span>boolean</span> dependencyCheck<span>)</span>\n\t\t\t<span>throws</span> <span>BeansException</span><span>;</span>\n      \n\t<span>void</span> <span>applyBeanPropertyValues</span><span>(</span><span>Object</span> existingBean<span>,</span> <span>String</span> beanName<span>)</span> <span>throws</span> <span>BeansException</span><span>;</span>\n  \n\t<span>Object</span> <span>initializeBean</span><span>(</span><span>Object</span> existingBean<span>,</span> <span>String</span> beanName<span>)</span> <span>throws</span> <span>BeansException</span><span>;</span>\n  \n\t<span>Object</span> <span>applyBeanPostProcessorsBeforeInitialization</span><span>(</span><span>Object</span> existingBean<span>,</span> <span>String</span> beanName<span>)</span>\n\t\t\t<span>throws</span> <span>BeansException</span><span>;</span>\n      \n\t<span>Object</span> <span>applyBeanPostProcessorsAfterInitialization</span><span>(</span><span>Object</span> existingBean<span>,</span> <span>String</span> beanName<span>)</span>\n\t\t\t<span>throws</span> <span>BeansException</span><span>;</span>\n      \n\t<span>void</span> <span>destroyBean</span><span>(</span><span>Object</span> existingBean<span>)</span><span>;</span>\n\n\t<span><span>&lt;</span><span>T</span><span>></span></span> <span>NamedBeanHolder</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>resolveNamedBean</span><span>(</span><span>Class</span><span><span>&lt;</span><span>T</span><span>></span></span> requiredType<span>)</span> <span>throws</span> <span>BeansException</span><span>;</span>\n\n\t<span>Object</span> <span>resolveBeanByName</span><span>(</span><span>String</span> name<span>,</span> <span>DependencyDescriptor</span> descriptor<span>)</span> <span>throws</span> <span>BeansException</span><span>;</span>\n\n\t<span>@Nullable</span>\n\t<span>Object</span> <span>resolveDependency</span><span>(</span><span>DependencyDescriptor</span> descriptor<span>,</span> <span>@Nullable</span> <span>String</span> requestingBeanName<span>)</span> <span>throws</span> <span>BeansException</span><span>;</span>\n\n\t<span>@Nullable</span>\n\t<span>Object</span> <span>resolveDependency</span><span>(</span><span>DependencyDescriptor</span> descriptor<span>,</span> <span>@Nullable</span> <span>String</span> requestingBeanName<span>,</span>\n\t\t\t<span>@Nullable</span> <span>Set</span><span><span>&lt;</span><span>String</span><span>></span></span> autowiredBeanNames<span>,</span> <span>@Nullable</span> <span>TypeConverter</span> typeConverter<span>)</span> <span>throws</span> <span>BeansException</span><span>;</span>\n\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br></div></div><h3 id=\"_2-3-6-configurablelistablebeanfactory\"> 2.3.6 ConfigurableListableBeanFactory</h3>\n<p>看名字大概就能猜出些什么了，具体接口定义看下面。</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>ConfigurableListableBeanFactory</span>\n\t\t<span>extends</span> <span>ListableBeanFactory</span><span>,</span> <span>AutowireCapableBeanFactory</span><span>,</span> <span>ConfigurableBeanFactory</span> <span>{</span>\n\n\t<span>// 自动装配时候，忽略这些类型</span>\n\t<span>void</span> <span>ignoreDependencyType</span><span>(</span><span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> type<span>)</span><span>;</span>\n\n\t<span>// 自动装配时候，忽略这些接口</span>\n\t<span>void</span> <span>ignoreDependencyInterface</span><span>(</span><span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> ifc<span>)</span><span>;</span>\n\n\t<span>// 给当前类型,注入指定的实例。</span>\n\t<span>void</span> <span>registerResolvableDependency</span><span>(</span><span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> dependencyType<span>,</span> <span>@Nullable</span> <span>Object</span> autowiredValue<span>)</span><span>;</span>\n\n\t<span>// 判断当前bean是否有资格作为自动装配的候选者</span>\n\t<span>boolean</span> <span>isAutowireCandidate</span><span>(</span><span>String</span> beanName<span>,</span> <span>DependencyDescriptor</span> descriptor<span>)</span>\n\t\t\t<span>throws</span> <span>NoSuchBeanDefinitionException</span><span>;</span>\n\n\t<span>// 返回指定 bean 的注册 BeanDefinition</span>\n\t<span>BeanDefinition</span> <span>getBeanDefinition</span><span>(</span><span>String</span> beanName<span>)</span> <span>throws</span> <span>NoSuchBeanDefinitionException</span><span>;</span>\n\n\t<span>// 返回此工厂管理的所有 bean 名称</span>\n\t<span>Iterator</span><span><span>&lt;</span><span>String</span><span>></span></span> <span>getBeanNamesIterator</span><span>(</span><span>)</span><span>;</span>\n\n\t<span>// 清除合并的 bean 定义缓存，通常在更改原始 bean 定义后触发</span>\n\t<span>void</span> <span>clearMetadataCache</span><span>(</span><span>)</span><span>;</span>\n\n\t<span>// 冻结所有 bean 定义，表示注册的 bean 定义将不会被修改或进一步后处理</span>\n\t<span>void</span> <span>freezeConfiguration</span><span>(</span><span>)</span><span>;</span>\n\n\t<span>// 返回此工厂的 bean 定义是否被冻结，即不应该进一步修改或后处理。</span>\n\t<span>boolean</span> <span>isConfigurationFrozen</span><span>(</span><span>)</span><span>;</span>\n\n\t<span>// 单例初始化方法,非常重要,我们开发中大部分bean初始化就是这个方法调用的哦。</span>\n\t<span>void</span> <span>preInstantiateSingletons</span><span>(</span><span>)</span> <span>throws</span> <span>BeansException</span><span>;</span>\n\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><p>好了关于工厂的定义已经全部展示了，剩下的都是具体的实现。具体的实现就不单独拿出来了。下面我们来看Spring中的上下文对象。</p>\n<h2 id=\"三、applicationcontext-容器上下文\"> 三、ApplicationContext 容器上下文</h2>\n<p>应用上下文,是Spring中最最核心的类,也是功能最强大的类,Spring所有的工具基本都能通过上下文来获取。</p>\n<ul>\n<li>获取环境变量</li>\n<li>获取Bean工厂</li>\n<li>发送容器事件</li>\n</ul>\n<p>下面我们看Spring中构建上下文的几种方式。</p>\n<h2 id=\"_3-1-构建上下文\"> 3.1 构建上下文</h2>\n<h3 id=\"_3-1-1-参数化构建\"> 3.1.1 参数化构建</h3>\n<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n    <span>ApplicationContext</span> ctx <span>=</span> <span>new</span> <span>AnnotationConfigApplicationContext</span><span>(</span><span>MyServiceImpl</span><span>.</span><span>class</span><span>,</span> <span>Dependency1</span><span>.</span><span>class</span><span>,</span> <span>Dependency2</span><span>.</span><span>class</span><span>)</span><span>;</span>\n    <span>MyService</span> myService <span>=</span> ctx<span>.</span><span>getBean</span><span>(</span><span>MyService</span><span>.</span><span>class</span><span>)</span><span>;</span>\n    myService<span>.</span><span>doStuff</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n    <span>AnnotationConfigApplicationContext</span> ctx <span>=</span> <span>new</span> <span>AnnotationConfigApplicationContext</span><span>(</span><span>)</span><span>;</span>\n    ctx<span>.</span><span>register</span><span>(</span><span>AppConfig</span><span>.</span><span>class</span><span>,</span> <span>OtherConfig</span><span>.</span><span>class</span><span>)</span><span>;</span>\n    ctx<span>.</span><span>register</span><span>(</span><span>AdditionalConfig</span><span>.</span><span>class</span><span>)</span><span>;</span>\n    ctx<span>.</span><span>refresh</span><span>(</span><span>)</span><span>;</span>\n    <span>MyService</span> myService <span>=</span> ctx<span>.</span><span>getBean</span><span>(</span><span>MyService</span><span>.</span><span>class</span><span>)</span><span>;</span>\n    myService<span>.</span><span>doStuff</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id=\"_3-1-2-目录扫描\"> 3.1.2 目录扫描</h3>\n<p>扫描 <code>com.acme</code> 包以查找任何 带@Component注释的类，并且这些类在容器中注册为 Spring bean 定义。</p>\n<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n    <span>AnnotationConfigApplicationContext</span> ctx <span>=</span> <span>new</span> <span>AnnotationConfigApplicationContext</span><span>(</span><span>)</span><span>;</span>\n    ctx<span>.</span><span>scan</span><span>(</span><span>\"com.acme\"</span><span>)</span><span>;</span>\n    ctx<span>.</span><span>refresh</span><span>(</span><span>)</span><span>;</span>\n    <span>MyService</span> myService <span>=</span> ctx<span>.</span><span>getBean</span><span>(</span><span>MyService</span><span>.</span><span>class</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id=\"_3-2-容器事件\"> 3.2 容器事件</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">事件</th>\n<th style=\"text-align:left\">解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>ContextRefreshedEvent</code></td>\n<td style=\"text-align:left\">在初始化或刷新时发布<code>ApplicationContext</code>（例如，通过使用接口<code>refresh()</code>上的方法<code>ConfigurableApplicationContext</code>）。这里，“初始化”意味着所有 bean 都已加载，后处理器 bean 被检测并激活，单例被预实例化，并且<code>ApplicationContext</code>对象已准备好使用。只要上下文没有关闭，就可以多次触发刷新，前提是所选择的<code>ApplicationContext</code>实际支持这种“热”刷新。例如，<code>XmlWebApplicationContext</code>支持热刷新，但 <code>GenericApplicationContext</code>不支持。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>ContextStartedEvent</code></td>\n<td style=\"text-align:left\">使用接口上的方法 <code>ApplicationContext</code>启动时发布。在这里，“已启动”意味着所有 bean 都接收到一个明确的启动信号。通常，此信号用于在显式停止后重新启动 bean，但它也可用于启动尚未配置为自动启动的组件（例如，尚未在初始化时启动的组件）。<code>start()``ConfigurableApplicationContext``Lifecycle</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>ContextStoppedEvent</code></td>\n<td style=\"text-align:left\">使用接口上的方法 <code>ApplicationContext</code>停止时发布。在这里，“停止”意味着所有 的 bean 都会收到一个明确的停止信号。可以通过 调用重新启动已停止的上下文。<code>stop()``ConfigurableApplicationContext``Lifecycle``start()</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>ContextClosedEvent</code></td>\n<td style=\"text-align:left\">在<code>ApplicationContext</code>使用接口<code>close()</code>上的方法<code>ConfigurableApplicationContext</code>或通过 JVM 关闭挂钩关闭时发布。在这里，“关闭”意味着所有的单例 bean 都将被销毁。一旦上下文关闭，它就到了生命的尽头，无法刷新或重新启动。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>RequestHandledEvent</code></td>\n<td style=\"text-align:left\">一个特定于 Web 的事件，告诉所有 bean 一个 HTTP 请求已得到服务。此事件在请求完成后发布。此事件仅适用于使用 Spring 的 Web 应用程序<code>DispatcherServlet</code>。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>ServletRequestHandledEvent</code></td>\n<td style=\"text-align:left\">它的子类<code>RequestHandledEvent</code>添加了 Servlet 特定的上下文信息。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_3-2-1-contextrefreshedevent-容器刷新事件\"> 3.2.1 ContextRefreshedEvent 容器刷新事件</h3>\n<p>容器启动的最后一步,发送容器刷新事件,当收到这个事件的时候,容器就已经准备就绪了,你就可以正常使用了。</p>\n<ul>\n<li><code>AbstractApplicationContext#finishRefresh</code></li>\n</ul>\n<p><img src=\"https://img.springlearn.cn/blog/125e0b6ea32c588517f32b72ed49e461.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_3-2-2-contextclosedevent-关闭事件\"> 3.2.2 ContextClosedEvent 关闭事件</h3>\n<p>一旦应用被关闭或者中断就会触发容器关闭事件。但是 <code>kill -9</code> 除外, <code>kill</code> 是可以的。这背后的原因,这是linux系统的机制,更多详细请自行百度。</p>\n<h3 id=\"_3-2-3-contextstartedevent-启动事件\"> 3.2.3 ContextStartedEvent 启动事件</h3>\n<p>ContextStartedEvent 跟前面两个的事件不同是,必须要显示触发,比如下面这样。</p>\n<div><pre><code> <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>SpringApplication</span><span>.</span><span>run</span><span>(</span><span>Application</span><span>.</span><span>class</span><span>,</span>args<span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"_3-2-4-contextstoppedevent-停止事件\"> 3.2.4 ContextStoppedEvent 停止事件</h3>\n<p>ContextStoppedEvent 和 ContextStartedEvent 是一样的，必须要显示调用。</p>\n<div><pre><code> <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>SpringApplication</span><span>.</span><span>run</span><span>(</span><span>Application</span><span>.</span><span>class</span><span>,</span>args<span>)</span><span>.</span><span>stop</span><span>(</span><span>)</span><span>;</span>\n <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"_3-2-5-requesthandledevent\"> 3.2.5 RequestHandledEvent</h3>\n<p>当收到http请求时候触发,此事件仅适用于使用 Spring 的 Web 应用程序DispatcherServlet。</p>\n<h3 id=\"_3-2-6-servletrequesthandledevent\"> 3.2.6 ServletRequestHandledEvent</h3>\n<p>跟前这一样,不同的是增加了Servlet的信息.</p>\n<p><img src=\"https://img.springlearn.cn/blog/1157fdfe955ecc93d98bbb3090e2258f.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>更多事件相关,请看下一篇,Event专题</strong></p>\n<h2 id=\"四、javaconfig-配置\"> 四、JavaConfig 配置</h2>\n<blockquote>\n<p>在之前Spring的配置都是基于xml方式,当Jdk5之后支持注解后,Spring的配置方式增加了基于注解的配置。</p>\n</blockquote>\n<p>那么你认为Java代码注解配置好? 还是xml方式好呢?</p>\n<p>我们看下官方的回答:</p>\n<ul>\n<li>简短的回答是“视情况而定”。</li>\n<li>长答案是每种方法都有其优点和缺点，通常由开发人员决定哪种策略更适合他们。</li>\n</ul>\n<p>由于它们的定义方式，注解方式在其声明中提供了大量上下文，从而使配置更短、更简洁。\n然而，XML 擅长在不触及源代码或重新编译它们的情况下连接组件。一些开发人员更喜欢在源附近进行布线，而另一些开发人员则认为带注释的类不再是 POJO，此外，配置变得分散且更难控制。\n无论选择如何，Spring 都可以同时适应这两种风格，甚至可以将它们混合在一起。</p>\n<p>改部分介绍如何在 Java 代码中使用注解来配置 Spring 容器。它包括以下主题：</p>\n<h2 id=\"_4-1-configuration-配置类\"> 4.1 @Configuration 配置类</h2>\n<p>Spring 新的 Java 配置,的主要使用的是 @Configuration注释的类。</p>\n<div><pre><code><span>@Configuration</span>\n<span>public</span> <span>class</span> <span>AppConfig</span> <span>{</span>\n\n    <span>@Bean</span>\n    <span>public</span> <span>MyService</span> <span>myService</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>new</span> <span>MyServiceImpl</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>前面的AppConfig类等价于下面的 Spring <beans/>XML：</p>\n<div><pre><code><span><span><span>&lt;</span>beans</span><span>></span></span>\n    <span><span><span>&lt;</span>bean</span> <span>id</span><span><span>=</span><span>\"</span>myService<span>\"</span></span> <span>class</span><span><span>=</span><span>\"</span>com.acme.services.MyServiceImpl<span>\"</span></span><span>/></span></span>\n<span><span><span>&lt;/</span>beans</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"_4-2-带-bean注解的方法\"> 4.2 带@Bean注解的方法</h2>\n<p>当@Bean方法在没有用 <code>@Configuration</code> 注解修饰的类中声明时 ，它们被称为以“精简”模式处理。\n如下代码示例。</p>\n<div><pre><code><span>@Component</span>\n<span>public</span> <span>class</span> <span>AppConfig</span> <span>{</span>\n\n    <span>@Bean</span>\n    <span>public</span> <span>MyService</span> <span>myService</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>new</span> <span>MyServiceImpl</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id=\"_4-3-configuration和-bean的区别\"> 4.3 @Configuration和@Bean的区别</h2>\n<p>与@Configuration不同的是,使用@Bean方法的模式, 不能声明 bean 间的依赖关系。这句话怎么理解的。我们举一个代码的例子。</p>\n<div><pre><code><span>@Component</span>\n<span>public</span> <span>class</span> <span>BeanConf</span> <span>{</span>\n\n    <span>@Bean</span><span>(</span><span>\"serverA\"</span><span>)</span>\n    <span>public</span> <span>ServerA</span> <span>serverA</span><span>(</span><span>)</span> <span>{</span>\n        <span>ServerA</span> serverA <span>=</span> <span>new</span> <span>ServerA</span><span>(</span><span>\"Configuration 方式\"</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"ServerA:\"</span> <span>+</span> serverA<span>.</span><span>hashCode</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>return</span> serverA<span>;</span>\n    <span>}</span>\n\n    <span>@Bean</span><span>(</span><span>\"serverB\"</span><span>)</span>\n    <span>public</span> <span>ServerB</span> <span>serverB</span><span>(</span><span>)</span> <span>{</span>\n        <span>ServerB</span> serverB <span>=</span> <span>new</span> <span>ServerB</span><span>(</span><span>)</span><span>;</span>\n        <span>ServerA</span> serverA <span>=</span> <span>serverA</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Method ServerA:\"</span> <span>+</span> serverA<span>.</span><span>hashCode</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        serverB<span>.</span><span>setServerA</span><span>(</span>serverA<span>)</span><span>;</span>\n        <span>return</span> serverB<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>我们使用 <code>Component</code> 来修饰, <code>ServerA:</code> 这一行,会打印2次,第一次是 <code>@Bean</code>解析Bean时候。第二次是\n在 serverB方法调用时候执行。此时ServerB中注入的ServerA并不是被容器管理的Bean。而是调用方法新建的ServerA。</p>\n<p>好下面我们看另外一个例子。</p>\n<div><pre><code><span>@Configuration</span>\n<span>public</span> <span>class</span> <span>BeanConf</span> <span>{</span>\n\n    <span>@Bean</span><span>(</span><span>\"serverA\"</span><span>)</span>\n    <span>public</span> <span>ServerA</span> <span>serverA</span><span>(</span><span>)</span> <span>{</span>\n        <span>ServerA</span> serverA <span>=</span> <span>new</span> <span>ServerA</span><span>(</span><span>\"Configuration 方式\"</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"ServerA:\"</span> <span>+</span> serverA<span>.</span><span>hashCode</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>return</span> serverA<span>;</span>\n    <span>}</span>\n\n    <span>@Bean</span><span>(</span><span>\"serverB\"</span><span>)</span>\n    <span>public</span> <span>ServerB</span> <span>serverB</span><span>(</span><span>)</span> <span>{</span>\n        <span>ServerB</span> serverB <span>=</span> <span>new</span> <span>ServerB</span><span>(</span><span>)</span><span>;</span>\n        <span>ServerA</span> serverA <span>=</span> <span>serverA</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Method ServerA:\"</span> <span>+</span> serverA<span>.</span><span>hashCode</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        serverB<span>.</span><span>setServerA</span><span>(</span>serverA<span>)</span><span>;</span>\n        <span>return</span> serverB<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>与前面不同的是, <code>ServerA:</code> 这一行,会打印1次,就是解析 <code>@Bean</code>的时候。而 serverB()方法中虽然调用了 serverA()方法,但是并不会执行,而是从容器中直接拿到前面解析的Bean。</p>\n<p>所以我们得出结论,我们尽量要用 <code>@Configuration</code> 来声明配置,避免出现意外的问题。</p>\n<h2 id=\"五、基于注解容器配置\"> 五、基于注解容器配置</h2>\n<h2 id=\"_5-1-required\"> 5.1 @Required</h2>\n<p>此注解指示必须在配置时通过 bean 定义中的显式属性值或通过自动装配来填充受影响的 bean 属性。如果受影响的 bean 属性尚未填充，则容器将引发异常。</p>\n<p>处理类: <code>RequiredAnnotationBeanPostProcessor</code></p>\n<p>注意: 这种方式已经声明废弃了,不过也支持,但是不建议使用。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>SimpleMovieLister</span> <span>{</span>\n\n    <span>private</span> <span>MovieFinder</span> movieFinder<span>;</span>\n\n    <span>@Required</span>\n    <span>public</span> <span>void</span> <span>setMovieFinder</span><span>(</span><span>MovieFinder</span> movieFinder<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>movieFinder <span>=</span> movieFinder<span>;</span>\n    <span>}</span>\n\n    <span>// ...</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id=\"_5-2-autowired\"> 5.2 @Autowired</h2>\n<p>声明注入的,@Autowired 默认不允许为空,即跟 <code>@Required</code> 一样,如果为空就中断,但是也允许为空。\n如果为空,不想中断,可以这样使用 <code>@Autowired(required = false)</code></p>\n<div><pre><code><span>public</span> <span>class</span> <span>MovieRecommender</span> <span>{</span>\n\n    <span>private</span> <span>final</span> <span>CustomerPreferenceDao</span> customerPreferenceDao<span>;</span>\n\n    <span>@Autowired</span>\n    <span>public</span> <span>MovieRecommender</span><span>(</span><span>CustomerPreferenceDao</span> customerPreferenceDao<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>customerPreferenceDao <span>=</span> customerPreferenceDao<span>;</span>\n    <span>}</span>\n\n    <span>// ...</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id=\"_5-3-primary\"> 5.3 @Primary</h2>\n<ul>\n<li>Primary翻译: 主要的</li>\n</ul>\n<p>由于按类型自动装配可能会导致多个候选者，因此通常需要对选择过程进行更多控制。实现这一点的一种方法是使用 Spring 的 @Primary注释。@Primary: 当多个 bean 是自动装配到单值依赖项的候选对象时，应该优先考虑特定的 bean。如果候选中恰好存在一个主 bean，则它将成为自动装配的值。</p>\n<p>如下,MovieCatalog类型有两个Bean。</p>\n<div><pre><code><span>@Configuration</span>\n<span>public</span> <span>class</span> <span>MovieConfiguration</span> <span>{</span>\n\n    <span>@Bean</span><span>(</span><span>\"MovieCatalog1\"</span><span>)</span>\n    <span>@Primary</span>\n    <span>public</span> <span>MovieCatalog</span> <span>firstMovieCatalog</span><span>(</span><span>)</span> <span>{</span> <span>.</span><span>.</span><span>.</span> <span>}</span>\n\n    <span>@Bean</span><span>(</span><span>\"MovieCatalog2\"</span><span>)</span>\n    <span>public</span> <span>MovieCatalog</span> <span>secondMovieCatalog</span><span>(</span><span>)</span> <span>{</span> <span>.</span><span>.</span><span>.</span> <span>}</span>\n\n    <span>// ...</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>当要进行注入时候就会报错,因为根据类型发现了两个备选的Bean。而这种情况的解决办法就是其中一个使用 <code>@Primary</code> 来修饰。此时容器就知道你到底要注册那个了,当被 <code>@Primary</code> 修饰的Bean会被正确注入。</p>\n<p>此时可能有朋友会问,如果两个一样类型的Bean都用 <code>@Primary</code> 来修饰呢? 结果就是会报错。如下。</p>\n<div><pre><code>No qualifying bean of type &#39;learn.spring.service.ServerA&#39; available: more than one &#39;primary&#39; bean found among candidates: [serverA1, serverA2]\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"_5-4-qualifier\"> 5.4 @Qualifier</h2>\n<p><code>@Primary</code>当可以确定一个主要候选者时，是一种通过类型使用多个实例的自动装配的有效方法。当您需要对选择过程进行更多控制时，可以使用 Spring 的@Qualifier注解。您可以将限定符值与特定参数相关联，缩小类型匹配的范围，以便为每个参数选择特定的 bean。</p>\n<div><pre><code><span>@Configuration</span>\n<span>public</span> <span>class</span> <span>MovieConfiguration</span> <span>{</span>\n\n    <span>@Bean</span><span>(</span><span>\"main\"</span><span>)</span>\n    <span>public</span> <span>MovieCatalog</span> <span>firstMovieCatalog</span><span>(</span><span>)</span> <span>{</span> <span>.</span><span>.</span><span>.</span> <span>}</span>\n\n    <span>@Bean</span>\n    <span>public</span> <span>MovieCatalog</span> <span>secondMovieCatalog</span><span>(</span><span>)</span> <span>{</span> <span>.</span><span>.</span><span>.</span> <span>}</span>\n\n    <span>// ...</span>\n<span>}</span>\n\n<span>public</span> <span>class</span> <span>MovieRecommender</span> <span>{</span>\n\n    <span>@Autowired</span>\n    <span>@Qualifier</span><span>(</span><span>\"main\"</span><span>)</span>\n    <span>private</span> <span>MovieCatalog</span> movieCatalog<span>;</span>\n\n    <span>// ...</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>一个最简单的解释就是 <code>@Autowired + @Qualifier</code> = <code>@Resource</code>。</p>\n<h2 id=\"_5-5-customautowireconfigurer\"> 5.5 CustomAutowireConfigurer</h2>\n<p>前面我们可以通过 @Qualifier 实现根据名字的注入, CustomAutowireConfigurer 允许我们自定义一个注解, 具备和  @Qualifier 一样的功能。</p>\n<p>首先我们声明一个注解,保持和@Qualifier一样的结构</p>\n<div><pre><code><span>@Target</span><span>(</span><span>{</span><span>ElementType</span><span>.</span>FIELD<span>,</span> <span>ElementType</span><span>.</span>METHOD<span>,</span> <span>ElementType</span><span>.</span>PARAMETER<span>,</span> <span>ElementType</span><span>.</span>TYPE<span>,</span> <span>ElementType</span><span>.</span>ANNOTATION_TYPE<span>}</span><span>)</span>\n<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>\n<span>@Inherited</span>\n<span>@Documented</span>\n<span>public</span> <span>@interface</span> <span>ConditionAutowire</span> <span>{</span>\n    <span>String</span> <span>value</span><span>(</span><span>)</span> <span>default</span> <span>\"\"</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>然后使用CustomAutowireConfigurer来,配置我们自定义的注解。</p>\n<div><pre><code>    <span>/**\n     * 自定义一个注入工具\n     *\n     * @return 注入工具\n     */</span>\n    <span>@Bean</span>\n    <span>public</span> <span>CustomAutowireConfigurer</span> <span>customAutowireConfigurer</span><span>(</span><span>)</span> <span>{</span>\n        <span>CustomAutowireConfigurer</span> customAutowireConfigurer <span>=</span> <span>new</span> <span>CustomAutowireConfigurer</span><span>(</span><span>)</span><span>;</span>\n        customAutowireConfigurer<span>.</span><span>setCustomQualifierTypes</span><span>(</span><span>Collections</span><span>.</span><span>singleton</span><span>(</span><span>ConditionAutowire</span><span>.</span><span>class</span><span>)</span><span>)</span><span>;</span>\n        <span>return</span> customAutowireConfigurer<span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>这样我们就能使用下面的代码了。</p>\n<div><pre><code><span>@Component</span>\n<span>public</span> <span>class</span> <span>ServerB</span> <span>{</span>\n\n    <span>ServerA</span> serverA<span>;</span>\n\n\n    <span>@Autowired</span>\n    <span>// @Qualifier(\"serverAA\") 与下面代码等价。</span>\n    <span>@ConditionAutowire</span><span>(</span><span>\"serverAA\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>setServerA</span><span>(</span><span>ServerA</span> serverA<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>serverA <span>=</span> serverA<span>;</span>\n    <span>}</span>\n<span>}</span>    \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id=\"_5-6-resource\"> 5.6 @Resource</h2>\n<p>Spring 还通过在字段或 bean 属性设置器方法上使用 JSR-250@Resource注释 ( )来支持注入。javax.annotation.Resource这是 Java EE 中的常见模式：例如，在 JSF 管理的 bean 和 JAX-WS 端点中。Spring 也支持 Spring 管理的对象的这种模式。</p>\n<p>@Resource采用名称属性。默认情况下，Spring 将该值解释为要注入的 bean 名称。换句话说，它遵循按名称语义，如以下示例所示：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>SimpleMovieLister</span> <span>{</span>\n\n    <span>private</span> <span>MovieFinder</span> movieFinder<span>;</span>\n\n    <span>@Resource</span><span>(</span>name<span>=</span><span>\"myMovieFinder\"</span><span>)</span> \n    <span>public</span> <span>void</span> <span>setMovieFinder</span><span>(</span><span>MovieFinder</span> movieFinder<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>movieFinder <span>=</span> movieFinder<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>如果没有明确指定名称，则默认名称派生自字段名称或 setter 方法。如果是字段，则采用字段名称。对于 setter 方法，它采用 bean 属性名称。以下示例将把名为 bean 的 beanmovieFinder注入到它的 setter 方法中：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>SimpleMovieLister</span> <span>{</span>\n\n    <span>private</span> <span>MovieFinder</span> movieFinder<span>;</span>\n\n    <span>@Resource</span>\n    <span>public</span> <span>void</span> <span>setMovieFinder</span><span>(</span><span>MovieFinder</span> movieFinder<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>movieFinder <span>=</span> movieFinder<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id=\"_5-7-value\"> 5.7 @Value</h2>\n<p>@Value通常用于注入外部属性</p>\n<div><pre><code><span>@Component</span>\n<span>public</span> <span>class</span> <span>MovieRecommender</span> <span>{</span>\n\n    <span>private</span> <span>final</span> <span>String</span> catalog<span>;</span>\n\n    <span>public</span> <span>MovieRecommender</span><span>(</span><span>@Value</span><span>(</span><span>\"${catalog.name}\"</span><span>)</span> <span>String</span> catalog<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>catalog <span>=</span> catalog<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>application.properties文件,添加上一下配置</p>\n<div><pre><code>catalog.name=MovieCatalog\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"_5-7-1-默认值\"> 5.7.1 默认值</h3>\n<ul>\n<li>@Value(&quot;${catalog.name:defaultCatalog}&quot;)</li>\n</ul>\n<div><pre><code><span>@Component</span>\n<span>public</span> <span>class</span> <span>MovieRecommender</span> <span>{</span>\n\n    <span>private</span> <span>final</span> <span>String</span> catalog<span>;</span>\n\n    <span>public</span> <span>MovieRecommender</span><span>(</span><span>@Value</span><span>(</span><span>\"${catalog.name:defaultCatalog}\"</span><span>)</span> <span>String</span> catalog<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>catalog <span>=</span> catalog<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"_5-7-1-支持springel-表达式\"> 5.7.1 支持SpringEL 表达式</h3>\n<p>当@Value包含SpEL表达式时，该值将在运行时动态计算，如以下示例所示：</p>\n<div><pre><code><span>@Component</span>\n<span>public</span> <span>class</span> <span>MovieRecommender</span> <span>{</span>\n\n    <span>private</span> <span>final</span> <span>String</span> catalog<span>;</span>\n\n    <span>public</span> <span>MovieRecommender</span><span>(</span><span>@Value</span><span>(</span><span>\"#{systemProperties['user.catalog'] + 'Catalog' }\"</span><span>)</span> <span>String</span> catalog<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>catalog <span>=</span> catalog<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>SpEL 还支持使用更复杂的数据结构：</p>\n<ul>\n<li>注意如果使用EL表达式,就不是$而是#</li>\n</ul>\n<div><pre><code><span>@Component</span>\n<span>public</span> <span>class</span> <span>MovieRecommender</span> <span>{</span>\n\n    <span>private</span> <span>final</span> <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Integer</span><span>></span></span> countOfMoviesPerCatalog<span>;</span>\n\n    <span>public</span> <span>MovieRecommender</span><span>(</span>\n            <span>@Value</span><span>(</span><span>\"#{{'Thriller': 100, 'Comedy': 300}}\"</span><span>)</span> <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Integer</span><span>></span></span> countOfMoviesPerCatalog<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>countOfMoviesPerCatalog <span>=</span> countOfMoviesPerCatalog<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id=\"_5-8-初始化-销毁方法\"> 5.8 初始化 &amp; 销毁方法</h2>\n<ul>\n<li>@PostConstruct</li>\n<li>@PreDestroy</li>\n</ul>\n<p>处理类: InitDestroyAnnotationBeanPostProcessor</p>\n<div><pre><code><span>public</span> <span>class</span> <span>CachingMovieLister</span> <span>{</span>\n\n    <span>@PostConstruct</span>\n    <span>public</span> <span>void</span> <span>populateMovieCache</span><span>(</span><span>)</span> <span>{</span>\n        <span>// 初始化执行</span>\n    <span>}</span>\n\n    <span>@PreDestroy</span>\n    <span>public</span> <span>void</span> <span>clearMovieCache</span><span>(</span><span>)</span> <span>{</span>\n        <span>// Bean销毁执行</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>可能会有人问</p>\n<ul>\n<li>不是还有<code>InitializingBean</code>初始化和<code>DisposableBean</code>接口能实现初始化和销毁方法吗?</li>\n</ul>\n<div><pre><code><span>public</span> <span>interface</span> <span>InitializingBean</span> <span>{</span>\n    <span>void</span> <span>afterPropertiesSet</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span><span>;</span>\n<span>}</span>\n<span>public</span> <span>interface</span> <span>DisposableBean</span> <span>{</span>\n    <span>void</span> <span>destroy</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ul>\n<li>不是还可以通过 <code>@Bean(initMethod = &quot;init&quot;,destroyMethod = &quot;destroy&quot;)</code> 来声明吗?</li>\n</ul>\n<p>是的当然都可以,不过这也是有执行顺序的,顺序如下。</p>\n<p><img src=\"https://img.springlearn.cn/blog/4c45e9413b184783019c571ab95c779b.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_5-9-scope\"> 5.9 @Scope</h2>\n<p>这个注解平时接触的都很少,但是其实我们都在用,因为如果不显示声明,默认就是 @Scope(&quot;singleton&quot;)</p>\n<p>这个怎么理解呢? 比如在Spring中默认都是单例 <code>singleton</code>,这就意味着就是说在容器不关闭的情况下，不管你调用了几次都是同一个实例。如果我们想让每个Thread拿到自己的实例呢? 有没有办法呢?</p>\n<p>当然有,如下我们定一个Thread范围的Bean, 首先给工厂定义自己的域范围。</p>\n<div><pre><code><span>@Component</span>\n<span>public</span> <span>class</span> <span>BeanFactoryConf</span> <span>implements</span> <span>BeanFactoryPostProcessor</span> <span>{</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>postProcessBeanFactory</span><span>(</span><span>ConfigurableListableBeanFactory</span> beanFactory<span>)</span> <span>throws</span> <span>BeansException</span> <span>{</span>\n        beanFactory<span>.</span><span>registerScope</span><span>(</span><span>\"thread\"</span><span>,</span> <span>new</span> <span>SimpleThreadScope</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Bean</span>\n    <span>@Scope</span><span>(</span><span>\"thread\"</span><span>)</span>\n    <span>public</span> <span>ThreadScopeBean</span> <span>threadScopeBean</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>new</span> <span>ThreadScopeBean</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>class</span> <span>ThreadScopeBean</span> <span>{</span>\n\n        <span>String</span> name<span>;</span>\n\n        <span>public</span> <span>ThreadScopeBean</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>\n            <span>this</span><span>.</span>name <span>=</span> name<span>;</span>\n        <span>}</span>\n\n        <span>@Override</span>\n        <span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span>\n            <span>return</span> name<span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><p>然后使用多个线程来获取这个Bean,最终我们会发现,每个线程得到的实例都是不一样的。符合Thread这个域的范围。</p>\n<div><pre><code>    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>ConfigurableApplicationContext</span> run <span>=</span> <span>SpringApplication</span><span>.</span><span>run</span><span>(</span><span>Application</span><span>.</span><span>class</span><span>,</span> args<span>)</span><span>;</span>\n        <span>ServerB</span> bean <span>=</span> run<span>.</span><span>getBean</span><span>(</span><span>ServerB</span><span>.</span><span>class</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>bean<span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>3</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>\n                <span>BeanFactoryConf<span>.</span>ThreadScopeBean</span> threadScope <span>=</span> run<span>.</span><span>getBean</span><span>(</span><span>BeanFactoryConf<span>.</span>ThreadScopeBean</span><span>.</span><span>class</span><span>)</span><span>;</span>\n                <span>// thread-scope-1</span>\n                <span>// thread-scope-2</span>\n                <span>// thread-scope-0</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>threadScope<span>)</span><span>;</span>\n            <span>}</span><span>,</span> <span>\"thread-scope-\"</span> <span>+</span> i<span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p><strong>注意:</strong> 上面这个例子,必须每次从容器中重新获取Bean才会生效。</p>\n<p>当然这里是Thread范围,其实还有Session范围和request范围,这两个是我们使用最多的。他们两个是如何实现的呢? 大家可以思考下,其实也很简单。就是对工具类和ThreadLocal的利用。有知道原理的,可以下面评论。</p>\n<h3 id=\"_5-9-1-httpservletrequest-注入\"> 5.9.1 HttpServletRequest 注入</h3>\n<p>这里解释一个经常被弄混淆概念,就是我们知道我们在容器中注入一个 <code>HttpServletRequest</code> 这个类,\n<code>HttpServletRequest</code> 不是一个 <code>Bean</code>, 为什么能注入呢?\n每次在使用的时候,都会获取当前的请求对象。他是如何实现的呢? 他不是Scope来实现的。而是通过。下面\n这两个行代码一起来实现的。</p>\n<ul>\n<li>beanFactory.registerScope(WebApplicationContext.SCOPE_REQUEST, new RequestScope()) 这一行的意思是,当发现你要注入的是SCOPE_REQUEST,时候会调用RequestScope@getObject来实例化。这个类不是单例不会被容器保存,也不是原型不会每次都来重新创建。</li>\n<li>beanFactory.registerResolvableDependency(ServletRequest.class, new RequestObjectFactory()) 的意思是，当这个类被注入到其他类的时候,要进行代理。</li>\n</ul>\n<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>registerWebApplicationScopes</span><span>(</span><span>ConfigurableListableBeanFactory</span> beanFactory<span>,</span>\n\t\t\t<span>@Nullable</span> <span>ServletContext</span> sc<span>)</span> <span>{</span>\n\n\t\tbeanFactory<span>.</span><span>registerScope</span><span>(</span><span>WebApplicationContext</span><span>.</span>SCOPE_REQUEST<span>,</span> <span>new</span> <span>RequestScope</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\t\tbeanFactory<span>.</span><span>registerResolvableDependency</span><span>(</span><span>ServletRequest</span><span>.</span><span>class</span><span>,</span> <span>new</span> <span>RequestObjectFactory</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>.</span><span>.</span><span>.</span>\n\t<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>在进行自动注入的时候,如果发现实例是一个 <code>ObjectFactory</code>  就会生成代理类。</p>\n<div><pre><code><span>public</span> <span>static</span> <span>Object</span> <span>resolveAutowiringValue</span><span>(</span><span>Object</span> autowiringValue<span>,</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> requiredType<span>)</span> <span>{</span>\n\t\t<span>if</span> <span>(</span>autowiringValue <span>instanceof</span> <span>ObjectFactory</span> <span>&amp;&amp;</span> <span>!</span>requiredType<span>.</span><span>isInstance</span><span>(</span>autowiringValue<span>)</span><span>)</span> <span>{</span>\n      <span>// 这里获取到RequestObjectFactory</span>\n\t\t\t<span>ObjectFactory</span><span><span>&lt;</span><span>?</span><span>></span></span> factory <span>=</span> <span>(</span><span>ObjectFactory</span><span><span>&lt;</span><span>?</span><span>></span></span><span>)</span> autowiringValue<span>;</span>\n\t\t\t<span>if</span> <span>(</span>autowiringValue <span>instanceof</span> <span>Serializable</span> <span>&amp;&amp;</span> requiredType<span>.</span><span>isInterface</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n\t\t\t\tautowiringValue <span>=</span> <span>Proxy</span><span>.</span><span>newProxyInstance</span><span>(</span>requiredType<span>.</span><span>getClassLoader</span><span>(</span><span>)</span><span>,</span>\n\t\t\t\t\t\t<span>new</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span><span>[</span><span>]</span> <span>{</span>requiredType<span>}</span><span>,</span> <span>new</span> <span>ObjectFactoryDelegatingInvocationHandler</span><span>(</span>factory<span>)</span><span>)</span><span>;</span>\n\t\t\t<span>}</span>\n\t\t\t<span>else</span> <span>{</span>\n\t\t\t\t<span>return</span> factory<span>.</span><span>getObject</span><span>(</span><span>)</span><span>;</span>\n\t\t\t<span>}</span>\n\t\t<span>}</span>\n\t\t<span>return</span> autowiringValue<span>;</span>\n\t<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>然后代理类中这样处理,在执行每个方法的时候,都从新获取 <code>ObjectFactory#getObject()</code>。</p>\n<div><pre><code><span>public</span> <span>Object</span> <span>invoke</span><span>(</span><span>Object</span> proxy<span>,</span> <span>Method</span> method<span>,</span> <span>Object</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>Throwable</span> <span>{</span>\n\t\t\t<span>String</span> methodName <span>=</span> method<span>.</span><span>getName</span><span>(</span><span>)</span><span>;</span>\n\t\t\t<span>if</span> <span>(</span>methodName<span>.</span><span>equals</span><span>(</span><span>\"equals\"</span><span>)</span><span>)</span> <span>{</span>\n\t\t\t\t<span>// Only consider equal when proxies are identical.</span>\n\t\t\t\t<span>return</span> <span>(</span>proxy <span>==</span> args<span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>\n\t\t\t<span>}</span>\n\t\t\t<span>else</span> <span>if</span> <span>(</span>methodName<span>.</span><span>equals</span><span>(</span><span>\"hashCode\"</span><span>)</span><span>)</span> <span>{</span>\n\t\t\t\t<span>// Use hashCode of proxy.</span>\n\t\t\t\t<span>return</span> <span>System</span><span>.</span><span>identityHashCode</span><span>(</span>proxy<span>)</span><span>;</span>\n\t\t\t<span>}</span>\n\t\t\t<span>else</span> <span>if</span> <span>(</span>methodName<span>.</span><span>equals</span><span>(</span><span>\"toString\"</span><span>)</span><span>)</span> <span>{</span>\n\t\t\t\t<span>return</span> <span>this</span><span>.</span>objectFactory<span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>\n\t\t\t<span>}</span>\n\t\t\t<span>try</span> <span>{</span>\n        <span>// 每次执行方法,都从新获取objectFactory.getObject()</span>\n        <span>// RequestObjectFactory中是使用ThreadLocal的方式来实现。</span>\n\t\t\t\t<span>return</span> method<span>.</span><span>invoke</span><span>(</span><span>this</span><span>.</span>objectFactory<span>.</span><span>getObject</span><span>(</span><span>)</span><span>,</span> args<span>)</span><span>;</span>\n\t\t\t<span>}</span>\n\t\t\t<span>catch</span> <span>(</span><span>InvocationTargetException</span> ex<span>)</span> <span>{</span>\n\t\t\t\t<span>throw</span> ex<span>.</span><span>getTargetException</span><span>(</span><span>)</span><span>;</span>\n\t\t\t<span>}</span>\n\t\t<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h2 id=\"_5-10-import\"> 5.10 @Import</h2>\n<p><code>@Import</code> 注解允许 <code>@Bean</code> 从另一个配置类加载定义，如以下示例所示：</p>\n<div><pre><code><span>@Configuration</span>\n<span>public</span> <span>class</span> <span>ConfigA</span> <span>{</span>\n\n    <span>@Bean</span>\n    <span>public</span> <span>A</span> <span>a</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>new</span> <span>A</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>@Configuration</span>\n<span>@Import</span><span>(</span><span>ConfigA</span><span>.</span><span>class</span><span>)</span>\n<span>public</span> <span>class</span> <span>ConfigB</span> <span>{</span>\n\n    <span>@Bean</span>\n    <span>public</span> <span>B</span> <span>b</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>new</span> <span>B</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>现在，不需要同时指定ConfigA.class和ConfigB.class在实例化上下文时，只ConfigB需要显式提供，如以下示例所示：</p>\n<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n    <span>ApplicationContext</span> ctx <span>=</span> <span>new</span> <span>AnnotationConfigApplicationContext</span><span>(</span><span>ConfigB</span><span>.</span><span>class</span><span>)</span><span>;</span>\n\n    <span>// now both beans A and B will be available...</span>\n    <span>A</span> a <span>=</span> ctx<span>.</span><span>getBean</span><span>(</span><span>A</span><span>.</span><span>class</span><span>)</span><span>;</span>\n    <span>B</span> b <span>=</span> ctx<span>.</span><span>getBean</span><span>(</span><span>B</span><span>.</span><span>class</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><blockquote>\n<p>从 Spring Framework 4.2 开始，@Import还支持对常规组件类的引用，类似于AnnotationConfigApplicationContext.register方法。如果您想通过使用一些配置类作为入口点来显式定义所有组件来避免组件扫描，这将特别有用。</p>\n</blockquote>\n<p>这里我们定义一个注解,使用Import修饰,这样当使用这个注解时候,就会自动去注册 <code>DubboComponentScanRegistrar</code> 到容器,然后去处理些dubbo组件扫描的逻辑。然后就可以你在DubboComponentScanRegistrar中来获取到DubboComponentScan注解的信息。</p>\n<div><pre><code><span>@Target</span><span>(</span><span>ElementType</span><span>.</span>TYPE<span>)</span>\n<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>\n<span>@Documented</span>\n<span>@Import</span><span>(</span><span>DubboComponentScanRegistrar</span><span>.</span><span>class</span><span>)</span>\n<span>public</span> <span>@interface</span> <span>DubboComponentScan</span> <span>{</span>\n   <span>String</span><span>[</span><span>]</span> <span>value</span><span>(</span><span>)</span> <span>default</span> <span>{</span><span>}</span><span>;</span>\n<span>}</span>\n\n<span>public</span> <span>class</span> <span>DubboComponentScanRegistrar</span> <span>implements</span> <span>ImportBeanDefinitionRegistrar</span> <span>{</span>\n\n   <span>public</span> <span>void</span> <span>registerBeanDefinitions</span><span>(</span><span>AnnotationMetadata</span> importingClassMetadata<span>,</span> <span>BeanDefinitionRegistry</span> registry<span>)</span> <span>{</span>\n        <span>// 获取DubboComponentScan注解中配置要扫描的目录</span>\n        <span>Set</span><span><span>&lt;</span><span>String</span><span>></span></span> packagesToScan <span>=</span> <span>getPackagesToScan</span><span>(</span>importingClassMetadata<span>)</span><span>;</span>\n        <span>// 扫描上面指定的目录,生成BeanDefinition通过registry去注册。</span>\n        <span>registerServiceAnnotationBeanPostProcessor</span><span>(</span>packagesToScan<span>,</span> registry<span>)</span><span>;</span>\n        \n        <span>registerReferenceAnnotationBeanPostProcessor</span><span>(</span>registry<span>)</span><span>;</span>\n\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h2 id=\"_5-11-profile\"> 5.11 @Profile</h2>\n<p>Bean 定义配置文件在核心容器中提供了一种机制，允许在不同环境中注册不同的 bean。“环境”这个词对不同的用户可能意味着不同的东西，这个功能可以帮助许多用例，包括：</p>\n<ul>\n<li>在开发中处理内存中的数据源，而不是在 QA 或生产中从 JNDI 中查找相同的数据源。</li>\n<li>仅在将应用程序部署到性能环境时才注册监控基础架构。</li>\n<li>为客户 A 和客户 B 部署注册定制的 bean 实现。</li>\n</ul>\n<div><pre><code><span>@Configuration</span>\n<span>@Profile</span><span>(</span><span>\"development\"</span><span>)</span>\n<span>public</span> <span>class</span> <span>StandaloneDataConfig</span> <span>{</span>\n\n    <span>@Bean</span>\n    <span>public</span> <span>DataSource</span> <span>dataSource</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>new</span> <span>EmbeddedDatabaseBuilder</span><span>(</span><span>)</span>\n            <span>.</span><span>setType</span><span>(</span><span>EmbeddedDatabaseType</span><span>.</span>HSQL<span>)</span>\n            <span>.</span><span>addScript</span><span>(</span><span>\"classpath:com/bank/config/sql/schema.sql\"</span><span>)</span>\n            <span>.</span><span>addScript</span><span>(</span><span>\"classpath:com/bank/config/sql/test-data.sql\"</span><span>)</span>\n            <span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n<span>@Configuration</span>\n<span>@Profile</span><span>(</span><span>\"production\"</span><span>)</span>\n<span>public</span> <span>class</span> <span>JndiDataConfig</span> <span>{</span>\n\n    <span>@Bean</span>\n    <span>public</span> <span>DataSource</span> <span>dataSource</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>Context</span> ctx <span>=</span> <span>new</span> <span>InitialContext</span><span>(</span><span>)</span><span>;</span>\n        <span>return</span> <span>(</span><span>DataSource</span><span>)</span> ctx<span>.</span><span>lookup</span><span>(</span><span>\"java:comp/env/jdbc/datasource\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h3 id=\"_5-11-1-自定义环境注解\"> 5.11.1 自定义环境注解</h3>\n<p>可以将 <code>@Profile</code> 其用作元注释以创建自定义组合注释。以下示例定义了一个自定义 <code>@Production</code> 注释，您可以将其用作 的替代品 <code>@Profile(&quot;production&quot;)</code></p>\n<div><pre><code><span>@Target</span><span>(</span><span>ElementType</span><span>.</span>TYPE<span>)</span>\n<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>\n<span>@Profile</span><span>(</span><span>\"production\"</span><span>)</span>\n<span>public</span> <span>@interface</span> <span>Production</span> <span>{</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"_5-11-2-激活环境\"> 5.11.2 激活环境</h3>\n<div><pre><code><span>AnnotationConfigApplicationContext</span> ctx <span>=</span> <span>new</span> <span>AnnotationConfigApplicationContext</span><span>(</span><span>)</span><span>;</span>\nctx<span>.</span><span>getEnvironment</span><span>(</span><span>)</span><span>.</span><span>setActiveProfiles</span><span>(</span><span>\"development\"</span><span>)</span><span>;</span>\nctx<span>.</span><span>register</span><span>(</span><span>SomeConfig</span><span>.</span><span>class</span><span>,</span> <span>StandaloneDataConfig</span><span>.</span><span>class</span><span>,</span> <span>JndiDataConfig</span><span>.</span><span>class</span><span>)</span><span>;</span>\nctx<span>.</span><span>refresh</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>此外，您还可以通过 <code>spring.profiles.active</code> 属性以声明方式激活配置文件</p>\n<p>以声明方式，<code>spring.profiles.active</code> 可以接受以逗号分隔的配置文件名称列表，如以下示例所示：</p>\n<div><pre><code>-Dspring.profiles.active=&quot;profile1,profile2&quot;\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"六、aware\"> 六、Aware</h2>\n<p>这个比较简单,当你看到实现了Aware结尾的接口,Spring都会给你自动给你注入对应的Spring种内置的组件。这个怎么理解呢,看下面。</p>\n<p><img src=\"https://img.springlearn.cn/blog/30492b96a0e4cf1464aa274a101483c9.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_6-1-beanfactoryaware\"> 6.1 BeanFactoryAware</h2>\n<p>获取 <code>BeanFactory</code></p>\n<div><pre><code><span>public</span> <span>interface</span> <span>BeanFactoryAware</span> <span>extends</span> <span>Aware</span> <span>{</span>\n\t<span>void</span> <span>setBeanFactory</span><span>(</span><span>BeanFactory</span> beanFactory<span>)</span> <span>throws</span> <span>BeansException</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"_6-2-beannameaware\"> 6.2 BeanNameAware</h2>\n<p>获取 <code>Bean</code> 的名称</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>BeanNameAware</span> <span>extends</span> <span>Aware</span> <span>{</span>\n\t<span>void</span> <span>setBeanName</span><span>(</span><span>String</span> name<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"_6-3-messagesourceaware\"> 6.3 MessageSourceAware</h2>\n<p>获取国际化对象 <code>MessageSource</code></p>\n<div><pre><code><span>public</span> <span>interface</span> <span>MessageSourceAware</span> <span>extends</span> <span>Aware</span> <span>{</span>\n\t<span>void</span> <span>setMessageSource</span><span>(</span><span>MessageSource</span> messageSource<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"_6-4-applicationcontextaware\"> 6.4 ApplicationContextAware</h2>\n<p>获取容器上下文 <code>ApplicationContext</code></p>\n<div><pre><code><span>public</span> <span>interface</span> <span>ApplicationContextAware</span> <span>extends</span> <span>Aware</span> <span>{</span>\n\t<span>void</span> <span>setApplicationContext</span><span>(</span><span>ApplicationContext</span> applicationContext<span>)</span> <span>throws</span> <span>BeansException</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"_6-5-applicationeventpublisheraware\"> 6.5 ApplicationEventPublisherAware</h2>\n<p>获取事件发送者 <code>ApplicationEventPublisher</code></p>\n<div><pre><code><span>public</span> <span>interface</span> <span>ApplicationEventPublisherAware</span> <span>extends</span> <span>Aware</span> <span>{</span>\n\t<span>void</span> <span>setApplicationEventPublisher</span><span>(</span><span>ApplicationEventPublisher</span> applicationEventPublisher<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"_6-6-resourceloaderaware\"> 6.6 ResourceLoaderAware</h2>\n<p>获取资源加载器 <code>ResourceLoader</code></p>\n<div><pre><code><span>public</span> <span>interface</span> <span>ResourceLoaderAware</span> <span>extends</span> <span>Aware</span> <span>{</span>\n\t<span>void</span> <span>setResourceLoader</span><span>(</span><span>ResourceLoader</span> resourceLoader<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"_6-7-servletconfigaware\"> 6.7 ServletConfigAware</h2>\n<p>获取 <code>ServletConfig</code></p>\n<div><pre><code><span>public</span> <span>interface</span> <span>ServletConfigAware</span> <span>extends</span> <span>Aware</span> <span>{</span>\n\t<span>void</span> <span>setServletConfig</span><span>(</span><span>ServletConfig</span> servletConfig<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"_6-8-servletcontextaware\"> 6.8 ServletContextAware</h2>\n<div><pre><code><span>public</span> <span>interface</span> <span>ServletContextAware</span> <span>extends</span> <span>Aware</span> <span>{</span>\n\t<span>void</span> <span>setServletContext</span><span>(</span><span>ServletContext</span> servletContext<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"七、生成候选组件的索引\"> 七、生成候选组件的索引</h2>\n<p>虽然类路径扫描非常快，但可以通过在编译时创建静态候选列表来提高大型应用程序的启动性能。在这种模式下，作为组件扫描目标的所有模块都必须使用这种机制。</p>\n<p>当 ApplicationContext检测到这样的索引时，它会自动使用它而不是扫描类路径,这样能提高速度。</p>\n<div><pre><code><span><span><span>&lt;</span>dependencies</span><span>></span></span>\n    <span><span><span>&lt;</span>dependency</span><span>></span></span>\n        <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n        <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-context-indexer<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n        <span><span><span>&lt;</span>version</span><span>></span></span>5.3.22<span><span><span>&lt;/</span>version</span><span>></span></span>\n        <span><span><span>&lt;</span>optional</span><span>></span></span>true<span><span><span>&lt;/</span>optional</span><span>></span></span>\n    <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n<span><span><span>&lt;/</span>dependencies</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>当引用之后,再编译期间生成配置文件。</p>\n<p><img src=\"https://img.springlearn.cn/blog/21fe9b4d82feb3f7e88e2d1bffde298d.png\" alt=\"\" loading=\"lazy\"></p>\n<p>这个的原理,其实就跟lombok类似,使用到的都是 <code>APT</code> 技术,如果感兴趣的话,可以看我这篇文章。</p>\n<p><a href=\"https://springlearn.blog.csdn.net/article/details/126695402\" target=\"_blank\" rel=\"noopener noreferrer\">【lombok原理】无聊的周末一个人手写一个lombok</a></p>\n<p><img src=\"https://img.springlearn.cn/learn_aecfc8e243edb199c726728413b1522c.gif\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>都看到这里了,最后如果这篇文章,对你有所帮助,请点个关注,交个朋友。</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/9e7a3d6be0b037aa72c573cb91fa2e30.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://img.springlearn.cn/blog/b8f74de10af99991e3fc73632eeeb190.png",
      "date_published": "2022-09-04T13:51:11.000Z",
      "date_modified": "2023-02-08T03:23:43.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Spring Framework"
      ]
    },
    {
      "title": "Spring声明式事务的实现方案?",
      "url": "https://java.springlearn.cn/learn/spring/Spring%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/",
      "id": "https://java.springlearn.cn/learn/spring/Spring%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/",
      "content_html": "<div><p>提示</p>\n<p>本篇文章是对Mybatis知识点的一个扩展,主要一起来研究下Spring是如何来管理事务的。顺便再多聊一点其他的知识点,在学习的过程中主要带着以下问题来进行有目的的学习\n然后最终来回答下面这些问题。</p>\n</div>\n<ol>\n<li>Mybatis是如何整合进Spring中的\n<ul>\n<li>Spring如何知道哪些接口是Mapper接口的?</li>\n<li>Mapper接口是如何变成Spring Bean的？</li>\n</ul>\n</li>\n<li>Spring在哪里声明的SqlSession的实现逻辑？</li>\n<li>Spring中声明式事务的实现方式是怎样的？</li>\n<li>Spring中如何处理嵌套事务的？</li>\n<li>Spring中事务的传播方式是如何实现的？</li>\n</ol>\n<p>https://cloud.tencent.com/developer/article/1497631</p>\n<h2 id=\"一、如何整合进spring中的\"> 一、如何整合进Spring中的</h2>\n<p>默认大家对Spring都比较了解了,这里只说结果。都知道接口是不能被实例化的,那么接口是如何成为Bean的呢?</p>\n<h2 id=\"_1-1-如何知道哪些是mybatis的接口呢\"> 1.1 如何知道哪些是Mybatis的接口呢?</h2>\n<ul>\n<li><code>@MapperScan</code> Spring中在配置类上加上这个注解。根据源码能看到还导入了<code>MapperScannerRegistrar</code></li>\n</ul>\n<div><pre><code><span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>\n<span>@Target</span><span>(</span><span>ElementType</span><span>.</span>TYPE<span>)</span>\n<span>@Documented</span>\n<span>@Import</span><span>(</span><span>MapperScannerRegistrar</span><span>.</span><span>class</span><span>)</span>\n<span>@Repeatable</span><span>(</span><span>MapperScans</span><span>.</span><span>class</span><span>)</span>\n<span>public</span> <span>@interface</span> <span>MapperScan</span> <span>{</span><span>}</span>\n\n<span>public</span> <span>class</span> <span>MapperScannerRegistrar</span> <span>implements</span> <span>ImportBeanDefinitionRegistrar</span><span>,</span> <span>ResourceLoaderAware</span> <span>{</span><span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><code>MapperScannerRegistrar</code> 会在配置类解析时候拿到<code>MapperScan</code>注解信息,并解析里面的参数。生成一个 <code>MapperScannerConfigurer</code> 信息。\n从源码中能看到Mybatis的很多配置信息,都会被注入到<code>MapperScannerConfigurer</code>中。</p>\n<p><img src=\"https://img.springlearn.cn/learn_4b3a9611962ebf20587584574ecb05ec.png\" alt=\"img.png\" loading=\"lazy\"></p>\n<div><pre><code><span>public</span> <span>class</span> <span>MapperScannerConfigurer</span>\n    <span>implements</span> <span>BeanDefinitionRegistryPostProcessor</span><span>,</span> <span>InitializingBean</span><span>,</span> <span>ApplicationContextAware</span><span>,</span> <span>BeanNameAware</span> <span>{</span><span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>实现自BeanDefinitionRegistryPostProcessor会前置,拿到MapperScan中的basePackage,最终通过<code>ClassPathMapperScanner</code>扫描并添加到\n<code>BeanDefinitionRegistry</code>中。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1655086500000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>到这里这种方式就能知道哪些是Mybatis中的Mapper接口了。</p>\n<p>还有第二种方式当发现Spring容器中没有<code>MapperScannerConfigurer</code>。会自动注入一个</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1655086934000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>会直接指定哪些类被Mapper修饰,就将他生成Bean。\n<img src=\"https://img.springlearn.cn/blog/learn_1655087073000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>好了，到这里就知道如何来确定那些接口是要生成Mybatis接口的了。下面看下个问题。</p>\n<h2 id=\"_1-2-mapper接口是如何变成spring-bean的\"> 1.2 Mapper接口是如何变成Spring Bean的？</h2>\n<p>接口是不能被实例化的，但是在Spring中如何想让接口实例化就可以使用 <a href=\"/learn/spring/FactoryBean接口实例化/\">FactoryBean</a> + 动态代理的方式，实现接口类的实例化。</p>\n<ul>\n<li>首先利用 ClassPathBeanDefinitionScanner 找到符合规则的类生成 BeanDefinition。</li>\n<li>给 BeanDefinition 指定BeanClass,执行 FactoryBean 是 <code>MapperFactoryBean</code></li>\n</ul>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1655087975000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"二、spring在哪里声明的sqlsession的实现逻辑\"> 二、Spring在哪里声明的SqlSession的实现逻辑？</h2>\n<p>通过Mybatis的学习知道SqlSession一共有2个包装类。SqlSessionManager和SqlSessionTemplate。那么SqlSession是在哪里指定用哪个的呢?\n答案就在 <code>MapperFactoryBean</code></p>\n<div><pre><code><span>public</span> <span>class</span> <span>MapperFactoryBean</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>extends</span> <span>SqlSessionDaoSupport</span> <span>implements</span> <span>FactoryBean</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>{</span>\n  <span>private</span> <span>SqlSessionTemplate</span> sqlSessionTemplate<span>;</span>\n   \n     <span>public</span> <span>void</span> <span>setSqlSessionFactory</span><span>(</span><span>SqlSessionFactory</span> sqlSessionFactory<span>)</span> <span>{</span>\n       <span>if</span> <span>(</span><span>this</span><span>.</span>sqlSessionTemplate <span>==</span> <span>null</span> <span>||</span> sqlSessionFactory <span>!=</span> <span>this</span><span>.</span>sqlSessionTemplate<span>.</span><span>getSqlSessionFactory</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n         <span>this</span><span>.</span>sqlSessionTemplate <span>=</span> <span>createSqlSessionTemplate</span><span>(</span>sqlSessionFactory<span>)</span><span>;</span>\n       <span>}</span>\n     <span>}</span>\n   \n     <span>@SuppressWarnings</span><span>(</span><span>\"WeakerAccess\"</span><span>)</span>\n     <span>protected</span> <span>SqlSessionTemplate</span> <span>createSqlSessionTemplate</span><span>(</span><span>SqlSessionFactory</span> sqlSessionFactory<span>)</span> <span>{</span>\n       <span>return</span> <span>new</span> <span>SqlSessionTemplate</span><span>(</span>sqlSessionFactory<span>)</span><span>;</span>\n     <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h2 id=\"三、spring中声明式事务的实现方式是怎样的\"> 三、Spring中声明式事务的实现方式是怎样的</h2>\n<p>看了Mybatis中事务这一章节,知道如果使用了SqlSessionTemplate,那么事务的权限就外包给了Spring。那么Spring中事务怎么处理的呢?\n终于进入正题了。Spring中提供两种事务的能力。</p>\n<ul>\n<li>声明式事务</li>\n<li>编程式事务</li>\n</ul>\n<h2 id=\"_3-1-声明式事务\"> 3.1 声明式事务</h2>\n<p>使用 <code>Transactional</code> 修饰方法，其主要实现是使用切面实现。</p>\n<ul>\n<li><code>TransactionAspectSupport#invokeWithinTransaction</code>。拦截方法。获取事务管理器。</li>\n</ul>\n<p>这里我们先来思考下,通过前面的学习知道事务的最底层实现是jdbc驱动来实现的。</p>\n<p><img src=\"https://img.springlearn.cn/learn_d3cd2ff5e89f6dbfffff18289043304e.png\" alt=\"\" loading=\"lazy\"></p>\n<p>那么切面中要想实现，就必须保证切面中的线程执行的数据库操作，一定是同一个<code>SqlSession</code>这样才能在方法正常执行时候做commit，异常时候做rollback操作。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1655099097000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>那我们看下他是如何保证切面中的数据库操作一定是同一个SqlSession的吧。这部分逻辑就在 <code>SqlSessionTemplate</code> 中。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1655099774000.png\" alt=\"\" loading=\"lazy\"></p>\n<ul>\n<li>获取当前线程是否已经有SqlSession了，如果有就直接使用，这样就保证在切面中的事务用的是同一个事务了。</li>\n</ul>\n<h2 id=\"_3-2-编程式事务\"> 3.2 编程式事务</h2>\n<ul>\n<li><code>TransactionTemplate#execute</code></li>\n</ul>\n<p>编程是事务需要实现者自己来管理事务的，Spring提供的扩展接口类是 <code>CallbackPreferringPlatformTransactionManager</code>。如果发现容器中默认的事务管理类是这个\n就直接调动全局的这个事务管理方法。如果不是就自己来处理。这种设计的好处是,事务管理器既可以做关系型数据库的事务管理,也可以满足一些特定场景的事务控制(eg: 给Kafka的逻辑做一个事务管理)。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1655100730000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"四、spring中如何处理嵌套事务的\"> 四、Spring中如何处理嵌套事务的？</h2>\n<p>什么是嵌套事务,举一个伪代码的例子。下面 <code>saveUser</code> 代码中有2个Mapper。但是有几个SqlSession呢?</p>\n<div><pre><code><span>UserMapper</span> userMapper<span>;</span>\n\n<span>RegistroyMapper</span> registoryMapper<span>;</span>\n\n<span>@Transactional</span><span>(</span>rollbackFor <span>=</span> <span>{</span><span>Throwable</span><span>.</span><span>class</span><span>,</span> <span>RuntimeException</span><span>.</span><span>class</span><span>,</span> <span>ExecutionException</span><span>.</span><span>class</span><span>}</span><span>)</span>\n<span>public</span> <span>void</span> <span>save</span><span>(</span><span>User</span> user<span>)</span><span>{</span>\n   userMapper<span>.</span><span>save</span><span>(</span>user<span>)</span><span>;</span>\n<span>}</span>\n\n<span>@Transactional</span><span>(</span>rollbackFor <span>=</span> <span>{</span><span>Throwable</span><span>.</span><span>class</span><span>,</span> <span>RuntimeException</span><span>.</span><span>class</span><span>,</span> <span>ExecutionException</span><span>.</span><span>class</span><span>}</span><span>)</span>\n<span>public</span> <span>void</span> <span>saveUser</span><span>(</span><span>String</span> userName<span>,</span><span>Strign</span> password<span>)</span><span>{</span>\n   <span>User</span> user <span>=</span> registoryMapper<span>.</span><span>regis</span><span>(</span>userName<span>,</span>password<span>)</span><span>;</span>\n   <span>save</span><span>(</span>user<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>通过上面的学习我们了解到如果是Spring来管理的事务是一个线程对应一个SqlSession。所以说上面伪代码中的两个Mapper\n其实是用的同一个SqlSession,这样才能保证是在同一个事务中。核心代码逻辑就在这里 <code>SqlSessionUtils#getSqlSession</code>。\n从Spring中的事务管理器中获取 <code>SqlSession</code>。是否使用同一个事务，外包给Spring容器去托管。这就给Spring提供了很多可以发挥的空间。\n比如说传播机制等。</p>\n<div><pre><code><span>public</span> <span>static</span> <span>SqlSession</span> <span>getSqlSession</span><span>(</span><span>SqlSessionFactory</span> sessionFactory<span>,</span> <span>ExecutorType</span> executorType<span>,</span>\n      <span>PersistenceExceptionTranslator</span> exceptionTranslator<span>)</span> <span>{</span>\n\n    <span>notNull</span><span>(</span>sessionFactory<span>,</span> NO_SQL_SESSION_FACTORY_SPECIFIED<span>)</span><span>;</span>\n    <span>notNull</span><span>(</span>executorType<span>,</span> NO_EXECUTOR_TYPE_SPECIFIED<span>)</span><span>;</span>\n\n    <span>SqlSessionHolder</span> holder <span>=</span> <span>(</span><span>SqlSessionHolder</span><span>)</span> <span>TransactionSynchronizationManager</span><span>.</span><span>getResource</span><span>(</span>sessionFactory<span>)</span><span>;</span>\n\n    <span>SqlSession</span> session <span>=</span> <span>sessionHolder</span><span>(</span>executorType<span>,</span> holder<span>)</span><span>;</span>\n    <span>if</span> <span>(</span>session <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n      <span>return</span> session<span>;</span>\n    <span>}</span>\n\n    LOGGER<span>.</span><span>debug</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>\"Creating a new SqlSession\"</span><span>)</span><span>;</span>\n    session <span>=</span> sessionFactory<span>.</span><span>openSession</span><span>(</span>executorType<span>)</span><span>;</span>\n\n    <span>registerSessionHolder</span><span>(</span>sessionFactory<span>,</span> executorType<span>,</span> exceptionTranslator<span>,</span> session<span>)</span><span>;</span>\n\n    <span>return</span> session<span>;</span>\n  <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h2 id=\"五、spring中事务的传播方式是如何实现的\"> 五、Spring中事务的传播方式是如何实现的？</h2>\n<table>\n<thead>\n<tr>\n<th>传播方式</th>\n<th>说明</th>\n<th>常用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>TransactionDefinition.PROPAGATION_REQUIRED</td>\n<td>如果存在一个事务，则支持当前事务。如果没有事务则开启</td>\n<td>✅</td>\n</tr>\n<tr>\n<td>TransactionDefinition.PROPAGATION_SUPPORTS</td>\n<td>如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行</td>\n<td></td>\n</tr>\n<tr>\n<td>TransactionDefinition.PROPAGATION_MANDATORY</td>\n<td>如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常</td>\n<td></td>\n</tr>\n<tr>\n<td>TransactionDefinition.PROPAGATION_NEVER</td>\n<td>总是非事务地执行，如果存在一个活动事务，则抛出异常</td>\n<td></td>\n</tr>\n<tr>\n<td>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</td>\n<td>总是非事务地执行，并挂起任何存在的事务</td>\n<td></td>\n</tr>\n<tr>\n<td>TransactionDefinition.PROPAGATION_REQUIRES_NEW</td>\n<td>总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起。</td>\n<td></td>\n</tr>\n<tr>\n<td>TransactionDefinition.PROPAGATION_NESTED</td>\n<td>如果一个活动的事务存在，则运行在一个嵌套的事务中. 如果没有活动事务则按TransactionDefinition.PROPAGATION_REQUIRED 属性执行</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p><strong>思考传播机制如何实现</strong></p>\n<p>首先我们先思考下传播机制是如何实现的,因为我们知道 <code>要保证是同一个事务,那么一定是同一个SqlSession,这样才能保证是同一个事务</code>。\n而如果要新开事务,就要先将当前线程绑定的SqlSession等事务信息,给挂起，那么是如何进行挂起的呢? SqlSession又是如何跟线程绑定的呢?</p>\n<h2 id=\"_5-1-sqlsession是如何跟线程绑定的呢\"> 5.1 SqlSession是如何跟线程绑定的呢?</h2>\n<p>通过TransactionSynchronizationManager中的ThreadLocal跟线程绑定<code>(new NamedThreadLocal&lt;&gt;(&quot;Transactional resources&quot;))</code>。注意: 如果主线程下创建子线程是不能绑定上的。</p>\n<div><pre><code><span>private</span> <span>static</span> <span>void</span> <span>registerSessionHolder</span><span>(</span><span>SqlSessionFactory</span> sessionFactory<span>,</span> <span>ExecutorType</span> executorType<span>,</span>\n      <span>PersistenceExceptionTranslator</span> exceptionTranslator<span>,</span> <span>SqlSession</span> session<span>)</span> <span>{</span>\n        <span>SqlSessionHolder</span> holder <span>=</span> <span>new</span> <span>SqlSessionHolder</span><span>(</span>session<span>,</span> executorType<span>,</span> exceptionTranslator<span>)</span><span>;</span>\n        <span>TransactionSynchronizationManager</span><span>.</span><span>bindResource</span><span>(</span>sessionFactory<span>,</span> holder<span>)</span><span>;</span>\n        <span>TransactionSynchronizationManager</span>\n            <span>.</span><span>registerSynchronization</span><span>(</span><span>new</span> <span>SqlSessionSynchronization</span><span>(</span>holder<span>,</span> sessionFactory<span>)</span><span>)</span><span>;</span>\n        holder<span>.</span><span>setSynchronizedWithTransaction</span><span>(</span><span>true</span><span>)</span><span>;</span>\n        holder<span>.</span><span>requested</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id=\"_5-2-事务是如何嵌套的\"> 5.2 事务是如何嵌套的?</h2>\n<p>答案就在 <code>TransactionAspectSupport#TransactionInfo</code> 中。一个事务注解对应一个TransactionInfo,如果出现嵌套\n就会生成一个事务链。如下图一样。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1655110242000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>当里层的事务处理完成后会执行清理动作,同时在将第一个的事务在进行恢复跟线程绑定。</p>\n<div><pre><code>        <span>private</span> <span>void</span> <span>restoreThreadLocalStatus</span><span>(</span><span>)</span> <span>{</span>\n\t\t\t<span>// Use stack to restore old transaction TransactionInfo.</span>\n\t\t\t<span>// Will be null if none was set.</span>\n\t\t\ttransactionInfoHolder<span>.</span><span>set</span><span>(</span><span>this</span><span>.</span>oldTransactionInfo<span>)</span><span>;</span>\n\t\t<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"_5-3-事务是如何挂起的\"> 5.3 事务是如何挂起的?</h2>\n<p>前面知道每一个 <code>@Transaction</code> 注解会对应一个 <code>TransactionAspectSupport#TransactionInfo</code>。而事务挂起后,会先跟线程进行解绑。\n然后挂起的事务 <code>SuspendedResourcesHolder</code> 会被添加在 <code>TransactionStatus</code> 中。</p>\n<p><strong>挂起的数据保存在哪里</strong></p>\n<div><pre><code><span>protected</span> <span>final</span> <span>class</span> <span>TransactionInfo</span> <span>{</span>\n        <span>// 事务管理器</span>\n\t\t<span>@Nullable</span>\n\t\t<span>private</span> <span>final</span> <span>PlatformTransactionManager</span> transactionManager<span>;</span>\n        <span>// 事务信息</span>\n\t\t<span>@Nullable</span>\n\t\t<span>private</span> <span>final</span> <span>TransactionAttribute</span> transactionAttribute<span>;</span>\n        <span>// 切面点</span>\n\t\t<span>private</span> <span>final</span> <span>String</span> joinpointIdentification<span>;</span>\n\t\t<span>// DefaultTransactionStatus</span>\n\t\t<span>@Nullable</span>\n\t\t<span>private</span> <span>TransactionStatus</span> transactionStatus<span>;</span> \n\t\t<span>@Nullable</span>\n\t\t<span>private</span> <span>TransactionInfo</span> oldTransactionInfo<span>;</span>\n<span>}</span>\n\n<span>public</span> <span>class</span> <span>DefaultTransactionStatus</span> <span>extends</span> <span>AbstractTransactionStatus</span> <span>{</span>\n\t<span>@Nullable</span>\n\t<span>private</span> <span>final</span> <span>Object</span> transaction<span>;</span>\n\t<span>private</span> <span>final</span> <span>boolean</span> newTransaction<span>;</span>\n\t<span>private</span> <span>final</span> <span>boolean</span> newSynchronization<span>;</span>\n\t<span>private</span> <span>final</span> <span>boolean</span> readOnly<span>;</span>\n\t<span>private</span> <span>final</span> <span>boolean</span> debug<span>;</span>\n\t<span>@Nullable</span>\n\t<span>private</span> <span>final</span> <span>Object</span> suspendedResources<span>;</span>\n<span>}</span>\t\t\t\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p><strong>如何进行挂起的</strong></p>\n<p>TransactionSynchronization 事务同步器，为了解决事务的传播方式</p>\n<ul>\n<li>suspend 暂定事务,将事务从当前线程上解绑</li>\n<li>resume  恢复事务,将事务从新恢复到当前线程上</li>\n<li>beforeCommit 触发提交事务，执行commit</li>\n<li>beforeCompletion 事务提交后</li>\n<li>afterCommit 提交后</li>\n<li>afterCompletion 完成后调用</li>\n</ul>\n<p>SqlSessionSynchronization 也是跟当前线程绑定的</p>\n<ul>\n<li>位置 <code>TransactionSynchronizationManager#ThreadLocal&lt;Set&lt;TransactionSynchronization&gt;&gt; synchronizations</code></li>\n</ul>\n<div><pre><code> <span>// 挂起时候,将SqlSessionHolder与当前线程进行解绑</span>\n <span>@Override</span>\n <span>public</span> <span>void</span> <span>suspend</span><span>(</span><span>)</span> <span>{</span>\n   <span>if</span> <span>(</span><span>this</span><span>.</span>holderActive<span>)</span> <span>{</span>\n     LOGGER<span>.</span><span>debug</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>\"Transaction synchronization suspending SqlSession [\"</span> <span>+</span> <span>this</span><span>.</span>holder<span>.</span><span>getSqlSession</span><span>(</span><span>)</span> <span>+</span> <span>\"]\"</span><span>)</span><span>;</span>\n     <span>TransactionSynchronizationManager</span><span>.</span><span>unbindResource</span><span>(</span><span>this</span><span>.</span>sessionFactory<span>)</span><span>;</span>\n   <span>}</span>\n <span>}</span>\n\n <span>/**\n  * 恢复时候重新跟当前线程绑定\n  */</span>\n <span>@Override</span>\n <span>public</span> <span>void</span> <span>resume</span><span>(</span><span>)</span> <span>{</span>\n   <span>if</span> <span>(</span><span>this</span><span>.</span>holderActive<span>)</span> <span>{</span>\n     LOGGER<span>.</span><span>debug</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>\"Transaction synchronization resuming SqlSession [\"</span> <span>+</span> <span>this</span><span>.</span>holder<span>.</span><span>getSqlSession</span><span>(</span><span>)</span> <span>+</span> <span>\"]\"</span><span>)</span><span>;</span>\n     <span>TransactionSynchronizationManager</span><span>.</span><span>bindResource</span><span>(</span><span>this</span><span>.</span>sessionFactory<span>,</span> <span>this</span><span>.</span>holder<span>)</span><span>;</span>\n   <span>}</span>\n <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h2 id=\"_5-4-传播方式具体实现\"> 5.4 传播方式具体实现</h2>\n<p>下面这段代码就是事务注解的切面处理类，Spring事务的所有逻辑和扩展支持都在这里。</p>\n<ul>\n<li><code>TransactionAspectSupport#invokeWithinTransaction</code></li>\n</ul>\n<p><strong>首先我们先看整体的逻辑</strong></p>\n<ol>\n<li>获取当切面上的 <code>@Transaction</code> 注解信息</li>\n<li>根据注解信息找到指定的事务管理器,如果没有执行就使用默认的</li>\n<li>生成事务信息 <code>TransactionInfo</code> 传播机制,事务挂起都在这个类上</li>\n<li>失败执行回滚&amp;成功提交&amp;如果是嵌套事务,从<code>TransactionInfo</code> 中将挂起的事务重新跟线程进行绑定</li>\n</ol>\n<div><div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><div>&nbsp;</div><br><div>&nbsp;</div><br><br><br></div><pre><code><span>protected</span> <span>Object</span> <span>invokeWithinTransaction</span><span>(</span><span>Method</span> method<span>,</span> <span>@Nullable</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> targetClass<span>,</span>\n\t\t\t<span>final</span> <span>InvocationCallback</span> invocation<span>)</span> <span>throws</span> <span>Throwable</span> <span>{</span>\n\n\t\t<span>// If the transaction attribute is null, the method is non-transactional.</span>\n\t\t<span>TransactionAttributeSource</span> tas <span>=</span> <span>getTransactionAttributeSource</span><span>(</span><span>)</span><span>;</span>\n\t\t<span>// 获取被事务注解标记的事务信息</span>\n\t\t<span>final</span> <span>TransactionAttribute</span> txAttr <span>=</span> <span>(</span>tas <span>!=</span> <span>null</span> <span>?</span> tas<span>.</span><span>getTransactionAttribute</span><span>(</span>method<span>,</span> targetClass<span>)</span> <span>:</span> <span>null</span><span>)</span><span>;</span>\n\t\t<span>// 根据事务注解上指定的事务管理器名称,去系统中获取，如果没有就拿系统中默认的事务管理器</span>\n\t\t<span>final</span> <span>PlatformTransactionManager</span> tm <span>=</span> <span>determineTransactionManager</span><span>(</span>txAttr<span>)</span><span>;</span>\n\t\t<span>// 切面拦截点: com.alibaba.purchase.domain.replenish.impl.ReplenishDomainWriteServiceImpl.mockSave</span>\n\t\t<span>final</span> <span>String</span> joinpointIdentification <span>=</span> <span>methodIdentification</span><span>(</span>method<span>,</span> targetClass<span>,</span> txAttr<span>)</span><span>;</span>\n        <span>// 这里只看关系型数据的的事务逻辑。CallbackPreferringPlatformTransactionManager是具有回调性质的事务管理器,多用于处理自定的事务</span>\n\t\t<span>if</span> <span>(</span>txAttr <span>==</span> <span>null</span> <span>||</span> <span>!</span><span>(</span>tm <span>instanceof</span> <span>CallbackPreferringPlatformTransactionManager</span><span>)</span><span>)</span> <span>{</span>\n\t\t\t<span>// Standard transaction demarcation with getTransaction and commit/rollback calls.</span>\n\t\t\t<span>// 获取事务的信息,包含传播方式</span>\n\t\t\t<span>TransactionInfo</span> txInfo <span>=</span> <span>createTransactionIfNecessary</span><span>(</span>tm<span>,</span> txAttr<span>,</span> joinpointIdentification<span>)</span><span>;</span>\n\t\t\t<span>Object</span> retVal <span>=</span> <span>null</span><span>;</span>\n\t\t\t<span>try</span> <span>{</span>\n\t\t\t\t<span>// This is an around advice: Invoke the next interceptor in the chain.</span>\n\t\t\t\t<span>// This will normally result in a target object being invoked.</span>\n\t\t\t\tretVal <span>=</span> invocation<span>.</span><span>proceedWithInvocation</span><span>(</span><span>)</span><span>;</span>\n\t\t\t<span>}</span>\n\t\t\t<span>catch</span> <span>(</span><span>Throwable</span> ex<span>)</span> <span>{</span>\n\t\t\t\t<span>// target invocation exception</span>\n\t\t\t\t<span>completeTransactionAfterThrowing</span><span>(</span>txInfo<span>,</span> ex<span>)</span><span>;</span>\n\t\t\t\t<span>throw</span> ex<span>;</span>\n\t\t\t<span>}</span>\n\t\t\t<span>finally</span> <span>{</span>\n\t\t\t\t<span>cleanupTransactionInfo</span><span>(</span>txInfo<span>)</span><span>;</span>\n\t\t\t<span>}</span>\n\t\t\t<span>commitTransactionAfterReturning</span><span>(</span>txInfo<span>)</span><span>;</span>\n\t\t\t<span>return</span> retVal<span>;</span>\n\t\t<span>}</span>\n<span>}</span>\t\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><p><strong>这里只看传播机制吧。AbstractPlatformTransactionManager#handleExistingTransaction</strong></p>\n<ul>\n<li>TransactionDefinition.PROPAGATION_NEVER 如果存在事务就报错</li>\n<li>TransactionDefinition.PROPAGATION_NOT_SUPPORTED 如果有事务,就挂起(当前事务跟线程解绑)。不使用事务进行执行。</li>\n<li>TransactionDefinition.PROPAGATION_REQUIRES_NEW 当前事务挂起,新开个事务。</li>\n</ul>\n<div><pre><code>     <span>/**\n\t * Create a TransactionStatus for an existing transaction.\n\t */</span>\n\t<span>private</span> <span>TransactionStatus</span> <span>handleExistingTransaction</span><span>(</span>\n\t\t\t<span>TransactionDefinition</span> definition<span>,</span> <span>Object</span> transaction<span>,</span> <span>boolean</span> debugEnabled<span>)</span>\n\t\t\t<span>throws</span> <span>TransactionException</span> <span>{</span>\n        <span>// TransactionDefinition.PROPAGATION_NEVER（总是非事务地执行，如果存在一个活动事务，则抛出异常）就直接阻断报错</span>\n\t\t<span>if</span> <span>(</span>definition<span>.</span><span>getPropagationBehavior</span><span>(</span><span>)</span> <span>==</span> <span>TransactionDefinition</span><span>.</span>PROPAGATION_NEVER<span>)</span> <span>{</span>\n\t\t\t<span>throw</span> <span>new</span> <span>IllegalTransactionStateException</span><span>(</span>\n\t\t\t\t\t<span>\"Existing transaction found for transaction marked with propagation 'never'\"</span><span>)</span><span>;</span>\n\t\t<span>}</span>\n        <span>// TransactionDefinition.PROPAGATION_NOT_SUPPORTED 总是非事务地执行，并挂起任何存在的事务</span>\n\t\t<span>if</span> <span>(</span>definition<span>.</span><span>getPropagationBehavior</span><span>(</span><span>)</span> <span>==</span> <span>TransactionDefinition</span><span>.</span>PROPAGATION_NOT_SUPPORTED<span>)</span> <span>{</span>\n\t\t\t<span>if</span> <span>(</span>debugEnabled<span>)</span> <span>{</span>\n\t\t\t\tlogger<span>.</span><span>debug</span><span>(</span><span>\"Suspending current transaction\"</span><span>)</span><span>;</span>\n\t\t\t<span>}</span>\n\t\t\t<span>Object</span> suspendedResources <span>=</span> <span>suspend</span><span>(</span>transaction<span>)</span><span>;</span>\n\t\t\t<span>boolean</span> newSynchronization <span>=</span> <span>(</span><span>getTransactionSynchronization</span><span>(</span><span>)</span> <span>==</span> SYNCHRONIZATION_ALWAYS<span>)</span><span>;</span>\n\t\t\t<span>// 数据暂存在TransactionSynchronizationManager#synchronizations同步器中</span>\n\t\t\t<span>return</span> <span>prepareTransactionStatus</span><span>(</span>\n\t\t\t\t\tdefinition<span>,</span> <span>null</span><span>,</span> <span>false</span><span>,</span> newSynchronization<span>,</span> debugEnabled<span>,</span> suspendedResources<span>)</span><span>;</span>\n\t\t<span>}</span>\n        <span>// 总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起。</span>\n\t\t<span>if</span> <span>(</span>definition<span>.</span><span>getPropagationBehavior</span><span>(</span><span>)</span> <span>==</span> <span>TransactionDefinition</span><span>.</span>PROPAGATION_REQUIRES_NEW<span>)</span> <span>{</span>\n\t\t\t<span>if</span> <span>(</span>debugEnabled<span>)</span> <span>{</span>\n\t\t\t\tlogger<span>.</span><span>debug</span><span>(</span><span>\"Suspending current transaction, creating new transaction with name [\"</span> <span>+</span>\n\t\t\t\t\t\tdefinition<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\"]\"</span><span>)</span><span>;</span>\n\t\t\t<span>}</span>\n\t\t\t<span>SuspendedResourcesHolder</span> suspendedResources <span>=</span> <span>suspend</span><span>(</span>transaction<span>)</span><span>;</span>\n\t\t\t<span>try</span> <span>{</span>\n\t\t\t\t<span>boolean</span> newSynchronization <span>=</span> <span>(</span><span>getTransactionSynchronization</span><span>(</span><span>)</span> <span>!=</span> SYNCHRONIZATION_NEVER<span>)</span><span>;</span>\n\t\t\t\t<span>DefaultTransactionStatus</span> status <span>=</span> <span>newTransactionStatus</span><span>(</span>\n\t\t\t\t\t\tdefinition<span>,</span> transaction<span>,</span> <span>true</span><span>,</span> newSynchronization<span>,</span> debugEnabled<span>,</span> suspendedResources<span>)</span><span>;</span>\n\t\t\t\t<span>doBegin</span><span>(</span>transaction<span>,</span> definition<span>)</span><span>;</span>\n\t\t\t\t<span>prepareSynchronization</span><span>(</span>status<span>,</span> definition<span>)</span><span>;</span>\n\t\t\t\t<span>return</span> status<span>;</span>\n\t\t\t<span>}</span>\n\t\t\t<span>catch</span> <span>(</span><span>RuntimeException</span> <span>|</span> <span>Error</span> beginEx<span>)</span> <span>{</span>\n\t\t\t\t<span>resumeAfterBeginException</span><span>(</span>transaction<span>,</span> suspendedResources<span>,</span> beginEx<span>)</span><span>;</span>\n\t\t\t\t<span>throw</span> beginEx<span>;</span>\n\t\t\t<span>}</span>\n\t\t<span>}</span>\n        <span>// 如果有事务存在，则运行在一个嵌套的事务中. 如果没有活动事务则按TransactionDefinition.PROPAGATION_REQUIRED 属性执行</span>\n\t\t<span>if</span> <span>(</span>definition<span>.</span><span>getPropagationBehavior</span><span>(</span><span>)</span> <span>==</span> <span>TransactionDefinition</span><span>.</span>PROPAGATION_NESTED<span>)</span> <span>{</span>\n\t\t\t<span>if</span> <span>(</span><span>!</span><span>isNestedTransactionAllowed</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n\t\t\t\t<span>throw</span> <span>new</span> <span>NestedTransactionNotSupportedException</span><span>(</span>\n\t\t\t\t\t\t<span>\"Transaction manager does not allow nested transactions by default - \"</span> <span>+</span>\n\t\t\t\t\t\t<span>\"specify 'nestedTransactionAllowed' property with value 'true'\"</span><span>)</span><span>;</span>\n\t\t\t<span>}</span>\n\t\t\t<span>if</span> <span>(</span>debugEnabled<span>)</span> <span>{</span>\n\t\t\t\tlogger<span>.</span><span>debug</span><span>(</span><span>\"Creating nested transaction with name [\"</span> <span>+</span> definition<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\"]\"</span><span>)</span><span>;</span>\n\t\t\t<span>}</span>\n\t\t\t<span>if</span> <span>(</span><span>useSavepointForNestedTransaction</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n\t\t\t\t<span>// Create savepoint within existing Spring-managed transaction,</span>\n\t\t\t\t<span>// through the SavepointManager API implemented by TransactionStatus.</span>\n\t\t\t\t<span>// Usually uses JDBC 3.0 savepoints. Never activates Spring synchronization.</span>\n\t\t\t\t<span>DefaultTransactionStatus</span> status <span>=</span>\n\t\t\t\t\t\t<span>prepareTransactionStatus</span><span>(</span>definition<span>,</span> transaction<span>,</span> <span>false</span><span>,</span> <span>false</span><span>,</span> debugEnabled<span>,</span> <span>null</span><span>)</span><span>;</span>\n\t\t\t\t<span>// 使用当前事务,并增加当前事务的一次引用。\t\t</span>\n\t\t\t\tstatus<span>.</span><span>createAndHoldSavepoint</span><span>(</span><span>)</span><span>;</span>\n\t\t\t\t<span>return</span> status<span>;</span>\n\t\t\t<span>}</span>\n\t\t\t<span>else</span> <span>{</span>\n\t\t\t\t<span>// Nested transaction through nested begin and commit/rollback calls.</span>\n\t\t\t\t<span>// Usually only for JTA: Spring synchronization might get activated here</span>\n\t\t\t\t<span>// in case of a pre-existing JTA transaction.</span>\n\t\t\t\t<span>// 没有新建一个事务</span>\n\t\t\t\t<span>boolean</span> newSynchronization <span>=</span> <span>(</span><span>getTransactionSynchronization</span><span>(</span><span>)</span> <span>!=</span> SYNCHRONIZATION_NEVER<span>)</span><span>;</span>\n\t\t\t\t<span>DefaultTransactionStatus</span> status <span>=</span> <span>newTransactionStatus</span><span>(</span>\n\t\t\t\t\t\tdefinition<span>,</span> transaction<span>,</span> <span>true</span><span>,</span> newSynchronization<span>,</span> debugEnabled<span>,</span> <span>null</span><span>)</span><span>;</span>\n\t\t\t\t<span>doBegin</span><span>(</span>transaction<span>,</span> definition<span>)</span><span>;</span>\n\t\t\t\t<span>prepareSynchronization</span><span>(</span>status<span>,</span> definition<span>)</span><span>;</span>\n\t\t\t\t<span>return</span> status<span>;</span>\n\t\t\t<span>}</span>\n\t\t<span>}</span>\n\n\t\t<span>// Assumably PROPAGATION_SUPPORTS or PROPAGATION_REQUIRED.</span>\n\t\t<span>if</span> <span>(</span>debugEnabled<span>)</span> <span>{</span>\n\t\t\tlogger<span>.</span><span>debug</span><span>(</span><span>\"Participating in existing transaction\"</span><span>)</span><span>;</span>\n\t\t<span>}</span>\n\t\t<span>if</span> <span>(</span><span>isValidateExistingTransaction</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n\t\t\t<span>if</span> <span>(</span>definition<span>.</span><span>getIsolationLevel</span><span>(</span><span>)</span> <span>!=</span> <span>TransactionDefinition</span><span>.</span>ISOLATION_DEFAULT<span>)</span> <span>{</span>\n\t\t\t\t<span>Integer</span> currentIsolationLevel <span>=</span> <span>TransactionSynchronizationManager</span><span>.</span><span>getCurrentTransactionIsolationLevel</span><span>(</span><span>)</span><span>;</span>\n\t\t\t\t<span>if</span> <span>(</span>currentIsolationLevel <span>==</span> <span>null</span> <span>||</span> currentIsolationLevel <span>!=</span> definition<span>.</span><span>getIsolationLevel</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n\t\t\t\t\t<span>Constants</span> isoConstants <span>=</span> <span>DefaultTransactionDefinition</span><span>.</span>constants<span>;</span>\n\t\t\t\t\t<span>throw</span> <span>new</span> <span>IllegalTransactionStateException</span><span>(</span><span>\"Participating transaction with definition [\"</span> <span>+</span>\n\t\t\t\t\t\t\tdefinition <span>+</span> <span>\"] specifies isolation level which is incompatible with existing transaction: \"</span> <span>+</span>\n\t\t\t\t\t\t\t<span>(</span>currentIsolationLevel <span>!=</span> <span>null</span> <span>?</span>\n\t\t\t\t\t\t\t\t\tisoConstants<span>.</span><span>toCode</span><span>(</span>currentIsolationLevel<span>,</span> <span>DefaultTransactionDefinition</span><span>.</span>PREFIX_ISOLATION<span>)</span> <span>:</span>\n\t\t\t\t\t\t\t\t\t<span>\"(unknown)\"</span><span>)</span><span>)</span><span>;</span>\n\t\t\t\t<span>}</span>\n\t\t\t<span>}</span>\n\t\t\t<span>if</span> <span>(</span><span>!</span>definition<span>.</span><span>isReadOnly</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n\t\t\t\t<span>if</span> <span>(</span><span>TransactionSynchronizationManager</span><span>.</span><span>isCurrentTransactionReadOnly</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n\t\t\t\t\t<span>throw</span> <span>new</span> <span>IllegalTransactionStateException</span><span>(</span><span>\"Participating transaction with definition [\"</span> <span>+</span>\n\t\t\t\t\t\t\tdefinition <span>+</span> <span>\"] is not marked as read-only but existing transaction is\"</span><span>)</span><span>;</span>\n\t\t\t\t<span>}</span>\n\t\t\t<span>}</span>\n\t\t<span>}</span>\n\t\t<span>// </span>\n\t\t<span>boolean</span> newSynchronization <span>=</span> <span>(</span><span>getTransactionSynchronization</span><span>(</span><span>)</span> <span>!=</span> SYNCHRONIZATION_NEVER<span>)</span><span>;</span>\n\t\t<span>return</span> <span>prepareTransactionStatus</span><span>(</span>definition<span>,</span> transaction<span>,</span> <span>false</span><span>,</span> newSynchronization<span>,</span> debugEnabled<span>,</span> <span>null</span><span>)</span><span>;</span>\n\t<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br></div></div><h2 id=\"_5-5-嵌套事务如何知道是否要提交\"> 5.5 嵌套事务如何知道是否要提交</h2>\n<p>当两个Mapper中使用的是同一个SqlSession,那么会不会第二个事务在执行后,就直接commit了呢,此时第一个事务有一次commit。导致异常呢?</p>\n<p>解决方案在这里 <code>DefaultTransactionStatus</code></p>\n<p>第二个事务状态中</p>\n<ul>\n<li>newTransaction = false</li>\n<li>newSynchronization = false\n<img src=\"https://img.springlearn.cn/blog/learn_1655202764000.png\" alt=\"\" loading=\"lazy\"></li>\n</ul>\n<p>而下面代码中会做校验,只需要同步时候才会提交事务。</p>\n<div><pre><code><span>protected</span> <span>final</span> <span>void</span> <span>triggerBeforeCommit</span><span>(</span><span>DefaultTransactionStatus</span> status<span>)</span> <span>{</span>\n\t\t<span>if</span> <span>(</span>status<span>.</span><span>isNewSynchronization</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n\t\t\t<span>if</span> <span>(</span>status<span>.</span><span>isDebug</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n\t\t\t\tlogger<span>.</span><span>trace</span><span>(</span><span>\"Triggering beforeCommit synchronization\"</span><span>)</span><span>;</span>\n\t\t\t<span>}</span>\n\t\t\t<span>TransactionSynchronizationUtils</span><span>.</span><span>triggerBeforeCommit</span><span>(</span>status<span>.</span><span>isReadOnly</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\t\t<span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>第一个事务状态中</p>\n<ul>\n<li>newTransaction = true</li>\n<li>newSynchronization = true\n才会真正的去执行。\n<img src=\"https://img.springlearn.cn/blog/learn_1655203089000.png\" alt=\"\" loading=\"lazy\"></li>\n</ul>\n<h2 id=\"_5-6-这样设计是否线程安全\"> 5.6 这样设计是否线程安全</h2>\n<p>线程安全只有在多线程环境下才会出现。那么这里一定会有多线程问题。而事务是跟线程进行绑定的,所以这里虽然有多线程但是不会有线程安全问题。</p>\n<p>但是这里我们看源码线程绑定时候使用的ThreadLocal,所以你在线程中创建子线程或者是线程中使用线程池,这里的事务都不会共享的。</p>\n",
      "image": "https://img.springlearn.cn/learn_4b3a9611962ebf20587584574ecb05ec.png",
      "date_published": "2022-06-16T13:10:16.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "SpringBoot"
      ]
    },
    {
      "title": "第02篇:解耦就用Event",
      "url": "https://java.springlearn.cn/learn/spring/core02/",
      "id": "https://java.springlearn.cn/learn/spring/core02/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/b8f74de10af99991e3fc73632eeeb190.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>公众号</strong>: 西魏陶渊明<br/>\n<strong>CSDN</strong>: <a href=\"https://springlearn.blog.csdn.net/?type=blog\" target=\"_blank\" rel=\"noopener noreferrer\">https://springlearn.blog.csdn.net</a><br/></p>\n<blockquote>\n<p>天下代码一大抄, 抄来抄去有提高, 看你会抄不会抄！</p>\n</blockquote>\n<p><img src=\"https://img.springlearn.cn/blog/8f3392b9badb093f9e1a6472b4a98487.gif\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"一、前言\"> 一、前言</h2>\n<p>消息常用做解耦,这句话这样讲,可能大家没有什么体感。下面我们举一个实际开发中的例子,可能会更加帮助大家来理解。现在我们有这么一个系统。用户登录系统, 来完成产品下面给我们提的需求任务。通过完成任务的形式,来发现问题,最后再来解决问题。</p>\n<h2 id=\"_1-1-自动签到\"> 1.1 自动签到</h2>\n<p>有一天,产品提了一个需求。在用户登录时候,要帮用户自动签到。于是我们代码这样写。</p>\n<div><pre><code><span>public</span> <span>boolean</span> <span>login</span><span>(</span><span>String</span> userId<span>,</span><span>String</span> password<span>)</span><span>{</span>\n  <span>// 登录成功处理逻辑</span>\n  <span>if</span><span>(</span><span>doLogin</span><span>(</span>userId<span>,</span>password<span>)</span><span>)</span><span>{</span>\n    <span>// 用户签到</span>\n    <span>this</span><span>.</span><span>userSign</span><span>(</span>userId<span>)</span><span>;</span>\n    <span>return</span> ture<span>;</span>\n  <span>}</span><span>else</span><span>{</span>\n    <span>return</span> <span>false</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id=\"_1-2-满七天赠送金币\"> 1.2 满七天赠送金币</h2>\n<p><img src=\"https://img.springlearn.cn/blog/bda67cac5aaf2b523d84529b5b66e0a3.png\" alt=\"\" loading=\"lazy\"></p>\n<p>后来为了提高用户对APP的粘性,产品提了一个需求,当用户连续登录7天,可以增送金币。</p>\n<p>ps: 这样看起来代码还行,但是需要知道的是,这只是伪代码,实际可能非常复杂。</p>\n<div><pre><code><span>public</span> <span>boolean</span> <span>login</span><span>(</span><span>String</span> userId<span>,</span><span>String</span> password<span>)</span><span>{</span>\n  <span>// 登录成功处理逻辑</span>\n  <span>if</span><span>(</span><span>doLogin</span><span>(</span>userId<span>,</span>password<span>)</span><span>)</span><span>{</span>\n    <span>// 用户签到</span>\n    <span>this</span><span>.</span><span>userSign</span><span>(</span>userId<span>)</span><span>;</span>\n    <span>// 查询用户登录次数</span>\n    <span>int</span> signCount <span>=</span> <span>queryUserSignCount</span><span>(</span>userId<span>)</span><span>;</span>\n    <span>// 连续登录7天,赠送7个金币</span>\n    <span>if</span><span>(</span>signCount <span>>=</span> <span>7</span><span>)</span><span>{</span>\n       <span>sendGiftToUser</span><span>(</span>userId<span>,</span><span>7L</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>return</span> ture<span>;</span>\n  <span>}</span><span>else</span><span>{</span>\n    <span>return</span> <span>false</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id=\"_1-3-自动领取徽章\"> 1.3 自动领取徽章</h2>\n<p>后台有一天产品又说,当用户连续登录了14天,自动领取徽章。哎这个怎么有点像CSDN呢?</p>\n<p><img src=\"https://img.springlearn.cn/blog/525752144d5e3fe54c375a6ac355e9c4.png\" alt=\"\" loading=\"lazy\"></p>\n<p>soga...</p>\n<div><pre><code><span>public</span> <span>boolean</span> <span>login</span><span>(</span><span>String</span> userId<span>,</span><span>String</span> password<span>)</span><span>{</span>\n  <span>// 登录成功处理逻辑</span>\n  <span>if</span><span>(</span><span>doLogin</span><span>(</span>userId<span>,</span>password<span>)</span><span>)</span><span>{</span>\n    <span>// 用户签到</span>\n    <span>this</span><span>.</span><span>userSign</span><span>(</span>userId<span>)</span><span>;</span>\n    <span>// 查询用户登录次数</span>\n    <span>int</span> signCount <span>=</span> <span>queryUserSignCount</span><span>(</span>userId<span>)</span><span>;</span>\n    <span>// 连续登录7天,赠送7个金币</span>\n    <span>if</span><span>(</span>signCount <span>>=</span> <span>7</span><span>)</span><span>{</span>\n       <span>sendGiftToUser</span><span>(</span>userId<span>,</span><span>7L</span><span>)</span><span>;</span>\n    <span>}</span><span>else</span> <span>if</span><span>(</span>signCount <span>>=</span> <span>14</span><span>)</span><span>{</span>\n       <span>// 连续登录14天,自动发放徽章</span>\n       <span>sendBadgeToUser</span><span>(</span>userId<span>)</span><span>;</span>\n    <span>}</span>\n    <span>return</span> ture<span>;</span>\n  <span>}</span><span>else</span><span>{</span>\n    <span>return</span> <span>false</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>这里我们思考一下,我们明明是一个用户登录系统,为什么还要给用户发礼品,关心用户签到? 这不是应该是\n营销团队关心的事情吗? login就是一个登录方法,为什么代码越写越多了? 于是乎我们开始进行第一次解耦了。将签到和赠送礼品的逻辑都拆解出营销的模块。</p>\n<h2 id=\"_1-4-营销业务解耦\"> 1.4 营销业务解耦</h2>\n<p>将原本属于用户营销的业务解耦到一个模块或者是拆解出微服务。于是乎代码就是这样,\n以后再有用户营销的业务,终于不用写在用户登录的方法里面了。login(...)。应该能坚持几个月了吧。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>UserMarketingService</span><span>{</span>\n\n    <span>public</span> <span>void</span> <span>userMarketing</span><span>(</span><span>String</span> userId<span>)</span><span>{</span>\n      <span>// 用户签到</span>\n      <span>this</span><span>.</span><span>userSign</span><span>(</span>userId<span>,</span>password<span>)</span><span>;</span>\n      <span>// 查询用户登录次数</span>\n      <span>int</span> signCount <span>=</span> <span>queryUserSignCount</span><span>(</span>userId<span>)</span><span>;</span>\n      <span>// 连续登录7天,赠送7个金币</span>\n      <span>if</span><span>(</span>signCount <span>>=</span> <span>7</span><span>)</span><span>{</span>\n         <span>sendGiftToUser</span><span>(</span>userId<span>,</span><span>7L</span><span>)</span><span>;</span>\n      <span>}</span><span>else</span> <span>if</span><span>(</span>signCount <span>>=</span> <span>14</span><span>)</span><span>{</span>\n         <span>// 连续登录14天,自动发放徽章</span>\n         <span>sendBadgeToUser</span><span>(</span>userId<span>)</span><span>;</span>\n      <span>}</span>\n    <span>}</span>\n<span>}</span>\n\n<span>public</span> <span>boolean</span> <span>login</span><span>(</span><span>String</span> userId<span>,</span><span>String</span> password<span>)</span><span>{</span>\n  <span>// 登录成功处理逻辑</span>\n  <span>if</span><span>(</span><span>doLogin</span><span>(</span>userId<span>,</span>password<span>)</span><span>)</span><span>{</span>\n    userMarketingService<span>.</span><span>userMarketing</span><span>(</span>userId<span>)</span><span>;</span>\n    <span>return</span> ture<span>;</span>\n  <span>}</span><span>else</span><span>{</span>\n    <span>return</span> <span>false</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span>// 营销处理逻辑</span>\n<span>public</span> <span>class</span> <span>UserMarketingListener</span> <span>implements</span> <span>ApplicationListener</span><span><span>&lt;</span><span>UserLoginEvent</span><span>></span></span> <span>{</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>onApplicationEvent</span><span>(</span><span>UserLoginEvent</span> event<span>)</span> <span>{</span>\n        <span>// 用户签到</span>\n      <span>Long</span> userId <span>=</span> event<span>.</span><span>getUser</span><span>(</span><span>)</span><span>.</span><span>getId</span><span>(</span><span>)</span><span>;</span>\n      <span>this</span><span>.</span><span>userSign</span><span>(</span>userId<span>)</span><span>;</span>\n      <span>// 查询用户登录次数</span>\n      <span>int</span> signCount <span>=</span> <span>queryUserSignCount</span><span>(</span>userId<span>)</span><span>;</span>\n      <span>// 连续登录7天,赠送7个金币</span>\n      <span>if</span><span>(</span>signCount <span>>=</span> <span>7</span><span>)</span><span>{</span>\n         <span>sendGiftToUser</span><span>(</span>userId<span>,</span><span>7L</span><span>)</span><span>;</span>\n      <span>}</span><span>else</span> <span>if</span><span>(</span>signCount <span>>=</span> <span>14</span><span>)</span><span>{</span>\n         <span>// 连续登录14天,自动发放徽章</span>\n         <span>sendBadgeToUser</span><span>(</span>userId<span>)</span><span>;</span>\n      <span>}</span>\n    <span>}</span>\n<span>}</span>\n\n<span>// 风控处理逻辑</span>\n<span>public</span> <span>class</span> <span>UserSafeRiskListener</span> <span>implements</span> <span>ApplicationListener</span><span><span>&lt;</span><span>UserLoginEvent</span><span>></span></span> <span>{</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>onApplicationEvent</span><span>(</span><span>UserLoginEvent</span> event<span>)</span> <span>{</span>\n       <span>// 处理风控业务</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br></div></div><h2 id=\"_1-5-用户登录风控升级\"> 1.5 用户登录风控升级</h2>\n<p>用户登录终于跟营销解耦,现在又来了新的挑战,随着我们APP的用户的增长,用户的数据安全越来越重要了。这个时候我们开始搭建了我们的风险控制部门。</p>\n<ul>\n<li>解决这些风险问题: 用户密码盗用,异地登录,频繁换设备登录等造成的安全措施。</li>\n</ul>\n<p>产品提了一个新的需求,在登录的时候,将用户信息发送给风控部门进行检查,一旦检测部通过,自动下线,冻结用户账号。</p>\n<p>于是乎我们又要开始动我们的login方法了。像这种情况还有很多很多,都需要再我们登录成功的时候,去处理一些信息。但是我们分析下,我们还有其他办法吗?</p>\n<p>当然有就是<strong>通过事件去解耦</strong>。我们只定义一个登录成功事件,谁想关心登录成功,想做点事情,就去订阅这个事件就行了。一劳永逸。登录就只干登录的事情就行了。谁想干什么事情,谁就自己去订阅。如下代码示例。</p>\n<div><pre><code><span>// 定义登录事件</span>\n<span>public</span> <span>class</span> <span>UserLoginEvent</span> <span>extends</span> <span>ApplicationEvent</span> <span>{</span>\n\n    <span>// 登录用户</span>\n    <span>User</span> loginUser<span>;</span>\n    <span>// 用户登录成功或者失败</span>\n    <span>boolean</span> loginFlag<span>;</span>\n\n    <span>public</span> <span>UserLoginEvent</span><span>(</span><span>User</span> login<span>,</span> <span>boolean</span> loginFlag<span>)</span> <span>{</span>\n        <span>super</span><span>(</span>login<span>)</span><span>;</span>\n        <span>this</span><span>.</span>loginUser <span>=</span> login<span>;</span>\n        <span>this</span><span>.</span>loginFlag <span>=</span> loginFlag<span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>public</span> <span>boolean</span> <span>login</span><span>(</span><span>String</span> userId<span>,</span><span>String</span> password<span>)</span><span>{</span>\n  <span>// 登录成功处理逻辑</span>\n  <span>if</span><span>(</span><span>doLogin</span><span>(</span>userId<span>,</span>password<span>)</span><span>)</span><span>{</span>\n    applicationEventPublisher<span>.</span><span>publishEvent</span><span>(</span><span>new</span> <span>UserLoginEvent</span><span>(</span>userInfo<span>,</span><span>true</span><span>)</span><span>)</span>\n    <span>return</span> ture<span>;</span>\n  <span>}</span><span>else</span><span>{</span>\n    <span>// 登录失败发送失败事件</span>\n    applicationEventPublisher<span>.</span><span>publishEvent</span><span>(</span><span>new</span> <span>UserLoginEvent</span><span>(</span><span>null</span><span>,</span><span>true</span><span>)</span><span>)</span>\n    <span>return</span> <span>false</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p>好了，前戏我们铺垫完了，下面来学习Spring中给我们提供的事件管理机制。</p>\n<h2 id=\"二、内置标准事件\"> 二、内置标准事件</h2>\n<p><img src=\"https://img.springlearn.cn/blog/037d4f8eea977e42efbfc5e225b0183e.png\" alt=\"\" loading=\"lazy\"></p>\n<p>什么是内置的标准事件? 其实就是Spring中自定义的事件,告诉你当前容器的状态,允许你做点自己的事情。\n哎? 这不也是解耦吗?</p>\n<p>这部分内容前面已经说过了。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">事件</th>\n<th style=\"text-align:left\">解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>ContextRefreshedEvent</code></td>\n<td style=\"text-align:left\">在初始化或刷新时发布<code>ApplicationContext</code>（例如，通过使用接口<code>refresh()</code>上的方法<code>ConfigurableApplicationContext</code>）。这里，“初始化”意味着所有 bean 都已加载，后处理器 bean 被检测并激活，单例被预实例化，并且<code>ApplicationContext</code>对象已准备好使用。只要上下文没有关闭，就可以多次触发刷新，前提是所选择的<code>ApplicationContext</code>实际支持这种“热”刷新。例如，<code>XmlWebApplicationContext</code>支持热刷新，但 <code>GenericApplicationContext</code>不支持。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>ContextStartedEvent</code></td>\n<td style=\"text-align:left\">使用接口上的方法 <code>ApplicationContext</code>启动时发布。在这里，“已启动”意味着所有 bean 都接收到一个明确的启动信号。通常，此信号用于在显式停止后重新启动 bean，但它也可用于启动尚未配置为自动启动的组件（例如，尚未在初始化时启动的组件）。<code>start()``ConfigurableApplicationContext``Lifecycle</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>ContextStoppedEvent</code></td>\n<td style=\"text-align:left\">使用接口上的方法 <code>ApplicationContext</code>停止时发布。在这里，“停止”意味着所有 的 bean 都会收到一个明确的停止信号。可以通过 调用重新启动已停止的上下文。<code>stop()``ConfigurableApplicationContext``Lifecycle``start()</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>ContextClosedEvent</code></td>\n<td style=\"text-align:left\">在<code>ApplicationContext</code>使用接口<code>close()</code>上的方法<code>ConfigurableApplicationContext</code>或通过 JVM 关闭挂钩关闭时发布。在这里，“关闭”意味着所有的单例 bean 都将被销毁。一旦上下文关闭，它就到了生命的尽头，无法刷新或重新启动。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>RequestHandledEvent</code></td>\n<td style=\"text-align:left\">一个特定于 Web 的事件，告诉所有 bean 一个 HTTP 请求已得到服务。此事件在请求完成后发布。此事件仅适用于使用 Spring 的 Web 应用程序<code>DispatcherServlet</code>。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>ServletRequestHandledEvent</code></td>\n<td style=\"text-align:left\">它的子类<code>RequestHandledEvent</code>添加了 Servlet 特定的上下文信息。</td>\n</tr>\n</tbody>\n</table>\n<p>想了解更多的话,可以参考前一篇文章。下面来说我们如何自定事件。</p>\n<h2 id=\"三、自定义事件\"> 三、自定义事件</h2>\n<h2 id=\"_3-1-自定义事件\"> 3.1 自定义事件</h2>\n<p><img src=\"https://img.springlearn.cn/blog/d80e77f1c042f7fc100ba6de2835cbf7.png\" alt=\"\" loading=\"lazy\"></p>\n<p>这张图是内置事件的继承管理,下面我们看下他的结构关系。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>EventObject</span> <span>implements</span> <span><span>java<span>.</span>io<span>.</span></span>Serializable</span> <span>{</span>\n    <span>private</span> <span>static</span> <span>final</span> <span>long</span> serialVersionUID <span>=</span> <span>5516075349620653480L</span><span>;</span>\n    <span>protected</span> <span>transient</span> <span>Object</span>  source<span>;</span>\n    <span>public</span> <span>EventObject</span><span>(</span><span>Object</span> source<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>source <span>==</span> <span>null</span><span>)</span>\n            <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>\"null source\"</span><span>)</span><span>;</span>\n        <span>this</span><span>.</span>source <span>=</span> source<span>;</span>\n    <span>}</span>   \n<span>}</span>    \n\n<span>public</span> <span>abstract</span> <span>class</span> <span>ApplicationEvent</span> <span>extends</span> <span>EventObject</span> <span>{</span>\n\t<span>/** use serialVersionUID from Spring 1.2 for interoperability. */</span>\n\t<span>private</span> <span>static</span> <span>final</span> <span>long</span> serialVersionUID <span>=</span> <span>7099057708183571937L</span><span>;</span>\n\t<span>/** System time when the event happened. */</span>\n\t<span>private</span> <span>final</span> <span>long</span> timestamp<span>;</span>\n\t<span>public</span> <span>ApplicationEvent</span><span>(</span><span>Object</span> source<span>)</span> <span>{</span>\n\t\t<span>super</span><span>(</span>source<span>)</span><span>;</span>\n\t\t<span>this</span><span>.</span>timestamp <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>\n\t<span>}</span>\n<span>}</span>  \n\n<span>public</span> <span>abstract</span> <span>class</span> <span>ApplicationContextEvent</span> <span>extends</span> <span>ApplicationEvent</span> <span>{</span>\n\t<span>public</span> <span>ApplicationContextEvent</span><span>(</span><span>ApplicationContext</span> source<span>)</span> <span>{</span>\n\t\t<span>super</span><span>(</span>source<span>)</span><span>;</span>\n\t<span>}</span>\n\t<span>public</span> <span>final</span> <span>ApplicationContext</span> <span>getApplicationContext</span><span>(</span><span>)</span> <span>{</span>\n\t\t<span>return</span> <span>(</span><span>ApplicationContext</span><span>)</span> <span>getSource</span><span>(</span><span>)</span><span>;</span>\n\t<span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><ul>\n<li>EventObject 是jdk提供给的事件对象</li>\n<li>ApplicationEvent 继承了jdk事件对象,扩展了一个时间戳。</li>\n<li>ApplicationContextEvent 继承了ApplicationEvent,事件对象是容器上下文。</li>\n</ul>\n<p>而我们要想自定义事件,只需要继承抽象类 <code>ApplicationEvent</code> 就行了,然后给事件，定义一个你要传递的信息,如下定义了一个用户登录事件。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>UserLoginEvent</span> <span>extends</span> <span>ApplicationEvent</span> <span>{</span>\n\n    <span>// 登录用户</span>\n    <span>User</span> loginUser<span>;</span>\n    <span>// 用户登录成功或者失败</span>\n    <span>boolean</span> loginFlag<span>;</span>\n\n    <span>public</span> <span>UserLoginEvent</span><span>(</span><span>User</span> login<span>,</span> <span>boolean</span> loginFlag<span>)</span> <span>{</span>\n        <span>super</span><span>(</span>login<span>)</span><span>;</span>\n        <span>this</span><span>.</span>loginUser <span>=</span> login<span>;</span>\n        <span>this</span><span>.</span>loginFlag <span>=</span> loginFlag<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id=\"_3-2-定义事件监听器的两种方法\"> 3.2 定义事件监听器的两种方法</h2>\n<h3 id=\"_3-2-1-实现-applicationlistener-接口\"> 3.2.1 实现 ApplicationListener 接口</h3>\n<ul>\n<li><code>ApplicationListener&lt;E extends ApplicationEvent&gt; extends EventListener</code> 泛型限定必须是 ApplicationEvent子类。</li>\n</ul>\n<div><pre><code><span>@Component</span>\n<span>public</span> <span>class</span> <span>UserMarketingListener</span> <span>implements</span> <span>ApplicationListener</span><span><span>&lt;</span><span>UserLoginEvent</span><span>></span></span> <span>{</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>onApplicationEvent</span><span>(</span><span>UserLoginEvent</span> event<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"UserMarketingListener Processor:\"</span> <span>+</span> event<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"_3-2-2-eventlistener-注解实现\"> 3.2.2 @EventListener 注解实现</h3>\n<p>我们也可以不实现 <code>ApplicationListener</code> 接口,我们使用 <code>@EventListener</code>.</p>\n<div><pre><code><span>@Component</span>\n<span>public</span> <span>class</span> <span>UserSafeRiskListener</span> <span>{</span>\n\n    <span>@EventListener</span><span>(</span><span>{</span><span>UserLoginEvent</span><span>.</span><span>class</span><span>}</span><span>)</span>\n    <span>public</span> <span>void</span> <span>userRiskEvent</span><span>(</span><span>UserLoginEvent</span> userLoginEvent<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"UserSafeRiskListener Processor:\"</span> <span>+</span> userLoginEvent<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id=\"_3-3-异步事件\"> 3.3 异步事件</h2>\n<h3 id=\"_3-3-1-自定义异步事件发射器\"> 3.3.1 自定义异步事件发射器</h3>\n<p>注意名称一定要是: <code>applicationEventMulticaster</code></p>\n<div><pre><code><span>@Configuration</span>\n<span>public</span> <span>class</span> <span>AsynApplicationEventPushConfig</span> <span>{</span>\n\n    <span>@Bean</span><span>(</span><span>\"applicationEventMulticaster\"</span><span>)</span>\n    <span>public</span> <span>SimpleApplicationEventMulticaster</span> <span>applicationEventMulticaster</span><span>(</span><span>BeanFactory</span> beanFactory<span>)</span> <span>{</span>\n        <span>SimpleApplicationEventMulticaster</span> simpleApplicationEventMulticaster <span>=</span> <span>new</span> <span>SimpleApplicationEventMulticaster</span><span>(</span>beanFactory<span>)</span><span>;</span>\n        <span>// 设置为异步处理</span>\n        simpleApplicationEventMulticaster<span>.</span><span>setTaskExecutor</span><span>(</span><span>new</span> <span>SimpleAsyncTaskExecutor</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// 统一的异常处理器</span>\n        simpleApplicationEventMulticaster<span>.</span><span>setErrorHandler</span><span>(</span><span>new</span> <span>ErrorHandler</span><span>(</span><span>)</span> <span>{</span>\n            <span>@Override</span>\n            <span>public</span> <span>void</span> <span>handleError</span><span>(</span><span>Throwable</span> t<span>)</span> <span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"事件处理异常:\"</span> <span>+</span> t<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n        <span>return</span> simpleApplicationEventMulticaster<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>想研究源码的,可以看下这里。</p>\n<p><code>AbstractApplicationContext#initApplicationEventMulticaster</code></p>\n<p><img src=\"https://img.springlearn.cn/blog/784956283bb3f58579daf7fe2093a0f3.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_3-3-2-注意事项\"> 3.3.2 注意事项</h3>\n<p><code>SimpleApplicationEventMulticaster#TaskExecutor</code></p>\n<ul>\n<li>\n<p>默认相当于<code>org.springframework.core.task.SyncTaskExecutor</code>,即在调用线程中同步执行所有监听器。</p>\n</li>\n<li>\n<p>当然如果要用异步,你需要使用 <code>org.springframework.core.task.SimpleAsyncTaskExecutor</code>\n需要注意的是,如果使用异步,发送事件不会阻塞调用线程。但是，请注意异步执行不会参与调用者的线程上下文（类加载器、事务关联）</p>\n</li>\n</ul>\n<h2 id=\"_3-4-最后发送事件\"> 3.4 最后发送事件</h2>\n<div><pre><code>    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>ConfigurableApplicationContext</span> run <span>=</span> <span>SpringApplication</span><span>.</span><span>run</span><span>(</span><span>Application</span><span>.</span><span>class</span><span>,</span> args<span>)</span><span>;</span>\n        <span>// 同步还是异步,取决于配置。</span>\n        run<span>.</span><span>publishEvent</span><span>(</span><span>new</span> <span>UserLoginEvent</span><span>(</span><span>new</span> <span>User</span><span>(</span><span>)</span><span>,</span><span>true</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>    \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><img src=\"https://img.springlearn.cn/learn_aecfc8e243edb199c726728413b1522c.gif\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>最后,都看到这里了,最后如果这篇文章,对你有所帮助,请点个关注,交个朋友。</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/9e7a3d6be0b037aa72c573cb91fa2e30.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://img.springlearn.cn/blog/b8f74de10af99991e3fc73632eeeb190.png",
      "date_published": "2022-09-04T13:51:11.000Z",
      "date_modified": "2023-02-08T03:23:43.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Spring Framework"
      ]
    },
    {
      "title": "第03篇:Validation参数校验",
      "url": "https://java.springlearn.cn/learn/spring/core03/",
      "id": "https://java.springlearn.cn/learn/spring/core03/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/b8f74de10af99991e3fc73632eeeb190.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>公众号</strong>: 西魏陶渊明<br/>\n<strong>CSDN</strong>: <a href=\"https://springlearn.blog.csdn.net/?type=blog\" target=\"_blank\" rel=\"noopener noreferrer\">https://springlearn.blog.csdn.net</a><br/></p>\n<blockquote>\n<p>天下代码一大抄, 抄来抄去有提高, 看你会抄不会抄！</p>\n</blockquote>\n<p><img src=\"https://img.springlearn.cn/blog/8f3392b9badb093f9e1a6472b4a98487.gif\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"一、前言\"> 一、前言</h2>\n<p>数据校验是任何开发情况下都不能避免的逻辑, 在实际的业务中往往我们会通过在业务中去前置校验我们需要使用的数据。代码可能是这样的。</p>\n<div><pre><code>  <span>public</span> <span>void</span> <span>saveUser</span><span>(</span><span>User</span> user<span>)</span> <span>{</span>\n        <span>// 前置校验</span>\n        <span>if</span> <span>(</span><span>Objects</span><span>.</span><span>isNull</span><span>(</span>user<span>)</span><span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>RuntimeException</span><span>(</span><span>\"user 不能为空\"</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>if</span> <span>(</span><span>StringUtils</span><span>.</span><span>isBlank</span><span>(</span>user<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>RuntimeException</span><span>(</span><span>\"userName 不能为空\"</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>if</span> <span>(</span><span>Objects</span><span>.</span><span>isNull</span><span>(</span>user<span>.</span><span>getAge</span><span>(</span><span>)</span><span>)</span> <span>||</span> user<span>.</span><span>getAge</span><span>(</span><span>)</span> <span>&lt;=</span> <span>0</span> <span>||</span> user<span>.</span><span>getAge</span><span>(</span><span>)</span> <span>></span> <span>120</span><span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>RuntimeException</span><span>(</span><span>\"age 非法\"</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>if</span> <span>(</span><span>Objects</span><span>.</span><span>isNull</span><span>(</span>user<span>.</span><span>getAddress</span><span>(</span><span>)</span><span>)</span><span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>RuntimeException</span><span>(</span><span>\"address 不能为空\"</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>// 数据保存</span>\n        <span>doSave</span><span>(</span>user<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>但是其实,Spring Framework 提供对 Java Bean Validation API 的支持。我们完全可以使用Spring提供的能力。如果使用Spring的能力,我们的代码就会变成下面这样。</p>\n<div><pre><code><span>@Data</span>\n<span>@ToString</span>\n<span>public</span> <span>class</span> <span>User</span><span>{</span>\n\n    <span>@NotBlank</span><span>(</span>message <span>=</span> <span>\"name 不能为空\"</span><span>)</span>\n    <span>@Size</span><span>(</span>min <span>=</span> <span>2</span><span>,</span> max <span>=</span> <span>120</span><span>,</span> message <span>=</span> <span>\"不能小于2字符,大于120字符\"</span><span>)</span>\n    <span>private</span> <span>String</span> name<span>;</span>\n\n    <span>@Max</span><span>(</span>value <span>=</span> <span>120</span><span>,</span> message <span>=</span> <span>\"年龄不能大于120\"</span><span>)</span>\n    <span>@Min</span><span>(</span>value <span>=</span> <span>0</span><span>,</span> message <span>=</span> <span>\"年龄不能小于0\"</span><span>)</span>\n    <span>private</span> <span>Integer</span> age<span>;</span>\n\n    <span>@NotEmpty</span><span>(</span>message <span>=</span> <span>\"家庭成员不能为空\"</span><span>)</span>\n    <span>@Size</span><span>(</span>max <span>=</span> <span>4</span><span>,</span> message <span>=</span> <span>\"数量不能超过4个\"</span><span>)</span>\n    <span>private</span> <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> membersFamily<span>;</span>\n\n    <span>@NotNull</span><span>(</span>message <span>=</span> <span>\"地址不能为空\"</span><span>)</span>\n    <span>private</span> <span>Address</span> address<span>;</span>\n<span>}</span>\n\n <span>public</span> <span>void</span> <span>saveUser</span><span>(</span><span>@Validated</span> <span>User</span> user<span>)</span> <span>{</span>\n        <span>// 数据保存</span>\n        <span>doSave</span><span>(</span>user<span>)</span><span>;</span>\n <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>本篇我们就是来了解下我们如何借助Spring的能力,来帮助我们减少工作量。</p>\n<h2 id=\"二、java-bean-validation-api\"> 二、Java Bean Validation API</h2>\n<p>Bean Validation 通过约束声明和 Java 应用程序的元数据提供了一种通用的验证方式。要使用它，您可以使用声明性验证约束来注释域模型属性，然后由运行时强制执行。有内置约束，您也可以定义自己的自定义约束。</p>\n<p>以下示例，该示例显示了一个PersonForm具有两个属性的简单模型：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>PersonForm</span> <span>{</span>\n    <span>private</span> <span>String</span> name<span>;</span>\n    <span>private</span> <span>int</span> age<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>Bean Validation 允许您声明约束，如以下示例所示：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>PersonForm</span> <span>{</span>\n\n    <span>@NotNull</span>\n    <span>@Size</span><span>(</span>max<span>=</span><span>64</span><span>)</span>\n    <span>private</span> <span>String</span> name<span>;</span>\n\n    <span>@Min</span><span>(</span><span>0</span><span>)</span>\n    <span>private</span> <span>int</span> age<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>一个 Bean Validation 验证器然后根据声明的约束来验证这个类的实例。</p>\n<p>下面一起来学习下如何正确使用。</p>\n<h2 id=\"_2-1-配置-bean-验证提供程序\"> 2.1 配置 Bean 验证提供程序</h2>\n<p>Spring 为 Bean Validation API 提供全面支持，包括将 Bean Validation 提供者引导为 Spring bean。这使您可以在应用程序中注入一个 javax.validation.ValidatorFactory或任何需要验证的位置。javax.validation.Validator</p>\n<p>您可以使用LocalValidatorFactoryBean 默认验证器配置为 Spring bean，如以下示例所示：</p>\n<div><pre><code><span>import</span> <span>org<span>.</span>springframework<span>.</span>validation<span>.</span>beanvalidation<span>.</span></span><span>LocalValidatorFactoryBean</span><span>;</span>\n\n<span>@Configuration</span>\n<span>public</span> <span>class</span> <span>AppConfig</span> <span>{</span>\n\n    <span>@Bean</span>\n    <span>public</span> <span>LocalValidatorFactoryBean</span> <span>validator</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>new</span> <span>LocalValidatorFactoryBean</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><pre><code>        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>org.hibernate.validator<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>hibernate-validator<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id=\"_2-2-注入验证器\"> 2.2 注入验证器</h2>\n<p>除了使用 <code>@Validated</code> 注解修饰外，我们还能通过硬编码来使用,比如我们直接注入一个验证器。</p>\n<blockquote>\n<p>LocalValidatorFactoryBean实现javax.validation.ValidatorFactory 和 javax.validation.Validator以及 Spring 的org.springframework.validation.Validator. 您可以将对这些接口中的任何一个的引用注入到需要调用验证逻辑的 bean 中。</p>\n</blockquote>\n<p>javax.validation.Validator如果您更喜欢直接使用 Bean Validation API，您可以注入一个引用，如以下示例所示</p>\n<div><pre><code><span>import</span> <span>javax<span>.</span>validation<span>.</span></span><span>Validator</span><span>;</span>\n\n<span>@Service</span>\n<span>public</span> <span>class</span> <span>MyService</span> <span>{</span>\n\n    <span>@Autowired</span>\n    <span>private</span> <span>Validator</span> validator<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>如果您的 bean 需要 Spring Validation API，您可以注入一个引用org.springframework.validation.Validator，如以下示例所示：</p>\n<div><pre><code><span>import</span> <span>org<span>.</span>springframework<span>.</span>validation<span>.</span></span><span>Validator</span><span>;</span>\n\n<span>@Service</span>\n<span>public</span> <span>class</span> <span>MyService</span> <span>{</span>\n\n    <span>@Autowired</span>\n    <span>private</span> <span>Validator</span> validator<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><strong>注意看所依赖的包是不一样哦,因为LocalValidatorFactoryBean都实现这些接口</strong></p>\n<h2 id=\"_2-3-内置约束注解\"> 2.3 内置约束注解</h2>\n<p><img src=\"https://img.springlearn.cn/blog/cd0bef8bfba2dc0facdc1fe90dad69fa.png\" alt=\"\" loading=\"lazy\"></p>\n<p>如果你用的idea可以在右侧找到 <code>Bean Validation</code>,这里可以看到内置和我们自定义的约束注解。</p>\n<p>下面我们看了默认都支持那些校验及支持的数据类型。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">注解</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:left\">支持类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">@Size</td>\n<td style=\"text-align:left\">带注释的元素大小必须在指定边界（包括）之间。</td>\n<td style=\"text-align:left\">CharSequence、Collection、Map、数组</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">@PositiveOrZero</td>\n<td style=\"text-align:left\">带注释的元素必须是正数或 0。</td>\n<td style=\"text-align:left\">BigDecimal、BigInteger、byte ， short ， int ， long ， float ， double和它们各自的包装器，null是被允许的</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">@Positive</td>\n<td style=\"text-align:left\">带注释的元素必须是严格的正数（即 0 被视为无效值）。</td>\n<td style=\"text-align:left\">BigDecimal、BigInteger、byte ， short ， int ， long ， float ， double和它们各自的包装器，null是被允许的</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">@Pattern</td>\n<td style=\"text-align:left\">带注释的CharSequence必须匹配指定的正则表达式。正则表达式遵循 Java 正则表达式约定</td>\n<td style=\"text-align:left\">接受CharSequence 。 null元素被认为是有效的。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">@PastOrPresent</td>\n<td style=\"text-align:left\">注释元素必须是过去或现在的瞬间、日期或时间</td>\n<td style=\"text-align:left\">java.time.*、Date、java.time.chrono</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">@Past</td>\n<td style=\"text-align:left\">带注释的元素必须是过去的瞬间、日期或时间</td>\n<td style=\"text-align:left\">同上</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">@Null</td>\n<td style=\"text-align:left\">带注释的元素必须为null</td>\n<td style=\"text-align:left\">接受任何类型。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">@NotNull</td>\n<td style=\"text-align:left\">带注释的元素不能为null</td>\n<td style=\"text-align:left\">接受任何类型。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">@NotEmpty</td>\n<td style=\"text-align:left\">带注释的元素不能为null也不能为空</td>\n<td style=\"text-align:left\">CharSequence、Collection、Map、数组</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">@NotBlank</td>\n<td style=\"text-align:left\">带注释的元素不能为null ，并且必须至少包含一个非空白字符</td>\n<td style=\"text-align:left\">CharSequence</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">@NegativeOrZero</td>\n<td style=\"text-align:left\">带注释的元素必须是负数或 0</td>\n<td style=\"text-align:left\">BigDecimal、BigInteger、byte ， short ， int ， long ， float ， double和它们各自的包装器，null是被允许的</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">@Negative</td>\n<td style=\"text-align:left\">带注释的元素必须是严格的负数（即，0 被视为无效值）。</td>\n<td style=\"text-align:left\">BigDecimal、BigInteger、byte ， short ， int ， long ， float ， double和它们各自的包装器，null是被允许的</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">@Min</td>\n<td style=\"text-align:left\">带注释的元素必须是一个数字，其值必须大于或等于指定的最小值</td>\n<td style=\"text-align:left\">BigDecimal、BigInteger、byte ， short ， int ， long ，它们各自的包装器，null是被允许的，不支持double和float</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">@Max</td>\n<td style=\"text-align:left\">带注释的元素必须是一个数字，其值必须小于或等于指定的最大值。</td>\n<td style=\"text-align:left\">BigDecimal、BigInteger、byte ， short ， int ， long ，它们各自的包装器，null是被允许的，不支持double和float</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">@FutureOrPresent</td>\n<td style=\"text-align:left\">注释元素必须是现在或将来的瞬间、日期或时间。</td>\n<td style=\"text-align:left\">java.time.*、Date、java.time.chrono</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">@Future</td>\n<td style=\"text-align:left\">带注释的元素必须是未来的瞬间、日期或时间。</td>\n<td style=\"text-align:left\">java.time.*、Date、java.time.chrono</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">@Email</td>\n<td style=\"text-align:left\">该字符串必须是格式正确的电子邮件地址</td>\n<td style=\"text-align:left\">CharSequence</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">@Digits</td>\n<td style=\"text-align:left\">带注释的元素必须是可接受范围内的数字支持的类型有</td>\n<td style=\"text-align:left\">BigDecimal、BigInteger、CharSequence、byte 、 short 、 int 、 long以及它们各自的包装类型</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">@DecimalMin</td>\n<td style=\"text-align:left\">带注释的元素必须是一个数字，其值必须大于或等于指定的最小值。</td>\n<td style=\"text-align:left\">BigDecimal、BigInteger、CharSequence、byte 、 short 、 int 、 long以及它们各自的包装类型，不支持double和float</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">@DecimalMax</td>\n<td style=\"text-align:left\">带注释的元素必须是一个数字，其值必须小于或等于指定的最大值。</td>\n<td style=\"text-align:left\">BigDecimal、BigInteger、CharSequence、byte 、 short 、 int 、 long以及它们各自的包装类型，不支持double和float</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">@AssertTrue</td>\n<td style=\"text-align:left\">带注释的元素必须为真。</td>\n<td style=\"text-align:left\">支持的类型是boolean和Boolean，null元素被认为是有效的。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">@AssertFalse</td>\n<td style=\"text-align:left\">带注释的元素必须为假</td>\n<td style=\"text-align:left\">支持的类型是boolean和Boolean</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"_2-4-配置自定义约束\"> 2.4 配置自定义约束</h2>\n<p>如果前面内置的还不能满足你，那么我们可以自定义一个约束类型。</p>\n<p>使用 <code>@Constraint</code> 来修饰我们自定义的注解,然后实现 <code>javax.validation.ConstraintValidator</code> 约束行为的接口。</p>\n<p>以下示例显示了一个自定义@Constraint声明，后跟一个 ConstraintValidator使用 Spring 进行依赖注入的关联实现：</p>\n<div><pre><code><span>@Target</span><span>(</span><span>{</span><span>ElementType</span><span>.</span>METHOD<span>,</span> <span>ElementType</span><span>.</span>FIELD<span>}</span><span>)</span>\n<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>\n<span>@Constraint</span><span>(</span>validatedBy<span>=</span><span>MyConstraintValidator</span><span>.</span><span>class</span><span>)</span>\n<span>public</span> <span>@interface</span> <span>MyConstraint</span> <span>{</span>\n    <span>// 错误提示语句</span>\n    <span>String</span> <span>message</span><span>(</span><span>)</span> <span>default</span> <span>\"\"</span><span>;</span>\n    <span>// 更加细维度控制是否验证【注意必须是接口】</span>\n    <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span><span>[</span><span>]</span> <span>groups</span><span>(</span><span>)</span> <span>default</span> <span>{</span><span>}</span><span>;</span>\n\n    <span>Class</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>Payload</span><span>></span></span><span>[</span><span>]</span> <span>payload</span><span>(</span><span>)</span> <span>default</span> <span>{</span><span>}</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>定义自定的验证器</p>\n<div><pre><code><span>import</span> <span>javax<span>.</span>validation<span>.</span></span><span>ConstraintValidator</span><span>;</span>\n<span>import</span> <span>javax<span>.</span>validation<span>.</span></span><span>ConstraintValidatorContext</span><span>;</span>\n<span>public</span> <span>class</span> <span>MyConstraintValidator</span> <span>implements</span> <span>ConstraintValidator</span><span><span>&lt;</span><span>MyConstraint</span><span>,</span> <span>Address</span><span>></span></span> <span>{</span>\n\n    <span>private</span> <span>MyConstraint</span> myConstraint<span>;</span>\n\n    <span>/**\n     * 初始化,会注入注解的信息\n     *\n     * @param constraintAnnotation annotation instance for a given constraint declaration\n     */</span>\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>initialize</span><span>(</span><span>MyConstraint</span> constraintAnnotation<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>myConstraint <span>=</span> constraintAnnotation<span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>boolean</span> <span>isValid</span><span>(</span><span>Address</span> value<span>,</span> <span>ConstraintValidatorContext</span> context<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"MyConstraint:\"</span> <span>+</span> myConstraint<span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"MyConstraintValidator:\"</span> <span>+</span> value<span>)</span><span>;</span>\n        <span>return</span> <span>true</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>如前面的示例所示，实现可以像任何其他 Spring bean 一样ConstraintValidator具有其依赖项。</p>\n<h2 id=\"_2-5-细维度校验\"> 2.5 细维度校验</h2>\n<p>前面说了如果要自定义注解,有三个必须要的参数.</p>\n<ul>\n<li>message 错误语句</li>\n<li>groups  分组控制【注意必须是接口】</li>\n<li>payload 【有效负载】</li>\n</ul>\n<p>下面通过举一个例子,来演示groups和payload究竟有什么用。</p>\n<p>举一个例子 <code>Person</code> 这个模型,在查询,修改和保存时候都会使用。但是只有保存时候才要求校验，其他场景: 查询和修改都不用校验。那么我们该怎么办呢? 如下代码实例。看如何使用groups来完成这个需求。</p>\n<h3 id=\"_2-5-1-定义模型\"> 2.5.1 定义模型</h3>\n<div><pre><code><span>public</span> <span>class</span> <span>Person</span> <span>{</span>\n\n    <span>@NotNull</span><span>(</span>message <span>=</span> <span>\"name不能为空\"</span><span>)</span>\n    <span>@Size</span><span>(</span>max <span>=</span> <span>64</span><span>,</span> message <span>=</span> <span>\"长度不能大于64\"</span><span>)</span>\n    <span>private</span> <span>String</span> name<span>;</span>\n\n    <span>@Min</span><span>(</span><span>0</span><span>)</span>\n    <span>private</span> <span>int</span> age<span>;</span>\n\n    <span>// 地址保存时候必须有值, 其他情况可以为空</span>\n    <span>@MyConstraint</span><span>(</span>message <span>=</span> <span>\"address不能为空\"</span><span>,</span>groups <span>=</span> <span>Save</span><span>.</span><span>class</span><span>)</span>\n    <span>private</span> <span>Address</span> address<span>;</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id=\"_2-5-2-不生效示例\"> 2.5.2 不生效示例</h3>\n<div><pre><code>   <span>@PostMapping</span><span>(</span>value <span>=</span> <span>\"validation\"</span><span>,</span> consumes <span>=</span> <span>MediaType</span><span>.</span>APPLICATION_JSON_VALUE<span>)</span>\n    <span>public</span> <span>String</span> <span>post</span><span>(</span><span>@Validated</span> <span>@RequestBody</span> <span>Person</span> person<span>)</span> <span>{</span>\n        <span>return</span> <span>\"success\"</span><span>;</span>\n    <span>}</span>\n    \n   <span>@PostMapping</span><span>(</span>value <span>=</span> <span>\"validation\"</span><span>,</span> consumes <span>=</span> <span>MediaType</span><span>.</span>APPLICATION_JSON_VALUE<span>)</span>\n    <span>public</span> <span>String</span> <span>post</span><span>(</span><span>@Validated</span><span>(</span><span>Query</span><span>.</span><span>class</span><span>)</span> <span>@RequestBody</span> <span>Person</span> person<span>)</span> <span>{</span>\n        <span>return</span> <span>\"success\"</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"_2-5-3-生效示例\"> 2.5.3 生效示例</h3>\n<div><pre><code>    <span>@PostMapping</span><span>(</span>value <span>=</span> <span>\"validation\"</span><span>,</span> consumes <span>=</span> <span>MediaType</span><span>.</span>APPLICATION_JSON_VALUE<span>)</span>\n    <span>public</span> <span>String</span> <span>post</span><span>(</span><span>@Validated</span><span>(</span><span>Save</span><span>.</span><span>class</span><span>)</span> <span>@RequestBody</span> <span>Person</span> person<span>)</span> <span>{</span>\n        <span>return</span> <span>\"success\"</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>原理: <code>org.hibernate.validator.internal.engine.ValidatorImpl</code>,感兴趣的可以研究下。</p>\n<h2 id=\"_2-6-校验原理\"> 2.6 校验原理</h2>\n<p><strong>MethodValidationPostProcessor</strong></p>\n<ul>\n<li>初始化时候,使用AOP做了一个切面,当方法参数使用@Validated修饰,就给加上一个代理。</li>\n<li>MethodValidationInterceptor 方法执行时候去检查参数。</li>\n</ul>\n<div><pre><code>  <span>// 初始化时候,使用AOP做了一个切面,当方法参数使用@Validated修饰,就给加上一个代理。</span>\n  <span>@Override</span>\n\t<span>public</span> <span>void</span> <span>afterPropertiesSet</span><span>(</span><span>)</span> <span>{</span>\n\t\t<span>Pointcut</span> pointcut <span>=</span> <span>new</span> <span>AnnotationMatchingPointcut</span><span>(</span><span>Validated</span><span>.</span><span>class</span><span>,</span> <span>true</span><span>)</span><span>;</span>\n\t\t<span>this</span><span>.</span>advisor <span>=</span> <span>new</span> <span>DefaultPointcutAdvisor</span><span>(</span>pointcut<span>,</span> <span>createMethodValidationAdvice</span><span>(</span><span>this</span><span>.</span>validator<span>)</span><span>)</span><span>;</span>\n\t<span>}</span>\n\n\t<span>/**\n\t * Create AOP advice for method validation purposes, to be applied\n\t * with a pointcut for the specified 'validated' annotation.\n\t * @param validator the JSR-303 Validator to delegate to\n\t * @return the interceptor to use (typically, but not necessarily,\n\t * a {@link MethodValidationInterceptor} or subclass thereof)\n\t * @since 4.2\n\t */</span>\n\t<span>protected</span> <span>Advice</span> <span>createMethodValidationAdvice</span><span>(</span><span>@Nullable</span> <span>Validator</span> validator<span>)</span> <span>{</span>\n\t\t<span>return</span> <span>(</span>validator <span>!=</span> <span>null</span> <span>?</span> <span>new</span> <span>MethodValidationInterceptor</span><span>(</span>validator<span>)</span> <span>:</span> <span>new</span> <span>MethodValidationInterceptor</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\t<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h2 id=\"三、总结\"> 三、总结</h2>\n<p>看起来使用注解来约束数据对象,是一个很好的选择。但是也不是那么好,因为这会导致,数据的校验逻辑\n比较分散。在面临项目需求的快速的迭代和项目组人员调整的情况,分散数据校验逻辑,往往会带的意想不到的问题。</p>\n<p>最后仁者见仁智者见智，如果是你，你会怎么来选择呢?</p>\n<p><img src=\"https://img.springlearn.cn/learn_aecfc8e243edb199c726728413b1522c.gif\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>最后,都看到这里了,最后如果这篇文章,对你有所帮助,请点个关注,交个朋友。</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/9e7a3d6be0b037aa72c573cb91fa2e30.png\" alt=\"\" loading=\"lazy\"></p>\n<ul>\n<li>message 错误语句</li>\n<li>groups  分组控制【注意必须是接口】</li>\n<li>payload</li>\n</ul>\n<p>下面通过举一个例子,来演示groups和payload究竟有什么用。</p>\n<h3 id=\"_2-5-1-定义模型-2\"> 2.5.1 定义模型</h3>\n<div><pre><code><span>public</span> <span>class</span> <span>Person</span> <span>{</span>\n\n    <span>@NotNull</span><span>(</span>message <span>=</span> <span>\"name不能为空\"</span><span>)</span>\n    <span>@Size</span><span>(</span>max <span>=</span> <span>64</span><span>,</span> message <span>=</span> <span>\"长度不能大于64\"</span><span>)</span>\n    <span>private</span> <span>String</span> name<span>;</span>\n\n    <span>@Min</span><span>(</span><span>0</span><span>)</span>\n    <span>private</span> <span>int</span> age<span>;</span>\n\n    <span>// 地址保存时候必须有值, 其他情况可以为空</span>\n    <span>@MyConstraint</span><span>(</span>message <span>=</span> <span>\"address不能为空\"</span><span>,</span>groups <span>=</span> <span>Save</span><span>.</span><span>class</span><span>)</span>\n    <span>private</span> <span>Address</span> address<span>;</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id=\"_2-5-2-不生效示例-2\"> 2.5.2 不生效示例</h3>\n<div><pre><code>   <span>@PostMapping</span><span>(</span>value <span>=</span> <span>\"validation\"</span><span>,</span> consumes <span>=</span> <span>MediaType</span><span>.</span>APPLICATION_JSON_VALUE<span>)</span>\n    <span>public</span> <span>String</span> <span>post</span><span>(</span><span>@Validated</span> <span>@RequestBody</span> <span>Person</span> person<span>)</span> <span>{</span>\n        <span>return</span> <span>\"success\"</span><span>;</span>\n    <span>}</span>\n    \n   <span>@PostMapping</span><span>(</span>value <span>=</span> <span>\"validation\"</span><span>,</span> consumes <span>=</span> <span>MediaType</span><span>.</span>APPLICATION_JSON_VALUE<span>)</span>\n    <span>public</span> <span>String</span> <span>post</span><span>(</span><span>@Validated</span><span>(</span><span>Query</span><span>.</span><span>class</span><span>)</span> <span>@RequestBody</span> <span>Person</span> person<span>)</span> <span>{</span>\n        <span>return</span> <span>\"success\"</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"_2-5-3-生效示例-2\"> 2.5.3 生效示例</h3>\n<div><pre><code>    <span>@PostMapping</span><span>(</span>value <span>=</span> <span>\"validation\"</span><span>,</span> consumes <span>=</span> <span>MediaType</span><span>.</span>APPLICATION_JSON_VALUE<span>)</span>\n    <span>public</span> <span>String</span> <span>post</span><span>(</span><span>@Validated</span><span>(</span><span>Save</span><span>.</span><span>class</span><span>)</span> <span>@RequestBody</span> <span>Person</span> person<span>)</span> <span>{</span>\n        <span>return</span> <span>\"success\"</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>原理: <code>org.hibernate.validator.internal.engine.ValidatorImpl</code>,感兴趣的可以研究下。</p>\n<h2 id=\"_2-6-校验原理-2\"> 2.6 校验原理</h2>\n<p><strong>MethodValidationPostProcessor</strong></p>\n<ul>\n<li>初始化时候,使用AOP做了一个切面,当方法参数使用@Validated修饰,就给加上一个代理。</li>\n<li>MethodValidationInterceptor 方法执行时候去检查参数。</li>\n</ul>\n<div><pre><code>  <span>// 初始化时候,使用AOP做了一个切面,当方法参数使用@Validated修饰,就给加上一个代理。</span>\n  <span>@Override</span>\n\t<span>public</span> <span>void</span> <span>afterPropertiesSet</span><span>(</span><span>)</span> <span>{</span>\n\t\t<span>Pointcut</span> pointcut <span>=</span> <span>new</span> <span>AnnotationMatchingPointcut</span><span>(</span><span>Validated</span><span>.</span><span>class</span><span>,</span> <span>true</span><span>)</span><span>;</span>\n\t\t<span>this</span><span>.</span>advisor <span>=</span> <span>new</span> <span>DefaultPointcutAdvisor</span><span>(</span>pointcut<span>,</span> <span>createMethodValidationAdvice</span><span>(</span><span>this</span><span>.</span>validator<span>)</span><span>)</span><span>;</span>\n\t<span>}</span>\n\n\t<span>/**\n\t * Create AOP advice for method validation purposes, to be applied\n\t * with a pointcut for the specified 'validated' annotation.\n\t * @param validator the JSR-303 Validator to delegate to\n\t * @return the interceptor to use (typically, but not necessarily,\n\t * a {@link MethodValidationInterceptor} or subclass thereof)\n\t * @since 4.2\n\t */</span>\n\t<span>protected</span> <span>Advice</span> <span>createMethodValidationAdvice</span><span>(</span><span>@Nullable</span> <span>Validator</span> validator<span>)</span> <span>{</span>\n\t\t<span>return</span> <span>(</span>validator <span>!=</span> <span>null</span> <span>?</span> <span>new</span> <span>MethodValidationInterceptor</span><span>(</span>validator<span>)</span> <span>:</span> <span>new</span> <span>MethodValidationInterceptor</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\t<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h2 id=\"三、总结-2\"> 三、总结</h2>\n<p>看起来使用注解来约束数据对象,是一个很好的选择。但是也不是那么好,因为这会导致,数据的校验逻辑\n比较分散。在面临项目需求的快速的迭代和项目组人员调整的情况,分散数据校验逻辑,往往会带的意想不到的问题。</p>\n<p>最后仁者见仁智者见智，如果是你，你会怎么来选择呢?</p>\n<p><img src=\"https://img.springlearn.cn/learn_aecfc8e243edb199c726728413b1522c.gif\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>最后,都看到这里了,最后如果这篇文章,对你有所帮助,请点个关注,交个朋友。</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/9e7a3d6be0b037aa72c573cb91fa2e30.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://img.springlearn.cn/blog/b8f74de10af99991e3fc73632eeeb190.png",
      "date_published": "2022-09-04T13:51:11.000Z",
      "date_modified": "2023-02-08T03:23:43.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Spring Framework"
      ]
    },
    {
      "title": "第04篇:Resources资源文件",
      "url": "https://java.springlearn.cn/learn/spring/core04/",
      "id": "https://java.springlearn.cn/learn/spring/core04/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/b8f74de10af99991e3fc73632eeeb190.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>公众号</strong>: 西魏陶渊明<br/>\n<strong>CSDN</strong>: <a href=\"https://springlearn.blog.csdn.net/?type=blog\" target=\"_blank\" rel=\"noopener noreferrer\">https://springlearn.blog.csdn.net</a><br/></p>\n<blockquote>\n<p>天下代码一大抄, 抄来抄去有提高, 看你会抄不会抄！</p>\n</blockquote>\n<p><img src=\"https://img.springlearn.cn/blog/8f3392b9badb093f9e1a6472b4a98487.gif\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"一、前言\"> 一、前言</h2>\n<p>Java 的java.net.URL各种 URL 前缀的标准类和标准处理程序不足以满足所有对低级资源的访问。例如，没有URL可用于访问需要从类路径或相对于ServletContext。于是乎这就给了Spring,封装继承多态,大展身手的展示了。怎么展示呢?</p>\n<p>在Spring中就是 <code>Resource</code> 接口,下面我们就看看 <code>Resource</code>。</p>\n<p>我们利用Spring提供的能力,可以获取任何你想获取的文件,也可以使用通配符来模糊查询你要的文件。下面开始展示。</p>\n<h2 id=\"二、代码实例\"> 二、代码实例</h2>\n<h2 id=\"_2-1-接口定义\"> 2.1 接口定义</h2>\n<div><pre><code><span>public</span> <span>interface</span> <span>Resource</span> <span>extends</span> <span>InputStreamSource</span> <span>{</span>\n    <span>// 确定此资源是否实际以物理形式存在</span>\n    <span>boolean</span> <span>exists</span><span>(</span><span>)</span><span>;</span>\n    <span>// 是否可以通过getInputStream()读取此资源的非空内容。</span>\n    <span>boolean</span> <span>isReadable</span><span>(</span><span>)</span><span>;</span>\n    <span>// 指示此资源是否表示具有打开流的句柄。如果为true ，则 InputStream 不能被多次读取，必须被读取并关闭以避免资源泄漏。</span>\n    <span>boolean</span> <span>isOpen</span><span>(</span><span>)</span><span>;</span>\n    <span>// 确定此资源是否代表文件系统中的文件。 </span>\n    <span>boolean</span> <span>isFile</span><span>(</span><span>)</span><span>;</span>\n    <span>// 返回此资源的 URL 句柄。</span>\n    <span>URL</span> <span>getURL</span><span>(</span><span>)</span> <span>throws</span> <span>IOException</span><span>;</span>\n    <span>// 返回此资源的 URI 句柄。</span>\n    <span>URI</span> <span>getURI</span><span>(</span><span>)</span> <span>throws</span> <span>IOException</span><span>;</span>\n    <span>// 返回此资源的文件句柄</span>\n    <span>File</span> <span>getFile</span><span>(</span><span>)</span> <span>throws</span> <span>IOException</span><span>;</span>\n    <span>// 预计每次通话都会创建一个新频道。</span>\n    <span>ReadableByteChannel</span> <span>readableChannel</span><span>(</span><span>)</span> <span>throws</span> <span>IOException</span><span>;</span>\n    <span>// 确定此资源的内容长度。</span>\n    <span>long</span> <span>contentLength</span><span>(</span><span>)</span> <span>throws</span> <span>IOException</span><span>;</span>\n    <span>// 确定此资源的最后修改时间戳。</span>\n    <span>long</span> <span>lastModified</span><span>(</span><span>)</span> <span>throws</span> <span>IOException</span><span>;</span>\n    <span>// 创建与此资源相关的资源 relativePath – 相对路径（相对于该资源）</span>\n    <span>Resource</span> <span>createRelative</span><span>(</span><span>String</span> relativePath<span>)</span> <span>throws</span> <span>IOException</span><span>;</span>\n    <span>// 确定此资源的文件名，即通常是路径的最后部分：例如，“myfile.txt”。</span>\n    <span>String</span> <span>getFilename</span><span>(</span><span>)</span><span>;</span>\n    <span>// 返回此资源的描述，用于在使用资源时输出错误。</span>\n    <span>String</span> <span>getDescription</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><h2 id=\"_2-2-内置resource实现\"> 2.2 内置Resource实现</h2>\n<p>Spring 包括几个内置的Resource实现：</p>\n<p><img src=\"https://img.springlearn.cn/blog/aec5094c4b2437e274d2b222c0f969d9.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_2-2-1-urlresource\"> 2.2.1 UrlResource</h3>\n<p>UrlResource包装 ajava.net.URL并可用于访问通常可通过 URL 访问的任何对象，例如文件、HTTPS 目标、FTP 目标等。所有 URL 都有一个标准化的String表示，因此使用适当的标准化前缀来指示一个 URL 类型与另一个 URL 类型。这包括 file:访问文件系统路径、https:通过 HTTPS 协议ftp:访问资源、通过 FTP 访问资源等。</p>\n<p>UrlResource是由 Java 代码通过显式使用UrlResource构造函数创建的，但通常是在调用 API 方法时隐式创建的。</p>\n<div><pre><code>  <span>AnnotationConfigApplicationContext</span> cxt <span>=</span> <span>new</span> <span>AnnotationConfigApplicationContext</span><span>(</span><span>)</span><span>;</span>\n  <span>Resource</span> urlResource <span>=</span> cxt<span>.</span><span>getResource</span><span>(</span><span>\"https://dev.springlearn.cn/_assets/style.f6b20991.css\"</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"_2-2-2-classpathresource\"> 2.2.2 ClassPathResource</h3>\n<p>此类表示应从类路径获取的资源。它使用线程上下文类加载器、给定的类加载器或给定的类来加载资源。</p>\n<p>ClassPathResource是由 Java 代码通过显式使用ClassPathResource 构造函数创建的，但通常是在调用 API 方法时隐式创建的。</p>\n<div><pre><code><span>Resource</span> classPathContextResource <span>=</span> cxt<span>.</span><span>getResource</span><span>(</span><span>\"application.yml\"</span><span>)</span><span>;</span>\n<span>Resource</span> classPathResource <span>=</span> cxt<span>.</span><span>getResource</span><span>(</span><span>\"classpath:application.yml\"</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"_2-2-3-filesystemresource\"> 2.2.3 FileSystemResource</h3>\n<p>java.io.File它还支持 java.nio.file.Path句柄，应用 Spring 的标准基于字符串的路径转换，但通过java.nio.file.FilesAPI 执行所有操作。对于纯 java.nio.path.Path基于支持，请改用 a PathResource。</p>\n<div><pre><code><span>FileSystemResource</span> fileSystemResource1 <span>=</span> <span>new</span> <span>FileSystemResource</span><span>(</span><span>\"/Users/lx/Github/learn-example/learn-spring/src/main/resources/a.txt\"</span><span>)</span><span>;</span>\n\n <span>Path</span> path <span>=</span> <span>Paths</span><span>.</span><span>get</span><span>(</span><span>\"/Users/lx/Github/learn-example/learn-spring/src/main/resources/a.txt\"</span><span>)</span><span>;</span>\n <span>FileSystemResource</span> fileSystemResource2 <span>=</span> <span>new</span> <span>FileSystemResource</span><span>(</span>path<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"_2-2-4-pathresource\"> 2.2.4 PathResource</h3>\n<p>对于纯 java.nio.path.Path基于支持</p>\n<div><pre><code><span>Path</span> path <span>=</span> <span>Paths</span><span>.</span><span>get</span><span>(</span><span>\"/Users/liuxin/Github/learn-example/learn-spring/src/main/resources/a.txt\"</span><span>)</span><span>;</span>\n<span>PathResource</span> pathResource <span>=</span> <span>new</span> <span>PathResource</span><span>(</span>path<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"_2-2-5-servletcontextresource\"> 2.2.5 ServletContextResource</h3>\n<p>Web 应用程序根目录中的相对路径Resource的资源实现。ServletContext</p>\n<p>它始终支持流访问和 URL 访问，但java.io.File仅在扩展 Web 应用程序存档且资源物理位于文件系统上时才允许访问。它是否被扩展并在文件系统上或直接从 JAR 或其他地方（如数据库）访问（这是可以想象的）实际上取决于 Servlet 容器。</p>\n<h3 id=\"_2-2-6-inputstreamresource\"> 2.2.6 InputStreamResource</h3>\n<p>InputStreamResource是Resource给定 的实现InputStream。Resource只有在没有特定实现适用时才应使用它。特别是，在可能的情况下，首选ByteArrayResource实现。</p>\n<p>与其他Resource实现相比，这是一个已打开资源的描述符。因此isOpen()=true. 如果您需要将资源描述符保存在某处或需要多次读取流，请不要使用它。</p>\n<h3 id=\"_2-2-7-bytearrayresource\"> 2.2.7 ByteArrayResource</h3>\n<p>这是Resource给定字节数组的实现,它对于从任何给定的字节数组加载内容很有用，而不必求助于单次使用InputStreamResource</p>\n<h2 id=\"_2-3-处理策略\"> 2.3 处理策略</h2>\n<p>前面我们看了,Spring中内置了很多的实现,但是难道我们要自己来判断使用哪个吗? 当时是不需要的。我们直接使用 <code>AnnotationConfigApplicationContext#getResource</code>。而具体使用哪个实现我们看底层的处理逻辑。</p>\n<p>这段逻辑是在 <code>DefaultResourceLoader</code> 中处理的。</p>\n<div><pre><code><span>@Override</span>\n\t<span>public</span> <span>Resource</span> <span>getResource</span><span>(</span><span>String</span> location<span>)</span> <span>{</span>\n\t\t<span>Assert</span><span>.</span><span>notNull</span><span>(</span>location<span>,</span> <span>\"Location must not be null\"</span><span>)</span><span>;</span>\n    <span>// 系统中是否有自己的解析处理器,这里可以自定义协议处理器。</span>\n\t\t<span>for</span> <span>(</span><span>ProtocolResolver</span> protocolResolver <span>:</span> <span>getProtocolResolvers</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n\t\t\t<span>Resource</span> resource <span>=</span> protocolResolver<span>.</span><span>resolve</span><span>(</span>location<span>,</span> <span>this</span><span>)</span><span>;</span>\n\t\t\t<span>if</span> <span>(</span>resource <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n\t\t\t\t<span>return</span> resource<span>;</span>\n\t\t\t<span>}</span>\n\t\t<span>}</span>\n    <span>// new ClassPathContextResource()</span>\n\t\t<span>if</span> <span>(</span>location<span>.</span><span>startsWith</span><span>(</span><span>\"/\"</span><span>)</span><span>)</span> <span>{</span>\n\t\t\t<span>return</span> <span>getResourceByPath</span><span>(</span>location<span>)</span><span>;</span>\n\t\t<span>}</span>\n    <span>// new ClassPathResource()</span>\n\t\t<span>else</span> <span>if</span> <span>(</span>location<span>.</span><span>startsWith</span><span>(</span>CLASSPATH_URL_PREFIX<span>)</span><span>)</span> <span>{</span>\n\t\t\t<span>return</span> <span>new</span> <span>ClassPathResource</span><span>(</span>location<span>.</span><span>substring</span><span>(</span>CLASSPATH_URL_PREFIX<span>.</span><span>length</span><span>(</span><span>)</span><span>)</span><span>,</span> <span>getClassLoader</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\t\t<span>}</span>\n\t\t<span>else</span> <span>{</span>\n\t\t\t<span>try</span> <span>{</span>\n\t\t\t\t<span>// 处理 http、https、ftp、file、jar</span>\n\t\t\t\t<span>URL</span> url <span>=</span> <span>new</span> <span>URL</span><span>(</span>location<span>)</span><span>;</span>\n\t\t\t\t<span>return</span> <span>(</span><span>ResourceUtils</span><span>.</span><span>isFileURL</span><span>(</span>url<span>)</span> <span>?</span> <span>new</span> <span>FileUrlResource</span><span>(</span>url<span>)</span> <span>:</span> <span>new</span> <span>UrlResource</span><span>(</span>url<span>)</span><span>)</span><span>;</span>\n\t\t\t<span>}</span>\n\t\t\t<span>catch</span> <span>(</span><span>MalformedURLException</span> ex<span>)</span> <span>{</span>\n\t\t\t\t<span>// 未知协议的，都使用ClassPathContextResource来加载</span>\n\t\t\t\t<span>return</span> <span>getResourceByPath</span><span>(</span>location<span>)</span><span>;</span>\n\t\t\t<span>}</span>\n\t\t<span>}</span>\n\t<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><h2 id=\"_2-4-classpath-匹配模式\"> 2.4 Classpath 匹配模式</h2>\n<ul>\n<li><code>classpath*:</code> 匹配模式,从当前项目文件中和依赖的jar包中进行查询</li>\n</ul>\n<p><strong>匹配实现类</strong>:PathMatchingResourcePatternResolver</p>\n<h3 id=\"_2-4-1-classpath路径\"> 2.4.1 classpath路径</h3>\n<p><img src=\"https://img.springlearn.cn/blog/0475f04822095f45cdaf02dacc2c6a44.png\" alt=\"\" loading=\"lazy\"></p>\n<p>使用classpath获取文件,默认就是从编译后的classes目录中获取</p>\n<ul>\n<li>获取a.txt  <code>classpath:a.txt</code> or <code>this.getClass().getClassLoader().getResource(&quot;a.txt&quot;)</code></li>\n<li>获取b.txt  <code>classpath:temp/b.txt</code> or <code>this.getClass().getClassLoader().getResource(&quot;temp/b.txt&quot;)</code></li>\n</ul>\n<p>注意当你发现源文件中有你要的文件,但是编译后的文件中没有了,如果是在开发环境,建议 <code>mvn clean</code> 后重新编译。(这种情况一般是idea缓存问题)</p>\n<p>如果是在上线后发现没有,可能就是maven配置的问题,项目打包的时候没有把文件给打包进去。此时可能就要添加下面的配置。</p>\n<div><pre><code><span><span><span>&lt;</span>build</span><span>></span></span>\n\t<span><span><span>&lt;</span>plugins</span><span>></span></span>\n\t\t<span><span><span>&lt;</span>plugin</span><span>></span></span>\n\t\t\t<span><span><span>&lt;</span>artifactId</span><span>></span></span>maven-resources-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n\t\t\t<span><span><span>&lt;</span>version</span><span>></span></span>${last_version}<span><span><span>&lt;/</span>version</span><span>></span></span>\n\t\t\t<span><span><span>&lt;</span>configuration</span><span>></span></span>\n\t\t\t\t<span><span><span>&lt;</span>encoding</span><span>></span></span>UTF-8<span><span><span>&lt;/</span>encoding</span><span>></span></span>\n\t\t\t<span><span><span>&lt;/</span>configuration</span><span>></span></span>\n\t\t<span><span><span>&lt;/</span>plugin</span><span>></span></span>\n\t<span><span><span>&lt;/</span>plugins</span><span>></span></span>\n<span><span><span>&lt;/</span>build</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>注意如果你的文件是放在resource中,一般是不会出现这种问题的,因为Maven会从项目的src/main/resources目录下查找资源。如果你的资源不在此目录下，可以用 <code>&lt;resources&gt;</code> 标签指定，同时也支持多个目录。</p>\n<div><pre><code><span><span><span>&lt;</span>build</span><span>></span></span>\n\t<span><span><span>&lt;</span>resources</span><span>></span></span>\n\t\t<span><span><span>&lt;</span>resource</span><span>></span></span>\n\t\t\t<span><span><span>&lt;</span>directory</span><span>></span></span>src/main/resources1<span><span><span>&lt;/</span>directory</span><span>></span></span>\n\t\t<span><span><span>&lt;/</span>resource</span><span>></span></span>\n\t\t<span><span><span>&lt;</span>resource</span><span>></span></span>\n\t\t\t<span><span><span>&lt;</span>directory</span><span>></span></span>src/main/resources2<span><span><span>&lt;/</span>directory</span><span>></span></span>\n\t\t<span><span><span>&lt;/</span>resource</span><span>></span></span>\n\t<span><span><span>&lt;/</span>resources</span><span>></span></span>\n<span><span><span>&lt;/</span>build</span><span>></span></span>  \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id=\"_2-4-2-匹配模式\"> 2.4.2 匹配模式</h3>\n<p>我们这里使用匹配模式 <code>classpath*:*.txt</code>, 获取txt结尾的文件</p>\n<p><img src=\"https://img.springlearn.cn/blog/0dc1294f41a73ae2963948257359ec37.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>test</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>AnnotationConfigApplicationContext</span> cxt <span>=</span> <span>new</span> <span>AnnotationConfigApplicationContext</span><span>(</span><span>)</span><span>;</span>\n        <span>Resource</span><span>[</span><span>]</span> resources <span>=</span> cxt<span>.</span><span>getResources</span><span>(</span><span>\"classpath*:*.txt\"</span><span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>Resource</span> resource <span>:</span> resources<span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>resource<span>.</span><span>getDescription</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>可以看到这里不仅把我们要的文件给查询到了,还把其他依赖的包中后缀.txt的文件给查询出来了。</p>\n<div><pre><code>file [/Users/liuxin/Github/learn-example/learn-spring/target/classes/a.txt]\nURL [jar:file:/Users/liuxin/.m2/repository3/junit/junit/4.13/junit-4.13.jar!/LICENSE-junit.txt]\nURL [jar:file:/Users/liuxin/.m2/repository3/org/hamcrest/hamcrest-core/2.2/hamcrest-core-2.2.jar!/hamcrest-core-is-deprecated.txt]\nURL [jar:file:/Users/liuxin/.m2/repository3/org/projectlombok/lombok/1.18.22/lombok-1.18.22.jar!/changelog.txt]\nURL [jar:file:/Users/liuxin/.m2/repository3/org/projectlombok/lombok/1.18.22/lombok-1.18.22.jar!/release-timestamp.txt]\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><img src=\"https://img.springlearn.cn/learn_aecfc8e243edb199c726728413b1522c.gif\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>最后,都看到这里了,最后如果这篇文章,对你有所帮助,请点个关注,交个朋友。</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/9e7a3d6be0b037aa72c573cb91fa2e30.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://img.springlearn.cn/blog/b8f74de10af99991e3fc73632eeeb190.png",
      "date_published": "2022-09-04T13:51:11.000Z",
      "date_modified": "2023-02-08T03:23:43.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Spring Framework"
      ]
    },
    {
      "title": "第05篇:SpEL强大的表达式语言",
      "url": "https://java.springlearn.cn/learn/spring/core05/",
      "id": "https://java.springlearn.cn/learn/spring/core05/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/b8f74de10af99991e3fc73632eeeb190.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>公众号</strong>: 西魏陶渊明<br/>\n<strong>CSDN</strong>: <a href=\"https://springlearn.blog.csdn.net/?type=blog\" target=\"_blank\" rel=\"noopener noreferrer\">https://springlearn.blog.csdn.net</a><br/></p>\n<blockquote>\n<p>天下代码一大抄, 抄来抄去有提高, 看你会抄不会抄！</p>\n</blockquote>\n<p><img src=\"https://img.springlearn.cn/blog/8f3392b9badb093f9e1a6472b4a98487.gif\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"一、概述\"> 一、概述</h2>\n<p>Spring 表达式语言（简称“SpEL”）是一种强大的表达式语言，支持在运行时查询和操作对象图。语言语法类似于 Unified EL，但提供了额外的功能，最值得注意的是方法调用和基本的字符串模板功能。</p>\n<p>虽然还有其他几种可用的 Java 表达式语言——OGNL、MVEL 和 JBoss EL 等等</p>\n<p>但创建 Spring 表达式语言的目的是为 Spring 社区提供一种可在所有产品中使用的受良好支持的表达式语言。它的语言特性由 Spring 产品组合中的项目需求驱动。</p>\n<h2 id=\"二、作用\"> 二、作用</h2>\n<h3 id=\"_2-1-基本表达式\"> 2.1 基本表达式</h3>\n<p>字面量表达式、关系，逻辑与算数运算表达式、字符串连接及截取表达式、三目运算、正则表达式、括号优先级表达式；</p>\n<h3 id=\"_2-2-类相关表达式\"> 2.2 类相关表达式</h3>\n<p>类类型表达式、类实例化、instanceof表达式、变量定义及引用、赋值表达式、自定义函数、对象属性存取及安全导航表达式、对象方法调用、Bean引用；</p>\n<h3 id=\"_2-3-集合相关表达式\"> 2.3 集合相关表达式</h3>\n<p>内联List、内联数组、集合，字典访问、列表，字典，数组修改、集合投影、集合选择；不支持多维内联数组初始化；不支持内联字典定义；</p>\n<h3 id=\"_2-4-其他表达式\"> 2.4 其他表达式</h3>\n<p>模板表达式。</p>\n<h2 id=\"三、主要类\"> 三、主要类</h2>\n<h2 id=\"_3-1-expressionparser\"> 3.1 ExpressionParser</h2>\n<p><img src=\"https://img.springlearn.cn/blog/dc2b1cd43cf0f44fcb70b678f794317c.png\" alt=\"\" loading=\"lazy\"></p>\n<p>表达式解析器接口，包含了(Expression) parseExpression(String), (Expression) parseExpression(String, ParserContext)两个接口方法。</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>ExpressionParser</span> <span>{</span>\n\n\t<span>/**\n   * 解析表达式字符串并返回一个可用于重复评估的表达式对象。\n\t */</span>\n\t<span>Expression</span> <span>parseExpression</span><span>(</span><span>String</span> expressionString<span>)</span> <span>throws</span> <span>ParseException</span><span>;</span>\n\n\t<span>/**\n   * 解析表达式字符串并返回一个可用于重复评估的表达式对象。\n   * context -- 用于影响此表达式解析例程的上下文（可选)\n\t */</span>\n\t<span>Expression</span> <span>parseExpression</span><span>(</span><span>String</span> expressionString<span>,</span> <span>ParserContext</span> context<span>)</span> <span>throws</span> <span>ParseException</span><span>;</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h2 id=\"_3-2-parsercontext\"> 3.2 ParserContext</h2>\n<p>解析器上下文接口，主要是对解析器Token的抽象类，包含3个方法：getExpressionPrefix,getExpressionSuffix和isTemplate，就是表示表达式从什么符号开始什么符号结束，是否是作为模板（包含字面量和表达式）解析。</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>ParserContext</span> <span>{</span>\n\n\t<span>/**\n\t * 被解析的表达式是否是模板\n\t */</span>\n\t<span>boolean</span> <span>isTemplate</span><span>(</span><span>)</span><span>;</span>\n\n\t<span>/**\n\t * 对于模板表达式，返回标识字符串中表达式块开始的前缀。例如：“${”\n\t */</span>\n\t<span>String</span> <span>getExpressionPrefix</span><span>(</span><span>)</span><span>;</span>\n\n\t<span>/**\n\t * 对于模板表达式，返回标识字符串中表达式块结尾的前缀。例如： ”}”\n\t */</span>\n\t<span>String</span> <span>getExpressionSuffix</span><span>(</span><span>)</span><span>;</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h2 id=\"_3-3-expression\"> 3.3 Expression</h2>\n<p>表达式的抽象，是经过解析后的字符串表达式的形式表示。通过expressionInstance.getValue方法，可以获取表示式的值。也可以通过调用getValue(EvaluationContext)，从评估（evaluation)上下文中获取表达式对于当前上下文的值</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>Expression</span> <span>{</span>\n\n\t<span>/**\n   * 返回用于创建此表达式的原始字符串（未修改）\n\t */</span>\n\t<span>String</span> <span>getExpressionString</span><span>(</span><span>)</span><span>;</span>\n\n\t<span>/**\n   * 在默认的标准上下文中计算这个表达式。\n\t */</span>\n\t<span>@Nullable</span>\n\t<span>Object</span> <span>getValue</span><span>(</span><span>)</span> <span>throws</span> <span>EvaluationException</span><span>;</span>\n\n\t<span>/**\n   * 在默认上下文中计算表达式。如果评估的结果与预期的结果类型不匹配，则将返回异常。\n\t */</span>\n\t<span>@Nullable</span>\n\t<span><span>&lt;</span><span>T</span><span>></span></span> <span>T</span> <span>getValue</span><span>(</span><span>@Nullable</span> <span>Class</span><span><span>&lt;</span><span>T</span><span>></span></span> desiredResultType<span>)</span> <span>throws</span> <span>EvaluationException</span><span>;</span>\n\n\t<span>/**\n   * 针对指定的根对象评估此表达式。\n\t */</span>\n\t<span>@Nullable</span>\n\t<span>Object</span> <span>getValue</span><span>(</span><span>Object</span> rootObject<span>)</span> <span>throws</span> <span>EvaluationException</span><span>;</span>\n\n\t<span>/**\n   * 针对指定的根对象评估此表达式。结果与预期的结果类型不匹配，则将返回异常。\n\t */</span>\n\t<span>@Nullable</span>\n\t<span><span>&lt;</span><span>T</span><span>></span></span> <span>T</span> <span>getValue</span><span>(</span><span>Object</span> rootObject<span>,</span> <span>@Nullable</span> <span>Class</span><span><span>&lt;</span><span>T</span><span>></span></span> desiredResultType<span>)</span> <span>throws</span> <span>EvaluationException</span><span>;</span>\n\n\t<span>/**\n   * 在提供的上下文中评估此表达式并返回评估结果。\n\t */</span>\n\t<span>@Nullable</span>\n\t<span>Object</span> <span>getValue</span><span>(</span><span>EvaluationContext</span> context<span>)</span> <span>throws</span> <span>EvaluationException</span><span>;</span>\n\n\t<span>/**\n   * 在提供的上下文中评估此表达式并返回评估结果。但提供的根上下文会覆盖,默认的上下文\n\t */</span>\n\t<span>@Nullable</span>\n\t<span>Object</span> <span>getValue</span><span>(</span><span>EvaluationContext</span> context<span>,</span> <span>Object</span> rootObject<span>)</span> <span>throws</span> <span>EvaluationException</span><span>;</span>\n\n\t<span>/**\n   * 在指定的上下文中评估表达式，该上下文可以解析对属性、方法、类型等的引用。评估结果的类型应为特定类，如果不是且无法转换为该类，将引发异常类型\n\t */</span>\n\t<span>@Nullable</span>\n\t<span><span>&lt;</span><span>T</span><span>></span></span> <span>T</span> <span>getValue</span><span>(</span><span>EvaluationContext</span> context<span>,</span> <span>@Nullable</span> <span>Class</span><span><span>&lt;</span><span>T</span><span>></span></span> desiredResultType<span>)</span> <span>throws</span> <span>EvaluationException</span><span>;</span>\n\n\t<span>/**\n   * 在指定的上下文中评估表达式，该上下文可以解析对属性、方法、类型等的引用。评估结果的类型应为特定类，如果不是且无法转换为该类，将引发异常类型。提供的根对象覆盖在提供的上下文中指定的任何默认值。\n\t */</span>\n\t<span>@Nullable</span>\n\t<span><span>&lt;</span><span>T</span><span>></span></span> <span>T</span> <span>getValue</span><span>(</span><span>EvaluationContext</span> context<span>,</span> <span>Object</span> rootObject<span>,</span> <span>@Nullable</span> <span>Class</span><span><span>&lt;</span><span>T</span><span>></span></span> desiredResultType<span>)</span>\n\t\t\t<span>throws</span> <span>EvaluationException</span><span>;</span>\n\n\t<span>/**\n   * 返回可以使用默认上下文传递给setValue方法的最通用类型。\n\t */</span>\n\t<span>@Nullable</span>\n\t<span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> <span>getValueType</span><span>(</span><span>)</span> <span>throws</span> <span>EvaluationException</span><span>;</span>\n\n\t<span>/**\n   * 根据根对象,获取表达式的类型\n\t */</span>\n\t<span>@Nullable</span>\n\t<span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> <span>getValueType</span><span>(</span><span>Object</span> rootObject<span>)</span> <span>throws</span> <span>EvaluationException</span><span>;</span>\n\n\t<span>/**\n   * 根据上下文,获取表达式的类型\n\t */</span>\n\t<span>@Nullable</span>\n\t<span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> <span>getValueType</span><span>(</span><span>EvaluationContext</span> context<span>)</span> <span>throws</span> <span>EvaluationException</span><span>;</span>\n\n\t<span>/**\n   * 根据上下文,获取表达式的类型,root对象会覆盖上下文\n\t */</span>\n\t<span>@Nullable</span>\n\t<span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> <span>getValueType</span><span>(</span><span>EvaluationContext</span> context<span>,</span> <span>Object</span> rootObject<span>)</span> <span>throws</span> <span>EvaluationException</span><span>;</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br></div></div><h2 id=\"_3-4-evaluationcontext\"> 3.4 EvaluationContext</h2>\n<p>EvaluationContext在评估表达式以解析属性、方法或字段并帮助执行类型转换时，使用该接口。Spring 提供了两种实现。</p>\n<ul>\n<li>SimpleEvaluationContext：针对不需要完整范围的 SpEL 语言语法且应受到有意义限制的表达式类别，公开了基本 SpEL 语言功能和配置选项的子集。示例包括但不限于数据绑定表达式和基于属性的过滤器。</li>\n<li>StandardEvaluationContext：公开全套 SpEL 语言功能和配置选项。您可以使用它来指定默认根对象并配置每个可用的评估相关策略。</li>\n</ul>\n<p>SimpleEvaluationContext旨在仅支持 SpEL 语言语法的一个子集。它不包括 Java 类型引用、构造函数和 bean 引用。它还要求您明确选择对表达式中的属性和方法的支持级别。默认情况下，create()静态工厂方法只允许对属性进行读取访问。您还可以获得构建器来配置所需的确切支持级别</p>\n<p>如下示例。</p>\n<div><pre><code>    <span>// 字符串表达式</span>\n    <span>String</span> exp <span>=</span> <span>\"Hello , #{ #username }\"</span><span>;</span>\n    <span>// 表达式解析器</span>\n    <span>ExpressionParser</span> parser <span>=</span> <span>new</span> <span>SpelExpressionParser</span><span>(</span><span>)</span><span>;</span>\n    <span>// 表达式上下文</span>\n    <span>EvaluationContext</span> context <span>=</span> <span>new</span> <span>StandardEvaluationContext</span><span>(</span><span>)</span><span>;</span>\n    context<span>.</span><span>setVariable</span><span>(</span><span>\"username\"</span><span>,</span> <span>\"纹银三百两\"</span><span>)</span><span>;</span>\n    <span>// 解析</span>\n    <span>Expression</span> expression <span>=</span> parser<span>.</span><span>parseExpression</span><span>(</span>exp<span>,</span> <span>new</span> <span>TemplateParserContext</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>// Hello , 纹银三百两</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>expression<span>.</span><span>getValue</span><span>(</span>context<span>,</span> <span>String</span><span>.</span><span>class</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id=\"_3-5-spelparserconfiguration\"> 3.5 SpelParserConfiguration</h2>\n<p>可以使用解析器配置对象 ( org.springframework.expression.spel.SpelParserConfiguration) 来配置 SpEL 表达式解析器。配置对象控制一些表达式组件的行为。例如，如果您对数组或集合进行索引，并且指定索引处的元素是null，SpEL可以自动创建元素。这在使用由属性引用链组成的表达式时很有用。</p>\n<div><pre><code><span>class</span> <span>Demo</span> <span>{</span>\n    <span>public</span> <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> list<span>;</span>\n<span>}</span>\n\n<span>// Turn on:</span>\n<span>// - 空引用,自动初始化</span>\n<span>// - 如果是集合,自动扩容</span>\n<span>SpelParserConfiguration</span> config <span>=</span> <span>new</span> <span>SpelParserConfiguration</span><span>(</span><span>true</span><span>,</span> <span>true</span><span>)</span><span>;</span>\n\n<span>ExpressionParser</span> parser <span>=</span> <span>new</span> <span>SpelExpressionParser</span><span>(</span>config<span>)</span><span>;</span>\n\n<span>Expression</span> expression <span>=</span> parser<span>.</span><span>parseExpression</span><span>(</span><span>\"list[3]\"</span><span>)</span><span>;</span>\n\n<span>Demo</span> demo <span>=</span> <span>new</span> <span>Demo</span><span>(</span><span>)</span><span>;</span>\n\n<span>Object</span> o <span>=</span> expression<span>.</span><span>getValue</span><span>(</span>demo<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id=\"四、案例运用\"> 四、案例运用</h2>\n<h2 id=\"_4-1-文字表达\"> 4.1 文字表达</h2>\n<div><pre><code>@Test\npublic void baseTest() {\n    // 字符串表达式\n    String exp = &quot;Hello , #{ #username }&quot;;\n    // 表达式解析器\n    ExpressionParser parser = new SpelExpressionParser();\n    // 表达式上下文\n    EvaluationContext context = new StandardEvaluationContext();\n    context.setVariable(&quot;username&quot;, &quot;纹银三百两&quot;);\n    // 解析\n    Expression expression = parser.parseExpression(exp, new TemplateParserContext());\n    // Hello , 纹银三百两\n    System.out.println(expression.getValue(context, String.class));\n    \n    // Hello World!\n    Expression exp = parser.parseExpression(&quot;&#39;Hello World&#39;.concat(&#39;!&#39;)&quot;); \n    String message = (String) exp.getValue();\n\n    Expression exp2 = parser.parseExpression(&quot;&#39;Hello World&#39;.bytes&quot;); \n    byte[] bytes = (byte[]) exp2.getValue();\n    \n    // invokes &#39;getBytes().length&#39;\n    Expression exp = parser.parseExpression(&quot;&#39;Hello World&#39;.bytes.length&quot;); \n    int length = (Integer) exp.getValue();\n    \n  \n    Expression exp = parser.parseExpression(&quot;new String(&#39;hello world&#39;).toUpperCase()&quot;); \n    String message = exp.getValue(String.class);\n  }\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><h2 id=\"_4-2-关系运算符\"> 4.2 关系运算符</h2>\n<div><pre><code>//true\nboolean trueValue1 = parser.parseExpression(&quot;2 == 2&quot;).getValue(Boolean.class);\n//false\nboolean falseValue1 = parser.parseExpression(&quot;2 &lt; -5.0&quot;).getValue(Boolean.class);\n//true\nboolean trueValue2 = parser.parseExpression(&quot;&#39;black&#39; &lt; &#39;block&#39;&quot;).getValue(Boolean.class);\n//false，字符xyz是否为int类型\nboolean falseValue2 = parser.parseExpression(&quot;&#39;xyz&#39; instanceof T(int)&quot;).getValue(Boolean.class);\n//true，正则是否匹配\nboolean trueValue3 =parser.parseExpression(&quot;&#39;5.00&#39; matches &#39;^-?\\\\d+(\\\\.\\\\d{2})?$&#39;&quot;).getValue(Boolean.class);\n//false\nboolean falseValue3=parser.parseExpression(&quot;&#39;5.0067&#39; matches &#39;^-?\\\\d+(\\\\.\\\\d{2})?$&#39;&quot;).getValue(Boolean.class);\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id=\"_4-3-逻辑运算符\"> 4.3 逻辑运算符</h2>\n<div><pre><code>// -- AND 与运算 --\n//false \nboolean falseValue4 = parser.parseExpression(&quot;true and false&quot;).getValue(Boolean.class);\n // -- OR 或运算--\n//true\nboolean trueValue5 = parser.parseExpression(&quot;true or false&quot;).getValue(Boolean.class);\n//false\nboolean falseValue5 = parser.parseExpression(&quot;!true&quot;).getValue(Boolean.class);\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id=\"_4-4-算术运算符\"> 4.4 算术运算符</h2>\n<div><pre><code>// Addition\nint two = parser.parseExpression(&quot;1 + 1&quot;).getValue(Integer.class); // 2\nString testString =\nparser.parseExpression(&quot;&#39;test&#39; + &#39; &#39; + &#39;string&#39;&quot;).getValue(String.class); // &#39;test string&#39;\n// Subtraction\nint four = parser.parseExpression(&quot;1 - -3&quot;).getValue(Integer.class); // 4\ndouble d = parser.parseExpression(&quot;1000.00 - 1e4&quot;).getValue(Double.class); // -9000\n// Multiplication\nint six = parser.parseExpression(&quot;-2 * -3&quot;).getValue(Integer.class); // 6\ndouble twentyFour = parser.parseExpression(&quot;2.0 * 3e0 * 4&quot;).getValue(Double.class); // 24.0\n// Division\nint minusTwo = parser.parseExpression(&quot;6 / -3&quot;).getValue(Integer.class); // -2\ndouble one = parser.parseExpression(&quot;8.0 / 4e0 / 2&quot;).getValue(Double.class); // 1.0\n// Modulus\nint three = parser.parseExpression(&quot;7 % 4&quot;).getValue(Integer.class); // 3\nint one = parser.parseExpression(&quot;8 / 5 % 2&quot;).getValue(Integer.class); // 1\n// Operator precedence\nint minusTwentyOne = parser.parseExpression(&quot;1+2-3*8&quot;).getValue(Integer.class); // -21\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h2 id=\"_4-5-三元运算符\"> 4.5 三元运算符</h2>\n<p>您可以使用三元运算符在表达式内执行 if-then-else 条件逻辑。以下清单显示了一个最小示例：</p>\n<div><pre><code><span>String</span> falseString <span>=</span> parser<span>.</span><span>parseExpression</span><span>(</span>\n        <span>\"false ? 'trueExp' : 'falseExp'\"</span><span>)</span><span>.</span><span>getValue</span><span>(</span><span>String</span><span>.</span><span>class</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>在这种情况下，布尔值false会返回字符串 value 'falseExp'。一个更现实的例子如下：</p>\n<div><pre><code>\n<span>public</span> <span>class</span> <span>SpringElTest</span> <span>{</span>\n\n    <span>public</span> <span>String</span> name<span>;</span>\n\n    <span>public</span> <span>boolean</span> <span>isMember</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>\n        <span>return</span> <span>true</span><span>;</span>\n    <span>}</span>\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>test</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>SpringElTest</span> root <span>=</span> <span>new</span> <span>SpringElTest</span><span>(</span><span>)</span><span>;</span>\n        <span>SpelExpressionParser</span> parser <span>=</span> <span>new</span> <span>SpelExpressionParser</span><span>(</span><span>)</span><span>;</span>\n        <span>StandardEvaluationContext</span> context <span>=</span> <span>new</span> <span>StandardEvaluationContext</span><span>(</span>root<span>)</span><span>;</span>\n        <span>// 可以注册方法,注意如果是注册的方法要 #isMember(#queryName)而不是isMember(#queryName)</span>\n<span>//        context.registerFunction(\"isMember\", isMember);</span>\n        context<span>.</span><span>setVariable</span><span>(</span><span>\"queryName\"</span><span>,</span> <span>\"周杰伦\"</span><span>)</span><span>;</span>\n\n        <span>// 绑定属性</span>\n        <span>EvaluationContext</span> setContext <span>=</span> <span>SimpleEvaluationContext</span><span>.</span><span>forReadWriteDataBinding</span><span>(</span><span>)</span><span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>\n        parser<span>.</span><span>parseExpression</span><span>(</span><span>\"name\"</span><span>)</span><span>.</span><span>setValue</span><span>(</span>setContext<span>,</span> root<span>,</span> <span>\"许嵩\"</span><span>)</span><span>;</span>\n\n        <span>String</span> expression <span>=</span> <span>\"isMember(#queryName)? #queryName + ' is a member of the ' \"</span> <span>+</span>\n                <span>\"+ name + ' Society' : #queryName + ' is not a member of the ' + name + ' Society'\"</span><span>;</span>\n        <span>String</span> queryResultString <span>=</span> parser<span>.</span><span>parseExpression</span><span>(</span>expression<span>)</span>\n                <span>.</span><span>getValue</span><span>(</span>context<span>,</span> <span>String</span><span>.</span><span>class</span><span>)</span><span>;</span>\n        <span>// 周杰伦 is a member of the 许嵩 Society</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>queryResultString<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><h2 id=\"_4-6-使用变量\"> 4.6 使用变量</h2>\n<div><pre><code><span>Inventor</span> tesla <span>=</span> <span>new</span> <span>Inventor</span><span>(</span><span>\"Nikola Tesla\"</span><span>,</span> <span>\"Serbian\"</span><span>)</span><span>;</span>\n\n<span>EvaluationContext</span> context <span>=</span> <span>SimpleEvaluationContext</span><span>.</span><span>forReadWriteDataBinding</span><span>(</span><span>)</span><span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>\ncontext<span>.</span><span>setVariable</span><span>(</span><span>\"newName\"</span><span>,</span> <span>\"Mike Tesla\"</span><span>)</span><span>;</span>\n\nparser<span>.</span><span>parseExpression</span><span>(</span><span>\"name = #newName\"</span><span>)</span><span>.</span><span>getValue</span><span>(</span>context<span>,</span> tesla<span>)</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>tesla<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span>  <span>// \"Mike Tesla\"</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id=\"五、集合操作\"> 五、集合操作</h2>\n<p>选择是一种强大的表达式语言功能，可让您通过从其条目中进行选择将源集合转换为另一个集合。</p>\n<p>选择使用.?[selectionExpression]. 它过滤集合并返回一个包含原始元素子集的新集合。例如，选择可以让我们轻松获得塞尔维亚发明人的列表，如下例所示：</p>\n<h2 id=\"_5-1-集合过滤\"> 5.1 集合过滤</h2>\n<div><pre><code><span>// create an array of integers</span>\n<span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> primes <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>(</span><span>)</span><span>;</span>\nprimes<span>.</span><span>addAll</span><span>(</span><span>Arrays</span><span>.</span><span>asList</span><span>(</span><span>2</span><span>,</span><span>3</span><span>,</span><span>5</span><span>,</span><span>7</span><span>,</span><span>11</span><span>,</span><span>13</span><span>,</span><span>17</span><span>)</span><span>)</span><span>;</span>\n\n<span>// create parser and set variable 'primes' as the array of integers</span>\n<span>ExpressionParser</span> parser <span>=</span> <span>new</span> <span>SpelExpressionParser</span><span>(</span><span>)</span><span>;</span>\n<span>EvaluationContext</span> context <span>=</span> <span>SimpleEvaluationContext</span><span>.</span><span>forReadOnlyDataAccess</span><span>(</span><span>)</span><span>;</span>\ncontext<span>.</span><span>setVariable</span><span>(</span><span>\"primes\"</span><span>,</span> primes<span>)</span><span>;</span>\n\n<span>// all prime numbers > 10 from the list (using selection ?{...})</span>\n<span>// evaluates to [11, 13, 17]</span>\n<span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> primesGreaterThanTen <span>=</span> <span>(</span><span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>)</span> parser<span>.</span><span>parseExpression</span><span>(</span>\n        <span>\"#primes.?[#this>10]\"</span><span>)</span><span>.</span><span>getValue</span><span>(</span>context<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id=\"_5-2-集合映射\"> 5.2 集合映射</h2>\n<p>类似与map操作，语法是.![projectionExpression]</p>\n<div><pre><code><span>// returns ['Smiljan', 'Idvor' ]</span>\n<span>List</span> placesOfBirth <span>=</span> <span>(</span><span>List</span><span>)</span>parser<span>.</span><span>parseExpression</span><span>(</span><span>\"members.![placeOfBirth.city]\"</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h2 id=\"六、操作类\"> 六、操作类</h2>\n<h2 id=\"_6-1-类类型\"> 6.1 类类型</h2>\n<div><pre><code>@Test\npublic void classTypeTest() {\n    ExpressionParser parser = new SpelExpressionParser();\n    //java.lang包类访问\n    Class&lt;String&gt; result1 = parser.parseExpression(&quot;T(String)&quot;).getValue(Class.class);\n    //class java.lang.String\n    System.out.println(result1);\n\n    //其他包类访问\n    String expression2 = &quot;T(spel.SpElTest)&quot;;\n    Class&lt;SpElTest&gt; value = parser.parseExpression(expression2).getValue(Class.class);\n    //true\n    System.out.println(value == SpElTest.class);\n\n    //类静态字段访问\n    int result3 = parser.parseExpression(&quot;T(Integer).MAX_VALUE&quot;).getValue(int.class);\n    //true\n    System.out.println(result3 == Integer.MAX_VALUE);\n\n    //类静态方法调用\n    int result4 = parser.parseExpression(&quot;T(Integer).parseInt(&#39;1&#39;)&quot;).getValue(int.class);\n    //1\n    System.out.println(result4);\n  }\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h2 id=\"_6-2-自定义函数\"> 6.2 自定义函数</h2>\n<div><pre><code>/**\n   * 两数之和\n   */\npublic static Integer add(Integer x, Integer y) {\n    return x + y;\n  }\n\n@Test\npublic void functionTest() throws NoSuchMethodException {\n    // 表达式\n    String exp = &quot;#{ #add(4,5)}&quot;;\n    // 表达式上下文\n    StandardEvaluationContext context = new StandardEvaluationContext();\n    Method add = SpElTest.class.getDeclaredMethod(&quot;add&quot;, Integer.class, Integer.class);\n    context.registerFunction(&quot;add&quot;, add);\n    // 表达式解析器\n    ExpressionParser parser = new SpelExpressionParser();\n    // 解析\n    Expression expression = parser.parseExpression(exp, new TemplateParserContext());\n    // 9\n    System.out.println(expression.getValue(context, Integer.class));\n  }\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h2 id=\"_6-3-类属性\"> 6.3 类属性</h2>\n<div><pre><code> @Test\n  public void assignTest() {\n    String exp = &quot;username: #{#user.username},age: #{#user.age}&quot;;\n    StandardEvaluationContext context = new StandardEvaluationContext();\n    Person person = new Person()\n        .setUsername(&quot;纹银三百两&quot;)\n        .setAge(23);\n    context.setVariable(&quot;user&quot;, person);\n    ExpressionParser parser = new SpelExpressionParser();\n    Expression expression = parser.parseExpression(exp, new TemplateParserContext());\n    //username: 纹银三百两,age: 23\n    System.out.println(expression.getValue(context, String.class));\n  }\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id=\"七、模板表达式\"> 七、模板表达式</h2>\n<p>指定模板 <code>%{ }</code>，默认是 <code>#{}</code></p>\n<div><pre><code>@Test\npublic void templateTest() {\n    SpelExpressionParser parser = new SpelExpressionParser();\n    ParserContext context = new TemplateParserContext(&quot;%{&quot;, &quot;}&quot;);\n    Expression expression = parser.parseExpression(&quot;你好:%{#name},正在学习:%{#lesson}，加油、奋斗！！！&quot;, context);\n    EvaluationContext evaluationContext = new StandardEvaluationContext();\n    evaluationContext.setVariable(&quot;name&quot;, &quot;纹银三百两&quot;);\n    evaluationContext.setVariable(&quot;lesson&quot;, &quot;spring高手系列。&quot;);\n    String value = expression.getValue(evaluationContext, String.class);\n    //你好:纹银三百两,正在学习:spring高手系列。加油、奋斗！！！\n    System.out.println(value);\n  }\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id=\"八、规则引擎\"> 八、规则引擎</h2>\n<h2 id=\"_8-1-背景\"> 8.1 背景</h2>\n<p>假设人员注册信息(姓名、年龄、性别），自定义其中规则，如下：</p>\n<p>李家好汉（李姓，男，且满18岁）\n豆蔻少女（13-15岁，女性）</p>\n<h2 id=\"_8-2-实现\"> 8.2 实现</h2>\n<div><pre><code>@Test\n  public void ruleTest() {\n    Person person1 = new Person().setUsername(&quot;小龙女&quot;).setAge(14).setSex(1);\n    checkRule(FastJsonUtil.parseMap(JSON.toJSONString(person1)));\n    Person person2 = new Person().setUsername(&quot;张三&quot;).setAge(18).setSex(0);\n    checkRule(FastJsonUtil.parseMap(JSON.toJSONString(person2)));\n    Person person3 = new Person().setUsername(&quot;李四&quot;).setAge(20).setSex(0);\n    checkRule(FastJsonUtil.parseMap(JSON.toJSONString(person3)));\n\n  }\n\n  /**\n   * 规则check\n   *\n   * @param exp 参数map\n   */\n  private static void checkRule(Map&lt;String, Object&gt; exp) {\n    ExpressionParser parser = new SpelExpressionParser();\n    //规则容器\n    Map&lt;String, String&gt; ruleMap = Maps.newHashMap();\n    String rule1 = &quot;( #username.contains({&#39;李&#39;}) and  #age &gt; 18 and #sex == 0 )&quot;;\n    ruleMap.put(&quot;李家好汉&quot;, rule1);\n    String rule2 = &quot;( #age between {13,15} and #sex == 1 )&quot;;\n    ruleMap.put(&quot;豆蔻少女&quot;, rule2);\n    EvaluationContext spElContext = getSpElContext(exp);\n    ruleMap.keySet().forEach(key -&gt; {\n      String ruleV = ruleMap.get(key);\n      Boolean isPass = parser.parseExpression(ruleV).getValue(spElContext, Boolean.class);\n      if (Objects.nonNull(isPass) &amp;&amp; isPass) {\n        System.out.println(&quot;username:【&quot; + exp.get(&quot;username&quot;) + &quot;】,命中规则:【&quot; + key+&quot;】&quot;);\n      }\n\n    });\n  }\n\n  /**\n   * 解析表达式需要的上下文，透传请求参数\n   *\n   * @param param 参数\n   * @return 返回结果\n   */\n  private static EvaluationContext getSpElContext(Map&lt;String, Object&gt; param) {\n    StandardEvaluationContext evaluationContext = new StandardEvaluationContext();\n    for (Entry&lt;String, Object&gt; entry : param.entrySet()) {\n      if (entry.getValue() != null) {\n        evaluationContext.setVariable(entry.getKey(), entry.getValue());\n      }\n    }\n    return evaluationContext;\n  }\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br></div></div><p><strong>结果：</strong></p>\n<div><pre><code>username:【小龙女】,命中规则:【豆蔻少女】\nusername:【李四】,命中规则:【李家好汉】\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h2 id=\"九、容器内使用\"> 九、容器内使用</h2>\n<h2 id=\"_9-1-注释配置\"> 9.1 注释配置</h2>\n<div><pre><code><span>public</span> <span>class</span> <span>FieldValueTestBean</span> <span>{</span>\n\n    <span>@Value</span><span>(</span><span>\"#{ systemProperties['user.region'] }\"</span><span>)</span>\n    <span>private</span> <span>String</span> defaultLocale<span>;</span>\n\n    <span>public</span> <span>void</span> <span>setDefaultLocale</span><span>(</span><span>String</span> defaultLocale<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>defaultLocale <span>=</span> defaultLocale<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>String</span> <span>getDefaultLocale</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>this</span><span>.</span>defaultLocale<span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>public</span> <span>class</span> <span>PropertyValueTestBean</span> <span>{</span>\n\n    <span>private</span> <span>String</span> defaultLocale<span>;</span>\n\n    <span>@Value</span><span>(</span><span>\"#{ systemProperties['user.region'] }\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>setDefaultLocale</span><span>(</span><span>String</span> defaultLocale<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>defaultLocale <span>=</span> defaultLocale<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>String</span> <span>getDefaultLocale</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>this</span><span>.</span>defaultLocale<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><h2 id=\"_9-2-自动装配\"> 9.2 自动装配</h2>\n<div><pre><code><span>public</span> <span>class</span> <span>SimpleMovieLister</span> <span>{</span>\n\n    <span>private</span> <span>MovieFinder</span> movieFinder<span>;</span>\n    <span>private</span> <span>String</span> defaultLocale<span>;</span>\n\n    <span>@Autowired</span>\n    <span>public</span> <span>void</span> <span>configure</span><span>(</span><span>MovieFinder</span> movieFinder<span>,</span>\n            <span>@Value</span><span>(</span><span>\"#{ systemProperties['user.region'] }\"</span><span>)</span> <span>String</span> defaultLocale<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>movieFinder <span>=</span> movieFinder<span>;</span>\n        <span>this</span><span>.</span>defaultLocale <span>=</span> defaultLocale<span>;</span>\n    <span>}</span>\n\n    <span>// ...</span>\n<span>}</span>\n\n<span>public</span> <span>class</span> <span>MovieRecommender</span> <span>{</span>\n\n    <span>private</span> <span>String</span> defaultLocale<span>;</span>\n\n    <span>private</span> <span>CustomerPreferenceDao</span> customerPreferenceDao<span>;</span>\n\n    <span>public</span> <span>MovieRecommender</span><span>(</span><span>CustomerPreferenceDao</span> customerPreferenceDao<span>,</span>\n            <span>@Value</span><span>(</span><span>\"#{systemProperties['user.country']}\"</span><span>)</span> <span>String</span> defaultLocale<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>customerPreferenceDao <span>=</span> customerPreferenceDao<span>;</span>\n        <span>this</span><span>.</span>defaultLocale <span>=</span> defaultLocale<span>;</span>\n    <span>}</span>\n\n    <span>// ...</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><h2 id=\"十、总结\"> 十、总结</h2>\n<p>Spring EL表达式，作为JAVA的内置语言，十分强大。主要可以用来做表达式解析，或者规则链路，且可以操作函数方法；从而达到一种动态的链路规则解析效果。</p>\n<p><img src=\"https://img.springlearn.cn/learn_aecfc8e243edb199c726728413b1522c.gif\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>最后,都看到这里了,最后如果这篇文章,对你有所帮助,请点个关注,交个朋友。</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/9e7a3d6be0b037aa72c573cb91fa2e30.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://img.springlearn.cn/blog/b8f74de10af99991e3fc73632eeeb190.png",
      "date_published": "2022-09-04T13:51:11.000Z",
      "date_modified": "2023-02-08T03:23:43.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Spring Framework"
      ]
    },
    {
      "title": "第06篇:AOP面向切面编程",
      "url": "https://java.springlearn.cn/learn/spring/core06/",
      "id": "https://java.springlearn.cn/learn/spring/core06/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/b8f74de10af99991e3fc73632eeeb190.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>公众号</strong>: 西魏陶渊明<br/>\n<strong>CSDN</strong>: <a href=\"https://springlearn.blog.csdn.net/?type=blog\" target=\"_blank\" rel=\"noopener noreferrer\">https://springlearn.blog.csdn.net</a><br/></p>\n<blockquote>\n<p>天下代码一大抄, 抄来抄去有提高, 看你会抄不会抄！</p>\n</blockquote>\n<p><img src=\"https://img.springlearn.cn/blog/8f3392b9badb093f9e1a6472b4a98487.gif\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"一、前言\"> 一、前言</h2>\n<blockquote>\n<p>面向切面编程 (AOP) 通过提供另一种思考程序结构的方式来补充面向对象编程 (OOP)。</p>\n</blockquote>\n<p>OOP 中模块化的关键单元是类，而 AOP 中模块化的单元是切面。切面支持跨多种类型和对象的关注点（例如事务管理）的模块化。（这种关注点在 AOP 文献中通常被称为“横切”关注点。）</p>\n<p>Spring 的关键组件之一是 AOP 框架。虽然 Spring IoC 容器不依赖 AOP（这意味着如果您不想使用 AOP，则无需使用 AOP），AOP 补充了 Spring IoC 以提供非常强大的中间件解决方案。</p>\n<p>AOP 在 Spring Framework 中用于：</p>\n<ol>\n<li>提供声明式事务管理。（TransactionalRepositoryProxyPostProcessor#postProcess）</li>\n<li>让用户实现自定义切面，用 AOP 补充他们对 OOP 的使用。\n<ul>\n<li>常用于接口日志打印</li>\n<li>或是基于接口的权限校验、数据预处理等操作</li>\n</ul>\n</li>\n</ol>\n<p>下面我们就学习下spring中aop的用法, 不用死记硬背, 了解收藏, 遇到会用即可。</p>\n<h2 id=\"二、aop的概念\"> 二、AOP的概念</h2>\n<h2 id=\"_2-1-aspect-切面\"> 2.1 Aspect 切面</h2>\n<p>Aspect: 方面、切面,如果说oop是看整体,那么aop就是看一个面。</p>\n<p>Spring 提供两种使用方法,1是基于注解方式, 2是基于配置方式。</p>\n<h3 id=\"_2-1-1-注解方式\"> 2.1.1 注解方式</h3>\n<p>Spring会从被@Aspect修饰的类中读取切面信息,为符合条件的对象生成代理类。</p>\n<div><pre><code><span>@Aspect</span>\n<span>public</span> <span>class</span> <span>NotVeryUsefulAspect</span> <span>{</span><span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"_2-1-2-xml方式\"> 2.1.2 xml方式</h3>\n<div><pre><code><span><span><span>&lt;</span><span>aop:</span>config</span><span>></span></span>\n    <span><span><span>&lt;</span><span>aop:</span>aspect</span> <span>id</span><span><span>=</span><span>\"</span>myAspect<span>\"</span></span> <span>ref</span><span><span>=</span><span>\"</span>aBean<span>\"</span></span><span>></span></span>\n        ...\n    <span><span><span>&lt;/</span><span>aop:</span>aspect</span><span>></span></span>\n<span><span><span>&lt;/</span><span>aop:</span>config</span><span>></span></span>\n\n<span><span><span>&lt;</span>bean</span> <span>id</span><span><span>=</span><span>\"</span>aBean<span>\"</span></span> <span>class</span><span><span>=</span><span>\"</span>...<span>\"</span></span><span>></span></span>\n    ...\n<span><span><span>&lt;/</span>bean</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>因为目前使用SpringBoot的较多,使用配置的方式的比较少,本文也只介绍使用注解方式。如果想了解xml配置方式,可以参考官方文档。</p>\n<h2 id=\"_2-2-join-point-连接点\"> 2.2 Join point 连接点</h2>\n<p>Join point(连接点)：程序执行过程中的一个点，例如方法的执行或异常的处理。在 Spring AOP 中，一个连接点总是代表一个方法执行。</p>\n<p><img src=\"https://img.springlearn.cn/blog/e05790e9d53efc94f952730851f7f669.png\" alt=\"\" loading=\"lazy\"></p>\n<ul>\n<li>JoinPoint 基类方法，可以获取如下信息。</li>\n<li>ProceedingJoinPoint 公开proceed(..)方法，以支持@AJ方面的around通知</li>\n</ul>\n<p>我们可以通过连接点来获取当前执行的方法的信息,具体如下。</p>\n<h3 id=\"_2-2-1-接口声明\"> 2.2.1 接口声明</h3>\n<div><pre><code><span>public</span> <span>interface</span> <span>JoinPoint</span> <span>{</span>\n    <span>// 当前执行的切面,或者说是拦截的方法</span>\n    <span>String</span> <span>toString</span><span>(</span><span>)</span><span>;</span>\n    <span>// 连接点的缩写字符串表示形式。</span>\n    <span>String</span> <span>toShortString</span><span>(</span><span>)</span><span>;</span>\n    <span>// 连接点的扩展字符串表示形式。</span>\n    <span>String</span> <span>toLongString</span><span>(</span><span>)</span><span>;</span>\n    <span>// 返回当前正在执行的对象。这将始终与@this切入点指示符匹配的对象相同。</span>\n    <span>// 除非您特别需要这种反射访问，否则您应该使用this切入点指示符来获取该对象，</span>\n    <span>// 以获得更好的静态类型和性能。 当当前没有可用的执行对象时返回null。</span>\n    <span>// 这包括在静态上下文中出现的所有连接点。</span>\n    <span>// 当前正在执行的对象(如果不可用则为空——例如静态上下文)</span>\n    <span>Object</span> <span>getThis</span><span>(</span><span>)</span><span>;</span>\n    <span>// 返回目标对象。这将始终与目标切入点指示符匹配的对象相同。</span>\n    <span>Object</span> <span>getTarget</span><span>(</span><span>)</span><span>;</span>\n    <span>// 这个连接点上的参数</span>\n    <span>Object</span><span>[</span><span>]</span> <span>getArgs</span><span>(</span><span>)</span><span>;</span>\n    <span>// 连接的执行方法签名,可以获取到执行的方法</span>\n    <span>Signature</span> <span>getSignature</span><span>(</span><span>)</span><span>;</span>\n    <span>// 源代码信息，比如获取执行的行，列，文件名。</span>\n    <span>SourceLocation</span> <span>getSourceLocation</span><span>(</span><span>)</span><span>;</span>\n    <span>// 当前的拦击的类型。</span>\n    <span>String</span> <span>getKind</span><span>(</span><span>)</span><span>;</span>\n    <span>// 封装此连接点的静态部分的对象。</span>\n    <span>StaticPart</span> <span>getStaticPart</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>    \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><h3 id=\"_2-2-2-实践\"> 2.2.2 实践</h3>\n<div><pre><code><span>@Component</span>\n<span>public</span> <span>class</span> <span>AopDemoService</span> <span>{</span>\n\n    <span>public</span> <span>void</span> <span>say</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"AopDemoService Say:\"</span> <span>+</span> name<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>@Aspect</span>\n<span>@Component</span>\n<span>public</span> <span>class</span> <span>AspectManager</span> <span>{</span>\n\n    <span>@Before</span><span>(</span>value <span>=</span> <span>\"within(AopDemoService)\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>beforeArgs</span><span>(</span><span>JoinPoint</span> joinPoint<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"拦截器逻辑----------------------------\"</span><span>)</span><span>;</span>\n        <span>// execution(void learn.spring.aop.AopDemoService.say(String))</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>joinPoint<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// execution(AopDemoService.say(..))</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>joinPoint<span>.</span><span>toShortString</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// execution(public void learn.spring.aop.AopDemoService.say(java.lang.String))</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>joinPoint<span>.</span><span>toLongString</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// method-execution</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>joinPoint<span>.</span><span>getKind</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// [Jay]</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Arrays</span><span>.</span><span>toString</span><span>(</span>joinPoint<span>.</span><span>getArgs</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>\n        <span>// learn.spring.aop.AopDemoService@73c9e8e8</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>joinPoint<span>.</span><span>getTarget</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// learn.spring.aop.AopDemoService@73c9e8e8</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>joinPoint<span>.</span><span>getThis</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// void learn.spring.aop.AopDemoService.say(String)</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>joinPoint<span>.</span><span>getSignature</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// execution(void learn.spring.aop.AopDemoService.say(String))</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>joinPoint<span>.</span><span>getStaticPart</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint$SourceLocationImpl@582a764a</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>joinPoint<span>.</span><span>getSourceLocation</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"拦截器逻辑----------------------------\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n<span>}</span>\n\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><h2 id=\"_2-3-advice-通知\"> 2.3 Advice 通知</h2>\n<p>通过使用 Advice通知,我们可以在方法执行的各个阶段植入我们的自定义代码。具体有哪些通知呢？可以参考下文。</p>\n<table>\n<thead>\n<tr>\n<th>注解</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>@Before</td>\n<td>前置通知, 在方法执行之前执行</td>\n</tr>\n<tr>\n<td>@After</td>\n<td>后置通知, 在方法执行之后执行</td>\n</tr>\n<tr>\n<td>@AfterRunning</td>\n<td>返回通知 在方法返回结果之后执行</td>\n</tr>\n<tr>\n<td>@AfterThrowing</td>\n<td>异常通知在方法抛出异常之后</td>\n</tr>\n<tr>\n<td>@Around</td>\n<td>环绕通知, 围绕着方法执行</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_2-3-1-before-advice\"> 2.3.1  Before Advice</h3>\n<p>通过前置请求,我们可以获取请求参数和请求方法等信息。\n在连接点之前运行但不能阻止执行流继续到连接点的通知（除非它抛出异常）。</p>\n<div><pre><code><span>@Aspect</span>\n<span>@Component</span>\n<span>public</span> <span>class</span> <span>AspectManager</span> <span>{</span>\n    <span>@Before</span><span>(</span>value <span>=</span> <span>\"within(AopDemoService)\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>beforeArgs</span><span>(</span><span>JoinPoint</span> joinPoint<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"拦截器逻辑----------------------------\"</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>joinPoint<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>joinPoint<span>.</span><span>toShortString</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>joinPoint<span>.</span><span>toLongString</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>joinPoint<span>.</span><span>getKind</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Arrays</span><span>.</span><span>toString</span><span>(</span>joinPoint<span>.</span><span>getArgs</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>joinPoint<span>.</span><span>getTarget</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>joinPoint<span>.</span><span>getThis</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>joinPoint<span>.</span><span>getSignature</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>joinPoint<span>.</span><span>getStaticPart</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>joinPoint<span>.</span><span>getSourceLocation</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"拦截器逻辑----------------------------\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h3 id=\"_2-3-2-after-advice\"> 2.3.2  After Advice</h3>\n<p>在连接点正常完成后运行的通知（例如，如果方法返回而没有引发异常）。【注意如果方法异常,则不执行】\n@After注释声明的方法,会在连接方法执行退出时(finally)执行。所以必须准备好处理正常和异常返回条件。它通常用于释放资源和类似的目的。下面的例子展示了如何使用after finally advice:</p>\n<div><pre><code><span>import</span> <span>org<span>.</span>aspectj<span>.</span>lang<span>.</span>annotation<span>.</span></span><span>Aspect</span><span>;</span>\n<span>import</span> <span>org<span>.</span>aspectj<span>.</span>lang<span>.</span>annotation<span>.</span></span><span>After</span><span>;</span>\n\n<span>@Aspect</span>\n<span>public</span> <span>class</span> <span>AfterFinallyExample</span> <span>{</span>\n\n    <span>@After</span><span>(</span><span>\"com.xyz.myapp.CommonPointcuts.dataAccessOperation()\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>doReleaseLock</span><span>(</span><span>)</span> <span>{</span>\n        <span>// ...</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id=\"_2-3-3-afterrunning-advice\"> 2.3.3  AfterRunning Advice</h3>\n<p>无论连接点以何种方式退出（正常或异常返回），都将运行建议。</p>\n<p>有时，您需要在通知体中访问返回的实际值。你可以使用@ afterreturns的形式绑定返回值来获得访问权限，如下例所示:</p>\n<p>返回属性中使用的名称必须与advice方法中的参数名称对应。当方法执行返回时，返回值作为对应的参数值传递给advice方法。返回子句还将匹配限制为仅那些返回指定类型值的方法执行(在本例中为Object，它匹配任何返回值)。</p>\n<p>请注意，在返回advice之后使用时，不可能返回一个完全不同的引用。</p>\n<div><pre><code><span>@Aspect</span>\n<span>@Component</span>\n<span>public</span> <span>class</span> <span>AopArgsMatchProcessor</span> <span>{</span>\n\n    <span>@AfterReturning</span><span>(</span>value <span>=</span> <span>\"within(Person) &amp;&amp; args(name,age)\"</span><span>,</span> returning <span>=</span> <span>\"retValue\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>beforeArgs</span><span>(</span><span>Integer</span> age<span>,</span> <span>String</span> name<span>,</span> <span>String</span> retValue<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"拦截器逻辑----------------------------\"</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"入参name:\"</span> <span>+</span> name<span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"入参age:\"</span> <span>+</span> age<span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"返回值:\"</span> <span>+</span> value<span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"拦截器逻辑----------------------------\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id=\"_2-3-4-afterthrowing-advice\"> 2.3.4 AfterThrowing Advice</h3>\n<p>如果方法因抛出异常而退出，则运行。</p>\n<p>当匹配的方法执行通过抛出异常退出时，将运行通知。你可以使用@ afterthrows注释来声明它，如下面的例子所示:</p>\n<p>通常，您希望仅在抛出给定类型的异常时才运行通知，而且通常还需要在通知主体中访问抛出的异常。您可以使用throw属性来限制匹配(如果需要，则使用Throwable作为异常类型)，并将抛出的异常绑定到通知参数。下面的例子展示了如何做到这一点:</p>\n<div><pre><code><span>import</span> <span>org<span>.</span>aspectj<span>.</span>lang<span>.</span>annotation<span>.</span></span><span>Aspect</span><span>;</span>\n<span>import</span> <span>org<span>.</span>aspectj<span>.</span>lang<span>.</span>annotation<span>.</span></span><span>AfterThrowing</span><span>;</span>\n\n<span>@Aspect</span>\n<span>public</span> <span>class</span> <span>AfterThrowingExample</span> <span>{</span>\n\n    <span>@AfterThrowing</span><span>(</span>\n        pointcut<span>=</span><span>\"com.xyz.myapp.CommonPointcuts.dataAccessOperation()\"</span><span>,</span>\n        throwing<span>=</span><span>\"ex\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>doRecoveryActions</span><span>(</span><span>DataAccessException</span> ex<span>)</span> <span>{</span>\n        <span>// ...</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id=\"_2-3-5-around-advice\"> 2.3.5  Around Advice</h3>\n<p>Around Advice: 环绕通知</p>\n<p>Around通知在匹配方法的执行过程中“绕”运行。它有机会在方法运行之前和之后都做一些工作，并决定什么时候、如何，甚至是否真的要运行方法。如果您需要以线程安全的方式在方法执行前后共享状态(例如，启动和停止计时器)，则经常使用Around通知。</p>\n<p>环绕通知可以在方法调用之前和之后执行自定义行为。它还负责选择是继续到连接点还是通过返回自己的返回值或抛出异常来缩短建议的方法执行。</p>\n<div><pre><code>    <span>@Around</span><span>(</span><span>\"controllerLog()&amp;&amp; @annotation(logAnnotation)\"</span><span>)</span>\n    <span>public</span> <span>Object</span> <span>doAround</span><span>(</span><span>ProceedingJoinPoint</span> joinPoint<span>,</span> <span>ApiOperation</span> logAnnotation<span>)</span> <span>{</span>\n        <span>try</span> <span>{</span>\n            <span>Long</span> startTime <span>=</span> <span>this</span><span>.</span><span>doBefore</span><span>(</span>joinPoint<span>,</span> logAnnotation<span>)</span><span>;</span>\n            <span>Object</span> result <span>=</span> joinPoint<span>.</span><span>proceed</span><span>(</span><span>)</span><span>;</span>\n            <span>this</span><span>.</span><span>doAfterReturning</span><span>(</span>result<span>,</span> logAnnotation<span>,</span> startTime<span>)</span><span>;</span>\n            <span>return</span> result<span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>Throwable</span> var5<span>)</span> <span>{</span>\n            <span>return</span> <span>this</span><span>.</span><span>doAfterThrowingAdvice</span><span>(</span>joinPoint<span>,</span> logAnnotation<span>,</span> var5<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id=\"_2-4-pointcut-切面表达式\"> 2.4 Pointcut 切面表达式</h2>\n<p>切面,Pointcut 配合 Advice 才有用, Advice只有在遇到Pointcut指定的类或者方法上才会执行。spring中Pointcut提供了灵活的匹配表达式。我们日常中最常用的就是 <code>execution</code> ,但是实际上匹配表达式还包含了很多的注解。如下图表格。这些你都见过吗?</p>\n<table>\n<thead>\n<tr>\n<th>注解</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>within</td>\n<td>拦截指定类及指定包下所有的类</td>\n</tr>\n<tr>\n<td>@within</td>\n<td>拦截被指定注解修饰的类</td>\n</tr>\n<tr>\n<td>this</td>\n<td>拦截指定的类型</td>\n</tr>\n<tr>\n<td>bean</td>\n<td>执行的bean中，支持模糊匹配 <code>*Service</code></td>\n</tr>\n<tr>\n<td>args</td>\n<td>拦截指定参数类型的方法，同时可以传递参数</td>\n</tr>\n<tr>\n<td>@annotation</td>\n<td>拦截带指定注解的方法</td>\n</tr>\n<tr>\n<td>@args</td>\n<td>拦截方法入参被中@args指定的注解(入参只能有一个)</td>\n</tr>\n<tr>\n<td>@target</td>\n<td>拦截方法被指定注解修饰的方法</td>\n</tr>\n<tr>\n<td>execution</td>\n<td>表达式详情见下文</td>\n</tr>\n</tbody>\n</table>\n<p>这里先做简单的介绍,因为内容较多,更多的实践见下文,三,切面表达式最佳实践。</p>\n<h3 id=\"_2-4-1-注解匹配\"> 2.4.1 注解匹配</h3>\n<p>凡是带@符号的，都是用来匹配注解的，如下，这些注解，可以用来匹配注解修饰的: 类，方法，参数.</p>\n<ul>\n<li>@within，拦截被指定注解，修饰的类</li>\n</ul>\n<p>如下 <code>AopDemoService</code> 被 <code>@CustomerAnnotation</code> 修饰,所以就可以使用 <code>@within</code> 匹配到。</p>\n<div><pre><code><span>@Component</span>\n<span>@CustomerAnnotation</span>\n<span>public</span> <span>class</span> <span>AopDemoService</span> <span>{</span>\n    <span>public</span> <span>void</span> <span>say</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"AopDemoService Say:\"</span> <span>+</span> name<span>)</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span>void</span> <span>sayAge</span><span>(</span><span>Integer</span> age<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"AopDemoSerCue sayAge:\"</span> <span>+</span> age<span>)</span><span>;</span>\n    <span>}</span>\n    <span>public</span> <span>void</span> <span>sayPerson</span><span>(</span><span>Person</span> person<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"AopDemoSerCue Person:\"</span> <span>+</span> person<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n<span>@Aspect</span>\n<span>@Component</span>\n<span>public</span> <span>class</span> <span>AspectConfig</span> <span>{</span>\n    <span>@After</span><span>(</span>value <span>=</span> <span>\"@within(CustomerAnnotation)\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>matchAnno</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"CustomerAnnotation @within 修饰类\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>    \n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><ul>\n<li>@target，跟@within是一样的,功能。不同的是,@within会把被注解标记的目标对象及其子类的方法都进行拦截,而@target只会拦截目标对象。</li>\n<li>@annotation，拦截被指定注解，修饰的方法</li>\n</ul>\n<div><pre><code><span>@Aspect</span>\n<span>@Component</span>\n<span>public</span> <span>class</span> <span>AspectConfig</span> <span>{</span>\n    <span>@After</span><span>(</span>value <span>=</span> <span>\"within(AopDemoService) &amp;&amp; @annotation(CustomerAnnotation)\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>matchAnnoAn</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"CustomerAnnotation @target 任意连接点\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n<span>@Component</span>\n<span>public</span> <span>class</span> <span>AopDemoService</span> <span>{</span>\n    <span>@CustomerAnnotation</span>\n    <span>public</span> <span>void</span> <span>say</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"AopDemoService Say:\"</span> <span>+</span> name<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><ul>\n<li>@args，拦截方法入参被中@args指定的注解</li>\n</ul>\n<p>如下 Person 被 <code>@CustomerAnnotation</code> 修饰,故可以使用 <code>@args</code> 匹配到</p>\n<div><pre><code><span>@CustomerAnnotation</span>\n<span>public</span> <span>class</span> <span>Person</span> <span>{</span>\n<span>}</span>\n<span>@Component</span>\n<span>public</span> <span>class</span> <span>AopDemoService</span> <span>{</span>\n    <span>public</span> <span>void</span> <span>sayPerson</span><span>(</span><span>Person</span> person<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"AopDemoSerCue Person:\"</span> <span>+</span> person<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n<span>@Aspect</span>\n<span>@Component</span>\n<span>public</span> <span>class</span> <span>AspectConfig</span> <span>{</span>\n    <span>@Before</span><span>(</span>value <span>=</span> <span>\"this(AopDemoService) &amp;&amp;  @args(customerAnnotation)\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>matchAnno1</span><span>(</span><span>CustomerAnnotation</span> customerAnnotation<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"CustomerAnnotation @args 修饰方法参数\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h3 id=\"_2-4-2-参数传递\"> 2.4.2 参数传递</h3>\n<p>使用 <code>args</code> 可以将参数进行传递。如下。</p>\n<div><pre><code><span>@Component</span>\n<span>public</span> <span>class</span> <span>AopDemoService</span> <span>{</span>\n    <span>public</span> <span>void</span> <span>sayPerson</span><span>(</span><span>Person</span> person<span>,</span> <span>Integer</span> count<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"AopDemoSerCue \"</span> <span>+</span> count <span>+</span> <span>\"Person:\"</span> <span>+</span> person<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n<span>@Aspect</span>\n<span>@Component</span>\n<span>public</span> <span>class</span> <span>AspectConfig</span> <span>{</span>\n    <span>// args中是变量名,会自动从当前方法的入参中找到这个变量名对应的实际类型。</span>\n    <span>@After</span><span>(</span>value <span>=</span> <span>\"within(AopDemoService) &amp;&amp; args(person,age,..)\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>args</span><span>(</span><span>Person</span> person<span>,</span> <span>Integer</span> age<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"指定匹配参数\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>    \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h2 id=\"_2-5-target-object-目标、代理类\"> 2.5 Target object 目标、代理类</h2>\n<p>一个或多个切面建议的对象。也称为“目标对象”。由于 Spring AOP 是使用运行时代理实现的，因此该对象始终是代理对象。</p>\n<div><pre><code><span>public</span> <span>abstract</span> <span>class</span> <span>AbstractAdvisingBeanPostProcessor</span> <span>extends</span> <span>ProxyProcessorSupport</span> <span>implements</span> <span>BeanPostProcessor</span> <span>{</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>Object</span> <span>postProcessAfterInitialization</span><span>(</span><span>Object</span> bean<span>,</span> <span>String</span> beanName<span>)</span> <span>{</span>\n      <span>.</span><span>.</span><span>.</span>\n      <span>if</span> <span>(</span><span>isEligible</span><span>(</span>bean<span>,</span> beanName<span>)</span><span>)</span> <span>{</span>\n        <span>ProxyFactory</span> proxyFactory <span>=</span> <span>prepareProxyFactory</span><span>(</span>bean<span>,</span> beanName<span>)</span><span>;</span>\n        <span>if</span> <span>(</span><span>!</span>proxyFactory<span>.</span><span>isProxyTargetClass</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n          <span>evaluateProxyInterfaces</span><span>(</span>bean<span>.</span><span>getClass</span><span>(</span><span>)</span><span>,</span> proxyFactory<span>)</span><span>;</span>\n        <span>}</span>\n        proxyFactory<span>.</span><span>addAdvisor</span><span>(</span><span>this</span><span>.</span>advisor<span>)</span><span>;</span>\n        <span>customizeProxyFactory</span><span>(</span>proxyFactory<span>)</span><span>;</span>\n        <span>return</span> proxyFactory<span>.</span><span>getProxy</span><span>(</span><span>getProxyClassLoader</span><span>(</span><span>)</span><span>)</span><span>;</span>\n      <span>}</span>\n\n      <span>// No proxy needed.</span>\n      <span>return</span> bean<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h2 id=\"_2-6-aop-proxy-代理工具\"> 2.6 AOP proxy 代理工具</h2>\n<p>由 AOP 框架创建的对象。在 Spring Framework 中，AOP 代理是 JDK 动态代理或 CGLIB 代理。</p>\n<p>我们可以使用下面这段代码, 来生成代理类, 而具体是用jdk还是cglib这些就交给底层自己去选择。更多的实践, 看下文。</p>\n<div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>testProxy</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>AopTest</span> aopTest <span>=</span> <span>new</span> <span>AopTest</span><span>(</span><span>)</span><span>;</span>\n        <span>ProxyFactory</span> proxyFactory <span>=</span> <span>new</span> <span>ProxyFactory</span><span>(</span>aopTest<span>)</span><span>;</span>\n      \n        proxyFactory<span>.</span><span>addAdvisor</span><span>(</span>defaultPointcutAdvisor<span>)</span><span>;</span>\n        proxyFactory<span>.</span><span>setExposeProxy</span><span>(</span><span>true</span><span>)</span><span>;</span>\n        <span>AopTest</span> proxy <span>=</span> <span>(</span><span>AopTest</span><span>)</span> proxyFactory<span>.</span><span>getProxy</span><span>(</span><span>)</span><span>;</span>\n        proxy<span>.</span><span>test</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>以上是spring aop的主要</p>\n<h2 id=\"三、切面表达式最佳实践\"> 三、切面表达式最佳实践</h2>\n<p>以下代码,全部已上传仓库: <code>https://github.com/lxchinesszz/spring-learning</code></p>\n<h2 id=\"_3-1-within\"> 3.1 within</h2>\n<h3 id=\"_3-1-1-api说明\"> 3.1.1 API说明</h3>\n<ol>\n<li>精确匹配类名</li>\n<li>模糊匹配包中所有的类</li>\n<li>模糊匹配包中所有的带Impl后缀的</li>\n</ol>\n<h3 id=\"_3-1-2-目录\"> 3.1.2 目录</h3>\n<div><pre><code>└── WithinMatchProcessor\n    ├── AopWithinMatchProcessor.java\n    ├── CokeImpl.java\n    ├── Water.java\n    └── readme.md\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"_3-1-3-拦截代码\"> 3.1.3 拦截代码</h3>\n<div><pre><code><span>@Aspect</span>\n<span>@Component</span>\n<span>public</span> <span>class</span> <span>AopWithinMatchProcessor</span> <span>{</span>\n\n    <span>/**\n     * 精确匹配类名\n     */</span>\n    <span>@Pointcut</span><span>(</span><span>\"within(spring.learning.aop.WithinMatchProcessor.Water)\"</span><span>)</span>\n    <span>private</span> <span>void</span> <span>matchClassName</span><span>(</span><span>)</span> <span>{</span>\n    <span>}</span>\n\n    <span>/**\n     * 模糊匹配包中所有的类\n     */</span>\n    <span>@Pointcut</span><span>(</span><span>\"within(spring.learning.aop.WithinMatchProcessor.*)\"</span><span>)</span>\n    <span>private</span> <span>void</span> <span>matchAllClassFromPackage</span><span>(</span><span>)</span> <span>{</span>\n    <span>}</span>\n\n    <span>/**\n     * 模糊匹配包中所有的带Impl后缀的\n     */</span>\n    <span>@Pointcut</span><span>(</span><span>\"within(spring.learning.aop.WithinMatchProcessor.*Impl)\"</span><span>)</span>\n    <span>private</span> <span>void</span> <span>matchClassFromPackage</span><span>(</span><span>)</span> <span>{</span>\n    <span>}</span>\n\n\n    <span>@Before</span><span>(</span><span>\"matchClassName()\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>beforeMatchClassName</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"--------精确匹配类名-------\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Before</span><span>(</span><span>\"matchAllClassFromPackage()\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>beforeMatchAllClassFormPackage</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"--------模糊匹配包中所有的类-------\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Before</span><span>(</span><span>\"matchClassFromPackage()\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>beforeMatchClassFromPackage</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"--------模糊匹配包中所有的带Impl后缀的-------\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><h2 id=\"_3-2-within\"> 3.2 @within</h2>\n<h3 id=\"_3-2-1-api说明\"> 3.2.1 API说明</h3>\n<p>拦截被指定注解标注的类</p>\n<h3 id=\"_3-2-2-目录\"> 3.2.2 目录</h3>\n<div><pre><code>├── AnnotationWithinMatchProcessor\n│   ├── AopAnnotationWithinMatchProcessor.java\n│   ├── Log.java\n│   ├── Sprite.java\n│   └── readme.md\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id=\"_3-2-3-拦截代码\"> 3.2.3 拦截代码</h3>\n<div><pre><code><span>@Log</span><span>(</span>tag <span>=</span> <span>\"SpriteLog\"</span><span>)</span>\n<span>@Component</span>\n<span>public</span> <span>class</span> <span>Sprite</span> <span>{</span>\n\n    <span>public</span> <span>void</span> <span>drink</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"空参数\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>drink</span><span>(</span><span>Integer</span> age<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"age\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n\n    <span>public</span> <span>String</span> <span>name</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>\"Sprite.name\"</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>toCalculate</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>0</span> <span>/</span> <span>0</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>@Aspect</span>\n<span>@Component</span>\n<span>public</span> <span>class</span> <span>AopAnnotationWithinMatchProcessor</span> <span>{</span>\n\n\n    <span>/**\n     * 注意可以将注解,放到参数中,此时@within()会将参数入参名去找到注解的类型\n     * 凡是被Log标记的类,都会被拦截\n     *\n     * @param spriteLog 注解\n     */</span>\n    <span>@Before</span><span>(</span><span>\"@within(spriteLog)\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>beforeAnnotationMatch</span><span>(</span><span>Log</span> spriteLog<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"--------拦截被Log修饰类的所有方法\"</span> <span>+</span> spriteLog<span>.</span><span>tag</span><span>(</span><span>)</span> <span>+</span> <span>\"-------\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n\n    <span>/**\n     * 返回值\n     *\n     * @param value     返回值\n     * @param spriteLog 注解\n     */</span>\n    <span>@AfterReturning</span><span>(</span>value <span>=</span> <span>\"@within(spriteLog)\"</span><span>,</span> returning <span>=</span> <span>\"value\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>afterReturningAnnotationMatch</span><span>(</span><span>String</span> value<span>,</span> <span>Log</span> spriteLog<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"afterReturningAnnotationMatch返回值:\"</span> <span>+</span> value <span>+</span> <span>\",注解:\"</span> <span>+</span> spriteLog<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 拦截异常\n     *\n     * @param e         异常\n     * @param spriteLog 拦截日志\n     */</span>\n    <span>@AfterThrowing</span><span>(</span>value <span>=</span> <span>\"@within(spriteLog)\"</span><span>,</span> throwing <span>=</span> <span>\"e\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>AfterThrowingAnnotationMatch</span><span>(</span><span>Exception</span> e<span>,</span> <span>Log</span> spriteLog<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>e<span>.</span><span>getMessage</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br></div></div><h2 id=\"_3-3-this\"> 3.3 this</h2>\n<h3 id=\"_3-3-1-api说明\"> 3.3.1 API说明</h3>\n<p>拦截指定的类</p>\n<h3 id=\"_3-3-2-目录\"> 3.3.2 目录</h3>\n<div><pre><code>├── ThisMatchProcessor\n│   ├── AopThisMatchProcessor.java\n│   ├── ThisPerson.java\n│   └── readme.md\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"_3-3-3-拦截代码\"> 3.3.3 拦截代码</h3>\n<div><pre><code><span>@Aspect</span>\n<span>@Component</span>\n<span>public</span> <span>class</span> <span>AopThisMatchProcessor</span> <span>{</span>\n\n    <span>@Before</span><span>(</span>value <span>=</span> <span>\"this(ThisPerson)\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>thisMatch</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"--------------ThisPerson------------\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id=\"_3-4-args\"> 3.4 args</h2>\n<h3 id=\"_3-4-1-api说明\"> 3.4.1 API说明</h3>\n<div><pre><code><span>@Component</span>\n<span>public</span> <span>class</span> <span>Person</span> <span>{</span>\n\n    <span>public</span> <span>String</span> <span>info</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>\n        <span>return</span> <span>\"姓名：\"</span> <span>+</span> name<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>String</span> <span>info</span><span>(</span><span>String</span> name<span>,</span> <span>Integer</span> age<span>)</span> <span>{</span>\n        <span>return</span> <span>\"姓名：\"</span> <span>+</span> name <span>+</span> <span>\",年龄:\"</span> <span>+</span> age<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>Person类中有两个info方法,但是入参不一样,假如要拦截指定入参的方法时候,就可以使用args</p>\n<h3 id=\"_3-4-2-目录\"> 3.4.2 目录</h3>\n<div><pre><code>├── ArgsMatchProcessor\n│   ├── AopArgsMatchProcessor.java\n│   ├── Person.java\n│   └── readme.md\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"_3-4-3-拦截代码\"> 3.4.3 拦截代码</h3>\n<p>可以看到args 和 within可以通过&amp;&amp;来进行,联合匹配。另外可以通过returning方法指定方法的返回值。但是注意，类型要和要拦截的方法的返回类型匹配。否则会报错。</p>\n<div><pre><code><span>@Aspect</span>\n<span>@Component</span>\n<span>public</span> <span>class</span> <span>AopArgsMatchProcessor</span> <span>{</span>\n\n    <span>@AfterReturning</span><span>(</span>value <span>=</span> <span>\"within(Person) &amp;&amp; args(name,age)\"</span><span>,</span> returning <span>=</span> <span>\"value\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>beforeArgs</span><span>(</span><span>Integer</span> age<span>,</span> <span>String</span> name<span>,</span> <span>String</span> value<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"拦截器逻辑----------------------------\"</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"入参name:\"</span> <span>+</span> name<span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"入参age:\"</span> <span>+</span> age<span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"返回值:\"</span> <span>+</span> value<span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"拦截器逻辑----------------------------\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id=\"_3-5-annotation\"> 3.5 @annotation</h2>\n<h3 id=\"_3-5-1-api说明\"> 3.5.1 API说明</h3>\n<p>拦截被指定注解标记的方法。</p>\n<h3 id=\"_3-5-2-目录\"> 3.5.2 目录</h3>\n<div><pre><code>├── AnnotationMethodMatchProcessor\n│   ├── AopAnnotationMethodMatchProcessor.java\n│   ├── LogMethod.java\n│   └── Main.java\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"_3-5-3-代码\"> 3.5.3 代码</h3>\n<div><pre><code><span>@Aspect</span>\n<span>@Component</span>\n<span>public</span> <span>class</span> <span>AopAnnotationMethodMatchProcessor</span> <span>{</span>\n\n\n    <span>@Before</span><span>(</span>value <span>=</span> <span>\"@annotation(logMethod) &amp;&amp; args(args)\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>annotationMethodMatch</span><span>(</span><span>LogMethod</span> logMethod<span>,</span> <span>String</span> args<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"注解方法匹配\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id=\"_3-6-args\"> 3.6 @args</h2>\n<h3 id=\"_3-6-1-api说明\"> 3.6.1 API说明</h3>\n<p>拦截方法中入参被@args指定注解的方法。</p>\n<h3 id=\"_3-6-2-目录\"> 3.6.2 目录</h3>\n<div><pre><code>├── AnnotationArgsMatchProcessor\n│   ├── AopAnnotationArgsMatchProcessor.java\n│   ├── Apple.java\n│   ├── Fruit.java\n│   ├── Orange.java\n│   └── Teacher.java\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id=\"_3-6-3-代码\"> 3.6.3 代码</h3>\n<p>注意当出现以下异常说明aop声明的拦截范围太广泛了，导致了一些不能拦截的类被拦截从而报错了，此时只用缩小拦截的范围即可</p>\n<div><pre><code> Cannot subclass final class org.springframework.boot.autoconfigure.AutoConfigurationPackages$BasePackages\n</code></pre>\n<div><span>1</span><br></div></div><p>缩小拦截范围如下使用this拦截指定类型</p>\n<div><pre><code><span>@Aspect</span>\n<span>@Component</span>\n<span>public</span> <span>class</span> <span>AopAnnotationArgsMatchProcessor</span> <span>{</span>\n\n    <span>@Before</span><span>(</span>value <span>=</span> <span>\"@args(fruit) &amp;&amp; this(Teacher)\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>annotationMethodMatch</span><span>(</span><span>Fruit</span> fruit<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"拦截被Fruit+tag:\"</span><span>+</span>fruit<span>.</span><span>tag</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id=\"_3-7-execution\"> 3.7 execution</h2>\n<h3 id=\"_3-7-1-api说明\"> 3.7.1 API说明</h3>\n<p>execution()是最常用的切点函数，其语法如下所示：</p>\n<p><code>execution(&lt;修饰符模式&gt;? &lt;返回类型模式&gt; &lt;方法名模式&gt;(&lt;参数模式&gt;) &lt;异常模式&gt;?) 除了返回类型模式、方法名模式和参数模式外，其它项都是可选的</code></p>\n<table>\n<thead>\n<tr>\n<th>表达式</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>execution(public * *(..))</td>\n<td>匹配所有目标类的public方法</td>\n</tr>\n<tr>\n<td>execution(* *Test(..))</td>\n<td>匹配目标类所有以To为后缀的方法</td>\n</tr>\n<tr>\n<td>execution(<em>spring.learning.Water.</em>(..))</td>\n<td>匹配Water接口所有方法</td>\n</tr>\n<tr>\n<td>execution(<em>spring.learning.Water+.</em>(..))</td>\n<td>匹配Water接口以及实现类中所有方法(包括Water接口中没有的方法)</td>\n</tr>\n<tr>\n<td>execution(* spring.learning.*(..))</td>\n<td>匹配spring.learning包下所有的类所有方法</td>\n</tr>\n<tr>\n<td>execution(* spring.learning..*(..))</td>\n<td>匹配spring.learning包及其子孙包下所有的类所有方法</td>\n</tr>\n<tr>\n<td>execution(* spring..*.<em>Dao.find</em>(..))</td>\n<td>匹配包名前缀为spring的任何包下类名后缀为Dao的方法，方法名必须以find为前缀</td>\n</tr>\n<tr>\n<td>execution(* info(String,Integer))</td>\n<td>匹配info方法中,第一个参数是String,第二个Integer的方法</td>\n</tr>\n<tr>\n<td>execution(* info(String,*)))</td>\n<td>匹配info方法中,第一个参数是String,第二个任意类型</td>\n</tr>\n<tr>\n<td>execution(* info(String,..)))</td>\n<td>匹配info方法中,第一个参数是String,后面任意参数</td>\n</tr>\n<tr>\n<td>execution(* info(Object+)))</td>\n<td>匹配info方法中,方法拥有一个入参，且入参是Object类型或该类的子类</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"四、编程式aop\"> 四、编程式AOP</h2>\n<p>spring的aop功能如此强大, 难道只能用来写业务吗? 相信如果你要用aop这么灵活的东西来写业务代码，一定会被喷的。\n因为太灵活了, 如果你不说，可能没人会发现，哎这块代码竟然有一个植入了切面逻辑。</p>\n<p><img src=\"https://img.soogif.com/jI6uiyFLIYMscPWSlfL3TlYupYUQmAMg.gif?scope=mdnice\" alt=\"\" loading=\"lazy\"></p>\n<p>所以我们学习这么多的, 终极目的是做中间件的开发, 这么强大的功能, 不好好利用,那不是亏了吗。就比如说aop,\n这不就是java代理的增强吗? 要你自己做代理，你还要兼容jdk和cglib的场景，我们直接用spring的aop模块它不香吗?</p>\n<p>所以下面我们学习如果编程是使用spring的aop能力。</p>\n<div><pre><code><span>ProxyFactory</span> factory <span>=</span> <span>new</span> <span>ProxyFactory</span><span>(</span>myBusinessInterfaceImpl<span>)</span><span>;</span>\nfactory<span>.</span><span>addAdvice</span><span>(</span>myMethodInterceptor<span>)</span><span>;</span>\nfactory<span>.</span><span>addAdvisor</span><span>(</span>myAdvisor<span>)</span><span>;</span>\n<span>MyBusinessInterface</span> tb <span>=</span> <span>(</span><span>MyBusinessInterface</span><span>)</span> factory<span>.</span><span>getProxy</span><span>(</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id=\"_4-1-advice-通知\"> 4.1 Advice 通知</h2>\n<p>这种方法就跟代理一样，advice就好比jdk代理中的 <code>InvocationHandler</code>，是否需要执行，要看拦截器中如何处理。</p>\n<ul>\n<li><code>ProxyFactory proxyFactory = new ProxyFactory(aopTest)</code></li>\n<li><code>proxyFactory.addAdvice()</code></li>\n</ul>\n<p>注意这种方法获取的代理类是针对所有的代理对象的方法。如果你想使用匹配的方式去精确的制定要连接那个方法，就不要这样使用。你要用 <code>Advisor</code>。</p>\n<div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>test1</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>AopTest</span> aopTest <span>=</span> <span>new</span> <span>AopTest</span><span>(</span><span>)</span><span>;</span>\n        <span>// 原始对象hashCode:124407148</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"原始对象hashCode:\"</span> <span>+</span> aopTest<span>.</span><span>hashCode</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>ProxyFactory</span> proxyFactory <span>=</span> <span>new</span> <span>ProxyFactory</span><span>(</span>aopTest<span>)</span><span>;</span>\n        proxyFactory<span>.</span><span>addAdvice</span><span>(</span><span>new</span> <span>MethodBeforeAdvice</span><span>(</span><span>)</span> <span>{</span>\n            <span>@Override</span>\n            <span>public</span> <span>void</span> <span>before</span><span>(</span><span>Method</span> method<span>,</span> <span>Object</span><span>[</span><span>]</span> args<span>,</span> <span>Object</span> target<span>)</span> <span>throws</span> <span>Throwable</span> <span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>method<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\"开始执行前\"</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n        proxyFactory<span>.</span><span>addAdvice</span><span>(</span><span>new</span> <span>MethodInterceptor</span><span>(</span><span>)</span> <span>{</span>\n            <span>@Override</span>\n            <span>public</span> <span>Object</span> <span>invoke</span><span>(</span><span>MethodInvocation</span> invocation<span>)</span> <span>throws</span> <span>Throwable</span> <span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>invocation<span>.</span><span>getMethod</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\"真正开始执行\"</span><span>)</span><span>;</span>\n                <span>return</span> invocation<span>.</span><span>proceed</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n        <span>AopTest</span> proxy <span>=</span> <span>(</span><span>AopTest</span><span>)</span> proxyFactory<span>.</span><span>getProxy</span><span>(</span><span>)</span><span>;</span>\n        <span>// 代理对象hashCode:-487413954</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"代理对象hashCode:\"</span> <span>+</span> proxy<span>.</span><span>hashCode</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>TargetSource</span> targetSource <span>=</span> proxyFactory<span>.</span><span>getTargetSource</span><span>(</span><span>)</span><span>;</span>\n        <span>// 获取原始对象hashCode:124407148</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"获取原始对象hashCode:\"</span> <span>+</span> targetSource<span>.</span><span>getTarget</span><span>(</span><span>)</span><span>.</span><span>hashCode</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// test开始执行前</span>\n        <span>// test真正开始执行</span>\n        <span>// test</span>\n        proxy<span>.</span><span>test</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><h2 id=\"_4-2-advisor\"> 4.2 Advisor</h2>\n<p>Advisor 是支持切面匹配的, 通过设置切入点,来生成代理类。我们只用向 <code>DefaultPointcutAdvisor</code> 设置你的切面匹配器和 <code>Advice</code> 就行。如下。</p>\n<div><pre><code><span>DefaultPointcutAdvisor</span> defaultPointcutAdvisor <span>=</span> <span>new</span> <span>DefaultPointcutAdvisor</span><span>(</span><span>)</span><span>;</span>\ndefaultPointcutAdvisor<span>.</span><span>setPointcut</span><span>(</span><span>new</span> <span>NameMatchMethodPointcut</span><span>(</span><span>)</span><span>)</span><span>;</span>\ndefaultPointcutAdvisor<span>.</span><span>setAdvice</span><span>(</span><span>.</span><span>.</span><span>.</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>如果我们想自定义切面,那么只用实现这个切面的方法</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>Pointcut</span> <span>{</span>\n\n\t<span>/**\n\t * Return the ClassFilter for this pointcut.\n\t * @return the ClassFilter (never {@code null})\n\t */</span>\n\t<span>ClassFilter</span> <span>getClassFilter</span><span>(</span><span>)</span><span>;</span>\n\n\t<span>/**\n\t * Return the MethodMatcher for this pointcut.\n\t * @return the MethodMatcher (never {@code null})\n\t */</span>\n\t<span>MethodMatcher</span> <span>getMethodMatcher</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>当然spring中给我们提供了很多可用的工具,但是为了加深大家的体感，这里我们就自定一个切面处理类吧。如下实例。</p>\n<div><pre><code>  <span>DefaultPointcutAdvisor</span> defaultPointcutAdvisor <span>=</span> <span>new</span> <span>DefaultPointcutAdvisor</span><span>(</span><span>)</span><span>;</span>\n        defaultPointcutAdvisor<span>.</span><span>setPointcut</span><span>(</span><span>new</span> <span>Pointcut</span><span>(</span><span>)</span> <span>{</span>\n            <span>@Override</span>\n            <span>public</span> <span>ClassFilter</span> <span>getClassFilter</span><span>(</span><span>)</span> <span>{</span>\n                <span>// 类都匹配</span>\n                <span>return</span> <span>ClassFilter</span><span>.</span>TRUE<span>;</span>\n            <span>}</span>\n\n            <span>@Override</span>\n            <span>public</span> <span>MethodMatcher</span> <span>getMethodMatcher</span><span>(</span><span>)</span> <span>{</span>\n                <span>return</span> <span>new</span> <span>MethodMatcher</span><span>(</span><span>)</span> <span>{</span>\n                    <span>@Override</span>\n                    <span>public</span> <span>boolean</span> <span>matches</span><span>(</span><span>Method</span> method<span>,</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> targetClass<span>)</span> <span>{</span>\n                        <span>return</span> method<span>.</span><span>getName</span><span>(</span><span>)</span><span>.</span><span>equals</span><span>(</span><span>\"test007\"</span><span>)</span><span>;</span>\n                    <span>}</span>\n\n                    <span>@Override</span>\n                    <span>public</span> <span>boolean</span> <span>isRuntime</span><span>(</span><span>)</span> <span>{</span>\n                        <span>return</span> <span>false</span><span>;</span>\n                    <span>}</span>\n\n                    <span>@Override</span>\n                    <span>public</span> <span>boolean</span> <span>matches</span><span>(</span><span>Method</span> method<span>,</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> targetClass<span>,</span> <span>Object</span><span>.</span><span>.</span><span>.</span> args<span>)</span> <span>{</span>\n                        <span>return</span> method<span>.</span><span>getName</span><span>(</span><span>)</span><span>.</span><span>equals</span><span>(</span><span>\"test007\"</span><span>)</span><span>;</span>\n                    <span>}</span>\n                <span>}</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n        defaultPointcutAdvisor<span>.</span><span>setAdvice</span><span>(</span><span>new</span> <span>MethodInterceptor</span><span>(</span><span>)</span> <span>{</span>\n            <span>@Override</span>\n            <span>public</span> <span>Object</span> <span>invoke</span><span>(</span><span>MethodInvocation</span> invocation<span>)</span> <span>throws</span> <span>Throwable</span> <span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>invocation<span>.</span><span>getMethod</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\"真正开始执行\"</span><span>)</span><span>;</span>\n                <span>return</span> invocation<span>.</span><span>proceed</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><p>如果你绝的麻烦你也可以直接使用spring提供的切面工具。比如我们可以使用方法匹配工具。</p>\n<div><pre><code>        <span>DefaultPointcutAdvisor</span> defaultPointcutAdvisor <span>=</span> <span>new</span> <span>DefaultPointcutAdvisor</span><span>(</span><span>)</span><span>;</span>\n        <span>NameMatchMethodPointcut</span> nameMatchMethodPointcut <span>=</span> <span>new</span> <span>NameMatchMethodPointcut</span><span>(</span><span>)</span><span>;</span>\n        nameMatchMethodPointcut<span>.</span><span>setMappedName</span><span>(</span><span>\"test007\"</span><span>)</span><span>;</span>\n        nameMatchMethodPointcut<span>.</span><span>setClassFilter</span><span>(</span><span>ClassFilter</span><span>.</span>TRUE<span>)</span><span>;</span>\n        defaultPointcutAdvisor<span>.</span><span>setPointcut</span><span>(</span>nameMatchMethodPointcut<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>然后执行下面代码获取代理类对象。</p>\n<div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>test2</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>AopTest</span> aopTest <span>=</span> <span>new</span> <span>AopTest</span><span>(</span><span>)</span><span>;</span>\n        <span>ProxyFactory</span> proxyFactory <span>=</span> <span>new</span> <span>ProxyFactory</span><span>(</span>aopTest<span>)</span><span>;</span>\n      \n        proxyFactory<span>.</span><span>addAdvisor</span><span>(</span>defaultPointcutAdvisor<span>)</span><span>;</span>\n        proxyFactory<span>.</span><span>setExposeProxy</span><span>(</span><span>true</span><span>)</span><span>;</span>\n        <span>AopTest</span> proxy <span>=</span> <span>(</span><span>AopTest</span><span>)</span> proxyFactory<span>.</span><span>getProxy</span><span>(</span><span>)</span><span>;</span>\n        proxy<span>.</span><span>test</span><span>(</span><span>)</span><span>;</span>\n        <span>// 只拦截test007</span>\n        proxy<span>.</span><span>test007</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>像这样的工具还有非常的多,毕竟Spring中切面非常的灵活,所以工具就非常的多。这个没比较都一一都掌握,了解就行。方便以后我们自己造轮子使用。但是如果你想了解的话,那就敬请期待下一课堂吧。</p>\n<p><strong>最后,都看到这里了,最后如果这篇文章,对你有所帮助,请点个关注,交个朋友。</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/9e7a3d6be0b037aa72c573cb91fa2e30.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://img.springlearn.cn/blog/b8f74de10af99991e3fc73632eeeb190.png",
      "date_published": "2022-09-04T13:51:11.000Z",
      "date_modified": "2023-02-08T03:23:43.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Spring Framework"
      ]
    },
    {
      "title": "第07篇:Converter SPI类型转换",
      "url": "https://java.springlearn.cn/learn/spring/core07/",
      "id": "https://java.springlearn.cn/learn/spring/core07/",
      "content_html": "<p><img src=\"https://img-blog.csdnimg.cn/img_convert/aa1d259419ff268edc2fe3088f940556.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>公众号</strong>: 西魏陶渊明<br/>\n<strong>CSDN</strong>: <a href=\"https://springlearn.blog.csdn.net/?type=blog\" title=\"https://springlearn.blog.csdn.net\" target=\"_blank\" rel=\"noopener noreferrer\">https://springlearn.blog.csdn.net</a><br/></p>\n<blockquote>\n<p>天下代码一大抄, 抄来抄去有提高, 看你会抄不会抄！</p>\n</blockquote>\n<p>[toc]</p>\n<h2 id=\"一、前言\"> 一、前言</h2>\n<p>本篇文章中的内容,非常的小众,虽然在实际开发中,基本上不会有使用的场景,但是在Spring中却无处不在的知识点。因为我们是学习Spring,所以我们最好了解一下。</p>\n<p>本篇文章,主要学习两个东西。第一个是类型转换, 第二个是格式化输出。</p>\n<h2 id=\"_1-1-类型转换\"> 1.1 类型转换</h2>\n<p>类型转换,比如说Long类型转换Date、String类型转换Long类型。\n在实际的开发中我们可能直接使用 <code>BeanUtils.copy()</code> 或者其他三方工具来实现,但其实Spring已经提供了这种的接口能力了。我们只需要下面这样就可以了。</p>\n<p>如下演示,将Long类型转Date。</p>\n<div><pre><code><span>@SpringBootApplication</span>\n<span>public</span> <span>class</span> <span>Application</span> <span>{</span>\n\n    <span>// 注册一个转换器,目标由Long转Date</span>\n    <span>public</span> <span>static</span> <span>class</span> <span>LongToDateConvert</span> <span>implements</span> <span>Converter</span><span><span>&lt;</span><span>Long</span><span>,</span> <span>Date</span><span>></span></span> <span>{</span>\n        <span>@Override</span>\n        <span>public</span> <span>Date</span> <span>convert</span><span>(</span><span>Long</span> source<span>)</span> <span>{</span>\n            <span>return</span> <span>new</span> <span>Date</span><span>(</span>source<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>@Bean</span><span>(</span><span>\"customerConvert\"</span><span>)</span>\n    <span>public</span> <span>ConversionServiceFactoryBean</span> <span>customerConvert</span><span>(</span><span>)</span> <span>{</span>\n        <span>ConversionServiceFactoryBean</span> conversionServiceFactoryBean <span>=</span> <span>new</span> <span>ConversionServiceFactoryBean</span><span>(</span><span>)</span><span>;</span>\n        conversionServiceFactoryBean<span>.</span><span>setConverters</span><span>(</span><span>Collections</span><span>.</span><span>singleton</span><span>(</span><span>new</span> <span>LongToDateConvert</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>\n        <span>return</span> conversionServiceFactoryBean<span>;</span>\n    <span>}</span>\n<span>}</span>\n<span>@SpringBootTest</span>\n<span>@TestConfiguration</span>\n<span>public</span> <span>class</span> <span>SpringConvertTest</span> <span>{</span>\n\n    <span>@Autowired</span>\n    <span>@Qualifier</span><span>(</span><span>\"customerConvert\"</span><span>)</span>\n    <span>private</span> <span>ConversionService</span> conversionService<span>;</span>\n\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>test</span><span>(</span><span>)</span> <span>{</span>\n        <span>// 直接使用即可。</span>\n        <span>Date</span> convert <span>=</span> conversionService<span>.</span><span>convert</span><span>(</span><span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>,</span> <span>Date</span><span>.</span><span>class</span><span>)</span><span>;</span>\n        <span>// Mon Oct 17 21:38:07 CST 2022</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>convert<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><p>举一反三,通过上面的接口能力,我们还能实现更多的使用场景。如上我们只实现了1:1的转换,其还可以1:N、N:N,更多的内容下面会讲。</p>\n<h2 id=\"_1-2-格式化输出\"> 1.2 格式化输出</h2>\n<p>什么是格式化输出,往往只针对的是文本类型。</p>\n<ol>\n<li>对象类型转文本类型</li>\n<li>文本类型转对象类型</li>\n</ol>\n<p>所以格式化是围绕String进行的,在格式化这方面最典型的一个案例就是国际化。</p>\n<p>同样的文本,针对不同国家地域展示为当地的语言类型。\n下面我们看他的接口定义。</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>Formatter</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>extends</span> <span>Printer</span><span><span>&lt;</span><span>T</span><span>></span></span><span>,</span> <span>Parser</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>{</span>\n<span>}</span>\n\n<span>@FunctionalInterface</span>\n<span>public</span> <span>interface</span> <span>Printer</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>{</span>\n  <span>// 对象类型,转换String类型,支持国际化</span>\n\t<span>String</span> <span>print</span><span>(</span><span>T</span> object<span>,</span> <span>Locale</span> locale<span>)</span><span>;</span>\n<span>}</span>\n<span>@FunctionalInterface</span>\n<span>public</span> <span>interface</span> <span>Parser</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>{</span>\n  <span>// String类型转换泛型,支持国际化</span>\n\t<span>T</span> <span>parse</span><span>(</span><span>String</span> text<span>,</span> <span>Locale</span> locale<span>)</span> <span>throws</span> <span>ParseException</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>下面我们看详细的内容。</p>\n<h2 id=\"二、converter-类型转换\"> 二、Converter 类型转换</h2>\n<p>Spring 3 引入了一个core.convert提供通用类型转换系统的包。系统定义了一个 SPI 来实现类型转换逻辑和一个 API 来在运行时执行类型转换。在 Spring 容器中，您可以使用此系统作为实现的替代PropertyEditor方案，将外部化的 bean 属性值字符串转换为所需的属性类型。您还可以在应用程序中需要类型转换的任何地方使用公共 API。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/e434654f83434c08d5fe5c04bb2f493d.png\" alt=\"\" loading=\"lazy\"></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">接口</th>\n<th style=\"text-align:left\">介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Converter</td>\n<td style=\"text-align:left\">单一的类型转换,从泛型 S -&gt; T</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ConverterFactory</td>\n<td style=\"text-align:left\">按照官方的描述是,具有层次的转换,从泛型 S -&gt; 转换成 R 的子类,实现一对多个类型的转换</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">GenericConverter</td>\n<td style=\"text-align:left\">前面是一对多，一对一,这个是多对多</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ConditionalGenericConverter</td>\n<td style=\"text-align:left\">在前者的基础上,添加上条件判断,符合条件才进行转换</td>\n</tr>\n</tbody>\n</table>\n<p>下面我们来以此看下,每个接口的</p>\n<h2 id=\"_2-1-converter\"> 2.1 Converter</h2>\n<h3 id=\"_2-1-1-接口定义\"> 2.1.1 接口定义</h3>\n<div><pre><code>package org.springframework.core.convert.converter;\n\npublic interface Converter&lt;S, T&gt; {\n\n    T convert(S source);\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>这个接口非常的简单,没什么好解释的。我们要创建自己的转换器，只用实现Converter接口就可以了。</p>\n<h3 id=\"_2-1-2-接口功能\"> 2.1.2 接口功能</h3>\n<p>实现从 S，向 T 的泛型转换，Spring提供了很多内置的转换,如下示例。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/c8d837bbb35e0881eb6ef53422e7bd5a.png\" alt=\"\" loading=\"lazy\"></p>\n<p>Spring默认提供了很多的默认实现,下面我们看一个简单的实现。看下面的源码,感觉Spring是真的用心呀。</p>\n<ul>\n<li>on、true、1、yes 都会转换成 true</li>\n<li>off、false、0、no 都会转换成 false</li>\n</ul>\n<div><pre><code><span>final</span> <span>class</span> <span>StringToBooleanConverter</span> <span>implements</span> <span>Converter</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Boolean</span><span>></span></span> <span>{</span>\n    <span>private</span> <span>static</span> <span>final</span> <span>Set</span><span><span>&lt;</span><span>String</span><span>></span></span> trueValues <span>=</span> <span>new</span> <span>HashSet</span><span>(</span><span>8</span><span>)</span><span>;</span>\n    <span>private</span> <span>static</span> <span>final</span> <span>Set</span><span><span>&lt;</span><span>String</span><span>></span></span> falseValues <span>=</span> <span>new</span> <span>HashSet</span><span>(</span><span>8</span><span>)</span><span>;</span>\n\n    <span>StringToBooleanConverter</span><span>(</span><span>)</span> <span>{</span>\n    <span>}</span>\n\n    <span>@Nullable</span>\n    <span>public</span> <span>Boolean</span> <span>convert</span><span>(</span><span>String</span> source<span>)</span> <span>{</span>\n        <span>String</span> value <span>=</span> source<span>.</span><span>trim</span><span>(</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span>value<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n            <span>return</span> <span>null</span><span>;</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            value <span>=</span> value<span>.</span><span>toLowerCase</span><span>(</span><span>)</span><span>;</span>\n            <span>if</span> <span>(</span>trueValues<span>.</span><span>contains</span><span>(</span>value<span>)</span><span>)</span> <span>{</span>\n                <span>return</span> <span>Boolean</span><span>.</span>TRUE<span>;</span>\n            <span>}</span> <span>else</span> <span>if</span> <span>(</span>falseValues<span>.</span><span>contains</span><span>(</span>value<span>)</span><span>)</span> <span>{</span>\n                <span>return</span> <span>Boolean</span><span>.</span>FALSE<span>;</span>\n            <span>}</span> <span>else</span> <span>{</span>\n                <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>\"Invalid boolean value '\"</span> <span>+</span> source <span>+</span> <span>\"'\"</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>static</span> <span>{</span>\n        trueValues<span>.</span><span>add</span><span>(</span><span>\"true\"</span><span>)</span><span>;</span>\n        trueValues<span>.</span><span>add</span><span>(</span><span>\"on\"</span><span>)</span><span>;</span>\n        trueValues<span>.</span><span>add</span><span>(</span><span>\"yes\"</span><span>)</span><span>;</span>\n        trueValues<span>.</span><span>add</span><span>(</span><span>\"1\"</span><span>)</span><span>;</span>\n        falseValues<span>.</span><span>add</span><span>(</span><span>\"false\"</span><span>)</span><span>;</span>\n        falseValues<span>.</span><span>add</span><span>(</span><span>\"off\"</span><span>)</span><span>;</span>\n        falseValues<span>.</span><span>add</span><span>(</span><span>\"no\"</span><span>)</span><span>;</span>\n        falseValues<span>.</span><span>add</span><span>(</span><span>\"0\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><h2 id=\"_2-2-converterfactory\"> 2.2 ConverterFactory</h2>\n<p>ConverterFactory 跟 Converter的区别在于, ConverterFactory 提供一个泛化的接口。根据泛型获取自己的转换类。但是前提是Converter要具备能处理返回接口的能力。以此来处理 1 对 N的转换。</p>\n<h3 id=\"_2-2-1-接口定义\"> 2.2.1 接口定义</h3>\n<div><pre><code><span>package</span> <span>org<span>.</span>springframework<span>.</span>core<span>.</span>convert<span>.</span>converter</span><span>;</span>\n\n<span>public</span> <span>interface</span> <span>ConverterFactory</span><span><span>&lt;</span><span>S</span><span>,</span> <span>R</span><span>></span></span> <span>{</span>\n\n    <span><span>&lt;</span><span>T</span> <span>extends</span> <span>R</span><span>></span></span> <span>Converter</span><span><span>&lt;</span><span>S</span><span>,</span> <span>T</span><span>></span></span> <span>getConverter</span><span>(</span><span>Class</span><span><span>&lt;</span><span>T</span><span>></span></span> targetType<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>可以看到泛型是从 S -&gt; R, getConverter 泛型方法允许 <code>&lt;T extends R&gt;</code> 返回 T</p>\n<h3 id=\"_2-2-2-接口功能\"> 2.2.2 接口功能</h3>\n<div><pre><code><span>package</span> <span>org<span>.</span>springframework<span>.</span>core<span>.</span>convert<span>.</span>support</span><span>;</span>\n\n<span>final</span> <span>class</span> <span>StringToEnumConverterFactory</span> <span>implements</span> <span>ConverterFactory</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Enum</span><span>></span></span> <span>{</span>\n\n    <span>public</span> <span><span>&lt;</span><span>T</span> <span>extends</span> <span>Enum</span><span>></span></span> <span>Converter</span><span><span>&lt;</span><span>String</span><span>,</span> <span>T</span><span>></span></span> <span>getConverter</span><span>(</span><span>Class</span><span><span>&lt;</span><span>T</span><span>></span></span> targetType<span>)</span> <span>{</span>\n        <span>return</span> <span>new</span> <span>StringToEnumConverter</span><span>(</span>targetType<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>private</span> <span>final</span> <span>class</span> <span>StringToEnumConverter</span><span><span>&lt;</span><span>T</span> <span>extends</span> <span>Enum</span><span>></span></span> <span>implements</span> <span>Converter</span><span><span>&lt;</span><span>String</span><span>,</span> <span>T</span><span>></span></span> <span>{</span>\n\n        <span>private</span> <span>Class</span><span><span>&lt;</span><span>T</span><span>></span></span> enumType<span>;</span>\n\n        <span>public</span> <span>StringToEnumConverter</span><span>(</span><span>Class</span><span><span>&lt;</span><span>T</span><span>></span></span> enumType<span>)</span> <span>{</span>\n            <span>this</span><span>.</span>enumType <span>=</span> enumType<span>;</span>\n        <span>}</span>\n        <span>// 将泛化类型</span>\n        <span>public</span> <span>T</span> <span>convert</span><span>(</span><span>String</span> source<span>)</span> <span>{</span>\n            <span>return</span> <span>(</span><span>T</span><span>)</span> <span>Enum</span><span>.</span><span>valueOf</span><span>(</span><span>this</span><span>.</span>enumType<span>,</span> source<span>.</span><span>trim</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>通过 <code>&lt;T exends R&gt;</code> 的限定, 最终实现 1 : N 的转换。</p>\n<h2 id=\"_2-3-genericconverter\"> 2.3 GenericConverter</h2>\n<ul>\n<li>Converter 处理 1:1的转换</li>\n<li>ConverterFactory 处理 1:N的转换</li>\n<li>GenericConverter 处理里 N: N的转换</li>\n</ul>\n<p>下面我们看接口</p>\n<h3 id=\"_2-3-1-接口定义\"> 2.3.1 接口定义</h3>\n<ul>\n<li>getConvertibleTypes 返回了一个集合,而集合中每个key都是一个键值对。就支持 N:N 了。</li>\n</ul>\n<div><pre><code>package org.springframework.core.convert.converter;\n\npublic interface GenericConverter {\n\n    public Set&lt;ConvertiblePair&gt; getConvertibleTypes();\n\n    Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);\n}\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>getConvertibleTypes() 是一个Set集合。可以看到ConvertiblePair是成对的,只要转换双方是包含在这set结合中,都会调用这个进行转换。</p>\n<div><pre><code><span>final</span> <span>class</span> <span>ConvertiblePair</span> <span>{</span>\n\t\t<span>private</span> <span>final</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> sourceType<span>;</span>\n\t\t<span>private</span> <span>final</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> targetType<span>;</span>\n<span>}</span>  \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>意味着一个转换器可以处理多种类型的转换。</p>\n<h3 id=\"_2-3-2-接口功能\"> 2.3.2 接口功能</h3>\n<p>下面举一个例子</p>\n<div><pre><code> <span>@Data</span>\n    <span>public</span> <span>static</span> <span>class</span> <span>SourceOne</span> <span>{</span>\n        <span>private</span> <span>String</span> name<span>;</span>\n    <span>}</span>\n\n    <span>@Data</span>\n    <span>public</span> <span>static</span> <span>class</span> <span>TargetOne</span> <span>{</span>\n        <span>private</span> <span>String</span> name<span>;</span>\n    <span>}</span>\n\n    <span>@Data</span>\n    <span>public</span> <span>static</span> <span>class</span> <span>TargetTwo</span> <span>{</span>\n        <span>private</span> <span>String</span> name<span>;</span>\n    <span>}</span>\n\n\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>test</span><span>(</span><span>)</span> <span>{</span>\n        <span>ApplicationConversionService</span> applicationConversionService <span>=</span> <span>new</span> <span>ApplicationConversionService</span><span>(</span><span>)</span><span>;</span>\n        <span>GenericConverter</span> genericConverter <span>=</span> <span>new</span> <span>GenericConverter</span><span>(</span><span>)</span> <span>{</span>\n            <span>@Override</span>\n            <span>public</span> <span>Set</span><span><span>&lt;</span><span>ConvertiblePair</span><span>></span></span> <span>getConvertibleTypes</span><span>(</span><span>)</span> <span>{</span>\n                <span>Set</span><span><span>&lt;</span><span>ConvertiblePair</span><span>></span></span> paris <span>=</span> <span>new</span> <span>HashSet</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n                paris<span>.</span><span>add</span><span>(</span><span>new</span> <span>ConvertiblePair</span><span>(</span><span>SourceOne</span><span>.</span><span>class</span><span>,</span> <span>TargetOne</span><span>.</span><span>class</span><span>)</span><span>)</span><span>;</span>\n                paris<span>.</span><span>add</span><span>(</span><span>new</span> <span>ConvertiblePair</span><span>(</span><span>SourceOne</span><span>.</span><span>class</span><span>,</span> <span>TargetTwo</span><span>.</span><span>class</span><span>)</span><span>)</span><span>;</span>\n\n                <span>return</span> paris<span>;</span>\n            <span>}</span>\n\n            <span>@Override</span>\n            <span>public</span> <span>Object</span> <span>convert</span><span>(</span><span>Object</span> source<span>,</span> <span>TypeDescriptor</span> sourceType<span>,</span> <span>TypeDescriptor</span> targetType<span>)</span> <span>{</span>\n                <span>if</span> <span>(</span>sourceType<span>.</span><span>getObjectType</span><span>(</span><span>)</span><span>.</span><span>equals</span><span>(</span><span>SourceOne</span><span>.</span><span>class</span><span>)</span> <span>&amp;&amp;</span> targetType<span>.</span><span>getObjectType</span><span>(</span><span>)</span><span>.</span><span>equals</span><span>(</span><span>TargetOne</span><span>.</span><span>class</span><span>)</span><span>)</span> <span>{</span>\n                    <span>TargetOne</span> targetOne <span>=</span> <span>new</span> <span>TargetOne</span><span>(</span><span>)</span><span>;</span>\n                    targetOne<span>.</span><span>setName</span><span>(</span><span>(</span><span>(</span><span>SourceOne</span><span>)</span> source<span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\"-> TargetOne\"</span><span>)</span><span>;</span>\n                    <span>return</span> targetOne<span>;</span>\n                <span>}</span>\n                <span>if</span> <span>(</span>sourceType<span>.</span><span>getObjectType</span><span>(</span><span>)</span><span>.</span><span>equals</span><span>(</span><span>SourceOne</span><span>.</span><span>class</span><span>)</span> <span>&amp;&amp;</span> targetType<span>.</span><span>getObjectType</span><span>(</span><span>)</span><span>.</span><span>equals</span><span>(</span><span>TargetTwo</span><span>.</span><span>class</span><span>)</span><span>)</span> <span>{</span>\n                    <span>TargetTwo</span> <span>TargetTwo</span> <span>=</span> <span>new</span> <span>TargetTwo</span><span>(</span><span>)</span><span>;</span>\n                    <span>TargetTwo</span><span>.</span><span>setName</span><span>(</span><span>(</span><span>(</span><span>SourceOne</span><span>)</span> source<span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\"-> TargetTwo\"</span><span>)</span><span>;</span>\n                    <span>return</span> <span>TargetTwo</span><span>;</span>\n                <span>}</span>\n                <span>return</span> <span>null</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>;</span>\n        applicationConversionService<span>.</span><span>addConverter</span><span>(</span>genericConverter<span>)</span><span>;</span>\n        <span>SourceOne</span> sourceOne <span>=</span> <span>new</span> <span>SourceOne</span><span>(</span><span>)</span><span>;</span>\n        sourceOne<span>.</span><span>setName</span><span>(</span><span>\"Jay\"</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>applicationConversionService<span>.</span><span>convert</span><span>(</span>sourceOne<span>,</span> <span>TargetOne</span><span>.</span><span>class</span><span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>applicationConversionService<span>.</span><span>convert</span><span>(</span>sourceOne<span>,</span> <span>TargetTwo</span><span>.</span><span>class</span><span>)</span><span>)</span><span>;</span>\n\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br></div></div><h2 id=\"_2-4-conditionalgenericconverter\"> 2.4 ConditionalGenericConverter</h2>\n<p>有时,你希望 Converter只有在特定条件成立时才运行，此时可以实现这个接口。这个接口是实现了 <code>GenericConverter</code> 、 <code>ConditionalConverter</code>。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/844f01a10884f95ad81f5ca066d22eb8.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_2-4-1-接口定义\"> 2.4.1 接口定义</h3>\n<div><pre><code><span>public</span> <span>interface</span> <span>ConditionalConverter</span> <span>{</span>\n\n    <span>boolean</span> <span>matches</span><span>(</span><span>TypeDescriptor</span> sourceType<span>,</span> <span>TypeDescriptor</span> targetType<span>)</span><span>;</span>\n<span>}</span>\n\n<span>public</span> <span>interface</span> <span>ConditionalGenericConverter</span> <span>extends</span> <span>GenericConverter</span><span>,</span> <span>ConditionalConverter</span> <span>{</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id=\"_2-5-spring-实践\"> 2.5 Spring 实践</h2>\n<p>ConversionService定义了一个统一的 API，用于在运行时执行类型转换逻辑。</p>\n<h3 id=\"_2-5-1-conversionservice\"> 2.5.1 ConversionService</h3>\n<div><pre><code><span>package</span> <span>org<span>.</span>springframework<span>.</span>core<span>.</span>convert</span><span>;</span>\n\n<span>public</span> <span>interface</span> <span>ConversionService</span> <span>{</span>\n    <span>// 如果sourceType的对象可以转换为targetType ，则返回true </span>\n    <span>boolean</span> <span>canConvert</span><span>(</span><span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> sourceType<span>,</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> targetType<span>)</span><span>;</span>\n    <span>// 将给定的source转换为指定的targetType 。</span>\n    <span><span>&lt;</span><span>T</span><span>></span></span> <span>T</span> <span>convert</span><span>(</span><span>Object</span> source<span>,</span> <span>Class</span><span><span>&lt;</span><span>T</span><span>></span></span> targetType<span>)</span><span>;</span>\n    <span>// 如果sourceType的对象可以转换为targetType ，则返回true</span>\n    <span>boolean</span> <span>canConvert</span><span>(</span><span>TypeDescriptor</span> sourceType<span>,</span> <span>TypeDescriptor</span> targetType<span>)</span><span>;</span>\n    <span>// 将给定的source转换为指定的targetType 。 TypeDescriptors 提供有关将发生转换的源和目标位置的附加上下文，通常是对象字段或属性位置。</span>\n    <span>Object</span> <span>convert</span><span>(</span><span>Object</span> source<span>,</span> <span>TypeDescriptor</span> sourceType<span>,</span> <span>TypeDescriptor</span> targetType<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id=\"_2-5-2-硬编码使用\"> 2.5.2 硬编码使用</h3>\n<p>如果转换失败会抛出 <code>org.springframework.core.convert.ConversionFailedException</code></p>\n<div><pre><code><span>public</span> <span>class</span> <span>ConvertTest</span> <span>{</span>\n\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>test</span><span>(</span><span>)</span><span>{</span>\n        <span>ConversionService</span> sharedInstance <span>=</span> <span>DefaultConversionService</span><span>.</span><span>getSharedInstance</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>sharedInstance<span>.</span><span>convert</span><span>(</span><span>\"1\"</span><span>,</span> <span>Boolean</span><span>.</span><span>class</span><span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>sharedInstance<span>.</span><span>convert</span><span>(</span><span>\"123\"</span><span>,</span> <span>Long</span><span>.</span><span>class</span><span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>sharedInstance<span>.</span><span>convert</span><span>(</span><span>\"1234\"</span><span>,</span> <span>Integer</span><span>.</span><span>class</span><span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>sharedInstance<span>.</span><span>convert</span><span>(</span><span>\"1235\"</span><span>,</span> <span>int</span><span>.</span><span>class</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id=\"_2-5-3-整合spring\"> 2.5.3 整合Spring</h3>\n<div><pre><code><span>@SpringBootApplication</span>\n<span>public</span> <span>class</span> <span>Application</span> <span>{</span>\n\n\n    <span>public</span> <span>static</span> <span>class</span> <span>LongToDateConvert</span> <span>implements</span> <span>Converter</span><span><span>&lt;</span><span>Long</span><span>,</span> <span>Date</span><span>></span></span> <span>{</span>\n        <span>@Override</span>\n        <span>public</span> <span>Date</span> <span>convert</span><span>(</span><span>Long</span> source<span>)</span> <span>{</span>\n            <span>return</span> <span>new</span> <span>Date</span><span>(</span>source<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>@Bean</span><span>(</span><span>\"customerConvert\"</span><span>)</span>\n    <span>public</span> <span>ConversionServiceFactoryBean</span> <span>customerConvert</span><span>(</span><span>)</span> <span>{</span>\n        <span>ConversionServiceFactoryBean</span> conversionServiceFactoryBean <span>=</span> <span>new</span> <span>ConversionServiceFactoryBean</span><span>(</span><span>)</span><span>;</span>\n        conversionServiceFactoryBean<span>.</span><span>setConverters</span><span>(</span><span>Collections</span><span>.</span><span>singleton</span><span>(</span><span>new</span> <span>LongToDateConvert</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>\n        <span>return</span> conversionServiceFactoryBean<span>;</span>\n    <span>}</span>\n<span>}</span>\n    \n<span>@SpringBootTest</span>\n<span>@TestConfiguration</span>\n<span>public</span> <span>class</span> <span>SpringConvertTest</span> <span>{</span>\n\n    <span>@Autowired</span>\n    <span>@Qualifier</span><span>(</span><span>\"customerConvert\"</span><span>)</span>\n    <span>private</span> <span>ConversionService</span> conversionService<span>;</span>\n\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>test</span><span>(</span><span>)</span> <span>{</span>\n        <span>Date</span> convert <span>=</span> conversionService<span>.</span><span>convert</span><span>(</span><span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>,</span> <span>Date</span><span>.</span><span>class</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>convert<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><h2 id=\"三、formatter-格式化输出\"> 三、Formatter 格式化输出</h2>\n<p><code>core.convert</code> 是一个通用的类型转换系统。它提供了一个统一的ConversionServiceAPI 以及一个强类型的ConverterSPI，用于实现从一种类型到另一种类型的转换逻辑。</p>\n<p>现在考虑典型客户端环境的类型转换要求，例如 Web 或桌面应用程序。在这样的环境中，您通常转换 fromString 以支持客户端回发过程，以及转换回String以支持视图呈现过程。</p>\n<p>此外，您经常需要本地化String值（国际化）。<code>core.convert Converter</code> 不直接解决此类格式要求。为了直接解决这些问题，Spring 3 引入了一个方便的SPI，它为客户端环境的实现Formatter提供了一个简单而健壮的替代方案。PropertyEditor。</p>\n<h2 id=\"_3-1-自定义formatter\"> 3.1 自定义Formatter</h2>\n<p>要想自定义Formatter我们只用实现 <code>Formatter</code> 接口即可。下面我们看他们的接口定义,就能看到。\nFormatter 跟Convert的区别是什么。</p>\n<ul>\n<li>Formatter 只支持String和对象的双向转换，适合文本格式化、国际化的处理。</li>\n<li>Converter 支持任意类型的转换</li>\n</ul>\n<div><pre><code><span>public</span> <span>interface</span> <span>Formatter</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>extends</span> <span>Printer</span><span><span>&lt;</span><span>T</span><span>></span></span><span>,</span> <span>Parser</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>{</span><span>}</span>\n<span>@FunctionalInterface</span>\n<span>public</span> <span>interface</span> <span>Printer</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>{</span>\n  <span>// 对象转String</span>\n\t<span>String</span> <span>print</span><span>(</span><span>T</span> object<span>,</span> <span>Locale</span> locale<span>)</span><span>;</span>\n<span>}</span>\n<span>@FunctionalInterface</span>\n<span>public</span> <span>interface</span> <span>Parser</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>{</span>\n\t<span>// String转对象</span>\n\t<span>T</span> <span>parse</span><span>(</span><span>String</span> text<span>,</span> <span>Locale</span> locale<span>)</span> <span>throws</span> <span>ParseException</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>如下我们自定义一个时间的转换器</p>\n<div><pre><code><span>public</span> <span>class</span> <span>DateFormatterTest</span> <span>{</span>\n\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>test</span><span>(</span><span>)</span> <span>{</span>\n        <span>DefaultFormattingConversionService</span> defaultFormattingConversionService <span>=</span> <span>new</span> <span>DefaultFormattingConversionService</span><span>(</span><span>)</span><span>;</span>\n        defaultFormattingConversionService<span>.</span><span>addFormatter</span><span>(</span><span>new</span> <span>DateFormatter</span><span>(</span><span>\"yyyy-MM-dd\"</span><span>)</span><span>)</span><span>;</span>\n        <span>Date</span> convert <span>=</span> defaultFormattingConversionService<span>.</span><span>convert</span><span>(</span><span>\"2022-10-10\"</span><span>,</span> <span>Date</span><span>.</span><span>class</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>convert<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>final</span> <span>class</span> <span>DateFormatter</span> <span>implements</span> <span>Formatter</span><span><span>&lt;</span><span>Date</span><span>></span></span> <span>{</span>\n        <span>private</span> <span>String</span> pattern<span>;</span>\n        <span>public</span> <span>DateFormatter</span><span>(</span><span>String</span> pattern<span>)</span> <span>{</span>\n            <span>this</span><span>.</span>pattern <span>=</span> pattern<span>;</span>\n        <span>}</span>\n        <span>public</span> <span>String</span> <span>print</span><span>(</span><span>Date</span> date<span>,</span> <span>Locale</span> locale<span>)</span> <span>{</span>\n            <span>if</span> <span>(</span>date <span>==</span> <span>null</span><span>)</span> <span>{</span>\n                <span>return</span> <span>\"\"</span><span>;</span>\n            <span>}</span>\n            <span>return</span> <span>getDateFormat</span><span>(</span>locale<span>)</span><span>.</span><span>format</span><span>(</span>date<span>)</span><span>;</span>\n        <span>}</span>\n        <span>public</span> <span>Date</span> <span>parse</span><span>(</span><span>String</span> formatted<span>,</span> <span>Locale</span> locale<span>)</span> <span>throws</span> <span>ParseException</span> <span>{</span>\n            <span>if</span> <span>(</span>formatted<span>.</span><span>length</span><span>(</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>\n                <span>return</span> <span>null</span><span>;</span>\n            <span>}</span>\n            <span>return</span> <span>getDateFormat</span><span>(</span>locale<span>)</span><span>.</span><span>parse</span><span>(</span>formatted<span>)</span><span>;</span>\n        <span>}</span>\n        <span>protected</span> <span>DateFormat</span> <span>getDateFormat</span><span>(</span><span>Locale</span> locale<span>)</span> <span>{</span>\n            <span>DateFormat</span> dateFormat <span>=</span> <span>new</span> <span>SimpleDateFormat</span><span>(</span><span>this</span><span>.</span>pattern<span>,</span> locale<span>)</span><span>;</span>\n            dateFormat<span>.</span><span>setLenient</span><span>(</span><span>false</span><span>)</span><span>;</span>\n            <span>return</span> dateFormat<span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><h2 id=\"_3-1-注解驱动formatter\"> 3.1 注解驱动Formatter</h2>\n<p>在Spring中很多很多功能都是可以基于注解进行驱动的，开发者不用关心底层实现，直接使用注解。就能使用很强大的工具了。下面我们实现一个注解驱动的类型转换。</p>\n<p>自定一个注解 <code>@DatePattern</code> , 将String类型,根据注解的配置最终给方法参数赋值。</p>\n<div><pre><code>    <span>public</span> <span>String</span> <span>print</span><span>(</span><span>@DatePattern</span><span>(</span>pattern <span>=</span> <span>\"yyyy-MM-dd\"</span><span>)</span> <span>Date</span> date<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>date<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>return</span> date<span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ol>\n<li>首先我们要实现这个接口。</li>\n</ol>\n<div><pre><code><span>public</span> <span>interface</span> <span>AnnotationFormatterFactory</span><span><span>&lt;</span><span>A</span> <span>extends</span> <span>Annotation</span><span>></span></span> <span>{</span>\n\n    <span>Set</span><span><span>&lt;</span><span>Class</span><span>&lt;</span><span>?</span><span>></span><span>></span></span> <span>getFieldTypes</span><span>(</span><span>)</span><span>;</span>\n\n    <span>Printer</span><span><span>&lt;</span><span>?</span><span>></span></span> <span>getPrinter</span><span>(</span><span>A</span> annotation<span>,</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> fieldType<span>)</span><span>;</span>\n\n    <span>Parser</span><span><span>&lt;</span><span>?</span><span>></span></span> <span>getParser</span><span>(</span><span>A</span> annotation<span>,</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> fieldType<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><ol start=\"2\">\n<li></li>\n</ol>\n<p>注意这里一定要用 <code>TypeDescriptor</code> 构造的方式来处理，因为只有这样才会处理注解。</p>\n<div><pre><code>   <span>@Test</span>\n    <span>public</span> <span>void</span> <span>test</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>DefaultFormattingConversionService</span> defaultFormattingConversionService <span>=</span> <span>new</span> <span>DefaultFormattingConversionService</span><span>(</span><span>)</span><span>;</span>\n        defaultFormattingConversionService<span>.</span><span>addFormatterForFieldAnnotation</span><span>(</span><span>new</span> <span>DatePatternFormatAnnotationFormatterFactory</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>Method</span> print <span>=</span> <span>getClass</span><span>(</span><span>)</span><span>.</span><span>getDeclaredMethod</span><span>(</span><span>\"print\"</span><span>,</span> <span>Date</span><span>.</span><span>class</span><span>)</span><span>;</span>\n        <span>// 注意一定要使用 TypeDescriptor 构造的方式声明才会有注解信息</span>\n        <span>for</span> <span>(</span><span>Parameter</span> parameter <span>:</span> print<span>.</span><span>getParameters</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n            <span>// true</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>new</span> <span>TypeDescriptor</span><span>(</span><span>MethodParameter</span><span>.</span><span>forParameter</span><span>(</span>parameter<span>)</span><span>)</span><span>.</span><span>hasAnnotation</span><span>(</span><span>DatePattern</span><span>.</span><span>class</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>// 通过注解的方式实现解析</span>\n        <span>Object</span> convert <span>=</span> defaultFormattingConversionService<span>.</span><span>convert</span><span>(</span><span>\"2021-12-12\"</span><span>,</span> <span>new</span> <span>TypeDescriptor</span><span>(</span><span>MethodParameter</span><span>.</span><span>forExecutable</span><span>(</span>print<span>,</span> <span>0</span><span>)</span><span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>convert<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>String</span> <span>print</span><span>(</span><span>@DatePattern</span><span>(</span>pattern <span>=</span> <span>\"yyyy-MM-dd\"</span><span>)</span> <span>Date</span> date<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>date<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>return</span> date<span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Documented</span>\n    <span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>\n    <span>@Target</span><span>(</span><span>{</span><span>ElementType</span><span>.</span>FIELD<span>,</span> <span>ElementType</span><span>.</span>PARAMETER<span>}</span><span>)</span>\n    <span>public</span> <span>@interface</span> <span>DatePattern</span> <span>{</span>\n        <span>String</span> <span>pattern</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>final</span> <span>class</span> <span>DatePatternFormatAnnotationFormatterFactory</span>\n            <span>implements</span> <span>AnnotationFormatterFactory</span><span><span>&lt;</span><span>DatePattern</span><span>></span></span> <span>{</span>\n        <span>public</span> <span>Set</span><span><span>&lt;</span><span>Class</span><span>&lt;</span><span>?</span><span>></span><span>></span></span> <span>getFieldTypes</span><span>(</span><span>)</span> <span>{</span>\n            <span>return</span> <span>new</span> <span>HashSet</span><span><span>&lt;</span><span>Class</span><span>&lt;</span><span>?</span><span>></span><span>></span></span><span>(</span><span>Arrays</span><span>.</span><span>asList</span><span>(</span><span>new</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span><span>[</span><span>]</span><span>{</span><span>Date</span><span>.</span><span>class</span><span>}</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>public</span> <span>Printer</span><span><span>&lt;</span><span>Date</span><span>></span></span> <span>getPrinter</span><span>(</span><span>DatePattern</span> annotation<span>,</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> fieldType<span>)</span> <span>{</span>\n            <span>return</span> <span>configureFormatterFrom</span><span>(</span>annotation<span>,</span> fieldType<span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>public</span> <span>Parser</span><span><span>&lt;</span><span>Date</span><span>></span></span> <span>getParser</span><span>(</span><span>DatePattern</span> annotation<span>,</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> fieldType<span>)</span> <span>{</span>\n            <span>return</span> <span>configureFormatterFrom</span><span>(</span>annotation<span>,</span> fieldType<span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>private</span> <span>Formatter</span><span><span>&lt;</span><span>Date</span><span>></span></span> <span>configureFormatterFrom</span><span>(</span><span>DatePattern</span> annotation<span>,</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> fieldType<span>)</span> <span>{</span>\n            <span>return</span> <span>new</span> <span>DateFormatter</span><span>(</span>annotation<span>.</span><span>pattern</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n    <span>public</span> <span>final</span> <span>class</span> <span>DateFormatter</span> <span>implements</span> <span>Formatter</span><span><span>&lt;</span><span>Date</span><span>></span></span> <span>{</span>\n        <span>private</span> <span>String</span> pattern<span>;</span>\n        <span>public</span> <span>DateFormatter</span><span>(</span><span>String</span> pattern<span>)</span> <span>{</span>\n            <span>this</span><span>.</span>pattern <span>=</span> pattern<span>;</span>\n        <span>}</span>\n        <span>public</span> <span>String</span> <span>print</span><span>(</span><span>Date</span> date<span>,</span> <span>Locale</span> locale<span>)</span> <span>{</span>\n            <span>if</span> <span>(</span>date <span>==</span> <span>null</span><span>)</span> <span>{</span>\n                <span>return</span> <span>\"\"</span><span>;</span>\n            <span>}</span>\n            <span>return</span> <span>getDateFormat</span><span>(</span>locale<span>)</span><span>.</span><span>format</span><span>(</span>date<span>)</span><span>;</span>\n        <span>}</span>\n        <span>public</span> <span>Date</span> <span>parse</span><span>(</span><span>String</span> formatted<span>,</span> <span>Locale</span> locale<span>)</span> <span>throws</span> <span>ParseException</span> <span>{</span>\n            <span>if</span> <span>(</span>formatted<span>.</span><span>length</span><span>(</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>\n                <span>return</span> <span>null</span><span>;</span>\n            <span>}</span>\n            <span>return</span> <span>getDateFormat</span><span>(</span>locale<span>)</span><span>.</span><span>parse</span><span>(</span>formatted<span>)</span><span>;</span>\n        <span>}</span>\n        <span>protected</span> <span>DateFormat</span> <span>getDateFormat</span><span>(</span><span>Locale</span> locale<span>)</span> <span>{</span>\n            <span>DateFormat</span> dateFormat <span>=</span> <span>new</span> <span>SimpleDateFormat</span><span>(</span><span>this</span><span>.</span>pattern<span>,</span> locale<span>)</span><span>;</span>\n            dateFormat<span>.</span><span>setLenient</span><span>(</span><span>false</span><span>)</span><span>;</span>\n            <span>return</span> dateFormat<span>;</span>\n        <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br></div></div><p><img src=\"https://img.springlearn.cn/learn_aecfc8e243edb199c726728413b1522c.gif\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>最后,都看到这里了,最后如果这篇文章,对你有所帮助,请点个关注,交个朋友。</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/9e7a3d6be0b037aa72c573cb91fa2e30.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://img.springlearn.cn/blog/b8f74de10af99991e3fc73632eeeb190.png",
      "date_published": "2022-09-04T13:51:11.000Z",
      "date_modified": "2023-02-08T03:23:43.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Spring Framework"
      ]
    },
    {
      "title": "第08篇:Data Binding类型绑定",
      "url": "https://java.springlearn.cn/learn/spring/core08/",
      "id": "https://java.springlearn.cn/learn/spring/core08/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/b8f74de10af99991e3fc73632eeeb190.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>公众号</strong>: 西魏陶渊明<br/>\n<strong>CSDN</strong>: <a href=\"https://springlearn.blog.csdn.net/?type=blog\" target=\"_blank\" rel=\"noopener noreferrer\">https://springlearn.blog.csdn.net</a><br/></p>\n<blockquote>\n<p>天下代码一大抄, 抄来抄去有提高, 看你会抄不会抄！</p>\n</blockquote>\n<p><img src=\"https://img.springlearn.cn/blog/8f3392b9badb093f9e1a6472b4a98487.gif\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"一、前言\"> 一、前言</h2>\n<h2 id=\"_1-1-什么是数据绑定\"> 1.1 什么是数据绑定?</h2>\n<p>本文我们所描述的数据绑定可以理解成。</p>\n<ol>\n<li>将结构化的数据文本, 转换成Java对象。</li>\n<li>通过Spring提供的API方式,而不通过反射的方式将属性信息,绑定到Java对象。</li>\n</ol>\n<h2 id=\"_1-2-为什么需要数据绑定api呢\"> 1.2 为什么需要数据绑定API呢?</h2>\n<p>为什么需要数据绑定呢? 因为在Spring中很多地方都使用到了数据绑定,通过提供统一的API,有以下这些好处。</p>\n<ol>\n<li>不使用反射,给开发者提供了一种更优雅的方式。</li>\n<li>逻辑业务收口,将Spring中自带的很多功能进行组合,通过一个API的方式进行业务收口,而不是要开发者自己去组装Spring已有的功能。</li>\n<li>通过提供标准的API的方式,在标准API中暴露扩展点,方便开发者二次开发,定制转换逻辑。</li>\n</ol>\n<h2 id=\"_1-3-spring中常见的数据绑定有那些\"> 1.3 Spring中常见的数据绑定有那些?</h2>\n<p>在Spring中随处可见参数的绑定如下。</p>\n<ol>\n<li>比如 <code>@RequestBody</code> 如何将参数绑定到实体对象上。</li>\n<li>应用配置信息如何通过 <code>@ConfigurationProperties</code>将参数绑定到配置实体类中</li>\n<li>参数绑定如何实现,弱类型绑定绑定。即: 下划线自动转驼峰,忽略字母大小写。 ConfigurationPropertiesBinder</li>\n</ol>\n<p>如果你有下面这些疑问,那么本篇文章将会告诉你这些问题的答案,希望对你有用。</p>\n<h2 id=\"二、数据绑定api\"> 二、数据绑定API</h2>\n<p>在回答 <code>1.3</code> 提出的问题前,我们先了解下在Spring中有那些能进行数据绑定的工具类把。</p>\n<p>为了方面演示,首先我们这里先定义一个实体。</p>\n<div><pre><code><span>@Data</span>\n<span>@ToString</span>\n<span>public</span> <span>class</span> <span>User</span><span>{</span>\n\n    <span>@NotBlank</span><span>(</span>message <span>=</span> <span>\"name 不能为空\"</span><span>)</span>\n    <span>@Size</span><span>(</span>min <span>=</span> <span>2</span><span>,</span> max <span>=</span> <span>120</span><span>,</span> message <span>=</span> <span>\"不能小于2字符,大于120字符\"</span><span>)</span>\n    <span>private</span> <span>String</span> name<span>;</span>\n\n    <span>@Max</span><span>(</span>value <span>=</span> <span>120</span><span>,</span> message <span>=</span> <span>\"年龄不能大于120\"</span><span>)</span>\n    <span>@Min</span><span>(</span>value <span>=</span> <span>0</span><span>,</span> message <span>=</span> <span>\"年龄不能小于0\"</span><span>)</span>\n    <span>private</span> <span>Integer</span> age<span>;</span>\n\n    <span>@NotEmpty</span><span>(</span>message <span>=</span> <span>\"家庭成员不能为空\"</span><span>)</span>\n    <span>@Size</span><span>(</span>max <span>=</span> <span>4</span><span>,</span> message <span>=</span> <span>\"数量不能超过4个\"</span><span>)</span>\n    <span>private</span> <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> membersFamily<span>;</span>\n\n    <span>@NotNull</span><span>(</span>message <span>=</span> <span>\"地址不能为空\"</span><span>)</span>\n    <span>private</span> <span>Address</span> address<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h2 id=\"_2-1-beanwrapper\"> 2.1 BeanWrapper</h2>\n<p>首先分享一个简单的用法,使用这种方式我们可以给一个实体对象,进行属性的绑定。（PS: 如果你看过Spring自动注入的原理,会发现也会用到<code>BeanWrapper:AbstractAutowireCapableBeanFactory#autowireBean</code> ）</p>\n<p>下面我们给User对象进行属性的绑定。</p>\n<div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>testBeanWrapper</span><span>(</span><span>)</span> <span>{</span>\n        <span>User</span> emptyUser <span>=</span> <span>new</span> <span>User</span><span>(</span><span>)</span><span>;</span>\n        <span>BeanWrapper</span> beanWrapper <span>=</span> <span>new</span> <span>BeanWrapperImpl</span><span>(</span>emptyUser<span>)</span><span>;</span>\n        beanWrapper<span>.</span><span>setPropertyValue</span><span>(</span><span>\"name\"</span><span>,</span> <span>\"Jay\"</span><span>)</span><span>;</span>\n        beanWrapper<span>.</span><span>setPropertyValue</span><span>(</span><span>\"address\"</span><span>,</span> <span>new</span> <span>Address</span><span>(</span><span>\"中国\"</span><span>)</span><span>)</span><span>;</span>\n        beanWrapper<span>.</span><span>setPropertyValue</span><span>(</span><span>new</span> <span>PropertyValue</span><span>(</span><span>\"age\"</span><span>,</span> <span>\"32\"</span><span>)</span><span>)</span><span>;</span>\n        beanWrapper<span>.</span><span>setPropertyValue</span><span>(</span><span>new</span> <span>PropertyValue</span><span>(</span><span>\"membersFamily\"</span><span>,</span> <span>Arrays</span><span>.</span><span>asList</span><span>(</span><span>\"谢霆锋\"</span><span>,</span> <span>\"孙悟空\"</span><span>)</span><span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>emptyUser<span>)</span><span>;</span>\n        <span>// User(name=Jay, age=32, membersFamily=[谢霆锋, 孙悟空], address=Address(name=中国, oneAddress=null, twoAddress=null))</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>BeanWrapper还可以针对字段进行定制转换逻辑,我们看下面这几个API.</p>\n<ul>\n<li>\n<p><code>void registerCustomEditor(Class&lt;?&gt; requiredType, PropertyEditor propertyEditor)</code> 如果不指定字段名称,可以只针对类型进行定制。</p>\n</li>\n<li>\n<p><code>void registerCustomEditor(@Nullable Class&lt;?&gt; requiredType, @Nullable String propertyPath, PropertyEditor propertyEditor)</code> 根据类型 + 字段名注册。</p>\n</li>\n<li>\n<p><code>PropertyEditor findCustomEditor(@Nullable Class&lt;?&gt; requiredType, @Nullable String propertyPath);</code> 根据类型获取属性编辑器</p>\n</li>\n</ul>\n<ol>\n<li>给name字段绑定时候,将value转换成小写。</li>\n</ol>\n<div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>testBeanWrapper2</span><span>(</span><span>)</span> <span>{</span>\n        <span>BeanWrapper</span> beanWrapper <span>=</span> <span>new</span> <span>BeanWrapperImpl</span><span>(</span><span>User</span><span>.</span><span>class</span><span>)</span><span>;</span>\n        <span>// String类型,属性是name的,将属性自动转换成小写。</span>\n        beanWrapper<span>.</span><span>registerCustomEditor</span><span>(</span><span>String</span><span>.</span><span>class</span><span>,</span> <span>\"name\"</span><span>,</span> <span>new</span> <span>PropertyEditorSupport</span><span>(</span><span>)</span> <span>{</span>\n            <span>@Override</span>\n            <span>public</span> <span>void</span> <span>setAsText</span><span>(</span><span>String</span> text<span>)</span> <span>throws</span> <span>IllegalArgumentException</span> <span>{</span>\n                <span>super</span><span>.</span><span>setValue</span><span>(</span>text<span>.</span><span>toLowerCase</span><span>(</span><span>Locale</span><span>.</span>ROOT<span>)</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n        beanWrapper<span>.</span><span>setPropertyValue</span><span>(</span><span>\"name\"</span><span>,</span> <span>\"Jay\"</span><span>)</span><span>;</span>\n        beanWrapper<span>.</span><span>setPropertyValue</span><span>(</span><span>\"address\"</span><span>,</span> <span>new</span> <span>Address</span><span>(</span><span>\"中国\"</span><span>)</span><span>)</span><span>;</span>\n        beanWrapper<span>.</span><span>setPropertyValue</span><span>(</span><span>new</span> <span>PropertyValue</span><span>(</span><span>\"age\"</span><span>,</span> <span>\"32\"</span><span>)</span><span>)</span><span>;</span>\n        beanWrapper<span>.</span><span>setPropertyValue</span><span>(</span><span>new</span> <span>PropertyValue</span><span>(</span><span>\"membersFamily\"</span><span>,</span> <span>Arrays</span><span>.</span><span>asList</span><span>(</span><span>\"谢霆锋\"</span><span>,</span> <span>\"孙悟空\"</span><span>)</span><span>)</span><span>)</span><span>;</span>\n        <span>// User(name=jay, age=32, membersFamily=[谢霆锋, 孙悟空], address=Address(name=中国, oneAddress=null, twoAddress=null))</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>beanWrapper<span>.</span><span>getWrappedInstance</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>除此之外,Spring中还有很多内置的属性编辑器,如下表格。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Class</th>\n<th style=\"text-align:left\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ByteArrayPropertyEditor</td>\n<td style=\"text-align:left\">将字符串转换为相应的字节表示形式。BeanWrapperImpl默认注册。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ClassEditor</td>\n<td style=\"text-align:left\">将表示类的字符串解析为实际类，反之亦然。当找不到类时，将引发IllegalArgumentException。默认情况下，由BeanWrapperImpl注册</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CustomBooleanEditor</td>\n<td style=\"text-align:left\">布尔属性的可自定义属性编辑器。默认情况下，由BeanWrapperImpl注册，但可以通过将其自定义实例注册为自定义编辑器来覆盖。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CustomCollectionEditor</td>\n<td style=\"text-align:left\">集合的属性编辑器，将任何源集合转换为给定的目标集合类型。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CustomDateEditor</td>\n<td style=\"text-align:left\">java.util的可定制属性编辑器。日期，支持自定义DateFormat。默认情况下未注册。用户必须根据需要以适当的格式注册。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CustomNumberEditor</td>\n<td style=\"text-align:left\">任何Number子类的可自定义属性编辑器，如Integer、Long、Float或Double。默认情况下，由BeanWrapperImpl注册，但可以通过将其自定义实例注册为自定义编辑器来覆盖。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">FileEditor</td>\n<td style=\"text-align:left\">将字符串解析为java.io。文件对象。默认情况下，由BeanWrapperImpl注册。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">InputStreamEditor</td>\n<td style=\"text-align:left\">单向属性编辑器，可以获取字符串并（通过中间的ResourceEditor和Resource）生成InputStream，以便可以将InputStriam属性直接设置为字符串。请注意，默认用法不会为您关闭InputStream。默认情况下，由BeanWrapperImpl注册。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">LocaleEditor</td>\n<td style=\"text-align:left\">可以将字符串解析为Locale对象，反之亦然（字符串格式为[language]<em>[country]</em>[variant]，与Locale的toString（）方法相同）。也接受空格作为分隔符，作为下划线的替代。默认情况下，由BeanWrapperImpl注册。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">PatternEditor</td>\n<td style=\"text-align:left\">将字符串解析为java.util.regex。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">PropertiesEditor</td>\n<td style=\"text-align:left\">可以将字符串（使用java.util.Properties类的javadoc中定义的格式格式化）转换为Properties对象。默认情况下，由BeanWrapperImpl注册。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">StringTrimmerEditor</td>\n<td style=\"text-align:left\">修剪字符串的属性编辑器。可选地，允许将空字符串转换为空值。默认情况下未注册 — 必须是用户注册的。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">URLEditor</td>\n<td style=\"text-align:left\">可以将URL的字符串表示解析为实际的URL对象。默认情况下，由BeanWrapperImpl注册。</td>\n</tr>\n</tbody>\n</table>\n<p>这些属性编辑器都比较简单,我们只分析其中的一个。<code>CustomBooleanEditor</code></p>\n<div><pre><code><span>public</span> <span>class</span> <span>CustomBooleanEditor</span> <span>extends</span> <span>PropertyEditorSupport</span> <span>{</span>\n  <span>// 当text等于on/yes/1的时候都会自动转换成布尔类型。true</span>\n  <span>@Override</span>\n\t<span>public</span> <span>void</span> <span>setAsText</span><span>(</span><span>@Nullable</span> <span>String</span> text<span>)</span> <span>throws</span> <span>IllegalArgumentException</span> <span>{</span>\n  \n\t<span>}</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id=\"_2-2-binder\"> 2.2 Binder</h2>\n<p><code>Binder</code> 可以给绑定的对象添加指定的前缀。</p>\n<div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>test2</span><span>(</span><span>)</span> <span>{</span>\n        <span>MockEnvironment</span> environment <span>=</span> <span>new</span> <span>MockEnvironment</span><span>(</span><span>)</span><span>;</span>\n        <span>// 下划线,中划线自动转驼峰，大小写不敏感</span>\n        environment<span>.</span><span>setProperty</span><span>(</span><span>\"customer.Name\"</span><span>,</span> <span>\"Jay\"</span><span>)</span><span>;</span>\n        <span>// 大小写不敏感</span>\n        environment<span>.</span><span>setProperty</span><span>(</span><span>\"customer.Age\"</span><span>,</span> <span>\"0\"</span><span>)</span><span>;</span>\n        environment<span>.</span><span>setProperty</span><span>(</span><span>\"customer.members_family\"</span><span>,</span> <span>\"周杰伦,谢霆锋,诸葛亮\"</span><span>)</span><span>;</span>\n        environment<span>.</span><span>setProperty</span><span>(</span><span>\"customer.address.name\"</span><span>,</span> <span>\"杭州\"</span><span>)</span><span>;</span>\n        environment<span>.</span><span>setProperty</span><span>(</span><span>\"customer.address.oneAddress\"</span><span>,</span> <span>\"上城区\"</span><span>)</span><span>;</span>\n        environment<span>.</span><span>setProperty</span><span>(</span><span>\"customer.address.twoAddress\"</span><span>,</span> <span>\"学区房\"</span><span>)</span><span>;</span>\n\n        <span>Binder</span> binder <span>=</span> <span>Binder</span><span>.</span><span>get</span><span>(</span>environment<span>)</span><span>;</span>\n        <span>User</span> user <span>=</span> <span>new</span> <span>User</span><span>(</span><span>)</span><span>;</span>\n        <span>// 这里我们声明所有的前缀都是customer开头</span>\n        binder<span>.</span><span>bind</span><span>(</span><span>ConfigurationPropertyName</span><span>.</span><span>of</span><span>(</span><span>\"customer\"</span><span>)</span><span>,</span> <span>Bindable</span><span>.</span><span>ofInstance</span><span>(</span>user<span>)</span><span>,</span> <span>null</span><span>)</span><span>;</span>\n        <span>// User(name=Jay, age=0, membersFamily=[周杰伦, 谢霆锋, 诸葛亮], address=Address(name=杭州, oneAddress=上城区, twoAddress=学区房))</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>user<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h2 id=\"_2-3-databinder\"> 2.3 DataBinder</h2>\n<ul>\n<li><code>setDisallowedFields()</code> 设置需要忽略的字段,如果给忽略的字段赋值,就会报错。</li>\n<li><code>setAllowedFields()</code> 允许绑定的,如果没有指定默认都允许,如果指定了就仅限指定的字段,可以绑定。</li>\n<li><code>setRequiredFields()</code> 指定的字段必须要有值,不能为null。</li>\n<li><code>registerCustomEditor()</code> 注册转换逻辑。</li>\n<li><code>addValidators(...)</code> 添加绑定的验证器。</li>\n<li><code>bind()</code> 执行绑定动作。</li>\n<li><code>validate()</code> 执行规则校验。</li>\n<li><code>getBindingResult()</code> 获取绑定结果信息</li>\n<li><code>getTarget()</code> 获取绑定后的数据对象</li>\n</ul>\n<div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>testDataBinder</span><span>(</span><span>)</span> <span>{</span>\n        <span>// 绑定那个字段,以及绑定的逻辑</span>\n        <span>DataBinder</span> dataBinder <span>=</span> <span>new</span> <span>DataBinder</span><span>(</span><span>new</span> <span>User</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// 忽略不绑定的,如果有绑定就报错</span>\n<span>//        dataBinder.setDisallowedFields(\"age\");</span>\n        <span>// 允许绑定的,如果没有指定默认都允许,如果指定了就仅限指定的字段,可以绑定。</span>\n<span>//        dataBinder.setAllowedFields(\"name\",\"address\",\"age\");</span>\n        <span>// 必须要有值,不能为null</span>\n        dataBinder<span>.</span><span>setRequiredFields</span><span>(</span><span>\"age\"</span><span>)</span><span>;</span>\n        <span>// 字段转换器</span>\n        dataBinder<span>.</span><span>registerCustomEditor</span><span>(</span><span>String</span><span>.</span><span>class</span><span>,</span> <span>\"name\"</span><span>,</span> <span>new</span> <span>PropertyEditorSupport</span><span>(</span><span>)</span> <span>{</span>\n            <span>@Override</span>\n            <span>public</span> <span>void</span> <span>setAsText</span><span>(</span><span>String</span> text<span>)</span> <span>throws</span> <span>IllegalArgumentException</span> <span>{</span>\n                <span>// name转成大写</span>\n                <span>setValue</span><span>(</span>text<span>.</span><span>toUpperCase</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n        dataBinder<span>.</span><span>registerCustomEditor</span><span>(</span><span>Address</span><span>.</span><span>class</span><span>,</span> <span>\"address\"</span><span>,</span> <span>new</span> <span>PropertyEditorSupport</span><span>(</span><span>)</span> <span>{</span>\n            <span>@Override</span>\n            <span>public</span> <span>void</span> <span>setAsText</span><span>(</span><span>String</span> text<span>)</span> <span>throws</span> <span>IllegalArgumentException</span> <span>{</span>\n                <span>// name转成大写</span>\n                <span>setValue</span><span>(</span>text<span>.</span><span>toUpperCase</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>}</span>\n\n            <span>@Override</span>\n            <span>public</span> <span>void</span> <span>setValue</span><span>(</span><span>Object</span> value<span>)</span> <span>{</span>\n                <span>if</span> <span>(</span>value <span>instanceof</span> <span>Address</span><span>)</span> <span>{</span>\n                    <span>(</span><span>(</span><span>Address</span><span>)</span> value<span>)</span><span>.</span><span>setName</span><span>(</span><span>\"Beijing\"</span><span>)</span><span>;</span>\n                <span>}</span>\n                <span>super</span><span>.</span><span>setValue</span><span>(</span>value<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n        <span>// 添加验证规则</span>\n        dataBinder<span>.</span><span>addValidators</span><span>(</span><span>new</span> <span>Validator</span><span>(</span><span>)</span> <span>{</span>\n            <span>@Override</span>\n            <span>public</span> <span>boolean</span> <span>supports</span><span>(</span><span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> clazz<span>)</span> <span>{</span>\n                <span>return</span> <span>User</span><span>.</span><span>class</span><span>.</span><span>equals</span><span>(</span>clazz<span>)</span><span>;</span>\n            <span>}</span>\n\n            <span>@Override</span>\n            <span>public</span> <span>void</span> <span>validate</span><span>(</span><span>Object</span> target<span>,</span> <span>Errors</span> errors<span>)</span> <span>{</span>\n                <span>if</span> <span>(</span><span>(</span><span>(</span><span>User</span><span>)</span> target<span>)</span><span>.</span><span>getAge</span><span>(</span><span>)</span> <span>&lt;=</span> <span>0</span><span>)</span> <span>{</span>\n                    errors<span>.</span><span>rejectValue</span><span>(</span><span>\"age\"</span><span>,</span> <span>\"年龄不合法\"</span><span>)</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n        <span>PropertyValues</span> pvs <span>=</span> <span>new</span> <span>MutablePropertyValues</span><span>(</span>\n                <span>Arrays</span><span>.</span><span>asList</span><span>(</span><span>new</span> <span>PropertyValue</span><span>(</span><span>\"name\"</span><span>,</span> <span>\"jar\"</span><span>)</span><span>,</span>\n                        <span>new</span> <span>PropertyValue</span><span>(</span><span>\"age\"</span><span>,</span> <span>0</span><span>)</span><span>,</span>\n                        <span>new</span> <span>PropertyValue</span><span>(</span><span>\"address\"</span><span>,</span> <span>new</span> <span>Address</span><span>(</span><span>)</span><span>)</span><span>)</span><span>)</span><span>;</span>\n        dataBinder<span>.</span><span>bind</span><span>(</span>pvs<span>)</span><span>;</span>\n        <span>// 验证字段</span>\n        dataBinder<span>.</span><span>validate</span><span>(</span><span>)</span><span>;</span>\n        <span>BindingResult</span> results <span>=</span> dataBinder<span>.</span><span>getBindingResult</span><span>(</span><span>)</span><span>;</span>\n        <span>// org.springframework.validation.BeanPropertyBindingResult: 1 errors</span>\n        <span>// Field error in object 'target' on field 'age': rejected value [0]; codes [年龄不合法.target.age,年龄不合法.age,年龄不合法.java.lang.Integer,年龄不合法]; arguments []; default message [null]</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>results<span>)</span><span>;</span>\n        <span>// User(name=JAR, age=0, membersFamily=null, address=Address(name=Beijing, oneAddress=null, twoAddress=null))</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>dataBinder<span>.</span><span>getTarget</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br></div></div><h2 id=\"_2-4-webdatabinder-自定义web请求参数转换器\"> 2.4 WebDataBinder 自定义Web请求参数转换器</h2>\n<p>WebDataBinder 继承自DataBinder Spring允许通过其进行自定义的类型转换,从而将请求参数转换成方法参数。</p>\n<ul>\n<li>如下我们定义一个get请求,将请求参数转换成 Address对象。</li>\n</ul>\n<div><pre><code>    <span>@GetMapping</span><span>(</span><span>\"get\"</span><span>)</span>\n    <span>public</span> <span>String</span> <span>test</span><span>(</span><span>@RequestParam</span><span>(</span><span>\"ads\"</span><span>)</span> <span>Address</span> address<span>)</span> <span>{</span>\n        <span>return</span> address<span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ul>\n<li>首先我们先实现PropertyEditorRegistrar,设置解析的规则</li>\n</ul>\n<div><pre><code><span>@Component</span><span>(</span><span>\"customPropertyEditorRegistrar\"</span><span>)</span>\n<span>public</span> <span>class</span> <span>AddressPropertyEditorRegistrar</span> <span>implements</span> <span>PropertyEditorRegistrar</span> <span>{</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>registerCustomEditors</span><span>(</span><span>PropertyEditorRegistry</span> registry<span>)</span> <span>{</span>\n        registry<span>.</span><span>registerCustomEditor</span><span>(</span><span>Address</span><span>.</span><span>class</span><span>,</span> <span>new</span> <span>PropertyEditorSupport</span><span>(</span><span>)</span> <span>{</span>\n            <span>@Override</span>\n            <span>public</span> <span>void</span> <span>setAsText</span><span>(</span><span>String</span> text<span>)</span> <span>throws</span> <span>IllegalArgumentException</span> <span>{</span>\n                <span>String</span><span>[</span><span>]</span> split <span>=</span> text<span>.</span><span>split</span><span>(</span><span>\"\\\\|\"</span><span>)</span><span>;</span>\n                <span>Address</span> address <span>=</span> <span>new</span> <span>Address</span><span>(</span><span>)</span><span>;</span>\n                address<span>.</span><span>setOneAddress</span><span>(</span>split<span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>\n                address<span>.</span><span>setTwoAddress</span><span>(</span>split<span>[</span><span>1</span><span>]</span><span>)</span><span>;</span>\n                <span>setValue</span><span>(</span>address<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><ul>\n<li>给WebDataBinder添加转换器</li>\n</ul>\n<div><pre><code><span>@RestController</span>\n<span>public</span> <span>class</span> <span>RegisterUserController</span>\n  \n   <span>@Autowired</span>\n   <span>private</span> <span>PropertyEditorRegistrar</span> customPropertyEditorRegistrar<span>;</span>\n   \n   <span>/**\n     * 只对当前接口有效\n     *\n     * @param binder\n     */</span>\n    <span>@InitBinder</span>\n    <span>void</span> <span>initBinder</span><span>(</span><span>WebDataBinder</span> binder<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>customPropertyEditorRegistrar<span>.</span><span>registerCustomEditors</span><span>(</span>binder<span>)</span><span>;</span>\n    <span>}</span>\n    <span>// GET http://localhost:8080/get?ads=杭州市|上城区</span>\n    <span>@GetMapping</span><span>(</span><span>\"get\"</span><span>)</span>\n    <span>public</span> <span>String</span> <span>test</span><span>(</span><span>@RequestParam</span><span>(</span><span>\"ads\"</span><span>)</span> <span>Address</span> address<span>)</span> <span>{</span>\n        <span>// Address(name=null, oneAddress=杭州市, twoAddress=上城区)</span>\n        <span>return</span> address<span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>    \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h2 id=\"三、问题解答\"> 三、问题解答</h2>\n<h2 id=\"_3-1-requestbody-如何将参数绑定到实体对象上\"> 3.1 @RequestBody 如何将参数绑定到实体对象上</h2>\n<p>主要思路就是从HttpServletRequest中获取参数,通过读取请求方法的 <code>MediaType</code> 类型,选择对应的\n<code>HttpMessageConverter</code> 转换器。</p>\n<ol>\n<li>HandlerMethodArgumentResolver 处理web方法的参数</li>\n<li>HandlerMethodReturnValueHandler 处理web方法的参数</li>\n</ol>\n<p><img src=\"https://img.springlearn.cn/blog/87db17f2f12a9f30f4611f036eef86ce.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_3-1-1-执行器请求方法\"> 3.1.1 执行器请求方法</h3>\n<p>同时如果请求类的使用到了 @InitBinder 自定义请求参数转换,在这里也会被执行。</p>\n<div><pre><code>  <span>// 从Request对象中获取方法参数 getMethodArgumentValues</span>\n\t<span>@Nullable</span>\n\t<span>public</span> <span>Object</span> <span>invokeForRequest</span><span>(</span><span>NativeWebRequest</span> request<span>,</span> <span>@Nullable</span> <span>ModelAndViewContainer</span> mavContainer<span>,</span>\n\t\t\t<span>Object</span><span>.</span><span>.</span><span>.</span> providedArgs<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n\n\t\t<span>Object</span><span>[</span><span>]</span> args <span>=</span> <span>getMethodArgumentValues</span><span>(</span>request<span>,</span> mavContainer<span>,</span> providedArgs<span>)</span><span>;</span>\n\t\t<span>if</span> <span>(</span>logger<span>.</span><span>isTraceEnabled</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n\t\t\tlogger<span>.</span><span>trace</span><span>(</span><span>\"Arguments: \"</span> <span>+</span> <span>Arrays</span><span>.</span><span>toString</span><span>(</span>args<span>)</span><span>)</span><span>;</span>\n\t\t<span>}</span>\n\t\t<span>return</span> <span>doInvoke</span><span>(</span>args<span>)</span><span>;</span>\n\t<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id=\"_3-1-2-转换请求参数\"> 3.1.2 转换请求参数</h3>\n<p><img src=\"https://img.springlearn.cn/blog/9a061a096787aee746c8993168e6dfca.png\" alt=\"\" loading=\"lazy\"></p>\n<ul>\n<li>RequestResponseBodyMethodProcessor</li>\n</ul>\n<h3 id=\"_3-1-3-requestbody-处理\"> 3.1.3 @RequestBody 处理</h3>\n<p>这里主要使用到的接口是 <code>HttpMessageConverter</code>，同时这里我们能看到一段逻辑就是\n什么时候会进行参数检查。就在 <code>validateIfApplicable</code>,如果参数失败就会抛出 <code>MethodArgumentNotValidException</code> 异常。</p>\n<p><img src=\"https://img.springlearn.cn/blog/98fa4b35ed341d19e43b23b86958f65b.png\" alt=\"\" loading=\"lazy\"></p>\n<p><img src=\"https://img.springlearn.cn/blog/0df70689e2560afd5ff613e221945218.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_3-2-configurationproperties-参数绑定原理\"> 3.2 ConfigurationProperties 参数绑定原理</h2>\n<ul>\n<li>ConfigurationPropertiesBindingPostProcessor</li>\n</ul>\n<p>在配置类Bean, 初始化前,执行绑定。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>ConfigurationPropertiesBindingPostProcessor</span>\n\t\t<span>implements</span> <span>BeanPostProcessor</span><span>,</span> <span>PriorityOrdered</span><span>,</span> <span>ApplicationContextAware</span><span>,</span> <span>InitializingBean</span> <span>{</span>\n  \n    <span>private</span> <span>ConfigurationPropertiesBinder</span> binder<span>;</span>\n    \n    <span>// 从容器中获取绑定工具类,ConfigurationPropertiesBinder</span>\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>afterPropertiesSet</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n      <span>this</span><span>.</span>registry <span>=</span> <span>(</span><span>BeanDefinitionRegistry</span><span>)</span> <span>this</span><span>.</span>applicationContext<span>.</span><span>getAutowireCapableBeanFactory</span><span>(</span><span>)</span><span>;</span>\n      <span>this</span><span>.</span>binder <span>=</span> <span>ConfigurationPropertiesBinder</span><span>.</span><span>get</span><span>(</span><span>this</span><span>.</span>applicationContext<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>// bean初始化前,进行绑定</span>\n    <span>@Override</span>\n    <span>public</span> <span>Object</span> <span>postProcessBeforeInitialization</span><span>(</span><span>Object</span> bean<span>,</span> <span>String</span> beanName<span>)</span> <span>throws</span> <span>BeansException</span> <span>{</span>\n      <span>bind</span><span>(</span><span>ConfigurationPropertiesBean</span><span>.</span><span>get</span><span>(</span><span>this</span><span>.</span>applicationContext<span>,</span> bean<span>,</span> beanName<span>)</span><span>)</span><span>;</span>\n      <span>return</span> bean<span>;</span>\n    <span>}</span>\n\n    <span>private</span> <span>void</span> <span>bind</span><span>(</span><span>ConfigurationPropertiesBean</span> bean<span>)</span> <span>{</span>\n      <span>if</span> <span>(</span>bean <span>==</span> <span>null</span> <span>||</span> <span>hasBoundValueObject</span><span>(</span>bean<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>)</span> <span>{</span>\n        <span>return</span><span>;</span>\n      <span>}</span>\n      <span>Assert</span><span>.</span><span>state</span><span>(</span>bean<span>.</span><span>getBindMethod</span><span>(</span><span>)</span> <span>==</span> <span>BindMethod</span><span>.</span>JAVA_BEAN<span>,</span> <span>\"Cannot bind @ConfigurationProperties for bean '\"</span>\n          <span>+</span> bean<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\"'. Ensure that @ConstructorBinding has not been applied to regular bean\"</span><span>)</span><span>;</span>\n      <span>try</span> <span>{</span>\n        <span>this</span><span>.</span>binder<span>.</span><span>bind</span><span>(</span>bean<span>)</span><span>;</span>\n      <span>}</span>\n      <span>catch</span> <span>(</span><span>Exception</span> ex<span>)</span> <span>{</span>\n        <span>throw</span> <span>new</span> <span>ConfigurationPropertiesBindException</span><span>(</span>bean<span>,</span> ex<span>)</span><span>;</span>\n      <span>}</span>\n    <span>}</span>  \n    \n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><h3 id=\"_3-2-1-configurationpropertiesbinder\"> 3.2.1 ConfigurationPropertiesBinder</h3>\n<p>因为在构造中就获取到了Spring的上下文对象,所有就能从Spring中获取到所有他想要的工具。\n最终调用前面我们学过的 <code>Binder</code> 去进行绑定。</p>\n<div><pre><code><span>class</span> <span>ConfigurationPropertiesBinder</span> <span>{</span>\n\n\t<span>ConfigurationPropertiesBinder</span><span>(</span><span>ApplicationContext</span> applicationContext<span>)</span> <span>{</span>\n      <span>this</span><span>.</span>applicationContext <span>=</span> applicationContext<span>;</span>\n      <span>this</span><span>.</span>propertySources <span>=</span> <span>new</span> <span>PropertySourcesDeducer</span><span>(</span>applicationContext<span>)</span><span>.</span><span>getPropertySources</span><span>(</span><span>)</span><span>;</span>\n      <span>this</span><span>.</span>configurationPropertiesValidator <span>=</span> <span>getConfigurationPropertiesValidator</span><span>(</span>applicationContext<span>)</span><span>;</span>\n      <span>this</span><span>.</span>jsr303Present <span>=</span> <span>ConfigurationPropertiesJsr303Validator</span><span>.</span><span>isJsr303Present</span><span>(</span>applicationContext<span>)</span><span>;</span>\n\t<span>}</span>\n  \n  <span>BindResult</span><span><span>&lt;</span><span>?</span><span>></span></span> <span>bind</span><span>(</span><span>ConfigurationPropertiesBean</span> propertiesBean<span>)</span> <span>{</span>\n      <span>Bindable</span><span><span>&lt;</span><span>?</span><span>></span></span> target <span>=</span> propertiesBean<span>.</span><span>asBindTarget</span><span>(</span><span>)</span><span>;</span>\n      <span>ConfigurationProperties</span> annotation <span>=</span> propertiesBean<span>.</span><span>getAnnotation</span><span>(</span><span>)</span><span>;</span>\n      <span>BindHandler</span> bindHandler <span>=</span> <span>getBindHandler</span><span>(</span>target<span>,</span> annotation<span>)</span><span>;</span>\n      <span>// 获取到前缀,进行绑定</span>\n      <span>return</span> <span>getBinder</span><span>(</span><span>)</span><span>.</span><span>bind</span><span>(</span>annotation<span>.</span><span>prefix</span><span>(</span><span>)</span><span>,</span> target<span>,</span> bindHandler<span>)</span><span>;</span>\n\t<span>}</span>\n<span>}</span>  \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h3 id=\"_3-2-2-constructorbinding-的用法\"> 3.2.2 ConstructorBinding 的用法</h3>\n<p>最后我们介绍一个很少用的注解,这个注解往往用于配合 @ConfigurationProperties使用,但是使用的场景不多。</p>\n<p><code>@ConstructorBinding</code> 可用于指示应该,使用构造函数参数而不是调用setter来绑定配置属性的注释。可以在类型级别(如果有明确的构造函数)或在要使用的实际构造函数上添加。</p>\n<p><img src=\"https://img.springlearn.cn/learn_aecfc8e243edb199c726728413b1522c.gif\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>最后,都看到这里了,最后如果这篇文章,对你有所帮助,请点个关注,交个朋友。</strong></p>\n",
      "image": "https://img.springlearn.cn/blog/b8f74de10af99991e3fc73632eeeb190.png",
      "date_published": "2022-09-04T13:51:11.000Z",
      "date_modified": "2023-02-08T03:23:43.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Spring Framework"
      ]
    },
    {
      "title": "第09篇:MessageSource国际化",
      "url": "https://java.springlearn.cn/learn/spring/core09/",
      "id": "https://java.springlearn.cn/learn/spring/core09/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/b8f74de10af99991e3fc73632eeeb190.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>公众号</strong>: 西魏陶渊明<br/>\n<strong>CSDN</strong>: <a href=\"https://springlearn.blog.csdn.net/?type=blog\" target=\"_blank\" rel=\"noopener noreferrer\">https://springlearn.blog.csdn.net</a><br/></p>\n<blockquote>\n<p>天下代码一大抄, 抄来抄去有提高, 看你会抄不会抄！\n<img src=\"https://img.springlearn.cn/blog/8f3392b9badb093f9e1a6472b4a98487.gif\" alt=\"\" loading=\"lazy\"></p>\n</blockquote>\n<h2 id=\"一、前言\"> 一、前言</h2>\n<h3 id=\"_1-1-i18n\"> 1.1 i18n</h3>\n<p>12</p>\n<h2 id=\"二、api\"> 二、API</h2>\n<h3 id=\"_2-1-locale\"> 2.1 Locale</h3>\n<h3 id=\"_2-2-文件命名规范\"> 2.2 文件命名规范</h3>\n<p>AcceptLanguage en_US 语言解析器</p>\n<p>LanguageTag.parse\nLocale#forLanguageTag  en_US 要转成 en-US 中划线</p>\n<h3 id=\"localeresolver-resolvelocale\"> LocaleResolver#resolveLocale</h3>\n<div><pre><code><span>@Override</span>\n\t<span>public</span> <span>Locale</span> <span>resolveLocale</span><span>(</span><span>HttpServletRequest</span> request<span>)</span> <span>{</span>\n\t\t<span>Locale</span> defaultLocale <span>=</span> <span>getDefaultLocale</span><span>(</span><span>)</span><span>;</span>\n\t\t<span>if</span> <span>(</span>defaultLocale <span>!=</span> <span>null</span> <span>&amp;&amp;</span> request<span>.</span><span>getHeader</span><span>(</span><span>\"Accept-Language\"</span><span>)</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>\n\t\t\t<span>return</span> defaultLocale<span>;</span>\n\t\t<span>}</span>\n\t\t<span>Locale</span> requestLocale <span>=</span> request<span>.</span><span>getLocale</span><span>(</span><span>)</span><span>;</span>\n\t\t<span>List</span><span><span>&lt;</span><span>Locale</span><span>></span></span> supportedLocales <span>=</span> <span>getSupportedLocales</span><span>(</span><span>)</span><span>;</span>\n\t\t<span>if</span> <span>(</span>supportedLocales<span>.</span><span>isEmpty</span><span>(</span><span>)</span> <span>||</span> supportedLocales<span>.</span><span>contains</span><span>(</span>requestLocale<span>)</span><span>)</span> <span>{</span>\n\t\t\t<span>return</span> requestLocale<span>;</span>\n\t\t<span>}</span>\n\t\t<span>Locale</span> supportedLocale <span>=</span> <span>findSupportedLocale</span><span>(</span>request<span>,</span> supportedLocales<span>)</span><span>;</span>\n\t\t<span>if</span> <span>(</span>supportedLocale <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n\t\t\t<span>return</span> supportedLocale<span>;</span>\n\t\t<span>}</span>\n\t\t<span>return</span> <span>(</span>defaultLocale <span>!=</span> <span>null</span> <span>?</span> defaultLocale <span>:</span> requestLocale<span>)</span><span>;</span>\n\t<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h3 id=\"_2-3-spring中体系\"> 2.3 Spring中体系</h3>\n<p><img src=\"https://img.springlearn.cn/blog/770062b2a890bc4663bcbfecc7420e75.png\" alt=\"\" loading=\"lazy\"></p>\n<ul>\n<li>\n<p>MessageSource</p>\n</li>\n<li>\n<p>HierarchicalMessageSource</p>\n</li>\n<li>\n<p>MessageSourceSupport</p>\n</li>\n<li>\n<p>AbstractMessageSource</p>\n</li>\n<li>\n<p>StaticMessageSource</p>\n</li>\n<li>\n<p>AbstractResourceBasedMessageSource</p>\n</li>\n<li>\n<p>ResourceBundleMessageSource</p>\n</li>\n<li>\n<p>ReloadableResourceBundleMessageSource</p>\n</li>\n</ul>\n<h2 id=\"三、使用\"> 三、使用</h2>\n<h3 id=\"后端渲染页面场景\"> 后端渲染页面场景</h3>\n<h3 id=\"前后端分离\"> 前后端分离</h3>\n<h3 id=\"_3-1-spring实现原理\"> 3.1 spring实现原理</h3>\n<h3 id=\"_3-2-springboot中使用\"> 3.2 springboot中使用</h3>\n<div><pre><code>spring<span>.</span>mvc<span>.</span>locale<span>-</span>resolver<span>=</span>accept_header\nspring<span>.</span>messages<span>.</span>basename<span>=</span>message\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div>",
      "image": "https://img.springlearn.cn/blog/b8f74de10af99991e3fc73632eeeb190.png",
      "date_published": "2022-09-04T13:51:11.000Z",
      "date_modified": "2023-02-08T03:23:43.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Spring Framework"
      ]
    },
    {
      "title": "第10篇:Spring Webflux",
      "url": "https://java.springlearn.cn/learn/spring/core10/",
      "id": "https://java.springlearn.cn/learn/spring/core10/",
      "content_html": "<p><img src=\"https://img-blog.csdnimg.cn/img_convert/aa1d259419ff268edc2fe3088f940556.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>公众号</strong>: 西魏陶渊明<br/>\n<strong>CSDN</strong>: <a href=\"https://springlearn.blog.csdn.net/?type=blog\" target=\"_blank\" rel=\"noopener noreferrer\">https://springlearn.blog.csdn.net</a><br/></p>\n<blockquote>\n<p>天下代码一大抄, 抄来抄去有提高, 看你会抄不会抄！</p>\n</blockquote>\n<h2 id=\"一、前言\"> 一、前言</h2>\n<h2 id=\"二、知识点\"> 二、知识点</h2>\n<h3 id=\"_2-1-beanfactory-工厂\"> 2.1 BeanFactory 工厂</h3>\n<h3 id=\"_2-2-applicationcontext-容器上下文\"> 2.2 ApplicationContext 容器上下文</h3>\n",
      "image": "https://img.springlearn.cn/blog/b8f74de10af99991e3fc73632eeeb190.png",
      "date_published": "2022-09-04T13:51:11.000Z",
      "date_modified": "2023-02-08T03:23:43.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Spring Framework"
      ]
    },
    {
      "title": "JUnit单测类属性注入",
      "url": "https://java.springlearn.cn/learn/test/JUnit%E5%8D%95%E6%B5%8B%E7%B1%BB%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5/",
      "id": "https://java.springlearn.cn/learn/test/JUnit%E5%8D%95%E6%B5%8B%E7%B1%BB%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5/",
      "content_html": "<p>通过前面的阅读我们已经能拿到了所有的容器启动参数。那么我们可以思考下。我们自己的\n单测类其实并没有交给容器来管理,那么我们的单测类中的属性都是什么时候注入的呢?</p>\n<p>答案就在 <code>TestExecutionListener</code></p>\n<div><pre><code><span>public</span> <span>interface</span> <span>TestExecutionListener</span> <span>{</span>\n\n\t<span>default</span> <span>void</span> <span>beforeTestClass</span><span>(</span><span>TestContext</span> testContext<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n\t<span>}</span>\n\n\t<span>default</span> <span>void</span> <span>prepareTestInstance</span><span>(</span><span>TestContext</span> testContext<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n\t<span>}</span>\n\n\t<span>default</span> <span>void</span> <span>beforeTestMethod</span><span>(</span><span>TestContext</span> testContext<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n\t<span>}</span>\n\n\t<span>default</span> <span>void</span> <span>beforeTestExecution</span><span>(</span><span>TestContext</span> testContext<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n\t<span>}</span>\n\n\t<span>default</span> <span>void</span> <span>afterTestExecution</span><span>(</span><span>TestContext</span> testContext<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n\t<span>}</span>\n\n\t<span>default</span> <span>void</span> <span>afterTestMethod</span><span>(</span><span>TestContext</span> testContext<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n\t<span>}</span>\n\n\t<span>default</span> <span>void</span> <span>afterTestClass</span><span>(</span><span>TestContext</span> testContext<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n\t<span>}</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p><img src=\"https://img.springlearn.cn/blog/learn_1617795655000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>通过名字我们发现了貌似一个可以进行依赖注入的类。没错就是在这里,在单侧方法执行前。通过</p>\n<div><pre><code><span>public</span> <span>class</span> <span>DependencyInjectionTestExecutionListener</span> <span>extends</span> <span>AbstractTestExecutionListener</span> <span>{</span>\n\t<span>@Override</span>\n\t<span>public</span> <span>void</span> <span>beforeTestMethod</span><span>(</span><span>TestContext</span> testContext<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n\t\t<span>if</span> <span>(</span><span>Boolean</span><span>.</span>TRUE<span>.</span><span>equals</span><span>(</span>testContext<span>.</span><span>getAttribute</span><span>(</span>REINJECT_DEPENDENCIES_ATTRIBUTE<span>)</span><span>)</span><span>)</span> <span>{</span>\n\t\t\t<span>if</span> <span>(</span>logger<span>.</span><span>isDebugEnabled</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n\t\t\t\tlogger<span>.</span><span>debug</span><span>(</span><span>\"Reinjecting dependencies for test context [\"</span> <span>+</span> testContext <span>+</span> <span>\"].\"</span><span>)</span><span>;</span>\n\t\t\t<span>}</span>\n\t\t\t<span>injectDependencies</span><span>(</span>testContext<span>)</span><span>;</span>\n\t\t<span>}</span>\n\t<span>}</span>\n\n\t<span>protected</span> <span>void</span> <span>injectDependencies</span><span>(</span><span>TestContext</span> testContext<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n\t\t<span>Object</span> bean <span>=</span> testContext<span>.</span><span>getTestInstance</span><span>(</span><span>)</span><span>;</span>\n\t\t<span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> clazz <span>=</span> testContext<span>.</span><span>getTestClass</span><span>(</span><span>)</span><span>;</span>\n\t\t<span>AutowireCapableBeanFactory</span> beanFactory <span>=</span> testContext<span>.</span><span>getApplicationContext</span><span>(</span><span>)</span><span>.</span><span>getAutowireCapableBeanFactory</span><span>(</span><span>)</span><span>;</span>\n\t\tbeanFactory<span>.</span><span>autowireBeanProperties</span><span>(</span>bean<span>,</span> <span>AutowireCapableBeanFactory</span><span>.</span>AUTOWIRE_NO<span>,</span> <span>false</span><span>)</span><span>;</span>\n\t\tbeanFactory<span>.</span><span>initializeBean</span><span>(</span>bean<span>,</span> clazz<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>AutowireCapableBeanFactory</span><span>.</span>ORIGINAL_INSTANCE_SUFFIX<span>)</span><span>;</span>\n\t\ttestContext<span>.</span><span>removeAttribute</span><span>(</span>REINJECT_DEPENDENCIES_ATTRIBUTE<span>)</span><span>;</span>\n\t<span>}</span>\n<span>}</span>\t\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div>",
      "image": "https://img.springlearn.cn/blog/learn_1617795655000.png",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Feign Mock注意事项",
      "url": "https://java.springlearn.cn/learn/test/FeignMock/",
      "id": "https://java.springlearn.cn/learn/test/FeignMock/",
      "content_html": "<h2 id=\"一、feign接口模拟\"> 一、Feign接口模拟</h2>\n<p>以下两种API的用法会导致你Feign类型推断不出来,建议使用最后一种</p>\n<div建议使用最后一种\" line-numbers-mode\"><pre><code>        <span>Mockito</span><span>.</span><span>when</span><span>(</span>arrivalOrderFeignClient<span>.</span><span>listArrivalNoticeBatch</span><span>(</span><span>new</span> <span>PmsArrivalNoticeBatchQueryDTO</span><span>(</span><span>)</span><span>)</span><span>)</span><span>.</span><span>thenReturn</span><span>(</span><span>JsonResult</span><span>.</span><span>success</span><span>(</span>result<span>)</span><span>)</span><span>;</span>\n        <span>Mockito</span><span>.</span><span>doReturn</span><span>(</span><span>JsonResult</span><span>.</span><span>success</span><span>(</span>result<span>)</span><span>)</span><span>.</span><span>when</span><span>(</span>arrivalOrderFeignClient<span>)</span><span>.</span><span>listArrivalNoticeBatch</span><span>(</span><span>Mockito</span><span>.</span><span>any</span><span>(</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h2 id=\"二、mapper接口要使用mock\"> 二、Mapper接口要使用Mock</h2>\n<p>对于Service层的数据测试,Mapper类使用@MockBean。保证数据都是模拟的。</p>\n<p>对于Dal层数据测试,Mapper使用真实的示例信息。</p>\n",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "JUnit API",
      "url": "https://java.springlearn.cn/learn/test/JUnitAPI/",
      "id": "https://java.springlearn.cn/learn/test/JUnitAPI/",
      "content_html": "<div><p>提示</p>\n<p>只打印的单测是没有意义的,正确使用单测工具, 提高单测质量。</p>\n</div>\n<h2 id=\"一、常用注解\"> 一、常用注解</h2>\n<h3 id=\"_1-1-before-after\"> 1.1 @Before &amp; @After</h3>\n<p>单测类中每个单测方法执行都会触发这两个方法</p>\n<div><pre><code>    <span>@Before</span>\n    <span>public</span> <span>void</span> <span>before</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"before\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@After</span>\n    <span>public</span> <span>void</span> <span>after</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"after\"</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"_1-2-beforeclass-afterclass\"> 1.2 @BeforeClass &amp; @AfterClass</h3>\n<p>区别与上一个,不管单测类中有几个单测方法,都只会执行一次</p>\n<p>要用静态修饰</p>\n<div><pre><code>    <span>@BeforeClass</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>beforeClass</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"beforeClass\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@AfterClass</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>afterClass</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"afterClass\"</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><div><p>代码实例</p>\n<p>针对上面说的两个注解演示一下</p>\n<ul>\n<li>beforeClass</li>\n<li>before</li>\n<li>testOne</li>\n<li>after</li>\n<li>before</li>\n<li>testTwo</li>\n<li>after</li>\n<li>afterClass</li>\n</ul>\n</div>\n<hr>\n<div><pre><code><span>public</span> <span>class</span> <span>JUnitTest</span> <span>{</span>\n\n    <span>@BeforeClass</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>beforeClass</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"beforeClass\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Before</span>\n    <span>public</span> <span>void</span> <span>before</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"before\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>testOne</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"testOne\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>testTwo</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"testTwo\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@AfterClass</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>afterClass</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"afterClass\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@After</span>\n    <span>public</span> <span>void</span> <span>after</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"after\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><h3 id=\"_1-3-timed\"> 1.3 @Timed</h3>\n<p>被修饰的方法会加上一个时间限制,如果超过了指定的时间范围,就算单侧代码执行成功\n了也被认为是失败。(注意该方法依赖于SpringBoot容器)</p>\n<p>@Timed</p>\n<div><pre><code>    <span>@Test</span>\n    <span>@Timed</span><span>(</span>millis <span>=</span> <span>2000</span><span>)</span>\n    <span>public</span> <span>void</span> <span>testTimeout</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"testOne\"</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"_1-4-repeat\"> 1.4 @Repeat</h3>\n<p>指定当前单测方法被执行的次数,如果被该注解修饰\n将会被重复执行。(注意该方法依赖于SpringBoot容器)</p>\n<p>@Repeat</p>\n<div><pre><code>    <span>@Test</span>\n    <span>@Repeat</span><span>(</span><span>3</span><span>)</span>\n    <span>public</span> <span>void</span> <span>testOne</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"testOne\"</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"二、断言api\"> 二、断言API</h2>\n<p>断言的好处在于程序帮忙判断单测结果。不需要人工在接入验证数据。JUnit的口号就是</p>\n<p><code>keep the bar green to keep the code clean。</code></p>\n<p>一个不用观察输出就知道代码有没有问题的高效单元测试工具。</p>\n<div><pre><code>import org.hamcrest.Matchers;\nimport org.hamcrest.core.AllOf;\nimport org.hamcrest.core.AnyOf;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"_2-1-matchers\"> 2.1 Matchers</h3>\n<p>Matchers</p>\n<div><pre><code>        <span>// 是否相等</span>\n        <span>Assert</span><span>.</span><span>assertThat</span><span>(</span><span>2</span><span>,</span> <span>Matchers</span><span>.</span><span>is</span><span>(</span><span>2</span><span>)</span><span>)</span><span>;</span>\n        <span>// 2 小于等于2</span>\n        <span>Assert</span><span>.</span><span>assertThat</span><span>(</span><span>2</span><span>,</span><span>Matchers</span><span>.</span><span>lessThanOrEqualTo</span><span>(</span><span>2</span><span>)</span><span>)</span><span>;</span>\n        <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span><span>String</span><span>></span></span> map <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        map<span>.</span><span>put</span><span>(</span><span>\"name\"</span><span>,</span><span>\"jay\"</span><span>)</span><span>;</span>\n        <span>// map 中是否包含key为name的元素</span>\n        <span>Assert</span><span>.</span><span>assertThat</span><span>(</span>map<span>,</span><span>Matchers</span><span>.</span><span>hasKey</span><span>(</span><span>\"name\"</span><span>)</span><span>)</span><span>;</span>\n        <span>// map 中是否包含value为jay的元素</span>\n        <span>Assert</span><span>.</span><span>assertThat</span><span>(</span>map<span>,</span><span>Matchers</span><span>.</span><span>hasValue</span><span>(</span><span>\"jay\"</span><span>)</span><span>)</span><span>;</span>\n        <span>// map 中是否包含name等于jay的元素</span>\n        <span>Assert</span><span>.</span><span>assertThat</span><span>(</span>map<span>,</span><span>Matchers</span><span>.</span><span>hasEntry</span><span>(</span><span>\"name\"</span><span>,</span><span>\"jay\"</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id=\"_2-2-allof\"> 2.2 AllOf</h3>\n<p>全部满足</p>\n<div><pre><code>   <span>// 2 小于4同时也小于3</span>\n   <span>Assert</span><span>.</span><span>assertThat</span><span>(</span><span>2</span><span>,</span> <span>AllOf</span><span>.</span><span>allOf</span><span>(</span><span>Matchers</span><span>.</span><span>lessThan</span><span>(</span><span>4</span><span>)</span><span>,</span> <span>Matchers</span><span>.</span><span>lessThan</span><span>(</span><span>3</span><span>)</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"_2-3-anyof\"> 2.3 AnyOf</h3>\n<p>任意满足</p>\n<div><pre><code>   <span>// 2 大于1小于3</span>\n   <span>Assert</span><span>.</span><span>assertThat</span><span>(</span><span>2</span><span>,</span> <span>AnyOf</span><span>.</span><span>anyOf</span><span>(</span><span>Matchers</span><span>.</span><span>greaterThan</span><span>(</span><span>1</span><span>)</span><span>,</span> <span>Matchers</span><span>.</span><span>lessThan</span><span>(</span><span>3</span><span>)</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h2 id=\"三、结果验证\"> 三、结果验证</h2>\n<h3 id=\"_3-1-空值验证\"> 3.1 空值验证</h3>\n<div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>test</span><span>(</span><span>)</span> <span>{</span>\n        <span>Object</span> o <span>=</span> <span>new</span> <span>Object</span><span>(</span><span>)</span><span>;</span>\n        <span>// 非空验证</span>\n        <span>Assert</span><span>.</span><span>assertNotNull</span><span>(</span>o<span>)</span><span>;</span>\n        <span>// 空值验证</span>\n        <span>Assert</span><span>.</span><span>assertNull</span><span>(</span><span>null</span><span>)</span><span>;</span>\n    <span>}</span>    \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id=\"_3-2-逻辑验证\"> 3.2 逻辑验证</h3>\n<div><pre><code>    <span>import</span> <span>static</span> <span>org<span>.</span>hamcrest<span>.</span></span><span>MatcherAssert</span><span>.</span>*<span>;</span>\n    <span>import</span> <span>static</span> <span>org<span>.</span>hamcrest<span>.</span></span><span>CoreMatchers</span><span>.</span>*<span>;</span>\n    <span>public</span> calss <span>Test</span><span>{</span>\n        <span>@Test</span>\n        <span>public</span> <span>void</span> <span>test</span><span>(</span><span>)</span> <span>{</span>\n            <span>//测试变量是否大于指定值</span>\n            <span>ArrivalNoticeOrderDO</span> ao <span>=</span> <span>new</span> <span>ArrivalNoticeOrderDO</span><span>(</span><span>)</span><span>;</span>\n            ao<span>.</span><span>setId</span><span>(</span><span>12L</span><span>)</span><span>;</span>\n            <span>//测试所有条件必须成立</span>\n            <span>assertThat</span><span>(</span>ao<span>.</span><span>getId</span><span>(</span><span>)</span><span>,</span> <span>allOf</span><span>(</span><span>is</span><span>(</span><span>12L</span><span>)</span><span>)</span><span>)</span><span>;</span>\n            <span>//测试只要有一个条件成立</span>\n            <span>assertThat</span><span>(</span>ao<span>.</span><span>getId</span><span>(</span><span>)</span><span>,</span> <span>anyOf</span><span>(</span><span>is</span><span>(</span><span>50</span><span>)</span><span>,</span> <span>is</span><span>(</span><span>12L</span><span>)</span><span>)</span><span>)</span><span>;</span>\n            <span>//测试变量值等于指定值</span>\n            <span>assertThat</span><span>(</span>ao<span>.</span><span>getId</span><span>(</span><span>)</span><span>,</span> <span>is</span><span>(</span><span>12L</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id=\"_3-3-异常验证\"> 3.3 异常验证</h3>\n<div><pre><code>    <span>/**\n     * 预期异常\n     */</span>\n    <span>@Test</span><span>(</span>expected <span>=</span> <span>NullPointerException</span><span>.</span><span>class</span><span>)</span>\n    <span>public</span> <span>void</span> <span>testError</span><span>(</span><span>)</span><span>{</span>\n        <span>Object</span> o <span>=</span> <span>null</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>o<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id=\"四、快速创建\"> 四、快速创建</h2>\n<p>建议使用 <code>Idea</code> 自动创建, 不要手动创建。</p>\n",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "如何设计一款通信层框架",
      "url": "https://java.springlearn.cn/learn/other/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E6%AC%BE%E9%80%9A%E4%BF%A1%E5%B1%82%E6%A1%86%E6%9E%B6/",
      "id": "https://java.springlearn.cn/learn/other/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E6%AC%BE%E9%80%9A%E4%BF%A1%E5%B1%82%E6%A1%86%E6%9E%B6/",
      "content_html": "<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcuc3ByaW5nbGVhcm4uY24vYmxvZy9sZWFybl8xNTk5MjIxNjk5MDAwLnBuZw?x-oss-process=image/format,png\" alt=\"\" loading=\"lazy\"></p>\n<blockquote>\n<p>网络世界离不开的就是通信,不管是任何框架只要是提供互联网服务就必须有通信的能力。作为业务开发者可能我们业务中也会遇到这样的需求,或者是有啥好的创意性框架,但是无奈现在通信层框架都太厚重了,想要快速学习使用显然不太可能,所以呢\n本文就是教你如何来实现一个封装一个通信层框架。</p>\n</blockquote>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcuc3ByaW5nbGVhcm4uY24vbGVhcm5fMWQ0YzBhYjAzM2FkNDAwY2M5ZWFiZmNjNjBhNTQ1MDEuZ2lm\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>当看完本篇你将会对Java技术有一个更深入的了解。你可以利用本文学习的内容去实现一下业务</strong></p>\n<ul>\n<li>自己设计一个Tomcat容器;</li>\n<li>自己设计一款RPC框架;</li>\n<li>也可以在你的应用程序内部去在启动一个通信服务。</li>\n</ul>\n<p><a href=\"https://mojito.springlearn.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">项目地址</a></p>\n<h2 id=\"一、通信框架设计要考虑的点\"> 一、通信框架设计要考虑的点</h2>\n<p>通信肯定是双方间的,客户端发送数据,服务端处理数据。我们日常的开发都是基于http协议的,是不用考虑服务端和客户端如何去发送数据的。因为我们理解的数据都是明文的模型,而http协议底层会将其转换成二进制数据通过<code>TCP/IP</code>协议传递给服务端和客户端。而下面内容是要讨论的如何将明文数据转换成二进制数据,以及让客户端和服务端都能理解这样的二进制数据。</p>\n<h3 id=\"_1-什么是协议-以及如何去设计协议\"> 1. 什么是协议？以及如何去设计协议?</h3>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcuc3ByaW5nbGVhcm4uY24vYmxvZy9sZWFybl8xNTk5MjExMjk2MDAwLnBuZw?x-oss-process=image/format,png\" alt=\"\" loading=\"lazy\"></p>\n<p>协议就是通信双方约定的明文和二进制数据的转换格式。客户端按照约定将明文数据转换成二进制数据,服务端按照约定将二进制数据转换成明文数据。</p>\n<p>如我们约定读取的第一个字节是协议类型,第二个字节是序列化类型,第三个是报文长度,第四是报文内容。</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcuc3ByaW5nbGVhcm4uY24vYmxvZy9sZWFybl8xNTk5MjExNDcyMDAwLnBuZw?x-oss-process=image/format,png\" alt=\"\" loading=\"lazy\"></p>\n<h4 id=\"_1-1-客户端根据协议去构建报文\"> 1.1 客户端根据协议去构建报文</h4>\n<p>那么客户端在发数据给服务端的时候就要根据前面定的协议去拼装二进制数据。</p>\n<div><pre><code>    <span>@Override</span>\n    <span>protected</span> <span>void</span> <span>doEncode</span><span>(</span><span>ChannelHandlerContext</span> ctx<span>,</span> <span>RpcProtocolHeader</span> msg<span>,</span> <span>ByteBuf</span> out<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>//1. 获取协议类型(1个字节)</span>\n        out<span>.</span><span>writeByte</span><span>(</span>msg<span>.</span><span>getProtocolType</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>//2. 获取序列化类型(1个字节)</span>\n        out<span>.</span><span>writeByte</span><span>(</span>msg<span>.</span><span>getSerializationType</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>//3. 根据序列化类型找到数据转换器生成二进制数据</span>\n        <span>Serializer</span> serializer <span>=</span> <span>SerializeEnum</span><span>.</span><span>ofByType</span><span>(</span>msg<span>.</span><span>getSerializationType</span><span>(</span><span>)</span><span>)</span><span>.</span><span>getSerialize</span><span>(</span><span>)</span><span>.</span><span>newInstance</span><span>(</span><span>)</span><span>;</span>\n        <span>byte</span><span>[</span><span>]</span> data <span>=</span> serializer<span>.</span><span>serialize</span><span>(</span>msg<span>)</span><span>;</span>\n        <span>//4. 写入报文长度(4个字节)</span>\n        out<span>.</span><span>writeInt</span><span>(</span>data<span>.</span>length<span>)</span><span>;</span>\n        <span>//5. 写入报文内容(数组)</span>\n        out<span>.</span><span>writeBytes</span><span>(</span>data<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h4 id=\"_1-2-服务端根据协议去解析报文\"> 1.2 服务端根据协议去解析报文</h4>\n<p>这里通常会遇到很多问题,比如拆包和粘包问题</p>\n<ul>\n<li>拆包是说一个数据发送时候发送的是hello,但是服务端收到的是2次的请求,第一次是hel，第二次是lo。</li>\n<li>粘包是说发了客户端发了2次hello,但是服务端收到的是在一起的hellohello,两个报文粘在一起的。\n如果要自定义协议就必须要解决这两个问题,如何来解决呢? 其实很简单,就是要知道,报文什么时候结束的。\n就像上面的说的协议,为什么要把报文长度写放到报文里面呢? 前面的协议接受到的数据最少是6个字节。</li>\n</ul>\n<p>1个字节的协议类型，1个字节的序列化类型，4个字节的数据长度,剩下的是数据包内容。</p>\n<p>当服务端在处理二进制数据时候如果发现可读的字节不到6个字节,那肯定说明报文不完整,就先不处理,等待报文都到了在处理。\n如果到了6个字节,那么我们肯定就能知道真正的报文长度是多少,然后在读取真正的报文内容,就能知道什么时候报文是结束了。\n如果报文真正内容不够,继续等待,等待数据都到齐。</p>\n<div><pre><code>\n    <span>@Override</span>\n    <span>protected</span> <span>void</span> <span>doDecode</span><span>(</span><span>ChannelHandlerContext</span> ctx<span>,</span> <span>ByteBuf</span> inByteBuf<span>,</span> <span>List</span><span><span>&lt;</span><span>Object</span><span>></span></span> out<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>byte</span><span>[</span><span>]</span> dataArr<span>;</span>\n        <span>//1. 不可读就关闭</span>\n        <span>if</span> <span>(</span><span>!</span>inByteBuf<span>.</span><span>isReadable</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n            <span>Channel</span> channel <span>=</span> ctx<span>.</span><span>channel</span><span>(</span><span>)</span><span>;</span>\n            <span>SocketAddress</span> socketAddress <span>=</span> channel<span>.</span><span>remoteAddress</span><span>(</span><span>)</span><span>;</span>\n            channel<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n            <span>System</span><span>.</span>err<span>.</span><span>println</span><span>(</span><span>\">>>>>>>>>[\"</span> <span>+</span> socketAddress <span>+</span> <span>\"]客户端已主动断开连接....\"</span><span>)</span><span>;</span>\n            <span>return</span><span>;</span>\n        <span>}</span>\n        <span>//2. 可读的数据大小</span>\n        <span>int</span> dataHeadSize <span>=</span> inByteBuf<span>.</span><span>readableBytes</span><span>(</span><span>)</span><span>;</span>\n        <span>//3. 不是完整的数据头(6个字节)</span>\n        <span>if</span> <span>(</span><span>!</span><span>isFullMessageHeader</span><span>(</span>dataHeadSize<span>)</span><span>)</span> <span>{</span>\n        <span>// 如果不到就直接返回,继续等待数据</span>\n            <span>return</span><span>;</span>\n        <span>}</span>\n        <span>//4. 完整的数据头就开始看数据长度是否满足(防止数据真正报文不够,在这里先打个标记)</span>\n        inByteBuf<span>.</span><span>markReaderIndex</span><span>(</span><span>)</span><span>;</span>\n        <span>//协议类型</span>\n        <span>byte</span> protocolType <span>=</span> inByteBuf<span>.</span><span>readByte</span><span>(</span><span>)</span><span>;</span>\n        <span>//序列化类型</span>\n        <span>byte</span> serializationType <span>=</span> inByteBuf<span>.</span><span>readByte</span><span>(</span><span>)</span><span>;</span>\n        <span>//数据长度</span>\n        <span>int</span> dataSize <span>=</span> inByteBuf<span>.</span><span>readInt</span><span>(</span><span>)</span><span>;</span>\n        <span>//5. 拆包的直接返回下次数据完整了,在处理</span>\n        <span>if</span> <span>(</span><span>!</span><span>isFullMessage</span><span>(</span>inByteBuf<span>,</span> dataSize<span>)</span><span>)</span> <span>{</span>\n            <span>// 回滚到4所在的标记,让下次再处理</span>\n            inByteBuf<span>.</span><span>resetReaderIndex</span><span>(</span><span>)</span><span>;</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>)</span><span>;</span>\n            <span>System</span><span>.</span>err<span>.</span><span>println</span><span>(</span><span>\"######################数据不足已重置buffer######################\"</span><span>)</span><span>;</span>\n            <span>return</span><span>;</span>\n        <span>}</span>\n        <span>//6. 数据都到了,就直接根据报文长度来读取数据</span>\n        dataArr <span>=</span> <span>new</span> <span>byte</span><span>[</span>dataSize<span>]</span><span>;</span>\n        inByteBuf<span>.</span><span>readBytes</span><span>(</span>dataArr<span>,</span> <span>0</span><span>,</span> dataSize<span>)</span><span>;</span>\n        <span>//7. 根据序列化类型找到指定的处理类</span>\n        <span>SerializeEnum</span> serializeEnum <span>=</span> <span>SerializeEnum</span><span>.</span><span>ofByType</span><span>(</span>serializationType<span>)</span><span>;</span>\n        <span>Class</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>Serializer</span><span>></span></span> serialize <span>=</span> serializeEnum<span>.</span><span>getSerialize</span><span>(</span><span>)</span><span>;</span>\n        <span>//根据类型获取序列化器</span>\n        <span>Serializer</span> serializerNewInstance <span>=</span> serialize<span>.</span><span>newInstance</span><span>(</span><span>)</span><span>;</span>\n        <span>//8. 转换成java模型</span>\n        <span>Object</span> deserialize <span>=</span> serializerNewInstance<span>.</span><span>deserialize</span><span>(</span>dataArr<span>)</span><span>;</span>\n        out<span>.</span><span>add</span><span>(</span>deserialize<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br></div></div><h3 id=\"_2-通信层如何选技术\"> 2. 通信层如何选技术</h3>\n<p>到底是使用Java提供的通信层API,还是选其他封装好的通信层框架呢? 小编明显选择了后者</p>\n<p>Netty 是一个利用 Java 的高级网络的能力，隐藏其背后的复杂性而提供一个易于使用的 API 的客户端/服务器框架。</p>\n<p>为什么要使用Netty呢? 因为Java的通信API实在太难用了,学习成本高,所以就用Netty已经封装好的简单的API吧。</p>\n<p>只要告诉Netty你们的通信解码编码器,就是告诉Netty你们客户端和服务端约定好的协议类型。Netty就能帮你把二进制数据</p>\n<p>转化成Java模型。</p>\n<p>现在市面上的RPC框架尤其是阿里体系内的<code>Dubbo</code>还是<code>Hsf</code>都是依赖Netty来实现的通信层。还有<code>ElasticSearch</code>等等。</p>\n<h3 id=\"_3-高性能高可靠\"> 3. 高性能高可靠</h3>\n<p>这些都是要有考虑的点,需要精益求精的去code设计和思考另外也要方法面面的压测和验证,但是不在本文的讨论范围。\n本文是想先告诉你怎么去实现,只有当知道如何去实现才能去考虑如何优化。</p>\n<h2 id=\"二、框架演示展示\"> 二、框架演示展示</h2>\n<p>下面演示的框架就是小编基于上面的内容来开发的。目的就是让我们能自定义数据模型,而不用关心底层二进制转换。\n当我们想进行通信的时候不去用启动一个tomcat或者是不用启动一个dubbo服务，只用两行代码就能搞定了。</p>\n<h3 id=\"_1-定义一个数据模型\"> 1. 定义一个数据模型</h3>\n<p>继承一个协议头<code>RpcProtocolHeader</code>。框架会自动将你定义的模型去转换成二进制数据,也可以将二进制数据转换成你的定义的数据模型,而这里的协议,就是前面说的协议。协议叫啥名字都无所谓, 如果你框架的名字叫dubbox,那你可以把前面约定的协议叫做dubbox协议。</p>\n<div><pre><code><span>class</span> <span>RpcUserRequest</span> <span>extends</span> <span>RpcProtocolHeader</span> <span>{</span>\n        <span>private</span> <span>String</span> message<span>;</span>\n\n        <span>public</span> <span>RpcUserRequest</span><span>(</span><span>String</span> message<span>)</span> <span>{</span>\n            <span>this</span><span>.</span>message <span>=</span> message<span>;</span>\n        <span>}</span>\n\n        <span>@Override</span>\n        <span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span>\n            <span>return</span> <span>\"RpcUserRequest{\"</span> <span>+</span>\n                    <span>\"message='\"</span> <span>+</span> message <span>+</span> <span>'\\''</span> <span>+</span>\n                    <span>'}'</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>class</span> <span>RpcUserResponse</span> <span>extends</span> <span>RpcProtocolHeader</span> <span>{</span>\n        <span>private</span> <span>String</span> message<span>;</span>\n\n        <span>public</span> <span>RpcUserResponse</span><span>(</span><span>String</span> message<span>)</span> <span>{</span>\n            <span>this</span><span>.</span>message <span>=</span> message<span>;</span>\n        <span>}</span>\n\n        <span>@Override</span>\n        <span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span>\n            <span>return</span> <span>\"RpcUserResponse{\"</span> <span>+</span>\n                    <span>\"message='\"</span> <span>+</span> message <span>+</span> <span>'\\''</span> <span>+</span>\n                    <span>'}'</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><h3 id=\"_2-创建一个服务端\"> 2. 创建一个服务端</h3>\n<p>API非常简单,如果使用链式编程风格真的就是几行行代码。</p>\n<p>这里举一个简单的例子,收到数据后将请求的message直接在返回给客户端即可。</p>\n<div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>serverTest</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>Installer</span><span>.</span><span>server</span><span>(</span><span>RpcUserRequest</span><span>.</span><span>class</span><span>,</span> <span>RpcUserResponse</span><span>.</span><span>class</span><span>)</span>\n                <span>//这里接受客户端的请求,并返回一个相应</span>\n                <span>.</span><span>serverHandler</span><span>(</span><span>(</span>channel<span>,</span> rpcRequest<span>)</span> <span>-></span> <span>new</span> <span>RpcUserResponse</span><span>(</span><span>\"服务端返回: \"</span> <span>+</span> rpcRequest<span>.</span>message<span>)</span><span>)</span>\n                <span>.</span><span>create</span><span>(</span><span>)</span><span>.</span><span>start</span><span>(</span><span>12306</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id=\"_3-创建一个客户端并发送数据\"> 3. 创建一个客户端并发送数据</h3>\n<p>最后会打印出//RpcUserResponse{message='服务端返回: 关注微信公众号:程序猿升级课'}</p>\n<div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>clientTest</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>//构建一个客户端端</span>\n        <span>Client</span><span><span>&lt;</span><span>RpcUserRequest</span><span>,</span> <span>RpcUserResponse</span><span>></span></span> client <span>=</span> <span>Installer</span><span>.</span><span>client</span><span>(</span><span>RpcUserRequest</span><span>.</span><span>class</span><span>,</span> <span>RpcUserResponse</span><span>.</span><span>class</span><span>)</span>\n                <span>.</span><span>conncet</span><span>(</span><span>\"127.0.0.1\"</span><span>,</span> <span>12306</span><span>)</span><span>;</span>\n        <span>//发送数据</span>\n        <span>MojitoFuture</span><span><span>&lt;</span><span>RpcUserResponse</span><span>></span></span> mojitoFuture <span>=</span> client<span>.</span><span>sendAsync</span><span>(</span><span>new</span> <span>RpcUserRequest</span><span>(</span><span>\"关注微信公众号:程序猿升级课\"</span><span>)</span><span>)</span><span>;</span>\n        <span>//RpcUserResponse{message='服务端返回: 关注微信公众号:程序猿升级课'}</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>mojitoFuture<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        client<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id=\"三、这个框架能做什么\"> 三、这个框架能做什么?</h2>\n<h3 id=\"_1-实现一个最小的http服务端\"> 1. 实现一个最小的HTTP服务端</h3>\n<p>快速就可以构建出一个服务端,这个服务端即可以像上面那样使用RPC的风格调用(前提要自己定义模型),也可以简单\n的构建一个支持http协议的服务端。就像下文那样。</p>\n<p>在SpringBoot应用启动类后面重新启动一个http服务器端口号是8083。当然这么写不够优雅,建议你自己封装一个SpringBoot的Start来使用。</p>\n<div><pre><code><span>@SpringBootApplication</span>\n<span>public</span> <span>class</span> <span>LayuiWebLearnApplication</span> <span>{</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>SpringApplication</span><span>.</span><span>run</span><span>(</span><span>LayuiWebLearnApplication</span><span>.</span><span>class</span><span>,</span> args<span>)</span><span>;</span>\n        <span>// 启动一个监听8083端的支持http协议的服务器</span>\n        <span>HttpCodecFactory</span> httpCodecFactory <span>=</span> <span>new</span> <span>HttpCodecFactory</span><span>(</span><span>new</span> <span>SubServerHandler</span><span><span>&lt;</span><span>HttpRequestFacade</span><span>,</span> <span>HttpResponseFacade</span><span>></span></span><span>(</span><span>)</span> <span>{</span>\n            <span>@Override</span>\n            <span>public</span> <span>HttpResponseFacade</span> <span>handler</span><span>(</span><span>EnhanceChannel</span> enhanceChannel<span>,</span> <span>HttpRequestFacade</span> httpRequestFacade<span>)</span> <span>throws</span> <span>RemotingException</span> <span>{</span>\n                <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> requestParams <span>=</span> httpRequestFacade<span>.</span><span>getRequestParams</span><span>(</span><span>)</span><span>;</span>\n                <span>Constant</span><span>.</span><span>setName</span><span>(</span>requestParams<span>.</span><span>getOrDefault</span><span>(</span><span>\"name\"</span><span>,</span> <span>\"请给我的爱人来一杯Mojito\"</span><span>)</span><span>)</span><span>;</span>\n                <span>return</span> <span>HttpResponseFacade</span><span>.</span><span>ok</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n\n        httpCodecFactory<span>.</span><span>getServer</span><span>(</span><span>)</span><span>.</span><span>startAsync</span><span>(</span><span>8083</span><span>)</span><span>;</span>\n    <span>}</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcuc3ByaW5nbGVhcm4uY24vYmxvZy9sZWFybl8xNTk5MjE1NDIxMDAwLnBuZw?x-oss-process=image/format,png\" alt=\"\" loading=\"lazy\"></p>\n<p>这是一个页面,name展示在页面这个地方,通过自定义框架的能力,将这个值给改变了。\n<img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcuc3ByaW5nbGVhcm4uY24vYmxvZy9sZWFybl8xNTk5MjE1NDYzMDAwLnBuZw?x-oss-process=image/format,png\" alt=\"\" loading=\"lazy\"></p>\n<p>访问<code>http://localhost:8083?name=请给我的爱人来一杯mojito2</code></p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcuc3ByaW5nbGVhcm4uY24vYmxvZy9sZWFybl8xNTk5MjE1NjU1MDAwLnBuZw?x-oss-process=image/format,png\" alt=\"\" loading=\"lazy\"></p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcuc3ByaW5nbGVhcm4uY24vYmxvZy9sZWFybl8xNTk5MjE1ODY1MDAwLnBuZw?x-oss-process=image/format,png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_2-实现一个rpc风格的框架\"> 2. 实现一个RPC风格的框架</h3>\n<p>框架提供了最简单的创建服务端和客户端的API。当然里面还允许指定序列化方式。可以自己去摸索。</p>\n<h4 id=\"创建一个要执行的类\"> 创建一个要执行的类</h4>\n<div><pre><code><span>public</span> <span>class</span> <span>UserInvoker</span> <span>{</span>\n    <span>public</span> <span>String</span> <span>getName</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>\n        <span>return</span> <span>\"反射执行:\"</span> <span>+</span> name<span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h4 id=\"构建服务端\"> 构建服务端</h4>\n<div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>testRpcServer</span><span>(</span><span>)</span> <span>{</span>\n        <span>Installer<span>.</span>ServerCreator</span><span><span>&lt;</span><span>RpcRequest</span><span>,</span> <span>RpcResponse</span><span>></span></span> serverCreator <span>=</span> <span>Installer</span><span>.</span><span>server</span><span>(</span><span>RpcRequest</span><span>.</span><span>class</span><span>,</span> <span>RpcResponse</span><span>.</span><span>class</span><span>)</span>\n                <span>.</span><span>serverHandler</span><span>(</span><span>(</span>channel<span>,</span> request<span>)</span> <span>-></span> <span>{</span>\n            <span>RpcResponse</span> response <span>=</span> <span>new</span> <span>RpcResponse</span><span>(</span><span>)</span><span>;</span>\n            <span>try</span> <span>{</span>\n                <span>//1. 拿到要执行的类</span>\n                <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> serviceType <span>=</span> request<span>.</span><span>getServiceType</span><span>(</span><span>)</span><span>;</span>\n                <span>//2. 拿到要执行类的方法</span>\n                <span>Method</span> method <span>=</span> serviceType<span>.</span><span>getMethod</span><span>(</span>request<span>.</span><span>getMethodName</span><span>(</span><span>)</span><span>,</span> request<span>.</span><span>getArgsType</span><span>(</span><span>)</span><span>)</span><span>;</span>\n                <span>Constructor</span><span><span>&lt;</span><span>?</span><span>></span></span> constructor <span>=</span> serviceType<span>.</span><span>getConstructor</span><span>(</span><span>)</span><span>;</span>\n                <span>Object</span> instance <span>=</span> constructor<span>.</span><span>newInstance</span><span>(</span><span>)</span><span>;</span>\n                <span>//3. 反射执行结果</span>\n                <span>Object</span> invoke <span>=</span> method<span>.</span><span>invoke</span><span>(</span>instance<span>,</span> request<span>.</span><span>getArgs</span><span>(</span><span>)</span><span>)</span><span>;</span>\n                response<span>.</span><span>setSuccess</span><span>(</span><span>true</span><span>)</span><span>;</span>\n                response<span>.</span><span>setResult</span><span>(</span>invoke<span>)</span><span>;</span>\n            <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n                e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n                response<span>.</span><span>setSuccess</span><span>(</span><span>false</span><span>)</span><span>;</span>\n            <span>}</span>\n            <span>return</span> response<span>;</span>\n        <span>}</span><span>)</span><span>;</span>\n        serverCreator<span>.</span><span>create</span><span>(</span><span>)</span><span>.</span><span>start</span><span>(</span><span>8084</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h4 id=\"构建客户端\"> 构建客户端</h4>\n<p><code>RpcResponse{id=1, protocolType=2, serializationType=3, type=1, timeout=0, serviceType=null, methodName='null', argsType=null, result=反射执行:欢迎关注程序猿升级课, success=true, message='null', code=null, returnType=null}</code></p>\n<div><pre><code> @Test\n    public void testRpcClient() throws Exception {\n        Client&lt;RpcRequest, RpcResponse&gt; client = Installer.client(RpcRequest.class, RpcResponse.class).create();\n        client.connect(&quot;127.0.0.1&quot;, 8084);\n        RpcRequest rpcRequest = new RpcRequest();\n        rpcRequest.setServiceType(UserInvoker.class);\n        rpcRequest.setMethodName(&quot;getName&quot;);\n        rpcRequest.setArgsType(new Class[]{String.class});\n        rpcRequest.setArgs(new Object[]{&quot;欢迎关注程序猿升级课&quot;});\n        MojitoFuture&lt;RpcResponse&gt; future = client.sendAsync(rpcRequest);\n        System.out.println(future.get());\n    }\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id=\"_3-实现一个mq消息系统\"> 3. 实现一个MQ消息系统</h3>\n<p>消息系统如何实现?</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcuc3ByaW5nbGVhcm4uY24vYmxvZy9sZWFybl8xNTk5MjE4MzkxMDAwLnBuZw?x-oss-process=image/format,png\" alt=\"\" loading=\"lazy\"></p>\n<h4 id=\"服务端\"> 服务端</h4>\n<div><pre><code> <span>@Test</span>\n    <span>public</span> <span>void</span> <span>queueTest</span><span>(</span><span>)</span> <span>{</span>\n        <span>Installer</span><span>.</span><span>server</span><span>(</span><span>Message</span><span>.</span><span>class</span><span>,</span> <span>QueueStatus</span><span>.</span><span>class</span><span>)</span>\n\n                <span>.</span><span>serverHandler</span><span>(</span><span>new</span> <span>SubServerHandler</span><span><span>&lt;</span><span>Message</span><span>,</span> <span>QueueStatus</span><span>></span></span><span>(</span><span>)</span> <span>{</span>\n\n                    <span>//1. 收到消息之后如果处理成功就返回给客户端。</span>\n\n                    <span>//2. 如果是订阅的链接,就启动服务去消费。</span>\n                    <span>private</span> <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>List</span><span>&lt;</span><span>EnhanceChannel</span><span>></span><span>></span></span> routeKeyChannelMap <span>=</span> <span>new</span> <span>ConcurrentHashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n\n                    <span>private</span> <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Queue</span><span>&lt;</span><span>String</span><span>></span><span>></span></span> routeKeyQueueMap <span>=</span> <span>new</span> <span>ConcurrentHashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n\n                    <span>private</span> <span>AtomicBoolean</span> atomicBoolean <span>=</span> <span>new</span> <span>AtomicBoolean</span><span>(</span><span>false</span><span>)</span><span>;</span>\n\n\n                    <span>@Override</span>\n                    <span>public</span> <span>QueueStatus</span> <span>handler</span><span>(</span><span>EnhanceChannel</span> channel<span>,</span> <span>Message</span> message<span>)</span> <span>{</span>\n                        <span>ProtocolEnum</span> protocolEnum <span>=</span> <span>ProtocolEnum</span><span>.</span><span>byType</span><span>(</span>message<span>.</span><span>getProtocolType</span><span>(</span><span>)</span><span>)</span><span>;</span>\n                        <span>//1. 如果发现是注册协议,就将当前客户端的连接给保存到指定的topic里面</span>\n                        <span>if</span> <span>(</span>protocolEnum <span>==</span> <span>ProtocolEnum</span><span>.</span>MQ_REG<span>)</span> <span>{</span>\n                            <span>List</span><span><span>&lt;</span><span>EnhanceChannel</span><span>></span></span> enhanceChannels <span>=</span> routeKeyChannelMap<span>.</span><span>computeIfAbsent</span><span>(</span>message<span>.</span>routeKey<span>,</span> k <span>-></span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>)</span><span>;</span>\n                            enhanceChannels<span>.</span><span>add</span><span>(</span>channel<span>)</span><span>;</span>\n                            <span>return</span> <span>new</span> <span>QueueStatus</span><span>(</span><span>\"订阅成功\"</span><span>)</span><span>;</span>\n                        <span>}</span> <span>else</span> <span>if</span> <span>(</span>protocolEnum <span>==</span> <span>ProtocolEnum</span><span>.</span>MQ_SEND<span>)</span> <span>{</span>\n                            <span>//2. 如果发现是发送协议,就向指定的topic去添加一条消息</span>\n                            <span>Queue</span><span><span>&lt;</span><span>String</span><span>></span></span> queue <span>=</span> routeKeyQueueMap<span>.</span><span>get</span><span>(</span>message<span>.</span>routeKey<span>)</span><span>;</span>\n                            <span>if</span> <span>(</span>queue <span>==</span> <span>null</span><span>)</span> <span>{</span>\n                                queue <span>=</span> <span>new</span> <span>ArrayBlockingQueue</span><span><span>&lt;</span><span>String</span><span>></span></span><span>(</span><span>23</span><span>)</span><span>;</span>\n                                routeKeyQueueMap<span>.</span><span>put</span><span>(</span>message<span>.</span>routeKey<span>,</span> queue<span>)</span><span>;</span>\n                            <span>}</span>\n                            queue<span>.</span><span>add</span><span>(</span>message<span>.</span>message<span>)</span><span>;</span>\n                            <span>//3. 启动一个线程去将topic信息,推送给客户端</span>\n                            <span>messageProcessing</span><span>(</span><span>)</span><span>;</span>\n                            <span>return</span> <span>new</span> <span>QueueStatus</span><span>(</span><span>\"发送成功\"</span><span>)</span><span>;</span>\n                        <span>}</span>\n\n                        <span>//推送给客户端,并收到客户端消息。看是否要把消息移出。</span>\n                        <span>return</span> <span>new</span> <span>QueueStatus</span><span>(</span><span>\"未知\"</span><span>)</span><span>;</span>\n                    <span>}</span>\n\n\n                    <span>private</span> <span>void</span> <span>messageProcessing</span><span>(</span><span>)</span> <span>{</span>\n                        <span>if</span> <span>(</span><span>!</span>atomicBoolean<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n                            atomicBoolean<span>.</span><span>compareAndSet</span><span>(</span>atomicBoolean<span>.</span><span>get</span><span>(</span><span>)</span><span>,</span> <span>true</span><span>)</span><span>;</span>\n                            <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>\n                                <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>\n                                    <span>for</span> <span>(</span><span>Map<span>.</span>Entry</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Queue</span><span>&lt;</span><span>String</span><span>></span><span>></span></span> queueEntry <span>:</span> routeKeyQueueMap<span>.</span><span>entrySet</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n                                        <span>String</span> routeKey <span>=</span> queueEntry<span>.</span><span>getKey</span><span>(</span><span>)</span><span>;</span>\n                                        <span>Queue</span><span><span>&lt;</span><span>String</span><span>></span></span> routeKeyMessages <span>=</span> queueEntry<span>.</span><span>getValue</span><span>(</span><span>)</span><span>;</span>\n                                        <span>String</span> message <span>=</span> routeKeyMessages<span>.</span><span>poll</span><span>(</span><span>)</span><span>;</span>\n                                        <span>if</span> <span>(</span><span>!</span><span>StringTools</span><span>.</span><span>isBlank</span><span>(</span>message<span>)</span><span>)</span> <span>{</span>\n                                            <span>//获取到订阅的链接</span>\n                                            <span>List</span><span><span>&lt;</span><span>EnhanceChannel</span><span>></span></span> enhanceChannels <span>=</span> routeKeyChannelMap<span>.</span><span>get</span><span>(</span>routeKey<span>)</span><span>;</span>\n                                            <span>for</span> <span>(</span><span>EnhanceChannel</span> enhanceChannel <span>:</span> enhanceChannels<span>)</span> <span>{</span>\n                                                <span>if</span> <span>(</span>enhanceChannel<span>.</span><span>isConnected</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n                                                    <span>Message</span> serverMsg <span>=</span> <span>new</span> <span>Message</span><span>(</span>routeKey<span>,</span> message<span>)</span><span>;</span>\n                                                    serverMsg<span>.</span><span>setProtocolType</span><span>(</span><span>ProtocolEnum</span><span>.</span>MQ_SEND<span>.</span><span>getType</span><span>(</span><span>)</span><span>)</span><span>;</span>\n                                                    enhanceChannel<span>.</span><span>send</span><span>(</span>serverMsg<span>)</span><span>;</span>\n                                                <span>}</span> <span>else</span> <span>{</span>\n                                                    enhanceChannels<span>.</span><span>remove</span><span>(</span>enhanceChannel<span>)</span><span>;</span>\n                                                <span>}</span>\n                                            <span>}</span>\n                                        <span>}</span>\n                                    <span>}</span>\n                                <span>}</span>\n                            <span>}</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n                        <span>}</span>\n                    <span>}</span>\n                <span>}</span><span>)</span><span>.</span><span>create</span><span>(</span><span>)</span><span>.</span><span>start</span><span>(</span><span>12306</span><span>)</span><span>;</span>\n\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br></div></div>",
      "image": "https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcuc3ByaW5nbGVhcm4uY24vYmxvZy9sZWFybl8xNTk5MjIxNjk5MDAwLnBuZw?x-oss-process=image/format,png",
      "date_published": "2022-07-09T04:36:00.000Z",
      "date_modified": "2022-07-09T04:36:00.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "SpringBoot Testing",
      "url": "https://java.springlearn.cn/learn/test/SpringBootTesting/",
      "id": "https://java.springlearn.cn/learn/test/SpringBootTesting/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/learn_1618140868000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>前面我们对Mockito的用法有了一个了解,这里告诉大家一个好消息,SpringBoot已经帮我们继承了\n这些框架,而且提供了更加简单好用的API。</p>\n<h2 id=\"一、mockito加载方式\"> 一、Mockito加载方式</h2>\n<p>前面我们说了两种加载方式 <code>MockitoJUnitRunner</code> 和 <code>MockitoAnnotations.initMocks(this);</code>\n这些在SpringBoot中都不需要了。</p>\n<p>所以这一段就是废话, 不用在看了。但是相信你已经看完了。</p>\n<h2 id=\"二、mockito必知概念\"> 二、Mockito必知概念</h2>\n<p>这些概念,参考Mockito章节,概念统统保留。</p>\n<h3 id=\"_2-1-完全模拟-mockbean\"> 2.1 完全模拟 MockBean</h3>\n<p>只需要将@Mock 换成 @MockBean即可</p>\n<h3 id=\"_2-2-部分模拟-spybean\"> 2.2 部分模拟 SpyBean</h3>\n<p>只需要将@Spy 换成 @MockBean即可。主要这里有一个小坑。\n如果是Feign接口,使用@SpyBean会报错。提示final class不能被代理。</p>\n<p>原因是SpringBoot依赖的Mockito版本太古老了,是2.23.4。从Mockito2.7.6\n开始已经解决了这个问题, 我们可以通过引入下面依赖解决。</p>\n<div><pre><code> <span><span><span>&lt;</span>dependency</span><span>></span></span>\n    <span><span><span>&lt;</span>groupId</span><span>></span></span>org.mockito<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n    <span><span><span>&lt;</span>artifactId</span><span>></span></span>mockito-inline<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n    <span><span><span>&lt;</span>version</span><span>></span></span>3.3.3<span><span><span>&lt;/</span>version</span><span>></span></span>\n<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>解决方案就是帮我们新增了一个配置,启动Mockit的插件来生成代理。\n大概原理就是及不实用JDK代理,也不是Cglib代理。\n<code>DefaultMockitoPlugins</code> &amp; <code>InlineByteBuddyMockMaker</code>\n<img src=\"https://img.springlearn.cn/blog/learn_1617877205000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"三、代码实例\"> 三、代码实例</h2>\n<h3 id=\"_3-1-mockbean-完全模拟\"> 3.1 @MockBean 完全模拟</h3>\n<p>没有被声明的方法返回值,对象类型返回null,基本类型是返回默认类型。</p>\n<p>@MockBean完全模拟</p>\n<div><pre><code>\n\n<span>public</span> <span>class</span> <span>TradeShopIntegrationImplTest</span> <span>extends</span> <span>BaseApplicationTest</span> <span>{</span>\n\n    <span>@Autowired</span>\n    <span>private</span> <span>TradeShopIntegration</span> shopBrandIntegration<span>;</span>\n\n    <span>@MockBean</span>\n    <span>private</span> <span>BrandServiceApi</span> brandService<span>;</span>\n    \n    <span>@MockBean</span>\n    <span>private</span> <span>GoodsStockApi</span> goodsStockApi<span>;</span>\n    \n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>testGetAllBrands</span><span>(</span><span>)</span> <span>{</span>\n        <span>Mockito</span><span>.</span><span>doReturn</span><span>(</span><span>JsonResult</span><span>.</span><span>failure</span><span>(</span><span>\"fail\"</span><span>)</span><span>)</span><span>.</span><span>when</span><span>(</span>goodsStockApi<span>)</span><span>.</span><span>getSkuList</span><span>(</span><span>Mockito</span><span>.</span><span>any</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// 底层调用的是goodsStockApi.getSkuList()</span>\n        <span>List</span><span><span>&lt;</span><span>GoodsBaseMsgDTO</span><span>></span></span> goodsBaseMsgDTOS <span>=</span> shopBrandIntegration<span>.</span><span>queryAllSku</span><span>(</span><span>)</span><span>;</span>\n        <span>// 因为前面声明了返回fail。所以这里没有数据返回。</span>\n        <span>JsonConsoleUtils</span><span>.</span><span>println</span><span>(</span>goodsBaseMsgDTOS<span>)</span><span>;</span>\n        <span>// 这里因为使用的是Mock完全模拟,所以尽管前面没有声明返回值,就默认返回null</span>\n        <span>List</span><span><span>&lt;</span><span>OutBrandDTO</span><span>></span></span> allBrands <span>=</span> shopBrandIntegration<span>.</span><span>getAllBrands</span><span>(</span><span>)</span><span>;</span>\n        <span>JsonConsoleUtils</span><span>.</span><span>println</span><span>(</span>allBrands<span>)</span><span>;</span>\n    <span>}</span>\n    \n<span>}</span>    \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><h3 id=\"_3-1-spybean-部分模拟\"> 3.1 @SpyBean 部分模拟</h3>\n<p>没有被声明的方法返回值,走原来逻辑。</p>\n<p>@SpyBean部分模拟</p>\n<div><div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br></div><pre><code>\n\n<span>public</span> <span>class</span> <span>TradeShopIntegrationImplTest</span> <span>extends</span> <span>BaseApplicationTest</span> <span>{</span>\n\n    <span>@Autowired</span>\n    <span>private</span> <span>TradeShopIntegration</span> shopBrandIntegration<span>;</span>\n\n    <span>@MockBean</span>\n    <span>private</span> <span>BrandServiceApi</span> brandService<span>;</span>\n    \n    <span>@MockBean</span>\n    <span>private</span> <span>GoodsStockApi</span> goodsStockApi<span>;</span>\n    \n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>testGetAllBrands</span><span>(</span><span>)</span> <span>{</span>\n        <span>Mockito</span><span>.</span><span>doReturn</span><span>(</span><span>JsonResult</span><span>.</span><span>failure</span><span>(</span><span>\"fail\"</span><span>)</span><span>)</span><span>.</span><span>when</span><span>(</span>goodsStockApi<span>)</span><span>.</span><span>getSkuList</span><span>(</span><span>Mockito</span><span>.</span><span>any</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// 底层调用的是goodsStockApi.getSkuList()</span>\n        <span>List</span><span><span>&lt;</span><span>GoodsBaseMsgDTO</span><span>></span></span> goodsBaseMsgDTOS <span>=</span> shopBrandIntegration<span>.</span><span>queryAllSku</span><span>(</span><span>)</span><span>;</span>\n        <span>// 因为前面声明了返回fail。所以这里没有数据返回。</span>\n        <span>JsonConsoleUtils</span><span>.</span><span>println</span><span>(</span>goodsBaseMsgDTOS<span>)</span><span>;</span>\n        <span>// 这里跟上面的区别就是,如果没有声明返回值,就走原来的方法。</span>\n        <span>List</span><span><span>&lt;</span><span>OutBrandDTO</span><span>></span></span> allBrands <span>=</span> shopBrandIntegration<span>.</span><span>getAllBrands</span><span>(</span><span>)</span><span>;</span>\n        <span>JsonConsoleUtils</span><span>.</span><span>println</span><span>(</span>allBrands<span>)</span><span>;</span>\n    <span>}</span>\n    \n<span>}</span>    \n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div>",
      "image": "https://img.springlearn.cn/blog/learn_1618140868000.png",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "第09篇:Formatter 格式转换",
      "url": "https://java.springlearn.cn/learn/spring/core11/",
      "id": "https://java.springlearn.cn/learn/spring/core11/",
      "content_html": "<p><img src=\"https://img-blog.csdnimg.cn/img_convert/aa1d259419ff268edc2fe3088f940556.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>公众号</strong>: 西魏陶渊明<br/>\n<strong>CSDN</strong>: <a href=\"https://springlearn.blog.csdn.net/?type=blog\" target=\"_blank\" rel=\"noopener noreferrer\">https://springlearn.blog.csdn.net</a><br/></p>\n<blockquote>\n<p>天下代码一大抄, 抄来抄去有提高, 看你会抄不会抄！</p>\n</blockquote>\n<h2 id=\"一、前言\"> 一、前言</h2>\n<h2 id=\"二、知识点\"> 二、知识点</h2>\n<h3 id=\"_2-1-beanfactory-工厂\"> 2.1 BeanFactory 工厂</h3>\n<h3 id=\"_2-2-applicationcontext-容器上下文\"> 2.2 ApplicationContext 容器上下文</h3>\n",
      "image": "https://img.springlearn.cn/blog/b8f74de10af99991e3fc73632eeeb190.png",
      "date_published": "2022-09-24T09:40:46.000Z",
      "date_modified": "2023-02-08T03:23:43.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "Spring Framework"
      ]
    },
    {
      "title": "Mockito API",
      "url": "https://java.springlearn.cn/learn/test/MockitoAPI/",
      "id": "https://java.springlearn.cn/learn/test/MockitoAPI/",
      "content_html": "<div><p>注意</p>\n<p>这里只是介绍原生的Mockito的API,针对SpringBoot应用有更简单的调用方式</p>\n</div>\n<h2 id=\"一、mockito加载方式\"> 一、Mockito加载方式</h2>\n<p>Mockito可以配合JUnit使用,也可以单独使用。有两种方式来引入Mockito</p>\n<h3 id=\"_1-1-方式-1-不依赖spring容器\"> 1.1 方式:1 不依赖Spring容器</h3>\n<p>如果你的单测不依赖容器,那么使用这种方式是比较方便和简介的。但是如果\n依赖容器,我们是到JUnit的原理是只要发现有一个Runner就会返回,如果这里指定了\nMockitoJUnitRunner那么SpringRunner就不会被使用。</p>\n<p>指定MockitoJUnitRunner</p>\n<div><pre><code>   <span>@RunWith</span><span>(</span><span>MockitoJUnitRunner</span><span>.</span><span>class</span><span>)</span>\n   <span>public</span> <span>class</span> <span>ExampleTest</span> <span>{</span>\n   \n       <span>@Mock</span>\n       <span>private</span> <span>List</span> list<span>;</span>\n   \n       <span>@Test</span>\n       <span>public</span> <span>void</span> <span>shouldDoSomething</span><span>(</span><span>)</span> <span>{</span>\n           list<span>.</span><span>add</span><span>(</span><span>100</span><span>)</span><span>;</span>\n       <span>}</span>\n   <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id=\"_1-2-方式-2-依赖容器\"> 1.2 方式:2 依赖容器</h3>\n<p>方式2是依赖于Spring容器的,所以要求我们在单测方法执行前来通知Mockito来处理\n他的逻辑,处理他说使用的注解。JUnit4的@Before注解就是做好的加载时机,因为我们\n可以这样写。</p>\n<div><pre><code>   <span>/**\n     * 将单测类中依赖Mockito的属性,进行处理。\n     * 帮我们实现 Mockito.mock()\n     */</span>\n    <span>@Before</span>\n    <span>public</span> <span>void</span> <span>setUp</span><span>(</span><span>)</span> <span>{</span>\n        <span>MockitoAnnotations</span><span>.</span><span>initMocks</span><span>(</span><span>this</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id=\"二、mockito必知概念\"> 二、Mockito必知概念</h2>\n<h3 id=\"_2-1-完全模拟-mock\"> 2.1 完全模拟 Mock</h3>\n<p>什么是完全模拟,使用的注解就是@Mock。被Mock的对象,所有的方法都不会被\n真正的执行。</p>\n<h3 id=\"_2-2-部分模拟-spy\"> 2.2 部分模拟 Spy</h3>\n<p>部分模拟,使用的注解就是@Spy(间谍一样)。被声明的方法走Mock,没有声明的方法\n还是由实例进行执行和反馈。</p>\n<h2 id=\"三、代码实例\"> 三、代码实例</h2>\n<p>这里的例子我们为了启动快速,不依赖Spring容器。直接new出来对象。\n另外多说一句,其实就算依赖Spring容器,当@Before方法执行前所有的示例其实也都是已经注入好的了。</p>\n<p>下面所有的演示围绕这个类进行</p>\n<div><pre><code><span>public</span> <span>class</span> <span>MockitoEmp</span> <span>{</span>\n        <span>public</span> <span>String</span> <span>getName</span><span>(</span><span>)</span> <span>{</span>\n            <span>return</span> <span>\"真实的MockitoTest\"</span><span>;</span>\n        <span>}</span>\n\n        <span>public</span> <span>Integer</span> <span>getAge</span><span>(</span><span>)</span> <span>{</span>\n            <span>return</span> <span>23</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"_3-1-mock\"> 3.1 @Mock</h3>\n<p>手动声明</p>\n<div><pre><code><span>MockitoEmp</span> mock <span>=</span> <span>Mockito</span><span>.</span><span>mock</span><span>(</span><span>MockitoEmp</span><span>.</span><span>class</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><div><p>说明</p>\n<p>前面说了这个是完全模拟,所有的动作都是模拟的。看下面代码颜色\n标记的地方,我们只声明了getName使用Mock返回。但是当我们\n调用getAge() 的时候竟然也是假数据。</p>\n</div>\n<p>基于注解和@Before自动声明</p>\n<div><div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br></div><pre><code>\n<span>public</span> <span>class</span> <span>MockitoTest</span> <span>{</span>\n\n    <span>// 整个对象都是Mock的</span>\n    <span>@Mock</span>\n    <span>private</span> <span>MockitoEmp</span> mock <span>=</span> <span>new</span> <span>MockitoEmp</span><span>(</span><span>)</span><span>;</span>\n\n    <span>/**\n     * 将单测类中依赖Mockito的属性,进行处理。\n     * 帮我们实现 Mockito.mock()\n     */</span>\n    <span>@Before</span>\n    <span>public</span> <span>void</span> <span>setUp</span><span>(</span><span>)</span> <span>{</span>\n        <span>MockitoAnnotations</span><span>.</span><span>initMocks</span><span>(</span><span>this</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>testMock</span><span>(</span><span>)</span> <span>{</span>\n        <span>Mockito</span><span>.</span><span>doReturn</span><span>(</span><span>\"Mock数据\"</span><span>)</span><span>.</span><span>when</span><span>(</span>mock<span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>;</span>\n        <span>//等价于Mockito.when(mock.getName()).thenReturn(\"Mock数据\");</span>\n        <span>// Mock数据</span>\n        <span>Assert</span><span>.</span><span>assertSame</span><span>(</span><span>\"Mock数据\"</span><span>,</span> mock<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// getAge() 方法没有用Mockito声明动作, 应该是多少呢?</span>\n        <span>Assert</span><span>.</span><span>assertSame</span><span>(</span><span>0</span><span>,</span> mock<span>.</span><span>getAge</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// 0</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>mock<span>.</span><span>getAge</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><h3 id=\"_3-2-spy\"> 3.2 @Spy</h3>\n<p>手动声明</p>\n<div><pre><code><span>MockitoEmp</span> spy <span>=</span> <span>Mockito</span><span>.</span><span>spy</span><span>(</span><span>MockitoEmp</span><span>.</span><span>class</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><div><p>说明</p>\n<p>Spy部分模拟,下面的例子和上面基本一样,唯一不一样的是我们吧 @Mock换成了@Spy。\n此时getAge() 方法就不是模拟的了。</p>\n</div>\n<p>基于注解和@Before自动声明</p>\n<div><div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><div>&nbsp;</div><br><br><br><br><br><br></div><pre><code>\n<span>public</span> <span>class</span> <span>MockitoTest</span> <span>{</span>\n\n    <span>// 整个对象都是Mock的</span>\n    <span>@Mock</span>\n    <span>private</span> <span>MockitoEmp</span> mock <span>=</span> <span>new</span> <span>MockitoEmp</span><span>(</span><span>)</span><span>;</span>\n\n    <span>/**\n     * 将单测类中依赖Mockito的属性,进行处理。\n     * 帮我们实现 Mockito.mock()\n     */</span>\n    <span>@Before</span>\n    <span>public</span> <span>void</span> <span>setUp</span><span>(</span><span>)</span> <span>{</span>\n        <span>MockitoAnnotations</span><span>.</span><span>initMocks</span><span>(</span><span>this</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>testSpy</span><span>(</span><span>)</span> <span>{</span>\n        <span>Mockito</span><span>.</span><span>doReturn</span><span>(</span><span>\"Mock数据\"</span><span>)</span><span>.</span><span>when</span><span>(</span>spy<span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>;</span>\n        <span>// Mock数据</span>\n        <span>Assert</span><span>.</span><span>assertSame</span><span>(</span><span>\"Mock数据\"</span><span>,</span> spy<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// getAge() 方法没有用Mockito声明动作, 应该是多少呢?</span>\n        <span>Assert</span><span>.</span><span>assertSame</span><span>(</span><span>23</span><span>,</span> spy<span>.</span><span>getAge</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// 23</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>spy<span>.</span><span>getAge</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div>",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "MockData API",
      "url": "https://java.springlearn.cn/learn/test/MockDataAPI/",
      "id": "https://java.springlearn.cn/learn/test/MockDataAPI/",
      "content_html": "<p><code>JMockData</code> 是一款国人开发用来生成模拟数据的工具</p>\n<h2 id=\"基础类型\"> 基础类型</h2>\n<table>\n<thead>\n<tr>\n<th>描述</th>\n<th>类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>基础类型</td>\n<td><code>byte</code> <code>boolean</code> <code>char</code> <code>short</code> <code>int</code> <code>long</code> <code>float</code> <code>double</code></td>\n</tr>\n<tr>\n<td>包装类型包装</td>\n<td><code>Byte</code> <code>Boolean</code> <code>Character</code> <code>Short</code> <code>Integer</code> <code>Long</code> <code>Float</code> <code>Double</code></td>\n</tr>\n<tr>\n<td>常用类型</td>\n<td><code>BigDecimal</code> <code>BigInteger</code> <code>Date</code> <code>LocalDateTime</code> <code>LocalDate</code> <code>LocalTime</code> <code>java.sql.Timestamp</code> <code>String</code> <code>Enum</code></td>\n</tr>\n<tr>\n<td>多维数组</td>\n<td>以上所有类型的多维数组 如：<code>int[]</code> <code>int[][]</code> <code>int[][][]</code> .... etc.</td>\n</tr>\n</tbody>\n</table>\n<div><pre><code><span>//基本类型模拟</span>\n<span>int</span> intNum <span>=</span> <span>JMockData</span><span>.</span><span>mock</span><span>(</span><span>int</span><span>.</span><span>class</span><span>)</span><span>;</span>\n<span>int</span><span>[</span><span>]</span> intArray <span>=</span> <span>JMockData</span><span>.</span><span>mock</span><span>(</span><span>int</span><span>[</span><span>]</span><span>.</span><span>class</span><span>)</span><span>;</span>\n<span>Integer</span> integer <span>=</span> <span>JMockData</span><span>.</span><span>mock</span><span>(</span><span>Integer</span><span>.</span><span>class</span><span>)</span><span>;</span>\n<span>Integer</span><span>[</span><span>]</span> integerArray <span>=</span> <span>JMockData</span><span>.</span><span>mock</span><span>(</span><span>Integer</span><span>[</span><span>]</span><span>.</span><span>class</span><span>)</span><span>;</span>\n<span>//常用类型模拟</span>\n<span>BigDecimal</span> bigDecimal <span>=</span> <span>JMockData</span><span>.</span><span>mock</span><span>(</span><span>BigDecimal</span><span>.</span><span>class</span><span>)</span><span>;</span>\n<span>BigInteger</span> bigInteger <span>=</span> <span>JMockData</span><span>.</span><span>mock</span><span>(</span><span>BigInteger</span><span>.</span><span>class</span><span>)</span><span>;</span>\n<span>Date</span> date <span>=</span> <span>JMockData</span><span>.</span><span>mock</span><span>(</span><span>Date</span><span>.</span><span>class</span><span>)</span><span>;</span>\n<span>String</span> str <span>=</span> <span>JMockData</span><span>.</span><span>mock</span><span>(</span><span>String</span><span>.</span><span>class</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id=\"java对象\"> JAVA对象</h2>\n<p>模拟bean，被模拟的数据最好是plain bean，通过反射给属性赋值。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>User</span> <span>{</span>\n\n    <span>private</span> <span>String</span> name<span>;</span>\n\n    <span>private</span> <span>int</span> age<span>;</span>\n\n    <span>private</span> <span>long</span> cardId<span>;</span>\n    \n<span>}</span>  \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>test</span><span>(</span><span>)</span> <span>{</span>\n        <span>User</span> mock <span>=</span> <span>JMockData</span><span>.</span><span>mock</span><span>(</span><span>User</span><span>.</span><span>class</span><span>)</span><span>;</span>\n        <span>// User{name='jrq2b', age=9338, cardId=2850}</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>mock<span>)</span><span>;</span>\n    <span>}</span>  \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id=\"容器类型\"> 容器类型</h2>\n<div><pre><code><span>@Test</span>\n<span>//******注意TypeReference要加{}才能模拟******</span>\n<span>public</span> <span>void</span> <span>testTypeRefrence</span><span>(</span><span>)</span> <span>{</span>\n  <span>//模拟基础类型，不建议使用这种方式，参考基础类型章节直接模拟。</span>\n  <span>Integer</span> integerNum <span>=</span> <span>JMockData</span><span>.</span><span>mock</span><span>(</span><span>new</span> <span>TypeReference</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>(</span><span>)</span><span>{</span><span>}</span><span>)</span><span>;</span>\n  <span>Integer</span><span>[</span><span>]</span> integerArray <span>=</span> <span>JMockData</span><span>.</span><span>mock</span><span>(</span><span>new</span> <span>TypeReference</span><span>&lt;</span><span>Integer</span><span>[</span><span>]</span><span>></span><span>(</span><span>)</span><span>{</span><span>}</span><span>)</span><span>;</span>\n  <span>//模拟集合</span>\n  <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> integerList <span>=</span> <span>JMockData</span><span>.</span><span>mock</span><span>(</span><span>new</span> <span>TypeReference</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span><span>(</span><span>)</span><span>{</span><span>}</span><span>)</span><span>;</span>\n  <span>//模拟数组集合</span>\n  <span>List</span><span>&lt;</span><span>Integer</span><span>[</span><span>]</span><span>></span> integerArrayList <span>=</span> <span>JMockData</span><span>.</span><span>mock</span><span>(</span><span>new</span> <span>TypeReference</span><span>&lt;</span><span>List</span><span>&lt;</span><span>Integer</span><span>[</span><span>]</span><span>>></span><span>(</span><span>)</span><span>{</span><span>}</span><span>)</span><span>;</span>\n  <span>//模拟集合数组</span>\n  <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>[</span><span>]</span> integerListArray <span>=</span> <span>JMockData</span><span>.</span><span>mock</span><span>(</span><span>new</span> <span>TypeReference</span><span>&lt;</span><span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>[</span><span>]</span><span>></span><span>(</span><span>)</span><span>{</span><span>}</span><span>)</span><span>;</span>\n  <span>//模拟集合实体</span>\n  <span>List</span><span><span>&lt;</span><span>BasicBean</span><span>></span></span> basicBeanList <span>=</span> <span>JMockData</span><span>.</span><span>mock</span><span>(</span><span>new</span> <span>TypeReference</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>BasicBean</span><span>></span><span>></span></span><span>(</span><span>)</span><span>{</span><span>}</span><span>)</span><span>;</span>\n  <span>//各种组合忽略。。。。map同理。下面模拟一个不知道什么类型的map</span>\n  <span>Map</span><span>&lt;</span><span>List</span><span>&lt;</span><span>Map</span><span>&lt;</span><span>Integer</span><span>,</span> <span>String</span><span>[</span><span>]</span><span>[</span><span>]</span><span>>></span><span>,</span> <span>Map</span><span>&lt;</span><span>Set</span><span><span>&lt;</span><span>String</span><span>></span></span><span>,</span> <span>Double</span><span>[</span><span>]</span><span>>></span> some <span>=</span> <span>JMockData</span><span>.</span><span>mock</span><span>(</span><span>new</span> <span>TypeReference</span><span>&lt;</span><span>Map</span><span>&lt;</span><span>List</span><span>&lt;</span><span>Map</span><span>&lt;</span><span>Integer</span><span>,</span> <span>String</span><span>[</span><span>]</span><span>[</span><span>]</span><span>>></span><span>,</span> <span>Map</span><span>&lt;</span><span>Set</span><span><span>&lt;</span><span>String</span><span>></span></span><span>,</span> <span>Double</span><span>[</span><span>]</span><span>>>></span><span>(</span><span>)</span><span>{</span><span>}</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h2 id=\"范围配置\"> 范围配置</h2>\n<p>前面说了可以模拟各种数据,不同类型的数据都允许指定一个范围。\n如下</p>\n<div><pre><code><span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>\n<span>JMockData</span><span>.</span><span>mock</span><span>(</span><span>Date</span><span>.</span><span>class</span><span>,</span><span>MockConfig</span><span>.</span><span>newInstance</span><span>(</span><span>)</span>\n<span>.</span><span>dateRange</span><span>(</span><span>\"2018-11-20\"</span><span>,</span> <span>\"2018-11-30\"</span><span>)</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div允许指定模拟数据的范围或者是排除\" line-numbers-mode\"><pre><code>        <span>MockConfig</span> mockConfig <span>=</span> <span>new</span> <span>MockConfig</span><span>(</span><span>)</span>\n                <span>// 全局配置</span>\n                <span>.</span><span>globalConfig</span><span>(</span><span>)</span>\n                <span>.</span><span>setEnabledStatic</span><span>(</span><span>false</span><span>)</span>\n                <span>.</span><span>setEnabledPrivate</span><span>(</span><span>false</span><span>)</span>\n                <span>.</span><span>setEnabledPublic</span><span>(</span><span>false</span><span>)</span>\n                <span>.</span><span>setEnabledProtected</span><span>(</span><span>false</span><span>)</span>\n                <span>.</span><span>sizeRange</span><span>(</span><span>1</span><span>,</span> <span>1</span><span>)</span>\n                <span>.</span><span>charSeed</span><span>(</span><span>(</span><span>char</span><span>)</span> <span>97</span><span>,</span> <span>(</span><span>char</span><span>)</span> <span>98</span><span>)</span>\n                <span>.</span><span>byteRange</span><span>(</span><span>(</span><span>byte</span><span>)</span> <span>0</span><span>,</span> <span>Byte</span><span>.</span>MAX_VALUE<span>)</span>\n                <span>.</span><span>shortRange</span><span>(</span><span>(</span><span>short</span><span>)</span> <span>0</span><span>,</span> <span>Short</span><span>.</span>MAX_VALUE<span>)</span>\n                <span>// 某些字段（名等于integerNum的字段、包含float的字段、double开头的字段）配置</span>\n                <span>.</span><span>subConfig</span><span>(</span><span>\"integerNum\"</span><span>,</span> <span>\"*float*\"</span><span>,</span> <span>\"double*\"</span><span>)</span>\n                <span>.</span><span>intRange</span><span>(</span><span>10</span><span>,</span> <span>11</span><span>)</span>\n                <span>.</span><span>floatRange</span><span>(</span><span>1.22f</span><span>,</span> <span>1.50f</span><span>)</span>\n                <span>.</span><span>doubleRange</span><span>(</span><span>1.50</span><span>,</span> <span>1.99</span><span>)</span>\n                <span>.</span><span>longRange</span><span>(</span><span>12</span><span>,</span> <span>13</span><span>)</span>\n                <span>.</span><span>dateRange</span><span>(</span><span>\"2018-11-20\"</span><span>,</span> <span>\"2018-11-30\"</span><span>)</span>\n                <span>.</span><span>stringSeed</span><span>(</span><span>\"SAVED\"</span><span>,</span> <span>\"REJECT\"</span><span>,</span> <span>\"APPROVED\"</span><span>)</span>\n                <span>.</span><span>sizeRange</span><span>(</span><span>1</span><span>,</span> <span>1</span><span>)</span>\n                <span>// 全局配置</span>\n                <span>.</span><span>globalConfig</span><span>(</span><span>)</span>\n                <span>// 排除所有包含list/set/map字符的字段。表达式不区分大小写。</span>\n                <span>.</span><span>excludes</span><span>(</span><span>\"*List*\"</span><span>,</span> <span>\"*Set*\"</span><span>,</span> <span>\"*Map*\"</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div>",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "命名规则",
      "url": "https://java.springlearn.cn/learn/test/%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/",
      "id": "https://java.springlearn.cn/learn/test/%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/",
      "content_html": "<div><p>命名规则</p>\n<p>单测类: 类名 + <code>Test</code> 整体大驼峰</p>\n<p>单测方法: <code>test</code> + 方法名 整体小驼峰</p>\n</div>\n<h3 id=\"保证目录结构是一致的\"> 保证目录结构是一致的</h3>\n<p>在这里有个误区,发现很多同学都是随意去创建测试类,其实这不是一个好的习惯,在Maven项目中,\n要尽量保证测试类与被测类的目录结构是一致的。如下图一样。这样的好处是,我们可以快速在\n这两个类中进行快捷键跳转,也方便我们去新增测试方法。<Highlight color=\"green\">跳转快捷键和创建快捷键保持一致,见下文.</Highlight></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1618123124000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>其实Idea已经为我们提供了快捷操作,如下图。</p>\n<p><img src=\"/junit.gif\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"快捷键\"> 快捷键</h3>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1618036976000.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1618123124000.png",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "事务回滚原理",
      "url": "https://java.springlearn.cn/learn/test/%E4%BA%8B%E5%8A%A1%E5%9B%9E%E6%BB%9A%E5%8E%9F%E7%90%86/",
      "id": "https://java.springlearn.cn/learn/test/%E4%BA%8B%E5%8A%A1%E5%9B%9E%E6%BB%9A%E5%8E%9F%E7%90%86/",
      "content_html": "<p>在前文单测类注入中我们知道.JUnit提供了一些监听器,允许\n当单测方法执行时候去对单测上下文进行调整。所以呢事务回滚也是基于\n这里的特性完成的。<Version>基于SpringBoot 2.1.x版本分析</Version></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1617795655000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"源码分析\"> 源码分析</h3>\n<p>Spring中为了适配不通的数据库,提供了事务平台的概念。 <code>PlatformTransactionManager</code> 只要实现了该接口\n就允许对事务进行控制。具体事务的控制是通过工具类来处理的。 <code>TransactionContextHolder</code> 可以获取当前线程\n执行的事务上下文。JUnit通过该工具拿到事务的上下文,然后对此做响应的修改。具体的\n修改逻辑见下文注释。两句话解释清楚。</p>\n<p><code>TransactionalTestExecutionListener</code></p>\n<p>伪代码分析</p>\n<div><div><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><pre><code>    <span>// 单测方法执行前,移除容器原来的事务管理器,然后开启一个新的事务</span>\n    <span>@Override</span>\n\t<span>public</span> <span>void</span> <span>beforeTestMethod</span><span>(</span><span>final</span> <span>TestContext</span> testContext<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n\t\t<span>Method</span> testMethod <span>=</span> testContext<span>.</span><span>getTestMethod</span><span>(</span><span>)</span><span>;</span>\n\t\t<span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> testClass <span>=</span> testContext<span>.</span><span>getTestClass</span><span>(</span><span>)</span><span>;</span>\n\t\t<span>Assert</span><span>.</span><span>notNull</span><span>(</span>testMethod<span>,</span> <span>\"Test method of supplied TestContext must not be null\"</span><span>)</span><span>;</span>\n\n\t\t<span>TransactionContext</span> txContext <span>=</span> <span>TransactionContextHolder</span><span>.</span><span>removeCurrentTransactionContext</span><span>(</span><span>)</span><span>;</span>\n\t\t<span>Assert</span><span>.</span><span>state</span><span>(</span>txContext <span>==</span> <span>null</span><span>,</span> <span>\"Cannot start new transaction without ending existing transaction\"</span><span>)</span><span>;</span>\n\n\t\t<span>PlatformTransactionManager</span> tm <span>=</span> <span>null</span><span>;</span>\n\t\t<span>TransactionAttribute</span> transactionAttribute <span>=</span> <span>this</span><span>.</span>attributeSource<span>.</span><span>getTransactionAttribute</span><span>(</span>testMethod<span>,</span> testClass<span>)</span><span>;</span>\n\n\t\t<span>if</span> <span>(</span>transactionAttribute <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n\t\t\ttransactionAttribute <span>=</span> <span>TestContextTransactionUtils</span><span>.</span><span>createDelegatingTransactionAttribute</span><span>(</span>testContext<span>,</span>\n\t\t\t\ttransactionAttribute<span>)</span><span>;</span>\n\n\t\t\t<span>if</span> <span>(</span>logger<span>.</span><span>isDebugEnabled</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n\t\t\t\tlogger<span>.</span><span>debug</span><span>(</span><span>\"Explicit transaction definition [\"</span> <span>+</span> transactionAttribute <span>+</span>\n\t\t\t\t\t\t<span>\"] found for test context \"</span> <span>+</span> testContext<span>)</span><span>;</span>\n\t\t\t<span>}</span>\n\n\t\t\t<span>if</span> <span>(</span>transactionAttribute<span>.</span><span>getPropagationBehavior</span><span>(</span><span>)</span> <span>==</span> <span>TransactionDefinition</span><span>.</span>PROPAGATION_NOT_SUPPORTED<span>)</span> <span>{</span>\n\t\t\t\t<span>return</span><span>;</span>\n\t\t\t<span>}</span>\n\n\t\t\ttm <span>=</span> <span>getTransactionManager</span><span>(</span>testContext<span>,</span> transactionAttribute<span>.</span><span>getQualifier</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\t\t\t<span>Assert</span><span>.</span><span>state</span><span>(</span>tm <span>!=</span> <span>null</span><span>,</span>\n\t\t\t\t\t<span>(</span><span>)</span> <span>-></span> <span>\"Failed to retrieve PlatformTransactionManager for @Transactional test: \"</span> <span>+</span> testContext<span>)</span><span>;</span>\n\t\t<span>}</span>\n\n\t\t<span>if</span> <span>(</span>tm <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n\t\t\ttxContext <span>=</span> <span>new</span> <span>TransactionContext</span><span>(</span>testContext<span>,</span> tm<span>,</span> transactionAttribute<span>,</span> <span>isRollback</span><span>(</span>testContext<span>)</span><span>)</span><span>;</span>\n\t\t\t<span>runBeforeTransactionMethods</span><span>(</span>testContext<span>)</span><span>;</span>\n\t\t\ttxContext<span>.</span><span>startTransaction</span><span>(</span><span>)</span><span>;</span>\n\t\t\t<span>TransactionContextHolder</span><span>.</span><span>setCurrentTransactionContext</span><span>(</span>txContext<span>)</span><span>;</span>\n\t\t<span>}</span>\n\t<span>}</span>\n\t\n\t<span>// 单测方法执行结束后,结束事务然后回滚或提交</span>\n\t<span>@Override</span>\n\t<span>public</span> <span>void</span> <span>afterTestMethod</span><span>(</span><span>TestContext</span> testContext<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n\t\t<span>Method</span> testMethod <span>=</span> testContext<span>.</span><span>getTestMethod</span><span>(</span><span>)</span><span>;</span>\n\t\t<span>Assert</span><span>.</span><span>notNull</span><span>(</span>testMethod<span>,</span> <span>\"The test method of the supplied TestContext must not be null\"</span><span>)</span><span>;</span>\n\n\t\t<span>TransactionContext</span> txContext <span>=</span> <span>TransactionContextHolder</span><span>.</span><span>removeCurrentTransactionContext</span><span>(</span><span>)</span><span>;</span>\n\t\t<span>// If there was (or perhaps still is) a transaction...</span>\n\t\t<span>if</span> <span>(</span>txContext <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n\t\t\t<span>TransactionStatus</span> transactionStatus <span>=</span> txContext<span>.</span><span>getTransactionStatus</span><span>(</span><span>)</span><span>;</span>\n\t\t\t<span>try</span> <span>{</span>\n\t\t\t\t<span>// If the transaction is still active...</span>\n\t\t\t\t<span>if</span> <span>(</span>transactionStatus <span>!=</span> <span>null</span> <span>&amp;&amp;</span> <span>!</span>transactionStatus<span>.</span><span>isCompleted</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n\t\t\t\t\ttxContext<span>.</span><span>endTransaction</span><span>(</span><span>)</span><span>;</span>\n\t\t\t\t<span>}</span>\n\t\t\t<span>}</span>\n\t\t\t<span>finally</span> <span>{</span>\n\t\t\t\t<span>runAfterTransactionMethods</span><span>(</span>testContext<span>)</span><span>;</span>\n\t\t\t<span>}</span>\n\t\t<span>}</span>\n\t<span>}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br></div></div>",
      "image": "https://img.springlearn.cn/blog/learn_1617795655000.png",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "使用断言",
      "url": "https://java.springlearn.cn/learn/test/%E4%BD%BF%E7%94%A8%E6%96%AD%E8%A8%80/",
      "id": "https://java.springlearn.cn/learn/test/%E4%BD%BF%E7%94%A8%E6%96%AD%E8%A8%80/",
      "content_html": "<div><p>断言</p>\n<p>单测方法尽可能去使用断言,明确方法的执行结果</p>\n</div>\n<h2 id=\"一、单测的目的\"> 一、单测的目的</h2>\n<p>我们单测的目的就是为了确定,被测试的方法或者是接口是否符合业务要求。\n其中一些方法是只要跑成功就算成功了,但是其实大部分方法还是要看其中的返回值是否符合预期。</p>\n<p>在平时的开发中发现许多同学只是喜欢把结果打印出来,人工去验证数据。这其实就跟JUnit的口号相违背了。\nJUnit的口号: <Highlight color=\"green\">keep the bar green to keep the code clean。</Highlight></p>\n<p><img src=\"/junit-success.gif\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_1-1-正确的单测一定是有断言的\"> 1.1 正确的单测一定是有断言的</h3>\n<p>断言明确执行结果,如果你要看数据也可以把结果打印出来。但是断言也要加上。\n<code>JUnit</code> 为我们提供了一些辅助的函数，就是用来帮助我们来判断被测试的方法是否如我们预期的效果一样正常执行。</p>\n<h2 id=\"二、断言api\"> 二、断言API</h2>\n<h3 id=\"_2-1-assertequals\"> 2.1 assertEquals</h3>\n<ul>\n<li>assertEquals(Object expected, Object actual)</li>\n<li>assertEquals(String message, Object expected, Object actual)</li>\n</ul>\n<p>String message： 可选参数，将在发生错误时报告这个消息\nObject expected： 期望值，一般为用户指定的内容\nObject actual： 被测试的代码实际返回的结果</p>\n<h3 id=\"_2-2-asserttrue-与-assertfalse\"> 2.2 assertTrue 与 assertFalse</h3>\n<ul>\n<li>assertTrue(boolean condition)</li>\n<li>assertTrue(String message, boolean condition)</li>\n</ul>\n<p>String message： 可选参数，将在发生错误时报告这个消息\nboolean condition：待验证的 Boolean 类型值</p>\n<p>assertTrue 该断言用来验证给定的布尔型值是否为真，如果结果为假，则验证失败；\n相反，assertFalse 用来验证给定的布尔型值是否为假，如果结果为真，则验证失败。</p>\n<h3 id=\"_2-3-assertnull-与-assertnotnull\"> 2.3 assertNull 与 assertNotNull</h3>\n<ul>\n<li>assertNull(Object object)</li>\n<li>assertNull(String message, Object object)</li>\n</ul>\n<p>String message： 可选参数，将会在发生错误时报告这个消息\nObject object： 待验证是否为 Null 的对象</p>\n<p>assertNull 该断言用来验证给定的对象是否为 Null ,如果给定对象为 非Null，则验证失败。\n相反，assertNotNull 用来验证给定的对象是否为 非Null，如果为 Null，则验证失败。</p>\n<h3 id=\"_2-4-assertsame-与-assertnotsame\"> 2.4 assertSame 与 assertNotSame</h3>\n<ul>\n<li>assertSame(Object expected, Object actual)</li>\n<li>assertSame(String message, Object expected, Object actual)</li>\n</ul>\n<p>String message： 可选参数，将会在发生错误时报告这个消息\nObject expected：期望值\nObject actual：被测试代码返回的实际值</p>\n<p>assertSame 该断言用来验证 expected 和 actual 的引用是否为同一个对象的引用，如果不是同一引用，则验证失败。\n相反，assertNotSame 用来验证 expected 和 actual 的引用是否为不同对象的引用，如果为同一对象引用，则验证失败。</p>\n<h3 id=\"_2-5-fail\"> 2.5 Fail</h3>\n<ul>\n<li>Fail()</li>\n<li>Fail(String message)</li>\n</ul>\n<p>String message是个可选参数，假如提供，将会在发生错误时报告这个消息。</p>\n<p>该断言会使测试立即失败，通常用在测试不能达到的分支上（如异常）。</p>\n<h2 id=\"三、断言匹配\"> 三、断言匹配</h2>\n<p>依赖包</p>\n<div><pre><code><span>import</span> <span>org<span>.</span>hamcrest<span>.</span></span><span>Matchers</span><span>;</span>\n<span>import</span> <span>org<span>.</span>hamcrest<span>.</span>core<span>.</span></span><span>AllOf</span><span>;</span>\n<span>import</span> <span>org<span>.</span>hamcrest<span>.</span>core<span>.</span></span><span>AnyOf</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"_3-1-matchers匹配器\"> 3.1 Matchers匹配器</h3>\n<div><pre><code>        <span>// 是否相等</span>\n        <span>Assert</span><span>.</span><span>assertThat</span><span>(</span><span>2</span><span>,</span> <span>Matchers</span><span>.</span><span>is</span><span>(</span><span>2</span><span>)</span><span>)</span><span>;</span>\n        <span>// 2 小于等于2</span>\n        <span>Assert</span><span>.</span><span>assertThat</span><span>(</span><span>2</span><span>,</span><span>Matchers</span><span>.</span><span>lessThanOrEqualTo</span><span>(</span><span>2</span><span>)</span><span>)</span><span>;</span>\n        <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span><span>String</span><span>></span></span> map <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        map<span>.</span><span>put</span><span>(</span><span>\"name\"</span><span>,</span><span>\"jay\"</span><span>)</span><span>;</span>\n        <span>// map 中是否包含key为name的元素</span>\n        <span>Assert</span><span>.</span><span>assertThat</span><span>(</span>map<span>,</span><span>Matchers</span><span>.</span><span>hasKey</span><span>(</span><span>\"name\"</span><span>)</span><span>)</span><span>;</span>\n        <span>// map 中是否包含value为jay的元素</span>\n        <span>Assert</span><span>.</span><span>assertThat</span><span>(</span>map<span>,</span><span>Matchers</span><span>.</span><span>hasValue</span><span>(</span><span>\"jay\"</span><span>)</span><span>)</span><span>;</span>\n        <span>// map 中是否包含name等于jay的元素</span>\n        <span>Assert</span><span>.</span><span>assertThat</span><span>(</span>map<span>,</span><span>Matchers</span><span>.</span><span>hasEntry</span><span>(</span><span>\"name\"</span><span>,</span><span>\"jay\"</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id=\"_3-2-allof\"> 3.2 AllOf</h3>\n<div><pre><code>   <span>// 2 小于4同时也小于3</span>\n   <span>Assert</span><span>.</span><span>assertThat</span><span>(</span><span>2</span><span>,</span> <span>AllOf</span><span>.</span><span>allOf</span><span>(</span><span>Matchers</span><span>.</span><span>lessThan</span><span>(</span><span>4</span><span>)</span><span>,</span> <span>Matchers</span><span>.</span><span>lessThan</span><span>(</span><span>3</span><span>)</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"_3-3-anyof\"> 3.3 AnyOf</h3>\n<div><pre><code>   <span>// 2 大于1小于3</span>\n   <span>Assert</span><span>.</span><span>assertThat</span><span>(</span><span>2</span><span>,</span> <span>AnyOf</span><span>.</span><span>anyOf</span><span>(</span><span>Matchers</span><span>.</span><span>greaterThan</span><span>(</span><span>1</span><span>)</span><span>,</span> <span>Matchers</span><span>.</span><span>lessThan</span><span>(</span><span>3</span><span>)</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div>",
      "image": "https://java.springlearn.cn/junit-success.gif",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "单元测试专题",
      "url": "https://java.springlearn.cn/learn/test/",
      "id": "https://java.springlearn.cn/learn/test/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/learn_1617880083000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>沉淀、分享、成长、让自己和他人都有所收货。</p>\n<h2 id=\"一、前言\"> 一、前言</h2>\n<p>本系列文章主要的目的是提高大家对代码的单测意识, 其中文章主要会分享单测过程中,常见的测试场景及这些场景的解决方案和处理思路。\n为了能使大家更好的了解单元测试,作为程序员首先从源码入手,分享JUnit的运行原理。在先了解了JUnit的原理后,再来回顾我们的问题场景, 就自然而然的从根源深处解决大家的测单痛点以及大家对单测框架不熟悉的情况。</p>\n<h2 id=\"二、单测的意义\"> 二、单测的意义</h2>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1617886822000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>很多人说单测没有意义, 这是完全不正确的思想。相信随着码龄增加你会越发的认同这句话。据国外研究统计软件系统中最大的成本是\n维护成本,所以你能看到凡是开源的框架单测一定是非常丰富的,因为它要去迭代升级,要去向下兼容版本。如果没有单测那就是完全的黑盒。\n是好是坏听从天意,这是没有质量保证的。这点是软件系统都具有的所以说就这一点,就证明了单测的必须性。下面谈几个不写单元测试的说法。</p>\n<h3 id=\"_2-1-压缩开发时间-任务延期\"> 2.1 压缩开发时间,任务延期</h3>\n<p>或许说中国的国情跟国外的不一样,中国的系统或者说是业务系统更新的快,单测用完就失效。写单测会压缩开发时间,导致任务延期。从眼下看是压缩了开发的时间,但是它提高了开发的质量,一定程度上减少了系统的维护成本。其次单测并不是说要对你所有的方法进行测试, 这个要针对业务系统情况,把系统的核心业务中使用到的核心方法进行详细的单测维护即可。系统的核心逻辑是不会经常变动的,\n所以这部分的单测就是你整个单测的核心。</p>\n<h3 id=\"_2-2-公司性质\"> 2.2 公司性质</h3>\n<p>像一般政府的项目基本都会给到外部的公司来竞争,部分的外包公司只注重交付,不注重质量。或者说这个项目就是一个xx工程, 没有实用价值。\n只要上线就行。也不用维护。对于这种的确实现状是都不会写单元测试。(因为整个项目就是没有任何实用价值)</p>\n<h3 id=\"_2-3-别人都不写-我为啥要写\"> 2.3 别人都不写,我为啥要写</h3>\n<p>代码是有温度的,养成好的习惯从自己做起。好习惯会传染,需要一个<Highlight color='green'>好的带头人</Highlight>。团队内部成员每个人都有自己负责的功能区域。\n只要每个人针对自己的功能区域的核心计算逻辑写好单测,那么一定是好处大于坏处的。另外要写在平时,不要专门找时间来写代码。那样就容易把单测当做是任务去完成,就失去了写单测的意义。</p>\n<Highlight color=\"red\">相信你所认为虽然很正确,但是做起来很傻逼的事情,一定有人在默默的坚持着。努力做一个优秀的人。</Highlight>\n<h3 id=\"_2-4-代码都测完了-要测试干嘛\"> 2.4 代码都测完了,要测试干嘛</h3>\n<p>自己测完了,要测试干嘛。首先如果你有这样的想法,那么一定是因为你不了解测试的工作。测试是开发的补充,他一定不是开发的保姆。测试\n是对应用或系统的整体场景或者说功能的验证, 他不能对你代码的最小单元进行验证。所谓代码的最小单元一定是开发同学最了解的,代码的最小单元\n就是你定义的代码块,方法,技术框架。这部分测试同学是无法帮你验证的。我们这里举一个例子。</p>\n<p>软件工程师好比是盖大楼的,具体每一堵墙砖头如何摆放,房间如何设计,是否关注采光这是你设计师要干的事情,而测试好比质量验收,会看你整栋\n大楼是否有倾斜,水电煤气是否可以使用。测试同学并不了解所有的细节。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1618206722000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>开发和测试看到的东西不是完全一样的,越往上测试的黑盒越大。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1618051810000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_2-5-应付覆盖率指标\"> 2.5 应付覆盖率指标</h3>\n<p>当然如果公司对这个有要求,一定会有应付的办法。最差的情况就是全部都是为了应付而写代码。从价值观上来看,这是不对的。从实用性上来看这是没有任何价值的。那么如何解决这个办法呢? 价值观来保证咯。那么就需要一个指标了(非硬性指标), 把数据量化展示出来,作为应用质量的一个参考的因素。\n就算你全是应付而写,也一定有一定的价值。</p>\n<p>另外要说一点的是<Highlight color=\"red\">单测行覆盖率高不代表应用的质量就一定高,</Highlight>但是单测行覆盖率低一定代表着这个应用出现质量问题的可能性就越大。\n这无疑增加了业务风险和测试成本。为了减少业务风险和测试成本,希望大家提高对单测的意识。</p>\n<p><strong>那么我们在上升一点总结下如何提高应用的质量呢? 请看下文</strong></p>\n<h2 id=\"三、应用质量的看法\"> 三、应用质量的看法</h2>\n<p>应用质量如何来衡量, 这是一个完全可以通过指标来进行衡量的。那么究竟如何指标化呢? 这里首先对应用质量进行一个拆分。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1617889750000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>可以将应用质量分为两种:</p>\n<ol>\n<li>代码编程质量(编程风格)</li>\n<li>业务编程质量(业务是否清晰,异常场景的考虑)</li>\n</ol>\n<h3 id=\"_3-1-代码编程质量\"> 3.1 代码编程质量</h3>\n<p>代码编程质量往往只的是开发人员的编程风格,基于团队成员风格的相似度。\n也可以说是代码的可读性,可维护性,方法的复杂度,方法的执行效率。这个是最容易指标化处理的。\n基于规则引擎,进行静态代码扫描就可以扫描出。Sonar 或者 阿里规约都可以完成。\n他们都会把问题分为四个等级Blocker, Critical, Major, Minor/Trivial。</p>\n<h4 id=\"_3-1-1-blocker\"> 3.1.1  Blocker</h4>\n<p>即系统无法执行、崩溃或严重资源不足、应用模块无法启动或异常退出、无法测试、造成系统不稳定。</p>\n<h4 id=\"_3-1-2-critical\"> 3.1.2 Critical</h4>\n<p>即影响系统功能或操作，主要功能存在严重缺陷，但不会影响到系统稳定性。</p>\n<h4 id=\"_3-1-3-major\"> 3.1.3 Major</h4>\n<p>即界面、性能缺陷、兼容性。</p>\n<h4 id=\"_3-1-4-minor-trivial\"> 3.1.4 Minor/Trivial</h4>\n<p>即易用性及建议性问题。</p>\n<Highlight color=\"red\">质量分计算</Highlight>\n<div><p>质量分计算</p>\n<p>100-(Blocker<em>100+Critical</em>10+Major*1)/(代码数/100)</p>\n<ul>\n<li>Blocker 占比100%,因为是比较严重的问题</li>\n<li>Critical 低于Blocker占比10%</li>\n<li>Major 性能缺陷占比1%</li>\n</ul>\n</div>\n<h3 id=\"_2-2-业务编程质量\"> 2.2 业务编程质量</h3>\n<ul>\n<li>对软件设计的最小单位进行正确性检测，如函数或一个类的方法。</li>\n<li>系统集成测试</li>\n</ul>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1618206722000.png\" alt=\"\" loading=\"lazy\"></p>\n<h4 id=\"_2-2-1-ut由开发同学保证\"> 2.2.1 UT由开发同学保证</h4>\n<p>开发同学进行最小单元测试, 数据如何进行衡量呢?</p>\n<p>基于Jenkins的 <code>Jcoco</code> 插件,会统计行覆盖率，类覆盖率，复杂方法覆盖率等。输出一个\n可视化的图表。</p>\n<h4 id=\"_2-2-2-it由自动化测试同学编写\"> 2.2.2 IT由自动化测试同学编写</h4>\n<h2 id=\"四、代码编程质量例子\"> 四、代码编程质量例子</h2>\n<p>面向对象的思想写入复用性高的代码</p>\n<div><pre><code>\n<span>// 姓名，家乡，大学，专业，兴趣爱好，单位职称 </span>\n<span>public</span> <span>interface</span> <span>Introduce</span><span>{</span>\n     <span>// 这是一个介绍类,负责介绍自己</span>\n     <span>public</span> <span>void</span> <span>introduce</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>public</span> <span>class</span> <span>XiaoMing</span> <span>implements</span> <span>Introduce</span><span>{</span>\n\n     <span>public</span> <span>void</span> <span>introduce</span><span>(</span><span>)</span><span>{</span>\n         <span>sout</span><span>(</span><span>\"我叫小明\"</span><span>)</span>\n         <span>sout</span><span>(</span><span>\"我的老家是河南南阳\"</span><span>)</span>\n         <span>sout</span><span>(</span><span>\"我的家乡就坐落在河南南阳邓州市\"</span><span>)</span>\n         <span>sout</span><span>(</span><span>\"邓州市一个美丽的城市,是中国邓姓的发源地\"</span><span>)</span>\n         <span>sout</span><span>(</span><span>\"邓州也是河南境内人口最多的一个县级城市\"</span><span>)</span>\n         <span>sout</span><span>(</span><span>\"我大学是在河南大学\"</span><span>)</span>\n         <span>sout</span><span>(</span>\"河南大学简称河大，是一所位于中国河南省开封市涵盖文、史、哲、经、管、\n         法、理、工、医、农、教育、艺术等<span>12</span>个学科门类的省部共建型综合性公立大学。\"<span>)</span>\n         <span>sout</span><span>(</span><span>\"我的专业是计算机与信息工程\"</span><span>)</span>\n         <span>sout</span><span>(</span><span>\"我的个人爱好是写博客、打游戏、做美食、偶会也会跑跑步\"</span><span>)</span>\n         <span>sout</span><span>(</span><span>\"从业xx年,目前在公司的职称是xxx\"</span><span>)</span>\n     <span>}</span>\n<span>}</span>\n\n<span>public</span> <span>class</span> <span>XiaoMing</span> <span>implements</span> <span>Introduce</span><span>{</span>\n\n     <span>private</span> <span>void</span> <span>introduceHometown</span><span>(</span><span>)</span><span>{</span>\n         <span>sout</span><span>(</span><span>\"我的老家是河南南阳\"</span><span>)</span>\n         <span>sout</span><span>(</span><span>\"我的家乡就坐落在河南南阳邓州市\"</span><span>)</span>\n         <span>sout</span><span>(</span><span>\"邓州市一个美丽的城市,是中国邓姓的发源地\"</span><span>)</span>\n         <span>sout</span><span>(</span><span>\"邓州也是河南境内人口最多的一个县级城市\"</span><span>)</span>\n     <span>}</span>\n     \n     <span>private</span> <span>void</span> <span>introduceSchool</span><span>(</span><span>)</span><span>{</span>\n         <span>sout</span><span>(</span><span>\"我大学是在河南大学\"</span><span>)</span>\n         <span>sout</span><span>(</span>\"河南大学简称河大，是一所位于中国河南省开封市涵盖文、史、哲、经、管、\n         法、理、工、医、农、教育、艺术等<span>12</span>个学科门类的省部共建型综合性公立大学。\"<span>)</span>\n     <span>}</span>\n     \n     <span>private</span> <span>void</span> <span>introduceMajor</span><span>(</span><span>)</span><span>{</span>\n         <span>sout</span><span>(</span><span>\"我的专业是计算机与信息工程\"</span><span>)</span>\n     <span>}</span>\n     \n     <span>private</span> <span>void</span> <span>introduceInterest</span><span>(</span><span>)</span><span>{</span>\n         <span>sout</span><span>(</span><span>\"我的个人爱好是写博客、打游戏、做美食、偶会也会跑跑步\"</span><span>)</span>\n     <span>}</span>\n     \n     <span>// 将任务进行拆分,拆分的维度是逻辑顺序,然后抽离出方法,抽离的维度是单一职责。</span>\n     <span>// 这样的好处是工能化,模块化,便于复用。</span>\n     <span>public</span> <span>void</span> <span>introduce</span><span>(</span><span>)</span><span>{</span>\n         <span>sout</span><span>(</span><span>\"我叫小明\"</span><span>)</span><span>;</span>\n         <span>introduceHometown</span><span>(</span><span>)</span><span>;</span>\n         <span>introduceSchool</span><span>(</span><span>)</span><span>;</span>\n         <span>introduceMajor</span><span>(</span><span>)</span><span>;</span>\n         <span>introduceInterest</span><span>(</span><span>)</span><span>;</span>\n         <span>sout</span><span>(</span><span>\"从业xx年,目前在公司的职称是xxx\"</span><span>)</span><span>;</span>\n     <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br></div></div><p>有人会说了,明明很简单就搞定了,为啥多写了这么多方法。这是因为你的思维没有转变过来,简单来说就是要\n学会用面向对象的方法去写代码,不要写面向过程的代码了。如果高级点说就是代码层面上的领域驱动。\n领域驱动和面向过程最大的相同就是思想上都是要对问题进行拆分成最小粒度,已解决代码冗余重复,以方便重复组装利用\n,以达到快速简单维护的目的。</p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1617880083000.png",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "单测维护",
      "url": "https://java.springlearn.cn/learn/test/%E5%8D%95%E6%B5%8B%E7%BB%B4%E6%8A%A4/",
      "id": "https://java.springlearn.cn/learn/test/%E5%8D%95%E6%B5%8B%E7%BB%B4%E6%8A%A4/",
      "content_html": "<div><p>单测维护</p>\n</div>\n<h2 id=\"一、考虑不要跳过单测\"> 一、考虑不要跳过单测</h2>\n<p>目前我们都是跳过单测的,测试都是每次改造完成后,手工去进行验证。\n验证没有问题就提测了。这样的单测是没有维护性的。</p>\n<p>当我们建立起单测体系后,真正重视单测维护后,就可以考虑不要跳过单元测试\n这样,每次编译时候都可以执行一遍单测用例,观察失败的单测试服是这次改造的bug导致。</p>\n<h2 id=\"二、后期维护单测\"> 二、后期维护单测</h2>\n<p>开发时间紧张,没有进行单测就提测了,测试也通过了。对于这类代码后期可以补充上单测。方便后面进行业务调整时候,进行单测验证。</p>\n<p>只有这样开发人员才更有底气。</p>\n<h2 id=\"三、售后服务\"> 三、售后服务</h2>\n<p>应用Owner要督促,应用成员要重视。做好应用质量把控。</p>\n",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "技术选型",
      "url": "https://java.springlearn.cn/learn/test/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/",
      "id": "https://java.springlearn.cn/learn/test/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/",
      "content_html": "<h2 id=\"一、junit\"> 一、JUnit</h2>\n<p><a href=\"https://junit.org/junit5/\" target=\"_blank\" rel=\"noopener noreferrer\">JUnit</a>目标是为JVM上的开发人员端测试创建最新的基础。这包括关注Java 8及更高版本，以及启用许多不同的测试样式。</p>\n<p>强制使用 <code>Junit3</code> 以上版本, 目前最新的版本是 <code>Junit5</code>, 常用的是 <code>JUnit4</code>,建议使用<Highlight color=\"#25c2a0\">JUnit4</Highlight>\n或者使用<Highlight color=\"#25c2a0\">JUnit5</Highlight>。</p>\n<p>这里有一个小坑。如果SpringBoot2.1.x版本依赖的Junit4。SpringBoot应用要通过 @RunWith + @SpringBootTest。\n在SpringBoot后续的版本依赖JUnit5,直接使用@SpringBootTest即可。</p>\n<div><pre><code>\n<span><span><span>&lt;</span>dependency</span><span>></span></span>\n    <span><span><span>&lt;</span>groupId</span><span>></span></span>junit<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n    <span><span><span>&lt;</span>artifactId</span><span>></span></span>junit<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n    <span><span><span>&lt;</span>version</span><span>></span></span>4.12<span><span><span>&lt;/</span>version</span><span>></span></span>\n    <span><span><span>&lt;</span>scope</span><span>></span></span>test<span><span><span>&lt;/</span>scope</span><span>></span></span>\n<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id=\"二、mockito\"> 二、Mockito</h2>\n<p><a href=\"https://site.mockito.org/\" target=\"_blank\" rel=\"noopener noreferrer\">Mockito</a> 是一个非常不错的模拟框架。它使您可以使用干净简单的API编写漂亮的测试。Mockito不会给您带来麻烦，因为这些测试的可读性很强，并且会产生清晰的验证错误。</p>\n<p><img src=\"https://github.com/mockito/mockito.github.io/raw/master/img/logo%402x.png\" alt=\"\" loading=\"lazy\"></p>\n<p>mockito-core只包含mockito类，而mockito-all包含mockito类以及一些依赖项，其中一个是hamcrest。</p>\n<p>实际上mockito-all已停产according to the mockito website</p>\n<div><pre><code><span>&lt;!-- https://mvnrepository.com/artifact/org.mockito/mockito-core --></span>\n<span><span><span>&lt;</span>dependency</span><span>></span></span>\n    <span><span><span>&lt;</span>groupId</span><span>></span></span>org.mockito<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n    <span><span><span>&lt;</span>artifactId</span><span>></span></span>mockito-core<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n    <span><span><span>&lt;</span>version</span><span>></span></span>3.8.0<span><span><span>&lt;/</span>version</span><span>></span></span>\n    <span><span><span>&lt;</span>scope</span><span>></span></span>test<span><span><span>&lt;/</span>scope</span><span>></span></span>\n<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>代码实例</p>\n<div><pre><code>    \n    <span>// 根据这个原理,我们可以mock所有未实现的功能,比如三方的接口</span>\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>test</span><span>(</span><span>)</span><span>{</span>\n        <span>List</span> mockList <span>=</span> <span>Mockito</span><span>.</span><span>mock</span><span>(</span><span>List</span><span>.</span><span>class</span><span>)</span><span>;</span>\n        <span>Mockito</span><span>.</span><span>doReturn</span><span>(</span><span>12</span><span>)</span><span>.</span><span>when</span><span>(</span>mockList<span>)</span><span>.</span><span>get</span><span>(</span><span>0</span><span>)</span><span>;</span>\n        <span>// 12</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>mockList<span>.</span><span>get</span><span>(</span><span>0</span><span>)</span><span>)</span><span>;</span>\n        <span>Assert</span><span>.</span><span>assertSame</span><span>(</span><span>12</span><span>,</span>mockList<span>.</span><span>get</span><span>(</span><span>0</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id=\"三、jmockdata\"> 三、JMockData</h2>\n<p><code>JMockData</code> 是一款国人开发用来生成模拟数据的工具,对象太复杂,模拟数据复制太难? 一行代码搞定。</p>\n<div><pre><code>   <span><span><span>&lt;</span>dependency</span><span>></span></span>\n       <span><span><span>&lt;</span>groupId</span><span>></span></span>com.github.jsonzou<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n       <span><span><span>&lt;</span>artifactId</span><span>></span></span>jmockdata<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n       <span><span><span>&lt;</span>version</span><span>></span></span>4.3.0<span><span><span>&lt;/</span>version</span><span>></span></span>\n       <span><span><span>&lt;</span>scope</span><span>></span></span>test<span><span><span>&lt;/</span>scope</span><span>></span></span>\n   <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div>",
      "image": "https://github.com/mockito/mockito.github.io/raw/master/img/logo%402x.png",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "数据隔离",
      "url": "https://java.springlearn.cn/learn/test/%E6%95%B0%E6%8D%AE%E9%9A%94%E7%A6%BB/",
      "id": "https://java.springlearn.cn/learn/test/%E6%95%B0%E6%8D%AE%E9%9A%94%E7%A6%BB/",
      "content_html": "<div><p>数据隔离</p>\n<p>数据隔离一直是一个测试的痛点，测试数据可能是 <code>mock</code> 的数据,所以单测过程中,难免会造成脏数据\n这种场景,有通用的解决方案。<code>JUnit</code> 已经帮我们做好了。这里我们只讲实操和用法。\n如果有兴趣的话可以研究下 <Highlight>TransactionalTestExecutionListener</Highlight></p>\n</div>\n<h2 id=\"解决方案\"> 解决方案</h2>\n<div><p>单测引导类配置说明</p>\n<ul>\n<li>@Transactional 如果加上这个注解,就代表全局的单测,事务执行完都会自动回滚</li>\n<li>@Rollback(false) 如果想某个方法事务不回滚,可以单独在方法上设置。<Highlight color=\"#25c2a0\">【方法级别&gt;全局】</Highlight></li>\n</ul>\n</div>\n<p>下面这两个方法</p>\n<ul>\n<li>第一个方法因为是使用测试全局事务配置,所以默认是回滚。</li>\n<li>第二个方法因为使用了方法事务配置,所以会忽略全局配置,然后提交事务。</li>\n</ul>\n<p>单测引导类配置</p>\n<div><pre><code><span>@Slf4j</span>\n<span>@ActiveProfiles</span><span>(</span><span>{</span><span>\"local\"</span><span>}</span><span>)</span>\n<span>// 使用Spring容器引导</span>\n<span>@RunWith</span><span>(</span><span>SpringRunner</span><span>.</span><span>class</span><span>)</span>\n<span>// 默认就是回滚,不用加@Rollback,如果全局不想回滚就在这个吧@Rollback(false),如果某个单测不想回滚,就放到单侧类上</span>\n<span>@Transactional</span>\n<span>@SpringBootTest</span><span>(</span>classes <span>=</span> <span>{</span><span>CenterProviderApplication</span><span>.</span><span>class</span><span>}</span><span>)</span> <span>// 指定启动类</span>\n<span>public</span> <span>class</span> <span>BaseApplicationTest</span> <span>{</span>\n\n    <span>// 全局事务,默认自动回滚</span>\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>testInsert</span><span>(</span><span>)</span> <span>{</span>\n        <span>String</span> json <span>=</span> <span>\"{\\n\"</span> <span>+</span>\n                <span>\"  \\\"id\\\": 1344215264312557570,\\n\"</span> <span>+</span>\n                <span>\"  \\\"arrivalOrderId\\\": 1344215264287391745,\\n\"</span> <span>+</span>\n                <span>\"  \\\"goodsDeployId\\\": 1344170561282879489,\\n\"</span> <span>+</span>\n                <span>\"  \\\"expectedReceiveNum\\\": 150,\\n\"</span> <span>+</span>\n                <span>\"}\"</span><span>;</span>\n        <span>OrderDetailDO</span> orderDetail <span>=</span> <span>TestConsole</span><span>.</span><span>toObject</span><span>(</span>json<span>,</span> <span>ArrivalNoticeOrderDetailDO</span><span>.</span><span>class</span><span>)</span><span>;</span>\n        orderDetail<span>.</span><span>setId</span><span>(</span><span>null</span><span>)</span><span>;</span>\n        orderDetail<span>.</span><span>setCreaterId</span><span>(</span><span>888888L</span><span>)</span><span>;</span>\n        <span>// true</span>\n        <span>Assert</span><span>.</span><span>assertTrue</span><span>(</span>DB<span>.</span><span>insert</span><span>(</span>orderDetail<span>)</span> <span>></span> <span>0</span><span>)</span><span>;</span>\n        <span>// notNull</span>\n        <span>Assert</span><span>.</span><span>assertNotNull</span><span>(</span>DB<span>.</span><span>selectById</span><span>(</span>orderDetail<span>.</span><span>getId</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n    \n    <span>// 方法事务>全局事务, 这里声明了不自动回滚</span>\n    <span>@Test</span>\n    <span>@Rollback</span><span>(</span>value <span>=</span> <span>false</span><span>)</span>\n    <span>public</span> <span>void</span> <span>testInsert</span><span>(</span><span>)</span> <span>{</span>\n        <span>String</span> json <span>=</span> <span>\"{\\n\"</span> <span>+</span>\n                <span>\"  \\\"id\\\": 1344215264312557570,\\n\"</span> <span>+</span>\n                <span>\"  \\\"arrivalOrderId\\\": 1344215264287391745,\\n\"</span> <span>+</span>\n                <span>\"  \\\"goodsDeployId\\\": 1344170561282879489,\\n\"</span> <span>+</span>\n                <span>\"  \\\"expectedReceiveNum\\\": 150,\\n\"</span> <span>+</span>\n                <span>\"}\"</span><span>;</span>\n        <span>OrderDetailDO</span> orderDetail <span>=</span> <span>TestConsole</span><span>.</span><span>toObject</span><span>(</span>json<span>,</span> <span>ArrivalNoticeOrderDetailDO</span><span>.</span><span>class</span><span>)</span><span>;</span>\n        orderDetail<span>.</span><span>setId</span><span>(</span><span>null</span><span>)</span><span>;</span>\n        orderDetail<span>.</span><span>setCreaterId</span><span>(</span><span>888888L</span><span>)</span><span>;</span>\n        <span>// true</span>\n        <span>Assert</span><span>.</span><span>assertTrue</span><span>(</span>DB<span>.</span><span>insert</span><span>(</span>orderDetail<span>)</span> <span>></span> <span>0</span><span>)</span><span>;</span>\n        <span>// notNull</span>\n        <span>Assert</span><span>.</span><span>assertNotNull</span><span>(</span>DB<span>.</span><span>selectById</span><span>(</span>orderDetail<span>.</span><span>getId</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div>",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "异步验证",
      "url": "https://java.springlearn.cn/learn/test/%E5%BC%82%E6%AD%A5%E9%AA%8C%E8%AF%81/",
      "id": "https://java.springlearn.cn/learn/test/%E5%BC%82%E6%AD%A5%E9%AA%8C%E8%AF%81/",
      "content_html": "<div><p>请听题</p>\n<p>对于下面这段代码你觉得单测能通过吗?</p>\n</div>\n<p>异步场景</p>\n<div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>test</span><span>(</span><span>)</span> <span>{</span>\n        <span>ExecutorService</span> executorService <span>=</span> <span>Executors</span><span>.</span><span>newFixedThreadPool</span><span>(</span><span>3</span><span>)</span><span>;</span>\n        executorService<span>.</span><span>submit</span><span>(</span><span>new</span> <span>Runnable</span><span>(</span><span>)</span> <span>{</span>\n            <span>@SneakyThrows</span>\n            <span>@Override</span>\n            <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n                <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>5000</span><span>)</span><span>;</span>\n                <span>Object</span> obj <span>=</span> <span>null</span><span>;</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>obj<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"单侧结束\"</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h2 id=\"一、常用解决方案\"> 一、常用解决方案</h2>\n<h3 id=\"_1-1-white解决简单暴力\"> 1.1 white解决简单暴力</h3>\n<p>white解决</p>\n<div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>test</span><span>(</span><span>)</span> <span>{</span>\n        <span>ExecutorService</span> executorService <span>=</span> <span>Executors</span><span>.</span><span>newFixedThreadPool</span><span>(</span><span>3</span><span>)</span><span>;</span>\n        executorService<span>.</span><span>submit</span><span>(</span><span>new</span> <span>Runnable</span><span>(</span><span>)</span> <span>{</span>\n            <span>@SneakyThrows</span>\n            <span>@Override</span>\n            <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n                <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>5000</span><span>)</span><span>;</span>\n                <span>Object</span> obj <span>=</span> <span>null</span><span>;</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>obj<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"单侧结束\"</span><span>)</span><span>;</span>\n        <span>white</span><span>(</span><span>true</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id=\"_1-2-locksupport最大时间限制\"> 1.2 LockSupport最大时间限制</h3>\n<p>LockSupport.parkNanos()线程挂起</p>\n<div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>test</span><span>(</span><span>)</span> <span>{</span>\n        <span>ExecutorService</span> executorService <span>=</span> <span>Executors</span><span>.</span><span>newFixedThreadPool</span><span>(</span><span>3</span><span>)</span><span>;</span>\n        executorService<span>.</span><span>submit</span><span>(</span><span>new</span> <span>Runnable</span><span>(</span><span>)</span> <span>{</span>\n            <span>@SneakyThrows</span>\n            <span>@Override</span>\n            <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n                <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>5000</span><span>)</span><span>;</span>\n                <span>Object</span> obj <span>=</span> <span>null</span><span>;</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>obj<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"单侧结束\"</span><span>)</span><span>;</span>\n         <span>// 挂起指定时间</span>\n        <span>LockSupport</span><span>.</span><span>parkNanos</span><span>(</span><span>TimeUnit</span><span>.</span>SECONDS<span>.</span><span>toNanos</span><span>(</span><span>6</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id=\"二、基于上面两种配合junit定制\"> 二、基于上面两种配合JUnit定制</h2>\n<h3 id=\"_2-1-使用演示\"> 2.1 使用演示</h3>\n<p>📢 注意这里的 @Timed 原生是不具备这个能力的,要基于JUnit进行扩展。</p>\n<p>@Timed 灵活控制时间</p>\n<div><div><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br></div><pre><code>    <span>@Test</span>\n    <span>@Timed</span><span>(</span>millis <span>=</span> <span>5000</span><span>)</span>\n    <span>public</span> <span>void</span> <span>test</span><span>(</span><span>)</span> <span>{</span>\n        <span>ExecutorService</span> executorService <span>=</span> <span>Executors</span><span>.</span><span>newFixedThreadPool</span><span>(</span><span>3</span><span>)</span><span>;</span>\n        executorService<span>.</span><span>submit</span><span>(</span><span>new</span> <span>Runnable</span><span>(</span><span>)</span> <span>{</span>\n            <span>@SneakyThrows</span>\n            <span>@Override</span>\n            <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n                <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>5000</span><span>)</span><span>;</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"任务执行结束\"</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"单侧结束\"</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id=\"_2-2-扩展实现\"> 2.2 扩展实现</h3>\n<p>同样是基于LockSupport线程挂起方案,类似于切面解决。</p>\n<p>扩展TestExecutionListener</p>\n<div><div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br></div><pre><code>\n    <span>private</span> <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Long</span><span>></span></span> timedMap <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n\n    <span>private</span> <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Long</span><span>></span></span> beforeTestCostMap <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n    \n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>beforeTestMethod</span><span>(</span><span>TestContext</span> testContext<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>String</span> key <span>=</span> testContext<span>.</span><span>getTestMethod</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>;</span>\n        beforeTestCostMap<span>.</span><span>put</span><span>(</span>key<span>,</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>Timed</span> timedA <span>=</span> <span>AnnotationUtils</span><span>.</span><span>getAnnotation</span><span>(</span>testContext<span>.</span><span>getTestMethod</span><span>(</span><span>)</span><span>,</span> <span>Timed</span><span>.</span><span>class</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span><span>Objects</span><span>.</span><span>nonNull</span><span>(</span>timedA<span>)</span><span>)</span> <span>{</span>\n            timedMap<span>.</span><span>put</span><span>(</span>testContext<span>.</span><span>getTestMethod</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>,</span> timedA<span>.</span><span>millis</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>Method</span> testMethod <span>=</span> testContext<span>.</span><span>getTestMethod</span><span>(</span><span>)</span><span>;</span>\n        <span>printActiveProfile</span><span>(</span>testContext<span>)</span><span>;</span>\n        <span>checkTransactional</span><span>(</span>testContext<span>)</span><span>;</span>\n        <span>TestConsole</span><span>.</span><span>colorPrintln</span><span>(</span><span>AnsiColor</span><span>.</span>BLUE<span>,</span> <span>\"西魏陶渊明发起了一个单侧用例: {}#{}\"</span><span>,</span> testContext<span>.</span><span>getTestClass</span><span>(</span><span>)</span><span>,</span> testMethod<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>afterTestMethod</span><span>(</span><span>TestContext</span> testContext<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>String</span> key <span>=</span> testContext<span>.</span><span>getTestMethod</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>;</span>\n        <span>Long</span> afterTestCost <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>\n        <span>Long</span> beforeTestCost <span>=</span> beforeTestCostMap<span>.</span><span>get</span><span>(</span>key<span>)</span><span>;</span>\n        <span>long</span> timed <span>=</span> timedMap<span>.</span><span>get</span><span>(</span>key<span>)</span><span>;</span>\n        <span>// 如果耗时已经大于指定的时间了,就直接过</span>\n        <span>if</span> <span>(</span><span>(</span>timed <span>&lt;=</span> <span>0</span><span>)</span> <span>||</span> afterTestCost <span>-</span> beforeTestCost <span>></span> timed<span>)</span> <span>{</span>\n            <span>Throwable</span> testException <span>=</span> testContext<span>.</span><span>getTestException</span><span>(</span><span>)</span><span>;</span>\n            <span>if</span> <span>(</span><span>Objects</span><span>.</span><span>nonNull</span><span>(</span>testException<span>)</span><span>)</span> <span>{</span>\n                <span>TestConsole</span><span>.</span><span>colorPrintln</span><span>(</span><span>AnsiColor</span><span>.</span>BRIGHT_RED<span>,</span> <span>\"测试用例执行失败了,快检查检查吧。🚒\"</span><span>)</span><span>;</span>\n            <span>}</span> <span>else</span> <span>{</span>\n                <span>TestConsole</span><span>.</span><span>colorPrintln</span><span>(</span><span>\"用例执行成功。💪\"</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            <span>// 如果不够,就要挂起指定时间。（减去1000毫秒,给Timed预留的时间）</span>\n            <span>long</span> nanos <span>=</span> <span>TimeUnit</span><span>.</span>MILLISECONDS<span>.</span><span>toNanos</span><span>(</span>timed <span>-</span> <span>(</span>afterTestCost <span>-</span> beforeTestCost<span>)</span> <span>-</span> <span>1000</span><span>)</span><span>;</span>\n            <span>// 主线程挂起,等待异步执行</span>\n            <span>System</span><span>.</span>err<span>.</span><span>printf</span><span>(</span><span>\"Timed任务挂起通知: 主线程挂起%d s,等待异步执行%n\"</span><span>,</span> <span>TimeUnit</span><span>.</span>NANOSECONDS<span>.</span><span>toSeconds</span><span>(</span>nanos<span>)</span><span>)</span><span>;</span>\n            <span>LockSupport</span><span>.</span><span>parkNanos</span><span>(</span>nanos<span>)</span><span>;</span>\n        <span>}</span>\n\n    <span>}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><h3 id=\"_2-3-引导类配置\"> 2.3 引导类配置</h3>\n<ul>\n<li>@TestExecutionListeners 注意声明添加模式是合并(默认是替换)</li>\n</ul>\n<div><div><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br></div><pre><code><span>@Slf4j</span>\n<span>@ActiveProfiles</span><span>(</span><span>{</span><span>\"local\"</span><span>}</span><span>)</span>\n<span>@ContextConfiguration</span><span>(</span>initializers <span>=</span> <span>{</span><span>BeanLazyApplicationContextInitializer</span><span>.</span><span>class</span><span>}</span><span>)</span>\n<span>// 使用Spring容器引导</span>\n<span>@RunWith</span><span>(</span><span>SpringRunner</span><span>.</span><span>class</span><span>)</span>\n<span>// 合并模式下,增加测试执行监听器</span>\n<span>@TestExecutionListeners</span><span>(</span>value <span>=</span> <span>PmsSentryTestExecutionListener</span><span>.</span><span>class</span><span>,</span> mergeMode <span>=</span> <span>TestExecutionListeners<span>.</span>MergeMode</span><span>.</span>MERGE_WITH_DEFAULTS<span>)</span>\n<span>// 默认就是回滚,不用加@Rollback,如果全局不想回滚就在这个吧@Rollback(false),如果某个单测不想回滚,就放到单侧类上</span>\n<span>@Transactional</span>\n<span>@SpringBootTest</span><span>(</span>classes <span>=</span> <span>{</span><span>CenterProviderApplication</span><span>.</span><span>class</span><span>}</span><span>)</span> <span>// 指定启动类</span>\n<span>public</span> <span>class</span> <span>BaseApplicationTest</span> <span>{</span>\n<span>}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div>",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "影响范围",
      "url": "https://java.springlearn.cn/learn/test/%E5%BD%B1%E5%93%8D%E8%8C%83%E5%9B%B4/",
      "id": "https://java.springlearn.cn/learn/test/%E5%BD%B1%E5%93%8D%E8%8C%83%E5%9B%B4/",
      "content_html": "<div><p>注意影响</p>\n<p>所有的单测一定针对不是生产环境,一般线上发布我们会声明不运行单测。\n如何考虑环境因素呢?</p>\n<p>两个解决办法:</p>\n<ul>\n<li>应用维度环境分离 spring.profiles.active=test</li>\n<li>测试基类指定环境 @ActiveProfiles(&quot;test&quot;)</li>\n</ul>\n</div>\n<h2 id=\"一、影响范围考虑哪些因素\"> 一、影响范围考虑哪些因素?</h2>\n<h3 id=\"_1-1-是否影响测试环境\"> 1.1 是否影响测试环境?</h3>\n<p>可以设置单测事务不提交,保证对数据无影响。</p>\n<h3 id=\"_1-2-是否对业务无影响\"> 1.2 是否对业务无影响?</h3>\n<p>检查是否做了环境隔离。</p>\n<h3 id=\"_1-3-是否可重复跑\"> 1.3 是否可重复跑?</h3>\n<p>如果前两点都已经解决,那么就可以重复跑。\n重复跑可以模拟验证幂等或者重复提交的问题。</p>\n<h2 id=\"三、什么时候写单测\"> 三、什么时候写单测</h2>\n<p>后端开发进度: 开发50% + 单元测试30% + 联调20%</p>\n<ol>\n<li>自己代码开发完成后,就应该进行单测。</li>\n<li>自己代码开发完了,其他人没有开发完。可以进行Mockito单测,先确保自己的代码没问题。</li>\n<li>对自己负责的功能模块进行单测维护。</li>\n</ol>\n",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "②如何知道是否依赖Spring容器",
      "url": "https://java.springlearn.cn/learn/test/%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E6%98%AF%E5%90%A6%E4%BE%9D%E8%B5%96Spring%E5%AE%B9%E5%99%A8/",
      "id": "https://java.springlearn.cn/learn/test/%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E6%98%AF%E5%90%A6%E4%BE%9D%E8%B5%96Spring%E5%AE%B9%E5%99%A8/",
      "content_html": "<p>默认使用 <code>BlockJUnit4ClassRunner</code> 来进行运行。即不依赖容器。\n假如说如果需要容器怎么办呢 ? <Version>基于SpringBoot 2.1.x版本分析</Version></p>\n<div><pre><code><span>@RunWith</span><span>(</span><span>SpringRunner</span><span>.</span><span>class</span><span>)</span>\n<span>@SpringBootTest</span><span>(</span>classes <span>=</span> <span>{</span><span>Application</span><span>.</span><span>class</span><span>}</span><span>)</span> <span>// 指定启动类</span>\n<span>public</span> <span>class</span> <span>BaseApplicationTest</span> <span>{</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ul>\n<li>SpringRunner告诉JUnit要使用Spring容器</li>\n<li>SpringBootTest告诉JUnit容器的引导类是这个</li>\n</ul>\n<p>JUnit是如何实现的呢?</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1617791013000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>前面启动类中我们使用的注解是 <code>@RunWith</code> 和 <code>@SpringBootTest</code> 那么哪里来解析这个的呢?</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1617791209000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>由此 <code>JUnit</code> 知道要使用 <code>SpringRunner</code> 进行引导。</p>\n<p>由上图我们知道 <code>SpringRunner</code> 实例化的入参就是当前的测试类。那么后续所有的奥妙就在这里了。\n我们跟进构造往下追究。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1617795279000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><code>BootstrapUtils#resolveTestContextBootstrapper</code>\n拿到SpringBoot的测试引导类 <code>SpringBootTestContextBootstrapper</code></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1617795346000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>拿到SpringBoot容器的启动 <code>Main</code> 函数。</p>\n<p>到此已经拿到了所有的SpringBoot容器启动参数了。</p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1617791013000.png",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "极限测试",
      "url": "https://java.springlearn.cn/learn/test/%E6%9E%81%E9%99%90%E6%B5%8B%E8%AF%95/",
      "id": "https://java.springlearn.cn/learn/test/%E6%9E%81%E9%99%90%E6%B5%8B%E8%AF%95/",
      "content_html": "<div><p>极限测试</p>\n<ul>\n<li>最大值</li>\n<li>最小值</li>\n<li>null值</li>\n<li>空值</li>\n<li>异常</li>\n</ul>\n</div>\n<h3 id=\"这段代码会执行通过吗\"> 这段代码会执行通过吗?</h3>\n<div><pre><code>  <span>int</span> a <span>=</span> <span>24</span> <span>*</span> <span>24</span> <span>*</span> <span>60</span> <span>*</span> <span>60</span> <span>*</span> <span>1000</span><span>;</span>\n  <span>int</span> b <span>=</span> <span>25</span> <span>*</span> <span>24</span> <span>*</span> <span>60</span> <span>*</span> <span>60</span> <span>*</span> <span>1000</span><span>;</span>\n  <span>Assert</span><span>.</span><span>assertTrue</span><span>(</span>b <span>></span> a<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>关于测试用例的要思考下是否要使用极限值,验证。</p>\n",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "消息验证",
      "url": "https://java.springlearn.cn/learn/test/%E6%B6%88%E6%81%AF%E9%AA%8C%E8%AF%81/",
      "id": "https://java.springlearn.cn/learn/test/%E6%B6%88%E6%81%AF%E9%AA%8C%E8%AF%81/",
      "content_html": "<div><p>相关信息</p>\n<p>这一是凑数的,想表达的内容只有一点: 消息入口不应该出现复杂的业务逻辑。\n对于消息的验证,我们只需要验证消息收发是否正常即可。处理方案就是将消息与\n业务分离测试。</p>\n</div>\n<p>eg:</p>\n<p>Message入口就类似于Web入口一样。我们复杂的业务逻辑一定不会再入口处直接写代码，\n如果是这样写的那么维护性和复用性一定是很差的。</p>\n",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "①谁在调用JUnit",
      "url": "https://java.springlearn.cn/learn/test/%E8%B0%81%E5%9C%A8%E8%B0%83%E7%94%A8JUnit/",
      "id": "https://java.springlearn.cn/learn/test/%E8%B0%81%E5%9C%A8%E8%B0%83%E7%94%A8JUnit/",
      "content_html": "<p>当点击了执行单例,发生了什么事情? <Version>基于SpringBoot 2.1.x版本分析</Version></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1617790044000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>可以看到idea会将单侧的类和方法传递给JUnit。最终由</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1617790263000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>可以看到最终是由 <code>AllDefaultPossibilitiesBuilder</code> 来进行了承接 。所以到这里我们就找到了入口。后续所有的能力,都要从JUnit中去寻找了。</p>\n<div><pre><code>    <span>@Override</span>\n    <span>public</span> <span>Runner</span> <span>getRunner</span><span>(</span><span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>runner <span>==</span> <span>null</span><span>)</span> <span>{</span>\n            <span>synchronized</span> <span>(</span>runnerLock<span>)</span> <span>{</span>\n                <span>if</span> <span>(</span>runner <span>==</span> <span>null</span><span>)</span> <span>{</span>\n                    runner <span>=</span> <span>new</span> <span>AllDefaultPossibilitiesBuilder</span><span>(</span>canUseSuiteMethod<span>)</span><span>.</span><span>safeRunnerForClass</span><span>(</span>fTestClass<span>)</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> runner<span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div>",
      "image": "https://img.springlearn.cn/blog/learn_1617790044000.png",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Java常用工具汇总",
      "url": "https://java.springlearn.cn/learn/tools/",
      "id": "https://java.springlearn.cn/learn/tools/",
      "content_html": "<p><img src=\"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fdingyue.nosdn.127.net%2FE6THXq%3DiQcEIsorT3I0CkBOmDirJ3h7O7kCs%3DrKoxB0Wc1541040371523.jpg&amp;refer=http%3A%2F%2Fdingyue.nosdn.127.net&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1663654489&amp;t=afedceaba71c16648aa56834849aa4d6\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"为什么会有工具系列专题\"> 为什么会有工具系列专题</h3>\n<p>好比, 初入江湖, 要想成为一个武林高手。必须要有一个基础的内功心法。内功心法越高, 练成最上乘武功就越快。\n而这些常用的框架，就是基础的内功心法。当然没有内功心法也能练成上乘武功。只不过可能时间花费会更多点。\n本篇小编分享下常用的Java 工具。这些会在后面我们写框架或者是写业务代码时候。如果你还有更多好的工具,可以留下\n你的评论。我们一起学习。</p>\n",
      "image": "https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fdingyue.nosdn.127.net%2FE6THXq%3DiQcEIsorT3I0CkBOmDirJ3h7O7kCs%3DrKoxB0Wc1541040371523.jpg&refer=http%3A%2F%2Fdingyue.nosdn.127.net&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1663654489&t=afedceaba71c16648aa56834849aa4d6",
      "date_published": "2022-08-22T01:35:49.000Z",
      "date_modified": "2022-08-22T01:35:49.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": [
        "java"
      ]
    },
    {
      "title": "测试范围",
      "url": "https://java.springlearn.cn/learn/test/%E6%B5%8B%E8%AF%95%E8%8C%83%E5%9B%B4/",
      "id": "https://java.springlearn.cn/learn/test/%E6%B5%8B%E8%AF%95%E8%8C%83%E5%9B%B4/",
      "content_html": "<div><p>相关信息</p>\n<p>项目中拿些类需要进行单元测试呢?\n单测不是目的,是手段。目的都是保证质量</p>\n</div>\n<h2 id=\"一、从项目分层维度设计单测用例\"> 一、从项目分层维度设计单测用例</h2>\n<p>常见的项目分层有一下这些。</p>\n<ul>\n<li>Web层</li>\n<li>Service层</li>\n<li>domain层</li>\n<li>Integration层</li>\n<li>Common层 公用类必须要做</li>\n</ul>\n<h3 id=\"_1-1-web层-【忽略】\"> 1.1 Web层   【忽略】</h3>\n<p>一般web层已经上线不会发生改动,往往改动的是新增或者删除参数。可以忽略。</p>\n<h3 id=\"_1-2-service层-【建议】\"> 1.2 Service层   【建议】</h3>\n<p>Service层往往是程序的接口层,接受来自Web或者Message、Job的调用。Service的逻辑会覆盖大部分的下游分层。Service是我们的业务入口\n接口往往不会改变,改变最多的是它的实现。这一层我们要做好单元测试。</p>\n<p>但是这一层的单元测试可能会涉及数据的读写和外部的数据读写。可以使用Mockito数据进行替换外部数据的返回。\n内部数据的读写可以通过事务回滚的方式处理,主要验证自己代码中对这些数据的结算逻辑是否有问题。</p>\n<p>这一层入参的数据往往会很多,对系统也有相关的依赖,自行评估方案。\n这里提供两个曲线救国的方案:</p>\n<ol>\n<li>如果不好测试可以对程序的最小单元进行测试,曲线救国。</li>\n<li>对某个方法中,不满足测试场景的接口,进行Mockito,以跳过这段逻辑。</li>\n</ol>\n<h3 id=\"_1-3-domain层-【建议】\"> 1.3 Domain层   【建议】</h3>\n<p>这一层和Service的业务是比较相像的,只不过不会有Service层一样那么复杂,参考上文。</p>\n<h3 id=\"_1-4-integration层-【建议】\"> 1.4 Integration层 【建议】</h3>\n<p>防腐层,主要逻辑就是对外部接口的调用,主要测试不要出现NPE。参数的输入值做好非空非null判断,对返回结果做好非空和非null。</p>\n<div><pre><code><span>public</span> <span>List</span><span><span>&lt;</span><span>GoodsBaseMsgDTO</span><span>></span></span> <span>querySkuList</span><span>(</span><span>Long</span> skuId<span>,</span> <span>Long</span> brandId<span>,</span> <span>String</span> goodsName<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span><span>Objects</span><span>.</span><span>isNull</span><span>(</span>skuId<span>)</span> <span>&amp;&amp;</span> <span>Objects</span><span>.</span><span>isNull</span><span>(</span>brandId<span>)</span> <span>&amp;&amp;</span> <span>StringUtils</span><span>.</span><span>isBlank</span><span>(</span>goodsName<span>)</span><span>)</span> <span>{</span>\n            <span>// 根据业务来判断是报错还是为空</span>\n            <span>return</span> <span>EnhanceStream</span><span>.</span><span>emptyList</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>GoodsMsgQueryParam</span> queryParam <span>=</span> <span>new</span> <span>GoodsMsgQueryParam</span><span>(</span><span>)</span><span>;</span>\n        queryParam<span>.</span><span>setBrandId</span><span>(</span>brandId<span>)</span><span>;</span>\n        queryParam<span>.</span><span>setSkuId</span><span>(</span>skuId<span>)</span><span>;</span>\n        queryParam<span>.</span><span>setGoodsName</span><span>(</span>goodsName<span>)</span><span>;</span>\n        <span>JsonResult</span><span><span>&lt;</span><span>PageData</span><span>&lt;</span><span>GoodsBaseMsgDTO</span><span>></span><span>></span></span> pageDataJsonResult <span>=</span> goodsStockApi<span>.</span><span>pageQuerySkuList</span><span>(</span>queryParam<span>)</span><span>;</span>\n        <span>PageData</span><span><span>&lt;</span><span>GoodsBaseMsgDTO</span><span>></span></span> pageData <span>=</span> <span>JsonResultUtils</span><span>.</span><span>orElseGetSafeData</span><span>(</span>pageDataJsonResult<span>,</span> <span>new</span> <span>PageData</span><span><span>&lt;</span><span>GoodsBaseMsgDTO</span><span>></span></span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span><span>Objects</span><span>.</span><span>isNull</span><span>(</span>pageData<span>)</span><span>)</span> <span>{</span>\n            <span>return</span> <span>EnhanceStream</span><span>.</span><span>emptyList</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> pageData<span>.</span><span>getRecords</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n    \n<span>public</span> <span>static</span> <span><span>&lt;</span><span>T</span><span>></span></span> <span>T</span> <span>orElseGetSafeData</span><span>(</span><span>JsonResult</span><span><span>&lt;</span><span>T</span><span>></span></span> result<span>,</span> <span>T</span> defaultValue<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span><span>null</span> <span>!=</span> result <span>&amp;&amp;</span> result<span>.</span><span>isSuccess</span><span>(</span><span>)</span> <span>&amp;&amp;</span> <span>Objects</span><span>.</span><span>nonNull</span><span>(</span>result<span>.</span><span>getData</span><span>(</span><span>)</span><span>)</span><span>)</span> <span>{</span>\n            <span>return</span> result<span>.</span><span>getData</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            <span>if</span> <span>(</span><span>Objects</span><span>.</span><span>nonNull</span><span>(</span>result<span>)</span><span>)</span><span>{</span>\n                log<span>.</span><span>error</span><span>(</span>result<span>.</span><span>getMsg</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>}</span>\n            <span>return</span> <span>Objects</span><span>.</span><span>nonNull</span><span>(</span>defaultValue<span>)</span> <span>?</span> defaultValue <span>:</span> <span>null</span><span>;</span>\n        <span>}</span>\n<span>}</span>    \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>外部提供的 <code>Feign</code> 接口, 在没有提供实现之前可以先使用 <code>Mockito</code>进行Mock\n帮助完成接口的测试。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>TradeShopIntegrationImplTest</span> <span>extends</span> <span>BaseApplicationTest</span> <span>{</span>\n\n    <span>@Autowired</span>\n    <span>private</span> <span>TradeShopIntegration</span> shopBrandIntegration<span>;</span>\n\n    <span>@MockBean</span>\n    <span>private</span> <span>BrandServiceApi</span> brandService<span>;</span>\n    \n    <span>@MockBean</span>\n    <span>private</span> <span>GoodsStockApi</span> goodsStockApi<span>;</span>\n    \n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>testGetAllBrands</span><span>(</span><span>)</span> <span>{</span>\n        <span>Mockito</span><span>.</span><span>doReturn</span><span>(</span><span>JsonResult</span><span>.</span><span>failure</span><span>(</span><span>\"fail\"</span><span>)</span><span>)</span><span>.</span><span>when</span><span>(</span>goodsStockApi<span>)</span><span>.</span><span>getSkuList</span><span>(</span><span>Mockito</span><span>.</span><span>any</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// 底层调用的是goodsStockApi.getSkuList()</span>\n        <span>List</span><span><span>&lt;</span><span>GoodsBaseMsgDTO</span><span>></span></span> goodsBaseMsgDTOS <span>=</span> shopBrandIntegration<span>.</span><span>queryAllSku</span><span>(</span><span>)</span><span>;</span>\n        <span>// 因为前面声明了返回fail。所以这里没有数据返回。</span>\n        <span>JsonConsoleUtils</span><span>.</span><span>println</span><span>(</span>goodsBaseMsgDTOS<span>)</span><span>;</span>\n        <span>// 这里跟上面的区别就是,如果没有声明返回值,就走原来的方法。</span>\n        <span>List</span><span><span>&lt;</span><span>OutBrandDTO</span><span>></span></span> allBrands <span>=</span> shopBrandIntegration<span>.</span><span>getAllBrands</span><span>(</span><span>)</span><span>;</span>\n        <span>JsonConsoleUtils</span><span>.</span><span>println</span><span>(</span>allBrands<span>)</span><span>;</span>\n    <span>}</span>\n    \n<span>}</span>    \n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h3 id=\"_1-5-common层-【必须-】\"> 1.5 Common层   【必须  】</h3>\n<p>这一层基本出现的都是工具类,主要是功能性代码,自己提供的工具类,一定要做好单元测试。主要是考虑\n异常情况和极限的情况。工具类因为变动的不会太频繁所以维护成本是也比较低的。</p>\n<p><a href=\"https://ddd.springlearn.cn/docs/test/spring-boot-testing\" target=\"_blank\" rel=\"noopener noreferrer\">Mockito学习跳转</a></p>\n<h2 id=\"二、针对核心计算逻辑设计单测用例\"> 二、针对核心计算逻辑设计单测用例</h2>\n<p>比较核心的计算逻辑进行测试。比如根据外部数据进行组装生成新的数据模型的方法。</p>\n<h2 id=\"三、忽略测试\"> 三、忽略测试</h2>\n<p>在实际开发中可能有些测试只是为了验证某些数据,每次执行要提前准备数据之类的。这种特殊的单测,只能人工指定运行的\n我们可以忽略它,使用<code>@Ignore</code> 忽略。这样在Maven运行单测时候,会只运行你没有进行忽略的单测。</p>\n",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "测试成本",
      "url": "https://java.springlearn.cn/learn/test/%E6%B5%8B%E8%AF%95%E6%88%90%E6%9C%AC/",
      "id": "https://java.springlearn.cn/learn/test/%E6%B5%8B%E8%AF%95%E6%88%90%E6%9C%AC/",
      "content_html": "<div><p>相关信息</p>\n<p>测试成本到底有多大? 你认为你写的代码需不需要测试? 为了引出成本的话题, 我们先从实际工作中出发\n看看你能否经受住这些灵魂的考验吧。</p>\n</div>\n<h2 id=\"一、灵魂深处的拷问\"> 一、灵魂深处的拷问</h2>\n<ul>\n<li>你的代码质量如何度量？</li>\n<li>你是如何保证代码质量？</li>\n<li>你敢随时重构代码吗？</li>\n<li>你是如何确保重构的代码依然保持正确性？</li>\n<li>你是否有足够信心在没有测试的情况下随时发布你的代码？</li>\n</ul>\n<p>📢 如果答案都比较犹豫，那么就证明我们非常需要单元测试。(ps: 不会有人心里想的是我们需要测试同学吧 😏)</p>\n<p><mark>它能带给我们很多保障：</mark></p>\n<hr>\n<ul>\n<li>代码质量持续有保障</li>\n<li>重构正确性保障</li>\n<li>增强自信心</li>\n<li>自动化运行</li>\n</ul>\n<hr>\n<p>Web 应用中的单元测试更加重要，在 Web 产品快速迭代的时期，每个测试用例都给应用的稳定性提供了一层保障。 API 升级，测试用例可以很好地检查代码是否向下兼容。 对于各种可能的输入，一旦测试覆盖，都能明确它的输出。 代码改动后，可以通过测试结果判断代码的改动是否影响已确定的结果。</p>\n<p>所以，应用的 Controller、Service、Common、Manager 等代码，都必须有对应的单元测试保证代码质量。 当然，框架和插件的每个功能改动和重构都需要有相应的单元测试，并且要求尽量做到修改的代码能被 100% 覆盖到。</p>\n<p>特别是中大型项目，经过多年的代码迭代，业务逻辑复杂，代码改动很容易牵一发动全身，\n单元测试就能给应用的稳定性提供了一层保障。不用面对qa的灵魂拷问：</p>\n<Highlight color=\"#ff603f\">为什么老是你的bug最多！</Highlight>\n<h2 id=\"二、单测是手段不是目的\"> 二、单测是手段不是目的</h2>\n<blockquote>\n<p>单测行覆盖率高不代表应用的质量就一定高,但是单测行覆盖率低一定代表着这个应用出现质量问题的可能性就越大</p>\n</blockquote>\n<p>还是引用前面话,我们不要为了单测而写单测,如果是把单测当做是目的来做,那么就偏离了单测的意义,自然而然你就认为\n这个单测的成本是高的。... ... ... ... ... ... ... <Highlight color=\"#ff603f\">你品你细品</Highlight></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1618049846000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"三、软件的质量不是测试出来的-而是设计和维护出来的\"> 三、软件的质量不是测试出来的，而是设计和维护出来的</h2>\n<Highlight color=\"#ff603f\">你品你细品</Highlight>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1618206722000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>作为底层开发人员, 我们清晰每一行代码, 也就是最小执行单元。哪里容易出现错误，这次改造涉及到了那些代码。一线开发人员一定是最清楚的人,没有之一。</p>\n<p>从这个角度来了, 这就不是成本的问题了, 是职责范围内的事情。</p>\n<p>如果单元测试都不做,就好比我去街上买鸡蛋, 我问老板鸡蛋是好是坏, 老板说我不知道, 然后说坏了拿来可以换。\n你认为那个成本更大呢? 那个代价更大呢? 玩意坏鸡蛋把人吃坏了，这老板岂不是赔了夫人又折兵,还要受到法律的制裁?</p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1618049846000.png",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Arthas（阿尔萨斯） 能为你做什么",
      "url": "https://java.springlearn.cn/learn/tools/arthas/",
      "id": "https://java.springlearn.cn/learn/tools/arthas/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/learn_1647177070000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>Arthas 是Alibaba开源的Java诊断工具，深受开发者喜爱。</p>\n<p>当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p>\n<ul>\n<li><input type=\"checkbox\" checked=\"checked\" disabled=\"disabled\" id=\"task-item-0\"><label for=\"task-item-0\"> 这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</label></li>\n<li><input type=\"checkbox\" checked=\"checked\" disabled=\"disabled\" id=\"task-item-1\"><label for=\"task-item-1\"> 我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</label></li>\n<li><input type=\"checkbox\" checked=\"checked\" disabled=\"disabled\" id=\"task-item-2\"><label for=\"task-item-2\"> 遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</label></li>\n<li><input type=\"checkbox\" checked=\"checked\" disabled=\"disabled\" id=\"task-item-3\"><label for=\"task-item-3\"> 线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</label></li>\n<li><input type=\"checkbox\" checked=\"checked\" disabled=\"disabled\" id=\"task-item-4\"><label for=\"task-item-4\"> 是否有一个全局视角来查看系统的运行状况？</label></li>\n<li><input type=\"checkbox\" checked=\"checked\" disabled=\"disabled\" id=\"task-item-5\"><label for=\"task-item-5\"> 有什么办法可以监控到JVM的实时运行状态？</label></li>\n<li><input type=\"checkbox\" checked=\"checked\" disabled=\"disabled\" id=\"task-item-6\"><label for=\"task-item-6\"> 怎么快速定位应用的热点，生成火焰图？</label></li>\n<li><input type=\"checkbox\" checked=\"checked\" disabled=\"disabled\" id=\"task-item-7\"><label for=\"task-item-7\"> 怎样直接从JVM内查找某个类的实例？</label></li>\n</ul>\n<p>Arthas支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。</p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1647177070000.png",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "APT技术",
      "url": "https://java.springlearn.cn/learn/tools/apt/",
      "id": "https://java.springlearn.cn/learn/tools/apt/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/0d7181f253655683928c302f20fe7c1d.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"一、什么是apt\"> 一、什么是APT</h2>\n<p><code>APT(Annotation Processing Tool)</code> 注解处理器，是 <code>javac</code> 的一个工具，他可以在源码生成class的时候,处理Java语法树。\n我们用他可以干什么呢?</p>\n<ol>\n<li>lombok的原理,在编译期修改字节码,生成 <code>get</code> 和 <code>set</code> 方法。</li>\n</ol>\n<p>本文我们就使用APT技术, 来自动生成get和set方法</p>\n<p><img src=\"https://img.springlearn.cn/blog/3c2d07c5116dd320a8a27439c6270cf2.png\" alt=\"\" loading=\"lazy\"></p>\n<p><a href=\"https://github.com/lxchinesszz/MyLombok.git\" target=\"_blank\" rel=\"noopener noreferrer\">源码地址</a></p>\n<p>感兴趣的可以了解一下,不用害怕,尤其是2.6到2.7目录，不需要看到这个API就害怕。也不用死记硬背。了解就好。\n正经人是不会用这个生成字节码的,字节码生成我们有很多好用的工具。</p>\n<ul>\n<li><a href=\"/learn/tools/bytecode/Javassist/\">Javassist</a></li>\n</ul>\n<p>或者是 <code>javapoet</code></p>\n<h2 id=\"二、实战演示\"> 二、实战演示</h2>\n<h2 id=\"_2-1-定义处理器\"> 2.1 定义处理器</h2>\n<p>继承 <code>AbstractProcessor</code></p>\n<div><pre><code><span>@AutoService</span><span>(</span><span>Processor</span><span>.</span><span>class</span><span>)</span>\n<span>@SupportedAnnotationTypes</span><span>(</span><span>{</span><span>\"cn.lxchinesszz.MyData\"</span><span>,</span><span>\"cn.lxchinesszz.MyGetter\"</span><span>,</span><span>\"cn.lxchinesszz.MySetter\"</span><span>}</span><span>)</span>\n<span>// 这个注解处理器是处理哪个注解的</span>\n<span>@SupportedSourceVersion</span><span>(</span><span>SourceVersion</span><span>.</span>RELEASE_8<span>)</span>\n<span>public</span> <span>class</span> <span>MyLombokProcessor</span> <span>extends</span> <span>AbstractProcessor</span> <span>{</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>synchronized</span> <span>void</span> <span>init</span><span>(</span><span>ProcessingEnvironment</span> processingEnvironment<span>)</span> <span>{</span><span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>boolean</span> <span>process</span><span>(</span><span>Set</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>TypeElement</span><span>></span></span> set<span>,</span> <span>RoundEnvironment</span> roundEnv<span>)</span> <span>{</span><span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><ul>\n<li>@AutoService 谷歌提供的SPI工具。当使用这个注解会自定生成Java SPI文件, 当然如果不想用谷歌的工具,我们也可以自己来写配置文件</li>\n</ul>\n<div><pre><code>├── classes\n│   ├── META-INF\n│   │   └── services\n│   │       └── javax.annotation.processing.Processor\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ul>\n<li>@SupportedAnnotationTypes({&quot;cn.lxchinesszz.MyData&quot;,&quot;cn.lxchinesszz.MyGetter&quot;,&quot;cn.lxchinesszz.MySetter&quot;})</li>\n</ul>\n<p>支持的注解类型</p>\n<ul>\n<li>@SupportedSourceVersion(SourceVersion.RELEASE_8)</li>\n</ul>\n<p>支持的源码类型</p>\n<h2 id=\"_2-2-element-体系\"> 2.2 Element 体系</h2>\n<ul>\n<li><code>roundEnv.getElementsAnnotatedWith(MyData.class)</code> 可以获取被该注解修饰的类或者字段或者方法。</li>\n</ul>\n<p>下面我们看下 <code>Element</code> 的类型。</p>\n<p><img src=\"https://img.springlearn.cn/blog/ca3e47d8d1707db1afb001febfd70c5a.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code><span>public</span> <span>class</span> <span>User</span><span>{</span> <span>// TypeElement</span>\n\n    <span>private</span> <span>String</span> name<span>;</span> <span>// VariableElement</span>\n    \n    <span>private</span> <span>Interge</span> age<span>;</span> <span>// VariableElement</span>\n    \n    <span>public</span> <span>String</span> <span>getName</span><span>(</span><span>)</span><span>{</span> <span>// ExecutableElement</span>\n        <span>return</span> <span>this</span><span>.</span>name<span>;</span>\n    <span>}</span>\n    \n    <span>public</span> <span>void</span> <span>setName</span><span>(</span> <span>// ExecutableElement</span>\n    <span>String</span> name <span>// VariableElement</span>\n    <span>)</span><span>{</span>\n        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>如何知道Element 的类型呢。</p>\n<ul>\n<li><code>Element#getKind</code></li>\n</ul>\n<p><img src=\"https://img.springlearn.cn/blog/df6b6e790bcc452c9e9552ddca4e1969.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_2-2-1-获取字段信息\"> 2.2.1 获取字段信息</h3>\n<p>这里我们先自定义一个字段类型来获取基础信息,来学习 <code>Element</code></p>\n<div><pre><code> <span>public</span> <span>class</span> <span>FieldElement</span> <span>extends</span> <span>ModifierElement</span> <span>{</span>\n\n    <span>/**\n     * 字段名\n     */</span>\n    <span>private</span> <span>final</span> <span>String</span> fieldName<span>;</span>\n\n    <span>/**\n     * 字段类型\n     */</span>\n    <span>private</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> fieldType<span>;</span>\n\n    <span>/**\n     * 资源原始类型\n     */</span>\n    <span>private</span> <span>final</span> <span>VariableElement</span> fieldElement<span>;</span>\n\n    <span>/**\n     * 基本类型提示\n     */</span>\n    <span>private</span> <span>String</span> remark<span>;</span>\n\n    <span>/**\n     * 字段所属类\n     */</span>\n    <span>private</span> <span>final</span> <span>TypeElement</span> classElement<span>;</span>\n\n    <span>public</span> <span>FieldElement</span><span>(</span><span>String</span> fieldName<span>,</span> <span>VariableElement</span> fieldElement<span>)</span> <span>{</span>\n        <span>super</span><span>(</span>fieldElement<span>)</span><span>;</span>\n        <span>this</span><span>.</span>fieldName <span>=</span> fieldName<span>;</span>\n        <span>this</span><span>.</span>fieldElement <span>=</span> fieldElement<span>;</span>\n        <span>this</span><span>.</span>classElement <span>=</span> <span>(</span><span>TypeElement</span><span>)</span> fieldElement<span>.</span><span>getEnclosingElement</span><span>(</span><span>)</span><span>;</span>\n        <span>try</span> <span>{</span>\n            <span>if</span> <span>(</span><span>isPrimitive</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n                fieldType <span>=</span> <span>null</span><span>;</span>\n                <span>this</span><span>.</span>remark <span>=</span> <span>\"基本类型:\"</span> <span>+</span> fieldElement<span>.</span><span>asType</span><span>(</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span> <span>else</span> <span>{</span>\n                <span>this</span><span>.</span>fieldType <span>=</span> <span>Class</span><span>.</span><span>forName</span><span>(</span>fieldElement<span>.</span><span>asType</span><span>(</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>ClassNotFoundException</span> e<span>)</span> <span>{</span>\n            <span>// 如果还报错说明是一个泛型 根据泛型类型来进行处理 fieldElement.asType()</span>\n            <span>// DeclaredType    Set&lt;String></span>\n            <span>// WildcardType</span>\n            <span>//    ?</span>\n            <span>//    ? extends Number</span>\n            <span>//    ? super T</span>\n            <span>this</span><span>.</span>fieldType <span>=</span> <span>Object</span><span>.</span><span>class</span><span>;</span>\n        <span>}</span>\n    <span>}</span>  \n <span>}</span>   \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br></div></div><ul>\n<li>首先先判断是字段类型</li>\n</ul>\n<div><pre><code>   <span>public</span> <span>static</span> <span>FieldElement</span> <span>toFiledElement</span><span>(</span><span>Element</span> enclosedElement<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span><span>ElementKind</span><span>.</span>FIELD<span>.</span><span>equals</span><span>(</span>enclosedElement<span>.</span><span>getKind</span><span>(</span><span>)</span><span>)</span><span>)</span> <span>{</span>\n            <span>VariableElement</span> fieldElement <span>=</span> <span>(</span><span>VariableElement</span><span>)</span> enclosedElement<span>;</span>\n            <span>Name</span> simpleName <span>=</span> fieldElement<span>.</span><span>getSimpleName</span><span>(</span><span>)</span><span>;</span>\n            <span>return</span> <span>new</span> <span>FieldElement</span><span>(</span>simpleName<span>.</span><span>toString</span><span>(</span><span>)</span><span>,</span> fieldElement<span>)</span><span>;</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>RuntimeException</span><span>(</span><span>\"enclosedElement 不是字段类型:\"</span> <span>+</span> enclosedElement<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n    \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id=\"_2-2-1-获取方法信息\"> 2.2.1 获取方法信息</h3>\n<ul>\n<li>方法包括方法参数和返回值,这里我们自定义一个方法参数。</li>\n</ul>\n<div><pre><code><span>public</span> <span>class</span> <span>MethodElement</span> <span>extends</span> <span>ModifierElement</span><span>{</span>\n\n    <span>/**\n     * 方法参数名\n     */</span>\n    <span>private</span> <span>final</span> <span>String</span> methodName<span>;</span>\n\n    <span>/**\n     * 返回值\n     */</span>\n    <span>private</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> returnType<span>;</span>\n\n    <span>/**\n     * 方法原始信息\n     */</span>\n    <span>private</span> <span>final</span> <span>ExecutableElement</span> methodElement<span>;</span>\n\n    <span>/**\n     * 方法参数\n     */</span>\n    <span>private</span> <span>final</span> <span>List</span><span><span>&lt;</span><span>MethodParamElement</span><span>></span></span> methodParamElements<span>;</span>\n\n    <span>public</span> <span>MethodElement</span><span>(</span><span>ExecutableElement</span> methodElement<span>,</span> <span>List</span><span><span>&lt;</span><span>MethodParamElement</span><span>></span></span> methodParamElements<span>)</span> <span>{</span>\n        <span>super</span><span>(</span>methodElement<span>)</span><span>;</span>\n        <span>this</span><span>.</span>methodName <span>=</span> methodElement<span>.</span><span>getSimpleName</span><span>(</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>\n        <span>try</span> <span>{</span>\n            <span>TypeMirror</span> returnTypeMirror <span>=</span> methodElement<span>.</span><span>getReturnType</span><span>(</span><span>)</span><span>;</span>\n            <span>if</span> <span>(</span>returnTypeMirror <span>instanceof</span> <span>NoType</span><span>)</span> <span>{</span>\n                <span>this</span><span>.</span>returnType <span>=</span> <span>Void</span><span>.</span>TYPE<span>;</span>\n            <span>}</span> <span>else</span> <span>{</span>\n                <span>this</span><span>.</span>returnType <span>=</span> <span>Class</span><span>.</span><span>forName</span><span>(</span>methodElement<span>.</span><span>getReturnType</span><span>(</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>ClassNotFoundException</span> e<span>)</span> <span>{</span>\n            <span>this</span><span>.</span>returnType <span>=</span> <span>Void</span><span>.</span>TYPE<span>;</span>\n        <span>}</span>\n        <span>this</span><span>.</span>methodElement <span>=</span> methodElement<span>;</span>\n        <span>this</span><span>.</span>methodParamElements <span>=</span> methodParamElements<span>;</span>\n    <span>}</span>\n<span>}</span>    \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div><ul>\n<li>生成方法</li>\n</ul>\n<div><pre><code>    <span>public</span> <span>static</span> <span>MethodParamElement</span> <span>toMethodParamElement</span><span>(</span><span>Element</span> enclosedElement<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span><span>ElementKind</span><span>.</span>PARAMETER<span>.</span><span>equals</span><span>(</span>enclosedElement<span>.</span><span>getKind</span><span>(</span><span>)</span><span>)</span><span>)</span> <span>{</span>\n            <span>VariableElement</span> fieldElement <span>=</span> <span>(</span><span>VariableElement</span><span>)</span> enclosedElement<span>;</span>\n            <span>Name</span> simpleName <span>=</span> fieldElement<span>.</span><span>getSimpleName</span><span>(</span><span>)</span><span>;</span>\n            <span>return</span> <span>new</span> <span>MethodParamElement</span><span>(</span>simpleName<span>.</span><span>toString</span><span>(</span><span>)</span><span>,</span> fieldElement<span>)</span><span>;</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>RuntimeException</span><span>(</span><span>\"enclosedElement 不是字段类型:\"</span> <span>+</span> enclosedElement<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>MethodElement</span> <span>toMethodElement</span><span>(</span><span>Element</span> enclosedElement<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span><span>ElementKind</span><span>.</span>METHOD<span>.</span><span>equals</span><span>(</span>enclosedElement<span>.</span><span>getKind</span><span>(</span><span>)</span><span>)</span><span>)</span> <span>{</span>\n            <span>ExecutableElement</span> methodElement <span>=</span> <span>(</span><span>ExecutableElement</span><span>)</span> enclosedElement<span>;</span>\n            <span>List</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>VariableElement</span><span>></span></span> parameters <span>=</span> methodElement<span>.</span><span>getParameters</span><span>(</span><span>)</span><span>;</span>\n            <span>List</span><span><span>&lt;</span><span>MethodParamElement</span><span>></span></span> paramElements <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n            <span>for</span> <span>(</span><span>VariableElement</span> parameter <span>:</span> parameters<span>)</span> <span>{</span>\n                paramElements<span>.</span><span>add</span><span>(</span><span>toMethodParamElement</span><span>(</span>parameter<span>)</span><span>)</span><span>;</span>\n            <span>}</span>\n            <span>return</span> <span>new</span> <span>MethodElement</span><span>(</span>methodElement<span>,</span> paramElements<span>)</span><span>;</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>RuntimeException</span><span>(</span><span>\"enclosedElement 不是方法类型:\"</span> <span>+</span> enclosedElement<span>.</span><span>getClass</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h3 id=\"_2-2-2-获取类信息\"> 2.2.2 获取类信息</h3>\n<p>类信息包括字段和方法</p>\n<div><pre><code><span>public</span> <span>class</span> <span>ClassElement</span> <span>extends</span> <span>ModifierElement</span> <span>{</span>\n\n    <span>/**\n     * 类名称\n     */</span>\n    <span>private</span> <span>final</span> <span>String</span> className<span>;</span>\n\n    <span>/**\n     * 包名称\n     */</span>\n    <span>private</span> <span>final</span> <span>String</span> packageName<span>;</span>\n\n    <span>/**\n     * 类原始信息\n     */</span>\n    <span>private</span> <span>final</span> <span>TypeElement</span> classElement<span>;</span>\n\n    <span>/**\n     * 字段信息\n     */</span>\n    <span>private</span> <span>final</span> <span>List</span><span><span>&lt;</span><span>FieldElement</span><span>></span></span> fieldElements<span>;</span>\n\n    <span>/**\n     * 方法信息\n     */</span>\n    <span>private</span> <span>final</span> <span>List</span><span><span>&lt;</span><span>MethodElement</span><span>></span></span> methodElements<span>;</span>\n\n    <span>public</span> <span>ClassElement</span><span>(</span><span>Element</span> enclosedElement<span>,</span> <span>List</span><span><span>&lt;</span><span>FieldElement</span><span>></span></span> fieldElements<span>,</span> <span>List</span><span><span>&lt;</span><span>MethodElement</span><span>></span></span> methodElements<span>)</span> <span>{</span>\n        <span>super</span><span>(</span>enclosedElement<span>)</span><span>;</span>\n        <span>this</span><span>.</span>classElement <span>=</span> <span>(</span><span>TypeElement</span><span>)</span> enclosedElement<span>;</span>\n        <span>this</span><span>.</span>fieldElements <span>=</span> fieldElements<span>;</span>\n        <span>this</span><span>.</span>methodElements <span>=</span> methodElements<span>;</span>\n        <span>this</span><span>.</span>className <span>=</span> classElement<span>.</span><span>getSimpleName</span><span>(</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>\n        <span>this</span><span>.</span>packageName <span>=</span> classElement<span>.</span><span>getQualifiedName</span><span>(</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>.</span><span>replaceAll</span><span>(</span><span>\"\\\\.\"</span> <span>+</span> classElement<span>.</span><span>getSimpleName</span><span>(</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>,</span> <span>\"\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>    \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><p>生成类信息</p>\n<div><pre><code><span>public</span> <span>static</span> <span>ClassElement</span> <span>toClassElement</span><span>(</span><span>Element</span> enclosedElement<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span><span>ElementKind</span><span>.</span>CLASS<span>.</span><span>equals</span><span>(</span>enclosedElement<span>.</span><span>getKind</span><span>(</span><span>)</span><span>)</span><span>)</span> <span>{</span>\n        <span>List</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>Element</span><span>></span></span> enclosedElements <span>=</span> enclosedElement<span>.</span><span>getEnclosedElements</span><span>(</span><span>)</span><span>;</span>\n        <span>List</span><span><span>&lt;</span><span>FieldElement</span><span>></span></span> fieldElements <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        <span>List</span><span><span>&lt;</span><span>MethodElement</span><span>></span></span> methodElements <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>Element</span> element <span>:</span> enclosedElements<span>)</span> <span>{</span>\n            <span>if</span> <span>(</span><span>ElementKind</span><span>.</span>FIELD<span>.</span><span>equals</span><span>(</span>element<span>.</span><span>getKind</span><span>(</span><span>)</span><span>)</span><span>)</span> <span>{</span>\n                fieldElements<span>.</span><span>add</span><span>(</span><span>toFiledElement</span><span>(</span>element<span>)</span><span>)</span><span>;</span>\n            <span>}</span>\n            <span>if</span> <span>(</span><span>ElementKind</span><span>.</span>METHOD<span>.</span><span>equals</span><span>(</span>element<span>.</span><span>getKind</span><span>(</span><span>)</span><span>)</span><span>)</span> <span>{</span>\n                methodElements<span>.</span><span>add</span><span>(</span><span>toMethodElement</span><span>(</span>element<span>)</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> <span>new</span> <span>ClassElement</span><span>(</span>enclosedElement<span>,</span> fieldElements<span>,</span> methodElements<span>)</span><span>;</span>\n    <span>}</span> <span>else</span> <span>{</span>\n        <span>throw</span> <span>new</span> <span>RuntimeException</span><span>(</span><span>\"enclosedElement 不是字段类型:\"</span> <span>+</span> enclosedElement<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h2 id=\"_2-3-日志打印\"> 2.3 日志打印</h2>\n<p>APT方法中日志的打印,要使用工具。在初始化方法中获取消息打印实例。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>MyLombokProcessor</span> <span>extends</span> <span>AbstractProcessor</span> <span>{</span>\n    <span>private</span> <span>Messager</span> message<span>;</span>\n\n     <span>@Override</span>\n    <span>public</span> <span>synchronized</span> <span>void</span> <span>init</span><span>(</span><span>ProcessingEnvironment</span> processingEnvironment<span>)</span> <span>{</span>\n        <span>super</span><span>.</span><span>init</span><span>(</span>processingEnvironment<span>)</span><span>;</span>\n        message <span>=</span> processingEnvironment<span>.</span><span>getMessager</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>boolean</span> <span>process</span><span>(</span><span>Set</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>TypeElement</span><span>></span></span> set<span>,</span> <span>RoundEnvironment</span> roundEnv<span>)</span> <span>{</span>\n        <span>//\t扫描所有被@MyData注解的元素</span>\n        processingEnv<span>.</span><span>getMessager</span><span>(</span><span>)</span><span>.</span><span>printMessage</span><span>(</span>NOTE<span>,</span> <span>\"------------MyData-----------\"</span> <span>+</span> roundEnv<span>.</span><span>getElementsAnnotatedWith</span><span>(</span><span>MyData</span><span>.</span><span>class</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>就想log日志一样,他也是有消息类型的,如: 提示、异常、警告等。如下枚举</p>\n<div><pre><code><span>/**\n * 诊断类型，例如错误或警告。诊断的类型可用于确定应如何将诊断呈现给用户。例如，错误可能被涂成红色或以“错误”一词为前缀，\n * 而警告可能被涂成黄色或以“警告”一词为前缀。没有要求 Kind 应该对诊断消息暗示任何固有的语义含义：例如，一个工具可能会\n * 提供一个选项来将所有警告报告为错误。\n */</span>\n<span>enum</span> <span>Kind</span> <span>{</span>\n   <span>/**\n    * 阻止工具正常完成编译\n    */</span>\n   ERROR<span>,</span>\n   <span>/**\n    * 警告\n    */</span>\n   WARNING<span>,</span>\n   <span>/**\n    * 类似于警告的问题，但由工具规范强制要求。例如，Java™ 语言规范要求对某些未经检查的操作和使用过时的方法发出警告。\n    */</span>\n   MANDATORY_WARNING<span>,</span>\n   <span>/**\n    * 来自该工具的信息性消息。\n    */</span>\n   NOTE<span>,</span>\n   <span>/**\n    * 其他类型的诊断\n    */</span>\n   OTHER<span>,</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><h2 id=\"_2-4-字节码修改\"> 2.4 字节码修改</h2>\n<p>字节码修改首先我们要拿到字节码语法树对象,通过观察者模式类进行修改。这里也在初始化时候获取工具。\n如下我们先定义一个工具。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>ClassElementBuilder</span> <span>{</span>\n    \n    <span>private</span> <span>ProcessingEnvironment</span> processingEnv<span>;</span>\n\n    <span>private</span> <span>JavacTrees</span> trees<span>;</span>\n\n    <span>protected</span> <span>Names</span> names<span>;</span>\n\n    <span>protected</span> <span>TreeMaker</span> treeMaker<span>;</span>\n\n\n    <span>public</span> <span>ClassElementBuilder</span><span>(</span><span>ProcessingEnvironment</span> processingEnv<span>)</span> <span>{</span>\n        <span>Context</span> context <span>=</span> <span>(</span><span>(</span><span>JavacProcessingEnvironment</span><span>)</span> processingEnv<span>)</span><span>.</span><span>getContext</span><span>(</span><span>)</span><span>;</span>\n        <span>this</span><span>.</span>processingEnv <span>=</span> processingEnv<span>;</span>\n        <span>this</span><span>.</span>trees <span>=</span> <span>JavacTrees</span><span>.</span><span>instance</span><span>(</span>processingEnv<span>)</span><span>;</span>\n        <span>this</span><span>.</span>treeMaker <span>=</span> <span>TreeMaker</span><span>.</span><span>instance</span><span>(</span>context<span>)</span><span>;</span>\n        <span>this</span><span>.</span>names <span>=</span> <span>Names</span><span>.</span><span>instance</span><span>(</span>context<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>    \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>处理器初始化方法进行工具的实例化。</p>\n<div><pre><code> <span>@Override</span>\n <span>public</span> <span>synchronized</span> <span>void</span> <span>init</span><span>(</span><span>ProcessingEnvironment</span> processingEnvironment<span>)</span> <span>{</span>\n     <span>super</span><span>.</span><span>init</span><span>(</span>processingEnvironment<span>)</span><span>;</span>\n     <span>this</span><span>.</span>classElementBuilder <span>=</span> <span>new</span> <span>ClassElementBuilder</span><span>(</span>processingEnvironment<span>)</span><span>;</span>\n <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>此时我们就能对添加和修改语法树了。但是这里我们先不着急, 我们在先学习一下语法树的API。</p>\n<h2 id=\"_2-5-jctree-语法树\"> 2.5 JCTree 语法树</h2>\n<h3 id=\"_2-5-1-定义字段\"> 2.5.1 定义字段</h3>\n<p><strong>定义变量使用</strong></p>\n<ul>\n<li>TreeMaker#VarDef(JCTree.JCModifiers 字段修饰符,Names 字段名,JCExpression 字段类型,JCExpression 赋值语句)</li>\n</ul>\n<div><pre><code><span>private</span> <span>String</span> $<span>{</span>fieldName<span>}</span><span>;</span>\n<span>private</span> <span>JCTree<span>.</span>JCVariableDecl</span> <span>generateStringField</span><span>(</span><span>JCTree<span>.</span>JCClassDecl</span> jcClassDecl<span>,</span> <span>String</span> fieldName<span>)</span> <span>{</span>\n    <span>JCTree<span>.</span>JCVariableDecl</span> <span>var</span> <span>=</span> <span><span>treeMaker<span>.</span></span>VarDef</span><span>(</span>\n            <span><span>treeMaker<span>.</span></span>Modifiers</span><span>(</span><span>Flags</span><span>.</span>PRIVATE<span>)</span><span>,</span>\n            names<span>.</span><span>fromString</span><span>(</span>fieldName<span>)</span><span>,</span>\n            <span><span>treeMaker<span>.</span></span>Ident</span><span>(</span>names<span>.</span><span>fromString</span><span>(</span><span>\"String\"</span><span>)</span><span>)</span><span>,</span>\n            <span>null</span><span>)</span><span>;</span>\n    jcClassDecl<span>.</span>defs <span>=</span> jcClassDecl<span>.</span>defs<span>.</span><span>prepend</span><span>(</span><span>var</span><span>)</span><span>;</span>\n    <span>return</span> <span>var</span><span>;</span>\n<span>}</span>\n\n<span>private</span> <span>String</span> $<span>{</span>fieldName<span>}</span> <span>=</span> $<span>{</span>fieldName<span>}</span>\n<span>private</span> <span>JCTree<span>.</span>JCVariableDecl</span> <span>generateStringField</span><span>(</span><span>JCTree<span>.</span>JCClassDecl</span> jcClassDecl<span>,</span> <span>String</span> fieldName<span>)</span> <span>{</span>\n    <span>// 字段的赋值语句</span>\n    <span>JCTree<span>.</span>JCVariableDecl</span> <span>var</span> <span>=</span> <span><span>treeMaker<span>.</span></span>VarDef</span><span>(</span>\n            <span><span>treeMaker<span>.</span></span>Modifiers</span><span>(</span><span>Flags</span><span>.</span>PRIVATE<span>)</span><span>,</span>\n            names<span>.</span><span>fromString</span><span>(</span>fieldName<span>)</span><span>,</span>\n            <span><span>treeMaker<span>.</span></span>Ident</span><span>(</span>names<span>.</span><span>fromString</span><span>(</span><span>\"String\"</span><span>)</span><span>)</span><span>,</span>\n            <span><span>treeMaker<span>.</span></span>Literal</span><span>(</span>fieldName<span>)</span><span>)</span><span>;</span>\n\n    jcClassDecl<span>.</span>defs <span>=</span> jcClassDecl<span>.</span>defs<span>.</span><span>prepend</span><span>(</span><span>var</span><span>)</span><span>;</span>\n    <span>return</span> <span>var</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>要想理解这个API,实现要分析字段是由什么构成的,正如下图。</p>\n<p><img src=\"https://img.springlearn.cn/blog/9575d00387bdb30b09432288524deba4.png\" alt=\"\" loading=\"lazy\"></p>\n<p>标示符三种处理方式。</p>\n<ol>\n<li>包装类型，不用引入包，可以直接使用</li>\n</ol>\n<ul>\n<li>TreeMaker#Ident\nJCExpression</li>\n</ul>\n<div><pre><code><span><span>treeMaker<span>.</span></span>Ident</span><span>(</span>names<span>.</span><span>fromString</span><span>(</span><span>\"String\"</span><span>)</span><span>)</span>\n</code></pre>\n<div><span>1</span><br></div></div><ol start=\"2\">\n<li>基本类型，不用引入包，可以直接使用</li>\n</ol>\n<ul>\n<li>TreeMaker#TypeIdent</li>\n</ul>\n<div><pre><code><span><span>treeMaker<span>.</span></span>TypeIdent</span><span>(</span><span>TypeTag</span><span>.</span>INT<span>)</span>\n</code></pre>\n<div><span>1</span><br></div></div><ol start=\"3\">\n<li>引用类型，需要引入包后再直接使用</li>\n</ol>\n<ul>\n<li>先引入包，然后就向包装类型那样进行处理。</li>\n</ul>\n<div><pre><code><span>// import package</span>\n<span>private</span> <span>JCTree<span>.</span>JCImport</span> <span>genImportPkg</span><span>(</span><span>String</span> packageName<span>,</span> <span>String</span> className<span>)</span> <span>{</span>\n    <span>JCTree<span>.</span>JCIdent</span> ident <span>=</span> <span><span>treeMaker<span>.</span></span>Ident</span><span>(</span>names<span>.</span><span>fromString</span><span>(</span>packageName<span>)</span><span>)</span><span>;</span>\n    <span>return</span> <span><span>treeMaker<span>.</span></span>Import</span><span>(</span><span><span>treeMaker<span>.</span></span>Select</span><span>(</span>\n            ident<span>,</span> names<span>.</span><span>fromString</span><span>(</span>className<span>)</span><span>)</span><span>,</span> <span>false</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id=\"_2-5-2-定义get和set方法\"> 2.5.2 定义get和set方法</h3>\n<p>生成set方法,方法是由</p>\n<ul>\n<li>方法修饰符 <code>treeMaker.Modifiers(Flags.PUBLIC + Flags.STATIC + Flags.FINAL)</code></li>\n<li>方法名 <code>names.fromString(&quot;setName&quot;)</code></li>\n<li>方法返回值 <code>treeMaker#Type、treeMaker#TypeIdent</code></li>\n</ul>\n<div><pre><code><span>/**\n * public void setName(String name){\n *      this.name = name;\n * }\n *\n * @param jcClassDecl 类\n * @param f           字段\n * @param fieldName   字段名\n */</span>\n<span>private</span> <span>void</span> <span>generateSetMethod</span><span>(</span><span>JCTree<span>.</span>JCClassDecl</span> jcClassDecl<span>,</span> <span>JCTree<span>.</span>JCVariableDecl</span> f<span>,</span> <span>String</span> fieldName<span>)</span> <span>{</span>\n    <span>// 方法体内容</span>\n    <span>ListBuffer</span><span><span>&lt;</span><span>JCTree<span>.</span>JCStatement</span><span>></span></span> statements <span>=</span> <span>new</span> <span>ListBuffer</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n    <span>// this.MyDate</span>\n    <span>JCTree<span>.</span>JCFieldAccess</span> aThis <span>=</span> <span><span>treeMaker<span>.</span></span>Select</span><span>(</span><span><span>treeMaker<span>.</span></span>Ident</span><span>(</span>names<span>.</span><span>fromString</span><span>(</span><span>\"this\"</span><span>)</span><span>)</span><span>,</span> names<span>.</span><span>fromString</span><span>(</span>fieldName<span>)</span><span>)</span><span>;</span>\n    <span>// this.MyDate = MyDate;</span>\n    <span>JCTree<span>.</span>JCExpressionStatement</span> exec <span>=</span> <span><span>treeMaker<span>.</span></span>Exec</span><span>(</span><span><span>treeMaker<span>.</span></span>Assign</span><span>(</span>aThis<span>,</span> <span><span>treeMaker<span>.</span></span>Ident</span><span>(</span>names<span>.</span><span>fromString</span><span>(</span>fieldName<span>)</span><span>)</span><span>)</span><span>)</span><span>;</span>\n    statements<span>.</span><span>add</span><span>(</span>exec<span>)</span><span>;</span>\n    <span>JCTree<span>.</span>JCBlock</span> body <span>=</span> <span><span>treeMaker<span>.</span></span>Block</span><span>(</span><span>0</span><span>,</span> statements<span>.</span><span>toList</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\n    <span>// 方法参数</span>\n    <span>JCTree<span>.</span>JCVariableDecl</span> param <span>=</span> <span><span>treeMaker<span>.</span></span>VarDef</span><span>(</span><span><span>treeMaker<span>.</span></span>Modifiers</span><span>(</span><span>Flags</span><span>.</span>PARAMETER<span>)</span><span>,</span> names<span>.</span><span>fromString</span><span>(</span>fieldName<span>)</span><span>,</span> f<span>.</span>vartype<span>,</span> <span>null</span><span>)</span><span>;</span>\n    <span><span>com<span>.</span>sun<span>.</span>tools<span>.</span>javac<span>.</span>util<span>.</span></span>List</span><span><span>&lt;</span><span>JCTree<span>.</span>JCVariableDecl</span><span>></span></span> parameters <span>=</span> <span><span>com<span>.</span>sun<span>.</span>tools<span>.</span>javac<span>.</span>util<span>.</span></span>List</span><span>.</span><span>of</span><span>(</span>param<span>)</span><span>;</span>\n\n    <span>JCTree<span>.</span>JCMethodDecl</span> getNameMethod <span>=</span> <span><span>treeMaker<span>.</span></span>MethodDef</span><span>(</span>\n            <span><span>treeMaker<span>.</span></span>Modifiers</span><span>(</span><span>Flags</span><span>.</span>PUBLIC<span>)</span><span>,</span>  <span>// 方法修饰符</span>\n            names<span>.</span><span>fromString</span><span>(</span><span>\"set\"</span> <span>+</span> <span>capRename</span><span>(</span>fieldName<span>)</span><span>)</span><span>,</span>  <span>// 方法名,capName转驼峰</span>\n            <span><span>treeMaker<span>.</span></span>Type</span><span>(</span><span>new</span> <span>Type<span>.</span>JCVoidType</span><span>(</span><span>)</span><span>)</span><span>,</span>  <span>// 方法返回值类型</span>\n            <span>List</span><span>.</span><span>nil</span><span>(</span><span>)</span><span>,</span>\n            parameters<span>,</span> <span>// 方法参数</span>\n            <span>List</span><span>.</span><span>nil</span><span>(</span><span>)</span><span>,</span>\n            body<span>,</span><span>// 方法体</span>\n            <span>null</span>\n    <span>)</span><span>;</span>\n    <span>// 插入到语法树中</span>\n    jcClassDecl<span>.</span>defs <span>=</span> jcClassDecl<span>.</span>defs<span>.</span><span>prepend</span><span>(</span>getNameMethod<span>)</span><span>;</span>\n<span>}</span>\n\n<span>/**\n * public void getName(){\n *    return this.name;\n * }\n *\n * @param jcClassDecl 类\n * @param f           字段\n * @param fieldName   字段名\n */</span>\n<span>private</span> <span>void</span> <span>generateGetMethod</span><span>(</span><span>JCTree<span>.</span>JCClassDecl</span> jcClassDecl<span>,</span> <span>JCTree<span>.</span>JCVariableDecl</span> f<span>,</span> <span>String</span> fieldName<span>)</span> <span>{</span>\n    <span>// 方法体内容</span>\n    <span>ListBuffer</span><span><span>&lt;</span><span>JCTree<span>.</span>JCStatement</span><span>></span></span> statements <span>=</span> <span>new</span> <span>ListBuffer</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n    <span>// this.name</span>\n    <span>JCTree<span>.</span>JCFieldAccess</span> select <span>=</span> <span><span>treeMaker<span>.</span></span>Select</span><span>(</span><span><span>treeMaker<span>.</span></span>Ident</span><span>(</span>names<span>.</span><span>fromString</span><span>(</span><span>\"this\"</span><span>)</span><span>)</span><span>,</span>\n            names<span>.</span><span>fromString</span><span>(</span>fieldName<span>)</span><span>)</span><span>;</span>\n    <span>// 生成return代码 return this.name</span>\n    <span>JCTree<span>.</span>JCReturn</span> jcReturn <span>=</span> <span><span>treeMaker<span>.</span></span>Return</span><span>(</span>select<span>)</span><span>;</span>\n    statements<span>.</span><span>add</span><span>(</span>jcReturn<span>)</span><span>;</span>\n    <span>// 方法体</span>\n    <span>JCTree<span>.</span>JCBlock</span> body <span>=</span> <span><span>treeMaker<span>.</span></span>Block</span><span>(</span><span>0</span><span>,</span> statements<span>.</span><span>toList</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>// 生成方法</span>\n    <span>JCTree<span>.</span>JCMethodDecl</span> getNameMethod <span>=</span> <span><span>treeMaker<span>.</span></span>MethodDef</span><span>(</span>\n            <span><span>treeMaker<span>.</span></span>Modifiers</span><span>(</span><span>Flags</span><span>.</span>PUBLIC<span>)</span><span>,</span> <span>// 方法修饰符</span>\n            names<span>.</span><span>fromString</span><span>(</span><span>\"get\"</span> <span>+</span> <span>capRename</span><span>(</span>fieldName<span>)</span><span>)</span><span>,</span> <span>// 方法名</span>\n            f<span>.</span>vartype<span>,</span> <span>// 方法返回值类型</span>\n            <span>List</span><span>.</span><span>nil</span><span>(</span><span>)</span><span>,</span>\n            <span>List</span><span>.</span><span>nil</span><span>(</span><span>)</span><span>,</span> <span>// 方法参数</span>\n            <span>List</span><span>.</span><span>nil</span><span>(</span><span>)</span><span>,</span>\n            body<span>,</span> <span>// 方法体</span>\n            <span>null</span>\n    <span>)</span><span>;</span>\n    <span>// 插入到语法树中</span>\n    jcClassDecl<span>.</span>defs <span>=</span> jcClassDecl<span>.</span>defs<span>.</span><span>prepend</span><span>(</span>getNameMethod<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br></div></div><p><a href=\"https://my.oschina.net/u/4030990/blog/3211858\" target=\"_blank\" rel=\"noopener noreferrer\">参考文章</a></p>\n<h2 id=\"_2-6-treemaker\"> 2.6 TreeMaker</h2>\n<p><a href=\"https://my.oschina.net/u/4030990/blog/3211858\" target=\"_blank\" rel=\"noopener noreferrer\">部分内容翻译自</a></p>\n<h3 id=\"_2-6-1-modifiers-修饰符\"> 2.6.1 Modifiers 修饰符</h3>\n<p>java中类,方法,字段都是有修饰符的。</p>\n<div><pre><code><span>public</span> <span>JCModifiers</span> <span>Modifiers</span><span>(</span><span>long</span> flags<span>)</span> <span>{</span>\n    <span>return</span> <span>Modifiers</span><span>(</span>flags<span>,</span> <span>List</span><span>.</span><span><span>&lt;</span> <span>JCAnnotation</span> <span>></span></span><span>nil</span><span>(</span><span>)</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>public</span> <span>JCModifiers</span> <span>Modifiers</span><span>(</span><span>long</span> flags<span>,</span>\n    <span>List</span><span><span>&lt;</span><span>JCAnnotation</span><span>></span></span> annotations<span>)</span> <span>{</span>\n        <span>JCModifiers</span> tree <span>=</span> <span>new</span> <span>JCModifiers</span><span>(</span>flags<span>,</span> annotations<span>)</span><span>;</span>\n        <span>boolean</span> noFlags <span>=</span> <span>(</span>flags <span>&amp;</span> <span>(</span><span>Flags<span>.</span>ModifierFlags</span> <span>|</span> <span>Flags</span><span>.</span>ANNOTATION<span>)</span><span>)</span> <span>==</span> <span>0</span><span>;</span>\n        tree<span>.</span>pos <span>=</span> <span>(</span>noFlags <span>&amp;&amp;</span> annotations<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>?</span> <span>Position</span><span>.</span>NOPOS <span>:</span> pos<span>;</span>\n        <span>return</span> tree<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><ul>\n<li>定义多个修饰符</li>\n</ul>\n<p>treeMaker.Modifiers(Flags.PUBLIC + Flags.STATIC + Flags.FINAL);</p>\n<h3 id=\"_2-6-2-classdef-定义类\"> 2.6.2 ClassDef 定义类</h3>\n<div><pre><code>\n<span>public</span> <span>JCClassDecl</span> <span>ClassDef</span><span>(</span><span>JCModifiers</span> mods<span>,</span> <span>// 访问标志，可以通过 TreeMaker.Modifiers 来创建</span>\n    <span>Name</span> name<span>,</span> <span>// 类名</span>\n    <span>List</span><span><span>&lt;</span><span>JCTypeParameter</span><span>></span></span> typarams<span>,</span> <span>// 泛型参数列表</span>\n    <span>JCExpression</span> extending<span>,</span> <span>// 父类</span>\n    <span>List</span><span><span>&lt;</span><span>JCExpression</span><span>></span></span> implementing<span>,</span> <span>// 实现的接口</span>\n    <span>List</span><span><span>&lt;</span><span>JCTree</span><span>></span></span> defs<span>)</span> <span>{</span> <span>// 类定义的详细语句，包括字段、方法的定义等等</span>\n        <span>JCClassDecl</span> tree <span>=</span> <span>new</span> <span>JCClassDecl</span><span>(</span>mods<span>,</span>\n                                     name<span>,</span>\n                                     typarams<span>,</span>\n                                     extending<span>,</span>\n                                     implementing<span>,</span>\n                                     defs<span>,</span>\n                                     <span>null</span><span>)</span><span>;</span>\n        tree<span>.</span>pos <span>=</span> pos<span>;</span>\n        <span>return</span> tree<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h3 id=\"_2-6-3-methoddef-定义方法\"> 2.6.3 MethodDef 定义方法</h3>\n<div><pre><code><span>public</span> <span>JCMethodDecl</span> <span>MethodDef</span><span>(</span><span>JCModifiers</span> mods<span>,</span> <span>// mods：访问标志</span>\n    <span>Name</span> name<span>,</span> <span>// 方法名</span>\n    <span>JCExpression</span> restype<span>,</span> <span>// 返回类型,返回类型 restype 填写 null 或者 treeMaker.TypeIdent(TypeTag.VOID) 都代表返回 void 类型</span>\n    <span>List</span><span><span>&lt;</span><span>JCTypeParameter</span><span>></span></span> typarams<span>,</span> <span>// 泛型参数列表</span>\n    <span>List</span><span><span>&lt;</span><span>JCVariableDecl</span><span>></span></span> params<span>,</span> <span>// 参数列表</span>\n    <span>List</span><span><span>&lt;</span><span>JCExpression</span><span>></span></span> thrown<span>,</span> <span>// 异常声明列表</span>\n    <span>JCBlock</span> body<span>,</span> <span>// 方法体</span>\n    <span>JCExpression</span> defaultValue <span>// 默认方法（可能是 interface 中的哪个 default）</span>\n    <span>)</span> <span>{</span>\n        <span>JCMethodDecl</span> tree <span>=</span> <span>new</span> <span>JCMethodDecl</span><span>(</span>mods<span>,</span>\n                                       name<span>,</span>\n                                       restype<span>,</span>\n                                       typarams<span>,</span>\n                                       params<span>,</span>\n                                       thrown<span>,</span>\n                                       body<span>,</span>\n                                       defaultValue<span>,</span>\n                                       <span>null</span><span>)</span><span>;</span>\n        tree<span>.</span>pos <span>=</span> pos<span>;</span>\n        <span>return</span> tree<span>;</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h3 id=\"_2-6-4-vardef-定义字段\"> 2.6.4 VarDef 定义字段</h3>\n<div><pre><code><span>public</span> <span>JCVariableDecl</span> <span>VarDef</span><span>(</span><span>JCModifiers</span> mods<span>,</span> <span>// 访问标志</span>\n    <span>Name</span> name<span>,</span> <span>// 参数名称</span>\n    <span>JCExpression</span> vartype<span>,</span> <span>// 类型</span>\n    <span>JCExpression</span> init <span>// 初始化语句</span>\n    <span>)</span> <span>{</span>\n        <span>JCVariableDecl</span> tree <span>=</span> <span>new</span> <span>JCVariableDecl</span><span>(</span>mods<span>,</span> name<span>,</span> vartype<span>,</span> init<span>,</span> <span>null</span><span>)</span><span>;</span>\n        tree<span>.</span>pos <span>=</span> pos<span>;</span>\n        <span>return</span> tree<span>;</span>\n<span>}</span>\n\n<span>public</span> <span>JCVariableDecl</span> <span>VarDef</span><span>(</span><span>VarSymbol</span> v<span>,</span>\n    <span>JCExpression</span> init<span>)</span> <span>{</span>\n        <span>return</span> <span>(</span><span>JCVariableDecl</span><span>)</span>\n            <span>new</span> <span>JCVariableDecl</span><span>(</span>\n                <span>Modifiers</span><span>(</span>v<span>.</span><span>flags</span><span>(</span><span>)</span><span>,</span> <span>Annotations</span><span>(</span>v<span>.</span><span>getAnnotationMirrors</span><span>(</span><span>)</span><span>)</span><span>)</span><span>,</span>\n                v<span>.</span>name<span>,</span>\n                <span>Type</span><span>(</span>v<span>.</span>type<span>)</span><span>,</span>\n                init<span>,</span>\n                v<span>)</span><span>.</span><span>setPos</span><span>(</span>pos<span>)</span><span>.</span><span>setType</span><span>(</span>v<span>.</span>type<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h3 id=\"_2-6-5-return-定义返回\"> 2.6.5 Return 定义返回</h3>\n<div><pre><code><span>public</span> <span>JCReturn</span> <span>Return</span><span>(</span><span>JCExpression</span> expr<span>)</span> <span>{</span>\n        <span>JCReturn</span> tree <span>=</span> <span>new</span> <span>JCReturn</span><span>(</span>expr<span>)</span><span>;</span>\n        tree<span>.</span>pos <span>=</span> pos<span>;</span>\n        <span>return</span> tree<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"_2-6-6-ident-定义关键字\"> 2.6.6 Ident 定义关键字</h3>\n<ul>\n<li><code>treeMaker.Ident(names.fromString(&quot;this&quot;))</code></li>\n</ul>\n<div><pre><code><span>public</span> <span>JCIdent</span> <span>Ident</span><span>(</span><span>Name</span> name<span>)</span> <span>{</span>\n        <span>JCIdent</span> tree <span>=</span> <span>new</span> <span>JCIdent</span><span>(</span>name<span>,</span> <span>null</span><span>)</span><span>;</span>\n        tree<span>.</span>pos <span>=</span> pos<span>;</span>\n        <span>return</span> tree<span>;</span>\n<span>}</span>\n\n<span>public</span> <span>JCIdent</span> <span>Ident</span><span>(</span><span>Symbol</span> sym<span>)</span> <span>{</span>\n        <span>return</span> <span>(</span><span>JCIdent</span><span>)</span><span>new</span> <span>JCIdent</span><span>(</span><span>(</span>sym<span>.</span>name <span>!=</span> names<span>.</span>empty<span>)</span>\n                                <span>?</span> sym<span>.</span>name\n                                <span>:</span> sym<span>.</span><span>flatName</span><span>(</span><span>)</span><span>,</span> sym<span>)</span>\n            <span>.</span><span>setPos</span><span>(</span>pos<span>)</span>\n            <span>.</span><span>setType</span><span>(</span>sym<span>.</span>type<span>)</span><span>;</span>\n<span>}</span>\n\n<span>public</span> <span>JCExpression</span> <span>Ident</span><span>(</span><span>JCVariableDecl</span> param<span>)</span> <span>{</span>\n        <span>return</span> <span>Ident</span><span>(</span>param<span>.</span>sym<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h3 id=\"_2-6-7-select\"> 2.6.7 Select</h3>\n<p>TreeMaker.Select 用于创建域访问 / 方法访问</p>\n<div><pre><code><span>public</span> <span>JCFieldAccess</span> <span>Select</span><span>(</span><span>JCExpression</span> selected<span>,</span>\n    <span>Name</span> selector<span>)</span> \n<span>{</span>\n        <span>JCFieldAccess</span> tree <span>=</span> <span>new</span> <span>JCFieldAccess</span><span>(</span>selected<span>,</span> selector<span>,</span> <span>null</span><span>)</span><span>;</span>\n        tree<span>.</span>pos <span>=</span> pos<span>;</span>\n        <span>return</span> tree<span>;</span>\n<span>}</span>\n\n<span>public</span> <span>JCExpression</span> <span>Select</span><span>(</span><span>JCExpression</span> base<span>,</span>\n    <span>Symbol</span> sym<span>)</span> <span>{</span>\n        <span>return</span> <span>new</span> <span>JCFieldAccess</span><span>(</span>base<span>,</span> sym<span>.</span>name<span>,</span> sym<span>)</span><span>.</span><span>setPos</span><span>(</span>pos<span>)</span><span>.</span><span>setType</span><span>(</span>sym<span>.</span>type<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>两个参数第一个是对象，第二个是对象的那个方法。</p>\n<ul>\n<li>this.${fieldName}</li>\n</ul>\n<div><pre><code>        <span>JCTree<span>.</span>JCFieldAccess</span> aThis <span>=</span> <span><span>treeMaker<span>.</span></span>Select</span><span>(</span><span><span>treeMaker<span>.</span></span>Ident</span><span>(</span>names<span>.</span><span>fromString</span><span>(</span><span>\"this\"</span><span>)</span><span>)</span><span>,</span> names<span>.</span><span>fromString</span><span>(</span>fieldName<span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"_2-6-8-newclass\"> 2.6.8 NewClass</h3>\n<p>用于创建 new 语句语法树节点（JCNewClass）</p>\n<div><pre><code><span>public</span> <span>JCNewClass</span> <span>NewClass</span><span>(</span><span>JCExpression</span> encl<span>,</span>\n    <span>List</span><span><span>&lt;</span><span>JCExpression</span><span>></span></span> typeargs<span>,</span> <span>// 参数类型列表</span>\n    <span>JCExpression</span> clazz<span>,</span> <span>// 待创建对象的类型</span>\n    <span>List</span><span><span>&lt;</span><span>JCExpression</span><span>></span></span> args<span>,</span> <span>// 参数列表</span>\n    <span>JCClassDecl</span> def<span>)</span> <span>{</span> <span>// 类定义</span>\n        <span>JCNewClass</span> tree <span>=</span> <span>new</span> <span>JCNewClass</span><span>(</span>encl<span>,</span> typeargs<span>,</span> clazz<span>,</span> args<span>,</span> def<span>)</span><span>;</span>\n        tree<span>.</span>pos <span>=</span> pos<span>;</span>\n        <span>return</span> tree<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"_2-6-9-assign-赋值语句\"> 2.6.9 Assign 赋值语句</h3>\n<p>类似 Select, 如果说Select是 <code>.</code>\n那么Assign是 <code>=</code></p>\n<div><pre><code><span>public</span> <span>JCAssign</span> <span>Assign</span><span>(</span><span>JCExpression</span> lhs<span>,</span>\n    <span>JCExpression</span> rhs<span>)</span> <span>{</span>\n    <span>JCAssign</span> tree <span>=</span> <span>new</span> <span>JCAssign</span><span>(</span>lhs<span>,</span> rhs<span>)</span><span>;</span>\n    tree<span>.</span>pos <span>=</span> pos<span>;</span>\n    <span>return</span> tree<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>select和assign配合使用</p>\n<div><pre><code>        <span>// this.MyDate</span>\n        <span>JCTree<span>.</span>JCFieldAccess</span> aThis <span>=</span> <span><span>treeMaker<span>.</span></span>Select</span><span>(</span><span><span>treeMaker<span>.</span></span>Ident</span><span>(</span>names<span>.</span><span>fromString</span><span>(</span><span>\"this\"</span><span>)</span><span>)</span><span>,</span> names<span>.</span><span>fromString</span><span>(</span>fieldName<span>)</span><span>)</span><span>;</span>\n        <span>// this.MyDate = MyDate;</span>\n        <span>JCTree<span>.</span>JCExpressionStatement</span> exec <span>=</span> <span><span>treeMaker<span>.</span></span>Exec</span><span>(</span><span><span>treeMaker<span>.</span></span>Assign</span><span>(</span>aThis<span>,</span> <span><span>treeMaker<span>.</span></span>Ident</span><span>(</span>names<span>.</span><span>fromString</span><span>(</span>fieldName<span>)</span><span>)</span><span>)</span><span>)</span><span>;</span>\n      \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"_2-6-10-exec执行语句\"> 2.6.10 Exec执行语句</h3>\n<p>配合赋值语句使用</p>\n<div><pre><code><span>public</span> <span>JCExpressionStatement</span> <span>Exec</span><span>(</span><span>JCExpression</span> expr<span>)</span> <span>{</span>\n        <span>JCExpressionStatement</span> tree <span>=</span> <span>new</span> <span>JCExpressionStatement</span><span>(</span>expr<span>)</span><span>;</span>\n        tree<span>.</span>pos <span>=</span> pos<span>;</span>\n        <span>return</span> tree<span>;</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id=\"_2-6-11-apply-方法调用\"> 2.6.11 Apply 方法调用</h3>\n<div><pre><code><span>// 创建一个方法调用 user.say(\"hello world!\");</span>\n<span>JCTree<span>.</span>JCExpressionStatement</span> exec2 <span>=</span> <span><span>treeMaker<span>.</span></span>Exec</span><span>(</span>\n        <span><span>treeMaker<span>.</span></span>Apply</span><span>(</span>\n                <span><span>com<span>.</span>sun<span>.</span>tools<span>.</span>javac<span>.</span>util<span>.</span></span>List</span><span>.</span><span>nil</span><span>(</span><span>)</span><span>,</span>\n                <span><span>treeMaker<span>.</span></span>Select</span><span>(</span>\n                        <span><span>treeMaker<span>.</span></span>Ident</span><span>(</span>names<span>.</span><span>fromString</span><span>(</span><span>\"user\"</span><span>)</span><span>)</span><span>,</span> <span>// . 左边的内容</span>\n                        names<span>.</span><span>fromString</span><span>(</span><span>\"say\"</span><span>)</span> <span>// . 右边的内容</span>\n                <span>)</span><span>,</span>\n                <span><span>com<span>.</span>sun<span>.</span>tools<span>.</span>javac<span>.</span>util<span>.</span></span>List</span><span>.</span><span>of</span><span>(</span><span><span>treeMaker<span>.</span></span>Literal</span><span>(</span><span>\"hello world!\"</span><span>)</span><span>)</span> <span>// 方法中的内容</span>\n        <span>)</span>\n<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id=\"_2-7-代码片段\"> 2.7 代码片段</h2>\n<p>2.6的API,是真的难用,这里列几个片段。</p>\n<h3 id=\"_2-7-1-生成字段\"> 2.7.1 生成字段</h3>\n<ul>\n<li><code>private String age;</code></li>\n</ul>\n<div><pre><code><span>// 生成参数 例如：private String age;</span>\n<span><span>treeMaker<span>.</span></span>VarDef</span><span>(</span><span><span>treeMaker<span>.</span></span>Modifiers</span><span>(</span><span>Flags</span><span>.</span>PRIVATE<span>)</span><span>,</span> names<span>.</span><span>fromString</span><span>(</span><span>\"age\"</span><span>)</span><span>,</span> <span><span>treeMaker<span>.</span></span>Ident</span><span>(</span>names<span>.</span><span>fromString</span><span>(</span><span>\"String\"</span><span>)</span><span>)</span><span>,</span> <span>null</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"_2-7-2-赋值变量\"> 2.7.2 赋值变量</h3>\n<ul>\n<li><code>private String name = &quot;西魏陶渊明&quot;</code></li>\n</ul>\n<div><pre><code><span><span>treeMaker<span>.</span></span>VarDef</span><span>(</span><span><span>treeMaker<span>.</span></span>Modifiers</span><span>(</span><span>Flags</span><span>.</span>PRIVATE<span>)</span><span>,</span>names<span>.</span><span>fromString</span><span>(</span><span>\"name\"</span><span>)</span><span>,</span><span><span>treeMaker<span>.</span></span>Ident</span><span>(</span>names<span>.</span><span>fromString</span><span>(</span><span>\"String\"</span><span>)</span><span>)</span><span>,</span><span><span>treeMaker<span>.</span></span>Literal</span><span>(</span><span>\"西魏陶渊明\"</span><span>)</span><span>)</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"_2-7-3-相加\"> 2.7.3 相加</h3>\n<ul>\n<li><code>JCTree.Tag.PLUS</code></li>\n</ul>\n<div><pre><code><span><span>treeMaker<span>.</span></span>Exec</span><span>(</span><span><span>treeMaker<span>.</span></span>Assign</span><span>(</span><span><span>treeMaker<span>.</span></span>Ident</span><span>(</span>names<span>.</span><span>fromString</span><span>(</span><span>\"add\"</span><span>)</span><span>)</span><span>,</span><span><span>treeMaker<span>.</span></span>Binary</span><span>(</span><span>JCTree<span>.</span>Tag</span><span>.</span>PLUS<span>,</span><span><span>treeMaker<span>.</span></span>Literal</span><span>(</span><span>\"a\"</span><span>)</span><span>,</span><span><span>treeMaker<span>.</span></span>Literal</span><span>(</span><span>\"b\"</span><span>)</span><span>)</span><span>)</span><span>)</span>\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"_2-7-4-语法\"> 2.7.4 += 语法</h3>\n<ul>\n<li><code>JCTree.Tag.PLUS_ASG</code></li>\n</ul>\n<div><pre><code><span><span>treeMaker<span>.</span></span>Exec</span><span>(</span><span><span>treeMaker<span>.</span></span>Assignop</span><span>(</span><span>JCTree<span>.</span>Tag</span><span>.</span>PLUS_ASG<span>,</span> <span><span>treeMaker<span>.</span></span>Ident</span><span>(</span>names<span>.</span><span>fromString</span><span>(</span><span>\"add\"</span><span>)</span><span>)</span><span>,</span>\n<span><span>treeMaker<span>.</span></span>Literal</span><span>(</span><span>\"test\"</span><span>)</span><span>)</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"_2-7-5-语法\"> 2.7.5 ++ 语法</h3>\n<div><pre><code><span><span>treeMaker<span>.</span></span>Exec</span><span>(</span><span><span>treeMaker<span>.</span></span>Unary</span><span>(</span><span>JCTree<span>.</span>Tag</span><span>.</span>PREINC<span>,</span><span><span>treeMaker<span>.</span></span>Ident</span><span>(</span>names<span>.</span><span>fromString</span><span>(</span><span>\"i\"</span><span>)</span><span>)</span><span>)</span><span>)</span>\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"_2-7-6-if语句\"> 2.7.6 If语句</h3>\n<div><pre><code><span>/*\n    创建一个if语句\n    if(\"BuXueWuShu\".equals(name)){\n        add = \"a\" + \"b\";\n    }else{\n        add += \"test\";\n    }\n */</span>\n<span>// \"BuXueWuShu\".equals(name)</span>\n<span>JCTree<span>.</span>JCMethodInvocation</span> apply <span>=</span> <span><span>treeMaker<span>.</span></span>Apply</span><span>(</span>\n        <span><span>com<span>.</span>sun<span>.</span>tools<span>.</span>javac<span>.</span>util<span>.</span></span>List</span><span>.</span><span>nil</span><span>(</span><span>)</span><span>,</span>\n        <span><span>treeMaker<span>.</span></span>Select</span><span>(</span>\n                <span><span>treeMaker<span>.</span></span>Literal</span><span>(</span><span>\"BuXueWuShu\"</span><span>)</span><span>,</span> <span>// . 左边的内容</span>\n                names<span>.</span><span>fromString</span><span>(</span><span>\"equals\"</span><span>)</span> <span>// . 右边的内容</span>\n        <span>)</span><span>,</span>\n        <span><span>com<span>.</span>sun<span>.</span>tools<span>.</span>javac<span>.</span>util<span>.</span></span>List</span><span>.</span><span>of</span><span>(</span><span><span>treeMaker<span>.</span></span>Ident</span><span>(</span>names<span>.</span><span>fromString</span><span>(</span><span>\"name\"</span><span>)</span><span>)</span><span>)</span>\n<span>)</span><span>;</span>\n<span>//  add = \"a\" + \"b\"</span>\n<span>JCTree<span>.</span>JCExpressionStatement</span> exec3 <span>=</span> <span><span>treeMaker<span>.</span></span>Exec</span><span>(</span><span><span>treeMaker<span>.</span></span>Assign</span><span>(</span><span><span>treeMaker<span>.</span></span>Ident</span><span>(</span>names<span>.</span><span>fromString</span><span>(</span><span>\"add\"</span><span>)</span><span>)</span><span>,</span> <span><span>treeMaker<span>.</span></span>Binary</span><span>(</span><span>JCTree<span>.</span>Tag</span><span>.</span>PLUS<span>,</span> <span><span>treeMaker<span>.</span></span>Literal</span><span>(</span><span>\"a\"</span><span>)</span><span>,</span> <span><span>treeMaker<span>.</span></span>Literal</span><span>(</span><span>\"b\"</span><span>)</span><span>)</span><span>)</span><span>)</span><span>;</span>\n<span>//  add += \"test\"</span>\n<span>JCTree<span>.</span>JCExpressionStatement</span> exec1 <span>=</span> <span><span>treeMaker<span>.</span></span>Exec</span><span>(</span><span><span>treeMaker<span>.</span></span>Assignop</span><span>(</span><span>JCTree<span>.</span>Tag</span><span>.</span>PLUS_ASG<span>,</span> <span><span>treeMaker<span>.</span></span>Ident</span><span>(</span>names<span>.</span><span>fromString</span><span>(</span><span>\"add\"</span><span>)</span><span>)</span><span>,</span> <span><span>treeMaker<span>.</span></span>Literal</span><span>(</span><span>\"test\"</span><span>)</span><span>)</span><span>)</span><span>;</span>\n\n<span>JCTree<span>.</span>JCIf</span> anIf <span>=</span> <span><span>treeMaker<span>.</span></span>If</span><span>(</span>\n        apply<span>,</span> <span>// if语句里面的判断语句</span>\n        exec3<span>,</span> <span>// 条件成立的语句</span>\n        exec1  <span>// 条件不成立的语句</span>\n<span>)</span><span>;</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div>",
      "image": "https://img.springlearn.cn/blog/0d7181f253655683928c302f20fe7c1d.png",
      "date_published": "2022-09-04T13:51:11.000Z",
      "date_modified": "2022-09-24T09:40:46.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "案例分享",
      "url": "https://java.springlearn.cn/learn/test/%E6%A1%88%E4%BE%8B%E5%88%86%E4%BA%AB/",
      "id": "https://java.springlearn.cn/learn/test/%E6%A1%88%E4%BE%8B%E5%88%86%E4%BA%AB/",
      "content_html": "<h2 id=\"前言\"> 前言</h2>\n<div><p>单测覆盖率为应用质量指标化提供解决方案</p>\n<p><strong>一口吃不了一个胖子, 由于每个人的认识不一样,要想达到理想的状态,显然是不可能的。此章节主要从实践出发,一步一步带领我们完成一个有效的可复用的单元测试的编写。</strong></p>\n</div>\n<h2 id=\"一、目标\"> 一、目标</h2>\n<h3 id=\"_1-1-质量保障\"> 1.1 质量保障</h3>\n<p><strong>单测是保证项目质量的手段,而不是目的。</strong></p>\n<p>通过 <code>mvn test</code> 在每次编译时候，对代码进行测试。以到达可持续集成的目的。这里的关键是在每次服务发布的时候,首先要运行测试用例。\n只有这样,我们的单测用例才有价值,才能提前发现问题。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1621248108000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_1-2-打扫屋子\"> 1.2 打扫屋子</h3>\n<p>要解决前面的这个问题,就要求我们编写正确的测试用例。因为大多数项目目前的编译脚本都是,跳过单元测试的.\n<code>mvn -Dmaven.test.skip=true</code>, 之所以这样是因为大多数的单测都是为 <code>debug</code> 写的,一旦在编译的时候执行单测用例,\n就会编译不通过。所以要想达到可持续集成的目的, 就要先把阻塞应用的单元测试用例给移除。</p>\n<p>我们可以通过 <code>@Ignore</code> 来。 当然这不是说不允许你写debug的单测,而是要我们<Highlight color=\"#ffffff\" bg=\"#117eed\"> 遵守一个约定</Highlight>, 对那种debug的单测, 必须人工执行的单测\n我们要通过 <code>@Ignore</code> 来标记, 避免我们执行单测时候失败。</p>\n<h3 id=\"_1-3-发挥价值\"> 1.3 发挥价值</h3>\n<p>如果做到了 1.1 和 1.2 那么单测的价值有会真正体现出来了。但是这一切的一切的前提是我们要编写出正确的符合规范的单测用例。</p>\n<p><img src=\"https://i0.hdslb.com/bfs/article/7698c4b6720896ccd93fffc15257b79122fe06df.gif\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"二、真实案例分享\"> 二、真实案例分享</h2>\n<p>首先这里我们使用到的技术,其实再前面的技术框架中都有列举了,所以这里就不详细说明了。这里就分享几个测试用例。</p>\n<h3 id=\"_2-1-查询接口测试用例-难度-⭐️\"> 2.1 查询接口测试用例 难度:⭐️</h3>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1620982729000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>对于上图这种仅仅涉及到读的接口,是比较简单的。我们的验证点其实只有两个。</p>\n<ol>\n<li>web接口是否可以调用</li>\n<li>接口查询条件是否有效</li>\n</ol>\n<h4 id=\"_2-1-1-启动web服务器\"> 2.1.1 启动web服务器</h4>\n<p>随机web端口,执行单测的时候启动一个web容器,用来模拟Web接口测试。</p>\n<div><pre><code><span>@RunWith</span><span>(</span><span>SpringRunner</span><span>.</span><span>class</span><span>)</span>\n<span>@SpringBootTest</span><span>(</span>classes <span>=</span> <span>CenterProviderApplication</span><span>.</span><span>class</span><span>,</span>\n                webEnvironment <span>=</span> <span>SpringBootTest<span>.</span>WebEnvironment</span><span>.</span>RANDOM_PORT<span>)</span>\n<span>// 指定启动类</span>\n<span>public</span> <span>class</span> <span>BaseApplicationTest</span> <span>{</span>\n\n    <span>protected</span> <span>URL</span> base<span>;</span>\n\n    <span>@LocalServerPort</span>\n    <span>private</span> <span>int</span> port<span>;</span>\n\n    <span>@Before</span>\n    <span>public</span> <span>void</span> <span>setUp</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>this</span><span>.</span>base <span>=</span> <span>new</span> <span>URL</span><span>(</span><span>\"http://localhost:\"</span> <span>+</span> port <span>+</span> <span>\"/pms/\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h4 id=\"_2-1-2-编写接口\"> 2.1.2 编写接口</h4>\n<p>这里就验证了Web的请求,同时可以进度查询条件的校验。当然这里也可以加上返回值类型的校验</p>\n<div><pre><code><span>public</span> <span>class</span> <span>CommonControllerTest</span> <span>extends</span> <span>BaseApplicationTest</span> <span>{</span>\n\n    <span>@Resource</span>\n    <span>private</span> <span>CommonController</span> commonController<span>;</span>\n\n    <span>/**\n     * 使用测试工具进行web端测试\n     *\n     */</span>\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>goodsList</span><span>(</span><span>)</span> <span>{</span>\n        <span>GoodsListDTO</span> dto <span>=</span> <span>new</span> <span>GoodsListDTO</span><span>(</span><span>)</span><span>;</span>\n        dto<span>.</span><span>setSize</span><span>(</span><span>5L</span><span>)</span><span>;</span>\n        dto<span>.</span><span>setCurrent</span><span>(</span><span>1L</span><span>)</span><span>;</span>\n        <span>// 使用该方法允许数据Mock</span>\n        <span>JsonResult</span><span><span>&lt;</span><span>DiyPage</span><span>&lt;</span><span>PmsGoodsVO</span><span>></span><span>></span></span> result <span>=</span> <span>TestWebUtils</span><span>.</span><span>web</span><span>(</span><span>this</span><span>.</span>base<span>)</span><span>.</span><span>mockWhen</span><span>(</span>commonController<span>)</span><span>.</span><span>goodsList</span><span>(</span>dto<span>)</span><span>;</span>\n        <span>// 非空判断</span>\n        <span>Assert</span><span>.</span><span>assertNotNull</span><span>(</span>result<span>)</span><span>;</span>\n        <span>// 接口响应值判断</span>\n        <span>Assert</span><span>.</span><span>assertTrue</span><span>(</span>result<span>.</span><span>getMsg</span><span>(</span><span>)</span><span>,</span> result<span>.</span><span>isSuccess</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// 接口数据输出</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>TestConsole</span><span>.</span><span>color</span><span>(</span><span>\"执行结果:\"</span><span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>TestConsole</span><span>.</span><span>colors</span><span>(</span>result<span>,</span> <span>AnsiColor</span><span>.</span>BRIGHT_BLUE<span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p>看到这里我们能亲身感受到,对于纯粹读的接口测试用例是比较容易编写的。一个项目只用维护一次就好了,开发同学也不会每次都去维护这个用例。\n虽然这个用例简单,但是我们能在每次发布完成后自动化的去执行校验。能帮助我们提前发现问题。</p>\n<h3 id=\"_2-2-读写测试用例-难度-⭐️⭐️\"> 2.2 读写测试用例 难度:⭐️⭐️</h3>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1620988529000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>像这种读写操作,且涉及到对外部数据调用的接口。我们要使用Mockito技术,对外部对象进行代理,并制定其中的行为。\n如下图这个测试用例,看下如何编写测试用例。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1620989004000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>首先分析下涉及到的接口。</p>\n<ul>\n<li>saveArrivalOrder 这个接口里面是包含了内部的业务逻辑和外部的数据调用,包含了下面两个外部的接口依赖。</li>\n</ul>\n<ol>\n<li>noticeTransportNodeNote 在保存到货通知单的时候,通知库存增加商品的在途库存数量的</li>\n<li>syncPurchaseOrder      在保存到货通知单的时候,是通知仓储做到货准备的</li>\n</ol>\n<p>这个业务中我们只需要验证我们内部的逻辑即可,涉及到外部的调用只需要验证代码即可,并不真的需要仓库和库存系统做\n真实的业务处理。所以我们就要针对这两个方法做数据mock我们使用到的技术就是Mockito做对象行为的mock。如下案例。</p>\n<p>主要看注释,我们在调用接口的时候,先通过给外部接口最Mockito代理,然后指定动作的出入参数。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>NoticeOrderControllerTest</span> <span>extends</span> <span>BaseApplicationTest</span> <span>{</span>\n\n    <span>@Autowired</span>\n    <span>NoticeOrderController</span> controller<span>;</span>\n\n    <span>/**\n     * 接口穿插在po单创建的单侧里面\n     */</span>\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>saveArrivalOrder</span><span>(</span><span>)</span> <span>{</span>\n        <span>// 1. 构建保存单据的参数(从浏览器中复制数据)</span>\n        <span>String</span> saveOrderJson <span>=</span>  <span>\"{}\"</span>\n        <span>NoticeOrderDTO</span> noticeOrder <span>=</span> <span>TestConsole</span><span>.</span><span>toObject</span><span>(</span>saveOrderJson<span>,</span> <span>ArrivalNoticeOrderDTO</span><span>.</span><span>class</span><span>)</span><span>;</span>\n\n        <span>// 2. mock库存中心返回 - inventoryTransportClient.noticeTransportNodeNote</span>\n        <span>JsonResult</span><span><span>&lt;</span><span>Boolean</span><span>></span></span> noticeResult <span>=</span> <span>JsonResult</span><span>.</span><span>success</span><span>(</span><span>true</span><span>)</span><span>;</span>\n        <span>Mockito</span><span>.</span><span>doReturn</span><span>(</span>noticeResult<span>)</span><span>.</span><span>when</span><span>(</span>inventoryTransportClient<span>)</span><span>.</span><span>noticeTransportNodeNote</span><span>(</span><span>Mockito</span><span>.</span><span>any</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// 3. mock同步中控台 - bookingOrderPmsFeignClient.syncPurchaseOrder(bookingOrderDetailDTO)</span>\n        <span>JsonResult</span><span><span>&lt;</span><span>Object</span><span>></span></span> syncResult <span>=</span> <span>JsonResult</span><span>.</span><span>success</span><span>(</span><span>)</span><span>;</span>\n        <span>Mockito</span><span>.</span><span>doReturn</span><span>(</span>syncResult<span>)</span><span>.</span><span>when</span><span>(</span>bookingOrderPmsFeignClient<span>)</span><span>.</span><span>syncPurchaseOrder</span><span>(</span><span>Mockito</span><span>.</span><span>any</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\n        <span>// 4. 执行保存+提交(走网络请求,事务不会自动回滚,如果想自动回滚直接调用,controller.saveArrivalOrder(arrivalNoticeOrder))</span>\n        arrivalNoticeOrder<span>.</span><span>setStatus</span><span>(</span><span>1</span><span>)</span><span>;</span>\n        <span>JsonResult</span><span><span>&lt;</span><span>Long</span><span>></span></span> longJsonResult <span>=</span> <span>TestWebUtils</span><span>.</span><span>web</span><span>(</span><span>this</span><span>.</span>base<span>)</span><span>.</span><span>when</span><span>(</span><span>ArrivalNoticeOrderController</span><span>.</span><span>class</span><span>)</span>\n                <span>.</span><span>saveArrivalOrder</span><span>(</span>arrivalNoticeOrder<span>)</span><span>;</span>\n        <span>PmsAssert</span><span>.</span><span>assertSuccess</span><span>(</span>longJsonResult<span>)</span><span>;</span>\n\n        <span>// 5. 验证关闭(这里因为我要验证关闭接口,所以不要自动会馆)</span>\n        <span>Mockito</span><span>.</span><span>doReturn</span><span>(</span>syncResult<span>)</span><span>.</span><span>when</span><span>(</span>bookingOrderPmsFeignClient<span>)</span><span>.</span><span>cancelPurchaseOrder</span><span>(</span><span>Mockito</span><span>.</span><span>any</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>Mockito</span><span>.</span><span>doReturn</span><span>(</span>noticeResult<span>)</span><span>.</span><span>when</span><span>(</span>inventoryTransportClient<span>)</span><span>.</span><span>cancelTransportNode</span><span>(</span><span>Mockito</span><span>.</span><span>any</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\n        <span>JsonResult</span><span><span>&lt;</span><span>Void</span><span>></span></span> jsonResult <span>=</span> <span>TestWebUtils</span><span>.</span><span>web</span><span>(</span><span>this</span><span>.</span>base<span>)</span><span>.</span><span>when</span><span>(</span><span>ArrivalNoticeOrderController</span><span>.</span><span>class</span><span>)</span>\n                <span>.</span><span>closeOrder</span><span>(</span><span>(</span>longJsonResult<span>.</span><span>getData</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>\n        <span>PmsAssert</span><span>.</span><span>assertSuccess</span><span>(</span>jsonResult<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><p>这个案例,我们可以学会如何使用Mockito做外部接口的代理,整体难度也不是很大。</p>\n<h3 id=\"_2-3-读写接口-复杂接口-难度-⭐️⭐️⭐️⭐️\"> 2.3 读写接口(复杂接口) 难度:⭐️⭐️⭐️⭐️</h3>\n<p>针对项目中核心流程, 可能并不仅仅是一个接口，而是有依赖关系的多个接口。</p>\n<p>针对系统核心链路流程，我们是有必要维护些自动化流程的测试用例。然后对每个接口中的出入参数进行校验。**当做到这一步的时候\n其实我们在发布时候就会更加有底气。敢于去重构代码了。**因为在项目迭代发布的过程中，我们会先跑一边单测。只要单测流程能通过，说明这个核心链路的流程问题就不会太大。</p>\n<p>当然这里不是说一定没有问题, 而是有问题的几率变小了。如果说出现问题了,我们的自动化流程没有提前发现，那么说明这些场景,我们的单测流程没有覆盖到, 那么这个时候我们再补充我们的自动化流程。</p>\n<p><strong>注意这里的自动化流程，跟测试同学的自动化流程是有区别的。开发的自动化流程的测试目标是自身项目的代码，所以我们关于外部接口都是通过Mock来模拟的。而测试同学的\n自动化流程，都是走真实的系统调用。</strong></p>\n<h4 id=\"_2-3-1-业务说明\"> 2.3.1 业务说明</h4>\n<ol>\n<li>\n<p>创建一个包含一个商品的，草稿状态的临时采购单【验证保存接口】</p>\n</li>\n<li>\n<p>模拟用户对采购单的商品进行二次修改【验证修改逻辑接口】</p>\n</li>\n<li>\n<p>模拟对已经审核的采购单,添加不同类型货通知单【验证不同单据到货通知单的校验接口】</p>\n</li>\n<li>\n<p>对已经创建的到货通知单进行人工关闭【验证关闭】</p>\n</li>\n<li>\n<p>关闭所有到货通知单【验证关闭】</p>\n</li>\n<li>\n<p>关闭采购单【验证采购关闭】</p>\n</li>\n</ol>\n<p>做到业务流程闭环</p>\n<div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>tempPurchaseOrderSave</span><span>(</span><span>)</span> <span>{</span>\n        <span>String</span> saveOrderJson <span>=</span> <span>\"{\\\"poOrderItemList\\\":[{\\\"id\\\":null,\\\"goodsId\\\":\\\"1\\\",\\\"skuId\\\":\\\"1001062\\\",\\\"goodsName\\\":\\\"ABM品牌招商手册包11112\\\",\\\"englishName\\\":\\\"1\\\",\\\"goodsCode\\\":\\\"9314807022860\\\",\\\"brandCode\\\":\\\"brand230\\\",\\\"brandName\\\":\\\"34 西班牙\\\",\\\"specificationModel\\\":\\\"12ml/瓶\\\",\\\"wmsItemList\\\":[{\\\"purchaseNum\\\":null,\\\"warehouseName\\\":\\\"DHL\\\",\\\"warehouseCode\\\":0},{\\\"purchaseNum\\\":null,\\\"warehouseName\\\":\\\"PCA\\\",\\\"warehouseCode\\\":1},{\\\"purchaseNum\\\":null,\\\"warehouseName\\\":\\\"EWE\\\",\\\"warehouseCode\\\":2},{\\\"purchaseNum\\\":null,\\\"warehouseName\\\":\\\"新西兰仓\\\",\\\"warehouseCode\\\":3}],\\\"purchaseNum\\\":30,\\\"goodProductNum\\\":30,\\\"purchasePrice\\\":\\\"10\\\",\\\"expectDeliveryDate\\\":\\\"2021-05-12\\\",\\\"actualPurchaseNum\\\":null}],\\\"tradeCompanyIdList\\\":[\\\"13\\\"],\\\"supplierId\\\":\\\"347\\\",\\\"businessLineId\\\":\\\"1\\\",\\\"sameChainId\\\":49,\\\"title\\\":\\\"mevan test自动跑验证流程\\\",\\\"companyId\\\":null,\\\"channelCode\\\":\\\"ABM\\\",\\\"brandCode\\\":\\\"brand230\\\",\\\"purchaseBrandId\\\":\\\"1374262965415165953\\\",\\\"currencyCode\\\":\\\"AUD\\\",\\\"tradeType\\\":20,\\\"deliveryWarehouseId\\\":null,\\\"transferWarehouseId\\\":\\\"542\\\",\\\"salesWarehouseId\\\":\\\"9\\\",\\\"giveawayOrderSign\\\":1,\\\"ids\\\":\\\"\\\"}\"</span><span>;</span>\n        <span>PurchaseOrderDTO</span> purchaseOrderDTO <span>=</span> <span>TestConsole</span><span>.</span><span>toObject</span><span>(</span>saveOrderJson<span>,</span> <span>PurchaseOrderDTO</span><span>.</span><span>class</span><span>)</span><span>;</span>\n        purchaseOrderDTO<span>.</span><span>setTitle</span><span>(</span><span>\"mvn test(临时订单自动化流程验证)\"</span><span>)</span><span>;</span>\n        <span>List</span><span><span>&lt;</span><span>PurchaseOrderDetailDTO</span><span>></span></span> poOrderItemList <span>=</span> purchaseOrderDTO<span>.</span><span>getPoOrderItemList</span><span>(</span><span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>PurchaseOrderDetailDTO</span> purchaseOrderDetailDTO <span>:</span> poOrderItemList<span>)</span> <span>{</span>\n            <span>// 赠品刚开始设置成1</span>\n            purchaseOrderDetailDTO<span>.</span><span>setGiveawayNum</span><span>(</span><span>1</span><span>)</span><span>;</span>\n            purchaseOrderDetailDTO<span>.</span><span>setExpectDeliveryDate</span><span>(</span><span>JodaTimeUtils</span><span>.</span><span>addDay</span><span>(</span><span>new</span> <span>Date</span><span>(</span><span>)</span><span>,</span> <span>1</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>// 1. 执行保存</span>\n        <span>Long</span> purchaseOrderId <span>=</span> <span>createPurchaseOrder</span><span>(</span>purchaseOrderDTO<span>)</span><span>;</span>\n\n        <span>// 2. 然后修改下商品明细</span>\n        <span>List</span><span><span>&lt;</span><span>PurchaseOrderDetailDTO</span><span>></span></span> updateOrderDetailList <span>=</span> purchaseOrderDTO<span>.</span><span>getPoOrderItemList</span><span>(</span><span>)</span><span>;</span>\n        <span>EnhanceStream</span><span>.</span><span>findAny</span><span>(</span>updateOrderDetailList<span>)</span>\n                <span>.</span><span>ifPresent</span><span>(</span>order <span>-></span> <span>{</span>\n                    order<span>.</span><span>setGiveawayNum</span><span>(</span><span>0</span><span>)</span><span>;</span>\n                <span>}</span><span>)</span><span>;</span>\n        purchaseOrderDTO<span>.</span><span>setId</span><span>(</span>purchaseOrderId<span>)</span><span>;</span><span>//第二次要修改要orderType</span>\n        purchaseOrderDTO<span>.</span><span>setOrderType</span><span>(</span><span>PurchaseOrderTypeEnum</span><span>.</span>TEMPORARY_ORDER<span>.</span><span>getKey</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>updatePurchaseOrder</span><span>(</span>purchaseOrderDTO<span>)</span><span>;</span>\n\n        <span>PurchaseOrderDTO</span> audit <span>=</span> <span>new</span> <span>PurchaseOrderDTO</span><span>(</span><span>)</span><span>;</span>\n        audit<span>.</span><span>setId</span><span>(</span>purchaseOrderId<span>)</span><span>;</span>\n        audit<span>.</span><span>setSameChainId</span><span>(</span>purchaseOrderDTO<span>.</span><span>getSameChainId</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        audit<span>.</span><span>setTradeCompanyIdList</span><span>(</span><span>(</span>purchaseOrderDTO<span>.</span><span>getTradeCompanyIdList</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>\n        audit<span>.</span><span>setSupplierId</span><span>(</span>purchaseOrderDTO<span>.</span><span>getSupplierId</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        audit<span>.</span><span>setCompanyId</span><span>(</span>purchaseOrderDTO<span>.</span><span>getCompanyId</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\n        <span>// 2. 执行审核</span>\n        <span>JsonResult</span><span><span>&lt;</span><span>Void</span><span>></span></span> auditJson <span>=</span> <span>TestWebUtils</span><span>.</span><span>web</span><span>(</span><span>this</span><span>.</span>base<span>)</span><span>.</span><span>when</span><span>(</span><span>PurchaseOrderController</span><span>.</span><span>class</span><span>)</span><span>.</span><span>audit</span><span>(</span>audit<span>)</span><span>;</span>\n        <span>PmsAssert</span><span>.</span><span>assertSuccess</span><span>(</span>auditJson<span>)</span><span>;</span>\n\n        <span>// 3. 订单查询</span>\n        <span>PurchaseOrderVO</span> purchaseOrderDetail <span>=</span> <span>queryPurchaseOrderDetail</span><span>(</span>purchaseOrderId<span>)</span><span>;</span>\n\n        <span>// 3.1 对po单主单里面的必填值</span>\n        <span>assertPo</span><span>(</span>purchaseOrderDetail<span>,</span> <span>false</span><span>,</span> purchaseOrderDetail<span>)</span><span>;</span>\n\n        <span>// 4. 生成三笔到货通知单,然后关闭</span>\n        <span>createArrivalOrderAndClose</span><span>(</span>purchaseOrderId<span>)</span><span>;</span>\n\n        <span>// 5. PO订单手动关闭</span>\n        <span>closePurchaseOrder</span><span>(</span>purchaseOrderId<span>,</span> <span>\"maven test 自动化脚本\"</span><span>)</span><span>;</span>\n\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br></div></div><p>当执行完上面的单测用例,就完成了采购核心链路的自动化流程,就会生成下面单据。</p>\n<p>采购单</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1621232807000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>到货通知单</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1621232854000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"三、可复用能力\"> 三、可复用能力</h2>\n<p>通过2我们知道如何使用Mockito做对象行为的mock。还有一个点要思考的,这里单独拿出来说。就是测试用例的可复用行。什么叫可复用性呢?\n就是说你这个单侧用例,在每次代码提交和编译时候执行，是否会有问题。如果是,且只能运行一次,那么这个就是不合格的。要做到可复用还要考虑两个地方。</p>\n<h3 id=\"_3-1-接口参数动态生成\"> 3.1 接口参数动态生成</h3>\n<p>为什么要动态生成呢? 因为比如我们指定了一个id去作为查询条件,那么当我们这个id被删除的时候,这个测试用例一定是失败的。\n这种场景下我们就应该动态去查询一个。如下，我们查询采购单的全链路数据。那么首先我先查询所有的有效的采购单,然后拿出任意一条\n作为测试用例的查询条件即可。</p>\n<div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>queryFullLinkData</span><span>(</span><span>)</span> <span>{</span>\n        <span>// 执行测试用例时候,动态获取一个采购单code</span>\n        <span>String</span> orderCode <span>=</span> testOrderUtils<span>.</span><span>purchaseOrderCode</span><span>(</span><span>)</span><span>;</span>\n        <span>TrackFullLinkDTO</span> trackFullLinkDTO <span>=</span> <span>new</span> <span>TrackFullLinkDTO</span><span>(</span><span>)</span><span>;</span>\n        trackFullLinkDTO<span>.</span><span>setCurrent</span><span>(</span><span>1L</span><span>)</span><span>;</span>\n        trackFullLinkDTO<span>.</span><span>setSize</span><span>(</span><span>10L</span><span>)</span><span>;</span>\n        trackFullLinkDTO<span>.</span><span>setPurchaseOrderCode</span><span>(</span>orderCode<span>)</span><span>;</span>\n        <span>JsonResult</span><span><span>&lt;</span><span>TrackFullLinkVO</span><span>></span></span> fullLinkData <span>=</span> <span>TestWebUtils</span><span>.</span><span>web</span><span>(</span><span>this</span><span>.</span>base<span>)</span><span>.</span><span>when</span><span>(</span><span>PurchaseOrderController</span><span>.</span><span>class</span><span>)</span><span>.</span><span>queryFullLinkData</span><span>(</span>trackFullLinkDTO<span>)</span><span>;</span>\n        <span>PmsAssert</span><span>.</span><span>assertSuccess</span><span>(</span>fullLinkData<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>上面这个用例只用声明一个测试的bean对象即可。在我们的 <code>src/test/java</code>包中。</p>\n<p>TestComponent</p>\n<div><pre><code><span>@TestComponent</span>\n<span>public</span> <span>class</span> <span>TestOrderUtils</span> <span>{</span>\n\n    <span>@Resource</span>\n    <span>private</span> <span>ArrivalNoticeOrderController</span> arrivalNoticeOrderController<span>;</span>\n\n    <span>public</span> <span>String</span> <span>purchaseOrderCode</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>purchaseOrder</span><span>(</span><span>)</span><span>.</span><span>getOrderCode</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"_3-2-业务流程要闭环\"> 3.2 业务流程要闭环</h3>\n<ol>\n<li>要么数据执行完成自动回滚</li>\n<li>要么数据不回滚,但是业务流程要闭环。</li>\n</ol>\n",
      "image": "https://img.springlearn.cn/blog/learn_1621248108000.png",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "monitor/watch/trace相关",
      "url": "https://java.springlearn.cn/learn/tools/arthas/watch-cli/",
      "id": "https://java.springlearn.cn/learn/tools/arthas/watch-cli/",
      "content_html": "<h2 id=\"一、启动arthas\"> 一、启动Arthas</h2>\n<div><pre><code>curl -O https://arthas.aliyun.com/arthas-boot.jar\njava -jar arthas-boot.jar\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>启动命令 <code>java -jar arthas-boot.jar</code></p>\n<h2 id=\"二、选择进程\"> 二、选择进程</h2>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1647178107000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>直接选择我们要监控的进程，输入3进入</p>\n<div><pre><code>[INFO] Attach process 28667 success.\n[INFO] arthas-client connect 127.0.0.1 3658\n  ,---.  ,------. ,--------.,--.  ,--.  ,---.   ,---.                           \n /  O  \\ |  .--. &#39;&#39;--.  .--&#39;|  &#39;--&#39;  | /  O  \\ &#39;   .-&#39;                          \n|  .-.  ||  &#39;--&#39;.&#39;   |  |   |  .--.  ||  .-.  |`.  `-.                          \n|  | |  ||  |\\  \\    |  |   |  |  |  ||  | |  |.-&#39;    |                         \n`--&#39; `--&#39;`--&#39; &#39;--&#39;   `--&#39;   `--&#39;  `--&#39;`--&#39; `--&#39;`-----&#39;                          \n\nwiki       https://arthas.aliyun.com/doc                                        \ntutorials  https://arthas.aliyun.com/doc/arthas-tutorials.html                  \nversion    3.5.6                                                                \nmain_class com.example.demo.DemoApplication                                     \npid        28667                                                                \ntime       2022-03-13 21:31:04   \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>提示已经连接上进程。</p>\n<h2 id=\"三、基础信息查询命令\"> 三、基础信息查询命令</h2>\n<h3 id=\"_3-1-dashboard-看板命令\"> 3.1 dashboard 看板命令</h3>\n<p>输入 <code>dashboard</code></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1647178404000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>会定时将应用信息输出到控制台上。</p>\n<h3 id=\"_3-2-jad-反向编译\"> 3.2 jad 反向编译</h3>\n<p><code>jad com.example.demo.DemoApplication</code></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1647178673000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_3-3-watch-监控指令\"> 3.3 watch 监控指令</h3>\n<p>这个命令是比较常用的命令,可以用来分析系统性能。</p>\n<div><pre><code><span>package</span> <span>com<span>.</span>example<span>.</span>demo</span><span>;</span>\n\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>web<span>.</span>bind<span>.</span>annotation<span>.</span></span><span>GetMapping</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>web<span>.</span>bind<span>.</span>annotation<span>.</span></span><span>ResponseBody</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>web<span>.</span>bind<span>.</span>annotation<span>.</span></span><span>RestController</span><span>;</span>\n<span>@RestController</span>\n<span>public</span> <span>class</span> <span>WebController</span> <span>{</span>\n\n    <span>@GetMapping</span><span>(</span><span>\"/get\"</span><span>)</span>\n    <span>@ResponseBody</span>\n    <span>public</span> <span>String</span> <span>get</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>\n        <span>return</span> name<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>监控这个类 <code>watch com.example.demo.WebController get returnObj</code></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数名</th>\n<th style=\"text-align:center\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">returnObj</td>\n<td style=\"text-align:center\">返回值</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">params</td>\n<td style=\"text-align:center\">入参</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">target</td>\n<td style=\"text-align:center\">方法调用方</td>\n</tr>\n</tbody>\n</table>\n<p><code>watch com.example.demo.WebController get {params,returnObj,target}</code></p>\n<div><pre><code>[arthas@32818]$ watch com.example.demo.WebController get returnObj\nPress Q or Ctrl+C to abort.\nAffect(class count: 1 , method count: 1) cost in 120 ms, listenerId: 1\nmethod=com.example.demo.WebController.get location=AtExit\nts=2022-03-13 21:41:56; [cost=1.317166ms] result=@String[123]\nmethod=com.example.demo.WebController.get location=AtExit\nts=2022-03-13 21:42:03; [cost=0.051875ms] result=@String[测试]\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h1 id=\"四、退出\"> 四、退出</h1>\n<p>输入 <code>q</code></p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1647178107000.png",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "class/classloader相关",
      "url": "https://java.springlearn.cn/learn/tools/arthas/class-cli/",
      "id": "https://java.springlearn.cn/learn/tools/arthas/class-cli/",
      "content_html": "<h2 id=\"一、启动arthas\"> 一、启动Arthas</h2>\n<div><pre><code>curl -O https://arthas.aliyun.com/arthas-boot.jar\njava -jar arthas-boot.jar\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>启动命令 <code>java -jar arthas-boot.jar</code></p>\n<h2 id=\"二、选择进程\"> 二、选择进程</h2>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1647178107000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>直接选择我们要监控的进程，输入3进入</p>\n<div><pre><code>[INFO] Attach process 28667 success.\n[INFO] arthas-client connect 127.0.0.1 3658\n  ,---.  ,------. ,--------.,--.  ,--.  ,---.   ,---.                           \n /  O  \\ |  .--. &#39;&#39;--.  .--&#39;|  &#39;--&#39;  | /  O  \\ &#39;   .-&#39;                          \n|  .-.  ||  &#39;--&#39;.&#39;   |  |   |  .--.  ||  .-.  |`.  `-.                          \n|  | |  ||  |\\  \\    |  |   |  |  |  ||  | |  |.-&#39;    |                         \n`--&#39; `--&#39;`--&#39; &#39;--&#39;   `--&#39;   `--&#39;  `--&#39;`--&#39; `--&#39;`-----&#39;                          \n\nwiki       https://arthas.aliyun.com/doc                                        \ntutorials  https://arthas.aliyun.com/doc/arthas-tutorials.html                  \nversion    3.5.6                                                                \nmain_class com.example.demo.DemoApplication                                     \npid        28667                                                                \ntime       2022-03-13 21:31:04   \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>提示已经连接上进程。</p>\n<h2 id=\"三、基础信息查询命令\"> 三、基础信息查询命令</h2>\n<h3 id=\"_3-1-dashboard-看板命令\"> 3.1 dashboard 看板命令</h3>\n<p>输入 <code>dashboard</code></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1647178404000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>会定时将应用信息输出到控制台上。</p>\n<h3 id=\"_3-2-jad-反向编译\"> 3.2 jad 反向编译</h3>\n<p><code>jad com.example.demo.DemoApplication</code></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1647178673000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_3-3-watch-监控指令\"> 3.3 watch 监控指令</h3>\n<p>这个命令是比较常用的命令,可以用来分析系统性能。</p>\n<div><pre><code><span>package</span> <span>com<span>.</span>example<span>.</span>demo</span><span>;</span>\n\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>web<span>.</span>bind<span>.</span>annotation<span>.</span></span><span>GetMapping</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>web<span>.</span>bind<span>.</span>annotation<span>.</span></span><span>ResponseBody</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>web<span>.</span>bind<span>.</span>annotation<span>.</span></span><span>RestController</span><span>;</span>\n<span>@RestController</span>\n<span>public</span> <span>class</span> <span>WebController</span> <span>{</span>\n\n    <span>@GetMapping</span><span>(</span><span>\"/get\"</span><span>)</span>\n    <span>@ResponseBody</span>\n    <span>public</span> <span>String</span> <span>get</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>\n        <span>return</span> name<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>监控这个类 <code>watch com.example.demo.WebController get returnObj</code></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数名</th>\n<th style=\"text-align:center\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">returnObj</td>\n<td style=\"text-align:center\">返回值</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">params</td>\n<td style=\"text-align:center\">入参</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">target</td>\n<td style=\"text-align:center\">方法调用方</td>\n</tr>\n</tbody>\n</table>\n<p><code>watch com.example.demo.WebController get {params,returnObj,target}</code></p>\n<div><pre><code>[arthas@32818]$ watch com.example.demo.WebController get returnObj\nPress Q or Ctrl+C to abort.\nAffect(class count: 1 , method count: 1) cost in 120 ms, listenerId: 1\nmethod=com.example.demo.WebController.get location=AtExit\nts=2022-03-13 21:41:56; [cost=1.317166ms] result=@String[123]\nmethod=com.example.demo.WebController.get location=AtExit\nts=2022-03-13 21:42:03; [cost=0.051875ms] result=@String[测试]\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h1 id=\"四、退出\"> 四、退出</h1>\n<p>输入 <code>q</code></p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1647178107000.png",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "基础命令",
      "url": "https://java.springlearn.cn/learn/tools/arthas/base-cli/",
      "id": "https://java.springlearn.cn/learn/tools/arthas/base-cli/",
      "content_html": "<h2 id=\"一、启动arthas\"> 一、启动Arthas</h2>\n<div><pre><code>curl -O https://arthas.aliyun.com/arthas-boot.jar\njava -jar arthas-boot.jar\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>启动命令 <code>java -jar arthas-boot.jar</code></p>\n<h2 id=\"二、选择进程\"> 二、选择进程</h2>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1647178107000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>直接选择我们要监控的进程，输入3进入</p>\n<div><pre><code>[INFO] Attach process 28667 success.\n[INFO] arthas-client connect 127.0.0.1 3658\n  ,---.  ,------. ,--------.,--.  ,--.  ,---.   ,---.                           \n /  O  \\ |  .--. &#39;&#39;--.  .--&#39;|  &#39;--&#39;  | /  O  \\ &#39;   .-&#39;                          \n|  .-.  ||  &#39;--&#39;.&#39;   |  |   |  .--.  ||  .-.  |`.  `-.                          \n|  | |  ||  |\\  \\    |  |   |  |  |  ||  | |  |.-&#39;    |                         \n`--&#39; `--&#39;`--&#39; &#39;--&#39;   `--&#39;   `--&#39;  `--&#39;`--&#39; `--&#39;`-----&#39;                          \n\nwiki       https://arthas.aliyun.com/doc                                        \ntutorials  https://arthas.aliyun.com/doc/arthas-tutorials.html                  \nversion    3.5.6                                                                \nmain_class com.example.demo.DemoApplication                                     \npid        28667                                                                \ntime       2022-03-13 21:31:04   \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>提示已经连接上进程。</p>\n<h2 id=\"三、基础信息查询命令\"> 三、基础信息查询命令</h2>\n<h3 id=\"_3-1-dashboard-看板命令\"> 3.1 dashboard 看板命令</h3>\n<p>输入 <code>dashboard</code></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1647178404000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>会定时将应用信息输出到控制台上。</p>\n<h3 id=\"_3-2-jad-反向编译\"> 3.2 jad 反向编译</h3>\n<p><code>jad com.example.demo.DemoApplication</code></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1647178673000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_3-3-watch-监控指令\"> 3.3 watch 监控指令</h3>\n<p>这个命令是比较常用的命令,可以用来分析系统性能。</p>\n<div><pre><code><span>package</span> <span>com<span>.</span>example<span>.</span>demo</span><span>;</span>\n\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>web<span>.</span>bind<span>.</span>annotation<span>.</span></span><span>GetMapping</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>web<span>.</span>bind<span>.</span>annotation<span>.</span></span><span>ResponseBody</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>web<span>.</span>bind<span>.</span>annotation<span>.</span></span><span>RestController</span><span>;</span>\n<span>@RestController</span>\n<span>public</span> <span>class</span> <span>WebController</span> <span>{</span>\n\n    <span>@GetMapping</span><span>(</span><span>\"/get\"</span><span>)</span>\n    <span>@ResponseBody</span>\n    <span>public</span> <span>String</span> <span>get</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>\n        <span>return</span> name<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>监控这个类 <code>watch com.example.demo.WebController get returnObj</code></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数名</th>\n<th style=\"text-align:center\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">returnObj</td>\n<td style=\"text-align:center\">返回值</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">params</td>\n<td style=\"text-align:center\">入参</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">target</td>\n<td style=\"text-align:center\">方法调用方</td>\n</tr>\n</tbody>\n</table>\n<p><code>watch com.example.demo.WebController get {params,returnObj,target}</code></p>\n<div><pre><code>[arthas@32818]$ watch com.example.demo.WebController get returnObj\nPress Q or Ctrl+C to abort.\nAffect(class count: 1 , method count: 1) cost in 120 ms, listenerId: 1\nmethod=com.example.demo.WebController.get location=AtExit\nts=2022-03-13 21:41:56; [cost=1.317166ms] result=@String[123]\nmethod=com.example.demo.WebController.get location=AtExit\nts=2022-03-13 21:42:03; [cost=0.051875ms] result=@String[测试]\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h1 id=\"四、退出\"> 四、退出</h1>\n<p>输入 <code>q</code></p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1647178107000.png",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "基础教程",
      "url": "https://java.springlearn.cn/learn/tools/arthas/learn/",
      "id": "https://java.springlearn.cn/learn/tools/arthas/learn/",
      "content_html": "<h2 id=\"一、启动arthas\"> 一、启动Arthas</h2>\n<div><pre><code>curl -O https://arthas.aliyun.com/arthas-boot.jar\njava -jar arthas-boot.jar\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>启动命令 <code>java -jar arthas-boot.jar</code></p>\n<h2 id=\"二、选择进程\"> 二、选择进程</h2>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1647178107000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>直接选择我们要监控的进程，输入3进入</p>\n<div><pre><code>[INFO] Attach process 28667 success.\n[INFO] arthas-client connect 127.0.0.1 3658\n  ,---.  ,------. ,--------.,--.  ,--.  ,---.   ,---.                           \n /  O  \\ |  .--. &#39;&#39;--.  .--&#39;|  &#39;--&#39;  | /  O  \\ &#39;   .-&#39;                          \n|  .-.  ||  &#39;--&#39;.&#39;   |  |   |  .--.  ||  .-.  |`.  `-.                          \n|  | |  ||  |\\  \\    |  |   |  |  |  ||  | |  |.-&#39;    |                         \n`--&#39; `--&#39;`--&#39; &#39;--&#39;   `--&#39;   `--&#39;  `--&#39;`--&#39; `--&#39;`-----&#39;                          \n\nwiki       https://arthas.aliyun.com/doc                                        \ntutorials  https://arthas.aliyun.com/doc/arthas-tutorials.html                  \nversion    3.5.6                                                                \nmain_class com.example.demo.DemoApplication                                     \npid        28667                                                                \ntime       2022-03-13 21:31:04   \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>提示已经连接上进程。</p>\n<h2 id=\"三、基础信息查询命令\"> 三、基础信息查询命令</h2>\n<h3 id=\"_3-1-dashboard-看板命令\"> 3.1 dashboard 看板命令</h3>\n<p>输入 <code>dashboard</code></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1647178404000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>会定时将应用信息输出到控制台上。</p>\n<h3 id=\"_3-2-jad-反向编译\"> 3.2 jad 反向编译</h3>\n<p><code>jad com.example.demo.DemoApplication</code></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1647178673000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_3-3-watch-监控指令\"> 3.3 watch 监控指令</h3>\n<p>这个命令是比较常用的命令,可以用来分析系统性能。</p>\n<div><pre><code><span>package</span> <span>com<span>.</span>example<span>.</span>demo</span><span>;</span>\n\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>web<span>.</span>bind<span>.</span>annotation<span>.</span></span><span>GetMapping</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>web<span>.</span>bind<span>.</span>annotation<span>.</span></span><span>ResponseBody</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>web<span>.</span>bind<span>.</span>annotation<span>.</span></span><span>RestController</span><span>;</span>\n<span>@RestController</span>\n<span>public</span> <span>class</span> <span>WebController</span> <span>{</span>\n\n    <span>@GetMapping</span><span>(</span><span>\"/get\"</span><span>)</span>\n    <span>@ResponseBody</span>\n    <span>public</span> <span>String</span> <span>get</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>\n        <span>return</span> name<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>监控这个类 <code>watch com.example.demo.WebController get returnObj</code></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数名</th>\n<th style=\"text-align:center\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">returnObj</td>\n<td style=\"text-align:center\">返回值</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">params</td>\n<td style=\"text-align:center\">入参</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">target</td>\n<td style=\"text-align:center\">方法调用方</td>\n</tr>\n</tbody>\n</table>\n<p><code>watch com.example.demo.WebController get {params,returnObj,target}</code></p>\n<div><pre><code>[arthas@32818]$ watch com.example.demo.WebController get returnObj\nPress Q or Ctrl+C to abort.\nAffect(class count: 1 , method count: 1) cost in 120 ms, listenerId: 1\nmethod=com.example.demo.WebController.get location=AtExit\nts=2022-03-13 21:41:56; [cost=1.317166ms] result=@String[123]\nmethod=com.example.demo.WebController.get location=AtExit\nts=2022-03-13 21:42:03; [cost=0.051875ms] result=@String[测试]\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h1 id=\"四、退出\"> 四、退出</h1>\n<p>输入 <code>q</code></p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1647178107000.png",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "JVM相关命令",
      "url": "https://java.springlearn.cn/learn/tools/arthas/jvm-cli/",
      "id": "https://java.springlearn.cn/learn/tools/arthas/jvm-cli/",
      "content_html": "<h2 id=\"一、启动arthas\"> 一、启动Arthas</h2>\n<div><pre><code>curl -O https://arthas.aliyun.com/arthas-boot.jar\njava -jar arthas-boot.jar\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>启动命令 <code>java -jar arthas-boot.jar</code></p>\n<h2 id=\"二、选择进程\"> 二、选择进程</h2>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1647178107000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>直接选择我们要监控的进程，输入3进入</p>\n<div><pre><code>[INFO] Attach process 28667 success.\n[INFO] arthas-client connect 127.0.0.1 3658\n  ,---.  ,------. ,--------.,--.  ,--.  ,---.   ,---.                           \n /  O  \\ |  .--. &#39;&#39;--.  .--&#39;|  &#39;--&#39;  | /  O  \\ &#39;   .-&#39;                          \n|  .-.  ||  &#39;--&#39;.&#39;   |  |   |  .--.  ||  .-.  |`.  `-.                          \n|  | |  ||  |\\  \\    |  |   |  |  |  ||  | |  |.-&#39;    |                         \n`--&#39; `--&#39;`--&#39; &#39;--&#39;   `--&#39;   `--&#39;  `--&#39;`--&#39; `--&#39;`-----&#39;                          \n\nwiki       https://arthas.aliyun.com/doc                                        \ntutorials  https://arthas.aliyun.com/doc/arthas-tutorials.html                  \nversion    3.5.6                                                                \nmain_class com.example.demo.DemoApplication                                     \npid        28667                                                                \ntime       2022-03-13 21:31:04   \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>提示已经连接上进程。</p>\n<h2 id=\"三、基础信息查询命令\"> 三、基础信息查询命令</h2>\n<h3 id=\"_3-1-dashboard-看板命令\"> 3.1 dashboard 看板命令</h3>\n<p>输入 <code>dashboard</code></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1647178404000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>会定时将应用信息输出到控制台上。</p>\n<h3 id=\"_3-2-jad-反向编译\"> 3.2 jad 反向编译</h3>\n<p><code>jad com.example.demo.DemoApplication</code></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1647178673000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_3-3-watch-监控指令\"> 3.3 watch 监控指令</h3>\n<p>这个命令是比较常用的命令,可以用来分析系统性能。</p>\n<div><pre><code><span>package</span> <span>com<span>.</span>example<span>.</span>demo</span><span>;</span>\n\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>web<span>.</span>bind<span>.</span>annotation<span>.</span></span><span>GetMapping</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>web<span>.</span>bind<span>.</span>annotation<span>.</span></span><span>ResponseBody</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>web<span>.</span>bind<span>.</span>annotation<span>.</span></span><span>RestController</span><span>;</span>\n<span>@RestController</span>\n<span>public</span> <span>class</span> <span>WebController</span> <span>{</span>\n\n    <span>@GetMapping</span><span>(</span><span>\"/get\"</span><span>)</span>\n    <span>@ResponseBody</span>\n    <span>public</span> <span>String</span> <span>get</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>\n        <span>return</span> name<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>监控这个类 <code>watch com.example.demo.WebController get returnObj</code></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数名</th>\n<th style=\"text-align:center\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">returnObj</td>\n<td style=\"text-align:center\">返回值</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">params</td>\n<td style=\"text-align:center\">入参</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">target</td>\n<td style=\"text-align:center\">方法调用方</td>\n</tr>\n</tbody>\n</table>\n<p><code>watch com.example.demo.WebController get {params,returnObj,target}</code></p>\n<div><pre><code>[arthas@32818]$ watch com.example.demo.WebController get returnObj\nPress Q or Ctrl+C to abort.\nAffect(class count: 1 , method count: 1) cost in 120 ms, listenerId: 1\nmethod=com.example.demo.WebController.get location=AtExit\nts=2022-03-13 21:41:56; [cost=1.317166ms] result=@String[123]\nmethod=com.example.demo.WebController.get location=AtExit\nts=2022-03-13 21:42:03; [cost=0.051875ms] result=@String[测试]\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h1 id=\"四、退出\"> 四、退出</h1>\n<p>输入 <code>q</code></p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1647178107000.png",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Javassist",
      "url": "https://java.springlearn.cn/learn/tools/bytecode/Javassist/",
      "id": "https://java.springlearn.cn/learn/tools/bytecode/Javassist/",
      "content_html": "<div><p>Javassist</p>\n<p>Javassist是一个开源的分析、编辑和创建Java字节码的类库，可以直接编辑和生成Java生成的字节码。\n相对于bcel, asm等这些工具，开发者不需要了解虚拟机指令，就能动态改变类的结构，或者动态生成类。javassist简单易用， 快速。</p>\n</div>\n<p><a href=\"https://github.com/lxchinesszz/bytecode-example\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://img.shields.io/badge/字节码编程-bytecode--example-green\" alt=\"\" loading=\"lazy\"></a></p>\n<h2 id=\"一、核心工具类\"> 一、核心工具类</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">核心类</th>\n<th style=\"text-align:left\">解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ClassPool</td>\n<td style=\"text-align:left\">javassist的类池，使用ClassPool 类可以跟踪和控制所操作的类，它的工作方式与 JVM 类装载器非常相似</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CtClass</td>\n<td style=\"text-align:left\">CtClass提供了类的操作，如在类中动态添加新字段、方法和构造函数、以及改变类、父类和接口的方法。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CtField</td>\n<td style=\"text-align:left\">类的属性，通过它可以给类创建新的属性，还可以修改已有的属性的类型，访问修饰符等</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CtMethod</td>\n<td style=\"text-align:left\">类中的方法，通过它可以给类创建新的方法，还可以修改返回类型，访问修饰符等， 甚至还可以修改方法体内容代码</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CtConstructor</td>\n<td style=\"text-align:left\">与CtMethod类似</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"二、api\"> 二、API</h2>\n<h3 id=\"_2-1-classpool\"> 2.1 ClassPool</h3>\n<div><pre><code>    <span>// 类库, jvm中所加载的class</span>\n \t<span>ClassPool</span> pool <span>=</span> <span>ClassPool</span><span>.</span><span>getDefault</span><span>(</span><span>)</span><span>;</span>\n\t<span>// 加载一个已知的类, 注：参数必须为全量类名</span>\n\t<span>CtClass</span> ctClass <span>=</span> pool<span>.</span><span>get</span><span>(</span><span>\"com.itheima.Student\"</span><span>)</span><span>;</span>\n\t<span>// 创建一个新的类, 类名必须为全量类名</span>\n\t<span>CtClass</span> tClass <span>=</span> pool<span>.</span><span>makeClass</span><span>(</span><span>\"com.itheima.Calculator\"</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id=\"_2-2-ctfield\"> 2.2 CtField</h3>\n<div><pre><code>\t<span>// 获取已知类的属性</span>\n\t<span>CtField</span> ctField <span>=</span> ctClass<span>.</span><span>getDeclaredField</span><span>(</span><span>\"name\"</span><span>)</span><span>;</span>\n\t<span>// 构建新的类的成员变量</span>\n\t<span>CtField</span> ctFieldNew <span>=</span> <span>new</span> <span>CtField</span><span>(</span><span>CtClass</span><span>.</span>intType<span>,</span><span>\"age\"</span><span>,</span>ctClass<span>)</span><span>;</span>\n\t<span>// 设置类的访问修饰符为public</span>\n\tctFieldNew<span>.</span><span>setModifiers</span><span>(</span><span>Modifier</span><span>.</span>PUBLIC<span>)</span><span>;</span>\n\t<span>// 将属性添加到类中</span>\n\tctClass<span>.</span><span>addField</span><span>(</span>ctFieldNew<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id=\"_2-3-ctmethod\"> 2.3 CtMethod</h3>\n<div><pre><code>\t<span>// 获取已有方法</span>\n\t<span>//创建新的方法, 参数1:方法的返回类型，参数2：名称，参数3：方法的参数，参数4：方法所属的类</span>\n\t<span>CtMethod</span> ctMethod <span>=</span> <span>new</span> <span>CtMethod</span><span>(</span><span>CtClass</span><span>.</span>intType<span>,</span> <span>\"calc\"</span><span>,</span> <span>new</span> <span>CtClass</span><span>[</span><span>]</span>\n<span>{</span><span>CtClass</span><span>.</span>intType<span>,</span><span>CtClass</span><span>.</span>intType<span>}</span><span>,</span> tClass<span>)</span><span>;</span>\n\t<span>// 设置方法的访问修饰</span>\n\tctMethod<span>.</span><span>setModifiers</span><span>(</span><span>Modifier</span><span>.</span>PUBLIC<span>)</span><span>;</span>\n\t<span>// 将新建的方法添加到类中</span>\n\tctClass<span>.</span><span>addMethod</span><span>(</span>ctMethod<span>)</span><span>;</span>\n\t<span>// 方法体内容代码 $1代表第一个参数，$2代表第二个参数</span>\n\tctMethod<span>.</span><span>setBody</span><span>(</span><span>\"return $1 + $2;\"</span><span>)</span><span>;</span> \n\n\t<span>CtMethod</span> ctMethod <span>=</span> ctClass<span>.</span><span>getDeclaredMethod</span><span>(</span><span>\"sayHello\"</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id=\"_2-4-ctconstructor\"> 2.4 CtConstructor</h3>\n<div><pre><code>    <span>// 获取已有的构造方法, 参数为构建方法的参数类型数组</span>\n    <span>CtConstructor</span> ctConstructor <span>=</span> ctClass<span>.</span><span>getDeclaredConstructor</span><span>(</span><span>new</span> <span>CtClass</span><span>[</span><span>]</span><span>{</span><span>}</span><span>)</span><span>;</span>\n    <span>// 创建新的构造方法</span>\n    <span>CtConstructor</span> ctConstructor <span>=</span> <span>new</span> <span>CtConstructor</span><span>(</span><span>new</span> <span>CtClass</span><span>[</span><span>]</span><span>{</span><span>CtClass</span><span>.</span>intType<span>}</span><span>,</span>ctClass<span>)</span><span>;</span> ctConstructor<span>.</span><span>setModifiers</span><span>(</span><span>Modifier</span><span>.</span>PUBLIC<span>)</span><span>;</span>\n    ctConstructor<span>.</span><span>setBody</span><span>(</span><span>\"this.age = $1;\"</span><span>)</span><span>;</span>\n    ctClass<span>.</span><span>addConstructor</span><span>(</span>ctConstructor<span>)</span><span>;</span>\n    <span>// 也可直接创建</span>\n    ctConstructor <span>=</span> <span>CtNewConstructor</span><span>.</span><span>make</span><span>(</span><span>\"public Student(int age){this.age=age;}\"</span><span>,</span> ctClass<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id=\"三、示例\"> 三、示例</h2>\n<div><pre><code><span>public</span> <span>class</span> <span>User</span> <span>{</span>\n\n    <span>private</span> <span>String</span> name<span>;</span>\n\n    <span>public</span> <span>User</span><span>(</span><span>)</span> <span>{</span>\n    <span>}</span>\n\n    <span>public</span> <span>User</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>String</span> <span>sayJavassist</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>\"Hello Javassist\"</span><span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>\"User{\"</span> <span>+</span>\n                <span>\"name='\"</span> <span>+</span> name <span>+</span> <span>'\\''</span> <span>+</span>\n                <span>'}'</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h3 id=\"_3-1-修改方法\"> 3.1 修改方法</h3>\n<div><pre><code>        <span>// 类库池, jvm中所加载的class</span>\n        <span>ClassPool</span> pool <span>=</span> <span>ClassPool</span><span>.</span><span>getDefault</span><span>(</span><span>)</span><span>;</span>\n        <span>// 获取指定的Student类</span>\n        <span>CtClass</span> ctClass <span>=</span> pool<span>.</span><span>get</span><span>(</span><span>\"com.example.test.User\"</span><span>)</span><span>;</span>\n        <span>// 获取sayHello方法</span>\n        <span>CtMethod</span> ctMethod <span>=</span> ctClass<span>.</span><span>getDeclaredMethod</span><span>(</span><span>\"sayJavassist\"</span><span>)</span><span>;</span>\n        <span>// 在方法的代码后追加 一段代码</span>\n        ctMethod<span>.</span><span>insertAfter</span><span>(</span><span>\"System.out.println(\\\"I'm Javassist.\\\");\"</span><span>)</span><span>;</span>\n        <span>// 使用当前的ClassLoader加载被修改后的类</span>\n        <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> newClass <span>=</span> ctClass<span>.</span><span>toClass</span><span>(</span><span>)</span><span>;</span>\n        <span>User</span> user <span>=</span> <span>(</span><span>User</span><span>)</span> newClass<span>.</span><span>newInstance</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>user<span>.</span><span>sayJavassist</span><span>(</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id=\"_3-2-动态添加方法\"> 3.2 动态添加方法</h3>\n<div><pre><code>        <span>// 类库池, jvm中所加载的class</span>\n        <span>ClassPool</span> pool <span>=</span> <span>ClassPool</span><span>.</span><span>getDefault</span><span>(</span><span>)</span><span>;</span>\n        <span>// 获取指定的Student类</span>\n        <span>CtClass</span> ctClass <span>=</span> pool<span>.</span><span>get</span><span>(</span><span>\"com.example.test.User\"</span><span>)</span><span>;</span>\n        <span>// 增加方法</span>\n        <span>CtMethod</span> ctMethod <span>=</span> <span>new</span> <span>CtMethod</span><span>(</span><span>CtClass</span><span>.</span>intType<span>,</span> <span>\"getAgeSum\"</span><span>,</span>\n                <span>new</span> <span>CtClass</span><span>[</span><span>]</span><span>{</span><span>CtClass</span><span>.</span>intType<span>,</span> <span>CtClass</span><span>.</span>intType<span>}</span><span>,</span> ctClass<span>)</span><span>;</span>\n        <span>// 设置方法的访问修饰</span>\n        ctMethod<span>.</span><span>setModifiers</span><span>(</span><span>Modifier</span><span>.</span>PUBLIC<span>)</span><span>;</span>\n        <span>// 设置方法体代码</span>\n        ctMethod<span>.</span><span>setBody</span><span>(</span><span>\"return $1 + $2;\"</span><span>)</span><span>;</span>\n        <span>// 添加新建的方法到原有的类中</span>\n        ctClass<span>.</span><span>addMethod</span><span>(</span>ctMethod<span>)</span><span>;</span>\n        <span>// 加载修改后的类</span>\n        ctClass<span>.</span><span>toClass</span><span>(</span><span>)</span><span>;</span>\n        <span>// 创建对象</span>\n        <span>User</span> stu <span>=</span> <span>new</span> <span>User</span><span>(</span><span>)</span><span>;</span>\n        <span>// 获取calc方法</span>\n        <span>Method</span> dMethod <span>=</span> <span>User</span><span>.</span><span>class</span><span>.</span><span>getDeclaredMethod</span><span>(</span><span>\"getAgeSum\"</span><span>,</span> <span>new</span> <span>Class</span><span>[</span><span>]</span>\n                <span>{</span><span>int</span><span>.</span><span>class</span><span>,</span> <span>int</span><span>.</span><span>class</span><span>}</span><span>)</span><span>;</span>\n        <span>// 反射调用 方法</span>\n        <span>Object</span> result <span>=</span> dMethod<span>.</span><span>invoke</span><span>(</span>stu<span>,</span> <span>10</span><span>,</span> <span>20</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>result<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h3 id=\"_3-3-动态创建类\"> 3.3 动态创建类</h3>\n<div><pre><code>        <span>// 类库池, jvm中所加载的class</span>\n        <span>ClassPool</span> pool <span>=</span> <span>ClassPool</span><span>.</span><span>getDefault</span><span>(</span><span>)</span><span>;</span>\n        <span>// 创建一个学校类</span>\n        <span>CtClass</span> schoolClass <span>=</span> pool<span>.</span><span>makeClass</span><span>(</span><span>\"com.example.test.School\"</span><span>)</span><span>;</span>\n        <span>// 设置为公有类</span>\n        schoolClass<span>.</span><span>setModifiers</span><span>(</span><span>Modifier</span><span>.</span>PUBLIC<span>)</span><span>;</span>\n        <span>// 获取String类型</span>\n        <span>CtClass</span> stringClass <span>=</span> pool<span>.</span><span>get</span><span>(</span><span>\"java.lang.String\"</span><span>)</span><span>;</span>\n        <span>// 获取list类型</span>\n        <span>CtClass</span> listClass <span>=</span> pool<span>.</span><span>get</span><span>(</span><span>\"java.util.List\"</span><span>)</span><span>;</span>\n        <span>// 获取学生的类型</span>\n        <span>CtClass</span> userClass <span>=</span> pool<span>.</span><span>get</span><span>(</span><span>\"com.example.test.User\"</span><span>)</span><span>;</span>\n        <span>// 给学校添加一个校名属性</span>\n        <span>CtField</span> nameField <span>=</span> <span>new</span> <span>CtField</span><span>(</span>stringClass<span>,</span> <span>\"schoolName\"</span><span>,</span> schoolClass<span>)</span><span>;</span>\n        nameField<span>.</span><span>setModifiers</span><span>(</span><span>Modifier</span><span>.</span>PUBLIC<span>)</span><span>;</span>\n        schoolClass<span>.</span><span>addField</span><span>(</span>nameField<span>)</span><span>;</span>\n        <span>// 给学校添加一个学生集合</span>\n        <span>CtField</span> studentList <span>=</span> <span>new</span> <span>CtField</span><span>(</span>listClass<span>,</span> <span>\"users\"</span><span>,</span> schoolClass<span>)</span><span>;</span>\n        studentList<span>.</span><span>setModifiers</span><span>(</span><span>Modifier</span><span>.</span>PUBLIC<span>)</span><span>;</span>\n        schoolClass<span>.</span><span>addField</span><span>(</span>studentList<span>)</span><span>;</span>\n        <span>// 给学校一个空构造</span>\n        <span>CtConstructor</span> ctConstructor <span>=</span> <span>CtNewConstructor</span><span>.</span><span>make</span><span>(</span><span>\"public School() \"</span> <span>+</span>\n                <span>\"{this.schoolName=\\\"湖畔小学\\\";this.users = new java.util.ArrayList();}\"</span><span>,</span> schoolClass<span>)</span><span>;</span>\n        schoolClass<span>.</span><span>addConstructor</span><span>(</span>ctConstructor<span>)</span><span>;</span>\n\n        <span>// 给学校一个addUser的方法</span>\n        <span>CtMethod</span> m <span>=</span> <span>new</span> <span>CtMethod</span><span>(</span><span>CtClass</span><span>.</span>voidType<span>,</span> <span>\"addUser\"</span><span>,</span> <span>new</span> <span>CtClass</span><span>[</span><span>]</span><span>{</span>userClass<span>}</span><span>,</span> schoolClass<span>)</span><span>;</span>\n        m<span>.</span><span>setModifiers</span><span>(</span><span>Modifier</span><span>.</span>PUBLIC<span>)</span><span>;</span>\n        <span>// 添加学生对象到students属性中, $1代表参数1</span>\n        m<span>.</span><span>setBody</span><span>(</span><span>\"this.users.add($1);\"</span><span>)</span><span>;</span>\n        schoolClass<span>.</span><span>addMethod</span><span>(</span>m<span>)</span><span>;</span>\n\n        <span>// 给学校添加一个介绍的方法</span>\n        <span>CtMethod</span> introduce <span>=</span> <span>new</span> <span>CtMethod</span><span>(</span><span>CtClass</span><span>.</span>voidType<span>,</span> <span>\"introduce\"</span><span>,</span> <span>new</span> <span>CtClass</span><span>[</span><span>]</span><span>{</span><span>}</span><span>,</span> schoolClass<span>)</span><span>;</span>\n        introduce<span>.</span><span>setBody</span><span>(</span><span>\"System.out.println(\\\"The School name is \\\" + this.schoolName);\"</span><span>)</span><span>;</span>\n        introduce<span>.</span><span>insertAfter</span><span>(</span><span>\"System.out.println(this.users);\"</span><span>)</span><span>;</span>\n        schoolClass<span>.</span><span>addMethod</span><span>(</span>introduce<span>)</span><span>;</span>\n\n        <span>// 加载修改后的学校</span>\n        <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> schoolLoadClass <span>=</span> schoolClass<span>.</span><span>toClass</span><span>(</span><span>)</span><span>;</span>\n        <span>// 构建一个学校(空构造)</span>\n        <span>Object</span> school <span>=</span> schoolLoadClass<span>.</span><span>newInstance</span><span>(</span><span>)</span><span>;</span>\n        <span>// 获取添加用户方法</span>\n        <span>Method</span> addUserMethod <span>=</span> schoolLoadClass<span>.</span><span>getDeclaredMethod</span><span>(</span><span>\"addUser\"</span><span>,</span> userClass<span>.</span><span>toClass</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        addUserMethod<span>.</span><span>invoke</span><span>(</span>school<span>,</span> <span>new</span> <span>User</span><span>(</span><span>\"小明\"</span><span>)</span><span>)</span><span>;</span>\n        addUserMethod<span>.</span><span>invoke</span><span>(</span>school<span>,</span> <span>new</span> <span>User</span><span>(</span><span>\"小张\"</span><span>)</span><span>)</span><span>;</span>\n        <span>// 获取介绍方法，把刚才的信息给打印处理</span>\n        <span>Method</span> introduceMethod <span>=</span> school<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getDeclaredMethod</span><span>(</span><span>\"introduce\"</span><span>)</span><span>;</span>\n        introduceMethod<span>.</span><span>invoke</span><span>(</span>school<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br></div></div><div><pre><code>The School name is 湖畔小学\n[User{name=&#39;小明&#39;}, User{name=&#39;小张&#39;}]\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div>",
      "image": "https://img.shields.io/badge/%E5%AD%97%E8%8A%82%E7%A0%81%E7%BC%96%E7%A8%8B-bytecode--example-green",
      "date_published": "2022-03-24T17:05:50.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Disruptor高性能队列",
      "url": "https://java.springlearn.cn/learn/tools/disruptor/",
      "id": "https://java.springlearn.cn/learn/tools/disruptor/",
      "content_html": "<div><p>介绍</p>\n<p>Disruptor是英国外汇交易公司LMAX开发的一个高性能队列，研发的初衷是解决内存队列的延迟问题。与Kafka、RabbitMQ用于服务间的消息队列不同，disruptor一般用于线程间消息的传递。基于Disruptor开发的系统单线程能支撑每秒600万订单。</p>\n<p>disruptor适用于多个线程之间的消息队列，<code>作用与ArrayBlockingQueue有相似之处</code>，但是disruptor从功能、性能都远好于ArrayBlockingQueue，当多个线程之间传递大量数据或对性能要求较高时，可以考虑使用disruptor作为ArrayBlockingQueue的替代者。\n官方也对disruptor和ArrayBlockingQueue的性能在不同的应用场景下做了对比，目测性能只有有5~10倍左右的提升。</p>\n</div>\n<h2 id=\"一、disruptor的好处\"> 一、Disruptor的好处</h2>\n<p>通过前面的介绍我们知道Disruptor作用与ArrayBlockingQueue类似,适用于多个线程之间的消息队列。为什么呢?\n因为Java中的队列就以BlockingQueue为例子,从命名上就能看出是一个阻塞的队列。当多线程的环境下会进行加锁。所以导致了性能不高，而Disruptor的设计\n非常的巧妙,他形成了一个环形队列。通过消除锁,从而提高了性能。</p>\n<p><a href=\"/learn/java/BlockingQueue/\">如何你还不了解Queue,请点这里✈️</a></p>\n<p>Log4j2 异步输出，在使用了Disruptor的提升如下图。来源<a href=\"https://logging.apache.org/log4j/2.x/performance.html\" target=\"_blank\" rel=\"noopener noreferrer\">log4j2官网</a></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1653013607000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"二、为什么这么快\"> 二、为什么这么快</h2>\n<p>这里涉及到的知识点比较多,如果想学性能优化的同学可以去看看。可以学习里面的设计思想和优化的方向。</p>\n<p><a href=\"https://www.jianshu.com/p/bad7b4b44e48\" target=\"_blank\" rel=\"noopener noreferrer\">Disruptor详解</a></p>\n<p><a href=\"/learn/java/Contended/\">伪共享概念</a></p>\n<h2 id=\"三、如何使用\"> 三、如何使用</h2>\n<div><pre><code>        <span><span><span>&lt;</span>dependency</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>com.lmax<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>disruptor<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n            <span><span><span>&lt;</span>version</span><span>></span></span>3.4.2<span><span><span>&lt;/</span>version</span><span>></span></span>\n        <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"_3-1-定义disruptor\"> 3.1 定义Disruptor</h2>\n<div><pre><code>        <span>//指定RingBuffer大小,</span>\n        <span>//必须是2的N次方</span>\n        <span>int</span> bufferSize <span>=</span> <span>1024</span><span>;</span>\n\n        <span>//构建Disruptor</span>\n        <span>Disruptor</span><span><span>&lt;</span><span>LongEvent</span><span>></span></span> disruptor\n                <span>=</span> <span>new</span> <span>Disruptor</span><span><span>&lt;</span><span>></span></span><span>(</span>\n                <span>LongEvent</span><span>::</span><span>new</span><span>,</span>\n                bufferSize<span>,</span>\n                <span>DaemonThreadFactory</span><span>.</span>INSTANCE<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id=\"_3-2-定义事件处理器\"> 3.2 定义事件处理器</h2>\n<div><pre><code>        <span>//注册事件处理器</span>\n        disruptor<span>.</span><span>handleEventsWith</span><span>(</span>\n                <span>(</span>event<span>,</span> sequence<span>,</span> endOfBatch<span>)</span> <span>-></span>\n                        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"E: \"</span> <span>+</span> event<span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id=\"_3-3-生产数据\"> 3.3 生产数据</h2>\n<div><pre><code>        <span>//启动Disruptor</span>\n        disruptor<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n\n        <span>//获取RingBuffer</span>\n        <span>RingBuffer</span><span><span>&lt;</span><span>LongEvent</span><span>></span></span> ringBuffer\n                <span>=</span> disruptor<span>.</span><span>getRingBuffer</span><span>(</span><span>)</span><span>;</span>\n        <span>//生产Event</span>\n        <span>ByteBuffer</span> bb <span>=</span> <span>ByteBuffer</span><span>.</span><span>allocate</span><span>(</span><span>8</span><span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>long</span> l <span>=</span> <span>0</span><span>;</span> l <span>&lt;</span> <span>10</span><span>;</span> l<span>++</span><span>)</span> <span>{</span>\n            bb<span>.</span><span>putLong</span><span>(</span><span>0</span><span>,</span> l<span>)</span><span>;</span>\n            <span>//生产者生产消息</span>\n            ringBuffer<span>.</span><span>publishEvent</span><span>(</span>\n                    <span>(</span>event<span>,</span> sequence<span>,</span> buffer<span>)</span> <span>-></span>\n                            event<span>.</span><span>setValue</span><span>(</span>buffer<span>.</span><span>getLong</span><span>(</span><span>0</span><span>)</span><span>)</span><span>,</span> bb<span>)</span><span>;</span>\n        <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div>",
      "image": "https://img.springlearn.cn/blog/learn_1653013607000.png",
      "date_published": "2022-05-22T07:02:41.000Z",
      "date_modified": "2022-08-22T01:35:49.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Guava核心库专题",
      "url": "https://java.springlearn.cn/learn/tools/guava/",
      "id": "https://java.springlearn.cn/learn/tools/guava/",
      "content_html": "<p><img src=\"https://camo.githubusercontent.com/45e5eb02492f9e3bf6345cfd7ca7ecb42dca2268fef7af35dfe3da82740b4000/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f72656c656173652f676f6f676c652f67756176612e737667\" alt=\"\" loading=\"lazy\">\n<img src=\"https://github.com/google/guava/workflows/CI/badge.svg?branch=master\" alt=\"\" loading=\"lazy\"></p>\n<p>Guava 是一组来自 Google 的核心 Java 库，其中包括新的集合类型（例如 multimap 和 multiset）、不可变集合、图形库以及用于并发、I/O、散列、缓存、原语、字符串等的实用程序！它广泛用于 Google 内部的大多数 Java 项目，也被许多其他公司广泛使用</p>\n<div><pre><code><span><span><span>&lt;</span>dependency</span><span>></span></span>\n    <span><span><span>&lt;</span>groupId</span><span>></span></span>com.google.guava<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n    <span><span><span>&lt;</span>artifactId</span><span>></span></span>guava<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n    <span><span><span>&lt;</span>version</span><span>></span></span>31.1-jre<span><span><span>&lt;/</span>version</span><span>></span></span>\n    <span>&lt;!-- or, for Android: --></span>\n    <span><span><span>&lt;</span>version</span><span>></span></span>31.1-android<span><span><span>&lt;/</span>version</span><span>></span></span>\n<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div>",
      "image": "https://camo.githubusercontent.com/45e5eb02492f9e3bf6345cfd7ca7ecb42dca2268fef7af35dfe3da82740b4000/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f72656c656173652f676f6f676c652f67756176612e737667",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-08-22T01:35:49.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Druid SQL解析",
      "url": "https://java.springlearn.cn/learn/tools/druid/",
      "id": "https://java.springlearn.cn/learn/tools/druid/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/learn_1648308606000.png\" alt=\"\" loading=\"lazy\"></p>\n<div><p>相关信息</p>\n<p>本篇主要学习Druid 对Sql的语法解析。学习完之后,我们可以对任意sql进行解析,同时也可以基于AST语法树来生成sql语句。</p>\n</div>\n<p><a href=\"https://github.com/lxchinesszz/sql-parse-example\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://img.shields.io/badge/SQL解析-sql--parse--example-green\" alt=\"\" loading=\"lazy\"></a></p>\n<h2 id=\"一、ast\"> 一、AST</h2>\n<p>AST是abstract syntax tree的缩写，也就是抽象语法树。和所有的Parser一样，Druid Parser会生成一个抽象语法树。</p>\n<p>在Druid中，AST节点类型主要包括SQLObject、SQLExpr、SQLStatement三种抽象类型。</p>\n<div><pre><code>\n<span>interface</span> <span>SQLObject</span> <span>{</span><span>}</span>\n<span>interface</span> <span>SQLExpr</span> <span>extends</span> <span>SQLObject</span> <span>{</span><span>}</span>\n<span>interface</span> <span>SQLStatement</span> <span>extends</span> <span>SQLObject</span> <span>{</span><span>}</span>\n\n<span>interface</span> <span>SQLTableSource</span> <span>extends</span> <span>SQLObject</span> <span>{</span><span>}</span>\n<span>class</span> <span>SQLSelect</span> <span>extends</span> <span>SQLObject</span> <span>{</span><span>}</span>\n<span>class</span> <span>SQLSelectQueryBlock</span> <span>extends</span> <span>SQLObject</span> <span>{</span><span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id=\"二、语法树解析\"> 二、语法树解析</h2>\n<h2 id=\"_2-1-核心类介绍\"> 2.1 核心类介绍</h2>\n<h3 id=\"_2-1-1-sqlstatemment-dql-dml顶级抽象\"> 2.1.1 SQLStatemment DQL &amp; DML顶级抽象</h3>\n<ul>\n<li>DQL 数据查询语言 select</li>\n<li>DML 数据操纵语言 insert update delete</li>\n</ul>\n<p>最常用的Statement当然是SELECT/UPDATE/DELETE/INSERT，他们分别是</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">核心类</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">SQLSelectStatement</td>\n<td style=\"text-align:left\">查询语句</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">SQLUpdateStatement</td>\n<td style=\"text-align:left\">更新语句</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">SQLDeleteStatement</td>\n<td style=\"text-align:left\">删除语句</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">SQLInsertStatement</td>\n<td style=\"text-align:left\">新增语句</td>\n</tr>\n</tbody>\n</table>\n<div><pre><code><span>@Test</span>\n<span>public</span> <span>void</span> <span>statement</span><span>(</span><span>)</span> <span>{</span>\n    <span>// 以下全部 true</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>SQLUtils</span><span>.</span><span>parseSingleMysqlStatement</span><span>(</span><span>\"select * from users\"</span><span>)</span> <span>instanceof</span> <span>SQLSelectStatement</span><span>)</span><span>;</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>SQLUtils</span><span>.</span><span>parseSingleMysqlStatement</span><span>(</span><span>\"insert into users(id,name,age) values (1,'孙悟空',500)\"</span><span>)</span> <span>instanceof</span> <span>SQLInsertStatement</span><span>)</span><span>;</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>SQLUtils</span><span>.</span><span>parseSingleMysqlStatement</span><span>(</span><span>\"update users set name = '唐僧' where id = 1 \"</span><span>)</span> <span>instanceof</span> <span>SQLUpdateStatement</span><span>)</span><span>;</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>SQLUtils</span><span>.</span><span>parseSingleMysqlStatement</span><span>(</span><span>\"delete from users where id = 1\"</span><span>)</span> <span>instanceof</span> <span>SQLDeleteStatement</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id=\"_2-1-2-sqlselect-sql查询\"> 2.1.2 SQLSelect SQL查询</h3>\n<p>SQLSelectStatement包含一个SQLSelect，SQLSelect包含一个SQLSelectQuery。SQLSelectQuery有主要的两个派生类，\n分别是SQLSelectQueryBlock(单表sql查询)和SQLUnionQuery(<a href=\"https://www.w3school.com.cn/sql/sql_union.asp\" target=\"_blank\" rel=\"noopener noreferrer\">union查询</a>)。</p>\n<div><pre><code>    <span>/**\n     * SQLSelectStatement包含一个SQLSelect，SQLSelect包含一个SQLSelectQuery。SQLSelectQuery有主要的两个派生类，\n     * 分别是SQLSelectQueryBlock(单表sql查询)和SQLUnionQuery(联合查询)。\n     */</span>\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>SQLSelectQuery</span><span>(</span><span>)</span> <span>{</span>\n        <span>// true</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>parseSQLSelectQuery</span><span>(</span><span>\"select * from users\"</span><span>)</span> <span>instanceof</span> <span>SQLSelectQueryBlock</span><span>)</span><span>;</span>\n        <span>// true</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>parseSQLSelectQuery</span><span>(</span><span>\"select name from users union select name from school\"</span><span>)</span> <span>instanceof</span> <span>SQLUnionQuery</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>SQLSelectQuery</span> <span>parseSQLSelectQuery</span><span>(</span><span>String</span> sql<span>)</span> <span>{</span>\n        <span>SQLStatement</span> sqlStatement <span>=</span> <span>SQLUtils</span><span>.</span><span>parseSingleMysqlStatement</span><span>(</span>sql<span>)</span><span>;</span>\n        <span>SQLSelectStatement</span> sqlSelectStatement <span>=</span> <span>Utils</span><span>.</span><span>cast</span><span>(</span>sqlStatement<span>,</span> <span>SQLSelectStatement</span><span>.</span><span>class</span><span>)</span><span>;</span>\n        <span>SQLSelect</span> select <span>=</span> sqlSelectStatement<span>.</span><span>getSelect</span><span>(</span><span>)</span><span>;</span>\n        <span>return</span> select<span>.</span><span>getQuery</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h3 id=\"_2-1-3-sqlexpr\"> 2.1.3 SQLExpr</h3>\n<p>SQLExpr 是有几个实现类的。</p>\n<div><pre><code><span>select</span> id<span>,</span>name<span>,</span>age <span>from</span> users <span>where</span> id <span>=</span> <span>1</span> <span>and</span> name <span>=</span> <span>'孙悟空'</span><span>;</span>\n\n<span>select</span> u<span>.</span>id<span>,</span> u<span>.</span>name <span>from</span> users <span>as</span> u <span>where</span> id <span>=</span> <span>1</span> <span>and</span> name <span>=</span> ?<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">核心类</th>\n<th style=\"text-align:left\">举例</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:left\">适用范围</th>\n<th style=\"text-align:left\">快速记忆</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">SQLIdentifierExpr</td>\n<td style=\"text-align:left\">id,name,age</td>\n<td style=\"text-align:left\">SQLIdentifierExpr</td>\n<td style=\"text-align:left\">查询字段或者where条件</td>\n<td style=\"text-align:left\">唯一标记</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">SQLPropertyExpr</td>\n<td style=\"text-align:left\">u.id,u.name</td>\n<td style=\"text-align:left\">区别于SQLIdentifierExpr,适用于有别名的场景; SQLPropertyExpr.name = id, SQLPropertyExpr.owner = SQLIdentifierExpr = u）</td>\n<td style=\"text-align:left\">查询字段或者where条件</td>\n<td style=\"text-align:left\">有别名就是它</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">SQLBinaryOpExpr</td>\n<td style=\"text-align:left\">id = 1, id &gt; 5</td>\n<td style=\"text-align:left\">SQLBinaryOpExpr(left = SQLIdentifierExpr = id ,right = SQLValuableExpr = 1)</td>\n<td style=\"text-align:left\">where条件</td>\n<td style=\"text-align:left\">有操作符就是它</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">SQLVariantRefExpr</td>\n<td style=\"text-align:left\">id = ?</td>\n<td style=\"text-align:left\">变量</td>\n<td style=\"text-align:left\">where条件</td>\n<td style=\"text-align:left\">有变量符就是它</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">SQLIntegerExpr</td>\n<td style=\"text-align:left\">id = 1</td>\n<td style=\"text-align:left\">数字类型</td>\n<td style=\"text-align:left\">值类型</td>\n<td style=\"text-align:left\">-</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">SQLCharExpr</td>\n<td style=\"text-align:left\">name = '孙悟空'</td>\n<td style=\"text-align:left\">字符类型</td>\n<td style=\"text-align:left\">值类型</td>\n<td style=\"text-align:left\">-</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"_2-1-3-1-sqlbinaryopexpr\"> 2.1.3.1 SQLBinaryOpExpr</h4>\n<div><pre><code>    <span>/**\n     * 操作符相关: SQLBinaryOpExpr\n     */</span>\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>SQLBinaryOpExpr</span><span>(</span><span>)</span> <span>{</span>\n        <span>String</span> sql <span>=</span> <span>\"select * from users where id > 1 and age = 18\"</span><span>;</span>\n        <span>SQLSelectQuery</span> sqlSelectQuery <span>=</span> <span>Utils</span><span>.</span><span>parseSQLSelectQuery</span><span>(</span>sql<span>)</span><span>;</span>\n        <span>SQLSelectQueryBlock</span> selectQueryBlock <span>=</span> <span>Utils</span><span>.</span><span>cast</span><span>(</span>sqlSelectQuery<span>,</span> <span>SQLSelectQueryBlock</span><span>.</span><span>class</span><span>)</span><span>;</span>\n        <span>SQLExpr</span> where <span>=</span> selectQueryBlock<span>.</span><span>getWhere</span><span>(</span><span>)</span><span>;</span>\n        <span>List</span><span><span>&lt;</span><span>SQLObject</span><span>></span></span> conditions <span>=</span> where<span>.</span><span>getChildren</span><span>(</span><span>)</span><span>;</span>\n        <span>// [id > 1 , age = 18] 出现了操作符所以是SQLBinaryOpExpr</span>\n        <span>for</span> <span>(</span><span>SQLObject</span> condition <span>:</span> conditions<span>)</span> <span>{</span>\n            <span>SQLBinaryOpExpr</span> conditionExpr <span>=</span> <span>Utils</span><span>.</span><span>cast</span><span>(</span>condition<span>,</span> <span>SQLBinaryOpExpr</span><span>.</span><span>class</span><span>)</span><span>;</span>\n            <span>SQLBinaryOperator</span> operator <span>=</span> conditionExpr<span>.</span><span>getOperator</span><span>(</span><span>)</span><span>;</span>\n            <span>SQLIdentifierExpr</span> conditionColumn <span>=</span> <span>Utils</span><span>.</span><span>cast</span><span>(</span>conditionExpr<span>.</span><span>getLeft</span><span>(</span><span>)</span><span>,</span> <span>SQLIdentifierExpr</span><span>.</span><span>class</span><span>)</span><span>;</span>\n            <span>SQLValuableExpr</span> conditionColumnValue <span>=</span> <span>Utils</span><span>.</span><span>cast</span><span>(</span>conditionExpr<span>.</span><span>getRight</span><span>(</span><span>)</span><span>,</span> <span>SQLValuableExpr</span><span>.</span><span>class</span><span>)</span><span>;</span>\n            <span>Utils</span><span>.</span><span>print</span><span>(</span><span>\"条件字段:{},操作符号:{},条件值:{}\"</span><span>,</span> conditionColumn<span>.</span><span>getName</span><span>(</span><span>)</span><span>,</span> operator<span>.</span>name<span>,</span> conditionColumnValue<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h4 id=\"_2-1-3-2-sqlvariantrefexpr\"> 2.1.3.2 SQLVariantRefExpr</h4>\n<div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>SQLVariantRefExpr</span><span>(</span><span>)</span> <span>{</span>\n        <span>String</span> sql <span>=</span> <span>\"select * from users where id = ? and name = ?\"</span><span>;</span>\n        <span>SQLSelectQuery</span> sqlSelectQuery <span>=</span> <span>Utils</span><span>.</span><span>parseSQLSelectQuery</span><span>(</span>sql<span>)</span><span>;</span>\n        <span>SQLSelectQueryBlock</span> selectQueryBlock <span>=</span> <span>Utils</span><span>.</span><span>cast</span><span>(</span>sqlSelectQuery<span>,</span> <span>SQLSelectQueryBlock</span><span>.</span><span>class</span><span>)</span><span>;</span>\n        <span>SQLExpr</span> where <span>=</span> selectQueryBlock<span>.</span><span>getWhere</span><span>(</span><span>)</span><span>;</span>\n        <span>List</span><span><span>&lt;</span><span>SQLObject</span><span>></span></span> conditions <span>=</span> where<span>.</span><span>getChildren</span><span>(</span><span>)</span><span>;</span>\n        <span>// [id = ?] 出现了变量符,所以要用SQLVariantRefExpr</span>\n        <span>for</span> <span>(</span><span>SQLObject</span> condition <span>:</span> conditions<span>)</span> <span>{</span>\n            <span>SQLBinaryOpExpr</span> conditionExpr <span>=</span> <span>Utils</span><span>.</span><span>cast</span><span>(</span>condition<span>,</span> <span>SQLBinaryOpExpr</span><span>.</span><span>class</span><span>)</span><span>;</span>\n            <span>SQLBinaryOperator</span> operator <span>=</span> conditionExpr<span>.</span><span>getOperator</span><span>(</span><span>)</span><span>;</span>\n            <span>SQLIdentifierExpr</span> conditionColumn <span>=</span> <span>Utils</span><span>.</span><span>cast</span><span>(</span>conditionExpr<span>.</span><span>getLeft</span><span>(</span><span>)</span><span>,</span> <span>SQLIdentifierExpr</span><span>.</span><span>class</span><span>)</span><span>;</span>\n            <span>SQLVariantRefExpr</span> conditionColumnValue <span>=</span> <span>Utils</span><span>.</span><span>cast</span><span>(</span>conditionExpr<span>.</span><span>getRight</span><span>(</span><span>)</span><span>,</span> <span>SQLVariantRefExpr</span><span>.</span><span>class</span><span>)</span><span>;</span>\n            <span>int</span> index <span>=</span> conditionColumnValue<span>.</span><span>getIndex</span><span>(</span><span>)</span><span>;</span>\n            <span>Utils</span><span>.</span><span>print</span><span>(</span><span>\"条件字段:{},操作符号:{},索引位:{}\"</span><span>,</span> conditionColumn<span>.</span><span>getName</span><span>(</span><span>)</span><span>,</span> operator<span>.</span>name<span>,</span> index<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h3 id=\"_2-1-4-sqltablesource\"> 2.1.4 SQLTableSource</h3>\n<p>常见的SQLTableSource包括SQLExprTableSource、SQLJoinTableSource、SQLSubqueryTableSource、SQLWithSubqueryClause.Entry</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">核心类</th>\n<th style=\"text-align:left\">举例</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:left\">快速记忆</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">SQLExprTableSource</td>\n<td style=\"text-align:left\">select * from emp where i = 3</td>\n<td style=\"text-align:left\">name = SQLIdentifierExpr = emp</td>\n<td style=\"text-align:left\">单表查询</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">SQLJoinTableSource</td>\n<td style=\"text-align:left\">select * from emp e inner join org o on e.org_id = o.id</td>\n<td style=\"text-align:left\">left = SQLExprTableSource(emp e),right = SQLExprTableSource(org o), condition = SQLBinaryOpExpr(e.org_id = o.id)</td>\n<td style=\"text-align:left\">join 查询使用</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">SQLSubqueryTableSource</td>\n<td style=\"text-align:left\">select * from (select * from temp) a</td>\n<td style=\"text-align:left\">from(...)是一个SQLSubqueryTableSource</td>\n<td style=\"text-align:left\">子查询语句</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">SQLWithSubqueryClause</td>\n<td style=\"text-align:left\">WITH RECURSIVE ancestors AS (SELECT * FROM org UNION SELECT f.* FROM org f, ancestors a WHERE f.id = a.parent_id ) SELECT * FROM ancestors;</td>\n<td style=\"text-align:left\">ancestors AS (...) 是一个SQLWithSubqueryClause.Entry</td>\n<td style=\"text-align:left\">with</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"_2-2-sql语句解析示例\"> 2.2 SQL语句解析示例</h2>\n<h3 id=\"_2-2-1-解析-where\"> 2.2.1 解析 Where</h3>\n<p>注意如果条件语句中只有一个条件,那么where就是一个 <code>SQLBinaryOpExpr</code>。\n当条件大于2个,使用 <code>where.getChildren()</code></p>\n<div><pre><code>    <span>/**\n     * 判断where要\n     * 1. 注意是SQLBinaryOpExpr(id = 1) or (u.id = 1) 需要注意是否使用了别名&lt;br>\n     * 2. 注意如果只有一个查询添加 where本身就是一个SQLBinaryOpExpr，如果是多个就要用 where.getChildren()&lt;br>&lt;/>\n     * 如果有别名: SQLPropertyExpr(name = id , ownerName = u)&lt;br>\n     * 如果没别名: SQLIdentifierExpr(name = id) &lt;br>&lt;/>\n     * 值对象: SQLValuableExpr\n     *\n     * @param where 条件对象\n     */</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>parseWhere</span><span>(</span><span>SQLExpr</span> where<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>where <span>instanceof</span> <span>SQLBinaryOpExpr</span><span>)</span> <span>{</span>\n            <span>parseSQLBinaryOpExpr</span><span>(</span><span>cast</span><span>(</span>where<span>,</span> <span>SQLBinaryOpExpr</span><span>.</span><span>class</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            <span>List</span><span><span>&lt;</span><span>SQLObject</span><span>></span></span> childrenList <span>=</span> where<span>.</span><span>getChildren</span><span>(</span><span>)</span><span>;</span>\n            <span>for</span> <span>(</span><span>SQLObject</span> sqlObject <span>:</span> childrenList<span>)</span> <span>{</span>\n                <span>// 包含了 left 和 right</span>\n                <span>SQLBinaryOpExpr</span> conditionBinary <span>=</span> <span>cast</span><span>(</span>sqlObject<span>,</span> <span>SQLBinaryOpExpr</span><span>.</span><span>class</span><span>)</span><span>;</span>\n                <span>parseSQLBinaryOpExpr</span><span>(</span>conditionBinary<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n\n    <span>}</span>\n    \n     <span>public</span> <span>static</span> <span>void</span> <span>parseSQLBinaryOpExpr</span><span>(</span><span>SQLBinaryOpExpr</span> conditionBinary<span>)</span> <span>{</span>\n        <span>SQLExpr</span> conditionExpr <span>=</span> conditionBinary<span>.</span><span>getLeft</span><span>(</span><span>)</span><span>;</span>\n        <span>SQLExpr</span> conditionValueExpr <span>=</span> conditionBinary<span>.</span><span>getRight</span><span>(</span><span>)</span><span>;</span>\n        <span>// 左边有别名所以是SQLPropertyExpr</span>\n        <span>if</span> <span>(</span>conditionExpr <span>instanceof</span> <span>SQLPropertyExpr</span><span>)</span> <span>{</span>\n            <span>SQLPropertyExpr</span> conditionColumnExpr <span>=</span> <span>cast</span><span>(</span>conditionExpr<span>,</span> <span>SQLPropertyExpr</span><span>.</span><span>class</span><span>)</span><span>;</span>\n            <span>// 右边根据类型进行转换 id是SQLIntegerExpr name是SQLCharExpr</span>\n            <span>SQLValuableExpr</span> conditionColumnValue <span>=</span> <span>cast</span><span>(</span>conditionValueExpr<span>,</span> <span>SQLValuableExpr</span><span>.</span><span>class</span><span>)</span><span>;</span>\n            <span>print</span><span>(</span><span>\"条件列名:{},条件别名:{},条件值:{}\"</span><span>,</span> conditionColumnExpr<span>.</span><span>getName</span><span>(</span><span>)</span><span>,</span> conditionColumnExpr<span>.</span><span>getOwnernName</span><span>(</span><span>)</span><span>,</span> conditionColumnValue<span>)</span><span>;</span>\n        <span>}</span>\n        <span>// 如果没有别名</span>\n        <span>if</span> <span>(</span>conditionExpr <span>instanceof</span> <span>SQLIdentifierExpr</span><span>)</span> <span>{</span>\n            <span>SQLIdentifierExpr</span> conditionColumnExpr <span>=</span> <span>cast</span><span>(</span>conditionExpr<span>,</span> <span>SQLIdentifierExpr</span><span>.</span><span>class</span><span>)</span><span>;</span>\n            <span>SQLValuableExpr</span> conditionColumnValue <span>=</span> <span>cast</span><span>(</span>conditionValueExpr<span>,</span> <span>SQLValuableExpr</span><span>.</span><span>class</span><span>)</span><span>;</span>\n            <span>print</span><span>(</span><span>\"条件列名:{},条件值:{}\"</span><span>,</span> conditionColumnExpr<span>.</span><span>getName</span><span>(</span><span>)</span><span>,</span> conditionColumnValue<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><h3 id=\"_2-2-2-解析-sqlselectitem\"> 2.2.2 解析 SQLSelectItem</h3>\n<p>解析查询的列信息</p>\n<div><pre><code>    <span>/**\n     * 解析查询字段,注意是否使用了别名.u.id as userId, u.name as userName, u.age as userAge&lt;br>\n     * userId（sqlSelectItem.getAlias）&lt;br>\n     * 如果有别名: u.id( id = SQLPropertyExpr.getName,u = SQLPropertyExpr.getOwnernName)&lt;br>\n     * 如果没别名: id(id = SQLIdentifierExpr.name)\n     *\n     * @param selectColumnList 查询字段\n     */</span>\n    <span>private</span> <span>void</span> <span>parseSQLSelectItem</span><span>(</span><span>List</span><span><span>&lt;</span><span>SQLSelectItem</span><span>></span></span> selectColumnList<span>)</span> <span>{</span>\n        <span>for</span> <span>(</span><span>SQLSelectItem</span> sqlSelectItem <span>:</span> selectColumnList<span>)</span> <span>{</span>\n            <span>// u.id as userId(selectColumnAlias)</span>\n            <span>String</span> selectColumnAlias <span>=</span> sqlSelectItem<span>.</span><span>getAlias</span><span>(</span><span>)</span><span>;</span>\n            <span>// u.id = SQLPropertyExpr</span>\n            <span>SQLExpr</span> expr <span>=</span> sqlSelectItem<span>.</span><span>getExpr</span><span>(</span><span>)</span><span>;</span>\n            <span>if</span> <span>(</span>expr <span>instanceof</span> <span>SQLPropertyExpr</span><span>)</span> <span>{</span>\n                <span>SQLPropertyExpr</span> selectColumnExpr <span>=</span> <span>cast</span><span>(</span>expr<span>,</span> <span>SQLPropertyExpr</span><span>.</span><span>class</span><span>)</span><span>;</span>\n                <span>print</span><span>(</span><span>\"列名:{},别名:{},表别名:{}\"</span><span>,</span> selectColumnExpr<span>.</span><span>getName</span><span>(</span><span>)</span><span>,</span> selectColumnAlias<span>,</span> selectColumnExpr<span>.</span><span>getOwnernName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>}</span>\n            <span>if</span> <span>(</span>expr <span>instanceof</span> <span>SQLIdentifierExpr</span><span>)</span> <span>{</span>\n                <span>SQLIdentifierExpr</span> selectColumnExpr <span>=</span> <span>cast</span><span>(</span>expr<span>,</span> <span>SQLIdentifierExpr</span><span>.</span><span>class</span><span>)</span><span>;</span>\n                <span>print</span><span>(</span><span>\"列名:{},别名:{}\"</span><span>,</span> selectColumnExpr<span>.</span><span>getName</span><span>(</span><span>)</span><span>,</span> selectColumnAlias<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h3 id=\"_2-2-3-解析-sqlupdatesetitem\"> 2.2.3 解析 SQLUpdateSetItem</h3>\n<div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>SQLUpdateStatement</span><span>(</span><span>)</span> <span>{</span>\n        <span>SQLStatement</span> sqlStatement <span>=</span> <span>SQLUtils</span><span>.</span><span>parseSingleMysqlStatement</span><span>(</span><span>\"update users u set u.name = '唐僧',age = 18 where u.id = 1 \"</span><span>)</span><span>;</span>\n        <span>SQLUpdateStatement</span> sqlUpdateStatement <span>=</span> <span>Utils</span><span>.</span><span>cast</span><span>(</span>sqlStatement<span>,</span> <span>SQLUpdateStatement</span><span>.</span><span>class</span><span>)</span><span>;</span>\n        <span>List</span><span><span>&lt;</span><span>SQLUpdateSetItem</span><span>></span></span> setItems <span>=</span> sqlUpdateStatement<span>.</span><span>getItems</span><span>(</span><span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>SQLUpdateSetItem</span> setItem <span>:</span> setItems<span>)</span> <span>{</span>\n            <span>SQLExpr</span> column <span>=</span> setItem<span>.</span><span>getColumn</span><span>(</span><span>)</span><span>;</span>\n            <span>if</span> <span>(</span>column <span>instanceof</span> <span>SQLPropertyExpr</span><span>)</span> <span>{</span>\n                <span>SQLPropertyExpr</span> sqlPropertyExpr <span>=</span> <span>Utils</span><span>.</span><span>cast</span><span>(</span>column<span>,</span> <span>SQLPropertyExpr</span><span>.</span><span>class</span><span>)</span><span>;</span>\n                <span>SQLExpr</span> value <span>=</span> setItem<span>.</span><span>getValue</span><span>(</span><span>)</span><span>;</span>\n                <span>Utils</span><span>.</span><span>print</span><span>(</span><span>\"column:{},列owner:{},value:{}\"</span><span>,</span> sqlPropertyExpr<span>.</span><span>getName</span><span>(</span><span>)</span><span>,</span> sqlPropertyExpr<span>.</span><span>getOwnernName</span><span>(</span><span>)</span><span>,</span> value<span>)</span><span>;</span>\n            <span>}</span>\n            <span>if</span> <span>(</span>column <span>instanceof</span> <span>SQLIdentifierExpr</span><span>)</span> <span>{</span>\n                <span>SQLExpr</span> value <span>=</span> setItem<span>.</span><span>getValue</span><span>(</span><span>)</span><span>;</span>\n                <span>Utils</span><span>.</span><span>print</span><span>(</span><span>\"column:{},value:{}\"</span><span>,</span> column<span>,</span> value<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>SQLExpr</span> where <span>=</span> sqlUpdateStatement<span>.</span><span>getWhere</span><span>(</span><span>)</span><span>;</span>\n        <span>Utils</span><span>.</span><span>startParse</span><span>(</span><span>\"解析where\"</span><span>,</span> <span>Utils</span><span>::</span><span>parseWhere</span><span>,</span> where<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h3 id=\"_2-2-4-解析-sqllimit\"> 2.2.4 解析 SQLLimit</h3>\n<div><pre><code>    <span>/**\n     * 偏移量,只有2个值\n     *\n     * @param limit 限制\n     */</span>\n    <span>private</span> <span>void</span> <span>parseLimit</span><span>(</span><span>SQLLimit</span> limit<span>)</span> <span>{</span>\n        <span>// 偏移量</span>\n        <span>SQLExpr</span> offset <span>=</span> limit<span>.</span><span>getOffset</span><span>(</span><span>)</span><span>;</span>\n        <span>// 便宜数量</span>\n        <span>SQLExpr</span> rowCount <span>=</span> limit<span>.</span><span>getRowCount</span><span>(</span><span>)</span><span>;</span>\n        <span>print</span><span>(</span><span>\"偏移量:{},偏移数量:{}\"</span><span>,</span> offset<span>,</span> rowCount<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id=\"_2-2-5-解析-sqlselectgroupby\"> 2.2.5 解析 SQLSelectGroupBy</h3>\n<div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>groupBy</span><span>(</span><span>)</span> <span>{</span>\n        <span>SQLStatement</span> sqlStatement <span>=</span> <span>SQLUtils</span><span>.</span><span>parseSingleMysqlStatement</span><span>(</span><span>\"select name,count(1) as count from users group by name,age having count > 2\"</span><span>)</span><span>;</span>\n        <span>SQLSelectStatement</span> selectStatement <span>=</span> <span>Utils</span><span>.</span><span>cast</span><span>(</span>sqlStatement<span>,</span> <span>SQLSelectStatement</span><span>.</span><span>class</span><span>)</span><span>;</span>\n        <span>SQLSelect</span> select <span>=</span> selectStatement<span>.</span><span>getSelect</span><span>(</span><span>)</span><span>;</span>\n        <span>SQLSelectQueryBlock</span> query <span>=</span> <span>Utils</span><span>.</span><span>cast</span><span>(</span>select<span>.</span><span>getQuery</span><span>(</span><span>)</span><span>,</span> <span>SQLSelectQueryBlock</span><span>.</span><span>class</span><span>)</span><span>;</span>\n        <span>SQLSelectGroupByClause</span> groupBy <span>=</span> query<span>.</span><span>getGroupBy</span><span>(</span><span>)</span><span>;</span>\n        <span>List</span><span><span>&lt;</span><span>SQLExpr</span><span>></span></span> items <span>=</span> groupBy<span>.</span><span>getItems</span><span>(</span><span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>SQLExpr</span> item <span>:</span> items<span>)</span> <span>{</span>\n            <span>// group by name</span>\n            <span>// group by age</span>\n            <span>SQLIdentifierExpr</span> groupByColumn <span>=</span> <span>Utils</span><span>.</span><span>cast</span><span>(</span>item<span>,</span> <span>SQLIdentifierExpr</span><span>.</span><span>class</span><span>)</span><span>;</span>\n            <span>Utils</span><span>.</span><span>print</span><span>(</span><span>\"group by {}\"</span><span>,</span> groupByColumn<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id=\"_2-2-6-解析-having\"> 2.2.6 解析 Having</h3>\n<div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>having</span><span>(</span><span>)</span> <span>{</span>\n        <span>SQLStatement</span> sqlStatement <span>=</span> <span>SQLUtils</span><span>.</span><span>parseSingleMysqlStatement</span><span>(</span><span>\"select name,count(1) as count from users group by name,age having count > 2\"</span><span>)</span><span>;</span>\n        <span>SQLSelectStatement</span> selectStatement <span>=</span> <span>Utils</span><span>.</span><span>cast</span><span>(</span>sqlStatement<span>,</span> <span>SQLSelectStatement</span><span>.</span><span>class</span><span>)</span><span>;</span>\n        <span>SQLSelect</span> select <span>=</span> selectStatement<span>.</span><span>getSelect</span><span>(</span><span>)</span><span>;</span>\n        <span>SQLSelectQueryBlock</span> query <span>=</span> <span>Utils</span><span>.</span><span>cast</span><span>(</span>select<span>.</span><span>getQuery</span><span>(</span><span>)</span><span>,</span> <span>SQLSelectQueryBlock</span><span>.</span><span>class</span><span>)</span><span>;</span>\n        <span>SQLSelectGroupByClause</span> groupBy <span>=</span> query<span>.</span><span>getGroupBy</span><span>(</span><span>)</span><span>;</span>\n        <span>SQLExpr</span> having <span>=</span> groupBy<span>.</span><span>getHaving</span><span>(</span><span>)</span><span>;</span>\n        <span>// 因为只有一个条件,所以having就是SQLBinaryOpExpr</span>\n        <span>SQLBinaryOpExpr</span> havingExpr <span>=</span> <span>Utils</span><span>.</span><span>cast</span><span>(</span>having<span>,</span> <span>SQLBinaryOpExpr</span><span>.</span><span>class</span><span>)</span><span>;</span>\n        <span>// 没有使用别名,所以就是SQLIdentifierExpr</span>\n        <span>SQLExpr</span> left <span>=</span> havingExpr<span>.</span><span>getLeft</span><span>(</span><span>)</span><span>;</span>\n        <span>SQLIdentifierExpr</span> leftExpr <span>=</span> <span>Utils</span><span>.</span><span>cast</span><span>(</span>left<span>,</span> <span>SQLIdentifierExpr</span><span>.</span><span>class</span><span>)</span><span>;</span>\n        <span>// 数字类型就是</span>\n        <span>SQLExpr</span> right <span>=</span> havingExpr<span>.</span><span>getRight</span><span>(</span><span>)</span><span>;</span>\n        <span>SQLValuableExpr</span> rightValue <span>=</span> <span>Utils</span><span>.</span><span>cast</span><span>(</span>right<span>,</span> <span>SQLValuableExpr</span><span>.</span><span>class</span><span>)</span><span>;</span>\n        <span>SQLBinaryOperator</span> operator <span>=</span> havingExpr<span>.</span><span>getOperator</span><span>(</span><span>)</span><span>;</span>\n        <span>// left:count, operator:>,right:2</span>\n        <span>Utils</span><span>.</span><span>print</span><span>(</span><span>\"left:{}, operator:{},right:{}\"</span><span>,</span> leftExpr<span>.</span><span>getName</span><span>(</span><span>)</span><span>,</span> operator<span>.</span>name<span>,</span> rightValue<span>.</span><span>getValue</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h2 id=\"三、语法树生成\"> 三、语法树生成</h2>\n<p>前面的内容如果都搞清楚了,那么我们就能对sql进行解析,通知可以修改sql解析后的语法树,同时再将修改后的语法树,重新转换成sql</p>\n<h2 id=\"_3-1-修改语法树\"> 3.1 修改语法树</h2>\n<h3 id=\"_3-1-1-增加一个条件\"> 3.1.1 增加一个条件</h3>\n<div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>SQLDeleteStatement</span><span>(</span><span>)</span><span>{</span>\n        <span>SQLStatement</span> sqlStatement <span>=</span> <span>SQLUtils</span><span>.</span><span>parseSingleMysqlStatement</span><span>(</span><span>\"delete from users where id = 1\"</span><span>)</span><span>;</span>\n        <span>SQLDeleteStatement</span> sqlDeleteStatement <span>=</span> <span>Utils</span><span>.</span><span>cast</span><span>(</span>sqlStatement<span>,</span> <span>SQLDeleteStatement</span><span>.</span><span>class</span><span>)</span><span>;</span>\n        sqlDeleteStatement<span>.</span><span>addCondition</span><span>(</span><span>SQLUtils</span><span>.</span><span>toSQLExpr</span><span>(</span><span>\"name = '孙悟空'\"</span><span>)</span><span>)</span><span>;</span>\n<span>//        DELETE FROM users</span>\n<span>//        WHERE id = 1</span>\n<span>//        AND name = '孙悟空'</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>SQLUtils</span><span>.</span><span>toSQLString</span><span>(</span>sqlDeleteStatement<span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id=\"_3-1-2-修改一个条件值\"> 3.1.2 修改一个条件值</h3>\n<p>将条件id = 1 修改成 id = 2</p>\n<div><pre><code>    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>SQLDeleteStatement2</span><span>(</span><span>)</span><span>{</span>\n        <span>SQLStatement</span> sqlStatement <span>=</span> <span>SQLUtils</span><span>.</span><span>parseSingleMysqlStatement</span><span>(</span><span>\"delete from users where id = 1\"</span><span>)</span><span>;</span>\n        <span>SQLDeleteStatement</span> sqlDeleteStatement <span>=</span> <span>Utils</span><span>.</span><span>cast</span><span>(</span>sqlStatement<span>,</span> <span>SQLDeleteStatement</span><span>.</span><span>class</span><span>)</span><span>;</span>\n        <span>SQLExpr</span> where <span>=</span> sqlDeleteStatement<span>.</span><span>getWhere</span><span>(</span><span>)</span><span>;</span>\n        <span>SQLBinaryOpExpr</span> sqlBinaryOpExpr <span>=</span> <span>Utils</span><span>.</span><span>cast</span><span>(</span>where<span>,</span> <span>SQLBinaryOpExpr</span><span>.</span><span>class</span><span>)</span><span>;</span>\n<span>//        DELETE FROM users</span>\n<span>//        WHERE id = 2</span>\n        sqlBinaryOpExpr<span>.</span><span>setRight</span><span>(</span><span>SQLUtils</span><span>.</span><span>toSQLExpr</span><span>(</span><span>\"2\"</span><span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>SQLUtils</span><span>.</span><span>toSQLString</span><span>(</span>sqlDeleteStatement<span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id=\"四、visitor模式\"> 四、Visitor模式</h2>\n<p>访问者模式</p>\n<p>所有的AST节点都支持Visitor模式，需要自定义遍历逻辑，可以实现相应的ASTVisitorAdapter派生类</p>\n<div><pre><code>    <span>public</span> <span>static</span> <span>class</span> <span>CustomerMySqlASTVisitorAdapter</span> <span>extends</span> <span>MySqlASTVisitorAdapter</span> <span>{</span>\n\n        <span>private</span> <span>final</span> <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>SQLTableSource</span><span>></span></span> ALIAS_MAP <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>String</span><span>,</span> <span>SQLTableSource</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n\n        <span>private</span> <span>final</span> <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>SQLExpr</span><span>></span></span> ALIAS_COLUMN_MAP <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>String</span><span>,</span> <span>SQLExpr</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n\n\n        <span>public</span> <span>boolean</span> <span>visit</span><span>(</span><span>SQLExprTableSource</span> x<span>)</span> <span>{</span>\n            <span>String</span> alias <span>=</span> x<span>.</span><span>getAlias</span><span>(</span><span>)</span><span>;</span>\n            ALIAS_MAP<span>.</span><span>put</span><span>(</span>alias<span>,</span> x<span>)</span><span>;</span>\n            <span>return</span> <span>true</span><span>;</span>\n        <span>}</span>\n\n        <span>@Override</span>\n        <span>public</span> <span>boolean</span> <span>visit</span><span>(</span><span>MySqlSelectQueryBlock</span> x<span>)</span> <span>{</span>\n            <span>List</span><span><span>&lt;</span><span>SQLSelectItem</span><span>></span></span> selectList <span>=</span> x<span>.</span><span>getSelectList</span><span>(</span><span>)</span><span>;</span>\n            <span>for</span> <span>(</span><span>SQLSelectItem</span> sqlSelectItem <span>:</span> selectList<span>)</span> <span>{</span>\n                <span>String</span> alias <span>=</span> sqlSelectItem<span>.</span><span>getAlias</span><span>(</span><span>)</span><span>;</span>\n                <span>SQLExpr</span> expr <span>=</span> sqlSelectItem<span>.</span><span>getExpr</span><span>(</span><span>)</span><span>;</span>\n                ALIAS_COLUMN_MAP<span>.</span><span>put</span><span>(</span>alias<span>,</span> expr<span>)</span><span>;</span>\n            <span>}</span>\n            <span>return</span> <span>true</span><span>;</span>\n        <span>}</span>\n\n        <span>public</span> <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>SQLTableSource</span><span>></span></span> <span>getAliasMap</span><span>(</span><span>)</span> <span>{</span>\n            <span>return</span> ALIAS_MAP<span>;</span>\n        <span>}</span>\n\n        <span>public</span> <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>SQLExpr</span><span>></span></span> <span>getAliasColumnMap</span><span>(</span><span>)</span> <span>{</span>\n            <span>return</span> ALIAS_COLUMN_MAP<span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>AliasVisitor</span><span>(</span><span>)</span> <span>{</span>\n        <span>String</span> sql <span>=</span> <span>\"select u.id as userId, u.name as userName, age as userAge from users as u where u.id = 1 and u.name = '孙悟空' limit 2,10\"</span><span>;</span>\n        <span>// 解析SQL</span>\n        <span>SQLStatement</span> sqlStatement <span>=</span> <span>SQLUtils</span><span>.</span><span>parseSingleMysqlStatement</span><span>(</span>sql<span>)</span><span>;</span>\n        <span>CustomerMySqlASTVisitorAdapter</span> customerMySqlASTVisitorAdapter <span>=</span> <span>new</span> <span>CustomerMySqlASTVisitorAdapter</span><span>(</span><span>)</span><span>;</span>\n        sqlStatement<span>.</span><span>accept</span><span>(</span>customerMySqlASTVisitorAdapter<span>)</span><span>;</span>\n        <span>// 表别名:{u=users}</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"表别名:\"</span> <span>+</span> customerMySqlASTVisitorAdapter<span>.</span><span>getAliasMap</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// 列别名{userName=u.name, userId=u.id, userAge=age}</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"列别名\"</span> <span>+</span> customerMySqlASTVisitorAdapter<span>.</span><span>getAliasColumnMap</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br></div></div>",
      "image": "https://img.springlearn.cn/blog/learn_1648308606000.png",
      "date_published": "2022-03-27T13:12:51.000Z",
      "date_modified": "2022-08-22T01:35:49.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Guava-Map",
      "url": "https://java.springlearn.cn/learn/tools/guava/guava-map/",
      "id": "https://java.springlearn.cn/learn/tools/guava/guava-map/",
      "content_html": "<h2 id=\"一、简介\"> 一、简介</h2>\n<p>Guava 是一组来自 Google 的核心 Java 库，其中包括新的集合类型（例如 multimap 和 multiset）、不可变集合、图形库以及用于并发、I/O、散列、缓存、原语、字符串等的实用程序！它广泛用于 Google\n内部的大多数 Java 项目，也被许多其他公司广泛使用。</p>\n<p>API 非常的简单，我们可以非常轻松的使用，来封装成我们业务中自己的组件。</p>\n<h2 id=\"二、依赖\"> 二、依赖</h2>\n<div><pre><code>    <span><span><span>&lt;</span>dependency</span><span>></span></span>\n        <span><span><span>&lt;</span>groupId</span><span>></span></span>com.google.guava<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n        <span><span><span>&lt;</span>artifactId</span><span>></span></span>guava<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n        <span><span><span>&lt;</span>version</span><span>></span></span>30.1.1-jre<span><span><span>&lt;/</span>version</span><span>></span></span>\n    <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"三、使用介绍\"> 三、使用介绍</h2>\n<h3 id=\"_3-1-table-双键-map\"> 3.1 Table 双键 Map</h3>\n<p>java中的Map只允许有一个key和一个value存在，但是guava中的Table允许一个value存在两个key。Table中的两个key分别被称为rowKey和columnKey，也就是行和列。</p>\n<div><pre><code><span>Table</span><span><span>&lt;</span><span>String</span><span>,</span><span>String</span><span>,</span><span>Integer</span><span>></span></span> table<span>=</span> <span>HashBasedTable</span><span>.</span><span>create</span><span>(</span><span>)</span><span>;</span>\n<span>//存放元素</span>\ntable<span>.</span><span>put</span><span>(</span><span>\"Hydra\"</span><span>,</span> <span>\"Jan\"</span><span>,</span> <span>20</span><span>)</span><span>;</span>\ntable<span>.</span><span>put</span><span>(</span><span>\"Hydra\"</span><span>,</span> <span>\"Feb\"</span><span>,</span> <span>28</span><span>)</span><span>;</span>\ntable<span>.</span><span>put</span><span>(</span><span>\"Trunks\"</span><span>,</span> <span>\"Jan\"</span><span>,</span> <span>28</span><span>)</span><span>;</span>\ntable<span>.</span><span>put</span><span>(</span><span>\"Trunks\"</span><span>,</span> <span>\"Feb\"</span><span>,</span> <span>16</span><span>)</span><span>;</span>\n<span>//取出元素</span>\n<span>Integer</span> dayCount <span>=</span> table<span>.</span><span>get</span><span>(</span><span>\"Hydra\"</span><span>,</span> <span>\"Feb\"</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id=\"_3-2-bimap-双向map\"> 3.2 BiMap 双向Map</h3>\n<p>在普通Map中，如果要想根据value查找对应的key，没什么简便的办法，无论是使用for循环还是迭代器，都需要遍历整个Map。\n而guava中的BiMap提供了一种key和value双向关联的数据结构。</p>\n<div><div><br><br><br><br><br><br><div>&nbsp;</div><br><br><br></div><pre><code><span>HashBiMap</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> biMap <span>=</span> <span>HashBiMap</span><span>.</span><span>create</span><span>(</span><span>)</span><span>;</span>\nbiMap<span>.</span><span>put</span><span>(</span><span>\"Hydra\"</span><span>,</span><span>\"Programmer\"</span><span>)</span><span>;</span>\nbiMap<span>.</span><span>put</span><span>(</span><span>\"Tony\"</span><span>,</span><span>\"IronMan\"</span><span>)</span><span>;</span>\nbiMap<span>.</span><span>put</span><span>(</span><span>\"Thanos\"</span><span>,</span><span>\"Titan\"</span><span>)</span><span>;</span>\n<span>//使用key获取value</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>biMap<span>.</span><span>get</span><span>(</span><span>\"Tony\"</span><span>)</span><span>)</span><span>;</span>\n<span>BiMap</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> inverse <span>=</span> biMap<span>.</span><span>inverse</span><span>(</span><span>)</span><span>;</span>\n<span>//使用value获取key</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>inverse<span>.</span><span>get</span><span>(</span><span>\"Titan\"</span><span>)</span><span>)</span><span>;</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>注意: 反转后的BiMap并不是一个新的对象，它实现了一种视图的关联，所以对反转后的BiMap执行的所有操作会作用于原先的BiMap上。</p>\n<div><pre><code><span>HashBiMap</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> biMap <span>=</span> <span>HashBiMap</span><span>.</span><span>create</span><span>(</span><span>)</span><span>;</span>\nbiMap<span>.</span><span>put</span><span>(</span><span>\"Hydra\"</span><span>,</span><span>\"Programmer\"</span><span>)</span><span>;</span>\nbiMap<span>.</span><span>put</span><span>(</span><span>\"Tony\"</span><span>,</span><span>\"IronMan\"</span><span>)</span><span>;</span>\nbiMap<span>.</span><span>put</span><span>(</span><span>\"Thanos\"</span><span>,</span><span>\"Titan\"</span><span>)</span><span>;</span>\n<span>BiMap</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> inverse <span>=</span> biMap<span>.</span><span>inverse</span><span>(</span><span>)</span><span>;</span>\ninverse<span>.</span><span>put</span><span>(</span><span>\"IronMan\"</span><span>,</span><span>\"Stark\"</span><span>)</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>biMap<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>对反转后的BiMap中的内容进行了修改后，再看一下原先BiMap中的内容：</p>\n<div><pre><code><span>{</span><span>Hydra</span><span>=</span><span>Programmer</span><span>,</span> <span>Thanos</span><span>=</span><span>Titan</span><span>,</span> <span>Stark</span><span>=</span><span>IronMan</span><span>}</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>可以看到，原先值为IronMan时对应的键是Tony，虽然没有直接修改，但是现在键变成了Stark。</p>\n<h3 id=\"_3-3-multimap-多值map\"> 3.3 Multimap 多值Map</h3>\n<p>java中的Map维护的是键值一对一的关系，如果要将一个键映射到多个值上，那么就只能把值的内容设为集合形式，而在guava中可以使用如下：</p>\n<div><pre><code><span>Multimap</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Integer</span><span>></span></span> multimap <span>=</span> <span>ArrayListMultimap</span><span>.</span><span>create</span><span>(</span><span>)</span><span>;</span>\nmultimap<span>.</span><span>put</span><span>(</span><span>\"day\"</span><span>,</span><span>1</span><span>)</span><span>;</span>\nmultimap<span>.</span><span>put</span><span>(</span><span>\"day\"</span><span>,</span><span>2</span><span>)</span><span>;</span>\nmultimap<span>.</span><span>put</span><span>(</span><span>\"day\"</span><span>,</span><span>8</span><span>)</span><span>;</span>\nmultimap<span>.</span><span>put</span><span>(</span><span>\"month\"</span><span>,</span><span>3</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>打印这个Multimap的内容，可以直观的看到每个key对应的都是一个集合：</p>\n<div><pre><code>{month=[3], day=[1, 2, 8]}\n</code></pre>\n<div><span>1</span><br></div></div><h3 id=\"_3-4-rangemap-范围map\"> 3.4 RangeMap 范围Map</h3>\n<p>先看一个例子，假设我们要根据分数对考试成绩进行分类，那么代码中就会出现这样丑陋的if-else：</p>\n<div><pre><code><span>public</span> <span>static</span> <span>String</span> <span>getRank</span><span>(</span><span>int</span> score<span>)</span><span>{</span>\n    <span>if</span> <span>(</span><span>0</span><span>&lt;=</span>score <span>&amp;&amp;</span> score<span>&lt;</span><span>60</span><span>)</span>\n        <span>return</span> <span>\"fail\"</span><span>;</span>\n    <span>else</span> <span>if</span> <span>(</span><span>60</span><span>&lt;=</span>score <span>&amp;&amp;</span> score<span>&lt;=</span><span>90</span><span>)</span>\n        <span>return</span> <span>\"satisfactory\"</span><span>;</span>\n    <span>else</span> <span>if</span> <span>(</span><span>90</span><span>&lt;</span>score <span>&amp;&amp;</span> score<span>&lt;=</span><span>100</span><span>)</span>\n        <span>return</span> <span>\"excellent\"</span><span>;</span>\n    <span>return</span> <span>null</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>而guava中的RangeMap描述了一种从区间到特定值的映射关系，让我们能够以更为优雅的方法来书写代码。下面用RangeMap改造上面的代码并进行测试：</p>\n<div><pre><code><span>RangeMap</span><span><span>&lt;</span><span>Integer</span><span>,</span> <span>String</span><span>></span></span> rangeMap <span>=</span> <span>TreeRangeMap</span><span>.</span><span>create</span><span>(</span><span>)</span><span>;</span>\nrangeMap<span>.</span><span>put</span><span>(</span><span>Range</span><span>.</span><span>closedOpen</span><span>(</span><span>0</span><span>,</span><span>60</span><span>)</span><span>,</span><span>\"fail\"</span><span>)</span><span>;</span>\nrangeMap<span>.</span><span>put</span><span>(</span><span>Range</span><span>.</span><span>closed</span><span>(</span><span>60</span><span>,</span><span>90</span><span>)</span><span>,</span><span>\"satisfactory\"</span><span>)</span><span>;</span>\nrangeMap<span>.</span><span>put</span><span>(</span><span>Range</span><span>.</span><span>openClosed</span><span>(</span><span>90</span><span>,</span><span>100</span><span>)</span><span>,</span><span>\"excellent\"</span><span>)</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>rangeMap<span>.</span><span>get</span><span>(</span><span>59</span><span>)</span><span>)</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>rangeMap<span>.</span><span>get</span><span>(</span><span>60</span><span>)</span><span>)</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>rangeMap<span>.</span><span>get</span><span>(</span><span>90</span><span>)</span><span>)</span><span>;</span>\n<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>rangeMap<span>.</span><span>get</span><span>(</span><span>91</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>在上面的代码中，先后创建了[0,60)的左闭右开区间、[60,90]的闭区间、(90,100]的左开右闭区间，并分别映射到某个值上。运行结果打印：</p>\n<div><pre><code>fail\nsatisfactory\nsatisfactory\nexcellent\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"_3-5-classtoinstancemap-实例map\"> 3.5 ClassToInstanceMap 实例Map</h3>\n<p>ClassToInstanceMap是一个比较特殊的Map，它的键是Class，而值是这个Class对应的实例对象。先看一个简单使用的例子，使用putInstance方法存入对象</p>\n<div><pre><code><span>ClassToInstanceMap</span><span><span>&lt;</span><span>Object</span><span>></span></span> instanceMap <span>=</span> <span>MutableClassToInstanceMap</span><span>.</span><span>create</span><span>(</span><span>)</span><span>;</span>\n<span>User</span> user<span>=</span><span>new</span> <span>User</span><span>(</span><span>\"Hydra\"</span><span>,</span><span>18</span><span>)</span><span>;</span>\n<span>Dept</span> dept<span>=</span><span>new</span> <span>Dept</span><span>(</span><span>\"develop\"</span><span>,</span><span>200</span><span>)</span><span>;</span>\ninstanceMap<span>.</span><span>putInstance</span><span>(</span><span>User</span><span>.</span><span>class</span><span>,</span>user<span>)</span><span>;</span>\ninstanceMap<span>.</span><span>putInstance</span><span>(</span><span>Dept</span><span>.</span><span>class</span><span>,</span>dept<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>那么，使用ClassToInstanceMap这种方式有什么好处呢?</p>\n<p>最明显的就是在取出对象时省去了复杂的强制类型转换，避免了手动进行类型转换的错误。\n所以，如果你想缓存对象，又不想做复杂的类型校验，那么使用方便的ClassToInstanceMap就可以了。</p>\n",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Spring-retry重试组件",
      "url": "https://java.springlearn.cn/learn/tools/guava/spring-retry/",
      "id": "https://java.springlearn.cn/learn/tools/guava/spring-retry/",
      "content_html": "<h2 id=\"一、简介\"> 一、简介</h2>\n<div><p>Spring-retry</p>\n<p>前面我们了解到了,Guava的重试组件,我们可以基于Guava的能力,来封装我们需要的能力来满足我们的业务。今天来分享Spring-Retry重试组件。当然Spring只是帮我们封装好了，如果你不想自定义\n重试组件，那么我们可以直接使用Spring的能力来实现。</p>\n<p>API 也是非常的简单，几个注解就可以搞定。</p>\n</div>\n<p><a href=\"https://github.com/lxchinesszz/spring-retry-example\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://img.shields.io/badge/仓库-spring--retry--example-green\" alt=\"\" loading=\"lazy\"></a></p>\n<h2 id=\"二、依赖\"> 二、依赖</h2>\n<div><pre><code>    <span>&lt;!--springboot项目都不用引入版本号--></span>\n    <span><span><span>&lt;</span>dependency</span><span>></span></span>\n      <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.retry<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n      <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-retry<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n    <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n    <span>&lt;!--还是需要aop的支持的(如果已经引入了aop就不用再添加这个依赖了)--></span>\n    <span><span><span>&lt;</span>dependency</span><span>></span></span>\n      <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n      <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-aspects<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n    <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id=\"三、使用\"> 三、使用</h2>\n<h3 id=\"_3-1-enableretry-开启重试\"> 3.1 @EnableRetry 开启重试</h3>\n<p>SpringBoot启动类上添加开启重试注解</p>\n<div><pre><code>    <span>@EnableRetry</span>\n    <span>@SpringBootApplication</span>\n    <span>public</span> <span>class</span> <span>Application</span> <span>{</span>\n        <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n            <span>ConfigurableApplicationContext</span> applicationContext <span>=</span> <span>SpringApplication</span><span>.</span><span>run</span><span>(</span><span>Application</span><span>.</span><span>class</span><span>,</span> args<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id=\"_3-2-retryable-重试策略\"> 3.2 @Retryable 重试策略</h3>\n<p>在需要重试的方法上加注解@Retryable</p>\n<div><pre><code>    <span>@Retryable</span><span>(</span>value <span>=</span> <span>RuntimeException</span><span>.</span><span>class</span><span>,</span> maxAttempts <span>=</span> <span>5</span><span>,</span> backoff <span>=</span> <span>@Backoff</span><span>(</span>delay <span>=</span> <span>100</span><span>)</span><span>)</span>\n    <span>public</span> <span>String</span> <span>say</span><span>(</span><span>String</span> param<span>)</span> <span>{</span>\n        <span>double</span> random <span>=</span> <span>Math</span><span>.</span><span>random</span><span>(</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span>random <span>></span> <span>0.1</span><span>)</span> <span>{</span>\n            <span>throw</span> <span>new</span> <span>RuntimeException</span><span>(</span><span>\"超时\"</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> random <span>+</span> <span>\"\"</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><ul>\n<li><input type=\"checkbox\" checked=\"checked\" disabled=\"disabled\" id=\"task-item-0\"><label for=\"task-item-0\"> value = RuntimeException.class：是指方法抛出RuntimeException异常时，进行重试。这里可以指定你想要拦截的异常。</label></li>\n<li><input type=\"checkbox\" checked=\"checked\" disabled=\"disabled\" id=\"task-item-1\"><label for=\"task-item-1\"> maxAttempts：是最大重试次数。如果不写，则是默认3次。</label></li>\n<li><input type=\"checkbox\" checked=\"checked\" disabled=\"disabled\" id=\"task-item-2\"><label for=\"task-item-2\"> backoff = @Backoff(delay = 100)：是指重试间隔。delay=100意味着下一次的重试，要等100毫秒之后才能执行。</label></li>\n</ul>\n<h3 id=\"_3-3-recover-重试失败\"> 3.3 @Recover 重试失败</h3>\n<p>当@Retryable方法重试失败之后，最后就会调用@Recover方法。用于@Retryable失败时的“兜底”处理方法。 @Recover的方法必须要与@Retryable注解的方法保持一致，第一入参为要重试的异常，其他参数与@Retryable保持一致，返回值也要一样，否则无法执行！</p>\n<div><pre><code>    <span>@Retryable</span><span>(</span>value <span>=</span> <span>IllegalAccessException</span><span>.</span><span>class</span><span>)</span>\n    <span>public</span> <span>void</span> <span>say</span><span>(</span><span>)</span> <span>throws</span> <span>IllegalAccessException</span> <span>{</span>\n        log<span>.</span><span>info</span><span>(</span><span>\"do something... {}\"</span><span>,</span> <span>LocalDateTime</span><span>.</span><span>now</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>throw</span> <span>new</span> <span>IllegalAccessException</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n\n    <span>@Recover</span>\n    <span>public</span> <span>void</span> <span>sayBackup</span><span>(</span><span>IllegalAccessException</span> e<span>)</span> <span>{</span>\n        log<span>.</span><span>info</span><span>(</span><span>\"service retry after Recover => {}\"</span><span>,</span> e<span>.</span><span>getMessage</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id=\"_3-4-circuitbreaker-熔断策略\"> 3.4 @CircuitBreaker 熔断策略</h3>\n<p>规定时间内如果重试次数达到了最大次数,开启熔断策略。\n5秒内,这个方法重试了2次,就会断路。直接走@Recover修饰的方法。当超过10s后进行重置,继续走get方法。</p>\n<p>注意@Retryable和@CircuitBreaker不要修饰同一个方法。</p>\n<div><pre><code>    <span>@CircuitBreaker</span><span>(</span>openTimeout <span>=</span> <span>5000</span><span>,</span> maxAttempts <span>=</span> <span>2</span><span>,</span>resetTimeout <span>=</span> <span>10000</span><span>)</span>\n    <span>public</span> <span>String</span> <span>get</span><span>(</span><span>@PathVariable</span> <span>Integer</span> flag<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>flag <span>></span> <span>1</span><span>)</span> <span>{</span>\n            log<span>.</span><span>info</span><span>(</span><span>\"重试进入\"</span><span>)</span><span>;</span>\n            <span>throw</span> <span>new</span> <span>RuntimeException</span><span>(</span><span>\"自定义异常\"</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> <span>\"处理正常\"</span><span>;</span>\n    <span>}</span>\n    <span>@Recover</span>\n    <span>public</span> <span>String</span> <span>getBackup</span><span>(</span><span>RuntimeException</span> runtimeException<span>)</span> <span>{</span>\n        log<span>.</span><span>error</span><span>(</span><span>\"重试一直失败,进入备用方法:\"</span> <span>+</span> runtimeException<span>.</span><span>getMessage</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>return</span> <span>\"备用方法进去\"</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">属性</th>\n<th style=\"text-align:left\">意思</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">include</td>\n<td style=\"text-align:left\">指定处理的异常类。默认为空</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">exclude</td>\n<td style=\"text-align:left\">指定不需要处理的异常。默认为空</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">value</td>\n<td style=\"text-align:left\">指定要重试的异常。默认为空</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">maxAttempts</td>\n<td style=\"text-align:left\">最大重试次数。默认3次</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">openTimeout</td>\n<td style=\"text-align:left\">配置熔断器打开的超时时间，默认5s，当超过openTimeout之后熔断器电路变成半打开状态（只要有一次重试成功，则闭合电路）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">resetTimeout</td>\n<td style=\"text-align:left\">配置熔断器重新闭合的超时时间，默认20s，超过这个时间断路器关闭</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">include</td>\n<td style=\"text-align:left\">指定处理的异常类。默认为空</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_3-5-retrylistener-监听器\"> 3.5 RetryListener 监听器</h3>\n<p>spring-retry和guava-retry一样同样有监听器。我们可以自定义我们的监听器</p>\n<div><pre><code><span>@Slf4j</span>\n<span>public</span> <span>class</span> <span>DefaultListenerSupport</span> <span>extends</span> <span>RetryListenerSupport</span> <span>{</span>\n    <span>@Override</span>\n    <span>public</span> <span><span>&lt;</span><span>T</span><span>,</span> <span>E</span> <span>extends</span> <span>Throwable</span><span>></span></span> <span>void</span> <span>close</span><span>(</span><span>RetryContext</span> context<span>,</span>\n                                               <span>RetryCallback</span><span><span>&lt;</span><span>T</span><span>,</span> <span>E</span><span>></span></span> callback<span>,</span> <span>Throwable</span> throwable<span>)</span> <span>{</span>\n        log<span>.</span><span>info</span><span>(</span><span>\"onClose\"</span><span>)</span><span>;</span>\n        <span>super</span><span>.</span><span>close</span><span>(</span>context<span>,</span> callback<span>,</span> throwable<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span><span>&lt;</span><span>T</span><span>,</span> <span>E</span> <span>extends</span> <span>Throwable</span><span>></span></span> <span>void</span> <span>onError</span><span>(</span><span>RetryContext</span> context<span>,</span>\n                                                 <span>RetryCallback</span><span><span>&lt;</span><span>T</span><span>,</span> <span>E</span><span>></span></span> callback<span>,</span> <span>Throwable</span> throwable<span>)</span> <span>{</span>\n        log<span>.</span><span>info</span><span>(</span><span>\"onError\"</span><span>)</span><span>;</span>\n        <span>super</span><span>.</span><span>onError</span><span>(</span>context<span>,</span> callback<span>,</span> throwable<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span><span>&lt;</span><span>T</span><span>,</span> <span>E</span> <span>extends</span> <span>Throwable</span><span>></span></span> <span>boolean</span> <span>open</span><span>(</span><span>RetryContext</span> context<span>,</span>\n                                                 <span>RetryCallback</span><span><span>&lt;</span><span>T</span><span>,</span> <span>E</span><span>></span></span> callback<span>)</span> <span>{</span>\n        log<span>.</span><span>info</span><span>(</span><span>\"onOpen\"</span><span>)</span><span>;</span>\n        <span>return</span> <span>super</span><span>.</span><span>open</span><span>(</span>context<span>,</span> callback<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>@Configuration</span>\n<span>public</span> <span>class</span> <span>RetryConfig</span> <span>{</span>\n\n    <span>@Bean</span>\n    <span>public</span> <span>RetryTemplate</span> <span>retryTemplate</span><span>(</span><span>)</span> <span>{</span>\n        <span>RetryTemplate</span> retryTemplate <span>=</span> <span>new</span> <span>RetryTemplate</span><span>(</span><span>)</span><span>;</span>\n        <span>SimpleRetryPolicy</span> retryPolicy <span>=</span> <span>new</span> <span>SimpleRetryPolicy</span><span>(</span><span>)</span><span>;</span> <span>//设置重试策略</span>\n        retryPolicy<span>.</span><span>setMaxAttempts</span><span>(</span><span>2</span><span>)</span><span>;</span>\n        retryTemplate<span>.</span><span>setRetryPolicy</span><span>(</span>retryPolicy<span>)</span><span>;</span>\n\n        <span>FixedBackOffPolicy</span> fixedBackOffPolicy <span>=</span> <span>new</span> <span>FixedBackOffPolicy</span><span>(</span><span>)</span><span>;</span> <span>//设置退避策略</span>\n        fixedBackOffPolicy<span>.</span><span>setBackOffPeriod</span><span>(</span><span>2000L</span><span>)</span><span>;</span>\n        retryTemplate<span>.</span><span>setBackOffPolicy</span><span>(</span>fixedBackOffPolicy<span>)</span><span>;</span>\n        \n        retryTemplate<span>.</span><span>registerListener</span><span>(</span><span>new</span> <span>DefaultListenerSupport</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>//设置retryListener</span>\n        <span>return</span> retryTemplate<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><h3 id=\"_3-6-retrypolicy-重试策略\"> 3.6 RetryPolicy 重试策略</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">属性</th>\n<th style=\"text-align:left\">意思</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">NeverRetryPolicy</td>\n<td style=\"text-align:left\">只允许调用RetryCallback一次，不允许重试；</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">AlwaysRetryPolicy</td>\n<td style=\"text-align:left\">允许无限重试，直到成功，此方式逻辑不当会导致死循环；</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">SimpleRetryPolicy</td>\n<td style=\"text-align:left\">固定次数重试策略，默认重试最大次数为3次，RetryTemplate默认使用的策略；</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">TimeoutRetryPolicy</td>\n<td style=\"text-align:left\">超时时间重试策略，默认超时时间为1秒，在指定的超时时间内允许重试；</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CircuitBreakerRetryPolicy</td>\n<td style=\"text-align:left\">有熔断功能的重试策略，需设置3个参数openTimeout、resetTimeout和delegate</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CompositeRetryPolicy</td>\n<td style=\"text-align:left\">组合重试策略，有两种组合方式，乐观组合重试策略是指只要有一个策略允许重试即可以，悲观组合重试策略是指只要有一个策略不允许重试即可以，但不管哪种组合方式，组合中的每一个策略都会执行。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_3-7-backoffpolicy-退避策略\"> 3.7 BackOffPolicy 退避策略</h3>\n<p>下一次重试的策略。\n退避是指怎么去做下一次的重试，在这里其实就是等待多长时间。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">属性</th>\n<th style=\"text-align:left\">意思</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">FixedBackOffPolicy</td>\n<td style=\"text-align:left\">默认固定延迟1秒后执行下一次重试</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ExponentialBackOffPolicy</td>\n<td style=\"text-align:left\">指数递增延迟执行重试，默认初始0.1秒，系数是2，那么下次延迟0.2秒，再下次就是延迟0.4秒，如此类推，最大30秒。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ExponentialRandomBackOffPolicy</td>\n<td style=\"text-align:left\">在上面那个策略上增加随机性</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">UniformRandomBackOffPolicy</td>\n<td style=\"text-align:left\">这个跟上面的区别就是，上面的延迟会不停递增，这个只会在固定的区间随机</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">StatelessBackOffPolicy</td>\n<td style=\"text-align:left\">这个说明是无状态的，所谓无状态就是对上次的退避无感知，从它下面的子类也能看出来</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"四、总结\"> 四、总结</h2>\n<p>天下代码一大抄，看你会抄不会抄。发现无论是guava还是spring的重试，基本都是类似的思路。只是看谁的功能比较鉴权而已。\nguava提供了基础的能力，你任意封装。\nspring基于spring提供了已经完好的能力，直接使用就好。不过因为是spring给你封装的能力，所以你要先了解清楚才行。不然可能使用错误，造成故障。</p>\n<p>以上两款工具都挺好，不过他们都不支持分布式重试的能力。不过这已经满足我们的日常开发了，如果真遇到分布式的重试，就自己来实现咯。</p>\n",
      "image": "https://img.shields.io/badge/%E4%BB%93%E5%BA%93-spring--retry--example-green",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Guava-cache",
      "url": "https://java.springlearn.cn/learn/tools/guava/guava-cache/",
      "id": "https://java.springlearn.cn/learn/tools/guava/guava-cache/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/blog/learn_1588264022000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>本篇主要是本地缓存代码实战，提供业务中常用的本地缓存使用代码片段(直接跳过看标题五)</strong></p>\n<div><p>写在前面</p>\n<p>常在业务系统中做开发,不会点高级知识点,有点不好意思了。在业务系统中，提高系统响应速度，提供系统高并发能力，其实方向很简单，三个方向,六个字而已: <strong>缓存降级限流。</strong>\n当然这是在排除代码质量非常差的情况，如果代码质量很差，都是while循环和高内存占用，那么其实再怎么做都于事无补。除非你有一个马云爸爸，性能不够，机器来凑嘛。阿里云前来支持(1000台机器够了吗?)</p>\n</div>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/182855/1588128723239-12cbd329-ab03-4e8c-86be-fd63da9cb39f.png?x-oss-process=image%2Fresize%2Cw_1492\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"一、什么是guava-cache\"> 一、什么是Guava Cache</h2>\n<div><pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;\n    &lt;artifactId&gt;guava&lt;/artifactId&gt;\n    &lt;version&gt;29.0-jre&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>其实就是Google提供的一个开发工具包,里面有很多好用的Java开工具,比如我们本文将的Cache缓存能力。\n说到缓存,每个业务系统中现在都会用到缓存,常用的缓存数据库就是Redis和Memcache,这两款kv数据库最常用的场景就是当缓存使用，极其适合在微服务架构下做缓存使用。速度是极高的，但是跟本地缓存来比，还是算慢的，毕竟本地缓存其实就相当于一个Map集合，本地缓存获取没有网络IO。但是最大的缺点是每台服务器的本地缓存是不能共享的。所以如果要用分布式缓存就可以跳过了。因为本文将的本地缓存使用。</p>\n<p>说到底其实缓存我们就可以理解为是一个Map集合，不过生产中我们不能用Map来做缓存，除非是缓存的数据只有一点点一点点。否则如果数据量瞬时或者数据积累量很大，很容易就直接就把Map撑爆。导致内存溢出,服务宕机下线风险。 所以我们必须要对Map做控制。</p>\n<ol>\n<li>控制数据量大小</li>\n<li>控制数据生命周期</li>\n<li>如果能做些数据命中率统计更好了</li>\n</ol>\n<p>对，以上就是Guava Cache已经为我们做好的能力了。我们只用使用就可以了</p>\n<h2 id=\"二、什么场景适合缓存\"> 二、什么场景适合缓存</h2>\n<p>不长更新的数据都可以使用缓存，只要我们定时去刷新缓存获取最新的数据就可以了。\n注意: 凡是使用GuavaCache的地方都可以使用RedisCache,但是使用RedisCache的地方不一定可以使用GuavaCache。因为前面我们也说了Guava是本地缓存，不支持多服务器数据共享,如果要共享缓存数据直接用Redis是更好的选择。</p>\n<h2 id=\"三、使用本地缓存-高并发会把机器打爆\"> 三、使用本地缓存,高并发会把机器打爆</h2>\n<p>这个担心是逻辑思考的必然,使用缓存主要是提高系统响应效率的,如果用不过把机器搞爆就不好了。所以这种担心很有必要，但是只要弄清楚没参数或者它的实现原理就不用担心了。4和5是快速入门即代码片段，直接根据代码去做不会有问题。</p>\n<h2 id=\"四、快速入门api\"> 四、快速入门API</h2>\n<p>CacheBuilder</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>作用</th>\n<th>例子</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>removalListener</td>\n<td>缓存移除的监听</td>\n<td>对指定key的删除,做监听</td>\n</tr>\n<tr>\n<td>maximumSize</td>\n<td>设置最大缓存数量</td>\n<td>当达到最大数量，会删除多余的缓存记录</td>\n</tr>\n<tr>\n<td>expireAfterWrite</td>\n<td>设置过期时间</td>\n<td>过期的缓存自动移除</td>\n</tr>\n<tr>\n<td>recordStats</td>\n<td>统计信息</td>\n<td>统计缓存命中率</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_1-设置最大缓存数量\"> 1. 设置最大缓存数量</h3>\n<div><pre><code>    <span>Cache</span><span><span>&lt;</span><span>String</span><span>,</span><span>String</span><span>></span></span> cache <span>=</span> <span>CacheBuilder</span><span>.</span><span>newBuilder</span><span>(</span><span>)</span>\n                                 <span>.</span><span>maximumSize</span><span>(</span><span>2</span><span>)</span><span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>\n    cache<span>.</span><span>put</span><span>(</span><span>\"key1\"</span><span>,</span><span>\"value1\"</span><span>)</span><span>;</span>\n    cache<span>.</span><span>put</span><span>(</span><span>\"key2\"</span><span>,</span><span>\"value2\"</span><span>)</span><span>;</span>\n    cache<span>.</span><span>put</span><span>(</span><span>\"key3\"</span><span>,</span><span>\"value3\"</span><span>)</span><span>;</span>\n    <span>// 第一个key是null，因为指定缓存数量是2个，当超过就删除前面一条</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"第一个值:\"</span> <span>+</span> cache<span>.</span><span>getIfPresent</span><span>(</span><span>\"key1\"</span><span>)</span><span>)</span><span>;</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"第一个值:\"</span> <span>+</span> cache<span>.</span><span>getIfPresent</span><span>(</span><span>\"key2\"</span><span>)</span><span>)</span><span>;</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"第一个值:\"</span> <span>+</span> cache<span>.</span><span>getIfPresent</span><span>(</span><span>\"key3\"</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"_2-设置过期时间\"> 2. 设置过期时间</h3>\n<div><pre><code>    <span>Cache</span><span><span>&lt;</span><span>String</span><span>,</span><span>String</span><span>></span></span> cache <span>=</span> <span>CacheBuilder</span><span>.</span><span>newBuilder</span><span>(</span><span>)</span>\n                                 <span>.</span><span>maximumSize</span><span>(</span><span>2</span><span>)</span>\n                                 <span>.</span><span>expireAfterWrite</span><span>(</span><span>3</span><span>,</span><span>TimeUnit</span><span>.</span>SECONDS<span>)</span>\n                                     <span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>\n    cache<span>.</span><span>put</span><span>(</span><span>\"key1\"</span><span>,</span><span>\"value1\"</span><span>)</span><span>;</span>\n    <span>int</span> time <span>=</span> <span>1</span><span>;</span>\n    <span>while</span><span>(</span><span>true</span><span>)</span><span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"第\"</span> <span>+</span> time <span>++</span> <span>\"次取到的key1的值为：\"</span> <span>+</span> cache<span>.</span><span>getIfPresent</span><span>(</span><span>\"key1\"</span><span>)</span><span>)</span><span>;</span>\n        <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>1000</span><span>)</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id=\"_3-统计命中率\"> 3. 统计命中率</h3>\n<div><pre><code>    <span>Cache</span><span><span>&lt;</span><span>String</span><span>,</span><span>String</span><span>></span></span> cache <span>=</span> <span>CacheBuilder</span><span>.</span><span>newBuilder</span><span>(</span><span>)</span>\n                                 <span>.</span><span>maximumSize</span><span>(</span><span>3</span><span>)</span>\n                                 <span>.</span><span>recordStats</span><span>(</span><span>)</span>\n                                     <span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>\n    cache<span>.</span><span>put</span><span>(</span><span>\"key1\"</span><span>,</span><span>\"value1\"</span><span>)</span><span>;</span>\n    cache<span>.</span><span>put</span><span>(</span><span>\"key2\"</span><span>,</span><span>\"value2\"</span><span>)</span><span>;</span>\n    cache<span>.</span><span>put</span><span>(</span><span>\"key3\"</span><span>,</span><span>\"value3\"</span><span>)</span><span>;</span>\n    \n    cache<span>.</span><span>getIfPresent</span><span>(</span><span>\"key1\"</span><span>)</span>\n    cache<span>.</span><span>getIfPresent</span><span>(</span><span>\"key1\"</span><span>)</span>\n    cache<span>.</span><span>getIfPresent</span><span>(</span><span>\"key2\"</span><span>)</span>\n    cache<span>.</span><span>getIfPresent</span><span>(</span><span>\"key3\"</span><span>)</span>\n    <span>// 获取统计信息</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>cache<span>.</span><span>stats</span><span>(</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p><strong>CacheStats</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">属性值</th>\n<th style=\"text-align:left\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">requestCount</td>\n<td style=\"text-align:left\">返回cache查找缓存的次数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">hitCount</td>\n<td style=\"text-align:left\">命中缓存的次数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">missCount</td>\n<td style=\"text-align:left\">未命中缓存的次数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">missRate</td>\n<td style=\"text-align:left\">返回缓存请求未命中的比率，未命中次数除以请求次数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">loadCount</td>\n<td style=\"text-align:left\">返回缓存调用load方法加载新值的次数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">loadSuccessCount</td>\n<td style=\"text-align:left\">返回缓存加载新值的成功次数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">loadExceptionCount</td>\n<td style=\"text-align:left\">返回缓存加载新值出现异常的次数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">loadExceptionRate</td>\n<td style=\"text-align:left\">返回缓存加载新值出现异常的比率</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">totalLoadTime</td>\n<td style=\"text-align:left\">返回缓存加载新值所耗费的总时间</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">averageLoadPenalty</td>\n<td style=\"text-align:left\">缓存加载新值的耗费的平均时间，加载的次数除以加载的总时间</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">evictionCount</td>\n<td style=\"text-align:left\">返回缓存中条目被移除的次数</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"五、代码片段\"> 五、代码片段</h2>\n<div><pre><code>    <span>private</span> <span>LoadingCache</span><span><span>&lt;</span><span>Long</span><span>,</span><span>UserInfoDTO</span><span>></span></span> userCache<span>;</span>\n    \n    <span>{</span>\n        userCache <span>=</span>  <span>CacheBuilder</span><span>.</span><span>newBuilder</span><span>(</span><span>)</span><span>.</span><span>maximumSize</span><span>(</span><span>30</span><span>)</span><span>//缓存30条数据</span>\n                <span>.</span><span>expireAfterWrite</span><span>(</span><span>10</span><span>,</span><span>TimeUnit</span><span>.</span>SECONDS<span>)</span> <span>// 缓存时间10s</span>\n                    <span>.</span><span>build</span><span>(</span><span>// 缓存加载器，如果没有找到key,就去加载这个key到缓存中</span>\n                <span>new</span> <span>CacheLoader</span><span><span>&lt;</span><span>Long</span><span>,</span><span>UserInfoDTO</span><span>></span></span><span>(</span><span>)</span><span>{</span>\n                    <span>@Override</span>\n                    <span>public</span> <span>UserInfoDTO</span> <span>load</span><span>(</span><span>Long</span> key<span>)</span> <span>throws</span> <span>Exception</span><span>{</span>\n                        <span>return</span> userService<span>.</span><span>queryById</span><span>(</span>key<span>)</span><span>;</span>\n                    <span>}</span>\n                <span>}</span>\n            <span>)</span>\n    <span>}</span>\n    \n    <span>public</span> <span>UserInfoDTO</span> <span>queryUserInfoByIdFromCache</span><span>(</span><span>Long</span> userId<span>)</span><span>{</span>\n        <span>return</span> userCache<span>.</span><span>get</span><span>(</span>userId<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div>",
      "image": "https://img.springlearn.cn/blog/learn_1588264022000.png",
      "date_published": "2022-03-27T13:12:51.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Java Object 内存布局",
      "url": "https://java.springlearn.cn/learn/tools/jol/",
      "id": "https://java.springlearn.cn/learn/tools/jol/",
      "content_html": "<p><a href=\"https://blog.csdn.net/uuqaz/article/details/123340729\" target=\"_blank\" rel=\"noopener noreferrer\">参考链接</a></p>\n",
      "date_published": "2022-05-29T13:46:15.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "JMH基准测试",
      "url": "https://java.springlearn.cn/learn/tools/jmh/",
      "id": "https://java.springlearn.cn/learn/tools/jmh/",
      "content_html": "<p><a href=\"https://www.zhihu.com/question/276455629/answer/1259967560\" target=\"_blank\" rel=\"noopener noreferrer\">参考链接</a></p>\n<p><a href=\"http://openjdk.java.net/projects/code-tools/jmh/\" target=\"_blank\" rel=\"noopener noreferrer\">官方文档</a></p>\n<p><a href=\"https://www.bbsmax.com/A/qVdeEr01dP/\" target=\"_blank\" rel=\"noopener noreferrer\">性能调优必备利器之 JMH</a></p>\n<h2 id=\"一、jmh\"> 一、JMH</h2>\n<p>JMH即Java Microbenchmark Harness，是Java用来做基准测试的一个工具，该工具由OpenJDK提供并维护，测试结果可信度高。</p>\n<p>基准测试Benchmark是测量、评估软件性能指标的一种测试，对某个特定目标场景的某项性能指标进行定量的和可对比的测试。</p>\n<h2 id=\"_1-1-为什么要用jmh\"> 1.1 为什么要用JMH</h2>\n<p>if 快还是 switch 快？HashMap 的初始化 size 要不要指定，指定之后性能可以提高多少？各种序列化方法哪个耗时更短？</p>\n<p>无论出自何种原因需要进行性能评估，量化指标总是必要的。</p>\n<p>在大部分场合，简单地回答谁快谁慢是远远不够的，如何将程序<code>性能量化</code>呢？</p>\n<p>这就需要我们的主角 JMH 登场了！</p>\n<h2 id=\"二、前期准备\"> 二、前期准备</h2>\n<h2 id=\"_2-1-引入依赖\"> 2.1 引入依赖</h2>\n<div><pre><code><span><span><span>&lt;</span>dependencies</span><span>></span></span>\n    <span><span><span>&lt;</span>dependency</span><span>></span></span>\n        <span><span><span>&lt;</span>groupId</span><span>></span></span>org.openjdk.jmh<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n        <span><span><span>&lt;</span>artifactId</span><span>></span></span>jmh-core<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n        <span><span><span>&lt;</span>version</span><span>></span></span>1.23<span><span><span>&lt;/</span>version</span><span>></span></span>\n    <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n \n    <span><span><span>&lt;</span>dependency</span><span>></span></span>\n        <span><span><span>&lt;</span>groupId</span><span>></span></span>org.openjdk.jmh<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n        <span><span><span>&lt;</span>artifactId</span><span>></span></span>jmh-generator-annprocess<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n        <span><span><span>&lt;</span>version</span><span>></span></span>1.23<span><span><span>&lt;/</span>version</span><span>></span></span>\n    <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n<span><span><span>&lt;/</span>dependencies</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id=\"_2-2-安装插件\"> 2.2 安装插件</h2>\n<p><a href=\"https://plugins.jetbrains.com/plugin/7529-jmh-java-microbenchmark-harness\" target=\"_blank\" rel=\"noopener noreferrer\">jmh-java-microbenchmark-harness</a></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1653405994000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>当安装插件后,只要被<code>@Benchmark</code>就会认为是一个test方法,出现执行按钮\n<img src=\"https://img.springlearn.cn/blog/learn_1653405953000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>当然也可以不安装插件,如下代码也会进行输出</p>\n<div><pre><code>    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>Options</span> opt <span>=</span> <span>new</span> <span>OptionsBuilder</span><span>(</span><span>)</span>\n                <span>.</span><span>include</span><span>(</span><span>BenchmarkTest</span><span>.</span><span>class</span><span>.</span><span>getSimpleName</span><span>(</span><span>)</span><span>)</span>\n                <span>.</span><span>resultFormat</span><span>(</span><span>ResultFormatType</span><span>.</span>JSON<span>)</span>\n                <span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>\n        <span>new</span> <span>Runner</span><span>(</span>opt<span>)</span><span>.</span><span>run</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id=\"三、使用说明\"> 三、使用说明</h2>\n<p>在正式使用前,先介绍下JMH基准测试中可以使用的注解。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1653716179000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"_3-1-benchmarkmode\"> 3.1 @BenchmarkMode</h2>\n<p>用来配置 Mode 选项，可用于类或者方法上，这个注解的 value 是一个数组，可以把几种 Mode 集合在一起执行，如：@BenchmarkMode({Mode.SampleTime, Mode.AverageTime})，还可以设置为 Mode.All，即全部执行一遍。</p>\n<ol>\n<li>Throughput：整体吞吐量，每秒执行了多少次调用，单位为 ops/time</li>\n<li>AverageTime：用的平均时间，每次操作的平均时间，单位为 time/op</li>\n<li>SampleTime：随机取样，最后输出取样结果的分布</li>\n<li>SingleShotTime：只运行一次，往往同时把 Warmup 次数设为 0，用于测试冷启动时的性能</li>\n<li>All：上面的所有模式都执行一次</li>\n</ol>\n<h2 id=\"_3-2-state\"> 3.2 @State</h2>\n<p>通过 State 可以指定一个对象的作用范围，JMH 根据 scope 来进行实例化和共享操作。@State 可以被继承使用，如果父类定义了该注解，子类则无需定义。由于 JMH 允许多线程同时执行测试，不同的选项含义如下</p>\n<ol>\n<li>Scope.Benchmark：所有测试线程共享一个实例，测试有状态实例在多线程共享下的性能</li>\n<li>Scope.Group：同一个线程在同一个 group 里共享实例</li>\n<li>Scope.Thread：默认的 State，每个测试线程分配一个实例</li>\n</ol>\n<h2 id=\"_3-3-outputtimeunit\"> 3.3 @OutputTimeUnit</h2>\n<p>为统计结果的时间单位，可用于类或者方法注解</p>\n<h2 id=\"_3-4-warmup\"> 3.4 @Warmup</h2>\n<p>预热所需要配置的一些基本测试参数，可用于类或者方法上。一般前几次进行程序测试的时候都会比较慢，所以要让程序进行几轮预热，保证测试的准确性。参数如下所示：</p>\n<ol>\n<li>iterations：预热的次数</li>\n<li>time：每次预热的时间</li>\n<li>timeUnit：时间的单位，默认秒</li>\n<li>batchSize：批处理大小，每次操作调用几次方法</li>\n</ol>\n<p>为什么需要预热？</p>\n<blockquote>\n<p>因为 JVM 的 JIT 机制的存在，如果某个函数被调用多次之后，JVM 会尝试将其编译为机器码，从而提高执行速度，所以为了让 benchmark 的结果更加接近真实情况就需要进行预热。</p>\n</blockquote>\n<h2 id=\"_3-5-measurement\"> 3.5 @Measurement</h2>\n<p>实际调用方法所需要配置的一些基本测试参数，可用于类或者方法上，参数和 @Warmup 相同。</p>\n<ol>\n<li>iterations：执行的次数</li>\n<li>time：每次执行时间</li>\n<li>timeUnit：时间的单位，默认秒</li>\n<li>batchSize：批处理大小，每次操作调用几次方法</li>\n</ol>\n<h2 id=\"_3-6-threads\"> 3.6 @Threads</h2>\n<p>配置同时起多少个线程执行，默认值世 Runtime.getRuntime().availableProcessors()</p>\n<h2 id=\"_3-7-fork\"> 3.7 @Fork</h2>\n<p>进行 fork 的次数，可用于类或者方法上。如果 fork 数是 2 的话，则 JMH 会 fork 出两个进程来进行测试。</p>\n<h2 id=\"_3-8-param\"> 3.8 @Param</h2>\n<p>指定某项参数的多种情况，特别适合用来测试一个函数在不同的参数输入的情况下的性能，只能作用在字段上，使用该注解必须定义 @State 注解。</p>\n<h2 id=\"四、场景案例\"> 四、场景案例</h2>\n<ul>\n<li><a href=\"https://jmh.morethan.io/\" target=\"_blank\" rel=\"noopener noreferrer\">可视化分析平台</a></li>\n<li><a href=\"http://deepoove.com/jmh-visual-chart/\" target=\"_blank\" rel=\"noopener noreferrer\">JMH Visual Chart</a></li>\n</ul>\n<h2 id=\"_4-1-for循环性能\"> 4.1 for循环性能</h2>\n<p>循环100w次,并输出。预热2次,执行2次,2个线程,1个进程,统计结果单位毫秒。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1653717279000.png\" alt=\"\" loading=\"lazy\"></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">方法</th>\n<th style=\"text-align:center\">平均耗时</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">普通for循环</td>\n<td style=\"text-align:center\">7898ms</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">增强for循环</td>\n<td style=\"text-align:center\">8078ms</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">迭代器</td>\n<td style=\"text-align:center\">8314ms</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Stream循环</td>\n<td style=\"text-align:center\">9085ms</td>\n</tr>\n</tbody>\n</table>\n<div><pre><code>\n<span>import</span> <span>org<span>.</span>openjdk<span>.</span>jmh<span>.</span>annotations<span>.</span></span><span>*</span><span>;</span>\n<span>import</span> <span>org<span>.</span>openjdk<span>.</span>jmh<span>.</span>results<span>.</span>format<span>.</span></span><span>ResultFormatType</span><span>;</span>\n<span>import</span> <span>org<span>.</span>openjdk<span>.</span>jmh<span>.</span>runner<span>.</span></span><span>Runner</span><span>;</span>\n<span>import</span> <span>org<span>.</span>openjdk<span>.</span>jmh<span>.</span>runner<span>.</span>options<span>.</span></span><span>Options</span><span>;</span>\n<span>import</span> <span>org<span>.</span>openjdk<span>.</span>jmh<span>.</span>runner<span>.</span>options<span>.</span></span><span>OptionsBuilder</span><span>;</span>\n\n<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>ArrayList</span><span>;</span>\n<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Iterator</span><span>;</span>\n<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>List</span><span>;</span>\n<span>import</span> <span>java<span>.</span>util<span>.</span>concurrent<span>.</span></span><span>TimeUnit</span><span>;</span>\n\n<span>@BenchmarkMode</span><span>(</span><span>Mode<span>.</span>AverageTime</span><span>)</span>\n<span>@OutputTimeUnit</span><span>(</span><span>TimeUnit</span><span>.</span>MILLISECONDS<span>)</span>\n<span>@Warmup</span><span>(</span>iterations <span>=</span> <span>2</span><span>)</span>\n<span>@Measurement</span><span>(</span>iterations <span>=</span> <span>2</span><span>)</span>\n<span>@Threads</span><span>(</span><span>2</span><span>)</span>\n<span>@Fork</span><span>(</span><span>1</span><span>)</span>\n<span>@State</span><span>(</span><span>Scope<span>.</span>Thread</span><span>)</span>\n<span>public</span> <span>class</span> <span>ForBenchmarkTest</span> <span>{</span>\n\n    <span>private</span> <span>static</span> <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> integers<span>;</span>\n\n    <span>static</span> <span>{</span>\n        integers <span>=</span> <span>generate</span><span>(</span><span>1000000</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>private</span> <span>static</span> <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> <span>generate</span><span>(</span><span>Integer</span> max<span>)</span> <span>{</span><span>2</span>\n        <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> result <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span>max<span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> max<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            result<span>.</span><span>add</span><span>(</span>i<span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> result<span>;</span>\n    <span>}</span>\n\n    <span>@Benchmark</span>\n    <span>public</span> <span>void</span> <span>forTest</span><span>(</span><span>)</span> <span>{</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> integers<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>integers<span>.</span><span>get</span><span>(</span>i<span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>@Benchmark</span>\n    <span>public</span> <span>void</span> <span>forEachTest</span><span>(</span><span>)</span> <span>{</span>\n        <span>for</span> <span>(</span><span>Integer</span> integer <span>:</span> integers<span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>integer<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>@Benchmark</span>\n    <span>public</span> <span>void</span> <span>iteratorTest</span><span>(</span><span>)</span> <span>{</span>\n        <span>Iterator</span><span><span>&lt;</span><span>Integer</span><span>></span></span> iterator <span>=</span> integers<span>.</span><span>iterator</span><span>(</span><span>)</span><span>;</span>\n        <span>while</span> <span>(</span>iterator<span>.</span><span>hasNext</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>iterator<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>@Benchmark</span>\n    <span>public</span> <span>void</span> <span>streamForEachTest</span><span>(</span><span>)</span> <span>{</span>\n        integers<span>.</span><span>forEach</span><span>(</span><span>System</span><span>.</span>out<span>::</span><span>println</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>Options</span> opt <span>=</span> <span>new</span> <span>OptionsBuilder</span><span>(</span><span>)</span>\n                <span>.</span><span>include</span><span>(</span><span>ForBenchmarkTest</span><span>.</span><span>class</span><span>.</span><span>getSimpleName</span><span>(</span><span>)</span><span>)</span>\n                <span>.</span><span>resultFormat</span><span>(</span><span>ResultFormatType</span><span>.</span>JSON<span>)</span>\n                <span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>\n        <span>new</span> <span>Runner</span><span>(</span>opt<span>)</span><span>.</span><span>run</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br></div></div><h2 id=\"_4-2-反射性能\"> 4.2 反射性能</h2>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1653719819000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>通过上面数据可以得到。反射缺失很耗时。开启安全检查比不开启耗时, 如果反射在加上缓存,会比较好一点。</p>\n<ul>\n<li>metaClass1k 是1k次操作，反射+缓存</li>\n<li>metaClass1w 是1w次操作，反射+缓存</li>\n<li>test1k 是1k次正常操作</li>\n<li>test1w 是1w次正常操作</li>\n<li>testReflection1k 是1k次操作，反射</li>\n<li>testReflection1w 是1w次操作，反射</li>\n<li>testReflectionAccessible1k 是1k次操作，反射，关闭安全检查</li>\n<li>testReflectionAccessible1k 是1w次操作，反射，关闭安全检查</li>\n</ul>\n<div><pre><code><span>@BenchmarkMode</span><span>(</span><span>Mode<span>.</span>AverageTime</span><span>)</span>\n<span>@OutputTimeUnit</span><span>(</span><span>TimeUnit</span><span>.</span>SECONDS<span>)</span>\n<span>@Warmup</span><span>(</span>iterations <span>=</span> <span>5</span><span>,</span> time <span>=</span> <span>1</span><span>)</span>\n<span>@Measurement</span><span>(</span>iterations <span>=</span> <span>10</span><span>,</span> time <span>=</span> <span>1</span><span>)</span>\n<span>@Threads</span><span>(</span><span>2</span><span>)</span>\n<span>@Fork</span><span>(</span><span>1</span><span>)</span>\n<span>@State</span><span>(</span><span>Scope<span>.</span>Thread</span><span>)</span>\n<span>public</span> <span>class</span> <span>ReflectionBenchmarkTest</span> <span>{</span>\n\n    <span>private</span> <span>static</span> <span>class</span> <span>Mode</span> <span>{</span>\n        <span>private</span> <span>Integer</span> age<span>;</span>\n\n        <span>public</span> <span>void</span> <span>setAge</span><span>(</span><span>Integer</span> age<span>)</span> <span>{</span>\n            <span>this</span><span>.</span>age <span>=</span> age<span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>@Benchmark</span>\n    <span>public</span> <span>void</span> <span>test1k</span><span>(</span><span>)</span> <span>{</span>\n        <span>Mode</span> mode <span>=</span> <span>new</span> <span>Mode</span><span>(</span><span>)</span><span>;</span>\n        <span>Loops</span><span>.</span><span>loop</span><span>(</span><span>1000</span><span>,</span> mode<span>::</span><span>setAge</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Benchmark</span>\n    <span>public</span> <span>void</span> <span>testReflection1k</span><span>(</span><span>)</span> <span>{</span>\n        <span>Mode</span> mode <span>=</span> <span>new</span> <span>Mode</span><span>(</span><span>)</span><span>;</span>\n        <span>Loops</span><span>.</span><span>loop</span><span>(</span><span>1000</span><span>,</span> i <span>-></span> <span>{</span>\n            <span>Method</span> setAge <span>=</span> <span>null</span><span>;</span>\n            <span>try</span> <span>{</span>\n                setAge <span>=</span> mode<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getMethod</span><span>(</span><span>\"setAge\"</span><span>,</span> <span>Integer</span><span>.</span><span>class</span><span>)</span><span>;</span>\n                setAge<span>.</span><span>invoke</span><span>(</span>mode<span>,</span> i<span>)</span><span>;</span>\n            <span>}</span> <span>catch</span> <span>(</span><span>Throwable</span> e<span>)</span> <span>{</span>\n                <span>throw</span> <span>new</span> <span>RuntimeException</span><span>(</span>e<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Benchmark</span>\n    <span>public</span> <span>void</span> <span>testReflectionAccessible1k</span><span>(</span><span>)</span> <span>{</span>\n        <span>Mode</span> mode <span>=</span> <span>new</span> <span>Mode</span><span>(</span><span>)</span><span>;</span>\n        <span>Loops</span><span>.</span><span>loop</span><span>(</span><span>1000</span><span>,</span> i <span>-></span> <span>{</span>\n            <span>Method</span> setAge <span>=</span> <span>null</span><span>;</span>\n            <span>try</span> <span>{</span>\n                setAge <span>=</span> mode<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getMethod</span><span>(</span><span>\"setAge\"</span><span>,</span> <span>Integer</span><span>.</span><span>class</span><span>)</span><span>;</span>\n                setAge<span>.</span><span>setAccessible</span><span>(</span><span>true</span><span>)</span><span>;</span>\n                setAge<span>.</span><span>invoke</span><span>(</span>mode<span>,</span> i<span>)</span><span>;</span>\n            <span>}</span> <span>catch</span> <span>(</span><span>Throwable</span> e<span>)</span> <span>{</span>\n                <span>throw</span> <span>new</span> <span>RuntimeException</span><span>(</span>e<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Benchmark</span>\n    <span>public</span> <span>void</span> <span>test1w</span><span>(</span><span>)</span> <span>{</span>\n        <span>Mode</span> mode <span>=</span> <span>new</span> <span>Mode</span><span>(</span><span>)</span><span>;</span>\n        <span>Loops</span><span>.</span><span>loop</span><span>(</span><span>10000</span><span>,</span> mode<span>::</span><span>setAge</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Benchmark</span>\n    <span>public</span> <span>void</span> <span>testReflection1w</span><span>(</span><span>)</span> <span>{</span>\n        <span>Mode</span> mode <span>=</span> <span>new</span> <span>Mode</span><span>(</span><span>)</span><span>;</span>\n        <span>Loops</span><span>.</span><span>loop</span><span>(</span><span>10000</span><span>,</span> i <span>-></span> <span>{</span>\n            <span>Method</span> setAge <span>=</span> <span>null</span><span>;</span>\n            <span>try</span> <span>{</span>\n                setAge <span>=</span> mode<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getMethod</span><span>(</span><span>\"setAge\"</span><span>,</span> <span>Integer</span><span>.</span><span>class</span><span>)</span><span>;</span>\n                setAge<span>.</span><span>invoke</span><span>(</span>mode<span>,</span> i<span>)</span><span>;</span>\n            <span>}</span> <span>catch</span> <span>(</span><span>Throwable</span> e<span>)</span> <span>{</span>\n                <span>throw</span> <span>new</span> <span>RuntimeException</span><span>(</span>e<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Benchmark</span>\n    <span>public</span> <span>void</span> <span>testReflectionAccessible1w</span><span>(</span><span>)</span> <span>{</span>\n        <span>Mode</span> mode <span>=</span> <span>new</span> <span>Mode</span><span>(</span><span>)</span><span>;</span>\n        <span>Loops</span><span>.</span><span>loop</span><span>(</span><span>10000</span><span>,</span> i <span>-></span> <span>{</span>\n            <span>Method</span> setAge <span>=</span> <span>null</span><span>;</span>\n            <span>try</span> <span>{</span>\n                setAge <span>=</span> mode<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getMethod</span><span>(</span><span>\"setAge\"</span><span>,</span> <span>Integer</span><span>.</span><span>class</span><span>)</span><span>;</span>\n                setAge<span>.</span><span>setAccessible</span><span>(</span><span>true</span><span>)</span><span>;</span>\n                setAge<span>.</span><span>invoke</span><span>(</span>mode<span>,</span> i<span>)</span><span>;</span>\n            <span>}</span> <span>catch</span> <span>(</span><span>Throwable</span> e<span>)</span> <span>{</span>\n                <span>throw</span> <span>new</span> <span>RuntimeException</span><span>(</span>e<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Benchmark</span>\n    <span>public</span> <span>void</span> <span>metaClass1k</span><span>(</span><span>)</span> <span>{</span>\n        <span>MetaClass</span> metaClass <span>=</span> <span>MetaClass</span><span>.</span><span>forClass</span><span>(</span><span>Mode</span><span>.</span><span>class</span><span>,</span> <span>new</span> <span>DefaultReflectorFactory</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>Mode</span> mode <span>=</span> <span>new</span> <span>Mode</span><span>(</span><span>)</span><span>;</span>\n        <span>Loops</span><span>.</span><span>loop</span><span>(</span><span>10000</span><span>,</span> i <span>-></span> <span>{</span>\n            <span>try</span> <span>{</span>\n                <span>Invoker</span> setAge <span>=</span> metaClass<span>.</span><span>getSetInvoker</span><span>(</span><span>\"age\"</span><span>)</span><span>;</span>\n                setAge<span>.</span><span>invoke</span><span>(</span>mode<span>,</span> <span>new</span> <span>Object</span><span>[</span><span>]</span><span>{</span>i<span>}</span><span>)</span><span>;</span>\n            <span>}</span> <span>catch</span> <span>(</span><span>Throwable</span> e<span>)</span> <span>{</span>\n                <span>throw</span> <span>new</span> <span>RuntimeException</span><span>(</span>e<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Benchmark</span>\n    <span>public</span> <span>void</span> <span>metaClass1w</span><span>(</span><span>)</span> <span>{</span>\n        <span>MetaClass</span> metaClass <span>=</span> <span>MetaClass</span><span>.</span><span>forClass</span><span>(</span><span>Mode</span><span>.</span><span>class</span><span>,</span> <span>new</span> <span>DefaultReflectorFactory</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>Mode</span> mode <span>=</span> <span>new</span> <span>Mode</span><span>(</span><span>)</span><span>;</span>\n        <span>Loops</span><span>.</span><span>loop</span><span>(</span><span>10000</span><span>,</span> i <span>-></span> <span>{</span>\n            <span>try</span> <span>{</span>\n                <span>Invoker</span> setAge <span>=</span> metaClass<span>.</span><span>getSetInvoker</span><span>(</span><span>\"age\"</span><span>)</span><span>;</span>\n                setAge<span>.</span><span>invoke</span><span>(</span>mode<span>,</span> <span>new</span> <span>Object</span><span>[</span><span>]</span><span>{</span>i<span>}</span><span>)</span><span>;</span>\n            <span>}</span> <span>catch</span> <span>(</span><span>Throwable</span> e<span>)</span> <span>{</span>\n                <span>throw</span> <span>new</span> <span>RuntimeException</span><span>(</span>e<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n    <span>}</span>\n\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>Options</span> opt <span>=</span> <span>new</span> <span>OptionsBuilder</span><span>(</span><span>)</span>\n                <span>.</span><span>include</span><span>(</span><span>ReflectionBenchmarkTest</span><span>.</span><span>class</span><span>.</span><span>getSimpleName</span><span>(</span><span>)</span><span>)</span>\n                <span>.</span><span>resultFormat</span><span>(</span><span>ResultFormatType</span><span>.</span>JSON<span>)</span>\n                <span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>\n        <span>new</span> <span>Runner</span><span>(</span>opt<span>)</span><span>.</span><span>run</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br></div></div>",
      "image": "https://img.springlearn.cn/blog/learn_1653405994000.png",
      "date_published": "2022-05-24T13:52:50.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Guava-retry重试组件",
      "url": "https://java.springlearn.cn/learn/tools/guava/guava-retry/",
      "id": "https://java.springlearn.cn/learn/tools/guava/guava-retry/",
      "content_html": "<h2 id=\"一、简介\"> 一、简介</h2>\n<div><p>Guava-retry</p>\n<p>Guava 是一组来自 Google 的核心 Java 库，其中包括新的集合类型（例如 multimap 和 multiset）、不可变集合、图形库以及用于并发、I/O、散列、缓存、原语、字符串等的实用程序！它广泛用于 Google\n内部的大多数 Java 项目，也被许多其他公司广泛使用。</p>\n<p>API 非常的简单，我们可以非常轻松的使用，来封装成我们业务中自己的组件。</p>\n</div>\n<h2 id=\"二、依赖\"> 二、依赖</h2>\n<div><pre><code>    <span><span><span>&lt;</span>dependency</span><span>></span></span>\n        <span><span><span>&lt;</span>groupId</span><span>></span></span>com.github.rholder<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n        <span><span><span>&lt;</span>artifactId</span><span>></span></span>guava-retrying<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n        <span><span><span>&lt;</span>version</span><span>></span></span>2.0.0<span><span><span>&lt;/</span>version</span><span>></span></span>\n    <span><span><span>&lt;/</span>dependency</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"三、使用\"> 三、使用</h2>\n<h3 id=\"_3-1-指定异常\"> 3.1 指定异常</h3>\n<p>配置如果发生了 <code>Exception</code> 异常进行重试</p>\n<div><div><br><br><div>&nbsp;</div><br><br><br><br><br></div><pre><code>    <span>Retryer</span><span><span>&lt;</span><span>User</span><span>></span></span> retry <span>=</span> <span>RetryerBuilder</span><span>.</span><span><span>&lt;</span><span>User</span><span>></span></span><span>newBuilder</span><span>(</span><span>)</span>\n                <span>//发生ConnectException异常时重试</span>\n                <span>.</span><span>retryIfExceptionOfType</span><span>(</span><span>Exception</span><span>.</span><span>class</span><span>)</span>\n                <span>//重试的等待策略 初始等待1s，每次递增1s。如：第一次1s，第二次2s，第三次3s，以此类推...</span>\n                <span>.</span><span>withWaitStrategy</span><span>(</span><span>WaitStrategies</span><span>.</span><span>incrementingWait</span><span>(</span><span>1</span><span>,</span> <span>TimeUnit</span><span>.</span>SECONDS<span>,</span> <span>1</span><span>,</span> <span>TimeUnit</span><span>.</span>SECONDS<span>)</span><span>)</span>\n                <span>//重试3次后停止</span>\n                <span>.</span><span>withStopStrategy</span><span>(</span><span>StopStrategies</span><span>.</span><span>stopAfterAttempt</span><span>(</span><span>3</span><span>)</span><span>)</span><span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id=\"_3-2-重试策略\"> 3.2 重试策略</h3>\n<p>WaitStrategy 重试策略</p>\n<div><div><br><br><br><br><div>&nbsp;</div><br><br><br></div><pre><code>    <span>Retryer</span><span><span>&lt;</span><span>User</span><span>></span></span> retry <span>=</span> <span>RetryerBuilder</span><span>.</span><span><span>&lt;</span><span>User</span><span>></span></span><span>newBuilder</span><span>(</span><span>)</span>\n                <span>//发生ConnectException异常时重试</span>\n                <span>.</span><span>retryIfExceptionOfType</span><span>(</span><span>Exception</span><span>.</span><span>class</span><span>)</span>\n                <span>//重试的等待策略 初始等待1s，每次递增1s。如：第一次1s，第二次2s，第三次3s，以此类推...</span>\n                <span>.</span><span>withWaitStrategy</span><span>(</span><span>WaitStrategies</span><span>.</span><span>incrementingWait</span><span>(</span><span>1</span><span>,</span> <span>TimeUnit</span><span>.</span>SECONDS<span>,</span> <span>1</span><span>,</span> <span>TimeUnit</span><span>.</span>SECONDS<span>)</span><span>)</span>\n                <span>//重试3次后停止</span>\n                <span>.</span><span>withStopStrategy</span><span>(</span><span>StopStrategies</span><span>.</span><span>stopAfterAttempt</span><span>(</span><span>3</span><span>)</span><span>)</span><span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><table>\n<thead>\n<tr>\n<th>策略</th>\n<th>使用方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>固定策略</td>\n<td>WaitStrategies.fixedWait(10,TimeUnit.SECONDS)</td>\n<td>每10秒执行一次</td>\n</tr>\n<tr>\n<td>随机策略</td>\n<td>WaitStrategies.randomWait(100,TimeUnit.SECONDS)</td>\n<td>0 到 100秒之间随机执行一次</td>\n</tr>\n<tr>\n<td>随机策略</td>\n<td>WaitStrategies.randomWait(10,TimeUnit.SECONDS,20,TimeUnit.SECONDS)</td>\n<td>10 到 20秒之间随机执行一次</td>\n</tr>\n<tr>\n<td>递增策略</td>\n<td>WaitStrategies.incrementingWait(1, TimeUnit.SECONDS, 1, TimeUnit.SECONDS)</td>\n<td>初始等待1s，每次递增1s。如：第一次1s，第二次2s，第三次3s，以此类推...</td>\n</tr>\n<tr>\n<td>异常策略</td>\n<td>WaitStrategies.exceptionWait(...)</td>\n<td>不同的异常返回不同的重试时间</td>\n</tr>\n<tr>\n<td>斐波那契数列策略</td>\n<td>WaitStrategies.fibonacciWait(...)</td>\n<td>1、1、2、3、5、8、13、21类推</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"_3-3-重试监听器\"> 3.3 重试监听器</h3>\n<p>Attempt 代表每次执行动作，可以获取执行次数，打印执行日志</p>\n<div><div><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br></div><pre><code> <span>Retryer</span><span><span>&lt;</span><span>User</span><span>></span></span> retry <span>=</span> <span>RetryerBuilder</span><span>.</span><span><span>&lt;</span><span>User</span><span>></span></span><span>newBuilder</span><span>(</span><span>)</span>\n                <span>//发生ConnectException异常时重试</span>\n                <span>.</span><span>retryIfExceptionOfType</span><span>(</span><span>Exception</span><span>.</span><span>class</span><span>)</span>\n                <span>//重试的等待策略 初始等待1s，每次递增1s。如：第一次1s，第二次2s，第三次3s，以此类推...</span>\n                <span>.</span><span>withWaitStrategy</span><span>(</span><span>WaitStrategies</span><span>.</span><span>incrementingWait</span><span>(</span><span>1</span><span>,</span> <span>TimeUnit</span><span>.</span>SECONDS<span>,</span> <span>1</span><span>,</span> <span>TimeUnit</span><span>.</span>SECONDS<span>)</span><span>)</span>\n                <span>//重试监听器</span>\n                <span>.</span><span>withRetryListener</span><span>(</span><span>new</span> <span>RetryListener</span><span>(</span><span>)</span> <span>{</span>\n                    <span>@Override</span>\n                    <span>public</span> <span><span>&lt;</span><span>V</span><span>></span></span> <span>void</span> <span>onRetry</span><span>(</span><span>Attempt</span><span><span>&lt;</span><span>V</span><span>></span></span> attempt<span>)</span> <span>{</span>\n                        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"重试次数:\"</span> <span>+</span> attempt<span>.</span><span>getAttemptNumber</span><span>(</span><span>)</span><span>)</span><span>;</span>\n                        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"异常:\"</span> <span>+</span> attempt<span>.</span><span>getExceptionCause</span><span>(</span><span>)</span><span>)</span><span>;</span>\n                        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"返回值:\"</span><span>+</span>attempt<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span><span>;</span>\n                    <span>}</span>\n                <span>}</span><span>)</span>\n                <span>//重试3次后停止</span>\n                <span>.</span><span>withStopStrategy</span><span>(</span><span>StopStrategies</span><span>.</span><span>stopAfterAttempt</span><span>(</span><span>10</span><span>)</span><span>)</span><span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id=\"_3-4-停止策略\"> 3.4 停止策略</h3>\n<p>StopStrategy 一般常用的就是重试多少次</p>\n<div><div><br><br><br><br><br><br><div>&nbsp;</div><br></div><pre><code> <span>Retryer</span><span><span>&lt;</span><span>User</span><span>></span></span> retry <span>=</span> <span>RetryerBuilder</span><span>.</span><span><span>&lt;</span><span>User</span><span>></span></span><span>newBuilder</span><span>(</span><span>)</span>\n                <span>//发生ConnectException异常时重试</span>\n                <span>.</span><span>retryIfExceptionOfType</span><span>(</span><span>Exception</span><span>.</span><span>class</span><span>)</span>\n                <span>//重试的等待策略 初始等待1s，每次递增1s。如：第一次1s，第二次2s，第三次3s，以此类推...</span>\n                <span>.</span><span>withWaitStrategy</span><span>(</span><span>WaitStrategies</span><span>.</span><span>incrementingWait</span><span>(</span><span>1</span><span>,</span> <span>TimeUnit</span><span>.</span>SECONDS<span>,</span> <span>1</span><span>,</span> <span>TimeUnit</span><span>.</span>SECONDS<span>)</span><span>)</span>\n                <span>//重试3次后停止</span>\n                <span>.</span><span>withStopStrategy</span><span>(</span><span>StopStrategies</span><span>.</span><span>stopAfterAttempt</span><span>(</span><span>10</span><span>)</span><span>)</span><span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><ul>\n<li>StopAfterDelayStrategy ：设定一个最长允许的执行时间；比如设定最长执行10s，无论任务执行次数，只要重试的时候超出了最长时间，则任务终止，并返回重试异常RetryException；</li>\n<li>NeverStopStrategy ：不停止，用于需要一直轮训直到返回期望结果的情况；</li>\n<li>StopAfterAttemptStrategy ：设定最大重试次数，如果超出最大重试次数则停止重试，并返回重试异常；</li>\n</ul>\n",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "启动缓慢",
      "url": "https://java.springlearn.cn/learn/test/%E5%90%AF%E5%8A%A8%E7%BC%93%E6%85%A2/",
      "id": "https://java.springlearn.cn/learn/test/%E5%90%AF%E5%8A%A8%E7%BC%93%E6%85%A2/",
      "content_html": "<div><p>启动缓慢分析</p>\n<p>当应用中拥有大对象,可能会导致单侧启动比较慢,针对这种问题有不同的解决方案</p>\n</div>\n<h3 id=\"springboot-2-2-解决方案\"> SpringBoot 2.2 解决方案</h3>\n<div><pre><code>spring.main.lazy-initialization = true\n</code></pre>\n<div><span>1</span><br></div></div><p>SpringApplication 会自动添加一个叫 <code>LazyInitializationBeanFactoryPostProcessor</code>的处理器\n<img src=\"https://img.springlearn.cn/blog/learn_1617787733000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"springboot-2-2-以前\"> SpringBoot 2.2 以前</h3>\n<p>给应用上下文提前装载一个类似的处理器,然后通过 <code>BeanFactoryPostProcessor</code> 在容器刷新前循环将 <code>BeanDefinition</code> 声明懒加载</p>\n<div><pre><code><span>public</span> <span>class</span> <span>BeanLazyApplicationContextInitializer</span> <span>implements</span> <span>ApplicationContextInitializer</span><span><span>&lt;</span><span>ConfigurableApplicationContext</span><span>></span></span> <span>{</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>initialize</span><span>(</span><span>ConfigurableApplicationContext</span> applicationContext<span>)</span> <span>{</span>\n        applicationContext<span>.</span><span>addBeanFactoryPostProcessor</span><span>(</span><span>new</span> <span>LazyBeanDefinitionPostProcessor</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>class</span> <span>LazyBeanDefinitionPostProcessor</span> <span>implements</span> <span>BeanFactoryPostProcessor</span><span>,</span> <span>Ordered</span> <span>{</span>\n\n        <span>@Override</span>\n        <span>public</span> <span>void</span> <span>postProcessBeanFactory</span><span>(</span><span>ConfigurableListableBeanFactory</span> beanFactory<span>)</span> <span>throws</span> <span>BeansException</span> <span>{</span>\n            <span>for</span> <span>(</span><span>String</span> beanName <span>:</span> beanFactory<span>.</span><span>getBeanDefinitionNames</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n                <span>BeanDefinition</span> beanDefinition <span>=</span> beanFactory<span>.</span><span>getBeanDefinition</span><span>(</span>beanName<span>)</span><span>;</span>\n                <span>if</span> <span>(</span>beanDefinition <span>instanceof</span> <span>AbstractBeanDefinition</span><span>)</span> <span>{</span>\n                    beanDefinition<span>.</span><span>setLazyInit</span><span>(</span><span>true</span><span>)</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n\n        <span>@Override</span>\n        <span>public</span> <span>int</span> <span>getOrder</span><span>(</span><span>)</span> <span>{</span>\n            <span>return</span> <span>Ordered</span><span>.</span>HIGHEST_PRECEDENCE<span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><div><p>测试引导类配置变更</p>\n<ul>\n<li>@ContextConfiguration 通过容器初始化去新增处理器</li>\n<li>@ActiveProfiles       指定测试环境激活的配置是local</li>\n</ul>\n</div>\n<p>@ContextConfiguration添加处理器</p>\n<div><pre><code><span>@Slf4j</span>\n<span>@ActiveProfiles</span><span>(</span><span>{</span><span>\"local\"</span><span>}</span><span>)</span>\n<span>@ContextConfiguration</span><span>(</span>initializers <span>=</span> <span>{</span><span>BeanLazyApplicationContextInitializer</span><span>.</span><span>class</span><span>}</span><span>)</span>\n<span>// 使用Spring容器引导</span>\n<span>@RunWith</span><span>(</span><span>SpringRunner</span><span>.</span><span>class</span><span>)</span>\n<span>@SpringBootTest</span><span>(</span>classes <span>=</span> <span>{</span><span>CenterProviderApplication</span><span>.</span><span>class</span><span>}</span><span>)</span> <span>// 指定启动类</span>\n<span>public</span> <span>class</span> <span>BaseApplicationTest</span> <span>{</span>\n    \n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"如何确定版本\"> 如何确定版本?</h3>\n<p><code>Idea</code> 中搜索 <code>@SpringApplication</code> 查看所在的包\n<img src=\"https://img.springlearn.cn/blog/learn_1617787113000.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1617787733000.png",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "apache-commons 池化技术",
      "url": "https://java.springlearn.cn/learn/tools/pool2/",
      "id": "https://java.springlearn.cn/learn/tools/pool2/",
      "content_html": "<div><p>羽化而登仙，池化而提效</p>\n<p>本篇文章我们的研究专题是池化技术, 其实所谓池化可以简单理解为缓存。将那些创建比较耗时的对象,缓存起来,放到一个池子里。\n比如数据库连接池，线程池，字符串常量池。这个技术常用于框架类设计。本文教你基于Apache-commons-pool2快速实现一个常量池的设计。</p>\n</div>\n<h2 id=\"一、pool2-四大件\"> 一、Pool2 四大件</h2>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1651339646000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_1-1-新建资源\"> 1.1 新建资源</h3>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1651340254000.png\" alt=\"\" loading=\"lazy\"></p>\n<h3 id=\"_1-2-回收资源\"> 1.2 回收资源</h3>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1651340687000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"二、数据库连接池实战\"> 二、数据库连接池实战</h2>\n<p>我们利用Common Pool2工具 可以使用很少的代码就实现了池化的能力。</p>\n<h2 id=\"_2-2-构建连接工厂\"> 2.2 构建连接工厂</h2>\n<p>可以看到核心方法非常少，开发者只用实现很少方法即可</p>\n<ol>\n<li>makeObject 创建资源</li>\n<li>activateObject 资源被激活时候调用</li>\n<li>passivateObject 资源在回收时候调用</li>\n<li>validateObject 当配置了资源检查时候会在创建和回收时候调用</li>\n<li>destroyObject 资源在销毁时候调用</li>\n</ol>\n<div><pre><code><span>public</span> <span>class</span> <span>PooledConnectFactory</span> <span>implements</span> <span>PooledObjectFactory</span><span><span>&lt;</span><span>Connection</span><span>></span></span> <span>{</span>\n\n\n    <span>/**\n     * 数据库连接\n     */</span>\n    <span>private</span> <span>final</span> <span>String</span> url<span>;</span>\n\n    <span>/**\n     * 用户名\n     */</span>\n    <span>private</span> <span>final</span> <span>String</span> userName<span>;</span>\n\n    <span>/**\n     * 数据密码\n     */</span>\n    <span>private</span> <span>final</span> <span>String</span> password<span>;</span>\n\n    <span>public</span> <span>PooledConnectFactory</span><span>(</span><span>String</span> url<span>,</span> <span>String</span> userName<span>,</span> <span>String</span> password<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>url <span>=</span> url<span>;</span>\n        <span>this</span><span>.</span>userName <span>=</span> userName<span>;</span>\n        <span>this</span><span>.</span>password <span>=</span> password<span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 对象被激活后，会进行调用\n     *\n     * @param pooledObject a {@code PooledObject} wrapping the instance to be activated\n     */</span>\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>activateObject</span><span>(</span><span>PooledObject</span><span><span>&lt;</span><span>Connection</span><span>></span></span> pooledObject<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n    <span>}</span>\n\n    <span>/**\n     * 销毁数据库连接\n     *\n     * @param pooledObject a {@code PooledObject} wrapping the instance to be destroyed\n     * @throws Exception 异常\n     */</span>\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>destroyObject</span><span>(</span><span>PooledObject</span><span><span>&lt;</span><span>Connection</span><span>></span></span> pooledObject<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>Connection</span> connection <span>=</span> pooledObject<span>.</span><span>getObject</span><span>(</span><span>)</span><span>;</span>\n        connection<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 创建一个数据库连接\n     *\n     * @return 数据库连接的池对象包装\n     * @throws Exception 异常\n     */</span>\n    <span>@Override</span>\n    <span>public</span> <span>PooledObject</span><span><span>&lt;</span><span>Connection</span><span>></span></span> <span>makeObject</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>Connection</span> connection <span>=</span> <span>DriverManager</span><span>.</span><span>getConnection</span><span>(</span><span>this</span><span>.</span>url<span>,</span> <span>this</span><span>.</span>userName<span>,</span> <span>this</span><span>.</span>password<span>)</span><span>;</span>\n        <span>return</span> <span>new</span> <span>DefaultPooledObject</span><span><span>&lt;</span><span>></span></span><span>(</span>connection<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 回收资源时候进行调用\n     * @param pooledObject a {@code PooledObject} wrapping the instance to be passivated\n     *\n     * @throws Exception\n     */</span>\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>passivateObject</span><span>(</span><span>PooledObject</span><span><span>&lt;</span><span>Connection</span><span>></span></span> pooledObject<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>@SneakyThrows</span>\n    <span>public</span> <span>boolean</span> <span>validateObject</span><span>(</span><span>PooledObject</span><span><span>&lt;</span><span>Connection</span><span>></span></span> pooledObject<span>)</span> <span>{</span>\n        <span>Connection</span> connection <span>=</span> pooledObject<span>.</span><span>getObject</span><span>(</span><span>)</span><span>;</span>\n        <span>// 如果连接关闭说明已经失效就返回false告诉池子,已经失效,会自动移除</span>\n        <span>return</span> <span>!</span>connection<span>.</span><span>isClosed</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br></div></div><h2 id=\"_2-3-连接池演示\"> 2.3 连接池演示</h2>\n<div><pre><code>    <span>@Test</span>\n    <span>@DisplayName</span><span>(</span><span>\"验证回收对象\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>testReturn</span><span>(</span><span>)</span><span>throws</span> <span>Exception</span><span>{</span>\n        <span>// 1. 构建一个数据连接池化工厂</span>\n        <span>String</span> dbUrl <span>=</span> <span>\"jdbc:mysql://127.0.0.1:3306/test\"</span><span>;</span>\n        <span>String</span> user <span>=</span> <span>\"root\"</span><span>;</span>\n        <span>String</span> pass <span>=</span> <span>\"123456\"</span><span>;</span>\n        <span>PooledConnectFactory</span> pooledConnectFactory <span>=</span> <span>new</span> <span>PooledConnectFactory</span><span>(</span>dbUrl<span>,</span> user<span>,</span> pass<span>)</span><span>;</span>\n\n        <span>// 2. 给池子添加支持的配置信息</span>\n        <span>GenericObjectPoolConfig</span><span><span>&lt;</span><span>Connection</span><span>></span></span> config <span>=</span> <span>new</span> <span>GenericObjectPoolConfig</span><span><span>&lt;</span><span>Connection</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        <span>// 2.1 最大池化对象数量</span>\n        config<span>.</span><span>setMaxTotal</span><span>(</span><span>5</span><span>)</span><span>;</span>\n        <span>// 2.2 最大空闲池化对象数量</span>\n        config<span>.</span><span>setMaxIdle</span><span>(</span><span>2</span><span>)</span><span>;</span>\n        <span>// 2.3 最小空闲池化对象数量</span>\n        config<span>.</span><span>setMinIdle</span><span>(</span><span>2</span><span>)</span><span>;</span>\n        <span>// 2.4 间隔多久检查一次池化对象状态,驱逐空闲对象,检查最小空闲数量小于就创建</span>\n        config<span>.</span><span>setTimeBetweenEvictionRuns</span><span>(</span><span>Duration</span><span>.</span><span>ofSeconds</span><span>(</span><span>5</span><span>)</span><span>)</span><span>;</span>\n        <span>// 2.5 阻塞就报错</span>\n        config<span>.</span><span>setBlockWhenExhausted</span><span>(</span><span>true</span><span>)</span><span>;</span>\n        <span>// 2.6 最大等待时长超过5秒就报错,如果不配置一直进行等待</span>\n        config<span>.</span><span>setMaxWait</span><span>(</span><span>Duration</span><span>.</span><span>ofSeconds</span><span>(</span><span>5</span><span>)</span><span>)</span><span>;</span>\n        <span>// 2.7 是否开启jmx监控,默认开启</span>\n        config<span>.</span><span>setJmxEnabled</span><span>(</span><span>true</span><span>)</span><span>;</span>\n        <span>// 2.8 一定要符合命名规则,否则无效</span>\n        config<span>.</span><span>setJmxNameBase</span><span>(</span><span>\"org.apache.commons.pool2:type=MysqlConnObjectPool,name=ConnectJmxNameBase\"</span><span>)</span><span>;</span>\n        <span>// 生成数据库连接池</span>\n        <span>// 连接池配置最大5个连接setMaxTotal(5),但是获取6次,那么有一次获取不到就会阻塞setBlockWhenExhausted(true),</span>\n        <span>// 当等待了10秒setMaxWait(Duration.ofSeconds(10))还是获取不到。就直接报错</span>\n        <span>try</span> <span>(</span><span>GenericObjectPool</span><span><span>&lt;</span><span>Connection</span><span>></span></span> connPool <span>=</span> <span>new</span> <span>GenericObjectPool</span><span><span>&lt;</span><span>></span></span><span>(</span>pooledConnectFactory<span>,</span> config<span>)</span><span>)</span> <span>{</span>\n            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;=</span> <span>7</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n                <span>Connection</span> connection <span>=</span> connPool<span>.</span><span>borrowObject</span><span>(</span><span>)</span><span>;</span>\n                <span>Statement</span> statement <span>=</span> connection<span>.</span><span>createStatement</span><span>(</span><span>)</span><span>;</span>\n                <span>ResultSet</span> show_tables <span>=</span> statement<span>.</span><span>executeQuery</span><span>(</span><span>\"show tables\"</span><span>)</span><span>;</span>\n                <span>printRows</span><span>(</span><span>\"Connect-\"</span> <span>+</span> i <span>+</span> <span>\">\"</span><span>,</span> show_tables<span>)</span><span>;</span>\n                connPool<span>.</span><span>returnObject</span><span>(</span>connection<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><p>甚至还能配置支持jmx管理。非常的简单和方便。</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1651342753000.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1651339646000.png",
      "date_published": "2022-04-26T15:44:59.000Z",
      "date_modified": "2022-08-22T01:35:49.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "字符串常量池",
      "url": "https://java.springlearn.cn/learn/tools/pool2/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0/",
      "id": "https://java.springlearn.cn/learn/tools/pool2/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0/",
      "content_html": "<Djt/>\n<p><strong>本篇课程不来虚的,上来就是干活,现在发车。小编通过代码案例及比喻,带你一窥究竟。</strong></p>\n<h2 id=\"为什么会有常量池的概念\"> 为什么会有常量池的概念?</h2>\n<p>不知道小伙伴们是否有思考过这个问题? 没有思考也无所谓,小编在这里类比一下,大家就会清晰了。\n什么是池? 我们听的最多的池,应该是数据库连接池. 为什么会有数据库连接池,其实就是为了节省资源,提高性能,防止重复创建连接,避免占用内存和网络资源。</p>\n<p>常量池其实就是跟数据库连接池的目的都是一样的。那么他是如何实现的呢? 因为常量池是JVM的概念，源码我们也不好看,所以我们还以连接池来类比,请看下文。</p>\n<h2 id=\"池化的目标就是缓存和管理\"> 池化的目标就是缓存和管理</h2>\n<p>稍微提一点池化的概念,其实就是对资源做一个包装,在包装层来加一些对这个资源的属性信息,比如使用次数,最后操作时间,最长生命周期一样。然后通过后台线程对资源包装层的扫描,来对真实资源的做一个管理。Google的Guava的Cache就是这么做的,我们自己也可以利用 <code>common-pool2</code> 工具包自己来做,或者说池化。</p>\n<h2 id=\"jvm常量池就相当于一个缓存\"> JVM常量池就相当于一个缓存</h2>\n<p>常量就是不会改变的信息,那么既然是不会改变的信息,系统中只存在一份,就可以了。存在多份也是浪费内存资源。然而在Java中只要是new的信息都会在堆上开辟一个新的空间,为了解决这个问题,JVM中才出现了字符串常量池的概念。但是只有直接用<code>&quot;&quot;</code>修饰的字符,才会被加入到常量池中,当再次用<code>&quot;&quot;</code>创建的时候,会首先从常量池中去获取。</p>\n<div><pre><code>String s1 = &quot;1&quot;;\nString s2 = &quot;1&quot;;\n//true\nSystem.out.print(s1==s2); \nString s3 = new String(&quot;1&quot;);\nString s4 = new String(&quot;1&quot;);\n//false\nSystem.out.print(s3==s4); \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>我们可以把常量池理解为一个Map&lt;String,String&gt;做的缓存容器。只不过这个缓存机制是有JVM使用C语言写的。我们看不到而已。</p>\n<h2 id=\"string-intern-的使用\"> String.intern()的使用</h2>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1567773914000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><code>new</code> 出来的 <code>String</code> 类型是否也能使用常量池呢? 当然可以,就是通过 <code>intern</code> 方法\n这个方法的意思就是先到缓存中(也就是常量池中)查询当前对象是否存在,存在就返回常量池中地址,不存在就加入常量池。我们可以用一段伪代码来解释一波。</p>\n<div><pre><code>        //双引号直接放入常量池\n        String s1 = &quot;1&quot;;\n        String s2 = new String(&quot;1&quot;);\n        //false\n        System.out.println(s1 == s2);\n        //先到常量池中查询是否有”1“,存在就将常量池中对象返回,不存在就放到常量池中(此时常量池中存在s1)\n        //于是就将s1的值重新复制给s3,所以s1 == s3\n        String s3 = new String(&quot;1&quot;).intern();\n        //true\n        System.out.println(s1 == s3);\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div>",
      "image": "https://img.springlearn.cn/blog/learn_1567773914000.png",
      "date_published": "2022-05-08T04:06:59.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "重剑无锋大巧不工",
      "url": "https://java.springlearn.cn/learn/%E7%BD%91%E7%AB%99%E5%9C%B0%E5%9B%BE/",
      "id": "https://java.springlearn.cn/learn/%E7%BD%91%E7%AB%99%E5%9C%B0%E5%9B%BE/",
      "content_html": "<Djt/>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1610273706000.png\" alt=\"\" loading=\"lazy\"></p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1610273619000.png\" alt=\"\" loading=\"lazy\"></p>\n<DownloadBtn url='https://nodejs.org/dist/v15.9.0/node-v15.9.0.pkg' />\n",
      "image": "https://img.springlearn.cn/blog/learn_1610273706000.png",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Java泛型体系知识学习",
      "url": "https://java.springlearn.cn/learn/tools/reflections/Java%E6%B3%9B%E5%9E%8B/",
      "id": "https://java.springlearn.cn/learn/tools/reflections/Java%E6%B3%9B%E5%9E%8B/",
      "content_html": "<Djt/>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1652114729000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"一、java泛型体系\"> 一、Java泛型体系</h2>\n<p>Type 是 Java 语言中所有类型的公共父接口，其从 JDK5 开始引入，引入的目的主要是为了支持泛型。\nJava的泛型体系还是比较复杂的, 不过没关系，本篇文章会从实战的角度来，学习泛型。</p>\n<h2 id=\"_1-1-parameterizedtype-参数化泛型\"> 1.1 ParameterizedType 参数化泛型</h2>\n<p>ParameterizedType 是, <code>参数化泛型</code>只要记住凡是带泛型的是明确的类型,只要不是数组GenericArrayType那么一定是ParameterizedType。\n如下:</p>\n<ul>\n<li>List&lt;?&gt; list 中的 list</li>\n<li>Map&lt;String,String&gt; map中的map</li>\n<li>Map&lt;String,String&gt; map中的map</li>\n</ul>\n<h3 id=\"_1-1-1-api-说明\"> 1.1.1 API 说明</h3>\n<p>ParameterizedType 一共有3个方法如下。</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>ParameterizedType</span> <span>extends</span> <span>Type</span> <span>{</span>\n    <span>// 获取泛型信息，输一个数组。因为可能泛型有多个</span>\n    <span>Type</span><span>[</span><span>]</span> <span>getActualTypeArguments</span><span>(</span><span>)</span><span>;</span>\n    <span>// 原始数据类型</span>\n    <span>Type</span> <span>getRawType</span><span>(</span><span>)</span><span>;</span>\n    <span>// </span>\n    <span>Type</span> <span>getOwnerType</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><ul>\n<li>getRawType 获取原始数据类型</li>\n<li>getActualTypeArguments 获取泛型信息,因为泛型可以是多个,所以返回是数组</li>\n</ul>\n<h3 id=\"_1-1-2-代码示例\"> 1.1.2 代码示例</h3>\n<div><pre><code><span>public</span> <span>class</span> <span>Test</span> <span>{</span>\n    <span>class</span> <span>Girl</span> <span>implements</span> <span>Person</span> <span>{</span><span>}</span>\n    <span>class</span> <span>Boy</span> <span>implements</span> <span>Person</span> <span>{</span><span>}</span>\n    <span>interface</span> <span>Person</span> <span>{</span><span>}</span>\n    <span>class</span> <span>School</span><span><span>&lt;</span><span>A</span> <span>extends</span> <span>Boy</span> <span>&amp;</span> <span>Person</span><span>></span></span> <span>{</span><span>}</span>\n    <span>School</span><span><span>&lt;</span><span>Boy</span><span>></span></span> boySchool<span>;</span>\n    <span>School</span><span><span>&lt;</span><span>Boy</span><span>></span></span><span>[</span><span>]</span> schools<span>;</span>\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>test</span><span>(</span><span>)</span> <span>{</span>\n        <span>// class java.lang.Class</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>ReflectionUtils</span><span>.</span><span>findField</span><span>(</span><span>Test</span><span>.</span><span>class</span><span>,</span> <span>\"boy\"</span><span>)</span><span>.</span><span>getGenericType</span><span>(</span><span>)</span><span>.</span><span>getClass</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// class sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>ReflectionUtils</span><span>.</span><span>findField</span><span>(</span><span>Test</span><span>.</span><span>class</span><span>,</span> <span>\"boySchool\"</span><span>)</span><span>.</span><span>getGenericType</span><span>(</span><span>)</span><span>.</span><span>getClass</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// class sun.reflect.generics.reflectiveObjects.GenericArrayTypeImpl</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>ReflectionUtils</span><span>.</span><span>findField</span><span>(</span><span>Test</span><span>.</span><span>class</span><span>,</span> <span>\"schools\"</span><span>)</span><span>.</span><span>getGenericType</span><span>(</span><span>)</span><span>.</span><span>getClass</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><ul>\n<li><code>boy</code> 是具体类型,且不是泛型,所以是Class类型</li>\n<li><code>School&lt;Boy&gt; boySchool</code> 是具体类型,但是有泛型<code>&lt;Boy&gt;</code>,所以是ParameterizedType\n<ul>\n<li><code>ParameterizedType#getActualTypeArguments</code> 下标0就是泛型<code>Boy</code></li>\n</ul>\n</li>\n<li><code>School&lt;Boy&gt;[] schools</code> 是具体类型,有泛型<code>&lt;Boy&gt;</code>,但是是数组类型所以是GenericArrayType</li>\n</ul>\n<h2 id=\"_1-2-genericarraytype-泛型数组\"> 1.2 GenericArrayType  泛型数组</h2>\n<p><code>GenericArrayType</code>和<code>ParameterizedType</code>是比较类似的,唯一的区别是GenericArrayType一定是数组,如果不是数组就是ParameterizedType</p>\n<h3 id=\"_1-2-1-api-说明\"> 1.2.1 API 说明</h3>\n<p>GenericArrayType 只提供了一个方法就是获取泛型的方法</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>GenericArrayType</span> <span>extends</span> <span>Type</span> <span>{</span>\n    <span>// 获取数组泛型</span>\n    <span>Type</span> <span>getGenericComponentType</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"_1-2-2-代码示例\"> 1.2.2 代码示例</h3>\n<div><pre><code><span>public</span> <span>class</span> <span>Test</span> <span>{</span>\n    <span>class</span> <span>Girl</span> <span>implements</span> <span>Person</span> <span>{</span><span>}</span>\n    <span>class</span> <span>Boy</span> <span>implements</span> <span>Person</span> <span>{</span><span>}</span>\n    <span>interface</span> <span>Person</span> <span>{</span><span>}</span>\n    <span>class</span> <span>School</span><span><span>&lt;</span><span>A</span> <span>extends</span> <span>Boy</span> <span>&amp;</span> <span>Person</span><span>></span></span> <span>{</span><span>}</span>\n    <span>School</span><span><span>&lt;</span><span>Boy</span><span>></span></span> boySchool<span>;</span>\n    <span>School</span><span><span>&lt;</span><span>Boy</span><span>></span></span><span>[</span><span>]</span> schools<span>;</span>\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>test2</span><span>(</span><span>)</span><span>{</span>\n        <span>GenericArrayType</span> schoolsArrayType <span>=</span> <span>(</span><span>GenericArrayType</span><span>)</span> <span>ReflectionUtils</span><span>.</span><span>findField</span><span>(</span><span>Test</span><span>.</span><span>class</span><span>,</span> <span>\"schools\"</span><span>)</span><span>.</span><span>getGenericType</span><span>(</span><span>)</span><span>;</span>\n        <span>Type</span> genericComponentType <span>=</span> schoolsArrayType<span>.</span><span>getGenericComponentType</span><span>(</span><span>)</span><span>;</span>\n        <span>// learn.common.print.Test$School&lt;learn.common.print.Test$Boy></span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>genericComponentType<span>.</span><span>getTypeName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// class sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>genericComponentType<span>.</span><span>getClass</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>  \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><ul>\n<li><code>School&lt;Boy&gt; boySchool</code> 是具体类型,且有泛型,但是<code>不是</code>数组所以是<code>ParameterizedType</code></li>\n<li><code>School&lt;Boy&gt;[] schools</code> 是具体类型,且有泛型,但是<code>是</code>数组所以就是<code>GenericArrayType</code>\n<ul>\n<li><code>GenericArrayType#getGenericComponentType</code> = <code>School&lt;Boy&gt;</code> = <code>ParameterizedType</code></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"_1-3-typevariable-泛型变量\"> 1.3 TypeVariable 泛型变量</h2>\n<p><code>TypeVariable</code>变量泛型是比较好判断的,只要是变量泛型。一定就是TypeVariable。</p>\n<h3 id=\"_1-3-1-api-说明\"> 1.3.1 API 说明</h3>\n<div><pre><code><span>public</span> <span>interface</span> <span>TypeVariable</span><span><span>&lt;</span><span>D</span> <span>extends</span> <span>GenericDeclaration</span><span>></span></span> <span>extends</span> <span>Type</span><span>,</span> <span>AnnotatedElement</span> <span>{</span>\n    <span>// 获取泛型信息</span>\n    <span>Type</span><span>[</span><span>]</span> <span>getBounds</span><span>(</span><span>)</span><span>;</span>\n\n    <span>D</span> <span>getGenericDeclaration</span><span>(</span><span>)</span><span>;</span>\n\n    <span>String</span> <span>getName</span><span>(</span><span>)</span><span>;</span>\n\n    <span>AnnotatedType</span><span>[</span><span>]</span> <span>getAnnotatedBounds</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id=\"_1-3-2-代码示例\"> 1.3.2 代码示例</h3>\n<div><pre><code>    <span>class</span> <span>TypeVariableObj</span><span><span>&lt;</span><span>A</span> <span>extends</span> <span>Number</span><span>></span></span> <span>{</span>\n        <span>A</span> a<span>;</span>\n        <span>TypeVariableObj</span><span><span>&lt;</span><span>A</span><span>></span></span> as<span>;</span>\n    <span>}</span>\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>test3</span><span>(</span><span>)</span> <span>{</span>\n        <span>Type</span> a <span>=</span> <span>ReflectionUtils</span><span>.</span><span>findField</span><span>(</span><span>TypeVariableObj</span><span>.</span><span>class</span><span>,</span> <span>\"a\"</span><span>)</span><span>.</span><span>getGenericType</span><span>(</span><span>)</span><span>;</span>\n        <span>// class sun.reflect.generics.reflectiveObjects.TypeVariableImpl</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a<span>.</span><span>getClass</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\n        <span>Type</span> as <span>=</span> <span>ReflectionUtils</span><span>.</span><span>findField</span><span>(</span><span>TypeVariableObj</span><span>.</span><span>class</span><span>,</span> <span>\"as\"</span><span>)</span><span>.</span><span>getGenericType</span><span>(</span><span>)</span><span>;</span>\n        <span>// class sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>as<span>.</span><span>getClass</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>Type</span><span>[</span><span>]</span> actualTypeArguments <span>=</span> <span>(</span><span>(</span><span>ParameterizedType</span><span>)</span> as<span>)</span><span>.</span><span>getActualTypeArguments</span><span>(</span><span>)</span><span>;</span>\n        <span>// A 因为只有1个泛型,所以直接去下标0</span>\n        <span>TypeVariable</span> actualTypeArgument <span>=</span> <span>(</span><span>TypeVariable</span><span>)</span> actualTypeArguments<span>[</span><span>0</span><span>]</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>actualTypeArgument<span>.</span><span>getTypeName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><ul>\n<li><code>A a = TypeVariable</code></li>\n<li><code>TypeVariableObj&lt;A&gt; as = ParameterizedType</code>\n<ul>\n<li><code>ParameterizedType#getActualTypeArguments()[0] = &lt;A&gt;</code></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"_1-4-wildcardtype-泛型表达式\"> 1.4 WildcardType 泛型表达式</h2>\n<p><code>WildcardType</code>也比较好判断只要是通配符,可以简单理解,直接带有 <code>?</code> 的泛型限定那么就是 <code>WildcardType</code></p>\n<h3 id=\"_1-4-1-api-说明\"> 1.4.1 API 说明</h3>\n<p>WildcardType通配符, 如 <code>?</code>, <code>? extends Number</code>, <code>? super Integer</code></p>\n<div><pre><code><span>public</span> <span>interface</span> <span>WildcardType</span> <span>extends</span> <span>Type</span> <span>{</span>\n    <span>// 泛型上限</span>\n    <span>Type</span><span>[</span><span>]</span> <span>getUpperBounds</span><span>(</span><span>)</span><span>;</span>\n    <span>// 泛型下限</span>\n    <span>Type</span><span>[</span><span>]</span> <span>getLowerBounds</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ul>\n<li><code>Type[] getUpperBounds();</code> //获得泛型表达式上界（上限） 获取泛型变量的上边界（extends）</li>\n<li><code>Type[] getLowerBounds();</code> //获得泛型表达式下界（下限） 获取泛型变量的下边界（super）</li>\n</ul>\n<h3 id=\"_1-4-2-代码示例\"> 1.4.2 代码示例</h3>\n<div><pre><code><span>public</span> <span>class</span> <span>WildcardTypeTest</span> <span>{</span>\n    <span>Map</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>String</span><span>,</span> <span>?</span> <span>super</span> <span>Number</span><span>></span></span> map<span>;</span>\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>wildcardTypeTest</span><span>(</span><span>)</span> <span>{</span>\n        <span>Field</span> map <span>=</span> <span>ReflectionUtils</span><span>.</span><span>findField</span><span>(</span><span>WildcardTypeTest</span><span>.</span><span>class</span><span>,</span> <span>\"map\"</span><span>)</span><span>;</span>\n        <span>Type</span><span>[</span><span>]</span> actualTypeArguments <span>=</span> <span>(</span><span>(</span><span>ParameterizedType</span><span>)</span> map<span>.</span><span>getGenericType</span><span>(</span><span>)</span><span>)</span><span>.</span><span>getActualTypeArguments</span><span>(</span><span>)</span><span>;</span>\n        <span>// ? extends java.lang.String</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>(</span><span>(</span><span>WildcardType</span><span>)</span> actualTypeArguments<span>[</span><span>0</span><span>]</span><span>)</span><span>.</span><span>getTypeName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>// class java.lang.String</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>(</span><span>(</span><span>WildcardType</span><span>)</span> actualTypeArguments<span>[</span><span>0</span><span>]</span><span>)</span><span>.</span><span>getUpperBounds</span><span>(</span><span>)</span><span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><ul>\n<li><code>Map&lt;? extends String, ? super Number&gt; map</code> 中 map是 <code>ParameterizedType</code>\n<ul>\n<li><code>ParameterizedType#getActualTypeArguments[0]</code> = <code>WildcardType#getUpperBounds[0]</code> = <code>String</code></li>\n<li><code>ParameterizedType#getActualTypeArguments[1]</code> = <code>WildcardType#getLowerBounds[0]</code> = <code>Number</code></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"二、泛型获取\"> 二、泛型获取</h2>\n<p>通过上面的学习,我们可以使用原始API来获取各种泛型的信息,而Spring中有一个比较好用的工具。屏蔽了底层的\n具体实现。比较方便。</p>\n<h2 id=\"_2-1-获取接口泛型\"> 2.1 获取接口泛型</h2>\n<div><pre><code>    <span>class</span> <span>A</span> <span>{</span><span>}</span>\n    <span>class</span> <span>B</span> <span>{</span><span>}</span>\n    <span>interface</span> <span>School</span><span><span>&lt;</span><span>T</span><span>,</span> <span>K</span><span>></span></span> <span>{</span><span>}</span>\n    <span>interface</span> <span>X</span> <span>extends</span> <span>School</span><span><span>&lt;</span><span>A</span><span>,</span> <span>B</span><span>></span></span> <span>{</span><span>}</span>\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>test</span><span>(</span><span>)</span> <span>{</span>\n        <span>// 获取实现的接口是泛型的信息</span>\n        <span>ResolvableType</span> resolvableType <span>=</span> <span>ResolvableType</span><span>.</span><span>forClass</span><span>(</span><span>X</span><span>.</span><span>class</span><span>)</span><span>;</span>\n        <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> resolve1 <span>=</span> resolvableType<span>.</span><span>getInterfaces</span><span>(</span><span>)</span><span>[</span><span>0</span><span>]</span><span>.</span><span>getGeneric</span><span>(</span><span>0</span><span>)</span><span>.</span><span>resolve</span><span>(</span><span>)</span><span>;</span>\n        <span>// class learn.common.print.ColorConsoleTest$A</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>resolve1<span>)</span><span>;</span>\n        <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> resolve2 <span>=</span> resolvableType<span>.</span><span>getInterfaces</span><span>(</span><span>)</span><span>[</span><span>0</span><span>]</span><span>.</span><span>getGeneric</span><span>(</span><span>1</span><span>)</span><span>.</span><span>resolve</span><span>(</span><span>)</span><span>;</span>\n        <span>// class learn.common.print.ColorConsoleTest$B</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>resolve2<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h2 id=\"_2-2-获取父类泛型\"> 2.2 获取父类泛型</h2>\n<div><pre><code>    <span>class</span> <span>A</span> <span>{</span><span>}</span>\n    <span>class</span> <span>B</span> <span>{</span><span>}</span>\n    <span>class</span> <span>School</span><span><span>&lt;</span><span>T</span><span>,</span> <span>K</span><span>></span></span> <span>{</span><span>}</span>\n    <span>class</span> <span>X</span> <span>extends</span> <span>School</span><span><span>&lt;</span><span>A</span><span>,</span> <span>B</span><span>></span></span> <span>{</span><span>}</span>\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>test</span><span>(</span><span>)</span> <span>{</span>\n        <span>// 获取实现的接口是泛型的信息</span>\n        <span>ResolvableType</span> resolvableType <span>=</span> <span>ResolvableType</span><span>.</span><span>forClass</span><span>(</span><span>X</span><span>.</span><span>class</span><span>)</span><span>;</span>\n        <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> resolve1 <span>=</span> resolvableType<span>.</span><span>getSuperType</span><span>(</span><span>)</span><span>.</span><span>getGeneric</span><span>(</span><span>0</span><span>)</span><span>.</span><span>resolve</span><span>(</span><span>)</span><span>;</span>\n        <span>// class learn.common.print.ColorConsoleTest$A</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>resolve1<span>)</span><span>;</span>\n        <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> resolve2 <span>=</span> resolvableType<span>.</span><span>getSuperType</span><span>(</span><span>)</span><span>.</span><span>getGeneric</span><span>(</span><span>1</span><span>)</span><span>.</span><span>resolve</span><span>(</span><span>)</span><span>;</span>\n        <span>// class learn.common.print.ColorConsoleTest$B</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>resolve2<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h2 id=\"_2-3-获取字段泛型\"> 2.3 获取字段泛型</h2>\n<div><pre><code>    <span>class</span> <span>A</span> <span>{</span><span>}</span>\n    <span>class</span> <span>B</span> <span>{</span><span>}</span>\n    <span>class</span> <span>School</span><span><span>&lt;</span><span>T</span><span>,</span> <span>K</span><span>></span></span> <span>{</span><span>}</span>\n    <span>class</span> <span>X</span> <span>{</span>\n        <span>private</span> <span>School</span><span><span>&lt;</span><span>A</span><span>,</span> <span>B</span><span>></span></span> school<span>;</span>\n    <span>}</span>\n\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>test</span><span>(</span><span>)</span> <span>{</span>\n        <span>// Spring的提供工具类,用于字段的泛型信息,Person&lt;String></span>\n        <span>ResolvableType</span> resolvableType <span>=</span> <span>ResolvableType</span><span>.</span><span>forField</span><span>(</span><span>Objects</span><span>.</span><span>requireNonNull</span><span>(</span><span>ReflectionUtils</span><span>.</span><span>findField</span><span>(</span><span>X</span><span>.</span><span>class</span><span>,</span> <span>\"school\"</span><span>)</span><span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>resolvableType<span>)</span><span>;</span>\n        <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> resolve1 <span>=</span> resolvableType<span>.</span><span>getGeneric</span><span>(</span><span>0</span><span>)</span><span>.</span><span>resolve</span><span>(</span><span>)</span><span>;</span>\n        <span>// class learn.common.print.ColorConsoleTest$A</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>resolve1<span>)</span><span>;</span>\n        <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> resolve2 <span>=</span> resolvableType<span>.</span><span>getGeneric</span><span>(</span><span>1</span><span>)</span><span>.</span><span>resolve</span><span>(</span><span>)</span><span>;</span>\n        <span>// class learn.common.print.ColorConsoleTest$B</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>resolve2<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h2 id=\"_2-4-获取方法泛型\"> 2.4 获取方法泛型</h2>\n<div><pre><code>    <span>class</span> <span>A</span> <span>{</span><span>}</span>\n    <span>class</span> <span>B</span> <span>{</span><span>}</span>\n    <span>class</span> <span>School</span><span><span>&lt;</span><span>T</span><span>,</span> <span>K</span><span>></span></span> <span>{</span><span>}</span>\n    <span>class</span> <span>X</span> <span>{</span>\n        <span>public</span> <span>School</span><span><span>&lt;</span><span>A</span><span>,</span> <span>B</span><span>></span></span> <span>getSchool</span><span>(</span><span>)</span> <span>{</span>\n            <span>return</span> <span>null</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>@Test</span>\n    <span>public</span> <span>void</span> <span>test</span><span>(</span><span>)</span> <span>{</span>\n        <span>// Spring的提供工具类,用于字段的泛型信息,Person&lt;String></span>\n        <span>ResolvableType</span> resolvableType <span>=</span> <span>ResolvableType</span><span>.</span><span>forMethodReturnType</span><span>(</span><span>Objects</span><span>.</span><span>requireNonNull</span><span>(</span><span>ReflectionUtils</span><span>.</span><span>findMethod</span><span>(</span><span>X</span><span>.</span><span>class</span><span>,</span> <span>\"getSchool\"</span><span>)</span><span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>resolvableType<span>)</span><span>;</span>\n        <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> resolve1 <span>=</span> resolvableType<span>.</span><span>getGeneric</span><span>(</span><span>0</span><span>)</span><span>.</span><span>resolve</span><span>(</span><span>)</span><span>;</span>\n        <span>// class learn.common.print.ColorConsoleTest$A</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>resolve1<span>)</span><span>;</span>\n        <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> resolve2 <span>=</span> resolvableType<span>.</span><span>getGeneric</span><span>(</span><span>1</span><span>)</span><span>.</span><span>resolve</span><span>(</span><span>)</span><span>;</span>\n        <span>// class learn.common.print.ColorConsoleTest$B</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>resolve2<span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div>",
      "image": "https://img.springlearn.cn/blog/learn_1652114729000.png",
      "date_published": "2022-05-09T16:49:39.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Reactive 反应式编程",
      "url": "https://java.springlearn.cn/learn/tools/reactor/",
      "id": "https://java.springlearn.cn/learn/tools/reactor/",
      "content_html": "<div><p>反应式编程</p>\n<p>reactive 是一种新的编程思想, 如同名字一样, 反应式编程。而Reactor 是一个工具包，类似于\nSpring一样。这点我们可以直接在Spring的官网上可以看到。本篇基于小编自己的学习进行总结。</p>\n</div>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1651411884000.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"一、提出问题\"> 一、提出问题</h2>\n<p>目前来说反应式编程在Java行业其实不是很流行, 其原因1在于传统的编程模型已经根深蒂固。虽然阻塞但是其实对于业务开发\n并不是一个很大的痛点。其2新的编程思想具有学习成本，但是又不是特别的痛，所以没有引起关注。下面我们来带着问题来学习吧。</p>\n<h2 id=\"_1-1-什么是反应式编程\"> 1.1 什么是反应式编程?</h2>\n<p>哎，可能因为都是从外国翻译过来的缘故，总喜欢翻译写高大上，且晦涩难懂的文字进行描述，搞得大多数程序猿一头雾水。但是没办法，\n谁让你不主动去学习原文，而要吃一些大牛的二手翻译资料呢。所以我们就要最这些二手资料进行重读，并且深入思考，来总结出自己的理解。\n小编理解，所谓反应式编程，简单来说就是基于事件编程，由事件去驱动。比如我们servlet api，传统的方式servlet 线程是阻塞线程，\n如果方法没有执行完成，那么servlet线程会一直在阻塞等待。从而会导致不能接受更多的外部请求。而如果要使用反应式编程</p>\n<h2 id=\"_1-2-反应式编程中背压指得是什么\"> 1.2 反应式编程中背压指得是什么?</h2>\n<p>我也不知道为什么称背压，如果单从这个词汇来说，想死都想不通。什么鬼玩意呀。现在我们忽略这个sb的词汇。直接来说他的含义。\n要想搞明白这个，先知道事件驱动是如何设计的。首先有一个事件发送者，和一个事件处理者。传统的方式是事件处理者被动的来接受\n事件发送者，发起的事件，并进行处理，而在reactor中，事件的处理者不仅可以被动的接受，同时也支持主动的拉去事件。于是这种\n能力被称为背压。在高大上的解释就是，这能实现组件之间的弹性。</p>\n<h2 id=\"_1-3-反应式编程好处是什么\"> 1.3 反应式编程好处是什么?</h2>\n<p>我们直接看官网的说明，然后进行白话翻译。</p>\n<blockquote>\n<p>Reactive systems better utilize modern processors. Also, the inclusion of back-pressure in reactive programming\nensures better resilience between decoupled components.</p>\n</blockquote>\n<p>直白点就是可以充分的利用其cpu多核多线程的处理能力, 另外背压的能力,使组件知道当前的负载,动态的确定自己还能接受的任务数量,称之为弹性。</p>\n<h2 id=\"二、reactor-核心类\"> 二、Reactor 核心类</h2>\n<p>这种编程思想其实还是值得学习的，因为基于事件来驱动，确实可以充分的利用其cpu多核多线程的处理能力。充分压榨cpu的能力。\n其实我们在很多地方都能看到类似的设计思想。eg: RxJava, Netty。\n下面我们就学习下如何使用吧。</p>\n<h2 id=\"_2-1-publisher-发布者\"> 2.1 Publisher 发布者</h2>\n<p>发布者只有一个接口,提供订阅能力。</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>Publisher</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>{</span>\n    <span>// 绑定一个订阅者</span>\n    <span>public</span> <span>void</span> <span>subscribe</span><span>(</span><span>Subscriber</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>T</span><span>></span></span> s<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id=\"_2-2-subscriber-订阅者\"> 2.2 Subscriber 订阅者</h2>\n<p>订阅者主要处理发布者发布的信息</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>Subscriber</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>{</span>\n    <span>// 确定订阅关系</span>\n    <span>public</span> <span>void</span> <span>onSubscribe</span><span>(</span><span>Subscription</span> s<span>)</span><span>;</span>\n    <span>// 处理数据</span>\n    <span>public</span> <span>void</span> <span>onNext</span><span>(</span><span>T</span> t<span>)</span><span>;</span>\n    <span>// 错误处理</span>\n    <span>public</span> <span>void</span> <span>onError</span><span>(</span><span>Throwable</span> t<span>)</span><span>;</span>\n    <span>// 当事件处理完时触发</span>\n    <span>public</span> <span>void</span> <span>onComplete</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id=\"_2-3-subscription-订阅关系\"> 2.3 Subscription 订阅关系</h2>\n<p>订阅关系，可以取消订阅，通知可以实现拉去能力。</p>\n<div><pre><code><span>public</span> <span>interface</span> <span>Subscription</span> <span>{</span>\n    <span>// 获取指定数量的数据</span>\n    <span>public</span> <span>void</span> <span>request</span><span>(</span><span>long</span> n<span>)</span><span>;</span>\n    <span>// 取消订阅关系</span>\n    <span>public</span> <span>void</span> <span>cancel</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id=\"_2-4-sink-数据池\"> 2.4 Sink 数据池</h2>\n<p>Sink#next会将数据放入池中，由Sink缓存或直接发送给订阅者。</p>\n<p>Mono和Flux分别提供了create和generate的方法,用来绑定事件发射器 Sink。开发者可以利用Sink来\n生产事件数据，然后发送给订阅者。</p>\n<h2 id=\"三、事件模式\"> 三、事件模式</h2>\n<p>Push推模式，PUSH_PULL混合模式</p>\n<div><pre><code><span>enum</span> <span>CreateMode</span> <span>{</span>\n\tPUSH_ONLY<span>,</span> PUSH_PULL\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"_3-1-pull-模式\"> 3.1 Pull 模式</h2>\n<p>generate 方法适用于拉去模式，当订阅者调用Subscription#request,则从Sink#next生产一条数据。\n如下两个代码示例。</p>\n<div><pre><code>    <span>@Test</span>\n    <span>@DisplayName</span><span>(</span><span>\"Flux Pull模式 Integer.MAX_VALUE\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>testFluxPull</span><span>(</span><span>)</span> <span>{</span>\n        <span>Flux</span><span>.</span><span>generate</span><span>(</span><span>(</span><span>Consumer</span><span><span>&lt;</span><span>SynchronousSink</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span><span>)</span> sink <span>-></span> <span>{</span>\n                    <span>int</span> k <span>=</span> <span>(</span><span>int</span><span>)</span> <span>(</span><span>Math</span><span>.</span><span>random</span><span>(</span><span>)</span> <span>*</span> <span>10</span><span>)</span><span>;</span>\n                    sink<span>.</span><span>next</span><span>(</span>k<span>)</span><span>;</span>\n                <span>}</span><span>)</span>\n                <span>// 默认获取 request(Integer.MAX_VALUE)</span>\n                <span>.</span><span>subscribe</span><span>(</span>integer <span>-></span> <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Pull:\"</span> <span>+</span> integer<span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Test</span>\n    <span>@DisplayName</span><span>(</span><span>\"Flux Pull模式 request调用一次,则调用Sink生产一次\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>testFluxPullTwo</span><span>(</span><span>)</span> <span>{</span>\n        <span>Flux</span><span>.</span><span>generate</span><span>(</span><span>(</span><span>Consumer</span><span><span>&lt;</span><span>SynchronousSink</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span><span>)</span> sink <span>-></span> <span>{</span>\n                    <span>int</span> k <span>=</span> <span>(</span><span>int</span><span>)</span> <span>(</span><span>Math</span><span>.</span><span>random</span><span>(</span><span>)</span> <span>*</span> <span>10</span><span>)</span><span>;</span>\n                    sink<span>.</span><span>next</span><span>(</span>k<span>)</span><span>;</span>\n                <span>}</span><span>)</span>\n                <span>.</span><span>subscribe</span><span>(</span><span>new</span> <span>Subscriber</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>(</span><span>)</span> <span>{</span>\n                    <span>Subscription</span> subscription<span>;</span>\n\n                    <span>private</span> <span>int</span> count<span>;</span>\n\n                    <span>@Override</span>\n                    <span>public</span> <span>void</span> <span>onSubscribe</span><span>(</span><span>Subscription</span> s<span>)</span> <span>{</span>\n                        <span>this</span><span>.</span>subscription <span>=</span> s<span>;</span>\n                        <span>// 订阅时候,生产1条数据</span>\n                        <span>this</span><span>.</span>subscription<span>.</span><span>request</span><span>(</span><span>1</span><span>)</span><span>;</span>\n                    <span>}</span>\n\n                    <span>@Override</span>\n                    <span>public</span> <span>void</span> <span>onNext</span><span>(</span><span>Integer</span> integer<span>)</span> <span>{</span>\n                        count<span>++</span><span>;</span>\n                        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"处理:\"</span> <span>+</span> integer<span>)</span><span>;</span>\n                        <span>// 在处理1次，当第二次处理时候,就不拉数据了</span>\n                        <span>if</span> <span>(</span>count <span>&lt;</span> <span>2</span><span>)</span> <span>{</span>\n                            <span>this</span><span>.</span>subscription<span>.</span><span>request</span><span>(</span><span>1</span><span>)</span><span>;</span>\n                        <span>}</span>\n                    <span>}</span>\n\n                    <span>@Override</span>\n                    <span>public</span> <span>void</span> <span>onError</span><span>(</span><span>Throwable</span> t<span>)</span> <span>{</span>\n                        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"onError\"</span><span>)</span><span>;</span>\n                    <span>}</span>\n\n                    <span>@Override</span>\n                    <span>public</span> <span>void</span> <span>onComplete</span><span>(</span><span>)</span> <span>{</span>\n                        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"onComplete\"</span><span>)</span><span>;</span>\n                    <span>}</span>\n                <span>}</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br></div></div><div><pre><code>处理:3\n处理:1\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h2 id=\"_3-2-push-模式\"> 3.2 Push 模式</h2>\n<p>发布者主动推动数据,跟Pull的区别是。他不会随着,订阅者调用Subscription#request,而从Sink#next生产一条数据。\n只有订阅时候Subscription#request,Sink只会执行一次</p>\n<div><pre><code>    <span>@Test</span>\n    <span>@DisplayName</span><span>(</span><span>\"Flux Push模式\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>testFluxPush</span><span>(</span><span>)</span> <span>{</span>\n        <span>Flux</span><span>.</span><span>create</span><span>(</span><span>(</span><span>Consumer</span><span><span>&lt;</span><span>FluxSink</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span><span>)</span> sink <span>-></span> <span>{</span>\n            <span>int</span> k <span>=</span> <span>(</span><span>int</span><span>)</span> <span>(</span><span>Math</span><span>.</span><span>random</span><span>(</span><span>)</span> <span>*</span> <span>10</span><span>)</span><span>;</span>\n            sink<span>.</span><span>next</span><span>(</span>k<span>)</span><span>;</span>\n        <span>}</span><span>)</span><span>.</span><span>subscribe</span><span>(</span><span>new</span> <span>Subscriber</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>(</span><span>)</span> <span>{</span>\n\n            <span>Subscription</span> subscription<span>;</span>\n\n            <span>@Override</span>\n            <span>public</span> <span>void</span> <span>onSubscribe</span><span>(</span><span>Subscription</span> s<span>)</span> <span>{</span>\n                <span>this</span><span>.</span>subscription <span>=</span> s<span>;</span>\n                <span>this</span><span>.</span>subscription<span>.</span><span>request</span><span>(</span><span>1</span><span>)</span><span>;</span>\n            <span>}</span>\n\n            <span>@SneakyThrows</span>\n            <span>@Override</span>\n            <span>public</span> <span>void</span> <span>onNext</span><span>(</span><span>Integer</span> integer<span>)</span> <span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"处理:\"</span> <span>+</span> integer<span>)</span><span>;</span>\n            <span>}</span>\n\n            <span>@Override</span>\n            <span>public</span> <span>void</span> <span>onError</span><span>(</span><span>Throwable</span> t<span>)</span> <span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"处理失败\"</span><span>)</span><span>;</span>\n            <span>}</span>\n\n            <span>@Override</span>\n            <span>public</span> <span>void</span> <span>onComplete</span><span>(</span><span>)</span> <span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"处理完成\"</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n    <span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><div><pre><code>处理:9\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"四、事件驱动的好处\"> 四、事件驱动的好处</h2>\n<p>反应式编程的好处, 主要是编程思想的不同, 抓住关键点非阻塞+事件驱动。</p>\n<div><pre><code>StopWatch &#39;耗时统计&#39;: running time = 2070915374 ns\n---------------------------------------------\nns         %     Task name\n---------------------------------------------\n063036666   003%  基于事件驱动的编程思想\n2007878708  097%  传统阻塞式的编程思想\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>如下举一个例子,假如这是Servlet API。Servlet 线程负责调用getMonoUserName()。但是其实没有执行\n处理逻辑,而真正的执行逻辑交给业务线程处理。而此时Servlet线程可以释放出来,继续接受外部请求。</p>\n<div><pre><code>    <span>@Test</span>\n    <span>@DisplayName</span><span>(</span><span>\"Mono 事件驱动的好处\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>testMono</span><span>(</span><span>)</span> <span>{</span>\n        <span>StopWatch</span> stopWatch <span>=</span> <span>new</span> <span>StopWatch</span><span>(</span><span>)</span><span>;</span>\n        stopWatch<span>.</span><span>start</span><span>(</span><span>\"基于事件驱动的编程思想\"</span><span>)</span><span>;</span>\n        <span>Mono</span><span><span>&lt;</span><span>String</span><span>></span></span> userNameMono <span>=</span> <span>getMonoUserName</span><span>(</span><span>)</span><span>;</span>\n        stopWatch<span>.</span><span>stop</span><span>(</span><span>)</span><span>;</span>\n        stopWatch<span>.</span><span>start</span><span>(</span><span>\"传统阻塞式的编程思想\"</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>getUserName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        stopWatch<span>.</span><span>stop</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>userNameMono<span>.</span><span>block</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>stopWatch<span>.</span><span>prettyPrint</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n\n\n    <span>@SneakyThrows</span>\n    <span>public</span> <span>String</span> <span>getUserName</span><span>(</span><span>)</span> <span>{</span>\n        <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>2000L</span><span>)</span><span>;</span>\n        <span>return</span> <span>\"JayChou\"</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 基于事件驱动的编程思想\n     *\n     * @return Mono&lt;String>\n     */</span>\n    <span>public</span> <span>Mono</span><span><span>&lt;</span><span>String</span><span>></span></span> <span>getMonoUserName</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>Mono</span><span>.</span><span>create</span><span>(</span>monoSink <span>-></span> <span>{</span>\n            <span>try</span> <span>{</span>\n                <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>2000L</span><span>)</span><span>;</span>\n            <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>\n                monoSink<span>.</span><span>error</span><span>(</span><span>new</span> <span>RuntimeException</span><span>(</span>e<span>)</span><span>)</span><span>;</span>\n                <span>return</span><span>;</span>\n            <span>}</span>\n            monoSink<span>.</span><span>success</span><span>(</span><span>\"JayChou\"</span><span>)</span><span>;</span>\n        <span>}</span><span>)</span><span>;</span>\n    <span>}</span>\n\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br></div></div><h2 id=\"五、总结-思考\"> 五、总结 &amp; 思考</h2>\n<p>传统的编程思想是: 基于数据处理来写处理逻辑,逻辑中可能直接就阻塞了。\n反应式编程思想是: 我们只写数据处理逻辑,里面虽然也有阻塞,但是并不直接执行。类似线程中,Future#get</p>\n<p><img src=\"https://img.springlearn.cn/blog/learn_1651427177000.png\" alt=\"\" loading=\"lazy\"></p>\n<p>其主要的不同就是编程思想不同，非阻塞的编程思想。但是我们也发现, 这样的思想其实带来好处其实并不是很大。\n我们也可以直接使用多线程来直接搞定，而不用增加学习成本来学习新的框架。</p>\n<p><strong>为什么反应式编程在后端开发者里面推广不起来</strong></p>\n<p>作为后台服务, 开发者其实对吞吐量并不是很关心,比如页面请求了后端，就算我后端服务慢，前台请求就会卡住。卡住就卡住等待呗，不管用什么框架都会卡住。（秒杀高并发服务除外，并不是所有的服务都要求高并发。特殊情况特殊处理, 异步也解决不了高并发的吞吐和rt问题）</p>\n<p>但是如果作为安卓开发呢？\n用户发起了一个请求, 请求慢就让用户主线程就卡住，手机不能滑动。这样用户体验是非常的差的。所以安卓开发会比较关注，解决方案就是纯异步，主线程只接受请求，然后任务安排给后台异步线程，这样就算请求慢，但是用户不会感觉手机是卡顿的。等到异步任务执行完，在跳转出来就行了。</p>\n<p>所以RxJava 是鼻祖，Reactor是追随者。也是因为上面的特性，所以后台开发者没有安卓开发者感兴趣，不需要压榨机器的性能。</p>\n<p><code>Reactor要想推广起来，必须要与异步Servlet或是Spring WebFlux结合</code>（开发者无感使用），或是<code>云原生应用彻底推广起来,强制开发者必须使用。</code>才可能推广使用起来。\n但是不管怎么样这种编程思想是可以借鉴。</p>\n",
      "image": "https://img.springlearn.cn/blog/learn_1651411884000.png",
      "date_published": "2022-05-08T04:06:59.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "反射框架Reflections",
      "url": "https://java.springlearn.cn/learn/tools/reflections/",
      "id": "https://java.springlearn.cn/learn/tools/reflections/",
      "content_html": "<p><a href=\"https://github.com/ronmamo/reflections\" target=\"_blank\" rel=\"noopener noreferrer\">Github</a></p>\n<h2 id=\"一、简介\"> 一、简介</h2>\n<p>Reflections通过扫描classpath，索引元数据，并且允许在运行时查询这些元数据。</p>\n<p>使用Reflections可以很轻松的获取以下元数据信息：</p>\n<ul>\n<li><input type=\"checkbox\" checked=\"checked\" disabled=\"disabled\" id=\"task-item-0\"><label for=\"task-item-0\"> 获取某个类型的全部子类</label></li>\n<li><input type=\"checkbox\" checked=\"checked\" disabled=\"disabled\" id=\"task-item-1\"><label for=\"task-item-1\"> 只要类型、构造器、方法，字段上带有特定注解，便能获取带有这个注解的全部信息（类型、构造器、方法，字段）</label></li>\n<li><input type=\"checkbox\" checked=\"checked\" disabled=\"disabled\" id=\"task-item-2\"><label for=\"task-item-2\"> 获取所有能匹配某个正则表达式的资源</label></li>\n<li><input type=\"checkbox\" checked=\"checked\" disabled=\"disabled\" id=\"task-item-3\"><label for=\"task-item-3\"> 获取所有带有特定签名的方法，包括参数，参数注解，返回类型</label></li>\n<li><input type=\"checkbox\" checked=\"checked\" disabled=\"disabled\" id=\"task-item-4\"><label for=\"task-item-4\">  获取所有方法的名字</label></li>\n<li><input type=\"checkbox\" checked=\"checked\" disabled=\"disabled\" id=\"task-item-5\"><label for=\"task-item-5\"> 获取代码里所有字段、方法名、构造器的使用权</label></li>\n</ul>\n<h2 id=\"二、maven依赖\"> 二、Maven依赖</h2>\n<div><pre><code><span><span><span>&lt;</span>dependency</span><span>></span></span>\n    <span><span><span>&lt;</span>groupId</span><span>></span></span>org.reflections<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n    <span><span><span>&lt;</span>artifactId</span><span>></span></span>reflections<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n    <span><span><span>&lt;</span>version</span><span>></span></span>0.9.11<span><span><span>&lt;/</span>version</span><span>></span></span>\n<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"三、使用方法\"> 三、使用方法</h2>\n<h3 id=\"_3-1-实例化\"> 3.1 实例化</h3>\n<p>指定要扫描的包名</p>\n<div><pre><code><span>// 实例化Reflections，并指定要扫描的包名</span>\n<span>Reflections</span> reflections <span>=</span> <span>new</span> <span>Reflections</span><span>(</span><span>\"my.project\"</span><span>)</span><span>;</span>\n<span>// 获取某个类的所有子类</span>\n<span>Set</span><span><span>&lt;</span><span>Class</span><span>&lt;</span><span>?</span> <span>extends</span> <span>SomeType</span><span>></span><span>></span></span> subTypes <span>=</span> reflections<span>.</span><span>getSubTypesOf</span><span>(</span><span>SomeType</span><span>.</span><span>class</span><span>)</span><span>;</span>\n<span>// 获取包含某个注解的所有类</span>\n<span>Set</span><span><span>&lt;</span><span>Class</span><span>&lt;</span><span>?</span><span>></span><span>></span></span> annotated <span>=</span> reflections<span>.</span><span>getTypesAnnotatedWith</span><span>(</span><span>SomeAnnotation</span><span>.</span><span>class</span><span>)</span><span>;</span>\n  \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>指定要扫描的包名并添加过滤器</p>\n<p><a href=\"https://ronmamo.github.io/reflections/org/reflections/util/ConfigurationBuilder.html\" target=\"_blank\" rel=\"noopener noreferrer\">ConfigurationBuilder API</a></p>\n<div><pre><code><span>Reflections</span> reflections <span>=</span> <span>new</span> <span>Reflections</span><span>(</span>\n  <span>new</span> <span>ConfigurationBuilder</span><span>(</span><span>)</span>\n    <span>.</span><span>forPackage</span><span>(</span><span>\"com.my.project\"</span><span>)</span>\n    <span>.</span><span>filterInputsBy</span><span>(</span><span>new</span> <span>FilterBuilder</span><span>(</span><span>)</span><span>.</span><span>includePackage</span><span>(</span><span>\"com.my.project\"</span><span>)</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>添加扫描器</p>\n<p><a href=\"https://ronmamo.github.io/reflections/org/reflections/scanners/Scanners.html\" target=\"_blank\" rel=\"noopener noreferrer\">Scanners API</a></p>\n<div><pre><code><span>// scan package with specific scanners</span>\n<span>Reflections</span> reflections <span>=</span> <span>new</span> <span>Reflections</span><span>(</span>\n  <span>new</span> <span>ConfigurationBuilder</span><span>(</span><span>)</span>\n    <span>.</span><span>forPackage</span><span>(</span><span>\"com.my.project\"</span><span>)</span>\n    <span>.</span><span>filterInputsBy</span><span>(</span><span>new</span> <span>FilterBuilder</span><span>(</span><span>)</span><span>.</span><span>includePackage</span><span>(</span><span>\"com.my.project\"</span><span>)</span><span>.</span><span>excludePackage</span><span>(</span><span>\"com.my.project.exclude\"</span><span>)</span><span>)</span>\n    <span>.</span><span>setScanners</span><span>(</span><span>TypesAnnotated</span><span>,</span> <span>MethodsAnnotated</span><span>,</span> <span>MethodsReturn</span><span>)</span><span>)</span><span>;</span>\n\n<span>// scan package with all standard scanners</span>\n<span>Reflections</span> reflections <span>=</span> <span>new</span> <span>Reflections</span><span>(</span><span>\"com.my.project\"</span><span>,</span> <span>Scanners</span><span>.</span><span>values</span><span>(</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"_3-2-扫描子类\"> 3.2 扫描子类</h3>\n<div><pre><code><span>Set</span><span><span>&lt;</span><span>Class</span><span>&lt;</span><span>?</span> <span>extends</span> <span>Module</span><span>></span><span>></span></span> modules <span>=</span> \n    reflections<span>.</span><span>getSubTypesOf</span><span>(</span><span><span>com<span>.</span>google<span>.</span>inject<span>.</span></span>Module</span><span>.</span><span>class</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"_3-3-扫描注解\"> 3.3 扫描注解</h3>\n<div><pre><code><span>//TypeAnnotationsScanner </span>\n<span>Set</span><span><span>&lt;</span><span>Class</span><span>&lt;</span><span>?</span><span>></span><span>></span></span> singletons <span>=</span> \n    reflections<span>.</span><span>getTypesAnnotatedWith</span><span>(</span><span><span>javax<span>.</span>inject<span>.</span></span>Singleton</span><span>.</span><span>class</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"_3-4-扫描资源\"> 3.4 扫描资源</h3>\n<div><pre><code><span>//ResourcesScanner</span>\n<span>Set</span><span><span>&lt;</span><span>String</span><span>></span></span> properties <span>=</span> \n    reflections<span>.</span><span>getResources</span><span>(</span><span>Pattern</span><span>.</span><span>compile</span><span>(</span><span>\".*\\\\.properties\"</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"_3-5-扫描方法、构造注解\"> 3.5 扫描方法、构造注解</h3>\n<div><pre><code><span>//MethodAnnotationsScanner</span>\n<span>Set</span><span><span>&lt;</span><span>Method</span><span>></span></span> resources <span>=</span>\n    reflections<span>.</span><span>getMethodsAnnotatedWith</span><span>(</span><span><span>javax<span>.</span>ws<span>.</span>rs<span>.</span></span>Path</span><span>.</span><span>class</span><span>)</span><span>;</span>\n<span>Set</span><span><span>&lt;</span><span>Constructor</span><span>></span></span> injectables <span>=</span> \n    reflections<span>.</span><span>getConstructorsAnnotatedWith</span><span>(</span><span><span>javax<span>.</span>inject<span>.</span></span>Inject</span><span>.</span><span>class</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id=\"_3-6-扫描字段注解\"> 3.6 扫描字段注解</h3>\n<div><pre><code><span>Set</span><span><span>&lt;</span><span>Field</span><span>></span></span> ids <span>=</span> \n    reflections<span>.</span><span>getFieldsAnnotatedWith</span><span>(</span><span><span>javax<span>.</span>persistence<span>.</span></span>Id</span><span>.</span><span>class</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"_3-7-扫描方法参数\"> 3.7 扫描方法参数</h3>\n<div><pre><code><span>//MethodParameterScanner</span>\n<span>Set</span><span><span>&lt;</span><span>Method</span><span>></span></span> someMethods <span>=</span>\n    reflections<span>.</span><span>getMethodsMatchParams</span><span>(</span><span>long</span><span>.</span><span>class</span><span>,</span> <span>int</span><span>.</span><span>class</span><span>)</span><span>;</span>\n<span>Set</span><span><span>&lt;</span><span>Method</span><span>></span></span> voidMethods <span>=</span>\n    reflections<span>.</span><span>getMethodsReturn</span><span>(</span><span>void</span><span>.</span><span>class</span><span>)</span><span>;</span>\n<span>Set</span><span><span>&lt;</span><span>Method</span><span>></span></span> pathParamMethods <span>=</span>\n    reflections<span>.</span><span>getMethodsWithAnyParamAnnotated</span><span>(</span><span>PathParam</span><span>.</span><span>class</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id=\"_3-8-扫描方法参数名\"> 3.8 扫描方法参数名</h3>\n<div><pre><code><span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> parameterNames <span>=</span> \n    reflections<span>.</span><span>getMethodParamNames</span><span>(</span><span>Method</span><span>.</span><span>class</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"_3-9-扫描方法调用情况\"> 3.9 扫描方法调用情况</h3>\n<div><pre><code><span>//MemberUsageScanner</span>\n<span>Set</span><span><span>&lt;</span><span>Member</span><span>></span></span> usages <span>=</span> \n    reflections<span>.</span><span>getMethodUsages</span><span>(</span><span>Method</span><span>.</span><span>class</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div>",
      "date_published": "2022-03-24T14:34:44.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Home",
      "url": "https://java.springlearn.cn/play/",
      "id": "https://java.springlearn.cn/play/",
      "content_html": "<h3 id=\"badge\"> Badge</h3>\n<ul>\n<li>\n<i>Not supported content</i>\n</li>\n<li>\n<i>Not supported content</i>\n</li>\n</ul>\n<CodeGroup>\n<CodeGroupItem title=\"yarn\">\n<div><pre><code><span>yarn</span> <span>add</span> -D vuepress-theme-hope\n</code></pre>\n<div><span>1</span><br></div></div></CodeGroupItem>\n<CodeGroupItem title=\"npm\" active>\n<div><pre><code><span>npm</span> i -D vuepress-theme-hope\n</code></pre>\n<div><span>1</span><br></div></div></CodeGroupItem>\n</CodeGroup>\n<div><div><br><div>&nbsp;</div><br><br><br><br><br></div><pre><code><span>public</span> <span>class</span> <span>Person</span><span>{</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span>args<span>)</span><span>{</span>\n\n    <span>}</span>\n<span>}</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div>",
      "date_published": "2021-12-21T05:46:37.000Z",
      "date_modified": "2022-01-04T14:58:20.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "切莫走火入魔",
      "url": "https://java.springlearn.cn/learn/%E8%AF%AF%E5%85%A5%E6%AD%A7%E9%80%94/",
      "id": "https://java.springlearn.cn/learn/%E8%AF%AF%E5%85%A5%E6%AD%A7%E9%80%94/",
      "content_html": "<p><img src=\"https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"为什么要坚持写博客\"> 为什么要坚持写博客?</h2>\n<ol>\n<li><code>避免眼高手低</code>，看起来全会，做起来全不对的情况。</li>\n<li>编程重要的是思想，<code>思路决定出路</code>，在思想的指引下。写的代码都只是工具，工具类的API没有必要都要记住。\n只要做到看到认识,再次遇到知道如何处理即可。<code>笔记的好处是下次再次遇到，只需要看看笔记就知道如何使用了</code>。</li>\n<li><code>记录内容</code>、<code>总结知识</code>、<code>分享成长</code>。</li>\n</ol>\n<h2 id=\"常见的技术误区\"> 常见的技术误区</h2>\n<ol>\n<li>技术是永远学不完的, 避免陷入到<code>技术旋涡中</code>，为了学技术而学技术。</li>\n<li>再厉害的技术，一定是了解决某些场景的问题而存在的。<code>重点是学习思想，参考其实现</code>。</li>\n<li>一通百通，一下看不懂的知识。要进行<code>拆解</code>，拆解成知识点。<code>逐个击破</code>，最终<code>为我所用</code>。</li>\n<li>it上高大上的名词都是唬人的，不要被名字给吓退了。</li>\n</ol>\n<h2 id=\"问题回答\"> 问题回答</h2>\n<h4 id=\"📢-1-这个网站内容都是你写的吗\"> 📢 1. 这个网站内容都是你写的吗?</h4>\n<p><code>绝大多数都是自己的学习笔记</code>。另在纯技术文章上，其实纯原创都是比较少的。为什么这么说呢？ 因为IT技术类的东西\n核心在于对源代码的学习, 只有开发源代码的人或者第一个吃螃蟹的人,可以说是纯原创。\n而后来者基本都是在学习了源代码的同时也吸收了大部分网络前辈们的文章观点，进行辨别的学习和思考后，\n总结的新的个人观点。这部分文章虽然业务原创，但是并不是那么的纯。<code>但是尽管不是那么的纯，也可能比纯的更加具有学习价值，因为他在前辈的总结的观点下，又增加了新的观点。</code></p>\n<p>本网站凡是收录的优秀文章,都会附带原文链接。<code>编码不易,必须尊重原创作者</code>。</p>\n<h4 id=\"📢-2-这个网站都是技术类文章吗\"> 📢 2. 这个网站都是技术类文章吗?</h4>\n<p><code>不是</code>，凡是优秀的文章，具有学习意义的。都可能存在。即是对自己知识面的补充，增加见识。也希望分享出来，让更多人看到这些优秀的文章。</p>\n<h4 id=\"📢-3-为什么有些链接都是404呢\"> 📢 3. 为什么有些链接都是404呢?</h4>\n<p>这个网站是小编利用业务时间进行自我学习，修炼和总结的乐园，因为时间没有那么充足，可能有些只写的标题。并没有补充文章内容。\n而这些没有补充内容的文章，都会<code>暂时</code>以404这种明确的<code>http</code> 暗号告诉你这篇文章，<code>已经被安排到学习日程上了</code>。接下来就会被安排上了。</p>\n<h4 id=\"📢-4-为什么有些文章是加密的呢\"> 📢 4. 为什么有些文章是加密的呢?</h4>\n<p>如果你有这个问题, 难道客官<code>你是想白嫖吗</code>? 加密方案是基于浏览器缓存实现的，所以只用关注一次，即所有文章都可以免费白嫖了。\n验证码是你我唯一的暗号，凭借这个暗号还有更多用处哦。</p>\n<h4 id=\"📢-5-个人博客是如何实现的\"> 📢 5. 个人博客是如何实现的?</h4>\n<p>首先这是基于 <code>vuepress</code> 实现的，服务部署也是免费的，如果你也想拥有可以。</p>\n<ul>\n<li><code>静态博客</code> <a href=\"https://java.springlearn.cn/learn/blog/vuepress/\" target=\"_blank\" rel=\"noopener noreferrer\">Vuepress</a></li>\n<li><code>免费部署</code> <a href=\"http://localhost:8080/learn/blog/vercel/\" target=\"_blank\" rel=\"noopener noreferrer\">Vercel</a></li>\n</ul>\n<h2 id=\"联系方式\"> 联系方式</h2>\n<p>微信: <code>lxchinesszz</code></p>\n<h2 id=\"意见反馈\"> 意见反馈</h2>\n<p>若本号内容有做得不到位的地方（比如：涉及版权或其他问题），请及时联系我进行整改。</p>\n",
      "image": "https://img.springlearn.cn/learn_c87a079fcea0d7893b03d4d57478bca7.png",
      "date_published": "2022-05-22T07:02:41.000Z",
      "date_modified": "2022-06-16T13:10:16.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    },
    {
      "title": "Home",
      "url": "https://java.springlearn.cn/",
      "id": "https://java.springlearn.cn/",
      "content_html": "<blockquote>\n<p>稻盛和夫说：你不会的东西，觉得难的东西，一定不要躲，先搞明白，后精湛，你就比别人优秀了。因为大部分人都不舍得花力气去钻研，自动被淘汰，所以你执着的努力，就占了大便宜。</p>\n</blockquote>\n<h2 id=\"\"> <i>Not supported content</i> <i>Not supported content</i>  <i>Not supported content</i> <i>Not supported content</i>  <i>Not supported content</i></h2>\n<Title title=\"必看专栏\" sub-title=\"读的书多了，自然就会写文章了 🚀\"/>\n<SeriesList/>\n<Title title=\"实战项目\" sub-title=\"🚴 滴滴滴，发车了，一起来搬砖。🧱\"/>\n<ProjectList/>\n<Title title=\"公众号\" sub-title=\"他们太强了，我卷不动了，随心月更，交个朋友\"/>\n<ul>\n<li><input type=\"checkbox\" checked=\"checked\" disabled=\"disabled\" id=\"task-item-0\"><label for=\"task-item-0\"> 关注公众号，留言: \"暗号\"，获取你我的独家记忆，并解锁全部文章，及更多福利。</label></li>\n<li><input type=\"checkbox\" checked=\"checked\" disabled=\"disabled\" id=\"task-item-1\"><label for=\"task-item-1\"> 最新文章会首发公众号，强烈推荐读者伙伴关注一波！</label></li>\n</ul>\n<div>\n<img src=\"https://img.springlearn.cn/learn_9ea02e620c7d483bfa2d310c1440d3e9.png\" width=\"40%\" style=\"text-align: center\">\n</div>\n<Title title=\"联系我\" sub-title=\"寻找志同道合，喜欢折腾的朋友。👬🏻\"/>\n<p><a href=\"https://muselink.cc/springlearn\" target=\"_blank\" rel=\"noopener noreferrer\">MuseLink数字名片！👉</a></p>\n<ul>\n<li><input type=\"checkbox\" checked=\"checked\" disabled=\"disabled\" id=\"task-item-2\"> 寻找喜欢折腾，志同道合的 <code>'新时代农民工'</code><label for=\"task-item-2\"> 寻找喜欢折腾，志同道合的 `'新时代农民工'` 朋友。</label></li>\n<li><input type=\"checkbox\" checked=\"checked\" disabled=\"disabled\" id=\"task-item-3\"><label for=\"task-item-3\"> 一起写java，一起写python，一起写js，一起写c++。 （ps: 一起逛海岛 🚗 ）</label></li>\n</ul>\n<p>天下代码一大抄，抄来抄去有提高，看你会抄不会抄。如果不会没关系, 联系我。我们一起来探讨。</p>\n",
      "date_published": "2021-12-21T05:46:37.000Z",
      "date_modified": "2023-02-08T03:23:43.000Z",
      "authors": [
        {
          "name": "西魏陶渊明"
        }
      ],
      "tags": []
    }
  ]
}