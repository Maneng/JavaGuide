---
breadcrumb: false
navbar: true
sidebar: true
pageInfo: false
contributor: true
editLink: true
updateTime: true
prev: true
next: true
comment: true
footer: true
backtotop: true
title: 第03篇:Mybatis核心类详细介绍
---

:::info 核心类介绍
前面我们知道Mybatis的解析原理,知道了在 `Configuration` 、`MapperBuilderAssistant` 出现了很多核心的类。
正是由这些类来实现了,Mybatis的核心功能。所以要想完全搞懂 Mybatis,这些类就必须要进行深入的研究，废话不多少，直接就开始吧。
:::

其实这里面的每个类要都能单独拆出来一篇进行详细说明，但是这里我们只取其精华，知道他的作用，及如何使用。和能借鉴的地方就可以了。

## 一、Configuration

|属性|解释|
|:--|:--|
|TypeAliasRegistry|key是一个别名,value是一个class对象|
|Properties variables|配置文件中占位符的变量配置|
|InterceptorChain interceptorChain|拦截链,用于拦截方法,实现插件|
|ObjectFactory objectFactory|对象实例化统一的工厂方法|
|ObjectWrapperFactory objectWrapperFactory| 扩展使用，允许用户自定义包装对象ObjectWrapper |
|ReflectorFactory reflectorFactory|反射工厂,用于生成一个反射信息对象|
|Environment environment|环境信息包含(事务管理器和数据源)|
|TypeHandlerRegistry typeHandlerRegistry|数据库返回数据类型转换成Java对象的处理器，或是Java数据类型转换jdbc数据类型的处理器|
|MapperRegistry mapperRegistry|Mapper生成的处理类,包含代理的逻辑|

## 1.1 TypeAliasRegistry

> key是别名,value是对应的Class<?>

这个在什么时候用的呢? 前面我们通过解析xml，发现很多的dtd约束，文件的值类型都是 CDATA 即 字符串。 但是这些字符串最终是要解析成指定的字节码的。
那么这个功能就交给 `TypeAliasRegistry`。 在实例化时候会把基本类型提前给注入进来。

```java 
    @Test
    public void TypeAliasRegistry() {
        TypeAliasRegistry typeAliasRegistry = new TypeAliasRegistry();
        System.out.println(typeAliasRegistry.resolveAlias("byte"));
    }
```

## 1.2 Properties

`Configuration` 中的变量信息。

## 1.3 InterceptorChain

内容较多,开单独的篇幅进行介绍; [第07篇:Mybatis的插件设计分析](https://java.springlearn.cn/learn/mybatis/%E6%8F%92%E4%BB%B6%E5%88%86%E6%9E%90/)

从名字就可以看到是一个拦截链; 主要是实现插件的功能。核心思路是, 通过拦截类的方法来实现插件。

MyBatis 允许你在映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包括：

- Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)
- ParameterHandler (getParameterObject, setParameters)
- ResultSetHandler (handleResultSets, handleOutputParameters)
- StatementHandler (prepare, parameterize, batch, update, query)

```java 
public class InterceptorChain {

  private final List<Interceptor> interceptors = new ArrayList<>();

  public Object pluginAll(Object target) {
    for (Interceptor interceptor : interceptors) {
      target = interceptor.plugin(target);
    }
    return target;
  }

  public void addInterceptor(Interceptor interceptor) {
    interceptors.add(interceptor);
  }

  public List<Interceptor> getInterceptors() {
    return Collections.unmodifiableList(interceptors);
  }

}

public interface Interceptor {

  Object intercept(Invocation invocation) throws Throwable;

  default Object plugin(Object target) {
    return Plugin.wrap(target, this);
  }

  default void setProperties(Properties properties) {
    // NOP
  }

}
```

## 1.4 ObjectFactory 对象工厂

在Mybatis中或者说是orm框架中, 使用到反射的地方较多。那么就一定会遇到实例化的问题。具体如何实例化。就是使用对象工厂。
之所以提供个工厂, 小编个人认为还是为了扩展使用。但是实际中一般不会扩展这个类。因为该有的功能默认的就已经具备了。

## 1.5 ObjectWrapperFactory 对象包装工厂

他的作用主要是提供外面的扩展，允许用户自己去创建包装对象。实际框架中不会用到这个对象。我们只要知道他的作用是什么行。 
我们重点说一下 ObjectWrapper 。

ObjectWrapper的主要作用是，提供统一的属性操作方法。主要在MetaObject被使用,如下。

```java 
public class MetaObject {

  private final Object originalObject;
  private final ObjectWrapper objectWrapper;
  private final ObjectFactory objectFactory;
  private final ObjectWrapperFactory objectWrapperFactory;
  private final ReflectorFactory reflectorFactory;

  private MetaObject(Object object, ObjectFactory objectFactory, ObjectWrapperFactory objectWrapperFactory, ReflectorFactory reflectorFactory) {
    this.originalObject = object;
    this.objectFactory = objectFactory;
    this.objectWrapperFactory = objectWrapperFactory;
    this.reflectorFactory = reflectorFactory;

    if (object instanceof ObjectWrapper) {
      this.objectWrapper = (ObjectWrapper) object;
    } else if (objectWrapperFactory.hasWrapperFor(object)) {
      this.objectWrapper = objectWrapperFactory.getWrapperFor(this, object);
    } else if (object instanceof Map) {
      this.objectWrapper = new MapWrapper(this, (Map) object);
    } else if (object instanceof Collection) {
      this.objectWrapper = new CollectionWrapper(this, (Collection) object);
    } else {
      this.objectWrapper = new BeanWrapper(this, object);
    }
  }
}  
```


我们看到普通的对象,被包装成 ObjectWrapper后就可以使用通用的API来获取和修改对象数值型,以及可以获取属性值的类型信息,如下面的例子。

![](https://img.springlearn.cn/blog/learn_1648542576000.png)

```java 
    @Test
    public void objectWrapper(){
        // 读取配置信息(为什么路径前不用加/,因为是相对路径。maven编译后的资源文件和class文件都是在一个包下,所以不用加/就是当前包目录)
        InputStream mapperInputStream = Thread.currentThread().getContextClassLoader().getResourceAsStream("mybatisConfig.xml");
        // 生成SqlSession工厂,SqlSession从名字上看就是,跟数据库交互的会话信息,负责将sql提交到数据库进行执行
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(mapperInputStream, "development");
        // 获取Mybatis配置信息
        Configuration configuration = sqlSessionFactory.getConfiguration();
        Map<String,String> map = new HashMap<>();
        map.put("name","孙悟空");
        MetaObject metaObject = MetaObject.forObject(map, configuration.getObjectFactory(), configuration.getObjectWrapperFactory(), configuration.getReflectorFactory());
        System.out.println(metaObject.getValue("name"));
        // 复制
        metaObject.setValue("age",18);
        // {name=孙悟空, age=18}
        System.out.println(map);

        TUser tUser = new TUser();
        tUser.setName("唐三藏");
        MetaObject tUserMetaObject = MetaObject.forObject(tUser, configuration.getObjectFactory(), configuration.getObjectWrapperFactory(), configuration.getReflectorFactory());
        // 唐三藏
        System.out.println(tUserMetaObject.getValue("name"));

        List<TUser> users = new ArrayList<>();
        users.add(tUser);
        MetaObject tUserMetaObjects = MetaObject.forObject(users, configuration.getObjectFactory(), configuration.getObjectWrapperFactory(), configuration.getReflectorFactory());
        tUserMetaObjects.add(new TUser());
        // [TUser(tokenId=null, uid=null, name=唐三藏), TUser(tokenId=null, uid=null, name=null)]
        System.out.println(tUserMetaObjects.getOriginalObject());
    }
```

## 1.6 ReflectorFactory 反射工厂

从名字看就是反射的工厂，主要是为了生成 Reflector 对象。Reflector 对反射的信息进行了缓存。用的时候直接从缓存中获取。

```java 
public interface ReflectorFactory {

  boolean isClassCacheEnabled();

  void setClassCacheEnabled(boolean classCacheEnabled);

  Reflector findForClass(Class<?> type);
}
```

## 1.7 Environment 环境

这里面的环境属性,是比较重要。因为他直接决定了你要跟那个数据库交互。以及事务如何处理。

```java 
public final class Environment {
  private final String id;
  private final TransactionFactory transactionFactory;
  private final DataSource dataSource;
}  
```

```java 
private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) {
    Transaction tx = null;
    try {
      final Environment environment = configuration.getEnvironment();
      final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);
      tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);
      final Executor executor = configuration.newExecutor(tx, execType);
      return new DefaultSqlSession(configuration, executor, autoCommit);
    } catch (Exception e) {
      closeTransaction(tx); // may have fetched a connection so lets call close()
      throw ExceptionFactory.wrapException("Error opening session.  Cause: " + e, e);
    } finally {
      ErrorContext.instance().reset();
    }
  }
```

## 1.8 TypeHandlerRegistry

TypeHandler + Registry, 从名字来看又是一个类型注册器用于反射使用。看来mybatis中用于反射的工具类是在太多了。那么TypeHandler究竟有什么用呢?
TypeHandler 是对Statement和ResultSet负责。
ResultSet 是从数据库获取的数据的载体，Statement 是准备向数据库提交数据的载体。TypeHandler 的作用就是
根据数据类型, 处理跟数据的输入和输出信息。看下面接口。

```java 
public interface TypeHandler<T> {

  void setParameter(PreparedStatement ps, int i, T parameter, JdbcType jdbcType) throws SQLException;

  /**
   * Gets the result.
   *
   * @param rs
   *          the rs
   * @param columnName
   *          Colunm name, when configuration <code>useColumnLabel</code> is <code>false</code>
   * @return the result
   * @throws SQLException
   *           the SQL exception
   */
  T getResult(ResultSet rs, String columnName) throws SQLException;

  T getResult(ResultSet rs, int columnIndex) throws SQLException;

  T getResult(CallableStatement cs, int columnIndex) throws SQLException;

}
```

这里举一个例子，比如name这个字段在数据库是varchar类型,但是java对象中name是一个Name对象。那么如何处理呢?
我们自定义一个处理器。
```java 
public class NameTypeHandler implements TypeHandler<Name> {

    @Override
    public void setParameter(PreparedStatement ps, int i, Name parameter, JdbcType jdbcType) throws SQLException {
        ps.setString(i, parameter.getFirstName() + "-" + parameter.getSurname());
    }

    @Override
    public Name getResult(ResultSet rs, String columnName) throws SQLException {
        String name = rs.getString(columnName);
        String[] split = name.split("-");
        return new Name(split[0], split[1]);
    }
}    
```

然后在配置文件中声明注册器,用于将java对象转换成jdbc数据库字段类型。同时也将数据库查询到的jdbc类型转换成java对象。

```xml 
    <configuration>
        <typeHandlers>
            <typeHandler handler="orm.example.dal.type.NameTypeHandler" javaType="orm.example.dal.model.Name"></typeHandler>
        </typeHandlers>
    </configuration>    
    <mapper>
         <insert id="insert" parameterType="orm.example.dal.model.T2User">
            <!--
              WARNING - @mbggenerated
              This element is automatically generated by MyBatis Generator, do not modify.
              This element was generated on Sun Mar 27 23:01:23 CST 2022.
            -->
            insert into T_USER (token_id, uid, name)
            values (#{tokenId,jdbcType=CHAR}, #{uid,jdbcType=INTEGER}, #{name,javaType=orm.example.dal.model.Name })
        </insert>
    </mapper>
```

我们执行下面代码,可以看到我们将数据类型转换成了jdbc存到了数据库，同时执行查询时候又将jdbc类型转换成了java对象。这就是它的作用。

```java {19}
    @Test
    public void test() {
        // 读取配置信息(为什么路径前不用加/,因为是相对路径。maven编译后的资源文件和class文件都是在一个包下,所以不用加/就是当前包目录)
        InputStream mapperInputStream = Thread.currentThread().getContextClassLoader().getResourceAsStream("mybatisConfig.xml");
        // 生成SqlSession工厂,SqlSession从名字上看就是,跟数据库交互的会话信息,负责将sql提交到数据库进行执行
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(mapperInputStream, "development");
        // 获取Mybatis配置信息
        Configuration configuration = sqlSessionFactory.getConfiguration();
        configuration.getTypeHandlerRegistry().register(new NameTypeHandler());
        // 参数: autoCommit,从名字上看就是是否自动提交事务
        SqlSession sqlSession = sqlSessionFactory.openSession(false);
        // 获取Mapper
        T2UserMapper mapper = configuration.getMapperRegistry().getMapper(T2UserMapper.class, sqlSession);
        T2User tUser = new T2User();
        Name name = new Name("孙","悟空");
        tUser.setName(name);
        tUser.setTokenId("西天取经");
        mapper.insert(tUser);
        // 获取插入的数据: T2User(tokenId=西天取经, uid=32, name=Name(surname=悟空, firstName=孙))
        System.out.println(mapper.selectByPrimaryKey("西天取经"));
        // 数据插入后，执行查询，然后回滚数据
        sqlSession.rollback();
    }
```

## 1.9 MapperRegistry

看到Registry又知道了，这货又是一个类似Map的工具类。肯定是跟Mapper有关系。下面代码关键在于13和17行。
Mybatis中获取Mapper对象都是从 MapperRegistry中获取的。

- line(13) `new MapperProxyFactory<>(type)` 接口生成代理对象
- line(17) `MapperAnnotationBuilder` 用于解析Mybatis支持的注解,并添加到 `Configuration`

这两个类比较重要我们开单独的篇幅进行说明。

```java {13,17}
public class MapperRegistry {

  private final Configuration config;
  private final Map<Class<?>, MapperProxyFactory<?>> knownMappers = new HashMap<>();
  
  public <T> void addMapper(Class<T> type) {
    if (type.isInterface()) {
      if (hasMapper(type)) {
        throw new BindingException("Type " + type + " is already known to the MapperRegistry.");
      }
      boolean loadCompleted = false;
      try {
        knownMappers.put(type, new MapperProxyFactory<>(type));
        // It's important that the type is added before the parser is run
        // otherwise the binding may automatically be attempted by the
        // mapper parser. If the type is already known, it won't try.
        MapperAnnotationBuilder parser = new MapperAnnotationBuilder(config, type);
        parser.parse();
        loadCompleted = true;
      } finally {
        if (!loadCompleted) {
          knownMappers.remove(type);
        }
      }
    }
  }
}
```


## 二、MapperBuilderAssistant

|属性|解释|
|:--|:--|
|MapperBuilderAssistant|Mapper构建辅助工具类(缓存配置)|
|CacheRefResolver|决定如何使用缓存|
|ParameterMapping|参数映射类|
|ResultMapResolver|返回值映射|
|Map<String, XNode> sqlFragments|sql片段|
|MappedStatement|Mapper方法的所有信息(出参，入参)|

## 2.1 MapperBuilderAssistant

Mapper构建工具类,下面小编列举了几个方法。可以看出来基本都是用于处理sql结果集向java对象转换使用，和对Mapper方法签名分析生成sql的工具。
下面我们一个一个来看看。

```java
public class MapperBuilderAssistant extends BaseBuilder {
    // 确定使用那个缓存
    public Cache useCacheRef(String namespace);
    // 生成2级缓存对象
    public Cache useNewCache(...);
    // 每个参数的信息
    public ParameterMapping buildParameterMapping();
    // 生成结构集
    public ResultMap addResultMap();
    // 鉴别器
    public Discriminator buildDiscriminator();
    // 生成Mapper签名
    public MappedStatement addMappedStatement();
    // 获取方言处理器
    public LanguageDriver getLanguageDriver(Class<? extends LanguageDriver> langClass);
}
```

### 2.1.1 Cache

### 2.1.2 ParameterMapping

### 2.1.3 ResultMap

### 2.1.4 Discriminator

### 2.1.5 LanguageDriver


## 2.2 CacheRefResolver

缓存

## 2.3 ParameterMapping

## 2.4 sqlFragments sql片段

## 2.5 MappedStatement

## 三、可以借鉴的知识点
